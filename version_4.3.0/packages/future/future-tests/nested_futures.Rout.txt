
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:13:16.291] plan(): Setting new future strategy stack:
[16:13:16.292] List of future strategies:
[16:13:16.292] 1. sequential:
[16:13:16.292]    - args: function (..., envir = parent.frame())
[16:13:16.292]    - tweaked: FALSE
[16:13:16.292]    - call: future::plan("sequential")
[16:13:16.304] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[16:13:16.355] plan(): Setting new future strategy stack:
[16:13:16.356] List of future strategies:
[16:13:16.356] 1. sequential:
[16:13:16.356]    - args: function (..., envir = parent.frame())
[16:13:16.356]    - tweaked: FALSE
[16:13:16.356]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.356] 2. sequential:
[16:13:16.356]    - args: function (..., envir = parent.frame())
[16:13:16.356]    - tweaked: FALSE
[16:13:16.356]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.367] plan(): nbrOfWorkers() = 1
[16:13:16.369] getGlobalsAndPackages() ...
[16:13:16.369] Searching for globals...
[16:13:16.391] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:16.391] Searching for globals ... DONE
[16:13:16.391] Resolving globals: FALSE
[16:13:16.393] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[16:13:16.393] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:16.393] - globals: [2] ‘nested’, ‘strategy2’
[16:13:16.394] - packages: [1] ‘future’
[16:13:16.394] getGlobalsAndPackages() ... DONE
[16:13:16.394] run() for ‘Future’ ...
[16:13:16.394] - state: ‘created’
[16:13:16.395] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.395] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.395]   - Field: ‘label’
[16:13:16.395]   - Field: ‘local’
[16:13:16.395]   - Field: ‘owner’
[16:13:16.395]   - Field: ‘envir’
[16:13:16.396]   - Field: ‘packages’
[16:13:16.396]   - Field: ‘gc’
[16:13:16.396]   - Field: ‘conditions’
[16:13:16.396]   - Field: ‘expr’
[16:13:16.396]   - Field: ‘uuid’
[16:13:16.396]   - Field: ‘seed’
[16:13:16.396]   - Field: ‘version’
[16:13:16.396]   - Field: ‘result’
[16:13:16.396]   - Field: ‘asynchronous’
[16:13:16.396]   - Field: ‘calls’
[16:13:16.396]   - Field: ‘globals’
[16:13:16.397]   - Field: ‘stdout’
[16:13:16.397]   - Field: ‘earlySignal’
[16:13:16.397]   - Field: ‘lazy’
[16:13:16.397]   - Field: ‘state’
[16:13:16.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.397] - Launch lazy future ...
[16:13:16.398] Packages needed by the future expression (n = 1): ‘future’
[16:13:16.398] Packages needed by future strategies (n = 1): ‘future’
[16:13:16.399] {
[16:13:16.399]     {
[16:13:16.399]         {
[16:13:16.399]             ...future.startTime <- base::Sys.time()
[16:13:16.399]             {
[16:13:16.399]                 {
[16:13:16.399]                   {
[16:13:16.399]                     {
[16:13:16.399]                       base::local({
[16:13:16.399]                         has_future <- base::requireNamespace("future", 
[16:13:16.399]                           quietly = TRUE)
[16:13:16.399]                         if (has_future) {
[16:13:16.399]                           ns <- base::getNamespace("future")
[16:13:16.399]                           version <- ns[[".package"]][["version"]]
[16:13:16.399]                           if (is.null(version)) 
[16:13:16.399]                             version <- utils::packageVersion("future")
[16:13:16.399]                         }
[16:13:16.399]                         else {
[16:13:16.399]                           version <- NULL
[16:13:16.399]                         }
[16:13:16.399]                         if (!has_future || version < "1.8.0") {
[16:13:16.399]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.399]                             "", base::R.version$version.string), 
[16:13:16.399]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.399]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.399]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.399]                               "release", "version")], collapse = " "), 
[16:13:16.399]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.399]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.399]                             info)
[16:13:16.399]                           info <- base::paste(info, collapse = "; ")
[16:13:16.399]                           if (!has_future) {
[16:13:16.399]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.399]                               info)
[16:13:16.399]                           }
[16:13:16.399]                           else {
[16:13:16.399]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.399]                               info, version)
[16:13:16.399]                           }
[16:13:16.399]                           base::stop(msg)
[16:13:16.399]                         }
[16:13:16.399]                       })
[16:13:16.399]                     }
[16:13:16.399]                     base::local({
[16:13:16.399]                       for (pkg in "future") {
[16:13:16.399]                         base::loadNamespace(pkg)
[16:13:16.399]                         base::library(pkg, character.only = TRUE)
[16:13:16.399]                       }
[16:13:16.399]                     })
[16:13:16.399]                   }
[16:13:16.399]                   options(future.plan = NULL)
[16:13:16.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.399]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:16.399]                   {
[16:13:16.399]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.399]                     if (!future$lazy) 
[16:13:16.399]                       future <- run(future)
[16:13:16.399]                     invisible(future)
[16:13:16.399]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.399]                 }
[16:13:16.399]                 ...future.workdir <- getwd()
[16:13:16.399]             }
[16:13:16.399]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.399]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.399]         }
[16:13:16.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.399]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.399]             base::names(...future.oldOptions))
[16:13:16.399]     }
[16:13:16.399]     if (FALSE) {
[16:13:16.399]     }
[16:13:16.399]     else {
[16:13:16.399]         if (TRUE) {
[16:13:16.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.399]                 open = "w")
[16:13:16.399]         }
[16:13:16.399]         else {
[16:13:16.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.399]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.399]         }
[16:13:16.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.399]             base::sink(type = "output", split = FALSE)
[16:13:16.399]             base::close(...future.stdout)
[16:13:16.399]         }, add = TRUE)
[16:13:16.399]     }
[16:13:16.399]     ...future.frame <- base::sys.nframe()
[16:13:16.399]     ...future.conditions <- base::list()
[16:13:16.399]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.399]     if (FALSE) {
[16:13:16.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.399]     }
[16:13:16.399]     ...future.result <- base::tryCatch({
[16:13:16.399]         base::withCallingHandlers({
[16:13:16.399]             ...future.value <- base::withVisible(base::local({
[16:13:16.399]                 a <- 1L
[16:13:16.399]                 plan_a <- unclass(future::plan("list"))
[16:13:16.399]                 nested_a <- nested[-1]
[16:13:16.399]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:16.399]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.399]                   strategy2))
[16:13:16.399]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:16.399]                   "init") <- NULL
[16:13:16.399]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:16.399]                   "init") <- NULL
[16:13:16.399]                 stopifnot(all.equal(plan_a, nested_a))
[16:13:16.399]                 y %<-% {
[16:13:16.399]                   b <- 2L
[16:13:16.399]                   plan_b <- future::plan("list")
[16:13:16.399]                   nested_b <- nested_a[-1]
[16:13:16.399]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:16.399]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.399]                     "sequential"))
[16:13:16.399]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:16.399]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:16.399]                 }
[16:13:16.399]                 y
[16:13:16.399]             }))
[16:13:16.399]             future::FutureResult(value = ...future.value$value, 
[16:13:16.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.399]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.399]                     ...future.globalenv.names))
[16:13:16.399]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.399]         }, condition = base::local({
[16:13:16.399]             c <- base::c
[16:13:16.399]             inherits <- base::inherits
[16:13:16.399]             invokeRestart <- base::invokeRestart
[16:13:16.399]             length <- base::length
[16:13:16.399]             list <- base::list
[16:13:16.399]             seq.int <- base::seq.int
[16:13:16.399]             signalCondition <- base::signalCondition
[16:13:16.399]             sys.calls <- base::sys.calls
[16:13:16.399]             `[[` <- base::`[[`
[16:13:16.399]             `+` <- base::`+`
[16:13:16.399]             `<<-` <- base::`<<-`
[16:13:16.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.399]                   3L)]
[16:13:16.399]             }
[16:13:16.399]             function(cond) {
[16:13:16.399]                 is_error <- inherits(cond, "error")
[16:13:16.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.399]                   NULL)
[16:13:16.399]                 if (is_error) {
[16:13:16.399]                   sessionInformation <- function() {
[16:13:16.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.399]                       search = base::search(), system = base::Sys.info())
[16:13:16.399]                   }
[16:13:16.399]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.399]                     cond$call), session = sessionInformation(), 
[16:13:16.399]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.399]                   signalCondition(cond)
[16:13:16.399]                 }
[16:13:16.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.399]                 "immediateCondition"))) {
[16:13:16.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.399]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.399]                   if (TRUE && !signal) {
[16:13:16.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.399]                     {
[16:13:16.399]                       inherits <- base::inherits
[16:13:16.399]                       invokeRestart <- base::invokeRestart
[16:13:16.399]                       is.null <- base::is.null
[16:13:16.399]                       muffled <- FALSE
[16:13:16.399]                       if (inherits(cond, "message")) {
[16:13:16.399]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.399]                         if (muffled) 
[16:13:16.399]                           invokeRestart("muffleMessage")
[16:13:16.399]                       }
[16:13:16.399]                       else if (inherits(cond, "warning")) {
[16:13:16.399]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.399]                         if (muffled) 
[16:13:16.399]                           invokeRestart("muffleWarning")
[16:13:16.399]                       }
[16:13:16.399]                       else if (inherits(cond, "condition")) {
[16:13:16.399]                         if (!is.null(pattern)) {
[16:13:16.399]                           computeRestarts <- base::computeRestarts
[16:13:16.399]                           grepl <- base::grepl
[16:13:16.399]                           restarts <- computeRestarts(cond)
[16:13:16.399]                           for (restart in restarts) {
[16:13:16.399]                             name <- restart$name
[16:13:16.399]                             if (is.null(name)) 
[16:13:16.399]                               next
[16:13:16.399]                             if (!grepl(pattern, name)) 
[16:13:16.399]                               next
[16:13:16.399]                             invokeRestart(restart)
[16:13:16.399]                             muffled <- TRUE
[16:13:16.399]                             break
[16:13:16.399]                           }
[16:13:16.399]                         }
[16:13:16.399]                       }
[16:13:16.399]                       invisible(muffled)
[16:13:16.399]                     }
[16:13:16.399]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.399]                   }
[16:13:16.399]                 }
[16:13:16.399]                 else {
[16:13:16.399]                   if (TRUE) {
[16:13:16.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.399]                     {
[16:13:16.399]                       inherits <- base::inherits
[16:13:16.399]                       invokeRestart <- base::invokeRestart
[16:13:16.399]                       is.null <- base::is.null
[16:13:16.399]                       muffled <- FALSE
[16:13:16.399]                       if (inherits(cond, "message")) {
[16:13:16.399]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.399]                         if (muffled) 
[16:13:16.399]                           invokeRestart("muffleMessage")
[16:13:16.399]                       }
[16:13:16.399]                       else if (inherits(cond, "warning")) {
[16:13:16.399]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.399]                         if (muffled) 
[16:13:16.399]                           invokeRestart("muffleWarning")
[16:13:16.399]                       }
[16:13:16.399]                       else if (inherits(cond, "condition")) {
[16:13:16.399]                         if (!is.null(pattern)) {
[16:13:16.399]                           computeRestarts <- base::computeRestarts
[16:13:16.399]                           grepl <- base::grepl
[16:13:16.399]                           restarts <- computeRestarts(cond)
[16:13:16.399]                           for (restart in restarts) {
[16:13:16.399]                             name <- restart$name
[16:13:16.399]                             if (is.null(name)) 
[16:13:16.399]                               next
[16:13:16.399]                             if (!grepl(pattern, name)) 
[16:13:16.399]                               next
[16:13:16.399]                             invokeRestart(restart)
[16:13:16.399]                             muffled <- TRUE
[16:13:16.399]                             break
[16:13:16.399]                           }
[16:13:16.399]                         }
[16:13:16.399]                       }
[16:13:16.399]                       invisible(muffled)
[16:13:16.399]                     }
[16:13:16.399]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.399]                   }
[16:13:16.399]                 }
[16:13:16.399]             }
[16:13:16.399]         }))
[16:13:16.399]     }, error = function(ex) {
[16:13:16.399]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.399]                 ...future.rng), started = ...future.startTime, 
[16:13:16.399]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.399]             version = "1.8"), class = "FutureResult")
[16:13:16.399]     }, finally = {
[16:13:16.399]         if (!identical(...future.workdir, getwd())) 
[16:13:16.399]             setwd(...future.workdir)
[16:13:16.399]         {
[16:13:16.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.399]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.399]             }
[16:13:16.399]             base::options(...future.oldOptions)
[16:13:16.399]             if (.Platform$OS.type == "windows") {
[16:13:16.399]                 old_names <- names(...future.oldEnvVars)
[16:13:16.399]                 envs <- base::Sys.getenv()
[16:13:16.399]                 names <- names(envs)
[16:13:16.399]                 common <- intersect(names, old_names)
[16:13:16.399]                 added <- setdiff(names, old_names)
[16:13:16.399]                 removed <- setdiff(old_names, names)
[16:13:16.399]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.399]                   envs[common]]
[16:13:16.399]                 NAMES <- toupper(changed)
[16:13:16.399]                 args <- list()
[16:13:16.399]                 for (kk in seq_along(NAMES)) {
[16:13:16.399]                   name <- changed[[kk]]
[16:13:16.399]                   NAME <- NAMES[[kk]]
[16:13:16.399]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.399]                     next
[16:13:16.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.399]                 }
[16:13:16.399]                 NAMES <- toupper(added)
[16:13:16.399]                 for (kk in seq_along(NAMES)) {
[16:13:16.399]                   name <- added[[kk]]
[16:13:16.399]                   NAME <- NAMES[[kk]]
[16:13:16.399]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.399]                     next
[16:13:16.399]                   args[[name]] <- ""
[16:13:16.399]                 }
[16:13:16.399]                 NAMES <- toupper(removed)
[16:13:16.399]                 for (kk in seq_along(NAMES)) {
[16:13:16.399]                   name <- removed[[kk]]
[16:13:16.399]                   NAME <- NAMES[[kk]]
[16:13:16.399]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.399]                     next
[16:13:16.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.399]                 }
[16:13:16.399]                 if (length(args) > 0) 
[16:13:16.399]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.399]             }
[16:13:16.399]             else {
[16:13:16.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.399]             }
[16:13:16.399]             {
[16:13:16.399]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.399]                   0L) {
[16:13:16.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.399]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.399]                   base::options(opts)
[16:13:16.399]                 }
[16:13:16.399]                 {
[16:13:16.399]                   {
[16:13:16.399]                     NULL
[16:13:16.399]                     RNGkind("Mersenne-Twister")
[16:13:16.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.399]                       inherits = FALSE)
[16:13:16.399]                   }
[16:13:16.399]                   options(future.plan = NULL)
[16:13:16.399]                   if (is.na(NA_character_)) 
[16:13:16.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.399]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:13:16.399]                   {
[16:13:16.399]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.399]                     if (!future$lazy) 
[16:13:16.399]                       future <- run(future)
[16:13:16.399]                     invisible(future)
[16:13:16.399]                   }, b = function (..., envir = parent.frame()) 
[16:13:16.399]                   {
[16:13:16.399]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.399]                     if (!future$lazy) 
[16:13:16.399]                       future <- run(future)
[16:13:16.399]                     invisible(future)
[16:13:16.399]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.399]                 }
[16:13:16.399]             }
[16:13:16.399]         }
[16:13:16.399]     })
[16:13:16.399]     if (TRUE) {
[16:13:16.399]         base::sink(type = "output", split = FALSE)
[16:13:16.399]         if (TRUE) {
[16:13:16.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.399]         }
[16:13:16.399]         else {
[16:13:16.399]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.399]         }
[16:13:16.399]         base::close(...future.stdout)
[16:13:16.399]         ...future.stdout <- NULL
[16:13:16.399]     }
[16:13:16.399]     ...future.result$conditions <- ...future.conditions
[16:13:16.399]     ...future.result$finished <- base::Sys.time()
[16:13:16.399]     ...future.result
[16:13:16.399] }
[16:13:16.401] assign_globals() ...
[16:13:16.401] List of 2
[16:13:16.401]  $ nested   :List of 2
[16:13:16.401]   ..$ a:function (..., envir = parent.frame())  
[16:13:16.401]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:16.401]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.401]   ..$ b:function (..., envir = parent.frame())  
[16:13:16.401]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:16.401]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.401]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:16.401]  $ strategy2: chr "sequential"
[16:13:16.401]  - attr(*, "where")=List of 2
[16:13:16.401]   ..$ nested   :<environment: R_EmptyEnv> 
[16:13:16.401]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:13:16.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.401]  - attr(*, "resolved")= logi FALSE
[16:13:16.401]  - attr(*, "total_size")= num 23144
[16:13:16.401]  - attr(*, "already-done")= logi TRUE
[16:13:16.408] - copied ‘nested’ to environment
[16:13:16.408] - copied ‘strategy2’ to environment
[16:13:16.408] assign_globals() ... done
[16:13:16.408] plan(): Setting new future strategy stack:
[16:13:16.408] List of future strategies:
[16:13:16.408] 1. sequential:
[16:13:16.408]    - args: function (..., envir = parent.frame())
[16:13:16.408]    - tweaked: FALSE
[16:13:16.408]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.409] plan(): nbrOfWorkers() = 1
[16:13:16.446] plan(): Setting new future strategy stack:
[16:13:16.446] List of future strategies:
[16:13:16.446] 1. sequential:
[16:13:16.446]    - args: function (..., envir = parent.frame())
[16:13:16.446]    - tweaked: FALSE
[16:13:16.446]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.446] 2. sequential:
[16:13:16.446]    - args: function (..., envir = parent.frame())
[16:13:16.446]    - tweaked: FALSE
[16:13:16.446]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.446] plan(): nbrOfWorkers() = 1
[16:13:16.447] SequentialFuture started (and completed)
[16:13:16.447] signalConditions() ...
[16:13:16.447]  - include = ‘immediateCondition’
[16:13:16.447]  - exclude = 
[16:13:16.447]  - resignal = FALSE
[16:13:16.447]  - Number of conditions: 54
[16:13:16.447] signalConditions() ... done
[16:13:16.447] - Launch lazy future ... done
[16:13:16.447] run() for ‘SequentialFuture’ ... done
[16:13:16.448] signalConditions() ...
[16:13:16.448]  - include = ‘immediateCondition’
[16:13:16.448]  - exclude = 
[16:13:16.448]  - resignal = FALSE
[16:13:16.448]  - Number of conditions: 54
[16:13:16.448] signalConditions() ... done
[16:13:16.448] Future state: ‘finished’
[16:13:16.448] signalConditions() ...
[16:13:16.448]  - include = ‘condition’
[16:13:16.448]  - exclude = ‘immediateCondition’
[16:13:16.449]  - resignal = TRUE
[16:13:16.449]  - Number of conditions: 54
[16:13:16.449]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.410] getGlobalsAndPackages() ...
[16:13:16.449]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.410] Searching for globals...
[16:13:16.449]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.430] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:13:16.449]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.430] Searching for globals ... DONE
[16:13:16.449]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.430] Resolving globals: FALSE
[16:13:16.449]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.431] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[16:13:16.449]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.431] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:13:16.450]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.431] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:13:16.450]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.431] 
[16:13:16.450]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.432] getGlobalsAndPackages() ... DONE
[16:13:16.450]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.432] run() for ‘Future’ ...
[16:13:16.450]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.432] - state: ‘created’
[16:13:16.450]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.432] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.450]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.450]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.451]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘label’
[16:13:16.451]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘local’
[16:13:16.451]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘owner’
[16:13:16.451]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘envir’
[16:13:16.451]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘packages’
[16:13:16.451]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘gc’
[16:13:16.451]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘conditions’
[16:13:16.451]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘expr’
[16:13:16.452]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.433]   - Field: ‘uuid’
[16:13:16.452]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘seed’
[16:13:16.452]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘version’
[16:13:16.452]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘result’
[16:13:16.452]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘asynchronous’
[16:13:16.452]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘calls’
[16:13:16.452]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘globals’
[16:13:16.453]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘stdout’
[16:13:16.453]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘earlySignal’
[16:13:16.453]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.434]   - Field: ‘lazy’
[16:13:16.453]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.435]   - Field: ‘state’
[16:13:16.453]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.453]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.435] - Launch lazy future ...
[16:13:16.453]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.435] Packages needed by the future expression (n = 0): <none>
[16:13:16.453]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.435] Packages needed by future strategies (n = 0): <none>
[16:13:16.454]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.435] {
[16:13:16.435]     {
[16:13:16.435]         {
[16:13:16.435]             ...future.startTime <- base::Sys.time()
[16:13:16.435]             {
[16:13:16.435]                 {
[16:13:16.435]                   {
[16:13:16.435]                     base::local({
[16:13:16.435]                       has_future <- base::requireNamespace("future", 
[16:13:16.435]                         quietly = TRUE)
[16:13:16.435]                       if (has_future) {
[16:13:16.435]                         ns <- base::getNamespace("future")
[16:13:16.435]                         version <- ns[[".package"]][["version"]]
[16:13:16.435]                         if (is.null(version)) 
[16:13:16.435]                           version <- utils::packageVersion("future")
[16:13:16.435]                       }
[16:13:16.435]                       else {
[16:13:16.435]                         version <- NULL
[16:13:16.435]                       }
[16:13:16.435]                       if (!has_future || version < "1.8.0") {
[16:13:16.435]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.435]                           "", base::R.version$version.string), 
[16:13:16.435]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:16.435]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.435]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.435]                             "release", "version")], collapse = " "), 
[16:13:16.435]                           hostname = base::Sys.info()[["nodename"]])
[16:13:16.435]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.435]                           info)
[16:13:16.435]                         info <- base::paste(info, collapse = "; ")
[16:13:16.435]                         if (!has_future) {
[16:13:16.435]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.435]                             info)
[16:13:16.435]                         }
[16:13:16.435]                         else {
[16:13:16.435]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.435]                             info, version)
[16:13:16.435]                         }
[16:13:16.435]                         base::stop(msg)
[16:13:16.435]                       }
[16:13:16.435]                     })
[16:13:16.435]                   }
[16:13:16.435]                   options(future.plan = NULL)
[16:13:16.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:16.435]                 }
[16:13:16.435]                 ...future.workdir <- getwd()
[16:13:16.435]             }
[16:13:16.435]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.435]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.435]         }
[16:13:16.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.435]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.435]             base::names(...future.oldOptions))
[16:13:16.435]     }
[16:13:16.435]     if (FALSE) {
[16:13:16.435]     }
[16:13:16.435]     else {
[16:13:16.435]         if (TRUE) {
[16:13:16.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.435]                 open = "w")
[16:13:16.435]         }
[16:13:16.435]         else {
[16:13:16.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.435]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.435]         }
[16:13:16.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.435]             base::sink(type = "output", split = FALSE)
[16:13:16.435]             base::close(...future.stdout)
[16:13:16.435]         }, add = TRUE)
[16:13:16.435]     }
[16:13:16.435]     ...future.frame <- base::sys.nframe()
[16:13:16.435]     ...future.conditions <- base::list()
[16:13:16.435]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.435]     if (FALSE) {
[16:13:16.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.435]     }
[16:13:16.435]     ...future.result <- base::tryCatch({
[16:13:16.435]         base::withCallingHandlers({
[16:13:16.435]             ...future.value <- base::withVisible(base::local({
[16:13:16.435]                 b <- 2L
[16:13:16.435]                 plan_b <- future::plan("list")
[16:13:16.435]                 nested_b <- nested_a[-1]
[16:13:16.435]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:16.435]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.435]                   "sequential"))
[16:13:16.435]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:16.435]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:16.435]             }))
[16:13:16.435]             future::FutureResult(value = ...future.value$value, 
[16:13:16.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.435]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.435]                     ...future.globalenv.names))
[16:13:16.435]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.435]         }, condition = base::local({
[16:13:16.435]             c <- base::c
[16:13:16.435]             inherits <- base::inherits
[16:13:16.435]             invokeRestart <- base::invokeRestart
[16:13:16.435]             length <- base::length
[16:13:16.435]             list <- base::list
[16:13:16.435]             seq.int <- base::seq.int
[16:13:16.435]             signalCondition <- base::signalCondition
[16:13:16.435]             sys.calls <- base::sys.calls
[16:13:16.435]             `[[` <- base::`[[`
[16:13:16.435]             `+` <- base::`+`
[16:13:16.435]             `<<-` <- base::`<<-`
[16:13:16.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.435]                   3L)]
[16:13:16.435]             }
[16:13:16.435]             function(cond) {
[16:13:16.435]                 is_error <- inherits(cond, "error")
[16:13:16.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.435]                   NULL)
[16:13:16.435]                 if (is_error) {
[16:13:16.435]                   sessionInformation <- function() {
[16:13:16.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.435]                       search = base::search(), system = base::Sys.info())
[16:13:16.435]                   }
[16:13:16.435]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.435]                     cond$call), session = sessionInformation(), 
[16:13:16.435]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.435]                   signalCondition(cond)
[16:13:16.435]                 }
[16:13:16.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.435]                 "immediateCondition"))) {
[16:13:16.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.435]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.435]                   if (TRUE && !signal) {
[16:13:16.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.435]                     {
[16:13:16.435]                       inherits <- base::inherits
[16:13:16.435]                       invokeRestart <- base::invokeRestart
[16:13:16.435]                       is.null <- base::is.null
[16:13:16.435]                       muffled <- FALSE
[16:13:16.435]                       if (inherits(cond, "message")) {
[16:13:16.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.435]                         if (muffled) 
[16:13:16.435]                           invokeRestart("muffleMessage")
[16:13:16.435]                       }
[16:13:16.435]                       else if (inherits(cond, "warning")) {
[16:13:16.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.435]                         if (muffled) 
[16:13:16.435]                           invokeRestart("muffleWarning")
[16:13:16.435]                       }
[16:13:16.435]                       else if (inherits(cond, "condition")) {
[16:13:16.435]                         if (!is.null(pattern)) {
[16:13:16.435]                           computeRestarts <- base::computeRestarts
[16:13:16.435]                           grepl <- base::grepl
[16:13:16.435]                           restarts <- computeRestarts(cond)
[16:13:16.435]                           for (restart in restarts) {
[16:13:16.435]                             name <- restart$name
[16:13:16.435]                             if (is.null(name)) 
[16:13:16.435]                               next
[16:13:16.435]                             if (!grepl(pattern, name)) 
[16:13:16.435]                               next
[16:13:16.435]                             invokeRestart(restart)
[16:13:16.435]                             muffled <- TRUE
[16:13:16.435]                             break
[16:13:16.435]                           }
[16:13:16.435]                         }
[16:13:16.435]                       }
[16:13:16.435]                       invisible(muffled)
[16:13:16.435]                     }
[16:13:16.435]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.435]                   }
[16:13:16.435]                 }
[16:13:16.435]                 else {
[16:13:16.435]                   if (TRUE) {
[16:13:16.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.435]                     {
[16:13:16.435]                       inherits <- base::inherits
[16:13:16.435]                       invokeRestart <- base::invokeRestart
[16:13:16.435]                       is.null <- base::is.null
[16:13:16.435]                       muffled <- FALSE
[16:13:16.435]                       if (inherits(cond, "message")) {
[16:13:16.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.435]                         if (muffled) 
[16:13:16.435]                           invokeRestart("muffleMessage")
[16:13:16.435]                       }
[16:13:16.435]                       else if (inherits(cond, "warning")) {
[16:13:16.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.435]                         if (muffled) 
[16:13:16.435]                           invokeRestart("muffleWarning")
[16:13:16.435]                       }
[16:13:16.435]                       else if (inherits(cond, "condition")) {
[16:13:16.435]                         if (!is.null(pattern)) {
[16:13:16.435]                           computeRestarts <- base::computeRestarts
[16:13:16.435]                           grepl <- base::grepl
[16:13:16.435]                           restarts <- computeRestarts(cond)
[16:13:16.435]                           for (restart in restarts) {
[16:13:16.435]                             name <- restart$name
[16:13:16.435]                             if (is.null(name)) 
[16:13:16.435]                               next
[16:13:16.435]                             if (!grepl(pattern, name)) 
[16:13:16.435]                               next
[16:13:16.435]                             invokeRestart(restart)
[16:13:16.435]                             muffled <- TRUE
[16:13:16.435]                             break
[16:13:16.435]                           }
[16:13:16.435]                         }
[16:13:16.435]                       }
[16:13:16.435]                       invisible(muffled)
[16:13:16.435]                     }
[16:13:16.435]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.435]                   }
[16:13:16.435]                 }
[16:13:16.435]             }
[16:13:16.435]         }))
[16:13:16.435]     }, error = function(ex) {
[16:13:16.435]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.435]                 ...future.rng), started = ...future.startTime, 
[16:13:16.435]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.435]             version = "1.8"), class = "FutureResult")
[16:13:16.435]     }, finally = {
[16:13:16.435]         if (!identical(...future.workdir, getwd())) 
[16:13:16.435]             setwd(...future.workdir)
[16:13:16.435]         {
[16:13:16.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.435]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.435]             }
[16:13:16.435]             base::options(...future.oldOptions)
[16:13:16.435]             if (.Platform$OS.type == "windows") {
[16:13:16.435]                 old_names <- names(...future.oldEnvVars)
[16:13:16.435]                 envs <- base::Sys.getenv()
[16:13:16.435]                 names <- names(envs)
[16:13:16.435]                 common <- intersect(names, old_names)
[16:13:16.435]                 added <- setdiff(names, old_names)
[16:13:16.435]                 removed <- setdiff(old_names, names)
[16:13:16.435]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.435]                   envs[common]]
[16:13:16.435]                 NAMES <- toupper(changed)
[16:13:16.435]                 args <- list()
[16:13:16.435]                 for (kk in seq_along(NAMES)) {
[16:13:16.435]                   name <- changed[[kk]]
[16:13:16.435]                   NAME <- NAMES[[kk]]
[16:13:16.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.435]                     next
[16:13:16.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.435]                 }
[16:13:16.435]                 NAMES <- toupper(added)
[16:13:16.435]                 for (kk in seq_along(NAMES)) {
[16:13:16.435]                   name <- added[[kk]]
[16:13:16.435]                   NAME <- NAMES[[kk]]
[16:13:16.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.435]                     next
[16:13:16.435]                   args[[name]] <- ""
[16:13:16.435]                 }
[16:13:16.435]                 NAMES <- toupper(removed)
[16:13:16.435]                 for (kk in seq_along(NAMES)) {
[16:13:16.435]                   name <- removed[[kk]]
[16:13:16.435]                   NAME <- NAMES[[kk]]
[16:13:16.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.435]                     next
[16:13:16.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.435]                 }
[16:13:16.435]                 if (length(args) > 0) 
[16:13:16.435]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.435]             }
[16:13:16.435]             else {
[16:13:16.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.435]             }
[16:13:16.435]             {
[16:13:16.435]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.435]                   0L) {
[16:13:16.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.435]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.435]                   base::options(opts)
[16:13:16.435]                 }
[16:13:16.435]                 {
[16:13:16.435]                   {
[16:13:16.435]                     NULL
[16:13:16.435]                     RNGkind("Mersenne-Twister")
[16:13:16.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.435]                       inherits = FALSE)
[16:13:16.435]                   }
[16:13:16.435]                   options(future.plan = NULL)
[16:13:16.435]                   if (is.na(NA_character_)) 
[16:13:16.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.435]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:16.435]                   {
[16:13:16.435]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.435]                     if (!future$lazy) 
[16:13:16.435]                       future <- run(future)
[16:13:16.435]                     invisible(future)
[16:13:16.435]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.435]                 }
[16:13:16.435]             }
[16:13:16.435]         }
[16:13:16.435]     })
[16:13:16.435]     if (TRUE) {
[16:13:16.435]         base::sink(type = "output", split = FALSE)
[16:13:16.435]         if (TRUE) {
[16:13:16.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.435]         }
[16:13:16.435]         else {
[16:13:16.435]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.435]         }
[16:13:16.435]         base::close(...future.stdout)
[16:13:16.435]         ...future.stdout <- NULL
[16:13:16.435]     }
[16:13:16.435]     ...future.result$conditions <- ...future.conditions
[16:13:16.435]     ...future.result$finished <- base::Sys.time()
[16:13:16.435]     ...future.result
[16:13:16.435] }
[16:13:16.454]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.437] assign_globals() ...
[16:13:16.455]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.437] List of 3
[16:13:16.437]  $ nested_a:List of 1
[16:13:16.437]   ..$ b:function (..., envir = parent.frame())  
[16:13:16.437]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:16.437]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.437]  $ a       : int 1
[16:13:16.437]  $ plan_a  :List of 1
[16:13:16.437]   ..$ b:function (..., envir = parent.frame())  
[16:13:16.437]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:16.437]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.437]  - attr(*, "where")=List of 3
[16:13:16.437]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:13:16.437]   ..$ a       :<environment: R_EmptyEnv> 
[16:13:16.437]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:13:16.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.437]  - attr(*, "resolved")= logi FALSE
[16:13:16.437]  - attr(*, "total_size")= num 23080
[16:13:16.437]  - attr(*, "already-done")= logi TRUE
[16:13:16.455]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.442] - copied ‘nested_a’ to environment
[16:13:16.455]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.442] - copied ‘a’ to environment
[16:13:16.455]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.442] - copied ‘plan_a’ to environment
[16:13:16.455]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.442] assign_globals() ... done
[16:13:16.456]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.442] plan(): Setting new future strategy stack:
[16:13:16.456]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.442] List of future strategies:
[16:13:16.442] 1. sequential:
[16:13:16.442]    - args: function (..., envir = parent.frame())
[16:13:16.442]    - tweaked: FALSE
[16:13:16.442]    - call: NULL
[16:13:16.456]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.443] plan(): nbrOfWorkers() = 1
[16:13:16.456]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.444] plan(): Setting new future strategy stack:
[16:13:16.456]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.444] List of future strategies:
[16:13:16.444] 1. sequential:
[16:13:16.444]    - args: function (..., envir = parent.frame())
[16:13:16.444]    - tweaked: FALSE
[16:13:16.444]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.456]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.444] plan(): nbrOfWorkers() = 1
[16:13:16.456]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.445] SequentialFuture started (and completed)
[16:13:16.456]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.445] - Launch lazy future ... done
[16:13:16.457]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.445] run() for ‘SequentialFuture’ ... done
[16:13:16.457] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:16.462] getGlobalsAndPackages() ...
[16:13:16.462] Searching for globals...
[16:13:16.463] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:16.463] Searching for globals ... DONE
[16:13:16.463] Resolving globals: FALSE
[16:13:16.464] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:16.464] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:16.464] - globals: [1] ‘data’
[16:13:16.464] - packages: [1] ‘future’
[16:13:16.464] getGlobalsAndPackages() ... DONE
[16:13:16.464] run() for ‘Future’ ...
[16:13:16.465] - state: ‘created’
[16:13:16.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.465]   - Field: ‘label’
[16:13:16.465]   - Field: ‘local’
[16:13:16.465]   - Field: ‘owner’
[16:13:16.465]   - Field: ‘envir’
[16:13:16.465]   - Field: ‘packages’
[16:13:16.466]   - Field: ‘gc’
[16:13:16.466]   - Field: ‘conditions’
[16:13:16.466]   - Field: ‘expr’
[16:13:16.466]   - Field: ‘uuid’
[16:13:16.466]   - Field: ‘seed’
[16:13:16.466]   - Field: ‘version’
[16:13:16.466]   - Field: ‘result’
[16:13:16.466]   - Field: ‘asynchronous’
[16:13:16.466]   - Field: ‘calls’
[16:13:16.466]   - Field: ‘globals’
[16:13:16.466]   - Field: ‘stdout’
[16:13:16.466]   - Field: ‘earlySignal’
[16:13:16.467]   - Field: ‘lazy’
[16:13:16.467]   - Field: ‘state’
[16:13:16.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.467] - Launch lazy future ...
[16:13:16.467] Packages needed by the future expression (n = 1): ‘future’
[16:13:16.467] Packages needed by future strategies (n = 1): ‘future’
[16:13:16.468] {
[16:13:16.468]     {
[16:13:16.468]         {
[16:13:16.468]             ...future.startTime <- base::Sys.time()
[16:13:16.468]             {
[16:13:16.468]                 {
[16:13:16.468]                   {
[16:13:16.468]                     {
[16:13:16.468]                       base::local({
[16:13:16.468]                         has_future <- base::requireNamespace("future", 
[16:13:16.468]                           quietly = TRUE)
[16:13:16.468]                         if (has_future) {
[16:13:16.468]                           ns <- base::getNamespace("future")
[16:13:16.468]                           version <- ns[[".package"]][["version"]]
[16:13:16.468]                           if (is.null(version)) 
[16:13:16.468]                             version <- utils::packageVersion("future")
[16:13:16.468]                         }
[16:13:16.468]                         else {
[16:13:16.468]                           version <- NULL
[16:13:16.468]                         }
[16:13:16.468]                         if (!has_future || version < "1.8.0") {
[16:13:16.468]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.468]                             "", base::R.version$version.string), 
[16:13:16.468]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.468]                               "release", "version")], collapse = " "), 
[16:13:16.468]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.468]                             info)
[16:13:16.468]                           info <- base::paste(info, collapse = "; ")
[16:13:16.468]                           if (!has_future) {
[16:13:16.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.468]                               info)
[16:13:16.468]                           }
[16:13:16.468]                           else {
[16:13:16.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.468]                               info, version)
[16:13:16.468]                           }
[16:13:16.468]                           base::stop(msg)
[16:13:16.468]                         }
[16:13:16.468]                       })
[16:13:16.468]                     }
[16:13:16.468]                     base::local({
[16:13:16.468]                       for (pkg in "future") {
[16:13:16.468]                         base::loadNamespace(pkg)
[16:13:16.468]                         base::library(pkg, character.only = TRUE)
[16:13:16.468]                       }
[16:13:16.468]                     })
[16:13:16.468]                   }
[16:13:16.468]                   options(future.plan = NULL)
[16:13:16.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.468]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:16.468]                   {
[16:13:16.468]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.468]                     if (!future$lazy) 
[16:13:16.468]                       future <- run(future)
[16:13:16.468]                     invisible(future)
[16:13:16.468]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.468]                 }
[16:13:16.468]                 ...future.workdir <- getwd()
[16:13:16.468]             }
[16:13:16.468]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.468]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.468]         }
[16:13:16.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.468]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.468]             base::names(...future.oldOptions))
[16:13:16.468]     }
[16:13:16.468]     if (FALSE) {
[16:13:16.468]     }
[16:13:16.468]     else {
[16:13:16.468]         if (TRUE) {
[16:13:16.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.468]                 open = "w")
[16:13:16.468]         }
[16:13:16.468]         else {
[16:13:16.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.468]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.468]         }
[16:13:16.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.468]             base::sink(type = "output", split = FALSE)
[16:13:16.468]             base::close(...future.stdout)
[16:13:16.468]         }, add = TRUE)
[16:13:16.468]     }
[16:13:16.468]     ...future.frame <- base::sys.nframe()
[16:13:16.468]     ...future.conditions <- base::list()
[16:13:16.468]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.468]     if (FALSE) {
[16:13:16.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.468]     }
[16:13:16.468]     ...future.result <- base::tryCatch({
[16:13:16.468]         base::withCallingHandlers({
[16:13:16.468]             ...future.value <- base::withVisible(base::local({
[16:13:16.468]                 value(future(subset(data, a == 2)))
[16:13:16.468]             }))
[16:13:16.468]             future::FutureResult(value = ...future.value$value, 
[16:13:16.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.468]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.468]                     ...future.globalenv.names))
[16:13:16.468]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.468]         }, condition = base::local({
[16:13:16.468]             c <- base::c
[16:13:16.468]             inherits <- base::inherits
[16:13:16.468]             invokeRestart <- base::invokeRestart
[16:13:16.468]             length <- base::length
[16:13:16.468]             list <- base::list
[16:13:16.468]             seq.int <- base::seq.int
[16:13:16.468]             signalCondition <- base::signalCondition
[16:13:16.468]             sys.calls <- base::sys.calls
[16:13:16.468]             `[[` <- base::`[[`
[16:13:16.468]             `+` <- base::`+`
[16:13:16.468]             `<<-` <- base::`<<-`
[16:13:16.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.468]                   3L)]
[16:13:16.468]             }
[16:13:16.468]             function(cond) {
[16:13:16.468]                 is_error <- inherits(cond, "error")
[16:13:16.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.468]                   NULL)
[16:13:16.468]                 if (is_error) {
[16:13:16.468]                   sessionInformation <- function() {
[16:13:16.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.468]                       search = base::search(), system = base::Sys.info())
[16:13:16.468]                   }
[16:13:16.468]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.468]                     cond$call), session = sessionInformation(), 
[16:13:16.468]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.468]                   signalCondition(cond)
[16:13:16.468]                 }
[16:13:16.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.468]                 "immediateCondition"))) {
[16:13:16.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.468]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.468]                   if (TRUE && !signal) {
[16:13:16.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.468]                     {
[16:13:16.468]                       inherits <- base::inherits
[16:13:16.468]                       invokeRestart <- base::invokeRestart
[16:13:16.468]                       is.null <- base::is.null
[16:13:16.468]                       muffled <- FALSE
[16:13:16.468]                       if (inherits(cond, "message")) {
[16:13:16.468]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.468]                         if (muffled) 
[16:13:16.468]                           invokeRestart("muffleMessage")
[16:13:16.468]                       }
[16:13:16.468]                       else if (inherits(cond, "warning")) {
[16:13:16.468]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.468]                         if (muffled) 
[16:13:16.468]                           invokeRestart("muffleWarning")
[16:13:16.468]                       }
[16:13:16.468]                       else if (inherits(cond, "condition")) {
[16:13:16.468]                         if (!is.null(pattern)) {
[16:13:16.468]                           computeRestarts <- base::computeRestarts
[16:13:16.468]                           grepl <- base::grepl
[16:13:16.468]                           restarts <- computeRestarts(cond)
[16:13:16.468]                           for (restart in restarts) {
[16:13:16.468]                             name <- restart$name
[16:13:16.468]                             if (is.null(name)) 
[16:13:16.468]                               next
[16:13:16.468]                             if (!grepl(pattern, name)) 
[16:13:16.468]                               next
[16:13:16.468]                             invokeRestart(restart)
[16:13:16.468]                             muffled <- TRUE
[16:13:16.468]                             break
[16:13:16.468]                           }
[16:13:16.468]                         }
[16:13:16.468]                       }
[16:13:16.468]                       invisible(muffled)
[16:13:16.468]                     }
[16:13:16.468]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.468]                   }
[16:13:16.468]                 }
[16:13:16.468]                 else {
[16:13:16.468]                   if (TRUE) {
[16:13:16.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.468]                     {
[16:13:16.468]                       inherits <- base::inherits
[16:13:16.468]                       invokeRestart <- base::invokeRestart
[16:13:16.468]                       is.null <- base::is.null
[16:13:16.468]                       muffled <- FALSE
[16:13:16.468]                       if (inherits(cond, "message")) {
[16:13:16.468]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.468]                         if (muffled) 
[16:13:16.468]                           invokeRestart("muffleMessage")
[16:13:16.468]                       }
[16:13:16.468]                       else if (inherits(cond, "warning")) {
[16:13:16.468]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.468]                         if (muffled) 
[16:13:16.468]                           invokeRestart("muffleWarning")
[16:13:16.468]                       }
[16:13:16.468]                       else if (inherits(cond, "condition")) {
[16:13:16.468]                         if (!is.null(pattern)) {
[16:13:16.468]                           computeRestarts <- base::computeRestarts
[16:13:16.468]                           grepl <- base::grepl
[16:13:16.468]                           restarts <- computeRestarts(cond)
[16:13:16.468]                           for (restart in restarts) {
[16:13:16.468]                             name <- restart$name
[16:13:16.468]                             if (is.null(name)) 
[16:13:16.468]                               next
[16:13:16.468]                             if (!grepl(pattern, name)) 
[16:13:16.468]                               next
[16:13:16.468]                             invokeRestart(restart)
[16:13:16.468]                             muffled <- TRUE
[16:13:16.468]                             break
[16:13:16.468]                           }
[16:13:16.468]                         }
[16:13:16.468]                       }
[16:13:16.468]                       invisible(muffled)
[16:13:16.468]                     }
[16:13:16.468]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.468]                   }
[16:13:16.468]                 }
[16:13:16.468]             }
[16:13:16.468]         }))
[16:13:16.468]     }, error = function(ex) {
[16:13:16.468]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.468]                 ...future.rng), started = ...future.startTime, 
[16:13:16.468]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.468]             version = "1.8"), class = "FutureResult")
[16:13:16.468]     }, finally = {
[16:13:16.468]         if (!identical(...future.workdir, getwd())) 
[16:13:16.468]             setwd(...future.workdir)
[16:13:16.468]         {
[16:13:16.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.468]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.468]             }
[16:13:16.468]             base::options(...future.oldOptions)
[16:13:16.468]             if (.Platform$OS.type == "windows") {
[16:13:16.468]                 old_names <- names(...future.oldEnvVars)
[16:13:16.468]                 envs <- base::Sys.getenv()
[16:13:16.468]                 names <- names(envs)
[16:13:16.468]                 common <- intersect(names, old_names)
[16:13:16.468]                 added <- setdiff(names, old_names)
[16:13:16.468]                 removed <- setdiff(old_names, names)
[16:13:16.468]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.468]                   envs[common]]
[16:13:16.468]                 NAMES <- toupper(changed)
[16:13:16.468]                 args <- list()
[16:13:16.468]                 for (kk in seq_along(NAMES)) {
[16:13:16.468]                   name <- changed[[kk]]
[16:13:16.468]                   NAME <- NAMES[[kk]]
[16:13:16.468]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.468]                     next
[16:13:16.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.468]                 }
[16:13:16.468]                 NAMES <- toupper(added)
[16:13:16.468]                 for (kk in seq_along(NAMES)) {
[16:13:16.468]                   name <- added[[kk]]
[16:13:16.468]                   NAME <- NAMES[[kk]]
[16:13:16.468]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.468]                     next
[16:13:16.468]                   args[[name]] <- ""
[16:13:16.468]                 }
[16:13:16.468]                 NAMES <- toupper(removed)
[16:13:16.468]                 for (kk in seq_along(NAMES)) {
[16:13:16.468]                   name <- removed[[kk]]
[16:13:16.468]                   NAME <- NAMES[[kk]]
[16:13:16.468]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.468]                     next
[16:13:16.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.468]                 }
[16:13:16.468]                 if (length(args) > 0) 
[16:13:16.468]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.468]             }
[16:13:16.468]             else {
[16:13:16.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.468]             }
[16:13:16.468]             {
[16:13:16.468]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.468]                   0L) {
[16:13:16.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.468]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.468]                   base::options(opts)
[16:13:16.468]                 }
[16:13:16.468]                 {
[16:13:16.468]                   {
[16:13:16.468]                     NULL
[16:13:16.468]                     RNGkind("Mersenne-Twister")
[16:13:16.468]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.468]                       inherits = FALSE)
[16:13:16.468]                   }
[16:13:16.468]                   options(future.plan = NULL)
[16:13:16.468]                   if (is.na(NA_character_)) 
[16:13:16.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.468]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:13:16.468]                   {
[16:13:16.468]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.468]                     if (!future$lazy) 
[16:13:16.468]                       future <- run(future)
[16:13:16.468]                     invisible(future)
[16:13:16.468]                   }, b = function (..., envir = parent.frame()) 
[16:13:16.468]                   {
[16:13:16.468]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.468]                     if (!future$lazy) 
[16:13:16.468]                       future <- run(future)
[16:13:16.468]                     invisible(future)
[16:13:16.468]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.468]                 }
[16:13:16.468]             }
[16:13:16.468]         }
[16:13:16.468]     })
[16:13:16.468]     if (TRUE) {
[16:13:16.468]         base::sink(type = "output", split = FALSE)
[16:13:16.468]         if (TRUE) {
[16:13:16.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.468]         }
[16:13:16.468]         else {
[16:13:16.468]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.468]         }
[16:13:16.468]         base::close(...future.stdout)
[16:13:16.468]         ...future.stdout <- NULL
[16:13:16.468]     }
[16:13:16.468]     ...future.result$conditions <- ...future.conditions
[16:13:16.468]     ...future.result$finished <- base::Sys.time()
[16:13:16.468]     ...future.result
[16:13:16.468] }
[16:13:16.469] assign_globals() ...
[16:13:16.469] List of 1
[16:13:16.469]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:16.469]   ..$ a: int [1:3] 1 2 3
[16:13:16.469]   ..$ b: int [1:3] 3 2 1
[16:13:16.469]  - attr(*, "where")=List of 1
[16:13:16.469]   ..$ data:<environment: R_EmptyEnv> 
[16:13:16.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.469]  - attr(*, "resolved")= logi FALSE
[16:13:16.469]  - attr(*, "total_size")= num 128
[16:13:16.469]  - attr(*, "already-done")= logi TRUE
[16:13:16.472] - copied ‘data’ to environment
[16:13:16.473] assign_globals() ... done
[16:13:16.473] plan(): Setting new future strategy stack:
[16:13:16.473] List of future strategies:
[16:13:16.473] 1. sequential:
[16:13:16.473]    - args: function (..., envir = parent.frame())
[16:13:16.473]    - tweaked: FALSE
[16:13:16.473]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.473] plan(): nbrOfWorkers() = 1
[16:13:16.501] plan(): Setting new future strategy stack:
[16:13:16.501] List of future strategies:
[16:13:16.501] 1. sequential:
[16:13:16.501]    - args: function (..., envir = parent.frame())
[16:13:16.501]    - tweaked: FALSE
[16:13:16.501]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.501] 2. sequential:
[16:13:16.501]    - args: function (..., envir = parent.frame())
[16:13:16.501]    - tweaked: FALSE
[16:13:16.501]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.502] plan(): nbrOfWorkers() = 1
[16:13:16.502] SequentialFuture started (and completed)
[16:13:16.502] signalConditions() ...
[16:13:16.502]  - include = ‘immediateCondition’
[16:13:16.502]  - exclude = 
[16:13:16.502]  - resignal = FALSE
[16:13:16.502]  - Number of conditions: 52
[16:13:16.503] signalConditions() ... done
[16:13:16.503] - Launch lazy future ... done
[16:13:16.503] run() for ‘SequentialFuture’ ... done
[16:13:16.503] signalConditions() ...
[16:13:16.503]  - include = ‘immediateCondition’
[16:13:16.503]  - exclude = 
[16:13:16.503]  - resignal = FALSE
[16:13:16.503]  - Number of conditions: 52
[16:13:16.503] signalConditions() ... done
[16:13:16.503] Future state: ‘finished’
[16:13:16.504] signalConditions() ...
[16:13:16.504]  - include = ‘condition’
[16:13:16.504]  - exclude = ‘immediateCondition’
[16:13:16.504]  - resignal = TRUE
[16:13:16.504]  - Number of conditions: 52
[16:13:16.504]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.474] getGlobalsAndPackages() ...
[16:13:16.504]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.474] Searching for globals...
[16:13:16.504]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.488] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:16.504]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.488] Searching for globals ... DONE
[16:13:16.505]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.488] Resolving globals: FALSE
[16:13:16.505]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.488] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:16.505]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.489] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:16.505]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.489] - globals: [1] ‘data’
[16:13:16.505]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.489] 
[16:13:16.505]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.489] getGlobalsAndPackages() ... DONE
[16:13:16.505]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.489] run() for ‘Future’ ...
[16:13:16.505]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.489] - state: ‘created’
[16:13:16.506]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.506]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.506]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.506]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490]   - Field: ‘label’
[16:13:16.506]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490]   - Field: ‘local’
[16:13:16.506]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490]   - Field: ‘owner’
[16:13:16.506]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490]   - Field: ‘envir’
[16:13:16.506]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490]   - Field: ‘packages’
[16:13:16.507]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.490]   - Field: ‘gc’
[16:13:16.507]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘conditions’
[16:13:16.507]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘expr’
[16:13:16.507]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘uuid’
[16:13:16.507]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘seed’
[16:13:16.507]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘version’
[16:13:16.507]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘result’
[16:13:16.507]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘asynchronous’
[16:13:16.508]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘calls’
[16:13:16.508]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘globals’
[16:13:16.508]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.491]   - Field: ‘stdout’
[16:13:16.508]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492]   - Field: ‘earlySignal’
[16:13:16.508]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492]   - Field: ‘lazy’
[16:13:16.508]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492]   - Field: ‘state’
[16:13:16.508]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.508]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492] - Launch lazy future ...
[16:13:16.509]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492] Packages needed by the future expression (n = 0): <none>
[16:13:16.509]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.492] Packages needed by future strategies (n = 0): <none>
[16:13:16.509]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.493] {
[16:13:16.493]     {
[16:13:16.493]         {
[16:13:16.493]             ...future.startTime <- base::Sys.time()
[16:13:16.493]             {
[16:13:16.493]                 {
[16:13:16.493]                   {
[16:13:16.493]                     base::local({
[16:13:16.493]                       has_future <- base::requireNamespace("future", 
[16:13:16.493]                         quietly = TRUE)
[16:13:16.493]                       if (has_future) {
[16:13:16.493]                         ns <- base::getNamespace("future")
[16:13:16.493]                         version <- ns[[".package"]][["version"]]
[16:13:16.493]                         if (is.null(version)) 
[16:13:16.493]                           version <- utils::packageVersion("future")
[16:13:16.493]                       }
[16:13:16.493]                       else {
[16:13:16.493]                         version <- NULL
[16:13:16.493]                       }
[16:13:16.493]                       if (!has_future || version < "1.8.0") {
[16:13:16.493]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.493]                           "", base::R.version$version.string), 
[16:13:16.493]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:16.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.493]                             "release", "version")], collapse = " "), 
[16:13:16.493]                           hostname = base::Sys.info()[["nodename"]])
[16:13:16.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.493]                           info)
[16:13:16.493]                         info <- base::paste(info, collapse = "; ")
[16:13:16.493]                         if (!has_future) {
[16:13:16.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.493]                             info)
[16:13:16.493]                         }
[16:13:16.493]                         else {
[16:13:16.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.493]                             info, version)
[16:13:16.493]                         }
[16:13:16.493]                         base::stop(msg)
[16:13:16.493]                       }
[16:13:16.493]                     })
[16:13:16.493]                   }
[16:13:16.493]                   options(future.plan = NULL)
[16:13:16.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:16.493]                 }
[16:13:16.493]                 ...future.workdir <- getwd()
[16:13:16.493]             }
[16:13:16.493]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.493]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.493]         }
[16:13:16.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.493]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.493]             base::names(...future.oldOptions))
[16:13:16.493]     }
[16:13:16.493]     if (FALSE) {
[16:13:16.493]     }
[16:13:16.493]     else {
[16:13:16.493]         if (TRUE) {
[16:13:16.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.493]                 open = "w")
[16:13:16.493]         }
[16:13:16.493]         else {
[16:13:16.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.493]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.493]         }
[16:13:16.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.493]             base::sink(type = "output", split = FALSE)
[16:13:16.493]             base::close(...future.stdout)
[16:13:16.493]         }, add = TRUE)
[16:13:16.493]     }
[16:13:16.493]     ...future.frame <- base::sys.nframe()
[16:13:16.493]     ...future.conditions <- base::list()
[16:13:16.493]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.493]     if (FALSE) {
[16:13:16.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.493]     }
[16:13:16.493]     ...future.result <- base::tryCatch({
[16:13:16.493]         base::withCallingHandlers({
[16:13:16.493]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:13:16.493]                 a == 2)))
[16:13:16.493]             future::FutureResult(value = ...future.value$value, 
[16:13:16.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.493]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.493]                     ...future.globalenv.names))
[16:13:16.493]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.493]         }, condition = base::local({
[16:13:16.493]             c <- base::c
[16:13:16.493]             inherits <- base::inherits
[16:13:16.493]             invokeRestart <- base::invokeRestart
[16:13:16.493]             length <- base::length
[16:13:16.493]             list <- base::list
[16:13:16.493]             seq.int <- base::seq.int
[16:13:16.493]             signalCondition <- base::signalCondition
[16:13:16.493]             sys.calls <- base::sys.calls
[16:13:16.493]             `[[` <- base::`[[`
[16:13:16.493]             `+` <- base::`+`
[16:13:16.493]             `<<-` <- base::`<<-`
[16:13:16.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.493]                   3L)]
[16:13:16.493]             }
[16:13:16.493]             function(cond) {
[16:13:16.493]                 is_error <- inherits(cond, "error")
[16:13:16.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.493]                   NULL)
[16:13:16.493]                 if (is_error) {
[16:13:16.493]                   sessionInformation <- function() {
[16:13:16.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.493]                       search = base::search(), system = base::Sys.info())
[16:13:16.493]                   }
[16:13:16.493]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.493]                     cond$call), session = sessionInformation(), 
[16:13:16.493]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.493]                   signalCondition(cond)
[16:13:16.493]                 }
[16:13:16.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.493]                 "immediateCondition"))) {
[16:13:16.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.493]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.493]                   if (TRUE && !signal) {
[16:13:16.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.493]                     {
[16:13:16.493]                       inherits <- base::inherits
[16:13:16.493]                       invokeRestart <- base::invokeRestart
[16:13:16.493]                       is.null <- base::is.null
[16:13:16.493]                       muffled <- FALSE
[16:13:16.493]                       if (inherits(cond, "message")) {
[16:13:16.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.493]                         if (muffled) 
[16:13:16.493]                           invokeRestart("muffleMessage")
[16:13:16.493]                       }
[16:13:16.493]                       else if (inherits(cond, "warning")) {
[16:13:16.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.493]                         if (muffled) 
[16:13:16.493]                           invokeRestart("muffleWarning")
[16:13:16.493]                       }
[16:13:16.493]                       else if (inherits(cond, "condition")) {
[16:13:16.493]                         if (!is.null(pattern)) {
[16:13:16.493]                           computeRestarts <- base::computeRestarts
[16:13:16.493]                           grepl <- base::grepl
[16:13:16.493]                           restarts <- computeRestarts(cond)
[16:13:16.493]                           for (restart in restarts) {
[16:13:16.493]                             name <- restart$name
[16:13:16.493]                             if (is.null(name)) 
[16:13:16.493]                               next
[16:13:16.493]                             if (!grepl(pattern, name)) 
[16:13:16.493]                               next
[16:13:16.493]                             invokeRestart(restart)
[16:13:16.493]                             muffled <- TRUE
[16:13:16.493]                             break
[16:13:16.493]                           }
[16:13:16.493]                         }
[16:13:16.493]                       }
[16:13:16.493]                       invisible(muffled)
[16:13:16.493]                     }
[16:13:16.493]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.493]                   }
[16:13:16.493]                 }
[16:13:16.493]                 else {
[16:13:16.493]                   if (TRUE) {
[16:13:16.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.493]                     {
[16:13:16.493]                       inherits <- base::inherits
[16:13:16.493]                       invokeRestart <- base::invokeRestart
[16:13:16.493]                       is.null <- base::is.null
[16:13:16.493]                       muffled <- FALSE
[16:13:16.493]                       if (inherits(cond, "message")) {
[16:13:16.493]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.493]                         if (muffled) 
[16:13:16.493]                           invokeRestart("muffleMessage")
[16:13:16.493]                       }
[16:13:16.493]                       else if (inherits(cond, "warning")) {
[16:13:16.493]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.493]                         if (muffled) 
[16:13:16.493]                           invokeRestart("muffleWarning")
[16:13:16.493]                       }
[16:13:16.493]                       else if (inherits(cond, "condition")) {
[16:13:16.493]                         if (!is.null(pattern)) {
[16:13:16.493]                           computeRestarts <- base::computeRestarts
[16:13:16.493]                           grepl <- base::grepl
[16:13:16.493]                           restarts <- computeRestarts(cond)
[16:13:16.493]                           for (restart in restarts) {
[16:13:16.493]                             name <- restart$name
[16:13:16.493]                             if (is.null(name)) 
[16:13:16.493]                               next
[16:13:16.493]                             if (!grepl(pattern, name)) 
[16:13:16.493]                               next
[16:13:16.493]                             invokeRestart(restart)
[16:13:16.493]                             muffled <- TRUE
[16:13:16.493]                             break
[16:13:16.493]                           }
[16:13:16.493]                         }
[16:13:16.493]                       }
[16:13:16.493]                       invisible(muffled)
[16:13:16.493]                     }
[16:13:16.493]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.493]                   }
[16:13:16.493]                 }
[16:13:16.493]             }
[16:13:16.493]         }))
[16:13:16.493]     }, error = function(ex) {
[16:13:16.493]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.493]                 ...future.rng), started = ...future.startTime, 
[16:13:16.493]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.493]             version = "1.8"), class = "FutureResult")
[16:13:16.493]     }, finally = {
[16:13:16.493]         if (!identical(...future.workdir, getwd())) 
[16:13:16.493]             setwd(...future.workdir)
[16:13:16.493]         {
[16:13:16.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.493]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.493]             }
[16:13:16.493]             base::options(...future.oldOptions)
[16:13:16.493]             if (.Platform$OS.type == "windows") {
[16:13:16.493]                 old_names <- names(...future.oldEnvVars)
[16:13:16.493]                 envs <- base::Sys.getenv()
[16:13:16.493]                 names <- names(envs)
[16:13:16.493]                 common <- intersect(names, old_names)
[16:13:16.493]                 added <- setdiff(names, old_names)
[16:13:16.493]                 removed <- setdiff(old_names, names)
[16:13:16.493]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.493]                   envs[common]]
[16:13:16.493]                 NAMES <- toupper(changed)
[16:13:16.493]                 args <- list()
[16:13:16.493]                 for (kk in seq_along(NAMES)) {
[16:13:16.493]                   name <- changed[[kk]]
[16:13:16.493]                   NAME <- NAMES[[kk]]
[16:13:16.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.493]                     next
[16:13:16.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.493]                 }
[16:13:16.493]                 NAMES <- toupper(added)
[16:13:16.493]                 for (kk in seq_along(NAMES)) {
[16:13:16.493]                   name <- added[[kk]]
[16:13:16.493]                   NAME <- NAMES[[kk]]
[16:13:16.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.493]                     next
[16:13:16.493]                   args[[name]] <- ""
[16:13:16.493]                 }
[16:13:16.493]                 NAMES <- toupper(removed)
[16:13:16.493]                 for (kk in seq_along(NAMES)) {
[16:13:16.493]                   name <- removed[[kk]]
[16:13:16.493]                   NAME <- NAMES[[kk]]
[16:13:16.493]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.493]                     next
[16:13:16.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.493]                 }
[16:13:16.493]                 if (length(args) > 0) 
[16:13:16.493]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.493]             }
[16:13:16.493]             else {
[16:13:16.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.493]             }
[16:13:16.493]             {
[16:13:16.493]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.493]                   0L) {
[16:13:16.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.493]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.493]                   base::options(opts)
[16:13:16.493]                 }
[16:13:16.493]                 {
[16:13:16.493]                   {
[16:13:16.493]                     NULL
[16:13:16.493]                     RNGkind("Mersenne-Twister")
[16:13:16.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.493]                       inherits = FALSE)
[16:13:16.493]                   }
[16:13:16.493]                   options(future.plan = NULL)
[16:13:16.493]                   if (is.na(NA_character_)) 
[16:13:16.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.493]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:16.493]                   {
[16:13:16.493]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.493]                     if (!future$lazy) 
[16:13:16.493]                       future <- run(future)
[16:13:16.493]                     invisible(future)
[16:13:16.493]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.493]                 }
[16:13:16.493]             }
[16:13:16.493]         }
[16:13:16.493]     })
[16:13:16.493]     if (TRUE) {
[16:13:16.493]         base::sink(type = "output", split = FALSE)
[16:13:16.493]         if (TRUE) {
[16:13:16.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.493]         }
[16:13:16.493]         else {
[16:13:16.493]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.493]         }
[16:13:16.493]         base::close(...future.stdout)
[16:13:16.493]         ...future.stdout <- NULL
[16:13:16.493]     }
[16:13:16.493]     ...future.result$conditions <- ...future.conditions
[16:13:16.493]     ...future.result$finished <- base::Sys.time()
[16:13:16.493]     ...future.result
[16:13:16.493] }
[16:13:16.509]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.494] assign_globals() ...
[16:13:16.509]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.494] List of 1
[16:13:16.494]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:16.494]   ..$ a: int [1:3] 1 2 3
[16:13:16.494]   ..$ b: int [1:3] 3 2 1
[16:13:16.494]  - attr(*, "where")=List of 1
[16:13:16.494]   ..$ data:<environment: R_EmptyEnv> 
[16:13:16.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.494]  - attr(*, "resolved")= logi FALSE
[16:13:16.494]  - attr(*, "total_size")= num 128
[16:13:16.494]  - attr(*, "already-done")= logi TRUE
[16:13:16.509]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.498] - copied ‘data’ to environment
[16:13:16.509]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.498] assign_globals() ... done
[16:13:16.510]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.499] plan(): Setting new future strategy stack:
[16:13:16.510]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.499] List of future strategies:
[16:13:16.499] 1. sequential:
[16:13:16.499]    - args: function (..., envir = parent.frame())
[16:13:16.499]    - tweaked: FALSE
[16:13:16.499]    - call: NULL
[16:13:16.510]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.499] plan(): nbrOfWorkers() = 1
[16:13:16.510]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.500] plan(): Setting new future strategy stack:
[16:13:16.510]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.500] List of future strategies:
[16:13:16.500] 1. sequential:
[16:13:16.500]    - args: function (..., envir = parent.frame())
[16:13:16.500]    - tweaked: FALSE
[16:13:16.500]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.510]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.500] plan(): nbrOfWorkers() = 1
[16:13:16.510]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.501] SequentialFuture started (and completed)
[16:13:16.510]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.501] - Launch lazy future ... done
[16:13:16.511]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.501] run() for ‘SequentialFuture’ ... done
[16:13:16.511] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[16:13:16.511] plan(): Setting new future strategy stack:
[16:13:16.511] List of future strategies:
[16:13:16.511] 1. sequential:
[16:13:16.511]    - args: function (..., envir = parent.frame())
[16:13:16.511]    - tweaked: FALSE
[16:13:16.511]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.511] 2. multicore:
[16:13:16.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:16.511]    - tweaked: FALSE
[16:13:16.511]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.512] plan(): nbrOfWorkers() = 1
[16:13:16.512] getGlobalsAndPackages() ...
[16:13:16.512] Searching for globals...
[16:13:16.528] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:16.528] Searching for globals ... DONE
[16:13:16.528] Resolving globals: FALSE
[16:13:16.529] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[16:13:16.530] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:16.530] - globals: [2] ‘nested’, ‘strategy2’
[16:13:16.530] - packages: [1] ‘future’
[16:13:16.530] getGlobalsAndPackages() ... DONE
[16:13:16.530] run() for ‘Future’ ...
[16:13:16.530] - state: ‘created’
[16:13:16.530] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.531] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.531]   - Field: ‘label’
[16:13:16.531]   - Field: ‘local’
[16:13:16.531]   - Field: ‘owner’
[16:13:16.531]   - Field: ‘envir’
[16:13:16.531]   - Field: ‘packages’
[16:13:16.531]   - Field: ‘gc’
[16:13:16.532]   - Field: ‘conditions’
[16:13:16.532]   - Field: ‘expr’
[16:13:16.532]   - Field: ‘uuid’
[16:13:16.532]   - Field: ‘seed’
[16:13:16.532]   - Field: ‘version’
[16:13:16.532]   - Field: ‘result’
[16:13:16.532]   - Field: ‘asynchronous’
[16:13:16.532]   - Field: ‘calls’
[16:13:16.532]   - Field: ‘globals’
[16:13:16.532]   - Field: ‘stdout’
[16:13:16.532]   - Field: ‘earlySignal’
[16:13:16.532]   - Field: ‘lazy’
[16:13:16.533]   - Field: ‘state’
[16:13:16.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.533] - Launch lazy future ...
[16:13:16.533] Packages needed by the future expression (n = 1): ‘future’
[16:13:16.533] Packages needed by future strategies (n = 1): ‘future’
[16:13:16.534] {
[16:13:16.534]     {
[16:13:16.534]         {
[16:13:16.534]             ...future.startTime <- base::Sys.time()
[16:13:16.534]             {
[16:13:16.534]                 {
[16:13:16.534]                   {
[16:13:16.534]                     {
[16:13:16.534]                       base::local({
[16:13:16.534]                         has_future <- base::requireNamespace("future", 
[16:13:16.534]                           quietly = TRUE)
[16:13:16.534]                         if (has_future) {
[16:13:16.534]                           ns <- base::getNamespace("future")
[16:13:16.534]                           version <- ns[[".package"]][["version"]]
[16:13:16.534]                           if (is.null(version)) 
[16:13:16.534]                             version <- utils::packageVersion("future")
[16:13:16.534]                         }
[16:13:16.534]                         else {
[16:13:16.534]                           version <- NULL
[16:13:16.534]                         }
[16:13:16.534]                         if (!has_future || version < "1.8.0") {
[16:13:16.534]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.534]                             "", base::R.version$version.string), 
[16:13:16.534]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.534]                               "release", "version")], collapse = " "), 
[16:13:16.534]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.534]                             info)
[16:13:16.534]                           info <- base::paste(info, collapse = "; ")
[16:13:16.534]                           if (!has_future) {
[16:13:16.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.534]                               info)
[16:13:16.534]                           }
[16:13:16.534]                           else {
[16:13:16.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.534]                               info, version)
[16:13:16.534]                           }
[16:13:16.534]                           base::stop(msg)
[16:13:16.534]                         }
[16:13:16.534]                       })
[16:13:16.534]                     }
[16:13:16.534]                     base::local({
[16:13:16.534]                       for (pkg in "future") {
[16:13:16.534]                         base::loadNamespace(pkg)
[16:13:16.534]                         base::library(pkg, character.only = TRUE)
[16:13:16.534]                       }
[16:13:16.534]                     })
[16:13:16.534]                   }
[16:13:16.534]                   options(future.plan = NULL)
[16:13:16.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.534]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:16.534]                     envir = parent.frame()) 
[16:13:16.534]                   {
[16:13:16.534]                     default_workers <- missing(workers)
[16:13:16.534]                     if (is.function(workers)) 
[16:13:16.534]                       workers <- workers()
[16:13:16.534]                     workers <- structure(as.integer(workers), 
[16:13:16.534]                       class = class(workers))
[16:13:16.534]                     stop_if_not(is.finite(workers), workers >= 
[16:13:16.534]                       1L)
[16:13:16.534]                     if ((workers == 1L && !inherits(workers, 
[16:13:16.534]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:16.534]                       if (default_workers) 
[16:13:16.534]                         supportsMulticore(warn = TRUE)
[16:13:16.534]                       return(sequential(..., envir = envir))
[16:13:16.534]                     }
[16:13:16.534]                     oopts <- options(mc.cores = workers)
[16:13:16.534]                     on.exit(options(oopts))
[16:13:16.534]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:16.534]                       envir = envir)
[16:13:16.534]                     if (!future$lazy) 
[16:13:16.534]                       future <- run(future)
[16:13:16.534]                     invisible(future)
[16:13:16.534]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.534]                 }
[16:13:16.534]                 ...future.workdir <- getwd()
[16:13:16.534]             }
[16:13:16.534]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.534]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.534]         }
[16:13:16.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.534]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.534]             base::names(...future.oldOptions))
[16:13:16.534]     }
[16:13:16.534]     if (FALSE) {
[16:13:16.534]     }
[16:13:16.534]     else {
[16:13:16.534]         if (TRUE) {
[16:13:16.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.534]                 open = "w")
[16:13:16.534]         }
[16:13:16.534]         else {
[16:13:16.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.534]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.534]         }
[16:13:16.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.534]             base::sink(type = "output", split = FALSE)
[16:13:16.534]             base::close(...future.stdout)
[16:13:16.534]         }, add = TRUE)
[16:13:16.534]     }
[16:13:16.534]     ...future.frame <- base::sys.nframe()
[16:13:16.534]     ...future.conditions <- base::list()
[16:13:16.534]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.534]     if (FALSE) {
[16:13:16.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.534]     }
[16:13:16.534]     ...future.result <- base::tryCatch({
[16:13:16.534]         base::withCallingHandlers({
[16:13:16.534]             ...future.value <- base::withVisible(base::local({
[16:13:16.534]                 a <- 1L
[16:13:16.534]                 plan_a <- unclass(future::plan("list"))
[16:13:16.534]                 nested_a <- nested[-1]
[16:13:16.534]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:16.534]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.534]                   strategy2))
[16:13:16.534]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:16.534]                   "init") <- NULL
[16:13:16.534]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:16.534]                   "init") <- NULL
[16:13:16.534]                 stopifnot(all.equal(plan_a, nested_a))
[16:13:16.534]                 y %<-% {
[16:13:16.534]                   b <- 2L
[16:13:16.534]                   plan_b <- future::plan("list")
[16:13:16.534]                   nested_b <- nested_a[-1]
[16:13:16.534]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:16.534]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.534]                     "sequential"))
[16:13:16.534]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:16.534]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:16.534]                 }
[16:13:16.534]                 y
[16:13:16.534]             }))
[16:13:16.534]             future::FutureResult(value = ...future.value$value, 
[16:13:16.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.534]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.534]                     ...future.globalenv.names))
[16:13:16.534]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.534]         }, condition = base::local({
[16:13:16.534]             c <- base::c
[16:13:16.534]             inherits <- base::inherits
[16:13:16.534]             invokeRestart <- base::invokeRestart
[16:13:16.534]             length <- base::length
[16:13:16.534]             list <- base::list
[16:13:16.534]             seq.int <- base::seq.int
[16:13:16.534]             signalCondition <- base::signalCondition
[16:13:16.534]             sys.calls <- base::sys.calls
[16:13:16.534]             `[[` <- base::`[[`
[16:13:16.534]             `+` <- base::`+`
[16:13:16.534]             `<<-` <- base::`<<-`
[16:13:16.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.534]                   3L)]
[16:13:16.534]             }
[16:13:16.534]             function(cond) {
[16:13:16.534]                 is_error <- inherits(cond, "error")
[16:13:16.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.534]                   NULL)
[16:13:16.534]                 if (is_error) {
[16:13:16.534]                   sessionInformation <- function() {
[16:13:16.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.534]                       search = base::search(), system = base::Sys.info())
[16:13:16.534]                   }
[16:13:16.534]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.534]                     cond$call), session = sessionInformation(), 
[16:13:16.534]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.534]                   signalCondition(cond)
[16:13:16.534]                 }
[16:13:16.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.534]                 "immediateCondition"))) {
[16:13:16.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.534]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.534]                   if (TRUE && !signal) {
[16:13:16.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.534]                     {
[16:13:16.534]                       inherits <- base::inherits
[16:13:16.534]                       invokeRestart <- base::invokeRestart
[16:13:16.534]                       is.null <- base::is.null
[16:13:16.534]                       muffled <- FALSE
[16:13:16.534]                       if (inherits(cond, "message")) {
[16:13:16.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.534]                         if (muffled) 
[16:13:16.534]                           invokeRestart("muffleMessage")
[16:13:16.534]                       }
[16:13:16.534]                       else if (inherits(cond, "warning")) {
[16:13:16.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.534]                         if (muffled) 
[16:13:16.534]                           invokeRestart("muffleWarning")
[16:13:16.534]                       }
[16:13:16.534]                       else if (inherits(cond, "condition")) {
[16:13:16.534]                         if (!is.null(pattern)) {
[16:13:16.534]                           computeRestarts <- base::computeRestarts
[16:13:16.534]                           grepl <- base::grepl
[16:13:16.534]                           restarts <- computeRestarts(cond)
[16:13:16.534]                           for (restart in restarts) {
[16:13:16.534]                             name <- restart$name
[16:13:16.534]                             if (is.null(name)) 
[16:13:16.534]                               next
[16:13:16.534]                             if (!grepl(pattern, name)) 
[16:13:16.534]                               next
[16:13:16.534]                             invokeRestart(restart)
[16:13:16.534]                             muffled <- TRUE
[16:13:16.534]                             break
[16:13:16.534]                           }
[16:13:16.534]                         }
[16:13:16.534]                       }
[16:13:16.534]                       invisible(muffled)
[16:13:16.534]                     }
[16:13:16.534]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.534]                   }
[16:13:16.534]                 }
[16:13:16.534]                 else {
[16:13:16.534]                   if (TRUE) {
[16:13:16.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.534]                     {
[16:13:16.534]                       inherits <- base::inherits
[16:13:16.534]                       invokeRestart <- base::invokeRestart
[16:13:16.534]                       is.null <- base::is.null
[16:13:16.534]                       muffled <- FALSE
[16:13:16.534]                       if (inherits(cond, "message")) {
[16:13:16.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.534]                         if (muffled) 
[16:13:16.534]                           invokeRestart("muffleMessage")
[16:13:16.534]                       }
[16:13:16.534]                       else if (inherits(cond, "warning")) {
[16:13:16.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.534]                         if (muffled) 
[16:13:16.534]                           invokeRestart("muffleWarning")
[16:13:16.534]                       }
[16:13:16.534]                       else if (inherits(cond, "condition")) {
[16:13:16.534]                         if (!is.null(pattern)) {
[16:13:16.534]                           computeRestarts <- base::computeRestarts
[16:13:16.534]                           grepl <- base::grepl
[16:13:16.534]                           restarts <- computeRestarts(cond)
[16:13:16.534]                           for (restart in restarts) {
[16:13:16.534]                             name <- restart$name
[16:13:16.534]                             if (is.null(name)) 
[16:13:16.534]                               next
[16:13:16.534]                             if (!grepl(pattern, name)) 
[16:13:16.534]                               next
[16:13:16.534]                             invokeRestart(restart)
[16:13:16.534]                             muffled <- TRUE
[16:13:16.534]                             break
[16:13:16.534]                           }
[16:13:16.534]                         }
[16:13:16.534]                       }
[16:13:16.534]                       invisible(muffled)
[16:13:16.534]                     }
[16:13:16.534]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.534]                   }
[16:13:16.534]                 }
[16:13:16.534]             }
[16:13:16.534]         }))
[16:13:16.534]     }, error = function(ex) {
[16:13:16.534]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.534]                 ...future.rng), started = ...future.startTime, 
[16:13:16.534]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.534]             version = "1.8"), class = "FutureResult")
[16:13:16.534]     }, finally = {
[16:13:16.534]         if (!identical(...future.workdir, getwd())) 
[16:13:16.534]             setwd(...future.workdir)
[16:13:16.534]         {
[16:13:16.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.534]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.534]             }
[16:13:16.534]             base::options(...future.oldOptions)
[16:13:16.534]             if (.Platform$OS.type == "windows") {
[16:13:16.534]                 old_names <- names(...future.oldEnvVars)
[16:13:16.534]                 envs <- base::Sys.getenv()
[16:13:16.534]                 names <- names(envs)
[16:13:16.534]                 common <- intersect(names, old_names)
[16:13:16.534]                 added <- setdiff(names, old_names)
[16:13:16.534]                 removed <- setdiff(old_names, names)
[16:13:16.534]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.534]                   envs[common]]
[16:13:16.534]                 NAMES <- toupper(changed)
[16:13:16.534]                 args <- list()
[16:13:16.534]                 for (kk in seq_along(NAMES)) {
[16:13:16.534]                   name <- changed[[kk]]
[16:13:16.534]                   NAME <- NAMES[[kk]]
[16:13:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.534]                     next
[16:13:16.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.534]                 }
[16:13:16.534]                 NAMES <- toupper(added)
[16:13:16.534]                 for (kk in seq_along(NAMES)) {
[16:13:16.534]                   name <- added[[kk]]
[16:13:16.534]                   NAME <- NAMES[[kk]]
[16:13:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.534]                     next
[16:13:16.534]                   args[[name]] <- ""
[16:13:16.534]                 }
[16:13:16.534]                 NAMES <- toupper(removed)
[16:13:16.534]                 for (kk in seq_along(NAMES)) {
[16:13:16.534]                   name <- removed[[kk]]
[16:13:16.534]                   NAME <- NAMES[[kk]]
[16:13:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.534]                     next
[16:13:16.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.534]                 }
[16:13:16.534]                 if (length(args) > 0) 
[16:13:16.534]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.534]             }
[16:13:16.534]             else {
[16:13:16.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.534]             }
[16:13:16.534]             {
[16:13:16.534]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.534]                   0L) {
[16:13:16.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.534]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.534]                   base::options(opts)
[16:13:16.534]                 }
[16:13:16.534]                 {
[16:13:16.534]                   {
[16:13:16.534]                     NULL
[16:13:16.534]                     RNGkind("Mersenne-Twister")
[16:13:16.534]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.534]                       inherits = FALSE)
[16:13:16.534]                   }
[16:13:16.534]                   options(future.plan = NULL)
[16:13:16.534]                   if (is.na(NA_character_)) 
[16:13:16.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.534]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:13:16.534]                   {
[16:13:16.534]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.534]                     if (!future$lazy) 
[16:13:16.534]                       future <- run(future)
[16:13:16.534]                     invisible(future)
[16:13:16.534]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:16.534]                     envir = parent.frame()) 
[16:13:16.534]                   {
[16:13:16.534]                     default_workers <- missing(workers)
[16:13:16.534]                     if (is.function(workers)) 
[16:13:16.534]                       workers <- workers()
[16:13:16.534]                     workers <- structure(as.integer(workers), 
[16:13:16.534]                       class = class(workers))
[16:13:16.534]                     stop_if_not(is.finite(workers), workers >= 
[16:13:16.534]                       1L)
[16:13:16.534]                     if ((workers == 1L && !inherits(workers, 
[16:13:16.534]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:16.534]                       if (default_workers) 
[16:13:16.534]                         supportsMulticore(warn = TRUE)
[16:13:16.534]                       return(sequential(..., envir = envir))
[16:13:16.534]                     }
[16:13:16.534]                     oopts <- options(mc.cores = workers)
[16:13:16.534]                     on.exit(options(oopts))
[16:13:16.534]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:16.534]                       envir = envir)
[16:13:16.534]                     if (!future$lazy) 
[16:13:16.534]                       future <- run(future)
[16:13:16.534]                     invisible(future)
[16:13:16.534]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.534]                 }
[16:13:16.534]             }
[16:13:16.534]         }
[16:13:16.534]     })
[16:13:16.534]     if (TRUE) {
[16:13:16.534]         base::sink(type = "output", split = FALSE)
[16:13:16.534]         if (TRUE) {
[16:13:16.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.534]         }
[16:13:16.534]         else {
[16:13:16.534]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.534]         }
[16:13:16.534]         base::close(...future.stdout)
[16:13:16.534]         ...future.stdout <- NULL
[16:13:16.534]     }
[16:13:16.534]     ...future.result$conditions <- ...future.conditions
[16:13:16.534]     ...future.result$finished <- base::Sys.time()
[16:13:16.534]     ...future.result
[16:13:16.534] }
[16:13:16.536] assign_globals() ...
[16:13:16.536] List of 2
[16:13:16.536]  $ nested   :List of 2
[16:13:16.536]   ..$ a:function (..., envir = parent.frame())  
[16:13:16.536]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:16.536]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.536]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:16.536]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:16.536]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.536]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:16.536]  $ strategy2: chr "multicore"
[16:13:16.536]  - attr(*, "where")=List of 2
[16:13:16.536]   ..$ nested   :<environment: R_EmptyEnv> 
[16:13:16.536]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:13:16.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.536]  - attr(*, "resolved")= logi FALSE
[16:13:16.536]  - attr(*, "total_size")= num 59224
[16:13:16.536]  - attr(*, "already-done")= logi TRUE
[16:13:16.541] - copied ‘nested’ to environment
[16:13:16.541] - copied ‘strategy2’ to environment
[16:13:16.541] assign_globals() ... done
[16:13:16.542] plan(): Setting new future strategy stack:
[16:13:16.542] List of future strategies:
[16:13:16.542] 1. multicore:
[16:13:16.542]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:16.542]    - tweaked: FALSE
[16:13:16.542]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.546] plan(): nbrOfWorkers() = 2
[16:13:16.603] plan(): Setting new future strategy stack:
[16:13:16.603] List of future strategies:
[16:13:16.603] 1. sequential:
[16:13:16.603]    - args: function (..., envir = parent.frame())
[16:13:16.603]    - tweaked: FALSE
[16:13:16.603]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.603] 2. multicore:
[16:13:16.603]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:16.603]    - tweaked: FALSE
[16:13:16.603]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.604] plan(): nbrOfWorkers() = 1
[16:13:16.604] SequentialFuture started (and completed)
[16:13:16.604] signalConditions() ...
[16:13:16.604]  - include = ‘immediateCondition’
[16:13:16.604]  - exclude = 
[16:13:16.604]  - resignal = FALSE
[16:13:16.604]  - Number of conditions: 51
[16:13:16.605] signalConditions() ... done
[16:13:16.605] - Launch lazy future ... done
[16:13:16.605] run() for ‘SequentialFuture’ ... done
[16:13:16.605] signalConditions() ...
[16:13:16.605]  - include = ‘immediateCondition’
[16:13:16.605]  - exclude = 
[16:13:16.605]  - resignal = FALSE
[16:13:16.606]  - Number of conditions: 51
[16:13:16.606] signalConditions() ... done
[16:13:16.606] Future state: ‘finished’
[16:13:16.606] signalConditions() ...
[16:13:16.606]  - include = ‘condition’
[16:13:16.606]  - exclude = ‘immediateCondition’
[16:13:16.606]  - resignal = TRUE
[16:13:16.606]  - Number of conditions: 51
[16:13:16.606]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.546] getGlobalsAndPackages() ...
[16:13:16.607]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.547] Searching for globals...
[16:13:16.607]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.564] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:13:16.607]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.564] Searching for globals ... DONE
[16:13:16.607]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.565] Resolving globals: FALSE
[16:13:16.607]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.565] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[16:13:16.608]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.566] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:13:16.608]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.566] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:13:16.608]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.566] 
[16:13:16.608]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.566] getGlobalsAndPackages() ... DONE
[16:13:16.608]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.566] run() for ‘Future’ ...
[16:13:16.608]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.566] - state: ‘created’
[16:13:16.609]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.567] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:16.609]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:16.609]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:16.609]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.570]   - Field: ‘label’
[16:13:16.609]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘local’
[16:13:16.609]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘owner’
[16:13:16.610]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘envir’
[16:13:16.610]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘workers’
[16:13:16.610]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘packages’
[16:13:16.610]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘gc’
[16:13:16.610]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘job’
[16:13:16.610]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘conditions’
[16:13:16.611]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘expr’
[16:13:16.611]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.571]   - Field: ‘uuid’
[16:13:16.611]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘seed’
[16:13:16.611]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘version’
[16:13:16.611]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘result’
[16:13:16.611]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘asynchronous’
[16:13:16.612]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘calls’
[16:13:16.612]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘globals’
[16:13:16.612]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘stdout’
[16:13:16.612]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘earlySignal’
[16:13:16.612]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.572]   - Field: ‘lazy’
[16:13:16.612]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.573]   - Field: ‘state’
[16:13:16.612]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:16.613]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.573] - Launch lazy future ...
[16:13:16.613]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.574] Packages needed by the future expression (n = 0): <none>
[16:13:16.613]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.574] Packages needed by future strategies (n = 0): <none>
[16:13:16.613]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.574] {
[16:13:16.574]     {
[16:13:16.574]         {
[16:13:16.574]             ...future.startTime <- base::Sys.time()
[16:13:16.574]             {
[16:13:16.574]                 {
[16:13:16.574]                   {
[16:13:16.574]                     {
[16:13:16.574]                       base::local({
[16:13:16.574]                         has_future <- base::requireNamespace("future", 
[16:13:16.574]                           quietly = TRUE)
[16:13:16.574]                         if (has_future) {
[16:13:16.574]                           ns <- base::getNamespace("future")
[16:13:16.574]                           version <- ns[[".package"]][["version"]]
[16:13:16.574]                           if (is.null(version)) 
[16:13:16.574]                             version <- utils::packageVersion("future")
[16:13:16.574]                         }
[16:13:16.574]                         else {
[16:13:16.574]                           version <- NULL
[16:13:16.574]                         }
[16:13:16.574]                         if (!has_future || version < "1.8.0") {
[16:13:16.574]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.574]                             "", base::R.version$version.string), 
[16:13:16.574]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.574]                               "release", "version")], collapse = " "), 
[16:13:16.574]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.574]                             info)
[16:13:16.574]                           info <- base::paste(info, collapse = "; ")
[16:13:16.574]                           if (!has_future) {
[16:13:16.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.574]                               info)
[16:13:16.574]                           }
[16:13:16.574]                           else {
[16:13:16.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.574]                               info, version)
[16:13:16.574]                           }
[16:13:16.574]                           base::stop(msg)
[16:13:16.574]                         }
[16:13:16.574]                       })
[16:13:16.574]                     }
[16:13:16.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:16.574]                     base::options(mc.cores = 1L)
[16:13:16.574]                   }
[16:13:16.574]                   options(future.plan = NULL)
[16:13:16.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:16.574]                 }
[16:13:16.574]                 ...future.workdir <- getwd()
[16:13:16.574]             }
[16:13:16.574]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.574]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.574]         }
[16:13:16.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.574]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.574]             base::names(...future.oldOptions))
[16:13:16.574]     }
[16:13:16.574]     if (FALSE) {
[16:13:16.574]     }
[16:13:16.574]     else {
[16:13:16.574]         if (TRUE) {
[16:13:16.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.574]                 open = "w")
[16:13:16.574]         }
[16:13:16.574]         else {
[16:13:16.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.574]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.574]         }
[16:13:16.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.574]             base::sink(type = "output", split = FALSE)
[16:13:16.574]             base::close(...future.stdout)
[16:13:16.574]         }, add = TRUE)
[16:13:16.574]     }
[16:13:16.574]     ...future.frame <- base::sys.nframe()
[16:13:16.574]     ...future.conditions <- base::list()
[16:13:16.574]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.574]     if (FALSE) {
[16:13:16.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.574]     }
[16:13:16.574]     ...future.result <- base::tryCatch({
[16:13:16.574]         base::withCallingHandlers({
[16:13:16.574]             ...future.value <- base::withVisible(base::local({
[16:13:16.574]                 withCallingHandlers({
[16:13:16.574]                   {
[16:13:16.574]                     b <- 2L
[16:13:16.574]                     plan_b <- future::plan("list")
[16:13:16.574]                     nested_b <- nested_a[-1]
[16:13:16.574]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:16.574]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.574]                       "sequential"))
[16:13:16.574]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:16.574]                       b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:16.574]                   }
[16:13:16.574]                 }, immediateCondition = function(cond) {
[16:13:16.574]                   save_rds <- function (object, pathname, ...) 
[16:13:16.574]                   {
[16:13:16.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:16.574]                     if (file_test("-f", pathname_tmp)) {
[16:13:16.574]                       fi_tmp <- file.info(pathname_tmp)
[16:13:16.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:16.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:16.574]                         fi_tmp[["mtime"]])
[16:13:16.574]                     }
[16:13:16.574]                     tryCatch({
[16:13:16.574]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:16.574]                     }, error = function(ex) {
[16:13:16.574]                       msg <- conditionMessage(ex)
[16:13:16.574]                       fi_tmp <- file.info(pathname_tmp)
[16:13:16.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:16.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:16.574]                         fi_tmp[["mtime"]], msg)
[16:13:16.574]                       ex$message <- msg
[16:13:16.574]                       stop(ex)
[16:13:16.574]                     })
[16:13:16.574]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:16.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:16.574]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:16.574]                       fi_tmp <- file.info(pathname_tmp)
[16:13:16.574]                       fi <- file.info(pathname)
[16:13:16.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:16.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:16.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:16.574]                         fi[["size"]], fi[["mtime"]])
[16:13:16.574]                       stop(msg)
[16:13:16.574]                     }
[16:13:16.574]                     invisible(pathname)
[16:13:16.574]                   }
[16:13:16.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:16.574]                     rootPath = tempdir()) 
[16:13:16.574]                   {
[16:13:16.574]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:16.574]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:16.574]                       tmpdir = path, fileext = ".rds")
[16:13:16.574]                     save_rds(obj, file)
[16:13:16.574]                   }
[16:13:16.574]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:16.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.574]                   {
[16:13:16.574]                     inherits <- base::inherits
[16:13:16.574]                     invokeRestart <- base::invokeRestart
[16:13:16.574]                     is.null <- base::is.null
[16:13:16.574]                     muffled <- FALSE
[16:13:16.574]                     if (inherits(cond, "message")) {
[16:13:16.574]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:16.574]                       if (muffled) 
[16:13:16.574]                         invokeRestart("muffleMessage")
[16:13:16.574]                     }
[16:13:16.574]                     else if (inherits(cond, "warning")) {
[16:13:16.574]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:16.574]                       if (muffled) 
[16:13:16.574]                         invokeRestart("muffleWarning")
[16:13:16.574]                     }
[16:13:16.574]                     else if (inherits(cond, "condition")) {
[16:13:16.574]                       if (!is.null(pattern)) {
[16:13:16.574]                         computeRestarts <- base::computeRestarts
[16:13:16.574]                         grepl <- base::grepl
[16:13:16.574]                         restarts <- computeRestarts(cond)
[16:13:16.574]                         for (restart in restarts) {
[16:13:16.574]                           name <- restart$name
[16:13:16.574]                           if (is.null(name)) 
[16:13:16.574]                             next
[16:13:16.574]                           if (!grepl(pattern, name)) 
[16:13:16.574]                             next
[16:13:16.574]                           invokeRestart(restart)
[16:13:16.574]                           muffled <- TRUE
[16:13:16.574]                           break
[16:13:16.574]                         }
[16:13:16.574]                       }
[16:13:16.574]                     }
[16:13:16.574]                     invisible(muffled)
[16:13:16.574]                   }
[16:13:16.574]                   muffleCondition(cond)
[16:13:16.574]                 })
[16:13:16.574]             }))
[16:13:16.574]             future::FutureResult(value = ...future.value$value, 
[16:13:16.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.574]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.574]                     ...future.globalenv.names))
[16:13:16.574]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.574]         }, condition = base::local({
[16:13:16.574]             c <- base::c
[16:13:16.574]             inherits <- base::inherits
[16:13:16.574]             invokeRestart <- base::invokeRestart
[16:13:16.574]             length <- base::length
[16:13:16.574]             list <- base::list
[16:13:16.574]             seq.int <- base::seq.int
[16:13:16.574]             signalCondition <- base::signalCondition
[16:13:16.574]             sys.calls <- base::sys.calls
[16:13:16.574]             `[[` <- base::`[[`
[16:13:16.574]             `+` <- base::`+`
[16:13:16.574]             `<<-` <- base::`<<-`
[16:13:16.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.574]                   3L)]
[16:13:16.574]             }
[16:13:16.574]             function(cond) {
[16:13:16.574]                 is_error <- inherits(cond, "error")
[16:13:16.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.574]                   NULL)
[16:13:16.574]                 if (is_error) {
[16:13:16.574]                   sessionInformation <- function() {
[16:13:16.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.574]                       search = base::search(), system = base::Sys.info())
[16:13:16.574]                   }
[16:13:16.574]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.574]                     cond$call), session = sessionInformation(), 
[16:13:16.574]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.574]                   signalCondition(cond)
[16:13:16.574]                 }
[16:13:16.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.574]                 "immediateCondition"))) {
[16:13:16.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.574]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.574]                   if (TRUE && !signal) {
[16:13:16.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.574]                     {
[16:13:16.574]                       inherits <- base::inherits
[16:13:16.574]                       invokeRestart <- base::invokeRestart
[16:13:16.574]                       is.null <- base::is.null
[16:13:16.574]                       muffled <- FALSE
[16:13:16.574]                       if (inherits(cond, "message")) {
[16:13:16.574]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.574]                         if (muffled) 
[16:13:16.574]                           invokeRestart("muffleMessage")
[16:13:16.574]                       }
[16:13:16.574]                       else if (inherits(cond, "warning")) {
[16:13:16.574]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.574]                         if (muffled) 
[16:13:16.574]                           invokeRestart("muffleWarning")
[16:13:16.574]                       }
[16:13:16.574]                       else if (inherits(cond, "condition")) {
[16:13:16.574]                         if (!is.null(pattern)) {
[16:13:16.574]                           computeRestarts <- base::computeRestarts
[16:13:16.574]                           grepl <- base::grepl
[16:13:16.574]                           restarts <- computeRestarts(cond)
[16:13:16.574]                           for (restart in restarts) {
[16:13:16.574]                             name <- restart$name
[16:13:16.574]                             if (is.null(name)) 
[16:13:16.574]                               next
[16:13:16.574]                             if (!grepl(pattern, name)) 
[16:13:16.574]                               next
[16:13:16.574]                             invokeRestart(restart)
[16:13:16.574]                             muffled <- TRUE
[16:13:16.574]                             break
[16:13:16.574]                           }
[16:13:16.574]                         }
[16:13:16.574]                       }
[16:13:16.574]                       invisible(muffled)
[16:13:16.574]                     }
[16:13:16.574]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.574]                   }
[16:13:16.574]                 }
[16:13:16.574]                 else {
[16:13:16.574]                   if (TRUE) {
[16:13:16.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.574]                     {
[16:13:16.574]                       inherits <- base::inherits
[16:13:16.574]                       invokeRestart <- base::invokeRestart
[16:13:16.574]                       is.null <- base::is.null
[16:13:16.574]                       muffled <- FALSE
[16:13:16.574]                       if (inherits(cond, "message")) {
[16:13:16.574]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.574]                         if (muffled) 
[16:13:16.574]                           invokeRestart("muffleMessage")
[16:13:16.574]                       }
[16:13:16.574]                       else if (inherits(cond, "warning")) {
[16:13:16.574]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.574]                         if (muffled) 
[16:13:16.574]                           invokeRestart("muffleWarning")
[16:13:16.574]                       }
[16:13:16.574]                       else if (inherits(cond, "condition")) {
[16:13:16.574]                         if (!is.null(pattern)) {
[16:13:16.574]                           computeRestarts <- base::computeRestarts
[16:13:16.574]                           grepl <- base::grepl
[16:13:16.574]                           restarts <- computeRestarts(cond)
[16:13:16.574]                           for (restart in restarts) {
[16:13:16.574]                             name <- restart$name
[16:13:16.574]                             if (is.null(name)) 
[16:13:16.574]                               next
[16:13:16.574]                             if (!grepl(pattern, name)) 
[16:13:16.574]                               next
[16:13:16.574]                             invokeRestart(restart)
[16:13:16.574]                             muffled <- TRUE
[16:13:16.574]                             break
[16:13:16.574]                           }
[16:13:16.574]                         }
[16:13:16.574]                       }
[16:13:16.574]                       invisible(muffled)
[16:13:16.574]                     }
[16:13:16.574]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.574]                   }
[16:13:16.574]                 }
[16:13:16.574]             }
[16:13:16.574]         }))
[16:13:16.574]     }, error = function(ex) {
[16:13:16.574]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.574]                 ...future.rng), started = ...future.startTime, 
[16:13:16.574]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.574]             version = "1.8"), class = "FutureResult")
[16:13:16.574]     }, finally = {
[16:13:16.574]         if (!identical(...future.workdir, getwd())) 
[16:13:16.574]             setwd(...future.workdir)
[16:13:16.574]         {
[16:13:16.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.574]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.574]             }
[16:13:16.574]             base::options(...future.oldOptions)
[16:13:16.574]             if (.Platform$OS.type == "windows") {
[16:13:16.574]                 old_names <- names(...future.oldEnvVars)
[16:13:16.574]                 envs <- base::Sys.getenv()
[16:13:16.574]                 names <- names(envs)
[16:13:16.574]                 common <- intersect(names, old_names)
[16:13:16.574]                 added <- setdiff(names, old_names)
[16:13:16.574]                 removed <- setdiff(old_names, names)
[16:13:16.574]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.574]                   envs[common]]
[16:13:16.574]                 NAMES <- toupper(changed)
[16:13:16.574]                 args <- list()
[16:13:16.574]                 for (kk in seq_along(NAMES)) {
[16:13:16.574]                   name <- changed[[kk]]
[16:13:16.574]                   NAME <- NAMES[[kk]]
[16:13:16.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.574]                     next
[16:13:16.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.574]                 }
[16:13:16.574]                 NAMES <- toupper(added)
[16:13:16.574]                 for (kk in seq_along(NAMES)) {
[16:13:16.574]                   name <- added[[kk]]
[16:13:16.574]                   NAME <- NAMES[[kk]]
[16:13:16.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.574]                     next
[16:13:16.574]                   args[[name]] <- ""
[16:13:16.574]                 }
[16:13:16.574]                 NAMES <- toupper(removed)
[16:13:16.574]                 for (kk in seq_along(NAMES)) {
[16:13:16.574]                   name <- removed[[kk]]
[16:13:16.574]                   NAME <- NAMES[[kk]]
[16:13:16.574]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.574]                     next
[16:13:16.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.574]                 }
[16:13:16.574]                 if (length(args) > 0) 
[16:13:16.574]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.574]             }
[16:13:16.574]             else {
[16:13:16.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.574]             }
[16:13:16.574]             {
[16:13:16.574]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.574]                   0L) {
[16:13:16.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.574]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.574]                   base::options(opts)
[16:13:16.574]                 }
[16:13:16.574]                 {
[16:13:16.574]                   {
[16:13:16.574]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:16.574]                     NULL
[16:13:16.574]                   }
[16:13:16.574]                   options(future.plan = NULL)
[16:13:16.574]                   if (is.na(NA_character_)) 
[16:13:16.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.574]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:16.574]                     envir = parent.frame()) 
[16:13:16.574]                   {
[16:13:16.574]                     default_workers <- missing(workers)
[16:13:16.574]                     if (is.function(workers)) 
[16:13:16.574]                       workers <- workers()
[16:13:16.574]                     workers <- structure(as.integer(workers), 
[16:13:16.574]                       class = class(workers))
[16:13:16.574]                     stop_if_not(is.finite(workers), workers >= 
[16:13:16.574]                       1L)
[16:13:16.574]                     if ((workers == 1L && !inherits(workers, 
[16:13:16.574]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:16.574]                       if (default_workers) 
[16:13:16.574]                         supportsMulticore(warn = TRUE)
[16:13:16.574]                       return(sequential(..., envir = envir))
[16:13:16.574]                     }
[16:13:16.574]                     oopts <- options(mc.cores = workers)
[16:13:16.574]                     on.exit(options(oopts))
[16:13:16.574]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:16.574]                       envir = envir)
[16:13:16.574]                     if (!future$lazy) 
[16:13:16.574]                       future <- run(future)
[16:13:16.574]                     invisible(future)
[16:13:16.574]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.574]                 }
[16:13:16.574]             }
[16:13:16.574]         }
[16:13:16.574]     })
[16:13:16.574]     if (TRUE) {
[16:13:16.574]         base::sink(type = "output", split = FALSE)
[16:13:16.574]         if (TRUE) {
[16:13:16.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.574]         }
[16:13:16.574]         else {
[16:13:16.574]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.574]         }
[16:13:16.574]         base::close(...future.stdout)
[16:13:16.574]         ...future.stdout <- NULL
[16:13:16.574]     }
[16:13:16.574]     ...future.result$conditions <- ...future.conditions
[16:13:16.574]     ...future.result$finished <- base::Sys.time()
[16:13:16.574]     ...future.result
[16:13:16.574] }
[16:13:16.613]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.577] assign_globals() ...
[16:13:16.613]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.577] List of 3
[16:13:16.577]  $ nested_a:List of 1
[16:13:16.577]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:16.577]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:16.577]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.577]  $ a       : int 1
[16:13:16.577]  $ plan_a  :List of 1
[16:13:16.577]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:16.577]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:16.577]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.577]  - attr(*, "where")=List of 3
[16:13:16.577]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:13:16.577]   ..$ a       :<environment: R_EmptyEnv> 
[16:13:16.577]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:13:16.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.577]  - attr(*, "resolved")= logi FALSE
[16:13:16.577]  - attr(*, "total_size")= num 95240
[16:13:16.577]  - attr(*, "already-done")= logi TRUE
[16:13:16.614]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.583] - copied ‘nested_a’ to environment
[16:13:16.614]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.583] - copied ‘a’ to environment
[16:13:16.614]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.583] - copied ‘plan_a’ to environment
[16:13:16.614]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.583] assign_globals() ... done
[16:13:16.614]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.584] requestCore(): workers = 2
[16:13:16.614]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.587] MulticoreFuture started
[16:13:16.615]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.588] - Launch lazy future ... done
[16:13:16.615]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.588] run() for ‘MulticoreFuture’ ... done
[16:13:16.615] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:16.621] getGlobalsAndPackages() ...
[16:13:16.621] Searching for globals...
[16:13:16.624] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:16.624] Searching for globals ... DONE
[16:13:16.625] Resolving globals: FALSE
[16:13:16.625] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:16.626] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:16.626] - globals: [1] ‘data’
[16:13:16.626] - packages: [1] ‘future’
[16:13:16.626] getGlobalsAndPackages() ... DONE
[16:13:16.626] run() for ‘Future’ ...
[16:13:16.626] - state: ‘created’
[16:13:16.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.627]   - Field: ‘label’
[16:13:16.627]   - Field: ‘local’
[16:13:16.627]   - Field: ‘owner’
[16:13:16.627]   - Field: ‘envir’
[16:13:16.627]   - Field: ‘packages’
[16:13:16.627]   - Field: ‘gc’
[16:13:16.628]   - Field: ‘conditions’
[16:13:16.628]   - Field: ‘expr’
[16:13:16.628]   - Field: ‘uuid’
[16:13:16.628]   - Field: ‘seed’
[16:13:16.628]   - Field: ‘version’
[16:13:16.628]   - Field: ‘result’
[16:13:16.628]   - Field: ‘asynchronous’
[16:13:16.628]   - Field: ‘calls’
[16:13:16.628]   - Field: ‘globals’
[16:13:16.628]   - Field: ‘stdout’
[16:13:16.628]   - Field: ‘earlySignal’
[16:13:16.629]   - Field: ‘lazy’
[16:13:16.629]   - Field: ‘state’
[16:13:16.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.629] - Launch lazy future ...
[16:13:16.629] Packages needed by the future expression (n = 1): ‘future’
[16:13:16.629] Packages needed by future strategies (n = 1): ‘future’
[16:13:16.630] {
[16:13:16.630]     {
[16:13:16.630]         {
[16:13:16.630]             ...future.startTime <- base::Sys.time()
[16:13:16.630]             {
[16:13:16.630]                 {
[16:13:16.630]                   {
[16:13:16.630]                     {
[16:13:16.630]                       base::local({
[16:13:16.630]                         has_future <- base::requireNamespace("future", 
[16:13:16.630]                           quietly = TRUE)
[16:13:16.630]                         if (has_future) {
[16:13:16.630]                           ns <- base::getNamespace("future")
[16:13:16.630]                           version <- ns[[".package"]][["version"]]
[16:13:16.630]                           if (is.null(version)) 
[16:13:16.630]                             version <- utils::packageVersion("future")
[16:13:16.630]                         }
[16:13:16.630]                         else {
[16:13:16.630]                           version <- NULL
[16:13:16.630]                         }
[16:13:16.630]                         if (!has_future || version < "1.8.0") {
[16:13:16.630]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.630]                             "", base::R.version$version.string), 
[16:13:16.630]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.630]                               "release", "version")], collapse = " "), 
[16:13:16.630]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.630]                             info)
[16:13:16.630]                           info <- base::paste(info, collapse = "; ")
[16:13:16.630]                           if (!has_future) {
[16:13:16.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.630]                               info)
[16:13:16.630]                           }
[16:13:16.630]                           else {
[16:13:16.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.630]                               info, version)
[16:13:16.630]                           }
[16:13:16.630]                           base::stop(msg)
[16:13:16.630]                         }
[16:13:16.630]                       })
[16:13:16.630]                     }
[16:13:16.630]                     base::local({
[16:13:16.630]                       for (pkg in "future") {
[16:13:16.630]                         base::loadNamespace(pkg)
[16:13:16.630]                         base::library(pkg, character.only = TRUE)
[16:13:16.630]                       }
[16:13:16.630]                     })
[16:13:16.630]                   }
[16:13:16.630]                   options(future.plan = NULL)
[16:13:16.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.630]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:16.630]                     envir = parent.frame()) 
[16:13:16.630]                   {
[16:13:16.630]                     default_workers <- missing(workers)
[16:13:16.630]                     if (is.function(workers)) 
[16:13:16.630]                       workers <- workers()
[16:13:16.630]                     workers <- structure(as.integer(workers), 
[16:13:16.630]                       class = class(workers))
[16:13:16.630]                     stop_if_not(is.finite(workers), workers >= 
[16:13:16.630]                       1L)
[16:13:16.630]                     if ((workers == 1L && !inherits(workers, 
[16:13:16.630]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:16.630]                       if (default_workers) 
[16:13:16.630]                         supportsMulticore(warn = TRUE)
[16:13:16.630]                       return(sequential(..., envir = envir))
[16:13:16.630]                     }
[16:13:16.630]                     oopts <- options(mc.cores = workers)
[16:13:16.630]                     on.exit(options(oopts))
[16:13:16.630]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:16.630]                       envir = envir)
[16:13:16.630]                     if (!future$lazy) 
[16:13:16.630]                       future <- run(future)
[16:13:16.630]                     invisible(future)
[16:13:16.630]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.630]                 }
[16:13:16.630]                 ...future.workdir <- getwd()
[16:13:16.630]             }
[16:13:16.630]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.630]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.630]         }
[16:13:16.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.630]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.630]             base::names(...future.oldOptions))
[16:13:16.630]     }
[16:13:16.630]     if (FALSE) {
[16:13:16.630]     }
[16:13:16.630]     else {
[16:13:16.630]         if (TRUE) {
[16:13:16.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.630]                 open = "w")
[16:13:16.630]         }
[16:13:16.630]         else {
[16:13:16.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.630]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.630]         }
[16:13:16.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.630]             base::sink(type = "output", split = FALSE)
[16:13:16.630]             base::close(...future.stdout)
[16:13:16.630]         }, add = TRUE)
[16:13:16.630]     }
[16:13:16.630]     ...future.frame <- base::sys.nframe()
[16:13:16.630]     ...future.conditions <- base::list()
[16:13:16.630]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.630]     if (FALSE) {
[16:13:16.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.630]     }
[16:13:16.630]     ...future.result <- base::tryCatch({
[16:13:16.630]         base::withCallingHandlers({
[16:13:16.630]             ...future.value <- base::withVisible(base::local({
[16:13:16.630]                 value(future(subset(data, a == 2)))
[16:13:16.630]             }))
[16:13:16.630]             future::FutureResult(value = ...future.value$value, 
[16:13:16.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.630]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.630]                     ...future.globalenv.names))
[16:13:16.630]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.630]         }, condition = base::local({
[16:13:16.630]             c <- base::c
[16:13:16.630]             inherits <- base::inherits
[16:13:16.630]             invokeRestart <- base::invokeRestart
[16:13:16.630]             length <- base::length
[16:13:16.630]             list <- base::list
[16:13:16.630]             seq.int <- base::seq.int
[16:13:16.630]             signalCondition <- base::signalCondition
[16:13:16.630]             sys.calls <- base::sys.calls
[16:13:16.630]             `[[` <- base::`[[`
[16:13:16.630]             `+` <- base::`+`
[16:13:16.630]             `<<-` <- base::`<<-`
[16:13:16.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.630]                   3L)]
[16:13:16.630]             }
[16:13:16.630]             function(cond) {
[16:13:16.630]                 is_error <- inherits(cond, "error")
[16:13:16.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.630]                   NULL)
[16:13:16.630]                 if (is_error) {
[16:13:16.630]                   sessionInformation <- function() {
[16:13:16.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.630]                       search = base::search(), system = base::Sys.info())
[16:13:16.630]                   }
[16:13:16.630]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.630]                     cond$call), session = sessionInformation(), 
[16:13:16.630]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.630]                   signalCondition(cond)
[16:13:16.630]                 }
[16:13:16.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.630]                 "immediateCondition"))) {
[16:13:16.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.630]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.630]                   if (TRUE && !signal) {
[16:13:16.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.630]                     {
[16:13:16.630]                       inherits <- base::inherits
[16:13:16.630]                       invokeRestart <- base::invokeRestart
[16:13:16.630]                       is.null <- base::is.null
[16:13:16.630]                       muffled <- FALSE
[16:13:16.630]                       if (inherits(cond, "message")) {
[16:13:16.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.630]                         if (muffled) 
[16:13:16.630]                           invokeRestart("muffleMessage")
[16:13:16.630]                       }
[16:13:16.630]                       else if (inherits(cond, "warning")) {
[16:13:16.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.630]                         if (muffled) 
[16:13:16.630]                           invokeRestart("muffleWarning")
[16:13:16.630]                       }
[16:13:16.630]                       else if (inherits(cond, "condition")) {
[16:13:16.630]                         if (!is.null(pattern)) {
[16:13:16.630]                           computeRestarts <- base::computeRestarts
[16:13:16.630]                           grepl <- base::grepl
[16:13:16.630]                           restarts <- computeRestarts(cond)
[16:13:16.630]                           for (restart in restarts) {
[16:13:16.630]                             name <- restart$name
[16:13:16.630]                             if (is.null(name)) 
[16:13:16.630]                               next
[16:13:16.630]                             if (!grepl(pattern, name)) 
[16:13:16.630]                               next
[16:13:16.630]                             invokeRestart(restart)
[16:13:16.630]                             muffled <- TRUE
[16:13:16.630]                             break
[16:13:16.630]                           }
[16:13:16.630]                         }
[16:13:16.630]                       }
[16:13:16.630]                       invisible(muffled)
[16:13:16.630]                     }
[16:13:16.630]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.630]                   }
[16:13:16.630]                 }
[16:13:16.630]                 else {
[16:13:16.630]                   if (TRUE) {
[16:13:16.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.630]                     {
[16:13:16.630]                       inherits <- base::inherits
[16:13:16.630]                       invokeRestart <- base::invokeRestart
[16:13:16.630]                       is.null <- base::is.null
[16:13:16.630]                       muffled <- FALSE
[16:13:16.630]                       if (inherits(cond, "message")) {
[16:13:16.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.630]                         if (muffled) 
[16:13:16.630]                           invokeRestart("muffleMessage")
[16:13:16.630]                       }
[16:13:16.630]                       else if (inherits(cond, "warning")) {
[16:13:16.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.630]                         if (muffled) 
[16:13:16.630]                           invokeRestart("muffleWarning")
[16:13:16.630]                       }
[16:13:16.630]                       else if (inherits(cond, "condition")) {
[16:13:16.630]                         if (!is.null(pattern)) {
[16:13:16.630]                           computeRestarts <- base::computeRestarts
[16:13:16.630]                           grepl <- base::grepl
[16:13:16.630]                           restarts <- computeRestarts(cond)
[16:13:16.630]                           for (restart in restarts) {
[16:13:16.630]                             name <- restart$name
[16:13:16.630]                             if (is.null(name)) 
[16:13:16.630]                               next
[16:13:16.630]                             if (!grepl(pattern, name)) 
[16:13:16.630]                               next
[16:13:16.630]                             invokeRestart(restart)
[16:13:16.630]                             muffled <- TRUE
[16:13:16.630]                             break
[16:13:16.630]                           }
[16:13:16.630]                         }
[16:13:16.630]                       }
[16:13:16.630]                       invisible(muffled)
[16:13:16.630]                     }
[16:13:16.630]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.630]                   }
[16:13:16.630]                 }
[16:13:16.630]             }
[16:13:16.630]         }))
[16:13:16.630]     }, error = function(ex) {
[16:13:16.630]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.630]                 ...future.rng), started = ...future.startTime, 
[16:13:16.630]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.630]             version = "1.8"), class = "FutureResult")
[16:13:16.630]     }, finally = {
[16:13:16.630]         if (!identical(...future.workdir, getwd())) 
[16:13:16.630]             setwd(...future.workdir)
[16:13:16.630]         {
[16:13:16.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.630]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.630]             }
[16:13:16.630]             base::options(...future.oldOptions)
[16:13:16.630]             if (.Platform$OS.type == "windows") {
[16:13:16.630]                 old_names <- names(...future.oldEnvVars)
[16:13:16.630]                 envs <- base::Sys.getenv()
[16:13:16.630]                 names <- names(envs)
[16:13:16.630]                 common <- intersect(names, old_names)
[16:13:16.630]                 added <- setdiff(names, old_names)
[16:13:16.630]                 removed <- setdiff(old_names, names)
[16:13:16.630]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.630]                   envs[common]]
[16:13:16.630]                 NAMES <- toupper(changed)
[16:13:16.630]                 args <- list()
[16:13:16.630]                 for (kk in seq_along(NAMES)) {
[16:13:16.630]                   name <- changed[[kk]]
[16:13:16.630]                   NAME <- NAMES[[kk]]
[16:13:16.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.630]                     next
[16:13:16.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.630]                 }
[16:13:16.630]                 NAMES <- toupper(added)
[16:13:16.630]                 for (kk in seq_along(NAMES)) {
[16:13:16.630]                   name <- added[[kk]]
[16:13:16.630]                   NAME <- NAMES[[kk]]
[16:13:16.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.630]                     next
[16:13:16.630]                   args[[name]] <- ""
[16:13:16.630]                 }
[16:13:16.630]                 NAMES <- toupper(removed)
[16:13:16.630]                 for (kk in seq_along(NAMES)) {
[16:13:16.630]                   name <- removed[[kk]]
[16:13:16.630]                   NAME <- NAMES[[kk]]
[16:13:16.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.630]                     next
[16:13:16.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.630]                 }
[16:13:16.630]                 if (length(args) > 0) 
[16:13:16.630]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.630]             }
[16:13:16.630]             else {
[16:13:16.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.630]             }
[16:13:16.630]             {
[16:13:16.630]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.630]                   0L) {
[16:13:16.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.630]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.630]                   base::options(opts)
[16:13:16.630]                 }
[16:13:16.630]                 {
[16:13:16.630]                   {
[16:13:16.630]                     NULL
[16:13:16.630]                     RNGkind("Mersenne-Twister")
[16:13:16.630]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.630]                       inherits = FALSE)
[16:13:16.630]                   }
[16:13:16.630]                   options(future.plan = NULL)
[16:13:16.630]                   if (is.na(NA_character_)) 
[16:13:16.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.630]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:13:16.630]                   {
[16:13:16.630]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.630]                     if (!future$lazy) 
[16:13:16.630]                       future <- run(future)
[16:13:16.630]                     invisible(future)
[16:13:16.630]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:16.630]                     envir = parent.frame()) 
[16:13:16.630]                   {
[16:13:16.630]                     default_workers <- missing(workers)
[16:13:16.630]                     if (is.function(workers)) 
[16:13:16.630]                       workers <- workers()
[16:13:16.630]                     workers <- structure(as.integer(workers), 
[16:13:16.630]                       class = class(workers))
[16:13:16.630]                     stop_if_not(is.finite(workers), workers >= 
[16:13:16.630]                       1L)
[16:13:16.630]                     if ((workers == 1L && !inherits(workers, 
[16:13:16.630]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:16.630]                       if (default_workers) 
[16:13:16.630]                         supportsMulticore(warn = TRUE)
[16:13:16.630]                       return(sequential(..., envir = envir))
[16:13:16.630]                     }
[16:13:16.630]                     oopts <- options(mc.cores = workers)
[16:13:16.630]                     on.exit(options(oopts))
[16:13:16.630]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:16.630]                       envir = envir)
[16:13:16.630]                     if (!future$lazy) 
[16:13:16.630]                       future <- run(future)
[16:13:16.630]                     invisible(future)
[16:13:16.630]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.630]                 }
[16:13:16.630]             }
[16:13:16.630]         }
[16:13:16.630]     })
[16:13:16.630]     if (TRUE) {
[16:13:16.630]         base::sink(type = "output", split = FALSE)
[16:13:16.630]         if (TRUE) {
[16:13:16.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.630]         }
[16:13:16.630]         else {
[16:13:16.630]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.630]         }
[16:13:16.630]         base::close(...future.stdout)
[16:13:16.630]         ...future.stdout <- NULL
[16:13:16.630]     }
[16:13:16.630]     ...future.result$conditions <- ...future.conditions
[16:13:16.630]     ...future.result$finished <- base::Sys.time()
[16:13:16.630]     ...future.result
[16:13:16.630] }
[16:13:16.632] assign_globals() ...
[16:13:16.632] List of 1
[16:13:16.632]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:16.632]   ..$ a: int [1:3] 1 2 3
[16:13:16.632]   ..$ b: int [1:3] 3 2 1
[16:13:16.632]  - attr(*, "where")=List of 1
[16:13:16.632]   ..$ data:<environment: R_EmptyEnv> 
[16:13:16.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.632]  - attr(*, "resolved")= logi FALSE
[16:13:16.632]  - attr(*, "total_size")= num 128
[16:13:16.632]  - attr(*, "already-done")= logi TRUE
[16:13:16.635] - copied ‘data’ to environment
[16:13:16.635] assign_globals() ... done
[16:13:16.635] plan(): Setting new future strategy stack:
[16:13:16.636] List of future strategies:
[16:13:16.636] 1. multicore:
[16:13:16.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:16.636]    - tweaked: FALSE
[16:13:16.636]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.639] plan(): nbrOfWorkers() = 2
[16:13:16.687] plan(): Setting new future strategy stack:
[16:13:16.687] List of future strategies:
[16:13:16.687] 1. sequential:
[16:13:16.687]    - args: function (..., envir = parent.frame())
[16:13:16.687]    - tweaked: FALSE
[16:13:16.687]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.687] 2. multicore:
[16:13:16.687]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:16.687]    - tweaked: FALSE
[16:13:16.687]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.688] plan(): nbrOfWorkers() = 1
[16:13:16.688] SequentialFuture started (and completed)
[16:13:16.688] signalConditions() ...
[16:13:16.688]  - include = ‘immediateCondition’
[16:13:16.688]  - exclude = 
[16:13:16.689]  - resignal = FALSE
[16:13:16.689]  - Number of conditions: 49
[16:13:16.689] signalConditions() ... done
[16:13:16.689] - Launch lazy future ... done
[16:13:16.689] run() for ‘SequentialFuture’ ... done
[16:13:16.689] signalConditions() ...
[16:13:16.690]  - include = ‘immediateCondition’
[16:13:16.690]  - exclude = 
[16:13:16.690]  - resignal = FALSE
[16:13:16.690]  - Number of conditions: 49
[16:13:16.690] signalConditions() ... done
[16:13:16.690] Future state: ‘finished’
[16:13:16.690] signalConditions() ...
[16:13:16.690]  - include = ‘condition’
[16:13:16.691]  - exclude = ‘immediateCondition’
[16:13:16.691]  - resignal = TRUE
[16:13:16.691]  - Number of conditions: 49
[16:13:16.691]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.640] getGlobalsAndPackages() ...
[16:13:16.691]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.640] Searching for globals...
[16:13:16.691]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.654] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:16.691]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.654] Searching for globals ... DONE
[16:13:16.692]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.655] Resolving globals: FALSE
[16:13:16.692]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.655] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:16.692]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.655] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:16.692]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.655] - globals: [1] ‘data’
[16:13:16.692]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.656] 
[16:13:16.693]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.656] getGlobalsAndPackages() ... DONE
[16:13:16.693]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.656] run() for ‘Future’ ...
[16:13:16.693]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.656] - state: ‘created’
[16:13:16.693]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:16.693]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.660] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:16.693]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:16.694]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.660]   - Field: ‘label’
[16:13:16.694]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.660]   - Field: ‘local’
[16:13:16.694]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.660]   - Field: ‘owner’
[16:13:16.694]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.660]   - Field: ‘envir’
[16:13:16.694]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘workers’
[16:13:16.694]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘packages’
[16:13:16.695]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘gc’
[16:13:16.695]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘job’
[16:13:16.695]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘conditions’
[16:13:16.695]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘expr’
[16:13:16.695]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘uuid’
[16:13:16.695]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘seed’
[16:13:16.696]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘version’
[16:13:16.696]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.661]   - Field: ‘result’
[16:13:16.696]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘asynchronous’
[16:13:16.696]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘calls’
[16:13:16.696]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘globals’
[16:13:16.696]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘stdout’
[16:13:16.697]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘earlySignal’
[16:13:16.697]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘lazy’
[16:13:16.697]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662]   - Field: ‘state’
[16:13:16.697]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:16.697]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.662] - Launch lazy future ...
[16:13:16.697]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.663] Packages needed by the future expression (n = 0): <none>
[16:13:16.698]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.663] Packages needed by future strategies (n = 0): <none>
[16:13:16.698]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.663] {
[16:13:16.663]     {
[16:13:16.663]         {
[16:13:16.663]             ...future.startTime <- base::Sys.time()
[16:13:16.663]             {
[16:13:16.663]                 {
[16:13:16.663]                   {
[16:13:16.663]                     {
[16:13:16.663]                       base::local({
[16:13:16.663]                         has_future <- base::requireNamespace("future", 
[16:13:16.663]                           quietly = TRUE)
[16:13:16.663]                         if (has_future) {
[16:13:16.663]                           ns <- base::getNamespace("future")
[16:13:16.663]                           version <- ns[[".package"]][["version"]]
[16:13:16.663]                           if (is.null(version)) 
[16:13:16.663]                             version <- utils::packageVersion("future")
[16:13:16.663]                         }
[16:13:16.663]                         else {
[16:13:16.663]                           version <- NULL
[16:13:16.663]                         }
[16:13:16.663]                         if (!has_future || version < "1.8.0") {
[16:13:16.663]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.663]                             "", base::R.version$version.string), 
[16:13:16.663]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.663]                               "release", "version")], collapse = " "), 
[16:13:16.663]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.663]                             info)
[16:13:16.663]                           info <- base::paste(info, collapse = "; ")
[16:13:16.663]                           if (!has_future) {
[16:13:16.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.663]                               info)
[16:13:16.663]                           }
[16:13:16.663]                           else {
[16:13:16.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.663]                               info, version)
[16:13:16.663]                           }
[16:13:16.663]                           base::stop(msg)
[16:13:16.663]                         }
[16:13:16.663]                       })
[16:13:16.663]                     }
[16:13:16.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:16.663]                     base::options(mc.cores = 1L)
[16:13:16.663]                   }
[16:13:16.663]                   options(future.plan = NULL)
[16:13:16.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:16.663]                 }
[16:13:16.663]                 ...future.workdir <- getwd()
[16:13:16.663]             }
[16:13:16.663]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.663]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.663]         }
[16:13:16.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.663]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.663]             base::names(...future.oldOptions))
[16:13:16.663]     }
[16:13:16.663]     if (FALSE) {
[16:13:16.663]     }
[16:13:16.663]     else {
[16:13:16.663]         if (TRUE) {
[16:13:16.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.663]                 open = "w")
[16:13:16.663]         }
[16:13:16.663]         else {
[16:13:16.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.663]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.663]         }
[16:13:16.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.663]             base::sink(type = "output", split = FALSE)
[16:13:16.663]             base::close(...future.stdout)
[16:13:16.663]         }, add = TRUE)
[16:13:16.663]     }
[16:13:16.663]     ...future.frame <- base::sys.nframe()
[16:13:16.663]     ...future.conditions <- base::list()
[16:13:16.663]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.663]     if (FALSE) {
[16:13:16.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.663]     }
[16:13:16.663]     ...future.result <- base::tryCatch({
[16:13:16.663]         base::withCallingHandlers({
[16:13:16.663]             ...future.value <- base::withVisible(base::local({
[16:13:16.663]                 withCallingHandlers({
[16:13:16.663]                   subset(data, a == 2)
[16:13:16.663]                 }, immediateCondition = function(cond) {
[16:13:16.663]                   save_rds <- function (object, pathname, ...) 
[16:13:16.663]                   {
[16:13:16.663]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:16.663]                     if (file_test("-f", pathname_tmp)) {
[16:13:16.663]                       fi_tmp <- file.info(pathname_tmp)
[16:13:16.663]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:16.663]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:16.663]                         fi_tmp[["mtime"]])
[16:13:16.663]                     }
[16:13:16.663]                     tryCatch({
[16:13:16.663]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:16.663]                     }, error = function(ex) {
[16:13:16.663]                       msg <- conditionMessage(ex)
[16:13:16.663]                       fi_tmp <- file.info(pathname_tmp)
[16:13:16.663]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:16.663]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:16.663]                         fi_tmp[["mtime"]], msg)
[16:13:16.663]                       ex$message <- msg
[16:13:16.663]                       stop(ex)
[16:13:16.663]                     })
[16:13:16.663]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:16.663]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:16.663]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:16.663]                       fi_tmp <- file.info(pathname_tmp)
[16:13:16.663]                       fi <- file.info(pathname)
[16:13:16.663]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:16.663]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:16.663]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:16.663]                         fi[["size"]], fi[["mtime"]])
[16:13:16.663]                       stop(msg)
[16:13:16.663]                     }
[16:13:16.663]                     invisible(pathname)
[16:13:16.663]                   }
[16:13:16.663]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:16.663]                     rootPath = tempdir()) 
[16:13:16.663]                   {
[16:13:16.663]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:16.663]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:16.663]                       tmpdir = path, fileext = ".rds")
[16:13:16.663]                     save_rds(obj, file)
[16:13:16.663]                   }
[16:13:16.663]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:16.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.663]                   {
[16:13:16.663]                     inherits <- base::inherits
[16:13:16.663]                     invokeRestart <- base::invokeRestart
[16:13:16.663]                     is.null <- base::is.null
[16:13:16.663]                     muffled <- FALSE
[16:13:16.663]                     if (inherits(cond, "message")) {
[16:13:16.663]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:16.663]                       if (muffled) 
[16:13:16.663]                         invokeRestart("muffleMessage")
[16:13:16.663]                     }
[16:13:16.663]                     else if (inherits(cond, "warning")) {
[16:13:16.663]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:16.663]                       if (muffled) 
[16:13:16.663]                         invokeRestart("muffleWarning")
[16:13:16.663]                     }
[16:13:16.663]                     else if (inherits(cond, "condition")) {
[16:13:16.663]                       if (!is.null(pattern)) {
[16:13:16.663]                         computeRestarts <- base::computeRestarts
[16:13:16.663]                         grepl <- base::grepl
[16:13:16.663]                         restarts <- computeRestarts(cond)
[16:13:16.663]                         for (restart in restarts) {
[16:13:16.663]                           name <- restart$name
[16:13:16.663]                           if (is.null(name)) 
[16:13:16.663]                             next
[16:13:16.663]                           if (!grepl(pattern, name)) 
[16:13:16.663]                             next
[16:13:16.663]                           invokeRestart(restart)
[16:13:16.663]                           muffled <- TRUE
[16:13:16.663]                           break
[16:13:16.663]                         }
[16:13:16.663]                       }
[16:13:16.663]                     }
[16:13:16.663]                     invisible(muffled)
[16:13:16.663]                   }
[16:13:16.663]                   muffleCondition(cond)
[16:13:16.663]                 })
[16:13:16.663]             }))
[16:13:16.663]             future::FutureResult(value = ...future.value$value, 
[16:13:16.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.663]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.663]                     ...future.globalenv.names))
[16:13:16.663]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.663]         }, condition = base::local({
[16:13:16.663]             c <- base::c
[16:13:16.663]             inherits <- base::inherits
[16:13:16.663]             invokeRestart <- base::invokeRestart
[16:13:16.663]             length <- base::length
[16:13:16.663]             list <- base::list
[16:13:16.663]             seq.int <- base::seq.int
[16:13:16.663]             signalCondition <- base::signalCondition
[16:13:16.663]             sys.calls <- base::sys.calls
[16:13:16.663]             `[[` <- base::`[[`
[16:13:16.663]             `+` <- base::`+`
[16:13:16.663]             `<<-` <- base::`<<-`
[16:13:16.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.663]                   3L)]
[16:13:16.663]             }
[16:13:16.663]             function(cond) {
[16:13:16.663]                 is_error <- inherits(cond, "error")
[16:13:16.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.663]                   NULL)
[16:13:16.663]                 if (is_error) {
[16:13:16.663]                   sessionInformation <- function() {
[16:13:16.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.663]                       search = base::search(), system = base::Sys.info())
[16:13:16.663]                   }
[16:13:16.663]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.663]                     cond$call), session = sessionInformation(), 
[16:13:16.663]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.663]                   signalCondition(cond)
[16:13:16.663]                 }
[16:13:16.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.663]                 "immediateCondition"))) {
[16:13:16.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.663]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.663]                   if (TRUE && !signal) {
[16:13:16.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.663]                     {
[16:13:16.663]                       inherits <- base::inherits
[16:13:16.663]                       invokeRestart <- base::invokeRestart
[16:13:16.663]                       is.null <- base::is.null
[16:13:16.663]                       muffled <- FALSE
[16:13:16.663]                       if (inherits(cond, "message")) {
[16:13:16.663]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.663]                         if (muffled) 
[16:13:16.663]                           invokeRestart("muffleMessage")
[16:13:16.663]                       }
[16:13:16.663]                       else if (inherits(cond, "warning")) {
[16:13:16.663]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.663]                         if (muffled) 
[16:13:16.663]                           invokeRestart("muffleWarning")
[16:13:16.663]                       }
[16:13:16.663]                       else if (inherits(cond, "condition")) {
[16:13:16.663]                         if (!is.null(pattern)) {
[16:13:16.663]                           computeRestarts <- base::computeRestarts
[16:13:16.663]                           grepl <- base::grepl
[16:13:16.663]                           restarts <- computeRestarts(cond)
[16:13:16.663]                           for (restart in restarts) {
[16:13:16.663]                             name <- restart$name
[16:13:16.663]                             if (is.null(name)) 
[16:13:16.663]                               next
[16:13:16.663]                             if (!grepl(pattern, name)) 
[16:13:16.663]                               next
[16:13:16.663]                             invokeRestart(restart)
[16:13:16.663]                             muffled <- TRUE
[16:13:16.663]                             break
[16:13:16.663]                           }
[16:13:16.663]                         }
[16:13:16.663]                       }
[16:13:16.663]                       invisible(muffled)
[16:13:16.663]                     }
[16:13:16.663]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.663]                   }
[16:13:16.663]                 }
[16:13:16.663]                 else {
[16:13:16.663]                   if (TRUE) {
[16:13:16.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.663]                     {
[16:13:16.663]                       inherits <- base::inherits
[16:13:16.663]                       invokeRestart <- base::invokeRestart
[16:13:16.663]                       is.null <- base::is.null
[16:13:16.663]                       muffled <- FALSE
[16:13:16.663]                       if (inherits(cond, "message")) {
[16:13:16.663]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.663]                         if (muffled) 
[16:13:16.663]                           invokeRestart("muffleMessage")
[16:13:16.663]                       }
[16:13:16.663]                       else if (inherits(cond, "warning")) {
[16:13:16.663]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.663]                         if (muffled) 
[16:13:16.663]                           invokeRestart("muffleWarning")
[16:13:16.663]                       }
[16:13:16.663]                       else if (inherits(cond, "condition")) {
[16:13:16.663]                         if (!is.null(pattern)) {
[16:13:16.663]                           computeRestarts <- base::computeRestarts
[16:13:16.663]                           grepl <- base::grepl
[16:13:16.663]                           restarts <- computeRestarts(cond)
[16:13:16.663]                           for (restart in restarts) {
[16:13:16.663]                             name <- restart$name
[16:13:16.663]                             if (is.null(name)) 
[16:13:16.663]                               next
[16:13:16.663]                             if (!grepl(pattern, name)) 
[16:13:16.663]                               next
[16:13:16.663]                             invokeRestart(restart)
[16:13:16.663]                             muffled <- TRUE
[16:13:16.663]                             break
[16:13:16.663]                           }
[16:13:16.663]                         }
[16:13:16.663]                       }
[16:13:16.663]                       invisible(muffled)
[16:13:16.663]                     }
[16:13:16.663]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.663]                   }
[16:13:16.663]                 }
[16:13:16.663]             }
[16:13:16.663]         }))
[16:13:16.663]     }, error = function(ex) {
[16:13:16.663]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.663]                 ...future.rng), started = ...future.startTime, 
[16:13:16.663]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.663]             version = "1.8"), class = "FutureResult")
[16:13:16.663]     }, finally = {
[16:13:16.663]         if (!identical(...future.workdir, getwd())) 
[16:13:16.663]             setwd(...future.workdir)
[16:13:16.663]         {
[16:13:16.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.663]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.663]             }
[16:13:16.663]             base::options(...future.oldOptions)
[16:13:16.663]             if (.Platform$OS.type == "windows") {
[16:13:16.663]                 old_names <- names(...future.oldEnvVars)
[16:13:16.663]                 envs <- base::Sys.getenv()
[16:13:16.663]                 names <- names(envs)
[16:13:16.663]                 common <- intersect(names, old_names)
[16:13:16.663]                 added <- setdiff(names, old_names)
[16:13:16.663]                 removed <- setdiff(old_names, names)
[16:13:16.663]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.663]                   envs[common]]
[16:13:16.663]                 NAMES <- toupper(changed)
[16:13:16.663]                 args <- list()
[16:13:16.663]                 for (kk in seq_along(NAMES)) {
[16:13:16.663]                   name <- changed[[kk]]
[16:13:16.663]                   NAME <- NAMES[[kk]]
[16:13:16.663]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.663]                     next
[16:13:16.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.663]                 }
[16:13:16.663]                 NAMES <- toupper(added)
[16:13:16.663]                 for (kk in seq_along(NAMES)) {
[16:13:16.663]                   name <- added[[kk]]
[16:13:16.663]                   NAME <- NAMES[[kk]]
[16:13:16.663]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.663]                     next
[16:13:16.663]                   args[[name]] <- ""
[16:13:16.663]                 }
[16:13:16.663]                 NAMES <- toupper(removed)
[16:13:16.663]                 for (kk in seq_along(NAMES)) {
[16:13:16.663]                   name <- removed[[kk]]
[16:13:16.663]                   NAME <- NAMES[[kk]]
[16:13:16.663]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.663]                     next
[16:13:16.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.663]                 }
[16:13:16.663]                 if (length(args) > 0) 
[16:13:16.663]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.663]             }
[16:13:16.663]             else {
[16:13:16.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.663]             }
[16:13:16.663]             {
[16:13:16.663]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.663]                   0L) {
[16:13:16.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.663]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.663]                   base::options(opts)
[16:13:16.663]                 }
[16:13:16.663]                 {
[16:13:16.663]                   {
[16:13:16.663]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:16.663]                     NULL
[16:13:16.663]                   }
[16:13:16.663]                   options(future.plan = NULL)
[16:13:16.663]                   if (is.na(NA_character_)) 
[16:13:16.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.663]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:16.663]                     envir = parent.frame()) 
[16:13:16.663]                   {
[16:13:16.663]                     default_workers <- missing(workers)
[16:13:16.663]                     if (is.function(workers)) 
[16:13:16.663]                       workers <- workers()
[16:13:16.663]                     workers <- structure(as.integer(workers), 
[16:13:16.663]                       class = class(workers))
[16:13:16.663]                     stop_if_not(is.finite(workers), workers >= 
[16:13:16.663]                       1L)
[16:13:16.663]                     if ((workers == 1L && !inherits(workers, 
[16:13:16.663]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:16.663]                       if (default_workers) 
[16:13:16.663]                         supportsMulticore(warn = TRUE)
[16:13:16.663]                       return(sequential(..., envir = envir))
[16:13:16.663]                     }
[16:13:16.663]                     oopts <- options(mc.cores = workers)
[16:13:16.663]                     on.exit(options(oopts))
[16:13:16.663]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:16.663]                       envir = envir)
[16:13:16.663]                     if (!future$lazy) 
[16:13:16.663]                       future <- run(future)
[16:13:16.663]                     invisible(future)
[16:13:16.663]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.663]                 }
[16:13:16.663]             }
[16:13:16.663]         }
[16:13:16.663]     })
[16:13:16.663]     if (TRUE) {
[16:13:16.663]         base::sink(type = "output", split = FALSE)
[16:13:16.663]         if (TRUE) {
[16:13:16.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.663]         }
[16:13:16.663]         else {
[16:13:16.663]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.663]         }
[16:13:16.663]         base::close(...future.stdout)
[16:13:16.663]         ...future.stdout <- NULL
[16:13:16.663]     }
[16:13:16.663]     ...future.result$conditions <- ...future.conditions
[16:13:16.663]     ...future.result$finished <- base::Sys.time()
[16:13:16.663]     ...future.result
[16:13:16.663] }
[16:13:16.698]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.665] assign_globals() ...
[16:13:16.698]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.666] List of 1
[16:13:16.666]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:16.666]   ..$ a: int [1:3] 1 2 3
[16:13:16.666]   ..$ b: int [1:3] 3 2 1
[16:13:16.666]  - attr(*, "where")=List of 1
[16:13:16.666]   ..$ data:<environment: R_EmptyEnv> 
[16:13:16.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.666]  - attr(*, "resolved")= logi FALSE
[16:13:16.666]  - attr(*, "total_size")= num 128
[16:13:16.666]  - attr(*, "already-done")= logi TRUE
[16:13:16.698]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.669] - copied ‘data’ to environment
[16:13:16.698]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.669] assign_globals() ... done
[16:13:16.699]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.669] requestCore(): workers = 2
[16:13:16.699]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.671] MulticoreFuture started
[16:13:16.699]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.672] - Launch lazy future ... done
[16:13:16.699]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.672] run() for ‘MulticoreFuture’ ... done
[16:13:16.699] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[16:13:16.700] plan(): Setting new future strategy stack:
[16:13:16.700] List of future strategies:
[16:13:16.700] 1. sequential:
[16:13:16.700]    - args: function (..., envir = parent.frame())
[16:13:16.700]    - tweaked: FALSE
[16:13:16.700]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.700] 2. multisession:
[16:13:16.700]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:16.700]    - tweaked: FALSE
[16:13:16.700]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.701] plan(): nbrOfWorkers() = 1
[16:13:16.701] getGlobalsAndPackages() ...
[16:13:16.701] Searching for globals...
[16:13:16.720] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:16.720] Searching for globals ... DONE
[16:13:16.720] Resolving globals: FALSE
[16:13:16.721] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[16:13:16.722] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:16.722] - globals: [2] ‘nested’, ‘strategy2’
[16:13:16.722] - packages: [1] ‘future’
[16:13:16.722] getGlobalsAndPackages() ... DONE
[16:13:16.723] run() for ‘Future’ ...
[16:13:16.723] - state: ‘created’
[16:13:16.723] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:16.723] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:16.723] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:16.723]   - Field: ‘label’
[16:13:16.723]   - Field: ‘local’
[16:13:16.724]   - Field: ‘owner’
[16:13:16.724]   - Field: ‘envir’
[16:13:16.724]   - Field: ‘packages’
[16:13:16.724]   - Field: ‘gc’
[16:13:16.724]   - Field: ‘conditions’
[16:13:16.724]   - Field: ‘expr’
[16:13:16.724]   - Field: ‘uuid’
[16:13:16.724]   - Field: ‘seed’
[16:13:16.724]   - Field: ‘version’
[16:13:16.724]   - Field: ‘result’
[16:13:16.725]   - Field: ‘asynchronous’
[16:13:16.725]   - Field: ‘calls’
[16:13:16.725]   - Field: ‘globals’
[16:13:16.725]   - Field: ‘stdout’
[16:13:16.725]   - Field: ‘earlySignal’
[16:13:16.725]   - Field: ‘lazy’
[16:13:16.725]   - Field: ‘state’
[16:13:16.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:16.727] - Launch lazy future ...
[16:13:16.727] Packages needed by the future expression (n = 1): ‘future’
[16:13:16.727] Packages needed by future strategies (n = 1): ‘future’
[16:13:16.728] {
[16:13:16.728]     {
[16:13:16.728]         {
[16:13:16.728]             ...future.startTime <- base::Sys.time()
[16:13:16.728]             {
[16:13:16.728]                 {
[16:13:16.728]                   {
[16:13:16.728]                     {
[16:13:16.728]                       base::local({
[16:13:16.728]                         has_future <- base::requireNamespace("future", 
[16:13:16.728]                           quietly = TRUE)
[16:13:16.728]                         if (has_future) {
[16:13:16.728]                           ns <- base::getNamespace("future")
[16:13:16.728]                           version <- ns[[".package"]][["version"]]
[16:13:16.728]                           if (is.null(version)) 
[16:13:16.728]                             version <- utils::packageVersion("future")
[16:13:16.728]                         }
[16:13:16.728]                         else {
[16:13:16.728]                           version <- NULL
[16:13:16.728]                         }
[16:13:16.728]                         if (!has_future || version < "1.8.0") {
[16:13:16.728]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:16.728]                             "", base::R.version$version.string), 
[16:13:16.728]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:16.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:16.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:16.728]                               "release", "version")], collapse = " "), 
[16:13:16.728]                             hostname = base::Sys.info()[["nodename"]])
[16:13:16.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:16.728]                             info)
[16:13:16.728]                           info <- base::paste(info, collapse = "; ")
[16:13:16.728]                           if (!has_future) {
[16:13:16.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:16.728]                               info)
[16:13:16.728]                           }
[16:13:16.728]                           else {
[16:13:16.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:16.728]                               info, version)
[16:13:16.728]                           }
[16:13:16.728]                           base::stop(msg)
[16:13:16.728]                         }
[16:13:16.728]                       })
[16:13:16.728]                     }
[16:13:16.728]                     base::local({
[16:13:16.728]                       for (pkg in "future") {
[16:13:16.728]                         base::loadNamespace(pkg)
[16:13:16.728]                         base::library(pkg, character.only = TRUE)
[16:13:16.728]                       }
[16:13:16.728]                     })
[16:13:16.728]                   }
[16:13:16.728]                   options(future.plan = NULL)
[16:13:16.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.728]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:16.728]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:16.728]                     envir = parent.frame()) 
[16:13:16.728]                   {
[16:13:16.728]                     if (is.function(workers)) 
[16:13:16.728]                       workers <- workers()
[16:13:16.728]                     workers <- structure(as.integer(workers), 
[16:13:16.728]                       class = class(workers))
[16:13:16.728]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:16.728]                       workers >= 1)
[16:13:16.728]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:16.728]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:16.728]                     }
[16:13:16.728]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:16.728]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:16.728]                       envir = envir)
[16:13:16.728]                     if (!future$lazy) 
[16:13:16.728]                       future <- run(future)
[16:13:16.728]                     invisible(future)
[16:13:16.728]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.728]                 }
[16:13:16.728]                 ...future.workdir <- getwd()
[16:13:16.728]             }
[16:13:16.728]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:16.728]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:16.728]         }
[16:13:16.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:16.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:16.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:16.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:16.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:16.728]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:16.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:16.728]             base::names(...future.oldOptions))
[16:13:16.728]     }
[16:13:16.728]     if (FALSE) {
[16:13:16.728]     }
[16:13:16.728]     else {
[16:13:16.728]         if (TRUE) {
[16:13:16.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:16.728]                 open = "w")
[16:13:16.728]         }
[16:13:16.728]         else {
[16:13:16.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:16.728]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:16.728]         }
[16:13:16.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:16.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:16.728]             base::sink(type = "output", split = FALSE)
[16:13:16.728]             base::close(...future.stdout)
[16:13:16.728]         }, add = TRUE)
[16:13:16.728]     }
[16:13:16.728]     ...future.frame <- base::sys.nframe()
[16:13:16.728]     ...future.conditions <- base::list()
[16:13:16.728]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:16.728]     if (FALSE) {
[16:13:16.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:16.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:16.728]     }
[16:13:16.728]     ...future.result <- base::tryCatch({
[16:13:16.728]         base::withCallingHandlers({
[16:13:16.728]             ...future.value <- base::withVisible(base::local({
[16:13:16.728]                 a <- 1L
[16:13:16.728]                 plan_a <- unclass(future::plan("list"))
[16:13:16.728]                 nested_a <- nested[-1]
[16:13:16.728]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:16.728]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.728]                   strategy2))
[16:13:16.728]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:16.728]                   "init") <- NULL
[16:13:16.728]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:16.728]                   "init") <- NULL
[16:13:16.728]                 stopifnot(all.equal(plan_a, nested_a))
[16:13:16.728]                 y %<-% {
[16:13:16.728]                   b <- 2L
[16:13:16.728]                   plan_b <- future::plan("list")
[16:13:16.728]                   nested_b <- nested_a[-1]
[16:13:16.728]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:16.728]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:16.728]                     "sequential"))
[16:13:16.728]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:16.728]                     b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:16.728]                 }
[16:13:16.728]                 y
[16:13:16.728]             }))
[16:13:16.728]             future::FutureResult(value = ...future.value$value, 
[16:13:16.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.728]                   ...future.rng), globalenv = if (FALSE) 
[16:13:16.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:16.728]                     ...future.globalenv.names))
[16:13:16.728]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:16.728]         }, condition = base::local({
[16:13:16.728]             c <- base::c
[16:13:16.728]             inherits <- base::inherits
[16:13:16.728]             invokeRestart <- base::invokeRestart
[16:13:16.728]             length <- base::length
[16:13:16.728]             list <- base::list
[16:13:16.728]             seq.int <- base::seq.int
[16:13:16.728]             signalCondition <- base::signalCondition
[16:13:16.728]             sys.calls <- base::sys.calls
[16:13:16.728]             `[[` <- base::`[[`
[16:13:16.728]             `+` <- base::`+`
[16:13:16.728]             `<<-` <- base::`<<-`
[16:13:16.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:16.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:16.728]                   3L)]
[16:13:16.728]             }
[16:13:16.728]             function(cond) {
[16:13:16.728]                 is_error <- inherits(cond, "error")
[16:13:16.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:16.728]                   NULL)
[16:13:16.728]                 if (is_error) {
[16:13:16.728]                   sessionInformation <- function() {
[16:13:16.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:16.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:16.728]                       search = base::search(), system = base::Sys.info())
[16:13:16.728]                   }
[16:13:16.728]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:16.728]                     cond$call), session = sessionInformation(), 
[16:13:16.728]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:16.728]                   signalCondition(cond)
[16:13:16.728]                 }
[16:13:16.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:16.728]                 "immediateCondition"))) {
[16:13:16.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:16.728]                   ...future.conditions[[length(...future.conditions) + 
[16:13:16.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:16.728]                   if (TRUE && !signal) {
[16:13:16.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.728]                     {
[16:13:16.728]                       inherits <- base::inherits
[16:13:16.728]                       invokeRestart <- base::invokeRestart
[16:13:16.728]                       is.null <- base::is.null
[16:13:16.728]                       muffled <- FALSE
[16:13:16.728]                       if (inherits(cond, "message")) {
[16:13:16.728]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.728]                         if (muffled) 
[16:13:16.728]                           invokeRestart("muffleMessage")
[16:13:16.728]                       }
[16:13:16.728]                       else if (inherits(cond, "warning")) {
[16:13:16.728]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.728]                         if (muffled) 
[16:13:16.728]                           invokeRestart("muffleWarning")
[16:13:16.728]                       }
[16:13:16.728]                       else if (inherits(cond, "condition")) {
[16:13:16.728]                         if (!is.null(pattern)) {
[16:13:16.728]                           computeRestarts <- base::computeRestarts
[16:13:16.728]                           grepl <- base::grepl
[16:13:16.728]                           restarts <- computeRestarts(cond)
[16:13:16.728]                           for (restart in restarts) {
[16:13:16.728]                             name <- restart$name
[16:13:16.728]                             if (is.null(name)) 
[16:13:16.728]                               next
[16:13:16.728]                             if (!grepl(pattern, name)) 
[16:13:16.728]                               next
[16:13:16.728]                             invokeRestart(restart)
[16:13:16.728]                             muffled <- TRUE
[16:13:16.728]                             break
[16:13:16.728]                           }
[16:13:16.728]                         }
[16:13:16.728]                       }
[16:13:16.728]                       invisible(muffled)
[16:13:16.728]                     }
[16:13:16.728]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.728]                   }
[16:13:16.728]                 }
[16:13:16.728]                 else {
[16:13:16.728]                   if (TRUE) {
[16:13:16.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:16.728]                     {
[16:13:16.728]                       inherits <- base::inherits
[16:13:16.728]                       invokeRestart <- base::invokeRestart
[16:13:16.728]                       is.null <- base::is.null
[16:13:16.728]                       muffled <- FALSE
[16:13:16.728]                       if (inherits(cond, "message")) {
[16:13:16.728]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:16.728]                         if (muffled) 
[16:13:16.728]                           invokeRestart("muffleMessage")
[16:13:16.728]                       }
[16:13:16.728]                       else if (inherits(cond, "warning")) {
[16:13:16.728]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:16.728]                         if (muffled) 
[16:13:16.728]                           invokeRestart("muffleWarning")
[16:13:16.728]                       }
[16:13:16.728]                       else if (inherits(cond, "condition")) {
[16:13:16.728]                         if (!is.null(pattern)) {
[16:13:16.728]                           computeRestarts <- base::computeRestarts
[16:13:16.728]                           grepl <- base::grepl
[16:13:16.728]                           restarts <- computeRestarts(cond)
[16:13:16.728]                           for (restart in restarts) {
[16:13:16.728]                             name <- restart$name
[16:13:16.728]                             if (is.null(name)) 
[16:13:16.728]                               next
[16:13:16.728]                             if (!grepl(pattern, name)) 
[16:13:16.728]                               next
[16:13:16.728]                             invokeRestart(restart)
[16:13:16.728]                             muffled <- TRUE
[16:13:16.728]                             break
[16:13:16.728]                           }
[16:13:16.728]                         }
[16:13:16.728]                       }
[16:13:16.728]                       invisible(muffled)
[16:13:16.728]                     }
[16:13:16.728]                     muffleCondition(cond, pattern = "^muffle")
[16:13:16.728]                   }
[16:13:16.728]                 }
[16:13:16.728]             }
[16:13:16.728]         }))
[16:13:16.728]     }, error = function(ex) {
[16:13:16.728]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:16.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:16.728]                 ...future.rng), started = ...future.startTime, 
[16:13:16.728]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:16.728]             version = "1.8"), class = "FutureResult")
[16:13:16.728]     }, finally = {
[16:13:16.728]         if (!identical(...future.workdir, getwd())) 
[16:13:16.728]             setwd(...future.workdir)
[16:13:16.728]         {
[16:13:16.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:16.728]                 ...future.oldOptions$nwarnings <- NULL
[16:13:16.728]             }
[16:13:16.728]             base::options(...future.oldOptions)
[16:13:16.728]             if (.Platform$OS.type == "windows") {
[16:13:16.728]                 old_names <- names(...future.oldEnvVars)
[16:13:16.728]                 envs <- base::Sys.getenv()
[16:13:16.728]                 names <- names(envs)
[16:13:16.728]                 common <- intersect(names, old_names)
[16:13:16.728]                 added <- setdiff(names, old_names)
[16:13:16.728]                 removed <- setdiff(old_names, names)
[16:13:16.728]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:16.728]                   envs[common]]
[16:13:16.728]                 NAMES <- toupper(changed)
[16:13:16.728]                 args <- list()
[16:13:16.728]                 for (kk in seq_along(NAMES)) {
[16:13:16.728]                   name <- changed[[kk]]
[16:13:16.728]                   NAME <- NAMES[[kk]]
[16:13:16.728]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.728]                     next
[16:13:16.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.728]                 }
[16:13:16.728]                 NAMES <- toupper(added)
[16:13:16.728]                 for (kk in seq_along(NAMES)) {
[16:13:16.728]                   name <- added[[kk]]
[16:13:16.728]                   NAME <- NAMES[[kk]]
[16:13:16.728]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.728]                     next
[16:13:16.728]                   args[[name]] <- ""
[16:13:16.728]                 }
[16:13:16.728]                 NAMES <- toupper(removed)
[16:13:16.728]                 for (kk in seq_along(NAMES)) {
[16:13:16.728]                   name <- removed[[kk]]
[16:13:16.728]                   NAME <- NAMES[[kk]]
[16:13:16.728]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:16.728]                     next
[16:13:16.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:16.728]                 }
[16:13:16.728]                 if (length(args) > 0) 
[16:13:16.728]                   base::do.call(base::Sys.setenv, args = args)
[16:13:16.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:16.728]             }
[16:13:16.728]             else {
[16:13:16.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:16.728]             }
[16:13:16.728]             {
[16:13:16.728]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:16.728]                   0L) {
[16:13:16.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:16.728]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:16.728]                   base::options(opts)
[16:13:16.728]                 }
[16:13:16.728]                 {
[16:13:16.728]                   {
[16:13:16.728]                     NULL
[16:13:16.728]                     RNGkind("Mersenne-Twister")
[16:13:16.728]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:16.728]                       inherits = FALSE)
[16:13:16.728]                   }
[16:13:16.728]                   options(future.plan = NULL)
[16:13:16.728]                   if (is.na(NA_character_)) 
[16:13:16.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:16.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:16.728]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:13:16.728]                   {
[16:13:16.728]                     future <- SequentialFuture(..., envir = envir)
[16:13:16.728]                     if (!future$lazy) 
[16:13:16.728]                       future <- run(future)
[16:13:16.728]                     invisible(future)
[16:13:16.728]                   }, b = function (..., workers = availableCores(), 
[16:13:16.728]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:16.728]                     envir = parent.frame()) 
[16:13:16.728]                   {
[16:13:16.728]                     if (is.function(workers)) 
[16:13:16.728]                       workers <- workers()
[16:13:16.728]                     workers <- structure(as.integer(workers), 
[16:13:16.728]                       class = class(workers))
[16:13:16.728]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:16.728]                       workers >= 1)
[16:13:16.728]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:16.728]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:16.728]                     }
[16:13:16.728]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:16.728]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:16.728]                       envir = envir)
[16:13:16.728]                     if (!future$lazy) 
[16:13:16.728]                       future <- run(future)
[16:13:16.728]                     invisible(future)
[16:13:16.728]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:16.728]                 }
[16:13:16.728]             }
[16:13:16.728]         }
[16:13:16.728]     })
[16:13:16.728]     if (TRUE) {
[16:13:16.728]         base::sink(type = "output", split = FALSE)
[16:13:16.728]         if (TRUE) {
[16:13:16.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:16.728]         }
[16:13:16.728]         else {
[16:13:16.728]             ...future.result["stdout"] <- base::list(NULL)
[16:13:16.728]         }
[16:13:16.728]         base::close(...future.stdout)
[16:13:16.728]         ...future.stdout <- NULL
[16:13:16.728]     }
[16:13:16.728]     ...future.result$conditions <- ...future.conditions
[16:13:16.728]     ...future.result$finished <- base::Sys.time()
[16:13:16.728]     ...future.result
[16:13:16.728] }
[16:13:16.730] assign_globals() ...
[16:13:16.730] List of 2
[16:13:16.730]  $ nested   :List of 2
[16:13:16.730]   ..$ a:function (..., envir = parent.frame())  
[16:13:16.730]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:16.730]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.730]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:16.730]     envir = parent.frame())  
[16:13:16.730]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:13:16.730]   .. ..- attr(*, "init")= logi TRUE
[16:13:16.730]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:13:16.730]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:16.730]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:16.730]  $ strategy2: chr "multisession"
[16:13:16.730]  - attr(*, "where")=List of 2
[16:13:16.730]   ..$ nested   :<environment: R_EmptyEnv> 
[16:13:16.730]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:13:16.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:16.730]  - attr(*, "resolved")= logi FALSE
[16:13:16.730]  - attr(*, "total_size")= num 56736
[16:13:16.730]  - attr(*, "already-done")= logi TRUE
[16:13:16.735] - copied ‘nested’ to environment
[16:13:16.735] - copied ‘strategy2’ to environment
[16:13:16.735] assign_globals() ... done
[16:13:16.736] plan(): Setting new future strategy stack:
[16:13:16.736] List of future strategies:
[16:13:16.736] 1. multisession:
[16:13:16.736]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:16.736]    - tweaked: FALSE
[16:13:16.736]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:16.739] plan(): nbrOfWorkers() = 2
[16:13:17.491] plan(): Setting new future strategy stack:
[16:13:17.491] List of future strategies:
[16:13:17.491] 1. sequential:
[16:13:17.491]    - args: function (..., envir = parent.frame())
[16:13:17.491]    - tweaked: FALSE
[16:13:17.491]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.491] 2. multisession:
[16:13:17.491]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:17.491]    - tweaked: FALSE
[16:13:17.491]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.492] plan(): nbrOfWorkers() = 1
[16:13:17.492] SequentialFuture started (and completed)
[16:13:17.492] signalConditions() ...
[16:13:17.493]  - include = ‘immediateCondition’
[16:13:17.493]  - exclude = 
[16:13:17.493]  - resignal = FALSE
[16:13:17.493]  - Number of conditions: 97
[16:13:17.493] signalConditions() ... done
[16:13:17.493] - Launch lazy future ... done
[16:13:17.493] run() for ‘SequentialFuture’ ... done
[16:13:17.494] signalConditions() ...
[16:13:17.494]  - include = ‘immediateCondition’
[16:13:17.494]  - exclude = 
[16:13:17.494]  - resignal = FALSE
[16:13:17.494]  - Number of conditions: 97
[16:13:17.494] signalConditions() ... done
[16:13:17.494] Future state: ‘finished’
[16:13:17.495] signalConditions() ...
[16:13:17.495]  - include = ‘condition’
[16:13:17.495]  - exclude = ‘immediateCondition’
[16:13:17.495]  - resignal = TRUE
[16:13:17.495]  - Number of conditions: 97
[16:13:17.495]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.741] getGlobalsAndPackages() ...
[16:13:17.495]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.741] Searching for globals...
[16:13:17.495]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.759] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:13:17.496]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.759] Searching for globals ... DONE
[16:13:17.496]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.759] Resolving globals: FALSE
[16:13:17.496]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.760] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[16:13:17.496]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.760] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:13:17.496]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.761] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:13:17.497]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.761] 
[16:13:17.497]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.761] getGlobalsAndPackages() ... DONE
[16:13:17.497]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.761] run() for ‘Future’ ...
[16:13:17.497]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.761] - state: ‘created’
[16:13:17.497]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.497]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.767] [local output] makeClusterPSOCK() ...
[16:13:17.498]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.819] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:17.498]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.824] [local output] Base port: 11975
[16:13:17.498]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.825] [local output] Getting setup options for 2 cluster nodes ...
[16:13:17.498]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.825] [local output]  - Node 1 of 2 ...
[16:13:17.498]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.825] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:17.498]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:16.826] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b567fa4d46d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b567fa4d46d.pid")'’
[16:13:17.499]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.013] - Possible to infer worker's PID: TRUE
[16:13:17.499]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.013] [local output] Rscript port: 11975

[16:13:17.499]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.013] [local output]  - Node 2 of 2 ...
[16:13:17.499]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.014] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:17.499]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.014] [local output] Rscript port: 11975

[16:13:17.499]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.015] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:17.500]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.015] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:17.500]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.015] [local output] Setting up PSOCK nodes in parallel
[16:13:17.500]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.016] List of 36
[16:13:17.016]  $ worker          : chr "localhost"
[16:13:17.016]   ..- attr(*, "localhost")= logi TRUE
[16:13:17.016]  $ master          : chr "localhost"
[16:13:17.016]  $ port            : int 11975
[16:13:17.016]  $ connectTimeout  : num 120
[16:13:17.016]  $ timeout         : num 2592000
[16:13:17.016]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:17.016]  $ homogeneous     : logi TRUE
[16:13:17.016]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:17.016]  $ rscript_envs    : NULL
[16:13:17.016]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:17.016]  $ rscript_startup : NULL
[16:13:17.016]  $ rscript_sh      : chr "sh"
[16:13:17.016]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:17.016]  $ methods         : logi TRUE
[16:13:17.016]  $ socketOptions   : chr "no-delay"
[16:13:17.016]  $ useXDR          : logi FALSE
[16:13:17.016]  $ outfile         : chr "/dev/null"
[16:13:17.016]  $ renice          : int NA
[16:13:17.016]  $ rshcmd          : NULL
[16:13:17.016]  $ user            : chr(0) 
[16:13:17.016]  $ revtunnel       : logi FALSE
[16:13:17.016]  $ rshlogfile      : NULL
[16:13:17.016]  $ rshopts         : chr(0) 
[16:13:17.016]  $ rank            : int 1
[16:13:17.016]  $ manual          : logi FALSE
[16:13:17.016]  $ dryrun          : logi FALSE
[16:13:17.016]  $ quiet           : logi FALSE
[16:13:17.016]  $ setup_strategy  : chr "parallel"
[16:13:17.016]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:17.016]  $ pidfile         : chr "/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b567fa4d46d.pid"
[16:13:17.016]  $ rshcmd_label    : NULL
[16:13:17.016]  $ rsh_call        : NULL
[16:13:17.016]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:17.016]  $ localMachine    : logi TRUE
[16:13:17.016]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:17.016]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:17.016]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:17.016]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:17.016]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:17.016]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:17.016]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:17.016]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:17.016]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:17.016]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:17.016]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:17.016]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:17.016]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:17.016]  $ arguments       :List of 28
[16:13:17.016]   ..$ worker          : chr "localhost"
[16:13:17.016]   ..$ master          : NULL
[16:13:17.016]   ..$ port            : int 11975
[16:13:17.016]   ..$ connectTimeout  : num 120
[16:13:17.016]   ..$ timeout         : num 2592000
[16:13:17.016]   ..$ rscript         : NULL
[16:13:17.016]   ..$ homogeneous     : NULL
[16:13:17.016]   ..$ rscript_args    : NULL
[16:13:17.016]   ..$ rscript_envs    : NULL
[16:13:17.016]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:17.016]   ..$ rscript_startup : NULL
[16:13:17.016]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:17.016]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:17.016]   ..$ methods         : logi TRUE
[16:13:17.016]   ..$ socketOptions   : chr "no-delay"
[16:13:17.016]   ..$ useXDR          : logi FALSE
[16:13:17.016]   ..$ outfile         : chr "/dev/null"
[16:13:17.016]   ..$ renice          : int NA
[16:13:17.016]   ..$ rshcmd          : NULL
[16:13:17.016]   ..$ user            : NULL
[16:13:17.016]   ..$ revtunnel       : logi NA
[16:13:17.016]   ..$ rshlogfile      : NULL
[16:13:17.016]   ..$ rshopts         : NULL
[16:13:17.016]   ..$ rank            : int 1
[16:13:17.016]   ..$ manual          : logi FALSE
[16:13:17.016]   ..$ dryrun          : logi FALSE
[16:13:17.016]   ..$ quiet           : logi FALSE
[16:13:17.016]   ..$ setup_strategy  : chr "parallel"
[16:13:17.016]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:17.500]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.032] [local output] System call to launch all workers:
[16:13:17.500]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.033] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b567fa4d46d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11975 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:17.500]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.033] [local output] Starting PSOCK main server
[16:13:17.501]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.034] [local output] Workers launched
[16:13:17.501]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.034] [local output] Waiting for workers to connect back
[16:13:17.501]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.034]  - [local output] 0 workers out of 2 ready
[16:13:17.501]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.277]  - [local output] 0 workers out of 2 ready
[16:13:17.501]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.277]  - [local output] 1 workers out of 2 ready
[16:13:17.501]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.278]  - [local output] 2 workers out of 2 ready
[16:13:17.502]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.278] [local output] Launching of workers completed
[16:13:17.502]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.278] [local output] Collecting session information from workers
[16:13:17.502]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.279] [local output]  - Worker #1 of 2
[16:13:17.502]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.279] [local output]  - Worker #2 of 2
[16:13:17.502]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.279] [local output] makeClusterPSOCK() ... done
[16:13:17.502]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.291] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:17.503]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:17.503]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.291]   - Field: ‘node’
[16:13:17.503]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.291]   - Field: ‘label’
[16:13:17.503]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.291]   - Field: ‘local’
[16:13:17.503]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.291]   - Field: ‘owner’
[16:13:17.503]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘envir’
[16:13:17.504]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘workers’
[16:13:17.504]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘packages’
[16:13:17.504]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘gc’
[16:13:17.504]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘conditions’
[16:13:17.504]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘persistent’
[16:13:17.504]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.292]   - Field: ‘expr’
[16:13:17.505]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘uuid’
[16:13:17.505]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘seed’
[16:13:17.505]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘version’
[16:13:17.505]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘result’
[16:13:17.505]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘asynchronous’
[16:13:17.505]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘calls’
[16:13:17.506]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.293]   - Field: ‘globals’
[16:13:17.506]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.294]   - Field: ‘stdout’
[16:13:17.506]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.294]   - Field: ‘earlySignal’
[16:13:17.506]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.294]   - Field: ‘lazy’
[16:13:17.506]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.294]   - Field: ‘state’
[16:13:17.506]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:17.507]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.294] - Launch lazy future ...
[16:13:17.507]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.295] Packages needed by the future expression (n = 0): <none>
[16:13:17.507]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.295] Packages needed by future strategies (n = 0): <none>
[16:13:17.507]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.296] {
[16:13:17.296]     {
[16:13:17.296]         {
[16:13:17.296]             ...future.startTime <- base::Sys.time()
[16:13:17.296]             {
[16:13:17.296]                 {
[16:13:17.296]                   {
[16:13:17.296]                     {
[16:13:17.296]                       base::local({
[16:13:17.296]                         has_future <- base::requireNamespace("future", 
[16:13:17.296]                           quietly = TRUE)
[16:13:17.296]                         if (has_future) {
[16:13:17.296]                           ns <- base::getNamespace("future")
[16:13:17.296]                           version <- ns[[".package"]][["version"]]
[16:13:17.296]                           if (is.null(version)) 
[16:13:17.296]                             version <- utils::packageVersion("future")
[16:13:17.296]                         }
[16:13:17.296]                         else {
[16:13:17.296]                           version <- NULL
[16:13:17.296]                         }
[16:13:17.296]                         if (!has_future || version < "1.8.0") {
[16:13:17.296]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.296]                             "", base::R.version$version.string), 
[16:13:17.296]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:17.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.296]                               "release", "version")], collapse = " "), 
[16:13:17.296]                             hostname = base::Sys.info()[["nodename"]])
[16:13:17.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.296]                             info)
[16:13:17.296]                           info <- base::paste(info, collapse = "; ")
[16:13:17.296]                           if (!has_future) {
[16:13:17.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.296]                               info)
[16:13:17.296]                           }
[16:13:17.296]                           else {
[16:13:17.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.296]                               info, version)
[16:13:17.296]                           }
[16:13:17.296]                           base::stop(msg)
[16:13:17.296]                         }
[16:13:17.296]                       })
[16:13:17.296]                     }
[16:13:17.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:17.296]                     base::options(mc.cores = 1L)
[16:13:17.296]                   }
[16:13:17.296]                   options(future.plan = NULL)
[16:13:17.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:17.296]                 }
[16:13:17.296]                 ...future.workdir <- getwd()
[16:13:17.296]             }
[16:13:17.296]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.296]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.296]         }
[16:13:17.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.296]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.296]             base::names(...future.oldOptions))
[16:13:17.296]     }
[16:13:17.296]     if (FALSE) {
[16:13:17.296]     }
[16:13:17.296]     else {
[16:13:17.296]         if (TRUE) {
[16:13:17.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.296]                 open = "w")
[16:13:17.296]         }
[16:13:17.296]         else {
[16:13:17.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.296]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.296]         }
[16:13:17.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.296]             base::sink(type = "output", split = FALSE)
[16:13:17.296]             base::close(...future.stdout)
[16:13:17.296]         }, add = TRUE)
[16:13:17.296]     }
[16:13:17.296]     ...future.frame <- base::sys.nframe()
[16:13:17.296]     ...future.conditions <- base::list()
[16:13:17.296]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.296]     if (FALSE) {
[16:13:17.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.296]     }
[16:13:17.296]     ...future.result <- base::tryCatch({
[16:13:17.296]         base::withCallingHandlers({
[16:13:17.296]             ...future.value <- base::withVisible(base::local({
[16:13:17.296]                 ...future.makeSendCondition <- local({
[16:13:17.296]                   sendCondition <- NULL
[16:13:17.296]                   function(frame = 1L) {
[16:13:17.296]                     if (is.function(sendCondition)) 
[16:13:17.296]                       return(sendCondition)
[16:13:17.296]                     ns <- getNamespace("parallel")
[16:13:17.296]                     if (exists("sendData", mode = "function", 
[16:13:17.296]                       envir = ns)) {
[16:13:17.296]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:17.296]                         envir = ns)
[16:13:17.296]                       envir <- sys.frame(frame)
[16:13:17.296]                       master <- NULL
[16:13:17.296]                       while (!identical(envir, .GlobalEnv) && 
[16:13:17.296]                         !identical(envir, emptyenv())) {
[16:13:17.296]                         if (exists("master", mode = "list", envir = envir, 
[16:13:17.296]                           inherits = FALSE)) {
[16:13:17.296]                           master <- get("master", mode = "list", 
[16:13:17.296]                             envir = envir, inherits = FALSE)
[16:13:17.296]                           if (inherits(master, c("SOCKnode", 
[16:13:17.296]                             "SOCK0node"))) {
[16:13:17.296]                             sendCondition <<- function(cond) {
[16:13:17.296]                               data <- list(type = "VALUE", value = cond, 
[16:13:17.296]                                 success = TRUE)
[16:13:17.296]                               parallel_sendData(master, data)
[16:13:17.296]                             }
[16:13:17.296]                             return(sendCondition)
[16:13:17.296]                           }
[16:13:17.296]                         }
[16:13:17.296]                         frame <- frame + 1L
[16:13:17.296]                         envir <- sys.frame(frame)
[16:13:17.296]                       }
[16:13:17.296]                     }
[16:13:17.296]                     sendCondition <<- function(cond) NULL
[16:13:17.296]                   }
[16:13:17.296]                 })
[16:13:17.296]                 withCallingHandlers({
[16:13:17.296]                   {
[16:13:17.296]                     b <- 2L
[16:13:17.296]                     plan_b <- future::plan("list")
[16:13:17.296]                     nested_b <- nested_a[-1]
[16:13:17.296]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:17.296]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:17.296]                       "sequential"))
[16:13:17.296]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:17.296]                       b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:17.296]                   }
[16:13:17.296]                 }, immediateCondition = function(cond) {
[16:13:17.296]                   sendCondition <- ...future.makeSendCondition()
[16:13:17.296]                   sendCondition(cond)
[16:13:17.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.296]                   {
[16:13:17.296]                     inherits <- base::inherits
[16:13:17.296]                     invokeRestart <- base::invokeRestart
[16:13:17.296]                     is.null <- base::is.null
[16:13:17.296]                     muffled <- FALSE
[16:13:17.296]                     if (inherits(cond, "message")) {
[16:13:17.296]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:17.296]                       if (muffled) 
[16:13:17.296]                         invokeRestart("muffleMessage")
[16:13:17.296]                     }
[16:13:17.296]                     else if (inherits(cond, "warning")) {
[16:13:17.296]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:17.296]                       if (muffled) 
[16:13:17.296]                         invokeRestart("muffleWarning")
[16:13:17.296]                     }
[16:13:17.296]                     else if (inherits(cond, "condition")) {
[16:13:17.296]                       if (!is.null(pattern)) {
[16:13:17.296]                         computeRestarts <- base::computeRestarts
[16:13:17.296]                         grepl <- base::grepl
[16:13:17.296]                         restarts <- computeRestarts(cond)
[16:13:17.296]                         for (restart in restarts) {
[16:13:17.296]                           name <- restart$name
[16:13:17.296]                           if (is.null(name)) 
[16:13:17.296]                             next
[16:13:17.296]                           if (!grepl(pattern, name)) 
[16:13:17.296]                             next
[16:13:17.296]                           invokeRestart(restart)
[16:13:17.296]                           muffled <- TRUE
[16:13:17.296]                           break
[16:13:17.296]                         }
[16:13:17.296]                       }
[16:13:17.296]                     }
[16:13:17.296]                     invisible(muffled)
[16:13:17.296]                   }
[16:13:17.296]                   muffleCondition(cond)
[16:13:17.296]                 })
[16:13:17.296]             }))
[16:13:17.296]             future::FutureResult(value = ...future.value$value, 
[16:13:17.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.296]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.296]                     ...future.globalenv.names))
[16:13:17.296]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.296]         }, condition = base::local({
[16:13:17.296]             c <- base::c
[16:13:17.296]             inherits <- base::inherits
[16:13:17.296]             invokeRestart <- base::invokeRestart
[16:13:17.296]             length <- base::length
[16:13:17.296]             list <- base::list
[16:13:17.296]             seq.int <- base::seq.int
[16:13:17.296]             signalCondition <- base::signalCondition
[16:13:17.296]             sys.calls <- base::sys.calls
[16:13:17.296]             `[[` <- base::`[[`
[16:13:17.296]             `+` <- base::`+`
[16:13:17.296]             `<<-` <- base::`<<-`
[16:13:17.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.296]                   3L)]
[16:13:17.296]             }
[16:13:17.296]             function(cond) {
[16:13:17.296]                 is_error <- inherits(cond, "error")
[16:13:17.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.296]                   NULL)
[16:13:17.296]                 if (is_error) {
[16:13:17.296]                   sessionInformation <- function() {
[16:13:17.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.296]                       search = base::search(), system = base::Sys.info())
[16:13:17.296]                   }
[16:13:17.296]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.296]                     cond$call), session = sessionInformation(), 
[16:13:17.296]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.296]                   signalCondition(cond)
[16:13:17.296]                 }
[16:13:17.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.296]                 "immediateCondition"))) {
[16:13:17.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.296]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.296]                   if (TRUE && !signal) {
[16:13:17.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.296]                     {
[16:13:17.296]                       inherits <- base::inherits
[16:13:17.296]                       invokeRestart <- base::invokeRestart
[16:13:17.296]                       is.null <- base::is.null
[16:13:17.296]                       muffled <- FALSE
[16:13:17.296]                       if (inherits(cond, "message")) {
[16:13:17.296]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.296]                         if (muffled) 
[16:13:17.296]                           invokeRestart("muffleMessage")
[16:13:17.296]                       }
[16:13:17.296]                       else if (inherits(cond, "warning")) {
[16:13:17.296]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.296]                         if (muffled) 
[16:13:17.296]                           invokeRestart("muffleWarning")
[16:13:17.296]                       }
[16:13:17.296]                       else if (inherits(cond, "condition")) {
[16:13:17.296]                         if (!is.null(pattern)) {
[16:13:17.296]                           computeRestarts <- base::computeRestarts
[16:13:17.296]                           grepl <- base::grepl
[16:13:17.296]                           restarts <- computeRestarts(cond)
[16:13:17.296]                           for (restart in restarts) {
[16:13:17.296]                             name <- restart$name
[16:13:17.296]                             if (is.null(name)) 
[16:13:17.296]                               next
[16:13:17.296]                             if (!grepl(pattern, name)) 
[16:13:17.296]                               next
[16:13:17.296]                             invokeRestart(restart)
[16:13:17.296]                             muffled <- TRUE
[16:13:17.296]                             break
[16:13:17.296]                           }
[16:13:17.296]                         }
[16:13:17.296]                       }
[16:13:17.296]                       invisible(muffled)
[16:13:17.296]                     }
[16:13:17.296]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.296]                   }
[16:13:17.296]                 }
[16:13:17.296]                 else {
[16:13:17.296]                   if (TRUE) {
[16:13:17.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.296]                     {
[16:13:17.296]                       inherits <- base::inherits
[16:13:17.296]                       invokeRestart <- base::invokeRestart
[16:13:17.296]                       is.null <- base::is.null
[16:13:17.296]                       muffled <- FALSE
[16:13:17.296]                       if (inherits(cond, "message")) {
[16:13:17.296]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.296]                         if (muffled) 
[16:13:17.296]                           invokeRestart("muffleMessage")
[16:13:17.296]                       }
[16:13:17.296]                       else if (inherits(cond, "warning")) {
[16:13:17.296]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.296]                         if (muffled) 
[16:13:17.296]                           invokeRestart("muffleWarning")
[16:13:17.296]                       }
[16:13:17.296]                       else if (inherits(cond, "condition")) {
[16:13:17.296]                         if (!is.null(pattern)) {
[16:13:17.296]                           computeRestarts <- base::computeRestarts
[16:13:17.296]                           grepl <- base::grepl
[16:13:17.296]                           restarts <- computeRestarts(cond)
[16:13:17.296]                           for (restart in restarts) {
[16:13:17.296]                             name <- restart$name
[16:13:17.296]                             if (is.null(name)) 
[16:13:17.296]                               next
[16:13:17.296]                             if (!grepl(pattern, name)) 
[16:13:17.296]                               next
[16:13:17.296]                             invokeRestart(restart)
[16:13:17.296]                             muffled <- TRUE
[16:13:17.296]                             break
[16:13:17.296]                           }
[16:13:17.296]                         }
[16:13:17.296]                       }
[16:13:17.296]                       invisible(muffled)
[16:13:17.296]                     }
[16:13:17.296]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.296]                   }
[16:13:17.296]                 }
[16:13:17.296]             }
[16:13:17.296]         }))
[16:13:17.296]     }, error = function(ex) {
[16:13:17.296]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.296]                 ...future.rng), started = ...future.startTime, 
[16:13:17.296]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.296]             version = "1.8"), class = "FutureResult")
[16:13:17.296]     }, finally = {
[16:13:17.296]         if (!identical(...future.workdir, getwd())) 
[16:13:17.296]             setwd(...future.workdir)
[16:13:17.296]         {
[16:13:17.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.296]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.296]             }
[16:13:17.296]             base::options(...future.oldOptions)
[16:13:17.296]             if (.Platform$OS.type == "windows") {
[16:13:17.296]                 old_names <- names(...future.oldEnvVars)
[16:13:17.296]                 envs <- base::Sys.getenv()
[16:13:17.296]                 names <- names(envs)
[16:13:17.296]                 common <- intersect(names, old_names)
[16:13:17.296]                 added <- setdiff(names, old_names)
[16:13:17.296]                 removed <- setdiff(old_names, names)
[16:13:17.296]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.296]                   envs[common]]
[16:13:17.296]                 NAMES <- toupper(changed)
[16:13:17.296]                 args <- list()
[16:13:17.296]                 for (kk in seq_along(NAMES)) {
[16:13:17.296]                   name <- changed[[kk]]
[16:13:17.296]                   NAME <- NAMES[[kk]]
[16:13:17.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.296]                     next
[16:13:17.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.296]                 }
[16:13:17.296]                 NAMES <- toupper(added)
[16:13:17.296]                 for (kk in seq_along(NAMES)) {
[16:13:17.296]                   name <- added[[kk]]
[16:13:17.296]                   NAME <- NAMES[[kk]]
[16:13:17.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.296]                     next
[16:13:17.296]                   args[[name]] <- ""
[16:13:17.296]                 }
[16:13:17.296]                 NAMES <- toupper(removed)
[16:13:17.296]                 for (kk in seq_along(NAMES)) {
[16:13:17.296]                   name <- removed[[kk]]
[16:13:17.296]                   NAME <- NAMES[[kk]]
[16:13:17.296]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.296]                     next
[16:13:17.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.296]                 }
[16:13:17.296]                 if (length(args) > 0) 
[16:13:17.296]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.296]             }
[16:13:17.296]             else {
[16:13:17.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.296]             }
[16:13:17.296]             {
[16:13:17.296]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.296]                   0L) {
[16:13:17.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.296]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.296]                   base::options(opts)
[16:13:17.296]                 }
[16:13:17.296]                 {
[16:13:17.296]                   {
[16:13:17.296]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:17.296]                     NULL
[16:13:17.296]                   }
[16:13:17.296]                   options(future.plan = NULL)
[16:13:17.296]                   if (is.na(NA_character_)) 
[16:13:17.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.296]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:17.296]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:17.296]                     envir = parent.frame()) 
[16:13:17.296]                   {
[16:13:17.296]                     if (is.function(workers)) 
[16:13:17.296]                       workers <- workers()
[16:13:17.296]                     workers <- structure(as.integer(workers), 
[16:13:17.296]                       class = class(workers))
[16:13:17.296]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:17.296]                       workers >= 1)
[16:13:17.296]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:17.296]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:17.296]                     }
[16:13:17.296]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:17.296]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:17.296]                       envir = envir)
[16:13:17.296]                     if (!future$lazy) 
[16:13:17.296]                       future <- run(future)
[16:13:17.296]                     invisible(future)
[16:13:17.296]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.296]                 }
[16:13:17.296]             }
[16:13:17.296]         }
[16:13:17.296]     })
[16:13:17.296]     if (TRUE) {
[16:13:17.296]         base::sink(type = "output", split = FALSE)
[16:13:17.296]         if (TRUE) {
[16:13:17.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.296]         }
[16:13:17.296]         else {
[16:13:17.296]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.296]         }
[16:13:17.296]         base::close(...future.stdout)
[16:13:17.296]         ...future.stdout <- NULL
[16:13:17.296]     }
[16:13:17.296]     ...future.result$conditions <- ...future.conditions
[16:13:17.296]     ...future.result$finished <- base::Sys.time()
[16:13:17.296]     ...future.result
[16:13:17.296] }
[16:13:17.507]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.367] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[16:13:17.507]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.367] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[16:13:17.508]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.368] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[16:13:17.508]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.368] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:13:17.508]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.368] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:13:17.508]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.369] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[16:13:17.508]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.412] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[16:13:17.509]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.412] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[16:13:17.509]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.413] MultisessionFuture started
[16:13:17.509]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.413] - Launch lazy future ... done
[16:13:17.509]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.413] run() for ‘MultisessionFuture’ ... done
[16:13:17.509]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.414] result() for ClusterFuture ...
[16:13:17.509]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.414] receiveMessageFromWorker() for ClusterFuture ...
[16:13:17.510]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.414] - Validating connection of MultisessionFuture
[16:13:17.510]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.489] - received message: FutureResult
[16:13:17.510]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.489] - Received FutureResult
[16:13:17.510]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.489] - Erased future from FutureRegistry
[16:13:17.510]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] result() for ClusterFuture ...
[16:13:17.510]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] - result already collected: FutureResult
[16:13:17.511]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] result() for ClusterFuture ... done
[16:13:17.511]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:17.511]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] result() for ClusterFuture ... done
[16:13:17.511]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] result() for ClusterFuture ...
[16:13:17.511]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.490] - result already collected: FutureResult
[16:13:17.511]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.491] result() for ClusterFuture ... done
[16:13:17.512] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:17.518] getGlobalsAndPackages() ...
[16:13:17.518] Searching for globals...
[16:13:17.520] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:17.520] Searching for globals ... DONE
[16:13:17.520] Resolving globals: FALSE
[16:13:17.521] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:17.521] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:17.522] - globals: [1] ‘data’
[16:13:17.522] - packages: [1] ‘future’
[16:13:17.522] getGlobalsAndPackages() ... DONE
[16:13:17.522] run() for ‘Future’ ...
[16:13:17.522] - state: ‘created’
[16:13:17.523] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:17.523] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:17.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:17.523]   - Field: ‘label’
[16:13:17.523]   - Field: ‘local’
[16:13:17.523]   - Field: ‘owner’
[16:13:17.524]   - Field: ‘envir’
[16:13:17.524]   - Field: ‘packages’
[16:13:17.524]   - Field: ‘gc’
[16:13:17.524]   - Field: ‘conditions’
[16:13:17.524]   - Field: ‘expr’
[16:13:17.524]   - Field: ‘uuid’
[16:13:17.524]   - Field: ‘seed’
[16:13:17.524]   - Field: ‘version’
[16:13:17.524]   - Field: ‘result’
[16:13:17.525]   - Field: ‘asynchronous’
[16:13:17.525]   - Field: ‘calls’
[16:13:17.525]   - Field: ‘globals’
[16:13:17.525]   - Field: ‘stdout’
[16:13:17.525]   - Field: ‘earlySignal’
[16:13:17.525]   - Field: ‘lazy’
[16:13:17.525]   - Field: ‘state’
[16:13:17.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:17.526] - Launch lazy future ...
[16:13:17.526] Packages needed by the future expression (n = 1): ‘future’
[16:13:17.526] Packages needed by future strategies (n = 1): ‘future’
[16:13:17.527] {
[16:13:17.527]     {
[16:13:17.527]         {
[16:13:17.527]             ...future.startTime <- base::Sys.time()
[16:13:17.527]             {
[16:13:17.527]                 {
[16:13:17.527]                   {
[16:13:17.527]                     {
[16:13:17.527]                       base::local({
[16:13:17.527]                         has_future <- base::requireNamespace("future", 
[16:13:17.527]                           quietly = TRUE)
[16:13:17.527]                         if (has_future) {
[16:13:17.527]                           ns <- base::getNamespace("future")
[16:13:17.527]                           version <- ns[[".package"]][["version"]]
[16:13:17.527]                           if (is.null(version)) 
[16:13:17.527]                             version <- utils::packageVersion("future")
[16:13:17.527]                         }
[16:13:17.527]                         else {
[16:13:17.527]                           version <- NULL
[16:13:17.527]                         }
[16:13:17.527]                         if (!has_future || version < "1.8.0") {
[16:13:17.527]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.527]                             "", base::R.version$version.string), 
[16:13:17.527]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:17.527]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.527]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.527]                               "release", "version")], collapse = " "), 
[16:13:17.527]                             hostname = base::Sys.info()[["nodename"]])
[16:13:17.527]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.527]                             info)
[16:13:17.527]                           info <- base::paste(info, collapse = "; ")
[16:13:17.527]                           if (!has_future) {
[16:13:17.527]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.527]                               info)
[16:13:17.527]                           }
[16:13:17.527]                           else {
[16:13:17.527]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.527]                               info, version)
[16:13:17.527]                           }
[16:13:17.527]                           base::stop(msg)
[16:13:17.527]                         }
[16:13:17.527]                       })
[16:13:17.527]                     }
[16:13:17.527]                     base::local({
[16:13:17.527]                       for (pkg in "future") {
[16:13:17.527]                         base::loadNamespace(pkg)
[16:13:17.527]                         base::library(pkg, character.only = TRUE)
[16:13:17.527]                       }
[16:13:17.527]                     })
[16:13:17.527]                   }
[16:13:17.527]                   options(future.plan = NULL)
[16:13:17.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.527]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:17.527]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:17.527]                     envir = parent.frame()) 
[16:13:17.527]                   {
[16:13:17.527]                     if (is.function(workers)) 
[16:13:17.527]                       workers <- workers()
[16:13:17.527]                     workers <- structure(as.integer(workers), 
[16:13:17.527]                       class = class(workers))
[16:13:17.527]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:17.527]                       workers >= 1)
[16:13:17.527]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:17.527]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:17.527]                     }
[16:13:17.527]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:17.527]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:17.527]                       envir = envir)
[16:13:17.527]                     if (!future$lazy) 
[16:13:17.527]                       future <- run(future)
[16:13:17.527]                     invisible(future)
[16:13:17.527]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.527]                 }
[16:13:17.527]                 ...future.workdir <- getwd()
[16:13:17.527]             }
[16:13:17.527]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.527]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.527]         }
[16:13:17.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.527]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.527]             base::names(...future.oldOptions))
[16:13:17.527]     }
[16:13:17.527]     if (FALSE) {
[16:13:17.527]     }
[16:13:17.527]     else {
[16:13:17.527]         if (TRUE) {
[16:13:17.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.527]                 open = "w")
[16:13:17.527]         }
[16:13:17.527]         else {
[16:13:17.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.527]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.527]         }
[16:13:17.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.527]             base::sink(type = "output", split = FALSE)
[16:13:17.527]             base::close(...future.stdout)
[16:13:17.527]         }, add = TRUE)
[16:13:17.527]     }
[16:13:17.527]     ...future.frame <- base::sys.nframe()
[16:13:17.527]     ...future.conditions <- base::list()
[16:13:17.527]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.527]     if (FALSE) {
[16:13:17.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.527]     }
[16:13:17.527]     ...future.result <- base::tryCatch({
[16:13:17.527]         base::withCallingHandlers({
[16:13:17.527]             ...future.value <- base::withVisible(base::local({
[16:13:17.527]                 value(future(subset(data, a == 2)))
[16:13:17.527]             }))
[16:13:17.527]             future::FutureResult(value = ...future.value$value, 
[16:13:17.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.527]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.527]                     ...future.globalenv.names))
[16:13:17.527]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.527]         }, condition = base::local({
[16:13:17.527]             c <- base::c
[16:13:17.527]             inherits <- base::inherits
[16:13:17.527]             invokeRestart <- base::invokeRestart
[16:13:17.527]             length <- base::length
[16:13:17.527]             list <- base::list
[16:13:17.527]             seq.int <- base::seq.int
[16:13:17.527]             signalCondition <- base::signalCondition
[16:13:17.527]             sys.calls <- base::sys.calls
[16:13:17.527]             `[[` <- base::`[[`
[16:13:17.527]             `+` <- base::`+`
[16:13:17.527]             `<<-` <- base::`<<-`
[16:13:17.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.527]                   3L)]
[16:13:17.527]             }
[16:13:17.527]             function(cond) {
[16:13:17.527]                 is_error <- inherits(cond, "error")
[16:13:17.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.527]                   NULL)
[16:13:17.527]                 if (is_error) {
[16:13:17.527]                   sessionInformation <- function() {
[16:13:17.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.527]                       search = base::search(), system = base::Sys.info())
[16:13:17.527]                   }
[16:13:17.527]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.527]                     cond$call), session = sessionInformation(), 
[16:13:17.527]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.527]                   signalCondition(cond)
[16:13:17.527]                 }
[16:13:17.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.527]                 "immediateCondition"))) {
[16:13:17.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.527]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.527]                   if (TRUE && !signal) {
[16:13:17.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.527]                     {
[16:13:17.527]                       inherits <- base::inherits
[16:13:17.527]                       invokeRestart <- base::invokeRestart
[16:13:17.527]                       is.null <- base::is.null
[16:13:17.527]                       muffled <- FALSE
[16:13:17.527]                       if (inherits(cond, "message")) {
[16:13:17.527]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.527]                         if (muffled) 
[16:13:17.527]                           invokeRestart("muffleMessage")
[16:13:17.527]                       }
[16:13:17.527]                       else if (inherits(cond, "warning")) {
[16:13:17.527]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.527]                         if (muffled) 
[16:13:17.527]                           invokeRestart("muffleWarning")
[16:13:17.527]                       }
[16:13:17.527]                       else if (inherits(cond, "condition")) {
[16:13:17.527]                         if (!is.null(pattern)) {
[16:13:17.527]                           computeRestarts <- base::computeRestarts
[16:13:17.527]                           grepl <- base::grepl
[16:13:17.527]                           restarts <- computeRestarts(cond)
[16:13:17.527]                           for (restart in restarts) {
[16:13:17.527]                             name <- restart$name
[16:13:17.527]                             if (is.null(name)) 
[16:13:17.527]                               next
[16:13:17.527]                             if (!grepl(pattern, name)) 
[16:13:17.527]                               next
[16:13:17.527]                             invokeRestart(restart)
[16:13:17.527]                             muffled <- TRUE
[16:13:17.527]                             break
[16:13:17.527]                           }
[16:13:17.527]                         }
[16:13:17.527]                       }
[16:13:17.527]                       invisible(muffled)
[16:13:17.527]                     }
[16:13:17.527]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.527]                   }
[16:13:17.527]                 }
[16:13:17.527]                 else {
[16:13:17.527]                   if (TRUE) {
[16:13:17.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.527]                     {
[16:13:17.527]                       inherits <- base::inherits
[16:13:17.527]                       invokeRestart <- base::invokeRestart
[16:13:17.527]                       is.null <- base::is.null
[16:13:17.527]                       muffled <- FALSE
[16:13:17.527]                       if (inherits(cond, "message")) {
[16:13:17.527]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.527]                         if (muffled) 
[16:13:17.527]                           invokeRestart("muffleMessage")
[16:13:17.527]                       }
[16:13:17.527]                       else if (inherits(cond, "warning")) {
[16:13:17.527]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.527]                         if (muffled) 
[16:13:17.527]                           invokeRestart("muffleWarning")
[16:13:17.527]                       }
[16:13:17.527]                       else if (inherits(cond, "condition")) {
[16:13:17.527]                         if (!is.null(pattern)) {
[16:13:17.527]                           computeRestarts <- base::computeRestarts
[16:13:17.527]                           grepl <- base::grepl
[16:13:17.527]                           restarts <- computeRestarts(cond)
[16:13:17.527]                           for (restart in restarts) {
[16:13:17.527]                             name <- restart$name
[16:13:17.527]                             if (is.null(name)) 
[16:13:17.527]                               next
[16:13:17.527]                             if (!grepl(pattern, name)) 
[16:13:17.527]                               next
[16:13:17.527]                             invokeRestart(restart)
[16:13:17.527]                             muffled <- TRUE
[16:13:17.527]                             break
[16:13:17.527]                           }
[16:13:17.527]                         }
[16:13:17.527]                       }
[16:13:17.527]                       invisible(muffled)
[16:13:17.527]                     }
[16:13:17.527]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.527]                   }
[16:13:17.527]                 }
[16:13:17.527]             }
[16:13:17.527]         }))
[16:13:17.527]     }, error = function(ex) {
[16:13:17.527]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.527]                 ...future.rng), started = ...future.startTime, 
[16:13:17.527]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.527]             version = "1.8"), class = "FutureResult")
[16:13:17.527]     }, finally = {
[16:13:17.527]         if (!identical(...future.workdir, getwd())) 
[16:13:17.527]             setwd(...future.workdir)
[16:13:17.527]         {
[16:13:17.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.527]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.527]             }
[16:13:17.527]             base::options(...future.oldOptions)
[16:13:17.527]             if (.Platform$OS.type == "windows") {
[16:13:17.527]                 old_names <- names(...future.oldEnvVars)
[16:13:17.527]                 envs <- base::Sys.getenv()
[16:13:17.527]                 names <- names(envs)
[16:13:17.527]                 common <- intersect(names, old_names)
[16:13:17.527]                 added <- setdiff(names, old_names)
[16:13:17.527]                 removed <- setdiff(old_names, names)
[16:13:17.527]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.527]                   envs[common]]
[16:13:17.527]                 NAMES <- toupper(changed)
[16:13:17.527]                 args <- list()
[16:13:17.527]                 for (kk in seq_along(NAMES)) {
[16:13:17.527]                   name <- changed[[kk]]
[16:13:17.527]                   NAME <- NAMES[[kk]]
[16:13:17.527]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.527]                     next
[16:13:17.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.527]                 }
[16:13:17.527]                 NAMES <- toupper(added)
[16:13:17.527]                 for (kk in seq_along(NAMES)) {
[16:13:17.527]                   name <- added[[kk]]
[16:13:17.527]                   NAME <- NAMES[[kk]]
[16:13:17.527]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.527]                     next
[16:13:17.527]                   args[[name]] <- ""
[16:13:17.527]                 }
[16:13:17.527]                 NAMES <- toupper(removed)
[16:13:17.527]                 for (kk in seq_along(NAMES)) {
[16:13:17.527]                   name <- removed[[kk]]
[16:13:17.527]                   NAME <- NAMES[[kk]]
[16:13:17.527]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.527]                     next
[16:13:17.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.527]                 }
[16:13:17.527]                 if (length(args) > 0) 
[16:13:17.527]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.527]             }
[16:13:17.527]             else {
[16:13:17.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.527]             }
[16:13:17.527]             {
[16:13:17.527]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.527]                   0L) {
[16:13:17.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.527]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.527]                   base::options(opts)
[16:13:17.527]                 }
[16:13:17.527]                 {
[16:13:17.527]                   {
[16:13:17.527]                     NULL
[16:13:17.527]                     RNGkind("Mersenne-Twister")
[16:13:17.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:17.527]                       inherits = FALSE)
[16:13:17.527]                   }
[16:13:17.527]                   options(future.plan = NULL)
[16:13:17.527]                   if (is.na(NA_character_)) 
[16:13:17.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.527]                   future::plan(list(a = function (..., envir = parent.frame()) 
[16:13:17.527]                   {
[16:13:17.527]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.527]                     if (!future$lazy) 
[16:13:17.527]                       future <- run(future)
[16:13:17.527]                     invisible(future)
[16:13:17.527]                   }, b = function (..., workers = availableCores(), 
[16:13:17.527]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:17.527]                     envir = parent.frame()) 
[16:13:17.527]                   {
[16:13:17.527]                     if (is.function(workers)) 
[16:13:17.527]                       workers <- workers()
[16:13:17.527]                     workers <- structure(as.integer(workers), 
[16:13:17.527]                       class = class(workers))
[16:13:17.527]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:17.527]                       workers >= 1)
[16:13:17.527]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:17.527]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:17.527]                     }
[16:13:17.527]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:17.527]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:17.527]                       envir = envir)
[16:13:17.527]                     if (!future$lazy) 
[16:13:17.527]                       future <- run(future)
[16:13:17.527]                     invisible(future)
[16:13:17.527]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.527]                 }
[16:13:17.527]             }
[16:13:17.527]         }
[16:13:17.527]     })
[16:13:17.527]     if (TRUE) {
[16:13:17.527]         base::sink(type = "output", split = FALSE)
[16:13:17.527]         if (TRUE) {
[16:13:17.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.527]         }
[16:13:17.527]         else {
[16:13:17.527]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.527]         }
[16:13:17.527]         base::close(...future.stdout)
[16:13:17.527]         ...future.stdout <- NULL
[16:13:17.527]     }
[16:13:17.527]     ...future.result$conditions <- ...future.conditions
[16:13:17.527]     ...future.result$finished <- base::Sys.time()
[16:13:17.527]     ...future.result
[16:13:17.527] }
[16:13:17.529] assign_globals() ...
[16:13:17.529] List of 1
[16:13:17.529]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:17.529]   ..$ a: int [1:3] 1 2 3
[16:13:17.529]   ..$ b: int [1:3] 3 2 1
[16:13:17.529]  - attr(*, "where")=List of 1
[16:13:17.529]   ..$ data:<environment: R_EmptyEnv> 
[16:13:17.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.529]  - attr(*, "resolved")= logi FALSE
[16:13:17.529]  - attr(*, "total_size")= num 128
[16:13:17.529]  - attr(*, "already-done")= logi TRUE
[16:13:17.534] - copied ‘data’ to environment
[16:13:17.535] assign_globals() ... done
[16:13:17.535] plan(): Setting new future strategy stack:
[16:13:17.535] List of future strategies:
[16:13:17.535] 1. multisession:
[16:13:17.535]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:17.535]    - tweaked: FALSE
[16:13:17.535]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.539] plan(): nbrOfWorkers() = 2
[16:13:17.626] plan(): Setting new future strategy stack:
[16:13:17.626] List of future strategies:
[16:13:17.626] 1. sequential:
[16:13:17.626]    - args: function (..., envir = parent.frame())
[16:13:17.626]    - tweaked: FALSE
[16:13:17.626]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.626] 2. multisession:
[16:13:17.626]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:17.626]    - tweaked: FALSE
[16:13:17.626]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.627] plan(): nbrOfWorkers() = 1
[16:13:17.627] SequentialFuture started (and completed)
[16:13:17.627] signalConditions() ...
[16:13:17.627]  - include = ‘immediateCondition’
[16:13:17.627]  - exclude = 
[16:13:17.627]  - resignal = FALSE
[16:13:17.628]  - Number of conditions: 63
[16:13:17.628] signalConditions() ... done
[16:13:17.628] - Launch lazy future ... done
[16:13:17.628] run() for ‘SequentialFuture’ ... done
[16:13:17.628] signalConditions() ...
[16:13:17.628]  - include = ‘immediateCondition’
[16:13:17.628]  - exclude = 
[16:13:17.628]  - resignal = FALSE
[16:13:17.628]  - Number of conditions: 63
[16:13:17.629] signalConditions() ... done
[16:13:17.629] Future state: ‘finished’
[16:13:17.629] signalConditions() ...
[16:13:17.629]  - include = ‘condition’
[16:13:17.629]  - exclude = ‘immediateCondition’
[16:13:17.629]  - resignal = TRUE
[16:13:17.629]  - Number of conditions: 63
[16:13:17.629]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.539] getGlobalsAndPackages() ...
[16:13:17.629]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.539] Searching for globals...
[16:13:17.630]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.552] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:17.630]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.553] Searching for globals ... DONE
[16:13:17.630]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.553] Resolving globals: FALSE
[16:13:17.630]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.553] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:17.630]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.553] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:17.630]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.554] - globals: [1] ‘data’
[16:13:17.630]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.554] 
[16:13:17.630]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.554] getGlobalsAndPackages() ... DONE
[16:13:17.631]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.554] run() for ‘Future’ ...
[16:13:17.631]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.554] - state: ‘created’
[16:13:17.631]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.631]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:17.631]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:17.631]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569]   - Field: ‘node’
[16:13:17.631]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569]   - Field: ‘label’
[16:13:17.631]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569]   - Field: ‘local’
[16:13:17.632]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569]   - Field: ‘owner’
[16:13:17.632]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.569]   - Field: ‘envir’
[16:13:17.632]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘workers’
[16:13:17.632]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘packages’
[16:13:17.632]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘gc’
[16:13:17.632]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘conditions’
[16:13:17.632]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘persistent’
[16:13:17.633]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘expr’
[16:13:17.633]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘uuid’
[16:13:17.633]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘seed’
[16:13:17.633]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘version’
[16:13:17.633]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.570]   - Field: ‘result’
[16:13:17.633]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘asynchronous’
[16:13:17.633]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘calls’
[16:13:17.633]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘globals’
[16:13:17.634]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘stdout’
[16:13:17.634]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘earlySignal’
[16:13:17.634]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘lazy’
[16:13:17.634]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571]   - Field: ‘state’
[16:13:17.634]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:17.634]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.571] - Launch lazy future ...
[16:13:17.634]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.572] Packages needed by the future expression (n = 0): <none>
[16:13:17.634]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.572] Packages needed by future strategies (n = 0): <none>
[16:13:17.635]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.572] {
[16:13:17.572]     {
[16:13:17.572]         {
[16:13:17.572]             ...future.startTime <- base::Sys.time()
[16:13:17.572]             {
[16:13:17.572]                 {
[16:13:17.572]                   {
[16:13:17.572]                     {
[16:13:17.572]                       base::local({
[16:13:17.572]                         has_future <- base::requireNamespace("future", 
[16:13:17.572]                           quietly = TRUE)
[16:13:17.572]                         if (has_future) {
[16:13:17.572]                           ns <- base::getNamespace("future")
[16:13:17.572]                           version <- ns[[".package"]][["version"]]
[16:13:17.572]                           if (is.null(version)) 
[16:13:17.572]                             version <- utils::packageVersion("future")
[16:13:17.572]                         }
[16:13:17.572]                         else {
[16:13:17.572]                           version <- NULL
[16:13:17.572]                         }
[16:13:17.572]                         if (!has_future || version < "1.8.0") {
[16:13:17.572]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.572]                             "", base::R.version$version.string), 
[16:13:17.572]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:17.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.572]                               "release", "version")], collapse = " "), 
[16:13:17.572]                             hostname = base::Sys.info()[["nodename"]])
[16:13:17.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.572]                             info)
[16:13:17.572]                           info <- base::paste(info, collapse = "; ")
[16:13:17.572]                           if (!has_future) {
[16:13:17.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.572]                               info)
[16:13:17.572]                           }
[16:13:17.572]                           else {
[16:13:17.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.572]                               info, version)
[16:13:17.572]                           }
[16:13:17.572]                           base::stop(msg)
[16:13:17.572]                         }
[16:13:17.572]                       })
[16:13:17.572]                     }
[16:13:17.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:17.572]                     base::options(mc.cores = 1L)
[16:13:17.572]                   }
[16:13:17.572]                   options(future.plan = NULL)
[16:13:17.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:17.572]                 }
[16:13:17.572]                 ...future.workdir <- getwd()
[16:13:17.572]             }
[16:13:17.572]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.572]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.572]         }
[16:13:17.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.572]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.572]             base::names(...future.oldOptions))
[16:13:17.572]     }
[16:13:17.572]     if (FALSE) {
[16:13:17.572]     }
[16:13:17.572]     else {
[16:13:17.572]         if (TRUE) {
[16:13:17.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.572]                 open = "w")
[16:13:17.572]         }
[16:13:17.572]         else {
[16:13:17.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.572]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.572]         }
[16:13:17.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.572]             base::sink(type = "output", split = FALSE)
[16:13:17.572]             base::close(...future.stdout)
[16:13:17.572]         }, add = TRUE)
[16:13:17.572]     }
[16:13:17.572]     ...future.frame <- base::sys.nframe()
[16:13:17.572]     ...future.conditions <- base::list()
[16:13:17.572]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.572]     if (FALSE) {
[16:13:17.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.572]     }
[16:13:17.572]     ...future.result <- base::tryCatch({
[16:13:17.572]         base::withCallingHandlers({
[16:13:17.572]             ...future.value <- base::withVisible(base::local({
[16:13:17.572]                 ...future.makeSendCondition <- local({
[16:13:17.572]                   sendCondition <- NULL
[16:13:17.572]                   function(frame = 1L) {
[16:13:17.572]                     if (is.function(sendCondition)) 
[16:13:17.572]                       return(sendCondition)
[16:13:17.572]                     ns <- getNamespace("parallel")
[16:13:17.572]                     if (exists("sendData", mode = "function", 
[16:13:17.572]                       envir = ns)) {
[16:13:17.572]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:17.572]                         envir = ns)
[16:13:17.572]                       envir <- sys.frame(frame)
[16:13:17.572]                       master <- NULL
[16:13:17.572]                       while (!identical(envir, .GlobalEnv) && 
[16:13:17.572]                         !identical(envir, emptyenv())) {
[16:13:17.572]                         if (exists("master", mode = "list", envir = envir, 
[16:13:17.572]                           inherits = FALSE)) {
[16:13:17.572]                           master <- get("master", mode = "list", 
[16:13:17.572]                             envir = envir, inherits = FALSE)
[16:13:17.572]                           if (inherits(master, c("SOCKnode", 
[16:13:17.572]                             "SOCK0node"))) {
[16:13:17.572]                             sendCondition <<- function(cond) {
[16:13:17.572]                               data <- list(type = "VALUE", value = cond, 
[16:13:17.572]                                 success = TRUE)
[16:13:17.572]                               parallel_sendData(master, data)
[16:13:17.572]                             }
[16:13:17.572]                             return(sendCondition)
[16:13:17.572]                           }
[16:13:17.572]                         }
[16:13:17.572]                         frame <- frame + 1L
[16:13:17.572]                         envir <- sys.frame(frame)
[16:13:17.572]                       }
[16:13:17.572]                     }
[16:13:17.572]                     sendCondition <<- function(cond) NULL
[16:13:17.572]                   }
[16:13:17.572]                 })
[16:13:17.572]                 withCallingHandlers({
[16:13:17.572]                   subset(data, a == 2)
[16:13:17.572]                 }, immediateCondition = function(cond) {
[16:13:17.572]                   sendCondition <- ...future.makeSendCondition()
[16:13:17.572]                   sendCondition(cond)
[16:13:17.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.572]                   {
[16:13:17.572]                     inherits <- base::inherits
[16:13:17.572]                     invokeRestart <- base::invokeRestart
[16:13:17.572]                     is.null <- base::is.null
[16:13:17.572]                     muffled <- FALSE
[16:13:17.572]                     if (inherits(cond, "message")) {
[16:13:17.572]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:17.572]                       if (muffled) 
[16:13:17.572]                         invokeRestart("muffleMessage")
[16:13:17.572]                     }
[16:13:17.572]                     else if (inherits(cond, "warning")) {
[16:13:17.572]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:17.572]                       if (muffled) 
[16:13:17.572]                         invokeRestart("muffleWarning")
[16:13:17.572]                     }
[16:13:17.572]                     else if (inherits(cond, "condition")) {
[16:13:17.572]                       if (!is.null(pattern)) {
[16:13:17.572]                         computeRestarts <- base::computeRestarts
[16:13:17.572]                         grepl <- base::grepl
[16:13:17.572]                         restarts <- computeRestarts(cond)
[16:13:17.572]                         for (restart in restarts) {
[16:13:17.572]                           name <- restart$name
[16:13:17.572]                           if (is.null(name)) 
[16:13:17.572]                             next
[16:13:17.572]                           if (!grepl(pattern, name)) 
[16:13:17.572]                             next
[16:13:17.572]                           invokeRestart(restart)
[16:13:17.572]                           muffled <- TRUE
[16:13:17.572]                           break
[16:13:17.572]                         }
[16:13:17.572]                       }
[16:13:17.572]                     }
[16:13:17.572]                     invisible(muffled)
[16:13:17.572]                   }
[16:13:17.572]                   muffleCondition(cond)
[16:13:17.572]                 })
[16:13:17.572]             }))
[16:13:17.572]             future::FutureResult(value = ...future.value$value, 
[16:13:17.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.572]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.572]                     ...future.globalenv.names))
[16:13:17.572]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.572]         }, condition = base::local({
[16:13:17.572]             c <- base::c
[16:13:17.572]             inherits <- base::inherits
[16:13:17.572]             invokeRestart <- base::invokeRestart
[16:13:17.572]             length <- base::length
[16:13:17.572]             list <- base::list
[16:13:17.572]             seq.int <- base::seq.int
[16:13:17.572]             signalCondition <- base::signalCondition
[16:13:17.572]             sys.calls <- base::sys.calls
[16:13:17.572]             `[[` <- base::`[[`
[16:13:17.572]             `+` <- base::`+`
[16:13:17.572]             `<<-` <- base::`<<-`
[16:13:17.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.572]                   3L)]
[16:13:17.572]             }
[16:13:17.572]             function(cond) {
[16:13:17.572]                 is_error <- inherits(cond, "error")
[16:13:17.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.572]                   NULL)
[16:13:17.572]                 if (is_error) {
[16:13:17.572]                   sessionInformation <- function() {
[16:13:17.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.572]                       search = base::search(), system = base::Sys.info())
[16:13:17.572]                   }
[16:13:17.572]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.572]                     cond$call), session = sessionInformation(), 
[16:13:17.572]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.572]                   signalCondition(cond)
[16:13:17.572]                 }
[16:13:17.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.572]                 "immediateCondition"))) {
[16:13:17.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.572]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.572]                   if (TRUE && !signal) {
[16:13:17.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.572]                     {
[16:13:17.572]                       inherits <- base::inherits
[16:13:17.572]                       invokeRestart <- base::invokeRestart
[16:13:17.572]                       is.null <- base::is.null
[16:13:17.572]                       muffled <- FALSE
[16:13:17.572]                       if (inherits(cond, "message")) {
[16:13:17.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.572]                         if (muffled) 
[16:13:17.572]                           invokeRestart("muffleMessage")
[16:13:17.572]                       }
[16:13:17.572]                       else if (inherits(cond, "warning")) {
[16:13:17.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.572]                         if (muffled) 
[16:13:17.572]                           invokeRestart("muffleWarning")
[16:13:17.572]                       }
[16:13:17.572]                       else if (inherits(cond, "condition")) {
[16:13:17.572]                         if (!is.null(pattern)) {
[16:13:17.572]                           computeRestarts <- base::computeRestarts
[16:13:17.572]                           grepl <- base::grepl
[16:13:17.572]                           restarts <- computeRestarts(cond)
[16:13:17.572]                           for (restart in restarts) {
[16:13:17.572]                             name <- restart$name
[16:13:17.572]                             if (is.null(name)) 
[16:13:17.572]                               next
[16:13:17.572]                             if (!grepl(pattern, name)) 
[16:13:17.572]                               next
[16:13:17.572]                             invokeRestart(restart)
[16:13:17.572]                             muffled <- TRUE
[16:13:17.572]                             break
[16:13:17.572]                           }
[16:13:17.572]                         }
[16:13:17.572]                       }
[16:13:17.572]                       invisible(muffled)
[16:13:17.572]                     }
[16:13:17.572]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.572]                   }
[16:13:17.572]                 }
[16:13:17.572]                 else {
[16:13:17.572]                   if (TRUE) {
[16:13:17.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.572]                     {
[16:13:17.572]                       inherits <- base::inherits
[16:13:17.572]                       invokeRestart <- base::invokeRestart
[16:13:17.572]                       is.null <- base::is.null
[16:13:17.572]                       muffled <- FALSE
[16:13:17.572]                       if (inherits(cond, "message")) {
[16:13:17.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.572]                         if (muffled) 
[16:13:17.572]                           invokeRestart("muffleMessage")
[16:13:17.572]                       }
[16:13:17.572]                       else if (inherits(cond, "warning")) {
[16:13:17.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.572]                         if (muffled) 
[16:13:17.572]                           invokeRestart("muffleWarning")
[16:13:17.572]                       }
[16:13:17.572]                       else if (inherits(cond, "condition")) {
[16:13:17.572]                         if (!is.null(pattern)) {
[16:13:17.572]                           computeRestarts <- base::computeRestarts
[16:13:17.572]                           grepl <- base::grepl
[16:13:17.572]                           restarts <- computeRestarts(cond)
[16:13:17.572]                           for (restart in restarts) {
[16:13:17.572]                             name <- restart$name
[16:13:17.572]                             if (is.null(name)) 
[16:13:17.572]                               next
[16:13:17.572]                             if (!grepl(pattern, name)) 
[16:13:17.572]                               next
[16:13:17.572]                             invokeRestart(restart)
[16:13:17.572]                             muffled <- TRUE
[16:13:17.572]                             break
[16:13:17.572]                           }
[16:13:17.572]                         }
[16:13:17.572]                       }
[16:13:17.572]                       invisible(muffled)
[16:13:17.572]                     }
[16:13:17.572]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.572]                   }
[16:13:17.572]                 }
[16:13:17.572]             }
[16:13:17.572]         }))
[16:13:17.572]     }, error = function(ex) {
[16:13:17.572]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.572]                 ...future.rng), started = ...future.startTime, 
[16:13:17.572]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.572]             version = "1.8"), class = "FutureResult")
[16:13:17.572]     }, finally = {
[16:13:17.572]         if (!identical(...future.workdir, getwd())) 
[16:13:17.572]             setwd(...future.workdir)
[16:13:17.572]         {
[16:13:17.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.572]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.572]             }
[16:13:17.572]             base::options(...future.oldOptions)
[16:13:17.572]             if (.Platform$OS.type == "windows") {
[16:13:17.572]                 old_names <- names(...future.oldEnvVars)
[16:13:17.572]                 envs <- base::Sys.getenv()
[16:13:17.572]                 names <- names(envs)
[16:13:17.572]                 common <- intersect(names, old_names)
[16:13:17.572]                 added <- setdiff(names, old_names)
[16:13:17.572]                 removed <- setdiff(old_names, names)
[16:13:17.572]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.572]                   envs[common]]
[16:13:17.572]                 NAMES <- toupper(changed)
[16:13:17.572]                 args <- list()
[16:13:17.572]                 for (kk in seq_along(NAMES)) {
[16:13:17.572]                   name <- changed[[kk]]
[16:13:17.572]                   NAME <- NAMES[[kk]]
[16:13:17.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.572]                     next
[16:13:17.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.572]                 }
[16:13:17.572]                 NAMES <- toupper(added)
[16:13:17.572]                 for (kk in seq_along(NAMES)) {
[16:13:17.572]                   name <- added[[kk]]
[16:13:17.572]                   NAME <- NAMES[[kk]]
[16:13:17.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.572]                     next
[16:13:17.572]                   args[[name]] <- ""
[16:13:17.572]                 }
[16:13:17.572]                 NAMES <- toupper(removed)
[16:13:17.572]                 for (kk in seq_along(NAMES)) {
[16:13:17.572]                   name <- removed[[kk]]
[16:13:17.572]                   NAME <- NAMES[[kk]]
[16:13:17.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.572]                     next
[16:13:17.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.572]                 }
[16:13:17.572]                 if (length(args) > 0) 
[16:13:17.572]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.572]             }
[16:13:17.572]             else {
[16:13:17.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.572]             }
[16:13:17.572]             {
[16:13:17.572]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.572]                   0L) {
[16:13:17.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.572]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.572]                   base::options(opts)
[16:13:17.572]                 }
[16:13:17.572]                 {
[16:13:17.572]                   {
[16:13:17.572]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:17.572]                     NULL
[16:13:17.572]                   }
[16:13:17.572]                   options(future.plan = NULL)
[16:13:17.572]                   if (is.na(NA_character_)) 
[16:13:17.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.572]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:17.572]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:17.572]                     envir = parent.frame()) 
[16:13:17.572]                   {
[16:13:17.572]                     if (is.function(workers)) 
[16:13:17.572]                       workers <- workers()
[16:13:17.572]                     workers <- structure(as.integer(workers), 
[16:13:17.572]                       class = class(workers))
[16:13:17.572]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:17.572]                       workers >= 1)
[16:13:17.572]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:17.572]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:17.572]                     }
[16:13:17.572]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:17.572]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:17.572]                       envir = envir)
[16:13:17.572]                     if (!future$lazy) 
[16:13:17.572]                       future <- run(future)
[16:13:17.572]                     invisible(future)
[16:13:17.572]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.572]                 }
[16:13:17.572]             }
[16:13:17.572]         }
[16:13:17.572]     })
[16:13:17.572]     if (TRUE) {
[16:13:17.572]         base::sink(type = "output", split = FALSE)
[16:13:17.572]         if (TRUE) {
[16:13:17.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.572]         }
[16:13:17.572]         else {
[16:13:17.572]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.572]         }
[16:13:17.572]         base::close(...future.stdout)
[16:13:17.572]         ...future.stdout <- NULL
[16:13:17.572]     }
[16:13:17.572]     ...future.result$conditions <- ...future.conditions
[16:13:17.572]     ...future.result$finished <- base::Sys.time()
[16:13:17.572]     ...future.result
[16:13:17.572] }
[16:13:17.635]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.575] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:13:17.635]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.575] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:13:17.635]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.576] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:13:17.635]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.576] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:13:17.635]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.576] MultisessionFuture started
[16:13:17.635]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.576] - Launch lazy future ... done
[16:13:17.636]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.576] run() for ‘MultisessionFuture’ ... done
[16:13:17.636]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.577] result() for ClusterFuture ...
[16:13:17.636]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.577] receiveMessageFromWorker() for ClusterFuture ...
[16:13:17.636]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.577] - Validating connection of MultisessionFuture
[16:13:17.636]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] - received message: FutureResult
[16:13:17.636]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] - Received FutureResult
[16:13:17.636]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] - Erased future from FutureRegistry
[16:13:17.637]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] result() for ClusterFuture ...
[16:13:17.637]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] - result already collected: FutureResult
[16:13:17.637]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] result() for ClusterFuture ... done
[16:13:17.637]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:17.637]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.625] result() for ClusterFuture ... done
[16:13:17.637]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.626] result() for ClusterFuture ...
[16:13:17.637]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.626] - result already collected: FutureResult
[16:13:17.637]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.626] result() for ClusterFuture ... done
[16:13:17.638] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[16:13:17.638] plan(): Setting new future strategy stack:
[16:13:17.638] List of future strategies:
[16:13:17.638] 1. multicore:
[16:13:17.638]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.638]    - tweaked: FALSE
[16:13:17.638]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.638] 2. sequential:
[16:13:17.638]    - args: function (..., envir = parent.frame())
[16:13:17.638]    - tweaked: FALSE
[16:13:17.638]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.643] plan(): nbrOfWorkers() = 2
[16:13:17.644] getGlobalsAndPackages() ...
[16:13:17.644] Searching for globals...
[16:13:17.667] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:17.667] Searching for globals ... DONE
[16:13:17.667] Resolving globals: FALSE
[16:13:17.668] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[16:13:17.669] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:17.669] - globals: [2] ‘nested’, ‘strategy2’
[16:13:17.669] - packages: [1] ‘future’
[16:13:17.669] getGlobalsAndPackages() ... DONE
[16:13:17.669] run() for ‘Future’ ...
[16:13:17.669] - state: ‘created’
[16:13:17.670] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:17.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:17.674]   - Field: ‘label’
[16:13:17.674]   - Field: ‘local’
[16:13:17.674]   - Field: ‘owner’
[16:13:17.674]   - Field: ‘envir’
[16:13:17.674]   - Field: ‘workers’
[16:13:17.674]   - Field: ‘packages’
[16:13:17.674]   - Field: ‘gc’
[16:13:17.674]   - Field: ‘job’
[16:13:17.675]   - Field: ‘conditions’
[16:13:17.675]   - Field: ‘expr’
[16:13:17.675]   - Field: ‘uuid’
[16:13:17.675]   - Field: ‘seed’
[16:13:17.675]   - Field: ‘version’
[16:13:17.675]   - Field: ‘result’
[16:13:17.675]   - Field: ‘asynchronous’
[16:13:17.675]   - Field: ‘calls’
[16:13:17.675]   - Field: ‘globals’
[16:13:17.676]   - Field: ‘stdout’
[16:13:17.676]   - Field: ‘earlySignal’
[16:13:17.676]   - Field: ‘lazy’
[16:13:17.676]   - Field: ‘state’
[16:13:17.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:17.676] - Launch lazy future ...
[16:13:17.676] Packages needed by the future expression (n = 1): ‘future’
[16:13:17.677] Packages needed by future strategies (n = 1): ‘future’
[16:13:17.677] {
[16:13:17.677]     {
[16:13:17.677]         {
[16:13:17.677]             ...future.startTime <- base::Sys.time()
[16:13:17.677]             {
[16:13:17.677]                 {
[16:13:17.677]                   {
[16:13:17.677]                     {
[16:13:17.677]                       {
[16:13:17.677]                         base::local({
[16:13:17.677]                           has_future <- base::requireNamespace("future", 
[16:13:17.677]                             quietly = TRUE)
[16:13:17.677]                           if (has_future) {
[16:13:17.677]                             ns <- base::getNamespace("future")
[16:13:17.677]                             version <- ns[[".package"]][["version"]]
[16:13:17.677]                             if (is.null(version)) 
[16:13:17.677]                               version <- utils::packageVersion("future")
[16:13:17.677]                           }
[16:13:17.677]                           else {
[16:13:17.677]                             version <- NULL
[16:13:17.677]                           }
[16:13:17.677]                           if (!has_future || version < "1.8.0") {
[16:13:17.677]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.677]                               "", base::R.version$version.string), 
[16:13:17.677]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:17.677]                                 base::R.version$platform, 8 * 
[16:13:17.677]                                   base::.Machine$sizeof.pointer), 
[16:13:17.677]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.677]                                 "release", "version")], collapse = " "), 
[16:13:17.677]                               hostname = base::Sys.info()[["nodename"]])
[16:13:17.677]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.677]                               info)
[16:13:17.677]                             info <- base::paste(info, collapse = "; ")
[16:13:17.677]                             if (!has_future) {
[16:13:17.677]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.677]                                 info)
[16:13:17.677]                             }
[16:13:17.677]                             else {
[16:13:17.677]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.677]                                 info, version)
[16:13:17.677]                             }
[16:13:17.677]                             base::stop(msg)
[16:13:17.677]                           }
[16:13:17.677]                         })
[16:13:17.677]                       }
[16:13:17.677]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:17.677]                       base::options(mc.cores = 1L)
[16:13:17.677]                     }
[16:13:17.677]                     base::local({
[16:13:17.677]                       for (pkg in "future") {
[16:13:17.677]                         base::loadNamespace(pkg)
[16:13:17.677]                         base::library(pkg, character.only = TRUE)
[16:13:17.677]                       }
[16:13:17.677]                     })
[16:13:17.677]                   }
[16:13:17.677]                   options(future.plan = NULL)
[16:13:17.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.677]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:17.677]                   {
[16:13:17.677]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.677]                     if (!future$lazy) 
[16:13:17.677]                       future <- run(future)
[16:13:17.677]                     invisible(future)
[16:13:17.677]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.677]                 }
[16:13:17.677]                 ...future.workdir <- getwd()
[16:13:17.677]             }
[16:13:17.677]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.677]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.677]         }
[16:13:17.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.677]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.677]             base::names(...future.oldOptions))
[16:13:17.677]     }
[16:13:17.677]     if (FALSE) {
[16:13:17.677]     }
[16:13:17.677]     else {
[16:13:17.677]         if (TRUE) {
[16:13:17.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.677]                 open = "w")
[16:13:17.677]         }
[16:13:17.677]         else {
[16:13:17.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.677]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.677]         }
[16:13:17.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.677]             base::sink(type = "output", split = FALSE)
[16:13:17.677]             base::close(...future.stdout)
[16:13:17.677]         }, add = TRUE)
[16:13:17.677]     }
[16:13:17.677]     ...future.frame <- base::sys.nframe()
[16:13:17.677]     ...future.conditions <- base::list()
[16:13:17.677]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.677]     if (FALSE) {
[16:13:17.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.677]     }
[16:13:17.677]     ...future.result <- base::tryCatch({
[16:13:17.677]         base::withCallingHandlers({
[16:13:17.677]             ...future.value <- base::withVisible(base::local({
[16:13:17.677]                 withCallingHandlers({
[16:13:17.677]                   {
[16:13:17.677]                     a <- 1L
[16:13:17.677]                     plan_a <- unclass(future::plan("list"))
[16:13:17.677]                     nested_a <- nested[-1]
[16:13:17.677]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:17.677]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:17.677]                       strategy2))
[16:13:17.677]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:17.677]                       "init") <- NULL
[16:13:17.677]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:17.677]                       "init") <- NULL
[16:13:17.677]                     stopifnot(all.equal(plan_a, nested_a))
[16:13:17.677]                     y %<-% {
[16:13:17.677]                       b <- 2L
[16:13:17.677]                       plan_b <- future::plan("list")
[16:13:17.677]                       nested_b <- nested_a[-1]
[16:13:17.677]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:17.677]                         1L, inherits(plan_b[[1]], "future"), 
[16:13:17.677]                         inherits(future::plan("next"), "sequential"))
[16:13:17.677]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:17.677]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:17.677]                     }
[16:13:17.677]                     y
[16:13:17.677]                   }
[16:13:17.677]                 }, immediateCondition = function(cond) {
[16:13:17.677]                   save_rds <- function (object, pathname, ...) 
[16:13:17.677]                   {
[16:13:17.677]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:17.677]                     if (file_test("-f", pathname_tmp)) {
[16:13:17.677]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.677]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:17.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.677]                         fi_tmp[["mtime"]])
[16:13:17.677]                     }
[16:13:17.677]                     tryCatch({
[16:13:17.677]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:17.677]                     }, error = function(ex) {
[16:13:17.677]                       msg <- conditionMessage(ex)
[16:13:17.677]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.677]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:17.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.677]                         fi_tmp[["mtime"]], msg)
[16:13:17.677]                       ex$message <- msg
[16:13:17.677]                       stop(ex)
[16:13:17.677]                     })
[16:13:17.677]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:17.677]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:17.677]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:17.677]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.677]                       fi <- file.info(pathname)
[16:13:17.677]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:17.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.677]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:17.677]                         fi[["size"]], fi[["mtime"]])
[16:13:17.677]                       stop(msg)
[16:13:17.677]                     }
[16:13:17.677]                     invisible(pathname)
[16:13:17.677]                   }
[16:13:17.677]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:17.677]                     rootPath = tempdir()) 
[16:13:17.677]                   {
[16:13:17.677]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:17.677]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:17.677]                       tmpdir = path, fileext = ".rds")
[16:13:17.677]                     save_rds(obj, file)
[16:13:17.677]                   }
[16:13:17.677]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:17.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.677]                   {
[16:13:17.677]                     inherits <- base::inherits
[16:13:17.677]                     invokeRestart <- base::invokeRestart
[16:13:17.677]                     is.null <- base::is.null
[16:13:17.677]                     muffled <- FALSE
[16:13:17.677]                     if (inherits(cond, "message")) {
[16:13:17.677]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:17.677]                       if (muffled) 
[16:13:17.677]                         invokeRestart("muffleMessage")
[16:13:17.677]                     }
[16:13:17.677]                     else if (inherits(cond, "warning")) {
[16:13:17.677]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:17.677]                       if (muffled) 
[16:13:17.677]                         invokeRestart("muffleWarning")
[16:13:17.677]                     }
[16:13:17.677]                     else if (inherits(cond, "condition")) {
[16:13:17.677]                       if (!is.null(pattern)) {
[16:13:17.677]                         computeRestarts <- base::computeRestarts
[16:13:17.677]                         grepl <- base::grepl
[16:13:17.677]                         restarts <- computeRestarts(cond)
[16:13:17.677]                         for (restart in restarts) {
[16:13:17.677]                           name <- restart$name
[16:13:17.677]                           if (is.null(name)) 
[16:13:17.677]                             next
[16:13:17.677]                           if (!grepl(pattern, name)) 
[16:13:17.677]                             next
[16:13:17.677]                           invokeRestart(restart)
[16:13:17.677]                           muffled <- TRUE
[16:13:17.677]                           break
[16:13:17.677]                         }
[16:13:17.677]                       }
[16:13:17.677]                     }
[16:13:17.677]                     invisible(muffled)
[16:13:17.677]                   }
[16:13:17.677]                   muffleCondition(cond)
[16:13:17.677]                 })
[16:13:17.677]             }))
[16:13:17.677]             future::FutureResult(value = ...future.value$value, 
[16:13:17.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.677]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.677]                     ...future.globalenv.names))
[16:13:17.677]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.677]         }, condition = base::local({
[16:13:17.677]             c <- base::c
[16:13:17.677]             inherits <- base::inherits
[16:13:17.677]             invokeRestart <- base::invokeRestart
[16:13:17.677]             length <- base::length
[16:13:17.677]             list <- base::list
[16:13:17.677]             seq.int <- base::seq.int
[16:13:17.677]             signalCondition <- base::signalCondition
[16:13:17.677]             sys.calls <- base::sys.calls
[16:13:17.677]             `[[` <- base::`[[`
[16:13:17.677]             `+` <- base::`+`
[16:13:17.677]             `<<-` <- base::`<<-`
[16:13:17.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.677]                   3L)]
[16:13:17.677]             }
[16:13:17.677]             function(cond) {
[16:13:17.677]                 is_error <- inherits(cond, "error")
[16:13:17.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.677]                   NULL)
[16:13:17.677]                 if (is_error) {
[16:13:17.677]                   sessionInformation <- function() {
[16:13:17.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.677]                       search = base::search(), system = base::Sys.info())
[16:13:17.677]                   }
[16:13:17.677]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.677]                     cond$call), session = sessionInformation(), 
[16:13:17.677]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.677]                   signalCondition(cond)
[16:13:17.677]                 }
[16:13:17.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.677]                 "immediateCondition"))) {
[16:13:17.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.677]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.677]                   if (TRUE && !signal) {
[16:13:17.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.677]                     {
[16:13:17.677]                       inherits <- base::inherits
[16:13:17.677]                       invokeRestart <- base::invokeRestart
[16:13:17.677]                       is.null <- base::is.null
[16:13:17.677]                       muffled <- FALSE
[16:13:17.677]                       if (inherits(cond, "message")) {
[16:13:17.677]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.677]                         if (muffled) 
[16:13:17.677]                           invokeRestart("muffleMessage")
[16:13:17.677]                       }
[16:13:17.677]                       else if (inherits(cond, "warning")) {
[16:13:17.677]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.677]                         if (muffled) 
[16:13:17.677]                           invokeRestart("muffleWarning")
[16:13:17.677]                       }
[16:13:17.677]                       else if (inherits(cond, "condition")) {
[16:13:17.677]                         if (!is.null(pattern)) {
[16:13:17.677]                           computeRestarts <- base::computeRestarts
[16:13:17.677]                           grepl <- base::grepl
[16:13:17.677]                           restarts <- computeRestarts(cond)
[16:13:17.677]                           for (restart in restarts) {
[16:13:17.677]                             name <- restart$name
[16:13:17.677]                             if (is.null(name)) 
[16:13:17.677]                               next
[16:13:17.677]                             if (!grepl(pattern, name)) 
[16:13:17.677]                               next
[16:13:17.677]                             invokeRestart(restart)
[16:13:17.677]                             muffled <- TRUE
[16:13:17.677]                             break
[16:13:17.677]                           }
[16:13:17.677]                         }
[16:13:17.677]                       }
[16:13:17.677]                       invisible(muffled)
[16:13:17.677]                     }
[16:13:17.677]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.677]                   }
[16:13:17.677]                 }
[16:13:17.677]                 else {
[16:13:17.677]                   if (TRUE) {
[16:13:17.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.677]                     {
[16:13:17.677]                       inherits <- base::inherits
[16:13:17.677]                       invokeRestart <- base::invokeRestart
[16:13:17.677]                       is.null <- base::is.null
[16:13:17.677]                       muffled <- FALSE
[16:13:17.677]                       if (inherits(cond, "message")) {
[16:13:17.677]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.677]                         if (muffled) 
[16:13:17.677]                           invokeRestart("muffleMessage")
[16:13:17.677]                       }
[16:13:17.677]                       else if (inherits(cond, "warning")) {
[16:13:17.677]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.677]                         if (muffled) 
[16:13:17.677]                           invokeRestart("muffleWarning")
[16:13:17.677]                       }
[16:13:17.677]                       else if (inherits(cond, "condition")) {
[16:13:17.677]                         if (!is.null(pattern)) {
[16:13:17.677]                           computeRestarts <- base::computeRestarts
[16:13:17.677]                           grepl <- base::grepl
[16:13:17.677]                           restarts <- computeRestarts(cond)
[16:13:17.677]                           for (restart in restarts) {
[16:13:17.677]                             name <- restart$name
[16:13:17.677]                             if (is.null(name)) 
[16:13:17.677]                               next
[16:13:17.677]                             if (!grepl(pattern, name)) 
[16:13:17.677]                               next
[16:13:17.677]                             invokeRestart(restart)
[16:13:17.677]                             muffled <- TRUE
[16:13:17.677]                             break
[16:13:17.677]                           }
[16:13:17.677]                         }
[16:13:17.677]                       }
[16:13:17.677]                       invisible(muffled)
[16:13:17.677]                     }
[16:13:17.677]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.677]                   }
[16:13:17.677]                 }
[16:13:17.677]             }
[16:13:17.677]         }))
[16:13:17.677]     }, error = function(ex) {
[16:13:17.677]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.677]                 ...future.rng), started = ...future.startTime, 
[16:13:17.677]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.677]             version = "1.8"), class = "FutureResult")
[16:13:17.677]     }, finally = {
[16:13:17.677]         if (!identical(...future.workdir, getwd())) 
[16:13:17.677]             setwd(...future.workdir)
[16:13:17.677]         {
[16:13:17.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.677]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.677]             }
[16:13:17.677]             base::options(...future.oldOptions)
[16:13:17.677]             if (.Platform$OS.type == "windows") {
[16:13:17.677]                 old_names <- names(...future.oldEnvVars)
[16:13:17.677]                 envs <- base::Sys.getenv()
[16:13:17.677]                 names <- names(envs)
[16:13:17.677]                 common <- intersect(names, old_names)
[16:13:17.677]                 added <- setdiff(names, old_names)
[16:13:17.677]                 removed <- setdiff(old_names, names)
[16:13:17.677]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.677]                   envs[common]]
[16:13:17.677]                 NAMES <- toupper(changed)
[16:13:17.677]                 args <- list()
[16:13:17.677]                 for (kk in seq_along(NAMES)) {
[16:13:17.677]                   name <- changed[[kk]]
[16:13:17.677]                   NAME <- NAMES[[kk]]
[16:13:17.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.677]                     next
[16:13:17.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.677]                 }
[16:13:17.677]                 NAMES <- toupper(added)
[16:13:17.677]                 for (kk in seq_along(NAMES)) {
[16:13:17.677]                   name <- added[[kk]]
[16:13:17.677]                   NAME <- NAMES[[kk]]
[16:13:17.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.677]                     next
[16:13:17.677]                   args[[name]] <- ""
[16:13:17.677]                 }
[16:13:17.677]                 NAMES <- toupper(removed)
[16:13:17.677]                 for (kk in seq_along(NAMES)) {
[16:13:17.677]                   name <- removed[[kk]]
[16:13:17.677]                   NAME <- NAMES[[kk]]
[16:13:17.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.677]                     next
[16:13:17.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.677]                 }
[16:13:17.677]                 if (length(args) > 0) 
[16:13:17.677]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.677]             }
[16:13:17.677]             else {
[16:13:17.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.677]             }
[16:13:17.677]             {
[16:13:17.677]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.677]                   0L) {
[16:13:17.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.677]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.677]                   base::options(opts)
[16:13:17.677]                 }
[16:13:17.677]                 {
[16:13:17.677]                   {
[16:13:17.677]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:17.677]                     NULL
[16:13:17.677]                   }
[16:13:17.677]                   options(future.plan = NULL)
[16:13:17.677]                   if (is.na(NA_character_)) 
[16:13:17.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.677]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.677]                     envir = parent.frame()) 
[16:13:17.677]                   {
[16:13:17.677]                     default_workers <- missing(workers)
[16:13:17.677]                     if (is.function(workers)) 
[16:13:17.677]                       workers <- workers()
[16:13:17.677]                     workers <- structure(as.integer(workers), 
[16:13:17.677]                       class = class(workers))
[16:13:17.677]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.677]                       1L)
[16:13:17.677]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.677]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.677]                       if (default_workers) 
[16:13:17.677]                         supportsMulticore(warn = TRUE)
[16:13:17.677]                       return(sequential(..., envir = envir))
[16:13:17.677]                     }
[16:13:17.677]                     oopts <- options(mc.cores = workers)
[16:13:17.677]                     on.exit(options(oopts))
[16:13:17.677]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.677]                       envir = envir)
[16:13:17.677]                     if (!future$lazy) 
[16:13:17.677]                       future <- run(future)
[16:13:17.677]                     invisible(future)
[16:13:17.677]                   }, b = function (..., envir = parent.frame()) 
[16:13:17.677]                   {
[16:13:17.677]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.677]                     if (!future$lazy) 
[16:13:17.677]                       future <- run(future)
[16:13:17.677]                     invisible(future)
[16:13:17.677]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.677]                 }
[16:13:17.677]             }
[16:13:17.677]         }
[16:13:17.677]     })
[16:13:17.677]     if (TRUE) {
[16:13:17.677]         base::sink(type = "output", split = FALSE)
[16:13:17.677]         if (TRUE) {
[16:13:17.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.677]         }
[16:13:17.677]         else {
[16:13:17.677]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.677]         }
[16:13:17.677]         base::close(...future.stdout)
[16:13:17.677]         ...future.stdout <- NULL
[16:13:17.677]     }
[16:13:17.677]     ...future.result$conditions <- ...future.conditions
[16:13:17.677]     ...future.result$finished <- base::Sys.time()
[16:13:17.677]     ...future.result
[16:13:17.677] }
[16:13:17.680] assign_globals() ...
[16:13:17.680] List of 2
[16:13:17.680]  $ nested   :List of 2
[16:13:17.680]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:17.680]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:17.680]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.680]   ..$ b:function (..., envir = parent.frame())  
[16:13:17.680]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:17.680]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.680]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:17.680]  $ strategy2: chr "sequential"
[16:13:17.680]  - attr(*, "where")=List of 2
[16:13:17.680]   ..$ nested   :<environment: R_EmptyEnv> 
[16:13:17.680]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:13:17.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.680]  - attr(*, "resolved")= logi FALSE
[16:13:17.680]  - attr(*, "total_size")= num 59224
[16:13:17.680]  - attr(*, "already-done")= logi TRUE
[16:13:17.684] - copied ‘nested’ to environment
[16:13:17.684] - copied ‘strategy2’ to environment
[16:13:17.684] assign_globals() ... done
[16:13:17.684] requestCore(): workers = 2
[16:13:17.687] MulticoreFuture started
[16:13:17.687] - Launch lazy future ... done
[16:13:17.687] run() for ‘MulticoreFuture’ ... done
[16:13:17.688] plan(): Setting new future strategy stack:
[16:13:17.689] List of future strategies:
[16:13:17.689] 1. sequential:
[16:13:17.689]    - args: function (..., envir = parent.frame())
[16:13:17.689]    - tweaked: FALSE
[16:13:17.689]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.689] plan(): nbrOfWorkers() = 1
[16:13:17.726] plan(): Setting new future strategy stack:
[16:13:17.726] List of future strategies:
[16:13:17.726] 1. multicore:
[16:13:17.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.726]    - tweaked: FALSE
[16:13:17.726]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.726] 2. sequential:
[16:13:17.726]    - args: function (..., envir = parent.frame())
[16:13:17.726]    - tweaked: FALSE
[16:13:17.726]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.731] plan(): nbrOfWorkers() = 2
[16:13:17.732] signalConditions() ...
[16:13:17.733]  - include = ‘immediateCondition’
[16:13:17.733]  - exclude = 
[16:13:17.733]  - resignal = FALSE
[16:13:17.733]  - Number of conditions: 54
[16:13:17.733] signalConditions() ... done
[16:13:17.733] signalConditions() ...
[16:13:17.733]  - include = ‘immediateCondition’
[16:13:17.733]  - exclude = 
[16:13:17.734]  - resignal = FALSE
[16:13:17.734]  - Number of conditions: 54
[16:13:17.734] signalConditions() ... done
[16:13:17.734] Future state: ‘finished’
[16:13:17.734] signalConditions() ...
[16:13:17.734]  - include = ‘condition’
[16:13:17.734]  - exclude = ‘immediateCondition’
[16:13:17.734]  - resignal = TRUE
[16:13:17.735]  - Number of conditions: 54
[16:13:17.735]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.691] getGlobalsAndPackages() ...
[16:13:17.735]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.692] Searching for globals...
[16:13:17.735]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.701] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:13:17.735]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.701] Searching for globals ... DONE
[16:13:17.735]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.702] Resolving globals: FALSE
[16:13:17.736]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.703] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[16:13:17.736]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.704] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:13:17.736]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.704] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:13:17.736]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.705] 
[16:13:17.736]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.705] getGlobalsAndPackages() ... DONE
[16:13:17.737]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.706] run() for ‘Future’ ...
[16:13:17.737]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.706] - state: ‘created’
[16:13:17.737]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.706] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:17.737]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:17.737]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:17.738]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.707]   - Field: ‘label’
[16:13:17.738]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.707]   - Field: ‘local’
[16:13:17.738]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.707]   - Field: ‘owner’
[16:13:17.738]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.708]   - Field: ‘envir’
[16:13:17.738]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.708]   - Field: ‘packages’
[16:13:17.738]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.708]   - Field: ‘gc’
[16:13:17.739]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.708]   - Field: ‘conditions’
[16:13:17.739]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.708]   - Field: ‘expr’
[16:13:17.739]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.708]   - Field: ‘uuid’
[16:13:17.739]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘seed’
[16:13:17.739]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘version’
[16:13:17.740]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘result’
[16:13:17.740]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘asynchronous’
[16:13:17.740]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘calls’
[16:13:17.740]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘globals’
[16:13:17.740]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.709]   - Field: ‘stdout’
[16:13:17.740]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.710]   - Field: ‘earlySignal’
[16:13:17.741]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.710]   - Field: ‘lazy’
[16:13:17.741]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.710]   - Field: ‘state’
[16:13:17.741]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:17.741]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.710] - Launch lazy future ...
[16:13:17.741]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.711] Packages needed by the future expression (n = 0): <none>
[16:13:17.741]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.711] Packages needed by future strategies (n = 0): <none>
[16:13:17.742]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.711] {
[16:13:17.711]     {
[16:13:17.711]         {
[16:13:17.711]             ...future.startTime <- base::Sys.time()
[16:13:17.711]             {
[16:13:17.711]                 {
[16:13:17.711]                   {
[16:13:17.711]                     base::local({
[16:13:17.711]                       has_future <- base::requireNamespace("future", 
[16:13:17.711]                         quietly = TRUE)
[16:13:17.711]                       if (has_future) {
[16:13:17.711]                         ns <- base::getNamespace("future")
[16:13:17.711]                         version <- ns[[".package"]][["version"]]
[16:13:17.711]                         if (is.null(version)) 
[16:13:17.711]                           version <- utils::packageVersion("future")
[16:13:17.711]                       }
[16:13:17.711]                       else {
[16:13:17.711]                         version <- NULL
[16:13:17.711]                       }
[16:13:17.711]                       if (!has_future || version < "1.8.0") {
[16:13:17.711]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.711]                           "", base::R.version$version.string), 
[16:13:17.711]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:17.711]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.711]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.711]                             "release", "version")], collapse = " "), 
[16:13:17.711]                           hostname = base::Sys.info()[["nodename"]])
[16:13:17.711]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.711]                           info)
[16:13:17.711]                         info <- base::paste(info, collapse = "; ")
[16:13:17.711]                         if (!has_future) {
[16:13:17.711]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.711]                             info)
[16:13:17.711]                         }
[16:13:17.711]                         else {
[16:13:17.711]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.711]                             info, version)
[16:13:17.711]                         }
[16:13:17.711]                         base::stop(msg)
[16:13:17.711]                       }
[16:13:17.711]                     })
[16:13:17.711]                   }
[16:13:17.711]                   options(future.plan = NULL)
[16:13:17.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:17.711]                 }
[16:13:17.711]                 ...future.workdir <- getwd()
[16:13:17.711]             }
[16:13:17.711]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.711]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.711]         }
[16:13:17.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.711]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.711]             base::names(...future.oldOptions))
[16:13:17.711]     }
[16:13:17.711]     if (FALSE) {
[16:13:17.711]     }
[16:13:17.711]     else {
[16:13:17.711]         if (TRUE) {
[16:13:17.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.711]                 open = "w")
[16:13:17.711]         }
[16:13:17.711]         else {
[16:13:17.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.711]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.711]         }
[16:13:17.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.711]             base::sink(type = "output", split = FALSE)
[16:13:17.711]             base::close(...future.stdout)
[16:13:17.711]         }, add = TRUE)
[16:13:17.711]     }
[16:13:17.711]     ...future.frame <- base::sys.nframe()
[16:13:17.711]     ...future.conditions <- base::list()
[16:13:17.711]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.711]     if (FALSE) {
[16:13:17.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.711]     }
[16:13:17.711]     ...future.result <- base::tryCatch({
[16:13:17.711]         base::withCallingHandlers({
[16:13:17.711]             ...future.value <- base::withVisible(base::local({
[16:13:17.711]                 b <- 2L
[16:13:17.711]                 plan_b <- future::plan("list")
[16:13:17.711]                 nested_b <- nested_a[-1]
[16:13:17.711]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:17.711]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:17.711]                   "sequential"))
[16:13:17.711]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:17.711]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:17.711]             }))
[16:13:17.711]             future::FutureResult(value = ...future.value$value, 
[16:13:17.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.711]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.711]                     ...future.globalenv.names))
[16:13:17.711]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.711]         }, condition = base::local({
[16:13:17.711]             c <- base::c
[16:13:17.711]             inherits <- base::inherits
[16:13:17.711]             invokeRestart <- base::invokeRestart
[16:13:17.711]             length <- base::length
[16:13:17.711]             list <- base::list
[16:13:17.711]             seq.int <- base::seq.int
[16:13:17.711]             signalCondition <- base::signalCondition
[16:13:17.711]             sys.calls <- base::sys.calls
[16:13:17.711]             `[[` <- base::`[[`
[16:13:17.711]             `+` <- base::`+`
[16:13:17.711]             `<<-` <- base::`<<-`
[16:13:17.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.711]                   3L)]
[16:13:17.711]             }
[16:13:17.711]             function(cond) {
[16:13:17.711]                 is_error <- inherits(cond, "error")
[16:13:17.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.711]                   NULL)
[16:13:17.711]                 if (is_error) {
[16:13:17.711]                   sessionInformation <- function() {
[16:13:17.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.711]                       search = base::search(), system = base::Sys.info())
[16:13:17.711]                   }
[16:13:17.711]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.711]                     cond$call), session = sessionInformation(), 
[16:13:17.711]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.711]                   signalCondition(cond)
[16:13:17.711]                 }
[16:13:17.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.711]                 "immediateCondition"))) {
[16:13:17.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.711]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.711]                   if (TRUE && !signal) {
[16:13:17.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.711]                     {
[16:13:17.711]                       inherits <- base::inherits
[16:13:17.711]                       invokeRestart <- base::invokeRestart
[16:13:17.711]                       is.null <- base::is.null
[16:13:17.711]                       muffled <- FALSE
[16:13:17.711]                       if (inherits(cond, "message")) {
[16:13:17.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.711]                         if (muffled) 
[16:13:17.711]                           invokeRestart("muffleMessage")
[16:13:17.711]                       }
[16:13:17.711]                       else if (inherits(cond, "warning")) {
[16:13:17.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.711]                         if (muffled) 
[16:13:17.711]                           invokeRestart("muffleWarning")
[16:13:17.711]                       }
[16:13:17.711]                       else if (inherits(cond, "condition")) {
[16:13:17.711]                         if (!is.null(pattern)) {
[16:13:17.711]                           computeRestarts <- base::computeRestarts
[16:13:17.711]                           grepl <- base::grepl
[16:13:17.711]                           restarts <- computeRestarts(cond)
[16:13:17.711]                           for (restart in restarts) {
[16:13:17.711]                             name <- restart$name
[16:13:17.711]                             if (is.null(name)) 
[16:13:17.711]                               next
[16:13:17.711]                             if (!grepl(pattern, name)) 
[16:13:17.711]                               next
[16:13:17.711]                             invokeRestart(restart)
[16:13:17.711]                             muffled <- TRUE
[16:13:17.711]                             break
[16:13:17.711]                           }
[16:13:17.711]                         }
[16:13:17.711]                       }
[16:13:17.711]                       invisible(muffled)
[16:13:17.711]                     }
[16:13:17.711]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.711]                   }
[16:13:17.711]                 }
[16:13:17.711]                 else {
[16:13:17.711]                   if (TRUE) {
[16:13:17.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.711]                     {
[16:13:17.711]                       inherits <- base::inherits
[16:13:17.711]                       invokeRestart <- base::invokeRestart
[16:13:17.711]                       is.null <- base::is.null
[16:13:17.711]                       muffled <- FALSE
[16:13:17.711]                       if (inherits(cond, "message")) {
[16:13:17.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.711]                         if (muffled) 
[16:13:17.711]                           invokeRestart("muffleMessage")
[16:13:17.711]                       }
[16:13:17.711]                       else if (inherits(cond, "warning")) {
[16:13:17.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.711]                         if (muffled) 
[16:13:17.711]                           invokeRestart("muffleWarning")
[16:13:17.711]                       }
[16:13:17.711]                       else if (inherits(cond, "condition")) {
[16:13:17.711]                         if (!is.null(pattern)) {
[16:13:17.711]                           computeRestarts <- base::computeRestarts
[16:13:17.711]                           grepl <- base::grepl
[16:13:17.711]                           restarts <- computeRestarts(cond)
[16:13:17.711]                           for (restart in restarts) {
[16:13:17.711]                             name <- restart$name
[16:13:17.711]                             if (is.null(name)) 
[16:13:17.711]                               next
[16:13:17.711]                             if (!grepl(pattern, name)) 
[16:13:17.711]                               next
[16:13:17.711]                             invokeRestart(restart)
[16:13:17.711]                             muffled <- TRUE
[16:13:17.711]                             break
[16:13:17.711]                           }
[16:13:17.711]                         }
[16:13:17.711]                       }
[16:13:17.711]                       invisible(muffled)
[16:13:17.711]                     }
[16:13:17.711]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.711]                   }
[16:13:17.711]                 }
[16:13:17.711]             }
[16:13:17.711]         }))
[16:13:17.711]     }, error = function(ex) {
[16:13:17.711]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.711]                 ...future.rng), started = ...future.startTime, 
[16:13:17.711]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.711]             version = "1.8"), class = "FutureResult")
[16:13:17.711]     }, finally = {
[16:13:17.711]         if (!identical(...future.workdir, getwd())) 
[16:13:17.711]             setwd(...future.workdir)
[16:13:17.711]         {
[16:13:17.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.711]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.711]             }
[16:13:17.711]             base::options(...future.oldOptions)
[16:13:17.711]             if (.Platform$OS.type == "windows") {
[16:13:17.711]                 old_names <- names(...future.oldEnvVars)
[16:13:17.711]                 envs <- base::Sys.getenv()
[16:13:17.711]                 names <- names(envs)
[16:13:17.711]                 common <- intersect(names, old_names)
[16:13:17.711]                 added <- setdiff(names, old_names)
[16:13:17.711]                 removed <- setdiff(old_names, names)
[16:13:17.711]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.711]                   envs[common]]
[16:13:17.711]                 NAMES <- toupper(changed)
[16:13:17.711]                 args <- list()
[16:13:17.711]                 for (kk in seq_along(NAMES)) {
[16:13:17.711]                   name <- changed[[kk]]
[16:13:17.711]                   NAME <- NAMES[[kk]]
[16:13:17.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.711]                     next
[16:13:17.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.711]                 }
[16:13:17.711]                 NAMES <- toupper(added)
[16:13:17.711]                 for (kk in seq_along(NAMES)) {
[16:13:17.711]                   name <- added[[kk]]
[16:13:17.711]                   NAME <- NAMES[[kk]]
[16:13:17.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.711]                     next
[16:13:17.711]                   args[[name]] <- ""
[16:13:17.711]                 }
[16:13:17.711]                 NAMES <- toupper(removed)
[16:13:17.711]                 for (kk in seq_along(NAMES)) {
[16:13:17.711]                   name <- removed[[kk]]
[16:13:17.711]                   NAME <- NAMES[[kk]]
[16:13:17.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.711]                     next
[16:13:17.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.711]                 }
[16:13:17.711]                 if (length(args) > 0) 
[16:13:17.711]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.711]             }
[16:13:17.711]             else {
[16:13:17.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.711]             }
[16:13:17.711]             {
[16:13:17.711]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.711]                   0L) {
[16:13:17.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.711]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.711]                   base::options(opts)
[16:13:17.711]                 }
[16:13:17.711]                 {
[16:13:17.711]                   {
[16:13:17.711]                     NULL
[16:13:17.711]                     RNGkind("Mersenne-Twister")
[16:13:17.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:17.711]                       inherits = FALSE)
[16:13:17.711]                   }
[16:13:17.711]                   options(future.plan = NULL)
[16:13:17.711]                   if (is.na(NA_character_)) 
[16:13:17.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.711]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:17.711]                   {
[16:13:17.711]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.711]                     if (!future$lazy) 
[16:13:17.711]                       future <- run(future)
[16:13:17.711]                     invisible(future)
[16:13:17.711]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.711]                 }
[16:13:17.711]             }
[16:13:17.711]         }
[16:13:17.711]     })
[16:13:17.711]     if (TRUE) {
[16:13:17.711]         base::sink(type = "output", split = FALSE)
[16:13:17.711]         if (TRUE) {
[16:13:17.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.711]         }
[16:13:17.711]         else {
[16:13:17.711]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.711]         }
[16:13:17.711]         base::close(...future.stdout)
[16:13:17.711]         ...future.stdout <- NULL
[16:13:17.711]     }
[16:13:17.711]     ...future.result$conditions <- ...future.conditions
[16:13:17.711]     ...future.result$finished <- base::Sys.time()
[16:13:17.711]     ...future.result
[16:13:17.711] }
[16:13:17.742]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.714] assign_globals() ...
[16:13:17.742]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.714] List of 3
[16:13:17.714]  $ nested_a:List of 1
[16:13:17.714]   ..$ b:function (..., envir = parent.frame())  
[16:13:17.714]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:17.714]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.714]  $ a       : int 1
[16:13:17.714]  $ plan_a  :List of 1
[16:13:17.714]   ..$ b:function (..., envir = parent.frame())  
[16:13:17.714]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[16:13:17.714]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.714]  - attr(*, "where")=List of 3
[16:13:17.714]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:13:17.714]   ..$ a       :<environment: R_EmptyEnv> 
[16:13:17.714]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:13:17.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.714]  - attr(*, "resolved")= logi FALSE
[16:13:17.714]  - attr(*, "total_size")= num 23080
[16:13:17.714]  - attr(*, "already-done")= logi TRUE
[16:13:17.742]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.722] - copied ‘nested_a’ to environment
[16:13:17.743]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.722] - copied ‘a’ to environment
[16:13:17.743]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.722] - copied ‘plan_a’ to environment
[16:13:17.743]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.722] assign_globals() ... done
[16:13:17.743]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.723] plan(): Setting new future strategy stack:
[16:13:17.743]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.723] List of future strategies:
[16:13:17.723] 1. sequential:
[16:13:17.723]    - args: function (..., envir = parent.frame())
[16:13:17.723]    - tweaked: FALSE
[16:13:17.723]    - call: NULL
[16:13:17.743]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.723] plan(): nbrOfWorkers() = 1
[16:13:17.744]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.724] plan(): Setting new future strategy stack:
[16:13:17.744]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.725] List of future strategies:
[16:13:17.725] 1. sequential:
[16:13:17.725]    - args: function (..., envir = parent.frame())
[16:13:17.725]    - tweaked: FALSE
[16:13:17.725]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.744]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.725] plan(): nbrOfWorkers() = 1
[16:13:17.744]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.725] SequentialFuture started (and completed)
[16:13:17.744]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.725] - Launch lazy future ... done
[16:13:17.745]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.726] run() for ‘SequentialFuture’ ... done
[16:13:17.745] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:17.751] getGlobalsAndPackages() ...
[16:13:17.751] Searching for globals...
[16:13:17.753] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:17.753] Searching for globals ... DONE
[16:13:17.753] Resolving globals: FALSE
[16:13:17.754] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:17.754] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:17.754] - globals: [1] ‘data’
[16:13:17.755] - packages: [1] ‘future’
[16:13:17.755] getGlobalsAndPackages() ... DONE
[16:13:17.755] run() for ‘Future’ ...
[16:13:17.755] - state: ‘created’
[16:13:17.755] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:17.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:17.760]   - Field: ‘label’
[16:13:17.760]   - Field: ‘local’
[16:13:17.760]   - Field: ‘owner’
[16:13:17.760]   - Field: ‘envir’
[16:13:17.760]   - Field: ‘workers’
[16:13:17.760]   - Field: ‘packages’
[16:13:17.761]   - Field: ‘gc’
[16:13:17.761]   - Field: ‘job’
[16:13:17.761]   - Field: ‘conditions’
[16:13:17.761]   - Field: ‘expr’
[16:13:17.761]   - Field: ‘uuid’
[16:13:17.761]   - Field: ‘seed’
[16:13:17.761]   - Field: ‘version’
[16:13:17.761]   - Field: ‘result’
[16:13:17.761]   - Field: ‘asynchronous’
[16:13:17.762]   - Field: ‘calls’
[16:13:17.762]   - Field: ‘globals’
[16:13:17.762]   - Field: ‘stdout’
[16:13:17.762]   - Field: ‘earlySignal’
[16:13:17.762]   - Field: ‘lazy’
[16:13:17.762]   - Field: ‘state’
[16:13:17.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:17.762] - Launch lazy future ...
[16:13:17.763] Packages needed by the future expression (n = 1): ‘future’
[16:13:17.763] Packages needed by future strategies (n = 1): ‘future’
[16:13:17.763] {
[16:13:17.763]     {
[16:13:17.763]         {
[16:13:17.763]             ...future.startTime <- base::Sys.time()
[16:13:17.763]             {
[16:13:17.763]                 {
[16:13:17.763]                   {
[16:13:17.763]                     {
[16:13:17.763]                       {
[16:13:17.763]                         base::local({
[16:13:17.763]                           has_future <- base::requireNamespace("future", 
[16:13:17.763]                             quietly = TRUE)
[16:13:17.763]                           if (has_future) {
[16:13:17.763]                             ns <- base::getNamespace("future")
[16:13:17.763]                             version <- ns[[".package"]][["version"]]
[16:13:17.763]                             if (is.null(version)) 
[16:13:17.763]                               version <- utils::packageVersion("future")
[16:13:17.763]                           }
[16:13:17.763]                           else {
[16:13:17.763]                             version <- NULL
[16:13:17.763]                           }
[16:13:17.763]                           if (!has_future || version < "1.8.0") {
[16:13:17.763]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.763]                               "", base::R.version$version.string), 
[16:13:17.763]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:17.763]                                 base::R.version$platform, 8 * 
[16:13:17.763]                                   base::.Machine$sizeof.pointer), 
[16:13:17.763]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.763]                                 "release", "version")], collapse = " "), 
[16:13:17.763]                               hostname = base::Sys.info()[["nodename"]])
[16:13:17.763]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.763]                               info)
[16:13:17.763]                             info <- base::paste(info, collapse = "; ")
[16:13:17.763]                             if (!has_future) {
[16:13:17.763]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.763]                                 info)
[16:13:17.763]                             }
[16:13:17.763]                             else {
[16:13:17.763]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.763]                                 info, version)
[16:13:17.763]                             }
[16:13:17.763]                             base::stop(msg)
[16:13:17.763]                           }
[16:13:17.763]                         })
[16:13:17.763]                       }
[16:13:17.763]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:17.763]                       base::options(mc.cores = 1L)
[16:13:17.763]                     }
[16:13:17.763]                     base::local({
[16:13:17.763]                       for (pkg in "future") {
[16:13:17.763]                         base::loadNamespace(pkg)
[16:13:17.763]                         base::library(pkg, character.only = TRUE)
[16:13:17.763]                       }
[16:13:17.763]                     })
[16:13:17.763]                   }
[16:13:17.763]                   options(future.plan = NULL)
[16:13:17.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.763]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:17.763]                   {
[16:13:17.763]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.763]                     if (!future$lazy) 
[16:13:17.763]                       future <- run(future)
[16:13:17.763]                     invisible(future)
[16:13:17.763]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.763]                 }
[16:13:17.763]                 ...future.workdir <- getwd()
[16:13:17.763]             }
[16:13:17.763]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.763]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.763]         }
[16:13:17.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.763]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.763]             base::names(...future.oldOptions))
[16:13:17.763]     }
[16:13:17.763]     if (FALSE) {
[16:13:17.763]     }
[16:13:17.763]     else {
[16:13:17.763]         if (TRUE) {
[16:13:17.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.763]                 open = "w")
[16:13:17.763]         }
[16:13:17.763]         else {
[16:13:17.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.763]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.763]         }
[16:13:17.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.763]             base::sink(type = "output", split = FALSE)
[16:13:17.763]             base::close(...future.stdout)
[16:13:17.763]         }, add = TRUE)
[16:13:17.763]     }
[16:13:17.763]     ...future.frame <- base::sys.nframe()
[16:13:17.763]     ...future.conditions <- base::list()
[16:13:17.763]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.763]     if (FALSE) {
[16:13:17.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.763]     }
[16:13:17.763]     ...future.result <- base::tryCatch({
[16:13:17.763]         base::withCallingHandlers({
[16:13:17.763]             ...future.value <- base::withVisible(base::local({
[16:13:17.763]                 withCallingHandlers({
[16:13:17.763]                   {
[16:13:17.763]                     value(future(subset(data, a == 2)))
[16:13:17.763]                   }
[16:13:17.763]                 }, immediateCondition = function(cond) {
[16:13:17.763]                   save_rds <- function (object, pathname, ...) 
[16:13:17.763]                   {
[16:13:17.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:17.763]                     if (file_test("-f", pathname_tmp)) {
[16:13:17.763]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:17.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.763]                         fi_tmp[["mtime"]])
[16:13:17.763]                     }
[16:13:17.763]                     tryCatch({
[16:13:17.763]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:17.763]                     }, error = function(ex) {
[16:13:17.763]                       msg <- conditionMessage(ex)
[16:13:17.763]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:17.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.763]                         fi_tmp[["mtime"]], msg)
[16:13:17.763]                       ex$message <- msg
[16:13:17.763]                       stop(ex)
[16:13:17.763]                     })
[16:13:17.763]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:17.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:17.763]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:17.763]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.763]                       fi <- file.info(pathname)
[16:13:17.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:17.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:17.763]                         fi[["size"]], fi[["mtime"]])
[16:13:17.763]                       stop(msg)
[16:13:17.763]                     }
[16:13:17.763]                     invisible(pathname)
[16:13:17.763]                   }
[16:13:17.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:17.763]                     rootPath = tempdir()) 
[16:13:17.763]                   {
[16:13:17.763]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:17.763]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:17.763]                       tmpdir = path, fileext = ".rds")
[16:13:17.763]                     save_rds(obj, file)
[16:13:17.763]                   }
[16:13:17.763]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:17.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.763]                   {
[16:13:17.763]                     inherits <- base::inherits
[16:13:17.763]                     invokeRestart <- base::invokeRestart
[16:13:17.763]                     is.null <- base::is.null
[16:13:17.763]                     muffled <- FALSE
[16:13:17.763]                     if (inherits(cond, "message")) {
[16:13:17.763]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:17.763]                       if (muffled) 
[16:13:17.763]                         invokeRestart("muffleMessage")
[16:13:17.763]                     }
[16:13:17.763]                     else if (inherits(cond, "warning")) {
[16:13:17.763]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:17.763]                       if (muffled) 
[16:13:17.763]                         invokeRestart("muffleWarning")
[16:13:17.763]                     }
[16:13:17.763]                     else if (inherits(cond, "condition")) {
[16:13:17.763]                       if (!is.null(pattern)) {
[16:13:17.763]                         computeRestarts <- base::computeRestarts
[16:13:17.763]                         grepl <- base::grepl
[16:13:17.763]                         restarts <- computeRestarts(cond)
[16:13:17.763]                         for (restart in restarts) {
[16:13:17.763]                           name <- restart$name
[16:13:17.763]                           if (is.null(name)) 
[16:13:17.763]                             next
[16:13:17.763]                           if (!grepl(pattern, name)) 
[16:13:17.763]                             next
[16:13:17.763]                           invokeRestart(restart)
[16:13:17.763]                           muffled <- TRUE
[16:13:17.763]                           break
[16:13:17.763]                         }
[16:13:17.763]                       }
[16:13:17.763]                     }
[16:13:17.763]                     invisible(muffled)
[16:13:17.763]                   }
[16:13:17.763]                   muffleCondition(cond)
[16:13:17.763]                 })
[16:13:17.763]             }))
[16:13:17.763]             future::FutureResult(value = ...future.value$value, 
[16:13:17.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.763]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.763]                     ...future.globalenv.names))
[16:13:17.763]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.763]         }, condition = base::local({
[16:13:17.763]             c <- base::c
[16:13:17.763]             inherits <- base::inherits
[16:13:17.763]             invokeRestart <- base::invokeRestart
[16:13:17.763]             length <- base::length
[16:13:17.763]             list <- base::list
[16:13:17.763]             seq.int <- base::seq.int
[16:13:17.763]             signalCondition <- base::signalCondition
[16:13:17.763]             sys.calls <- base::sys.calls
[16:13:17.763]             `[[` <- base::`[[`
[16:13:17.763]             `+` <- base::`+`
[16:13:17.763]             `<<-` <- base::`<<-`
[16:13:17.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.763]                   3L)]
[16:13:17.763]             }
[16:13:17.763]             function(cond) {
[16:13:17.763]                 is_error <- inherits(cond, "error")
[16:13:17.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.763]                   NULL)
[16:13:17.763]                 if (is_error) {
[16:13:17.763]                   sessionInformation <- function() {
[16:13:17.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.763]                       search = base::search(), system = base::Sys.info())
[16:13:17.763]                   }
[16:13:17.763]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.763]                     cond$call), session = sessionInformation(), 
[16:13:17.763]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.763]                   signalCondition(cond)
[16:13:17.763]                 }
[16:13:17.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.763]                 "immediateCondition"))) {
[16:13:17.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.763]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.763]                   if (TRUE && !signal) {
[16:13:17.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.763]                     {
[16:13:17.763]                       inherits <- base::inherits
[16:13:17.763]                       invokeRestart <- base::invokeRestart
[16:13:17.763]                       is.null <- base::is.null
[16:13:17.763]                       muffled <- FALSE
[16:13:17.763]                       if (inherits(cond, "message")) {
[16:13:17.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.763]                         if (muffled) 
[16:13:17.763]                           invokeRestart("muffleMessage")
[16:13:17.763]                       }
[16:13:17.763]                       else if (inherits(cond, "warning")) {
[16:13:17.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.763]                         if (muffled) 
[16:13:17.763]                           invokeRestart("muffleWarning")
[16:13:17.763]                       }
[16:13:17.763]                       else if (inherits(cond, "condition")) {
[16:13:17.763]                         if (!is.null(pattern)) {
[16:13:17.763]                           computeRestarts <- base::computeRestarts
[16:13:17.763]                           grepl <- base::grepl
[16:13:17.763]                           restarts <- computeRestarts(cond)
[16:13:17.763]                           for (restart in restarts) {
[16:13:17.763]                             name <- restart$name
[16:13:17.763]                             if (is.null(name)) 
[16:13:17.763]                               next
[16:13:17.763]                             if (!grepl(pattern, name)) 
[16:13:17.763]                               next
[16:13:17.763]                             invokeRestart(restart)
[16:13:17.763]                             muffled <- TRUE
[16:13:17.763]                             break
[16:13:17.763]                           }
[16:13:17.763]                         }
[16:13:17.763]                       }
[16:13:17.763]                       invisible(muffled)
[16:13:17.763]                     }
[16:13:17.763]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.763]                   }
[16:13:17.763]                 }
[16:13:17.763]                 else {
[16:13:17.763]                   if (TRUE) {
[16:13:17.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.763]                     {
[16:13:17.763]                       inherits <- base::inherits
[16:13:17.763]                       invokeRestart <- base::invokeRestart
[16:13:17.763]                       is.null <- base::is.null
[16:13:17.763]                       muffled <- FALSE
[16:13:17.763]                       if (inherits(cond, "message")) {
[16:13:17.763]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.763]                         if (muffled) 
[16:13:17.763]                           invokeRestart("muffleMessage")
[16:13:17.763]                       }
[16:13:17.763]                       else if (inherits(cond, "warning")) {
[16:13:17.763]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.763]                         if (muffled) 
[16:13:17.763]                           invokeRestart("muffleWarning")
[16:13:17.763]                       }
[16:13:17.763]                       else if (inherits(cond, "condition")) {
[16:13:17.763]                         if (!is.null(pattern)) {
[16:13:17.763]                           computeRestarts <- base::computeRestarts
[16:13:17.763]                           grepl <- base::grepl
[16:13:17.763]                           restarts <- computeRestarts(cond)
[16:13:17.763]                           for (restart in restarts) {
[16:13:17.763]                             name <- restart$name
[16:13:17.763]                             if (is.null(name)) 
[16:13:17.763]                               next
[16:13:17.763]                             if (!grepl(pattern, name)) 
[16:13:17.763]                               next
[16:13:17.763]                             invokeRestart(restart)
[16:13:17.763]                             muffled <- TRUE
[16:13:17.763]                             break
[16:13:17.763]                           }
[16:13:17.763]                         }
[16:13:17.763]                       }
[16:13:17.763]                       invisible(muffled)
[16:13:17.763]                     }
[16:13:17.763]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.763]                   }
[16:13:17.763]                 }
[16:13:17.763]             }
[16:13:17.763]         }))
[16:13:17.763]     }, error = function(ex) {
[16:13:17.763]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.763]                 ...future.rng), started = ...future.startTime, 
[16:13:17.763]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.763]             version = "1.8"), class = "FutureResult")
[16:13:17.763]     }, finally = {
[16:13:17.763]         if (!identical(...future.workdir, getwd())) 
[16:13:17.763]             setwd(...future.workdir)
[16:13:17.763]         {
[16:13:17.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.763]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.763]             }
[16:13:17.763]             base::options(...future.oldOptions)
[16:13:17.763]             if (.Platform$OS.type == "windows") {
[16:13:17.763]                 old_names <- names(...future.oldEnvVars)
[16:13:17.763]                 envs <- base::Sys.getenv()
[16:13:17.763]                 names <- names(envs)
[16:13:17.763]                 common <- intersect(names, old_names)
[16:13:17.763]                 added <- setdiff(names, old_names)
[16:13:17.763]                 removed <- setdiff(old_names, names)
[16:13:17.763]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.763]                   envs[common]]
[16:13:17.763]                 NAMES <- toupper(changed)
[16:13:17.763]                 args <- list()
[16:13:17.763]                 for (kk in seq_along(NAMES)) {
[16:13:17.763]                   name <- changed[[kk]]
[16:13:17.763]                   NAME <- NAMES[[kk]]
[16:13:17.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.763]                     next
[16:13:17.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.763]                 }
[16:13:17.763]                 NAMES <- toupper(added)
[16:13:17.763]                 for (kk in seq_along(NAMES)) {
[16:13:17.763]                   name <- added[[kk]]
[16:13:17.763]                   NAME <- NAMES[[kk]]
[16:13:17.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.763]                     next
[16:13:17.763]                   args[[name]] <- ""
[16:13:17.763]                 }
[16:13:17.763]                 NAMES <- toupper(removed)
[16:13:17.763]                 for (kk in seq_along(NAMES)) {
[16:13:17.763]                   name <- removed[[kk]]
[16:13:17.763]                   NAME <- NAMES[[kk]]
[16:13:17.763]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.763]                     next
[16:13:17.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.763]                 }
[16:13:17.763]                 if (length(args) > 0) 
[16:13:17.763]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.763]             }
[16:13:17.763]             else {
[16:13:17.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.763]             }
[16:13:17.763]             {
[16:13:17.763]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.763]                   0L) {
[16:13:17.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.763]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.763]                   base::options(opts)
[16:13:17.763]                 }
[16:13:17.763]                 {
[16:13:17.763]                   {
[16:13:17.763]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:17.763]                     NULL
[16:13:17.763]                   }
[16:13:17.763]                   options(future.plan = NULL)
[16:13:17.763]                   if (is.na(NA_character_)) 
[16:13:17.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.763]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.763]                     envir = parent.frame()) 
[16:13:17.763]                   {
[16:13:17.763]                     default_workers <- missing(workers)
[16:13:17.763]                     if (is.function(workers)) 
[16:13:17.763]                       workers <- workers()
[16:13:17.763]                     workers <- structure(as.integer(workers), 
[16:13:17.763]                       class = class(workers))
[16:13:17.763]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.763]                       1L)
[16:13:17.763]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.763]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.763]                       if (default_workers) 
[16:13:17.763]                         supportsMulticore(warn = TRUE)
[16:13:17.763]                       return(sequential(..., envir = envir))
[16:13:17.763]                     }
[16:13:17.763]                     oopts <- options(mc.cores = workers)
[16:13:17.763]                     on.exit(options(oopts))
[16:13:17.763]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.763]                       envir = envir)
[16:13:17.763]                     if (!future$lazy) 
[16:13:17.763]                       future <- run(future)
[16:13:17.763]                     invisible(future)
[16:13:17.763]                   }, b = function (..., envir = parent.frame()) 
[16:13:17.763]                   {
[16:13:17.763]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.763]                     if (!future$lazy) 
[16:13:17.763]                       future <- run(future)
[16:13:17.763]                     invisible(future)
[16:13:17.763]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.763]                 }
[16:13:17.763]             }
[16:13:17.763]         }
[16:13:17.763]     })
[16:13:17.763]     if (TRUE) {
[16:13:17.763]         base::sink(type = "output", split = FALSE)
[16:13:17.763]         if (TRUE) {
[16:13:17.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.763]         }
[16:13:17.763]         else {
[16:13:17.763]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.763]         }
[16:13:17.763]         base::close(...future.stdout)
[16:13:17.763]         ...future.stdout <- NULL
[16:13:17.763]     }
[16:13:17.763]     ...future.result$conditions <- ...future.conditions
[16:13:17.763]     ...future.result$finished <- base::Sys.time()
[16:13:17.763]     ...future.result
[16:13:17.763] }
[16:13:17.766] assign_globals() ...
[16:13:17.766] List of 1
[16:13:17.766]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:17.766]   ..$ a: int [1:3] 1 2 3
[16:13:17.766]   ..$ b: int [1:3] 3 2 1
[16:13:17.766]  - attr(*, "where")=List of 1
[16:13:17.766]   ..$ data:<environment: R_EmptyEnv> 
[16:13:17.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.766]  - attr(*, "resolved")= logi FALSE
[16:13:17.766]  - attr(*, "total_size")= num 128
[16:13:17.766]  - attr(*, "already-done")= logi TRUE
[16:13:17.770] - copied ‘data’ to environment
[16:13:17.770] assign_globals() ... done
[16:13:17.770] requestCore(): workers = 2
[16:13:17.773] MulticoreFuture started
[16:13:17.773] - Launch lazy future ... done
[16:13:17.773] run() for ‘MulticoreFuture’ ... done
[16:13:17.774] plan(): Setting new future strategy stack:
[16:13:17.774] List of future strategies:
[16:13:17.774] 1. sequential:
[16:13:17.774]    - args: function (..., envir = parent.frame())
[16:13:17.774]    - tweaked: FALSE
[16:13:17.774]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.775] plan(): nbrOfWorkers() = 1
[16:13:17.799] plan(): Setting new future strategy stack:
[16:13:17.799] List of future strategies:
[16:13:17.799] 1. multicore:
[16:13:17.799]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.799]    - tweaked: FALSE
[16:13:17.799]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.799] 2. sequential:
[16:13:17.799]    - args: function (..., envir = parent.frame())
[16:13:17.799]    - tweaked: FALSE
[16:13:17.799]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.803] plan(): nbrOfWorkers() = 2
[16:13:17.804] signalConditions() ...
[16:13:17.805]  - include = ‘immediateCondition’
[16:13:17.805]  - exclude = 
[16:13:17.805]  - resignal = FALSE
[16:13:17.805]  - Number of conditions: 52
[16:13:17.805] signalConditions() ... done
[16:13:17.805] signalConditions() ...
[16:13:17.805]  - include = ‘immediateCondition’
[16:13:17.806]  - exclude = 
[16:13:17.806]  - resignal = FALSE
[16:13:17.806]  - Number of conditions: 52
[16:13:17.806] signalConditions() ... done
[16:13:17.806] Future state: ‘finished’
[16:13:17.806] signalConditions() ...
[16:13:17.806]  - include = ‘condition’
[16:13:17.806]  - exclude = ‘immediateCondition’
[16:13:17.807]  - resignal = TRUE
[16:13:17.807]  - Number of conditions: 52
[16:13:17.807]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.776] getGlobalsAndPackages() ...
[16:13:17.807]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.776] Searching for globals...
[16:13:17.807]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.778] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:17.807]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.778] Searching for globals ... DONE
[16:13:17.807]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.779] Resolving globals: FALSE
[16:13:17.808]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.780] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:17.808]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.780] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:17.808]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.781] - globals: [1] ‘data’
[16:13:17.808]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.781] 
[16:13:17.808]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.781] getGlobalsAndPackages() ... DONE
[16:13:17.808]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.782] run() for ‘Future’ ...
[16:13:17.809]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.782] - state: ‘created’
[16:13:17.809]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.782] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:17.809]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.782] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:17.809]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:17.809]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.783]   - Field: ‘label’
[16:13:17.809]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.783]   - Field: ‘local’
[16:13:17.809]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.783]   - Field: ‘owner’
[16:13:17.810]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.783]   - Field: ‘envir’
[16:13:17.810]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.783]   - Field: ‘packages’
[16:13:17.810]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.784]   - Field: ‘gc’
[16:13:17.810]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.784]   - Field: ‘conditions’
[16:13:17.810]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.784]   - Field: ‘expr’
[16:13:17.810]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.784]   - Field: ‘uuid’
[16:13:17.811]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.784]   - Field: ‘seed’
[16:13:17.811]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.784]   - Field: ‘version’
[16:13:17.811]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.785]   - Field: ‘result’
[16:13:17.811]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.785]   - Field: ‘asynchronous’
[16:13:17.811]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.785]   - Field: ‘calls’
[16:13:17.811]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.785]   - Field: ‘globals’
[16:13:17.812]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.785]   - Field: ‘stdout’
[16:13:17.812]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.785]   - Field: ‘earlySignal’
[16:13:17.812]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.786]   - Field: ‘lazy’
[16:13:17.812]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.786]   - Field: ‘state’
[16:13:17.812]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:17.812]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.786] - Launch lazy future ...
[16:13:17.812]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.786] Packages needed by the future expression (n = 0): <none>
[16:13:17.813]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.787] Packages needed by future strategies (n = 0): <none>
[16:13:17.813]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.787] {
[16:13:17.787]     {
[16:13:17.787]         {
[16:13:17.787]             ...future.startTime <- base::Sys.time()
[16:13:17.787]             {
[16:13:17.787]                 {
[16:13:17.787]                   {
[16:13:17.787]                     base::local({
[16:13:17.787]                       has_future <- base::requireNamespace("future", 
[16:13:17.787]                         quietly = TRUE)
[16:13:17.787]                       if (has_future) {
[16:13:17.787]                         ns <- base::getNamespace("future")
[16:13:17.787]                         version <- ns[[".package"]][["version"]]
[16:13:17.787]                         if (is.null(version)) 
[16:13:17.787]                           version <- utils::packageVersion("future")
[16:13:17.787]                       }
[16:13:17.787]                       else {
[16:13:17.787]                         version <- NULL
[16:13:17.787]                       }
[16:13:17.787]                       if (!has_future || version < "1.8.0") {
[16:13:17.787]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.787]                           "", base::R.version$version.string), 
[16:13:17.787]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:17.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.787]                             "release", "version")], collapse = " "), 
[16:13:17.787]                           hostname = base::Sys.info()[["nodename"]])
[16:13:17.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.787]                           info)
[16:13:17.787]                         info <- base::paste(info, collapse = "; ")
[16:13:17.787]                         if (!has_future) {
[16:13:17.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.787]                             info)
[16:13:17.787]                         }
[16:13:17.787]                         else {
[16:13:17.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.787]                             info, version)
[16:13:17.787]                         }
[16:13:17.787]                         base::stop(msg)
[16:13:17.787]                       }
[16:13:17.787]                     })
[16:13:17.787]                   }
[16:13:17.787]                   options(future.plan = NULL)
[16:13:17.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:17.787]                 }
[16:13:17.787]                 ...future.workdir <- getwd()
[16:13:17.787]             }
[16:13:17.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.787]         }
[16:13:17.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.787]             base::names(...future.oldOptions))
[16:13:17.787]     }
[16:13:17.787]     if (FALSE) {
[16:13:17.787]     }
[16:13:17.787]     else {
[16:13:17.787]         if (TRUE) {
[16:13:17.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.787]                 open = "w")
[16:13:17.787]         }
[16:13:17.787]         else {
[16:13:17.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.787]         }
[16:13:17.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.787]             base::sink(type = "output", split = FALSE)
[16:13:17.787]             base::close(...future.stdout)
[16:13:17.787]         }, add = TRUE)
[16:13:17.787]     }
[16:13:17.787]     ...future.frame <- base::sys.nframe()
[16:13:17.787]     ...future.conditions <- base::list()
[16:13:17.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.787]     if (FALSE) {
[16:13:17.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.787]     }
[16:13:17.787]     ...future.result <- base::tryCatch({
[16:13:17.787]         base::withCallingHandlers({
[16:13:17.787]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:13:17.787]                 a == 2)))
[16:13:17.787]             future::FutureResult(value = ...future.value$value, 
[16:13:17.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.787]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.787]                     ...future.globalenv.names))
[16:13:17.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.787]         }, condition = base::local({
[16:13:17.787]             c <- base::c
[16:13:17.787]             inherits <- base::inherits
[16:13:17.787]             invokeRestart <- base::invokeRestart
[16:13:17.787]             length <- base::length
[16:13:17.787]             list <- base::list
[16:13:17.787]             seq.int <- base::seq.int
[16:13:17.787]             signalCondition <- base::signalCondition
[16:13:17.787]             sys.calls <- base::sys.calls
[16:13:17.787]             `[[` <- base::`[[`
[16:13:17.787]             `+` <- base::`+`
[16:13:17.787]             `<<-` <- base::`<<-`
[16:13:17.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.787]                   3L)]
[16:13:17.787]             }
[16:13:17.787]             function(cond) {
[16:13:17.787]                 is_error <- inherits(cond, "error")
[16:13:17.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.787]                   NULL)
[16:13:17.787]                 if (is_error) {
[16:13:17.787]                   sessionInformation <- function() {
[16:13:17.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.787]                       search = base::search(), system = base::Sys.info())
[16:13:17.787]                   }
[16:13:17.787]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.787]                     cond$call), session = sessionInformation(), 
[16:13:17.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.787]                   signalCondition(cond)
[16:13:17.787]                 }
[16:13:17.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.787]                 "immediateCondition"))) {
[16:13:17.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.787]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.787]                   if (TRUE && !signal) {
[16:13:17.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.787]                     {
[16:13:17.787]                       inherits <- base::inherits
[16:13:17.787]                       invokeRestart <- base::invokeRestart
[16:13:17.787]                       is.null <- base::is.null
[16:13:17.787]                       muffled <- FALSE
[16:13:17.787]                       if (inherits(cond, "message")) {
[16:13:17.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.787]                         if (muffled) 
[16:13:17.787]                           invokeRestart("muffleMessage")
[16:13:17.787]                       }
[16:13:17.787]                       else if (inherits(cond, "warning")) {
[16:13:17.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.787]                         if (muffled) 
[16:13:17.787]                           invokeRestart("muffleWarning")
[16:13:17.787]                       }
[16:13:17.787]                       else if (inherits(cond, "condition")) {
[16:13:17.787]                         if (!is.null(pattern)) {
[16:13:17.787]                           computeRestarts <- base::computeRestarts
[16:13:17.787]                           grepl <- base::grepl
[16:13:17.787]                           restarts <- computeRestarts(cond)
[16:13:17.787]                           for (restart in restarts) {
[16:13:17.787]                             name <- restart$name
[16:13:17.787]                             if (is.null(name)) 
[16:13:17.787]                               next
[16:13:17.787]                             if (!grepl(pattern, name)) 
[16:13:17.787]                               next
[16:13:17.787]                             invokeRestart(restart)
[16:13:17.787]                             muffled <- TRUE
[16:13:17.787]                             break
[16:13:17.787]                           }
[16:13:17.787]                         }
[16:13:17.787]                       }
[16:13:17.787]                       invisible(muffled)
[16:13:17.787]                     }
[16:13:17.787]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.787]                   }
[16:13:17.787]                 }
[16:13:17.787]                 else {
[16:13:17.787]                   if (TRUE) {
[16:13:17.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.787]                     {
[16:13:17.787]                       inherits <- base::inherits
[16:13:17.787]                       invokeRestart <- base::invokeRestart
[16:13:17.787]                       is.null <- base::is.null
[16:13:17.787]                       muffled <- FALSE
[16:13:17.787]                       if (inherits(cond, "message")) {
[16:13:17.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.787]                         if (muffled) 
[16:13:17.787]                           invokeRestart("muffleMessage")
[16:13:17.787]                       }
[16:13:17.787]                       else if (inherits(cond, "warning")) {
[16:13:17.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.787]                         if (muffled) 
[16:13:17.787]                           invokeRestart("muffleWarning")
[16:13:17.787]                       }
[16:13:17.787]                       else if (inherits(cond, "condition")) {
[16:13:17.787]                         if (!is.null(pattern)) {
[16:13:17.787]                           computeRestarts <- base::computeRestarts
[16:13:17.787]                           grepl <- base::grepl
[16:13:17.787]                           restarts <- computeRestarts(cond)
[16:13:17.787]                           for (restart in restarts) {
[16:13:17.787]                             name <- restart$name
[16:13:17.787]                             if (is.null(name)) 
[16:13:17.787]                               next
[16:13:17.787]                             if (!grepl(pattern, name)) 
[16:13:17.787]                               next
[16:13:17.787]                             invokeRestart(restart)
[16:13:17.787]                             muffled <- TRUE
[16:13:17.787]                             break
[16:13:17.787]                           }
[16:13:17.787]                         }
[16:13:17.787]                       }
[16:13:17.787]                       invisible(muffled)
[16:13:17.787]                     }
[16:13:17.787]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.787]                   }
[16:13:17.787]                 }
[16:13:17.787]             }
[16:13:17.787]         }))
[16:13:17.787]     }, error = function(ex) {
[16:13:17.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.787]                 ...future.rng), started = ...future.startTime, 
[16:13:17.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.787]             version = "1.8"), class = "FutureResult")
[16:13:17.787]     }, finally = {
[16:13:17.787]         if (!identical(...future.workdir, getwd())) 
[16:13:17.787]             setwd(...future.workdir)
[16:13:17.787]         {
[16:13:17.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.787]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.787]             }
[16:13:17.787]             base::options(...future.oldOptions)
[16:13:17.787]             if (.Platform$OS.type == "windows") {
[16:13:17.787]                 old_names <- names(...future.oldEnvVars)
[16:13:17.787]                 envs <- base::Sys.getenv()
[16:13:17.787]                 names <- names(envs)
[16:13:17.787]                 common <- intersect(names, old_names)
[16:13:17.787]                 added <- setdiff(names, old_names)
[16:13:17.787]                 removed <- setdiff(old_names, names)
[16:13:17.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.787]                   envs[common]]
[16:13:17.787]                 NAMES <- toupper(changed)
[16:13:17.787]                 args <- list()
[16:13:17.787]                 for (kk in seq_along(NAMES)) {
[16:13:17.787]                   name <- changed[[kk]]
[16:13:17.787]                   NAME <- NAMES[[kk]]
[16:13:17.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.787]                     next
[16:13:17.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.787]                 }
[16:13:17.787]                 NAMES <- toupper(added)
[16:13:17.787]                 for (kk in seq_along(NAMES)) {
[16:13:17.787]                   name <- added[[kk]]
[16:13:17.787]                   NAME <- NAMES[[kk]]
[16:13:17.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.787]                     next
[16:13:17.787]                   args[[name]] <- ""
[16:13:17.787]                 }
[16:13:17.787]                 NAMES <- toupper(removed)
[16:13:17.787]                 for (kk in seq_along(NAMES)) {
[16:13:17.787]                   name <- removed[[kk]]
[16:13:17.787]                   NAME <- NAMES[[kk]]
[16:13:17.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.787]                     next
[16:13:17.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.787]                 }
[16:13:17.787]                 if (length(args) > 0) 
[16:13:17.787]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.787]             }
[16:13:17.787]             else {
[16:13:17.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.787]             }
[16:13:17.787]             {
[16:13:17.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.787]                   0L) {
[16:13:17.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.787]                   base::options(opts)
[16:13:17.787]                 }
[16:13:17.787]                 {
[16:13:17.787]                   {
[16:13:17.787]                     NULL
[16:13:17.787]                     RNGkind("Mersenne-Twister")
[16:13:17.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:17.787]                       inherits = FALSE)
[16:13:17.787]                   }
[16:13:17.787]                   options(future.plan = NULL)
[16:13:17.787]                   if (is.na(NA_character_)) 
[16:13:17.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.787]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:17.787]                   {
[16:13:17.787]                     future <- SequentialFuture(..., envir = envir)
[16:13:17.787]                     if (!future$lazy) 
[16:13:17.787]                       future <- run(future)
[16:13:17.787]                     invisible(future)
[16:13:17.787]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.787]                 }
[16:13:17.787]             }
[16:13:17.787]         }
[16:13:17.787]     })
[16:13:17.787]     if (TRUE) {
[16:13:17.787]         base::sink(type = "output", split = FALSE)
[16:13:17.787]         if (TRUE) {
[16:13:17.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.787]         }
[16:13:17.787]         else {
[16:13:17.787]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.787]         }
[16:13:17.787]         base::close(...future.stdout)
[16:13:17.787]         ...future.stdout <- NULL
[16:13:17.787]     }
[16:13:17.787]     ...future.result$conditions <- ...future.conditions
[16:13:17.787]     ...future.result$finished <- base::Sys.time()
[16:13:17.787]     ...future.result
[16:13:17.787] }
[16:13:17.813]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.789] assign_globals() ...
[16:13:17.813]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.790] List of 1
[16:13:17.790]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:17.790]   ..$ a: int [1:3] 1 2 3
[16:13:17.790]   ..$ b: int [1:3] 3 2 1
[16:13:17.790]  - attr(*, "where")=List of 1
[16:13:17.790]   ..$ data:<environment: R_EmptyEnv> 
[16:13:17.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.790]  - attr(*, "resolved")= logi FALSE
[16:13:17.790]  - attr(*, "total_size")= num 128
[16:13:17.790]  - attr(*, "already-done")= logi TRUE
[16:13:17.813]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.794] - copied ‘data’ to environment
[16:13:17.813]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.794] assign_globals() ... done
[16:13:17.814]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.795] plan(): Setting new future strategy stack:
[16:13:17.814]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.795] List of future strategies:
[16:13:17.795] 1. sequential:
[16:13:17.795]    - args: function (..., envir = parent.frame())
[16:13:17.795]    - tweaked: FALSE
[16:13:17.795]    - call: NULL
[16:13:17.814]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.795] plan(): nbrOfWorkers() = 1
[16:13:17.814]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.797] plan(): Setting new future strategy stack:
[16:13:17.814]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.797] List of future strategies:
[16:13:17.797] 1. sequential:
[16:13:17.797]    - args: function (..., envir = parent.frame())
[16:13:17.797]    - tweaked: FALSE
[16:13:17.797]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.814]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.797] plan(): nbrOfWorkers() = 1
[16:13:17.814]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.798] SequentialFuture started (and completed)
[16:13:17.815]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.798] - Launch lazy future ... done
[16:13:17.815]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.798] run() for ‘SequentialFuture’ ... done
[16:13:17.815] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[16:13:17.815] plan(): Setting new future strategy stack:
[16:13:17.815] List of future strategies:
[16:13:17.815] 1. multicore:
[16:13:17.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.815]    - tweaked: FALSE
[16:13:17.815]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.815] 2. multicore:
[16:13:17.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.815]    - tweaked: FALSE
[16:13:17.815]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.820] plan(): nbrOfWorkers() = 2
[16:13:17.821] getGlobalsAndPackages() ...
[16:13:17.821] Searching for globals...
[16:13:17.842] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:17.843] Searching for globals ... DONE
[16:13:17.843] Resolving globals: FALSE
[16:13:17.844] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[16:13:17.844] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:17.845] - globals: [2] ‘nested’, ‘strategy2’
[16:13:17.845] - packages: [1] ‘future’
[16:13:17.845] getGlobalsAndPackages() ... DONE
[16:13:17.845] run() for ‘Future’ ...
[16:13:17.845] - state: ‘created’
[16:13:17.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.849] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:17.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:17.849]   - Field: ‘label’
[16:13:17.850]   - Field: ‘local’
[16:13:17.850]   - Field: ‘owner’
[16:13:17.850]   - Field: ‘envir’
[16:13:17.850]   - Field: ‘workers’
[16:13:17.850]   - Field: ‘packages’
[16:13:17.850]   - Field: ‘gc’
[16:13:17.850]   - Field: ‘job’
[16:13:17.850]   - Field: ‘conditions’
[16:13:17.850]   - Field: ‘expr’
[16:13:17.850]   - Field: ‘uuid’
[16:13:17.851]   - Field: ‘seed’
[16:13:17.851]   - Field: ‘version’
[16:13:17.851]   - Field: ‘result’
[16:13:17.851]   - Field: ‘asynchronous’
[16:13:17.851]   - Field: ‘calls’
[16:13:17.851]   - Field: ‘globals’
[16:13:17.851]   - Field: ‘stdout’
[16:13:17.851]   - Field: ‘earlySignal’
[16:13:17.851]   - Field: ‘lazy’
[16:13:17.852]   - Field: ‘state’
[16:13:17.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:17.852] - Launch lazy future ...
[16:13:17.852] Packages needed by the future expression (n = 1): ‘future’
[16:13:17.852] Packages needed by future strategies (n = 1): ‘future’
[16:13:17.853] {
[16:13:17.853]     {
[16:13:17.853]         {
[16:13:17.853]             ...future.startTime <- base::Sys.time()
[16:13:17.853]             {
[16:13:17.853]                 {
[16:13:17.853]                   {
[16:13:17.853]                     {
[16:13:17.853]                       {
[16:13:17.853]                         base::local({
[16:13:17.853]                           has_future <- base::requireNamespace("future", 
[16:13:17.853]                             quietly = TRUE)
[16:13:17.853]                           if (has_future) {
[16:13:17.853]                             ns <- base::getNamespace("future")
[16:13:17.853]                             version <- ns[[".package"]][["version"]]
[16:13:17.853]                             if (is.null(version)) 
[16:13:17.853]                               version <- utils::packageVersion("future")
[16:13:17.853]                           }
[16:13:17.853]                           else {
[16:13:17.853]                             version <- NULL
[16:13:17.853]                           }
[16:13:17.853]                           if (!has_future || version < "1.8.0") {
[16:13:17.853]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.853]                               "", base::R.version$version.string), 
[16:13:17.853]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:17.853]                                 base::R.version$platform, 8 * 
[16:13:17.853]                                   base::.Machine$sizeof.pointer), 
[16:13:17.853]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.853]                                 "release", "version")], collapse = " "), 
[16:13:17.853]                               hostname = base::Sys.info()[["nodename"]])
[16:13:17.853]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.853]                               info)
[16:13:17.853]                             info <- base::paste(info, collapse = "; ")
[16:13:17.853]                             if (!has_future) {
[16:13:17.853]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.853]                                 info)
[16:13:17.853]                             }
[16:13:17.853]                             else {
[16:13:17.853]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.853]                                 info, version)
[16:13:17.853]                             }
[16:13:17.853]                             base::stop(msg)
[16:13:17.853]                           }
[16:13:17.853]                         })
[16:13:17.853]                       }
[16:13:17.853]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:17.853]                       base::options(mc.cores = 1L)
[16:13:17.853]                     }
[16:13:17.853]                     base::local({
[16:13:17.853]                       for (pkg in "future") {
[16:13:17.853]                         base::loadNamespace(pkg)
[16:13:17.853]                         base::library(pkg, character.only = TRUE)
[16:13:17.853]                       }
[16:13:17.853]                     })
[16:13:17.853]                   }
[16:13:17.853]                   options(future.plan = NULL)
[16:13:17.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.853]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.853]                     envir = parent.frame()) 
[16:13:17.853]                   {
[16:13:17.853]                     default_workers <- missing(workers)
[16:13:17.853]                     if (is.function(workers)) 
[16:13:17.853]                       workers <- workers()
[16:13:17.853]                     workers <- structure(as.integer(workers), 
[16:13:17.853]                       class = class(workers))
[16:13:17.853]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.853]                       1L)
[16:13:17.853]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.853]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.853]                       if (default_workers) 
[16:13:17.853]                         supportsMulticore(warn = TRUE)
[16:13:17.853]                       return(sequential(..., envir = envir))
[16:13:17.853]                     }
[16:13:17.853]                     oopts <- options(mc.cores = workers)
[16:13:17.853]                     on.exit(options(oopts))
[16:13:17.853]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.853]                       envir = envir)
[16:13:17.853]                     if (!future$lazy) 
[16:13:17.853]                       future <- run(future)
[16:13:17.853]                     invisible(future)
[16:13:17.853]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.853]                 }
[16:13:17.853]                 ...future.workdir <- getwd()
[16:13:17.853]             }
[16:13:17.853]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.853]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.853]         }
[16:13:17.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.853]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.853]             base::names(...future.oldOptions))
[16:13:17.853]     }
[16:13:17.853]     if (FALSE) {
[16:13:17.853]     }
[16:13:17.853]     else {
[16:13:17.853]         if (TRUE) {
[16:13:17.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.853]                 open = "w")
[16:13:17.853]         }
[16:13:17.853]         else {
[16:13:17.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.853]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.853]         }
[16:13:17.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.853]             base::sink(type = "output", split = FALSE)
[16:13:17.853]             base::close(...future.stdout)
[16:13:17.853]         }, add = TRUE)
[16:13:17.853]     }
[16:13:17.853]     ...future.frame <- base::sys.nframe()
[16:13:17.853]     ...future.conditions <- base::list()
[16:13:17.853]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.853]     if (FALSE) {
[16:13:17.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.853]     }
[16:13:17.853]     ...future.result <- base::tryCatch({
[16:13:17.853]         base::withCallingHandlers({
[16:13:17.853]             ...future.value <- base::withVisible(base::local({
[16:13:17.853]                 withCallingHandlers({
[16:13:17.853]                   {
[16:13:17.853]                     a <- 1L
[16:13:17.853]                     plan_a <- unclass(future::plan("list"))
[16:13:17.853]                     nested_a <- nested[-1]
[16:13:17.853]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:17.853]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:17.853]                       strategy2))
[16:13:17.853]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:17.853]                       "init") <- NULL
[16:13:17.853]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:17.853]                       "init") <- NULL
[16:13:17.853]                     stopifnot(all.equal(plan_a, nested_a))
[16:13:17.853]                     y %<-% {
[16:13:17.853]                       b <- 2L
[16:13:17.853]                       plan_b <- future::plan("list")
[16:13:17.853]                       nested_b <- nested_a[-1]
[16:13:17.853]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:17.853]                         1L, inherits(plan_b[[1]], "future"), 
[16:13:17.853]                         inherits(future::plan("next"), "sequential"))
[16:13:17.853]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:17.853]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:17.853]                     }
[16:13:17.853]                     y
[16:13:17.853]                   }
[16:13:17.853]                 }, immediateCondition = function(cond) {
[16:13:17.853]                   save_rds <- function (object, pathname, ...) 
[16:13:17.853]                   {
[16:13:17.853]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:17.853]                     if (file_test("-f", pathname_tmp)) {
[16:13:17.853]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.853]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:17.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.853]                         fi_tmp[["mtime"]])
[16:13:17.853]                     }
[16:13:17.853]                     tryCatch({
[16:13:17.853]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:17.853]                     }, error = function(ex) {
[16:13:17.853]                       msg <- conditionMessage(ex)
[16:13:17.853]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.853]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:17.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.853]                         fi_tmp[["mtime"]], msg)
[16:13:17.853]                       ex$message <- msg
[16:13:17.853]                       stop(ex)
[16:13:17.853]                     })
[16:13:17.853]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:17.853]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:17.853]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:17.853]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.853]                       fi <- file.info(pathname)
[16:13:17.853]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:17.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.853]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:17.853]                         fi[["size"]], fi[["mtime"]])
[16:13:17.853]                       stop(msg)
[16:13:17.853]                     }
[16:13:17.853]                     invisible(pathname)
[16:13:17.853]                   }
[16:13:17.853]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:17.853]                     rootPath = tempdir()) 
[16:13:17.853]                   {
[16:13:17.853]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:17.853]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:17.853]                       tmpdir = path, fileext = ".rds")
[16:13:17.853]                     save_rds(obj, file)
[16:13:17.853]                   }
[16:13:17.853]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:17.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.853]                   {
[16:13:17.853]                     inherits <- base::inherits
[16:13:17.853]                     invokeRestart <- base::invokeRestart
[16:13:17.853]                     is.null <- base::is.null
[16:13:17.853]                     muffled <- FALSE
[16:13:17.853]                     if (inherits(cond, "message")) {
[16:13:17.853]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:17.853]                       if (muffled) 
[16:13:17.853]                         invokeRestart("muffleMessage")
[16:13:17.853]                     }
[16:13:17.853]                     else if (inherits(cond, "warning")) {
[16:13:17.853]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:17.853]                       if (muffled) 
[16:13:17.853]                         invokeRestart("muffleWarning")
[16:13:17.853]                     }
[16:13:17.853]                     else if (inherits(cond, "condition")) {
[16:13:17.853]                       if (!is.null(pattern)) {
[16:13:17.853]                         computeRestarts <- base::computeRestarts
[16:13:17.853]                         grepl <- base::grepl
[16:13:17.853]                         restarts <- computeRestarts(cond)
[16:13:17.853]                         for (restart in restarts) {
[16:13:17.853]                           name <- restart$name
[16:13:17.853]                           if (is.null(name)) 
[16:13:17.853]                             next
[16:13:17.853]                           if (!grepl(pattern, name)) 
[16:13:17.853]                             next
[16:13:17.853]                           invokeRestart(restart)
[16:13:17.853]                           muffled <- TRUE
[16:13:17.853]                           break
[16:13:17.853]                         }
[16:13:17.853]                       }
[16:13:17.853]                     }
[16:13:17.853]                     invisible(muffled)
[16:13:17.853]                   }
[16:13:17.853]                   muffleCondition(cond)
[16:13:17.853]                 })
[16:13:17.853]             }))
[16:13:17.853]             future::FutureResult(value = ...future.value$value, 
[16:13:17.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.853]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.853]                     ...future.globalenv.names))
[16:13:17.853]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.853]         }, condition = base::local({
[16:13:17.853]             c <- base::c
[16:13:17.853]             inherits <- base::inherits
[16:13:17.853]             invokeRestart <- base::invokeRestart
[16:13:17.853]             length <- base::length
[16:13:17.853]             list <- base::list
[16:13:17.853]             seq.int <- base::seq.int
[16:13:17.853]             signalCondition <- base::signalCondition
[16:13:17.853]             sys.calls <- base::sys.calls
[16:13:17.853]             `[[` <- base::`[[`
[16:13:17.853]             `+` <- base::`+`
[16:13:17.853]             `<<-` <- base::`<<-`
[16:13:17.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.853]                   3L)]
[16:13:17.853]             }
[16:13:17.853]             function(cond) {
[16:13:17.853]                 is_error <- inherits(cond, "error")
[16:13:17.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.853]                   NULL)
[16:13:17.853]                 if (is_error) {
[16:13:17.853]                   sessionInformation <- function() {
[16:13:17.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.853]                       search = base::search(), system = base::Sys.info())
[16:13:17.853]                   }
[16:13:17.853]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.853]                     cond$call), session = sessionInformation(), 
[16:13:17.853]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.853]                   signalCondition(cond)
[16:13:17.853]                 }
[16:13:17.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.853]                 "immediateCondition"))) {
[16:13:17.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.853]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.853]                   if (TRUE && !signal) {
[16:13:17.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.853]                     {
[16:13:17.853]                       inherits <- base::inherits
[16:13:17.853]                       invokeRestart <- base::invokeRestart
[16:13:17.853]                       is.null <- base::is.null
[16:13:17.853]                       muffled <- FALSE
[16:13:17.853]                       if (inherits(cond, "message")) {
[16:13:17.853]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.853]                         if (muffled) 
[16:13:17.853]                           invokeRestart("muffleMessage")
[16:13:17.853]                       }
[16:13:17.853]                       else if (inherits(cond, "warning")) {
[16:13:17.853]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.853]                         if (muffled) 
[16:13:17.853]                           invokeRestart("muffleWarning")
[16:13:17.853]                       }
[16:13:17.853]                       else if (inherits(cond, "condition")) {
[16:13:17.853]                         if (!is.null(pattern)) {
[16:13:17.853]                           computeRestarts <- base::computeRestarts
[16:13:17.853]                           grepl <- base::grepl
[16:13:17.853]                           restarts <- computeRestarts(cond)
[16:13:17.853]                           for (restart in restarts) {
[16:13:17.853]                             name <- restart$name
[16:13:17.853]                             if (is.null(name)) 
[16:13:17.853]                               next
[16:13:17.853]                             if (!grepl(pattern, name)) 
[16:13:17.853]                               next
[16:13:17.853]                             invokeRestart(restart)
[16:13:17.853]                             muffled <- TRUE
[16:13:17.853]                             break
[16:13:17.853]                           }
[16:13:17.853]                         }
[16:13:17.853]                       }
[16:13:17.853]                       invisible(muffled)
[16:13:17.853]                     }
[16:13:17.853]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.853]                   }
[16:13:17.853]                 }
[16:13:17.853]                 else {
[16:13:17.853]                   if (TRUE) {
[16:13:17.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.853]                     {
[16:13:17.853]                       inherits <- base::inherits
[16:13:17.853]                       invokeRestart <- base::invokeRestart
[16:13:17.853]                       is.null <- base::is.null
[16:13:17.853]                       muffled <- FALSE
[16:13:17.853]                       if (inherits(cond, "message")) {
[16:13:17.853]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.853]                         if (muffled) 
[16:13:17.853]                           invokeRestart("muffleMessage")
[16:13:17.853]                       }
[16:13:17.853]                       else if (inherits(cond, "warning")) {
[16:13:17.853]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.853]                         if (muffled) 
[16:13:17.853]                           invokeRestart("muffleWarning")
[16:13:17.853]                       }
[16:13:17.853]                       else if (inherits(cond, "condition")) {
[16:13:17.853]                         if (!is.null(pattern)) {
[16:13:17.853]                           computeRestarts <- base::computeRestarts
[16:13:17.853]                           grepl <- base::grepl
[16:13:17.853]                           restarts <- computeRestarts(cond)
[16:13:17.853]                           for (restart in restarts) {
[16:13:17.853]                             name <- restart$name
[16:13:17.853]                             if (is.null(name)) 
[16:13:17.853]                               next
[16:13:17.853]                             if (!grepl(pattern, name)) 
[16:13:17.853]                               next
[16:13:17.853]                             invokeRestart(restart)
[16:13:17.853]                             muffled <- TRUE
[16:13:17.853]                             break
[16:13:17.853]                           }
[16:13:17.853]                         }
[16:13:17.853]                       }
[16:13:17.853]                       invisible(muffled)
[16:13:17.853]                     }
[16:13:17.853]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.853]                   }
[16:13:17.853]                 }
[16:13:17.853]             }
[16:13:17.853]         }))
[16:13:17.853]     }, error = function(ex) {
[16:13:17.853]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.853]                 ...future.rng), started = ...future.startTime, 
[16:13:17.853]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.853]             version = "1.8"), class = "FutureResult")
[16:13:17.853]     }, finally = {
[16:13:17.853]         if (!identical(...future.workdir, getwd())) 
[16:13:17.853]             setwd(...future.workdir)
[16:13:17.853]         {
[16:13:17.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.853]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.853]             }
[16:13:17.853]             base::options(...future.oldOptions)
[16:13:17.853]             if (.Platform$OS.type == "windows") {
[16:13:17.853]                 old_names <- names(...future.oldEnvVars)
[16:13:17.853]                 envs <- base::Sys.getenv()
[16:13:17.853]                 names <- names(envs)
[16:13:17.853]                 common <- intersect(names, old_names)
[16:13:17.853]                 added <- setdiff(names, old_names)
[16:13:17.853]                 removed <- setdiff(old_names, names)
[16:13:17.853]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.853]                   envs[common]]
[16:13:17.853]                 NAMES <- toupper(changed)
[16:13:17.853]                 args <- list()
[16:13:17.853]                 for (kk in seq_along(NAMES)) {
[16:13:17.853]                   name <- changed[[kk]]
[16:13:17.853]                   NAME <- NAMES[[kk]]
[16:13:17.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.853]                     next
[16:13:17.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.853]                 }
[16:13:17.853]                 NAMES <- toupper(added)
[16:13:17.853]                 for (kk in seq_along(NAMES)) {
[16:13:17.853]                   name <- added[[kk]]
[16:13:17.853]                   NAME <- NAMES[[kk]]
[16:13:17.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.853]                     next
[16:13:17.853]                   args[[name]] <- ""
[16:13:17.853]                 }
[16:13:17.853]                 NAMES <- toupper(removed)
[16:13:17.853]                 for (kk in seq_along(NAMES)) {
[16:13:17.853]                   name <- removed[[kk]]
[16:13:17.853]                   NAME <- NAMES[[kk]]
[16:13:17.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.853]                     next
[16:13:17.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.853]                 }
[16:13:17.853]                 if (length(args) > 0) 
[16:13:17.853]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.853]             }
[16:13:17.853]             else {
[16:13:17.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.853]             }
[16:13:17.853]             {
[16:13:17.853]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.853]                   0L) {
[16:13:17.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.853]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.853]                   base::options(opts)
[16:13:17.853]                 }
[16:13:17.853]                 {
[16:13:17.853]                   {
[16:13:17.853]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:17.853]                     NULL
[16:13:17.853]                   }
[16:13:17.853]                   options(future.plan = NULL)
[16:13:17.853]                   if (is.na(NA_character_)) 
[16:13:17.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.853]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.853]                     envir = parent.frame()) 
[16:13:17.853]                   {
[16:13:17.853]                     default_workers <- missing(workers)
[16:13:17.853]                     if (is.function(workers)) 
[16:13:17.853]                       workers <- workers()
[16:13:17.853]                     workers <- structure(as.integer(workers), 
[16:13:17.853]                       class = class(workers))
[16:13:17.853]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.853]                       1L)
[16:13:17.853]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.853]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.853]                       if (default_workers) 
[16:13:17.853]                         supportsMulticore(warn = TRUE)
[16:13:17.853]                       return(sequential(..., envir = envir))
[16:13:17.853]                     }
[16:13:17.853]                     oopts <- options(mc.cores = workers)
[16:13:17.853]                     on.exit(options(oopts))
[16:13:17.853]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.853]                       envir = envir)
[16:13:17.853]                     if (!future$lazy) 
[16:13:17.853]                       future <- run(future)
[16:13:17.853]                     invisible(future)
[16:13:17.853]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.853]                     envir = parent.frame()) 
[16:13:17.853]                   {
[16:13:17.853]                     default_workers <- missing(workers)
[16:13:17.853]                     if (is.function(workers)) 
[16:13:17.853]                       workers <- workers()
[16:13:17.853]                     workers <- structure(as.integer(workers), 
[16:13:17.853]                       class = class(workers))
[16:13:17.853]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.853]                       1L)
[16:13:17.853]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.853]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.853]                       if (default_workers) 
[16:13:17.853]                         supportsMulticore(warn = TRUE)
[16:13:17.853]                       return(sequential(..., envir = envir))
[16:13:17.853]                     }
[16:13:17.853]                     oopts <- options(mc.cores = workers)
[16:13:17.853]                     on.exit(options(oopts))
[16:13:17.853]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.853]                       envir = envir)
[16:13:17.853]                     if (!future$lazy) 
[16:13:17.853]                       future <- run(future)
[16:13:17.853]                     invisible(future)
[16:13:17.853]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.853]                 }
[16:13:17.853]             }
[16:13:17.853]         }
[16:13:17.853]     })
[16:13:17.853]     if (TRUE) {
[16:13:17.853]         base::sink(type = "output", split = FALSE)
[16:13:17.853]         if (TRUE) {
[16:13:17.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.853]         }
[16:13:17.853]         else {
[16:13:17.853]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.853]         }
[16:13:17.853]         base::close(...future.stdout)
[16:13:17.853]         ...future.stdout <- NULL
[16:13:17.853]     }
[16:13:17.853]     ...future.result$conditions <- ...future.conditions
[16:13:17.853]     ...future.result$finished <- base::Sys.time()
[16:13:17.853]     ...future.result
[16:13:17.853] }
[16:13:17.856] assign_globals() ...
[16:13:17.856] List of 2
[16:13:17.856]  $ nested   :List of 2
[16:13:17.856]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:17.856]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:17.856]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.856]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:17.856]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:17.856]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.856]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:17.856]  $ strategy2: chr "multicore"
[16:13:17.856]  - attr(*, "where")=List of 2
[16:13:17.856]   ..$ nested   :<environment: R_EmptyEnv> 
[16:13:17.856]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:13:17.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.856]  - attr(*, "resolved")= logi FALSE
[16:13:17.856]  - attr(*, "total_size")= num 95304
[16:13:17.856]  - attr(*, "already-done")= logi TRUE
[16:13:17.862] - copied ‘nested’ to environment
[16:13:17.862] - copied ‘strategy2’ to environment
[16:13:17.862] assign_globals() ... done
[16:13:17.862] requestCore(): workers = 2
[16:13:17.865] MulticoreFuture started
[16:13:17.865] - Launch lazy future ... done
[16:13:17.866] run() for ‘MulticoreFuture’ ... done
[16:13:17.867] plan(): Setting new future strategy stack:
[16:13:17.867] List of future strategies:
[16:13:17.867] 1. multicore:
[16:13:17.867]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.867]    - tweaked: FALSE
[16:13:17.867]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.873] plan(): nbrOfWorkers() = 1
[16:13:17.914] plan(): Setting new future strategy stack:
[16:13:17.914] List of future strategies:
[16:13:17.914] 1. multicore:
[16:13:17.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.914]    - tweaked: FALSE
[16:13:17.914]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.914] 2. multicore:
[16:13:17.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.914]    - tweaked: FALSE
[16:13:17.914]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.918] plan(): nbrOfWorkers() = 2
[16:13:17.919] signalConditions() ...
[16:13:17.919]  - include = ‘immediateCondition’
[16:13:17.920]  - exclude = 
[16:13:17.920]  - resignal = FALSE
[16:13:17.920]  - Number of conditions: 54
[16:13:17.920] signalConditions() ... done
[16:13:17.920] signalConditions() ...
[16:13:17.921]  - include = ‘immediateCondition’
[16:13:17.921]  - exclude = 
[16:13:17.921]  - resignal = FALSE
[16:13:17.921]  - Number of conditions: 54
[16:13:17.921] signalConditions() ... done
[16:13:17.921] Future state: ‘finished’
[16:13:17.922] signalConditions() ...
[16:13:17.922]  - include = ‘condition’
[16:13:17.922]  - exclude = ‘immediateCondition’
[16:13:17.922]  - resignal = TRUE
[16:13:17.922]  - Number of conditions: 54
[16:13:17.923]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.874] getGlobalsAndPackages() ...
[16:13:17.923]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.875] Searching for globals...
[16:13:17.923]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.883] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:13:17.923]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.883] Searching for globals ... DONE
[16:13:17.924]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.884] Resolving globals: FALSE
[16:13:17.924]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.885] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[16:13:17.924]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.885] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:13:17.924]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.886] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:13:17.924]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.886] 
[16:13:17.925]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.886] getGlobalsAndPackages() ... DONE
[16:13:17.925]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.887] run() for ‘Future’ ...
[16:13:17.925]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.887] - state: ‘created’
[16:13:17.925]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.925]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:17.926]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:17.926]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.892]   - Field: ‘label’
[16:13:17.926]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.892]   - Field: ‘local’
[16:13:17.926]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.892]   - Field: ‘owner’
[16:13:17.926]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.892]   - Field: ‘envir’
[16:13:17.926]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.892]   - Field: ‘packages’
[16:13:17.926]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.892]   - Field: ‘gc’
[16:13:17.927]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.893]   - Field: ‘conditions’
[16:13:17.927]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.893]   - Field: ‘expr’
[16:13:17.927]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.893]   - Field: ‘uuid’
[16:13:17.927]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.893]   - Field: ‘seed’
[16:13:17.927]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.893]   - Field: ‘version’
[16:13:17.927]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.893]   - Field: ‘result’
[16:13:17.928]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘asynchronous’
[16:13:17.928]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘calls’
[16:13:17.928]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘globals’
[16:13:17.928]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘stdout’
[16:13:17.928]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘earlySignal’
[16:13:17.928]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘lazy’
[16:13:17.929]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.894]   - Field: ‘state’
[16:13:17.929]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:17.929]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.895] - Launch lazy future ...
[16:13:17.929]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.895] Packages needed by the future expression (n = 0): <none>
[16:13:17.929]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.895] Packages needed by future strategies (n = 0): <none>
[16:13:17.929]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.896] {
[16:13:17.896]     {
[16:13:17.896]         {
[16:13:17.896]             ...future.startTime <- base::Sys.time()
[16:13:17.896]             {
[16:13:17.896]                 {
[16:13:17.896]                   {
[16:13:17.896]                     base::local({
[16:13:17.896]                       has_future <- base::requireNamespace("future", 
[16:13:17.896]                         quietly = TRUE)
[16:13:17.896]                       if (has_future) {
[16:13:17.896]                         ns <- base::getNamespace("future")
[16:13:17.896]                         version <- ns[[".package"]][["version"]]
[16:13:17.896]                         if (is.null(version)) 
[16:13:17.896]                           version <- utils::packageVersion("future")
[16:13:17.896]                       }
[16:13:17.896]                       else {
[16:13:17.896]                         version <- NULL
[16:13:17.896]                       }
[16:13:17.896]                       if (!has_future || version < "1.8.0") {
[16:13:17.896]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.896]                           "", base::R.version$version.string), 
[16:13:17.896]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:17.896]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.896]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.896]                             "release", "version")], collapse = " "), 
[16:13:17.896]                           hostname = base::Sys.info()[["nodename"]])
[16:13:17.896]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.896]                           info)
[16:13:17.896]                         info <- base::paste(info, collapse = "; ")
[16:13:17.896]                         if (!has_future) {
[16:13:17.896]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.896]                             info)
[16:13:17.896]                         }
[16:13:17.896]                         else {
[16:13:17.896]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.896]                             info, version)
[16:13:17.896]                         }
[16:13:17.896]                         base::stop(msg)
[16:13:17.896]                       }
[16:13:17.896]                     })
[16:13:17.896]                   }
[16:13:17.896]                   options(future.plan = NULL)
[16:13:17.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:17.896]                 }
[16:13:17.896]                 ...future.workdir <- getwd()
[16:13:17.896]             }
[16:13:17.896]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.896]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.896]         }
[16:13:17.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.896]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.896]             base::names(...future.oldOptions))
[16:13:17.896]     }
[16:13:17.896]     if (FALSE) {
[16:13:17.896]     }
[16:13:17.896]     else {
[16:13:17.896]         if (TRUE) {
[16:13:17.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.896]                 open = "w")
[16:13:17.896]         }
[16:13:17.896]         else {
[16:13:17.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.896]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.896]         }
[16:13:17.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.896]             base::sink(type = "output", split = FALSE)
[16:13:17.896]             base::close(...future.stdout)
[16:13:17.896]         }, add = TRUE)
[16:13:17.896]     }
[16:13:17.896]     ...future.frame <- base::sys.nframe()
[16:13:17.896]     ...future.conditions <- base::list()
[16:13:17.896]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.896]     if (FALSE) {
[16:13:17.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.896]     }
[16:13:17.896]     ...future.result <- base::tryCatch({
[16:13:17.896]         base::withCallingHandlers({
[16:13:17.896]             ...future.value <- base::withVisible(base::local({
[16:13:17.896]                 b <- 2L
[16:13:17.896]                 plan_b <- future::plan("list")
[16:13:17.896]                 nested_b <- nested_a[-1]
[16:13:17.896]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:17.896]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:17.896]                   "sequential"))
[16:13:17.896]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:17.896]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:17.896]             }))
[16:13:17.896]             future::FutureResult(value = ...future.value$value, 
[16:13:17.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.896]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.896]                     ...future.globalenv.names))
[16:13:17.896]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.896]         }, condition = base::local({
[16:13:17.896]             c <- base::c
[16:13:17.896]             inherits <- base::inherits
[16:13:17.896]             invokeRestart <- base::invokeRestart
[16:13:17.896]             length <- base::length
[16:13:17.896]             list <- base::list
[16:13:17.896]             seq.int <- base::seq.int
[16:13:17.896]             signalCondition <- base::signalCondition
[16:13:17.896]             sys.calls <- base::sys.calls
[16:13:17.896]             `[[` <- base::`[[`
[16:13:17.896]             `+` <- base::`+`
[16:13:17.896]             `<<-` <- base::`<<-`
[16:13:17.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.896]                   3L)]
[16:13:17.896]             }
[16:13:17.896]             function(cond) {
[16:13:17.896]                 is_error <- inherits(cond, "error")
[16:13:17.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.896]                   NULL)
[16:13:17.896]                 if (is_error) {
[16:13:17.896]                   sessionInformation <- function() {
[16:13:17.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.896]                       search = base::search(), system = base::Sys.info())
[16:13:17.896]                   }
[16:13:17.896]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.896]                     cond$call), session = sessionInformation(), 
[16:13:17.896]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.896]                   signalCondition(cond)
[16:13:17.896]                 }
[16:13:17.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.896]                 "immediateCondition"))) {
[16:13:17.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.896]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.896]                   if (TRUE && !signal) {
[16:13:17.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.896]                     {
[16:13:17.896]                       inherits <- base::inherits
[16:13:17.896]                       invokeRestart <- base::invokeRestart
[16:13:17.896]                       is.null <- base::is.null
[16:13:17.896]                       muffled <- FALSE
[16:13:17.896]                       if (inherits(cond, "message")) {
[16:13:17.896]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.896]                         if (muffled) 
[16:13:17.896]                           invokeRestart("muffleMessage")
[16:13:17.896]                       }
[16:13:17.896]                       else if (inherits(cond, "warning")) {
[16:13:17.896]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.896]                         if (muffled) 
[16:13:17.896]                           invokeRestart("muffleWarning")
[16:13:17.896]                       }
[16:13:17.896]                       else if (inherits(cond, "condition")) {
[16:13:17.896]                         if (!is.null(pattern)) {
[16:13:17.896]                           computeRestarts <- base::computeRestarts
[16:13:17.896]                           grepl <- base::grepl
[16:13:17.896]                           restarts <- computeRestarts(cond)
[16:13:17.896]                           for (restart in restarts) {
[16:13:17.896]                             name <- restart$name
[16:13:17.896]                             if (is.null(name)) 
[16:13:17.896]                               next
[16:13:17.896]                             if (!grepl(pattern, name)) 
[16:13:17.896]                               next
[16:13:17.896]                             invokeRestart(restart)
[16:13:17.896]                             muffled <- TRUE
[16:13:17.896]                             break
[16:13:17.896]                           }
[16:13:17.896]                         }
[16:13:17.896]                       }
[16:13:17.896]                       invisible(muffled)
[16:13:17.896]                     }
[16:13:17.896]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.896]                   }
[16:13:17.896]                 }
[16:13:17.896]                 else {
[16:13:17.896]                   if (TRUE) {
[16:13:17.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.896]                     {
[16:13:17.896]                       inherits <- base::inherits
[16:13:17.896]                       invokeRestart <- base::invokeRestart
[16:13:17.896]                       is.null <- base::is.null
[16:13:17.896]                       muffled <- FALSE
[16:13:17.896]                       if (inherits(cond, "message")) {
[16:13:17.896]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.896]                         if (muffled) 
[16:13:17.896]                           invokeRestart("muffleMessage")
[16:13:17.896]                       }
[16:13:17.896]                       else if (inherits(cond, "warning")) {
[16:13:17.896]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.896]                         if (muffled) 
[16:13:17.896]                           invokeRestart("muffleWarning")
[16:13:17.896]                       }
[16:13:17.896]                       else if (inherits(cond, "condition")) {
[16:13:17.896]                         if (!is.null(pattern)) {
[16:13:17.896]                           computeRestarts <- base::computeRestarts
[16:13:17.896]                           grepl <- base::grepl
[16:13:17.896]                           restarts <- computeRestarts(cond)
[16:13:17.896]                           for (restart in restarts) {
[16:13:17.896]                             name <- restart$name
[16:13:17.896]                             if (is.null(name)) 
[16:13:17.896]                               next
[16:13:17.896]                             if (!grepl(pattern, name)) 
[16:13:17.896]                               next
[16:13:17.896]                             invokeRestart(restart)
[16:13:17.896]                             muffled <- TRUE
[16:13:17.896]                             break
[16:13:17.896]                           }
[16:13:17.896]                         }
[16:13:17.896]                       }
[16:13:17.896]                       invisible(muffled)
[16:13:17.896]                     }
[16:13:17.896]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.896]                   }
[16:13:17.896]                 }
[16:13:17.896]             }
[16:13:17.896]         }))
[16:13:17.896]     }, error = function(ex) {
[16:13:17.896]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.896]                 ...future.rng), started = ...future.startTime, 
[16:13:17.896]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.896]             version = "1.8"), class = "FutureResult")
[16:13:17.896]     }, finally = {
[16:13:17.896]         if (!identical(...future.workdir, getwd())) 
[16:13:17.896]             setwd(...future.workdir)
[16:13:17.896]         {
[16:13:17.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.896]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.896]             }
[16:13:17.896]             base::options(...future.oldOptions)
[16:13:17.896]             if (.Platform$OS.type == "windows") {
[16:13:17.896]                 old_names <- names(...future.oldEnvVars)
[16:13:17.896]                 envs <- base::Sys.getenv()
[16:13:17.896]                 names <- names(envs)
[16:13:17.896]                 common <- intersect(names, old_names)
[16:13:17.896]                 added <- setdiff(names, old_names)
[16:13:17.896]                 removed <- setdiff(old_names, names)
[16:13:17.896]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.896]                   envs[common]]
[16:13:17.896]                 NAMES <- toupper(changed)
[16:13:17.896]                 args <- list()
[16:13:17.896]                 for (kk in seq_along(NAMES)) {
[16:13:17.896]                   name <- changed[[kk]]
[16:13:17.896]                   NAME <- NAMES[[kk]]
[16:13:17.896]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.896]                     next
[16:13:17.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.896]                 }
[16:13:17.896]                 NAMES <- toupper(added)
[16:13:17.896]                 for (kk in seq_along(NAMES)) {
[16:13:17.896]                   name <- added[[kk]]
[16:13:17.896]                   NAME <- NAMES[[kk]]
[16:13:17.896]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.896]                     next
[16:13:17.896]                   args[[name]] <- ""
[16:13:17.896]                 }
[16:13:17.896]                 NAMES <- toupper(removed)
[16:13:17.896]                 for (kk in seq_along(NAMES)) {
[16:13:17.896]                   name <- removed[[kk]]
[16:13:17.896]                   NAME <- NAMES[[kk]]
[16:13:17.896]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.896]                     next
[16:13:17.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.896]                 }
[16:13:17.896]                 if (length(args) > 0) 
[16:13:17.896]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.896]             }
[16:13:17.896]             else {
[16:13:17.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.896]             }
[16:13:17.896]             {
[16:13:17.896]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.896]                   0L) {
[16:13:17.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.896]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.896]                   base::options(opts)
[16:13:17.896]                 }
[16:13:17.896]                 {
[16:13:17.896]                   {
[16:13:17.896]                     NULL
[16:13:17.896]                     RNGkind("Mersenne-Twister")
[16:13:17.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:17.896]                       inherits = FALSE)
[16:13:17.896]                   }
[16:13:17.896]                   options(future.plan = NULL)
[16:13:17.896]                   if (is.na(NA_character_)) 
[16:13:17.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.896]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.896]                     envir = parent.frame()) 
[16:13:17.896]                   {
[16:13:17.896]                     default_workers <- missing(workers)
[16:13:17.896]                     if (is.function(workers)) 
[16:13:17.896]                       workers <- workers()
[16:13:17.896]                     workers <- structure(as.integer(workers), 
[16:13:17.896]                       class = class(workers))
[16:13:17.896]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.896]                       1L)
[16:13:17.896]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.896]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.896]                       if (default_workers) 
[16:13:17.896]                         supportsMulticore(warn = TRUE)
[16:13:17.896]                       return(sequential(..., envir = envir))
[16:13:17.896]                     }
[16:13:17.896]                     oopts <- options(mc.cores = workers)
[16:13:17.896]                     on.exit(options(oopts))
[16:13:17.896]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.896]                       envir = envir)
[16:13:17.896]                     if (!future$lazy) 
[16:13:17.896]                       future <- run(future)
[16:13:17.896]                     invisible(future)
[16:13:17.896]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.896]                 }
[16:13:17.896]             }
[16:13:17.896]         }
[16:13:17.896]     })
[16:13:17.896]     if (TRUE) {
[16:13:17.896]         base::sink(type = "output", split = FALSE)
[16:13:17.896]         if (TRUE) {
[16:13:17.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.896]         }
[16:13:17.896]         else {
[16:13:17.896]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.896]         }
[16:13:17.896]         base::close(...future.stdout)
[16:13:17.896]         ...future.stdout <- NULL
[16:13:17.896]     }
[16:13:17.896]     ...future.result$conditions <- ...future.conditions
[16:13:17.896]     ...future.result$finished <- base::Sys.time()
[16:13:17.896]     ...future.result
[16:13:17.896] }
[16:13:17.930]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.899] assign_globals() ...
[16:13:17.930]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.899] List of 3
[16:13:17.899]  $ nested_a:List of 1
[16:13:17.899]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:17.899]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:17.899]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.899]  $ a       : int 1
[16:13:17.899]  $ plan_a  :List of 1
[16:13:17.899]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:17.899]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:17.899]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:17.899]  - attr(*, "where")=List of 3
[16:13:17.899]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:13:17.899]   ..$ a       :<environment: R_EmptyEnv> 
[16:13:17.899]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:13:17.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.899]  - attr(*, "resolved")= logi FALSE
[16:13:17.899]  - attr(*, "total_size")= num 95240
[16:13:17.899]  - attr(*, "already-done")= logi TRUE
[16:13:17.930]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.906] - copied ‘nested_a’ to environment
[16:13:17.930]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.906] - copied ‘a’ to environment
[16:13:17.930]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.906] - copied ‘plan_a’ to environment
[16:13:17.930]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.906] assign_globals() ... done
[16:13:17.931]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.907] plan(): Setting new future strategy stack:
[16:13:17.931]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.907] List of future strategies:
[16:13:17.907] 1. sequential:
[16:13:17.907]    - args: function (..., envir = parent.frame())
[16:13:17.907]    - tweaked: FALSE
[16:13:17.907]    - call: NULL
[16:13:17.931]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.907] plan(): nbrOfWorkers() = 1
[16:13:17.931]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.908] plan(): Setting new future strategy stack:
[16:13:17.931]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.908] List of future strategies:
[16:13:17.908] 1. multicore:
[16:13:17.908]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.908]    - tweaked: FALSE
[16:13:17.908]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.931]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.912] plan(): nbrOfWorkers() = 1
[16:13:17.931]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.913] SequentialFuture started (and completed)
[16:13:17.932]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.913] - Launch lazy future ... done
[16:13:17.932]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.913] run() for ‘SequentialFuture’ ... done
[16:13:17.932] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:17.938] getGlobalsAndPackages() ...
[16:13:17.938] Searching for globals...
[16:13:17.940] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:17.940] Searching for globals ... DONE
[16:13:17.940] Resolving globals: FALSE
[16:13:17.941] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:17.942] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:17.942] - globals: [1] ‘data’
[16:13:17.942] - packages: [1] ‘future’
[16:13:17.942] getGlobalsAndPackages() ... DONE
[16:13:17.943] run() for ‘Future’ ...
[16:13:17.943] - state: ‘created’
[16:13:17.943] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:17.948] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:17.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:17.948]   - Field: ‘label’
[16:13:17.948]   - Field: ‘local’
[16:13:17.948]   - Field: ‘owner’
[16:13:17.948]   - Field: ‘envir’
[16:13:17.949]   - Field: ‘workers’
[16:13:17.949]   - Field: ‘packages’
[16:13:17.949]   - Field: ‘gc’
[16:13:17.949]   - Field: ‘job’
[16:13:17.949]   - Field: ‘conditions’
[16:13:17.949]   - Field: ‘expr’
[16:13:17.949]   - Field: ‘uuid’
[16:13:17.949]   - Field: ‘seed’
[16:13:17.949]   - Field: ‘version’
[16:13:17.950]   - Field: ‘result’
[16:13:17.950]   - Field: ‘asynchronous’
[16:13:17.950]   - Field: ‘calls’
[16:13:17.950]   - Field: ‘globals’
[16:13:17.950]   - Field: ‘stdout’
[16:13:17.950]   - Field: ‘earlySignal’
[16:13:17.950]   - Field: ‘lazy’
[16:13:17.950]   - Field: ‘state’
[16:13:17.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:17.951] - Launch lazy future ...
[16:13:17.951] Packages needed by the future expression (n = 1): ‘future’
[16:13:17.951] Packages needed by future strategies (n = 1): ‘future’
[16:13:17.952] {
[16:13:17.952]     {
[16:13:17.952]         {
[16:13:17.952]             ...future.startTime <- base::Sys.time()
[16:13:17.952]             {
[16:13:17.952]                 {
[16:13:17.952]                   {
[16:13:17.952]                     {
[16:13:17.952]                       {
[16:13:17.952]                         base::local({
[16:13:17.952]                           has_future <- base::requireNamespace("future", 
[16:13:17.952]                             quietly = TRUE)
[16:13:17.952]                           if (has_future) {
[16:13:17.952]                             ns <- base::getNamespace("future")
[16:13:17.952]                             version <- ns[[".package"]][["version"]]
[16:13:17.952]                             if (is.null(version)) 
[16:13:17.952]                               version <- utils::packageVersion("future")
[16:13:17.952]                           }
[16:13:17.952]                           else {
[16:13:17.952]                             version <- NULL
[16:13:17.952]                           }
[16:13:17.952]                           if (!has_future || version < "1.8.0") {
[16:13:17.952]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.952]                               "", base::R.version$version.string), 
[16:13:17.952]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:17.952]                                 base::R.version$platform, 8 * 
[16:13:17.952]                                   base::.Machine$sizeof.pointer), 
[16:13:17.952]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.952]                                 "release", "version")], collapse = " "), 
[16:13:17.952]                               hostname = base::Sys.info()[["nodename"]])
[16:13:17.952]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.952]                               info)
[16:13:17.952]                             info <- base::paste(info, collapse = "; ")
[16:13:17.952]                             if (!has_future) {
[16:13:17.952]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.952]                                 info)
[16:13:17.952]                             }
[16:13:17.952]                             else {
[16:13:17.952]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.952]                                 info, version)
[16:13:17.952]                             }
[16:13:17.952]                             base::stop(msg)
[16:13:17.952]                           }
[16:13:17.952]                         })
[16:13:17.952]                       }
[16:13:17.952]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:17.952]                       base::options(mc.cores = 1L)
[16:13:17.952]                     }
[16:13:17.952]                     base::local({
[16:13:17.952]                       for (pkg in "future") {
[16:13:17.952]                         base::loadNamespace(pkg)
[16:13:17.952]                         base::library(pkg, character.only = TRUE)
[16:13:17.952]                       }
[16:13:17.952]                     })
[16:13:17.952]                   }
[16:13:17.952]                   options(future.plan = NULL)
[16:13:17.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.952]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.952]                     envir = parent.frame()) 
[16:13:17.952]                   {
[16:13:17.952]                     default_workers <- missing(workers)
[16:13:17.952]                     if (is.function(workers)) 
[16:13:17.952]                       workers <- workers()
[16:13:17.952]                     workers <- structure(as.integer(workers), 
[16:13:17.952]                       class = class(workers))
[16:13:17.952]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.952]                       1L)
[16:13:17.952]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.952]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.952]                       if (default_workers) 
[16:13:17.952]                         supportsMulticore(warn = TRUE)
[16:13:17.952]                       return(sequential(..., envir = envir))
[16:13:17.952]                     }
[16:13:17.952]                     oopts <- options(mc.cores = workers)
[16:13:17.952]                     on.exit(options(oopts))
[16:13:17.952]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.952]                       envir = envir)
[16:13:17.952]                     if (!future$lazy) 
[16:13:17.952]                       future <- run(future)
[16:13:17.952]                     invisible(future)
[16:13:17.952]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.952]                 }
[16:13:17.952]                 ...future.workdir <- getwd()
[16:13:17.952]             }
[16:13:17.952]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.952]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.952]         }
[16:13:17.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.952]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.952]             base::names(...future.oldOptions))
[16:13:17.952]     }
[16:13:17.952]     if (FALSE) {
[16:13:17.952]     }
[16:13:17.952]     else {
[16:13:17.952]         if (TRUE) {
[16:13:17.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.952]                 open = "w")
[16:13:17.952]         }
[16:13:17.952]         else {
[16:13:17.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.952]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.952]         }
[16:13:17.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.952]             base::sink(type = "output", split = FALSE)
[16:13:17.952]             base::close(...future.stdout)
[16:13:17.952]         }, add = TRUE)
[16:13:17.952]     }
[16:13:17.952]     ...future.frame <- base::sys.nframe()
[16:13:17.952]     ...future.conditions <- base::list()
[16:13:17.952]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.952]     if (FALSE) {
[16:13:17.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.952]     }
[16:13:17.952]     ...future.result <- base::tryCatch({
[16:13:17.952]         base::withCallingHandlers({
[16:13:17.952]             ...future.value <- base::withVisible(base::local({
[16:13:17.952]                 withCallingHandlers({
[16:13:17.952]                   {
[16:13:17.952]                     value(future(subset(data, a == 2)))
[16:13:17.952]                   }
[16:13:17.952]                 }, immediateCondition = function(cond) {
[16:13:17.952]                   save_rds <- function (object, pathname, ...) 
[16:13:17.952]                   {
[16:13:17.952]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:17.952]                     if (file_test("-f", pathname_tmp)) {
[16:13:17.952]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.952]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:17.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.952]                         fi_tmp[["mtime"]])
[16:13:17.952]                     }
[16:13:17.952]                     tryCatch({
[16:13:17.952]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:17.952]                     }, error = function(ex) {
[16:13:17.952]                       msg <- conditionMessage(ex)
[16:13:17.952]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.952]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:17.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.952]                         fi_tmp[["mtime"]], msg)
[16:13:17.952]                       ex$message <- msg
[16:13:17.952]                       stop(ex)
[16:13:17.952]                     })
[16:13:17.952]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:17.952]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:17.952]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:17.952]                       fi_tmp <- file.info(pathname_tmp)
[16:13:17.952]                       fi <- file.info(pathname)
[16:13:17.952]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:17.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:17.952]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:17.952]                         fi[["size"]], fi[["mtime"]])
[16:13:17.952]                       stop(msg)
[16:13:17.952]                     }
[16:13:17.952]                     invisible(pathname)
[16:13:17.952]                   }
[16:13:17.952]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:17.952]                     rootPath = tempdir()) 
[16:13:17.952]                   {
[16:13:17.952]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:17.952]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:17.952]                       tmpdir = path, fileext = ".rds")
[16:13:17.952]                     save_rds(obj, file)
[16:13:17.952]                   }
[16:13:17.952]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:17.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.952]                   {
[16:13:17.952]                     inherits <- base::inherits
[16:13:17.952]                     invokeRestart <- base::invokeRestart
[16:13:17.952]                     is.null <- base::is.null
[16:13:17.952]                     muffled <- FALSE
[16:13:17.952]                     if (inherits(cond, "message")) {
[16:13:17.952]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:17.952]                       if (muffled) 
[16:13:17.952]                         invokeRestart("muffleMessage")
[16:13:17.952]                     }
[16:13:17.952]                     else if (inherits(cond, "warning")) {
[16:13:17.952]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:17.952]                       if (muffled) 
[16:13:17.952]                         invokeRestart("muffleWarning")
[16:13:17.952]                     }
[16:13:17.952]                     else if (inherits(cond, "condition")) {
[16:13:17.952]                       if (!is.null(pattern)) {
[16:13:17.952]                         computeRestarts <- base::computeRestarts
[16:13:17.952]                         grepl <- base::grepl
[16:13:17.952]                         restarts <- computeRestarts(cond)
[16:13:17.952]                         for (restart in restarts) {
[16:13:17.952]                           name <- restart$name
[16:13:17.952]                           if (is.null(name)) 
[16:13:17.952]                             next
[16:13:17.952]                           if (!grepl(pattern, name)) 
[16:13:17.952]                             next
[16:13:17.952]                           invokeRestart(restart)
[16:13:17.952]                           muffled <- TRUE
[16:13:17.952]                           break
[16:13:17.952]                         }
[16:13:17.952]                       }
[16:13:17.952]                     }
[16:13:17.952]                     invisible(muffled)
[16:13:17.952]                   }
[16:13:17.952]                   muffleCondition(cond)
[16:13:17.952]                 })
[16:13:17.952]             }))
[16:13:17.952]             future::FutureResult(value = ...future.value$value, 
[16:13:17.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.952]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.952]                     ...future.globalenv.names))
[16:13:17.952]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.952]         }, condition = base::local({
[16:13:17.952]             c <- base::c
[16:13:17.952]             inherits <- base::inherits
[16:13:17.952]             invokeRestart <- base::invokeRestart
[16:13:17.952]             length <- base::length
[16:13:17.952]             list <- base::list
[16:13:17.952]             seq.int <- base::seq.int
[16:13:17.952]             signalCondition <- base::signalCondition
[16:13:17.952]             sys.calls <- base::sys.calls
[16:13:17.952]             `[[` <- base::`[[`
[16:13:17.952]             `+` <- base::`+`
[16:13:17.952]             `<<-` <- base::`<<-`
[16:13:17.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.952]                   3L)]
[16:13:17.952]             }
[16:13:17.952]             function(cond) {
[16:13:17.952]                 is_error <- inherits(cond, "error")
[16:13:17.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.952]                   NULL)
[16:13:17.952]                 if (is_error) {
[16:13:17.952]                   sessionInformation <- function() {
[16:13:17.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.952]                       search = base::search(), system = base::Sys.info())
[16:13:17.952]                   }
[16:13:17.952]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.952]                     cond$call), session = sessionInformation(), 
[16:13:17.952]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.952]                   signalCondition(cond)
[16:13:17.952]                 }
[16:13:17.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.952]                 "immediateCondition"))) {
[16:13:17.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.952]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.952]                   if (TRUE && !signal) {
[16:13:17.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.952]                     {
[16:13:17.952]                       inherits <- base::inherits
[16:13:17.952]                       invokeRestart <- base::invokeRestart
[16:13:17.952]                       is.null <- base::is.null
[16:13:17.952]                       muffled <- FALSE
[16:13:17.952]                       if (inherits(cond, "message")) {
[16:13:17.952]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.952]                         if (muffled) 
[16:13:17.952]                           invokeRestart("muffleMessage")
[16:13:17.952]                       }
[16:13:17.952]                       else if (inherits(cond, "warning")) {
[16:13:17.952]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.952]                         if (muffled) 
[16:13:17.952]                           invokeRestart("muffleWarning")
[16:13:17.952]                       }
[16:13:17.952]                       else if (inherits(cond, "condition")) {
[16:13:17.952]                         if (!is.null(pattern)) {
[16:13:17.952]                           computeRestarts <- base::computeRestarts
[16:13:17.952]                           grepl <- base::grepl
[16:13:17.952]                           restarts <- computeRestarts(cond)
[16:13:17.952]                           for (restart in restarts) {
[16:13:17.952]                             name <- restart$name
[16:13:17.952]                             if (is.null(name)) 
[16:13:17.952]                               next
[16:13:17.952]                             if (!grepl(pattern, name)) 
[16:13:17.952]                               next
[16:13:17.952]                             invokeRestart(restart)
[16:13:17.952]                             muffled <- TRUE
[16:13:17.952]                             break
[16:13:17.952]                           }
[16:13:17.952]                         }
[16:13:17.952]                       }
[16:13:17.952]                       invisible(muffled)
[16:13:17.952]                     }
[16:13:17.952]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.952]                   }
[16:13:17.952]                 }
[16:13:17.952]                 else {
[16:13:17.952]                   if (TRUE) {
[16:13:17.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.952]                     {
[16:13:17.952]                       inherits <- base::inherits
[16:13:17.952]                       invokeRestart <- base::invokeRestart
[16:13:17.952]                       is.null <- base::is.null
[16:13:17.952]                       muffled <- FALSE
[16:13:17.952]                       if (inherits(cond, "message")) {
[16:13:17.952]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.952]                         if (muffled) 
[16:13:17.952]                           invokeRestart("muffleMessage")
[16:13:17.952]                       }
[16:13:17.952]                       else if (inherits(cond, "warning")) {
[16:13:17.952]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.952]                         if (muffled) 
[16:13:17.952]                           invokeRestart("muffleWarning")
[16:13:17.952]                       }
[16:13:17.952]                       else if (inherits(cond, "condition")) {
[16:13:17.952]                         if (!is.null(pattern)) {
[16:13:17.952]                           computeRestarts <- base::computeRestarts
[16:13:17.952]                           grepl <- base::grepl
[16:13:17.952]                           restarts <- computeRestarts(cond)
[16:13:17.952]                           for (restart in restarts) {
[16:13:17.952]                             name <- restart$name
[16:13:17.952]                             if (is.null(name)) 
[16:13:17.952]                               next
[16:13:17.952]                             if (!grepl(pattern, name)) 
[16:13:17.952]                               next
[16:13:17.952]                             invokeRestart(restart)
[16:13:17.952]                             muffled <- TRUE
[16:13:17.952]                             break
[16:13:17.952]                           }
[16:13:17.952]                         }
[16:13:17.952]                       }
[16:13:17.952]                       invisible(muffled)
[16:13:17.952]                     }
[16:13:17.952]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.952]                   }
[16:13:17.952]                 }
[16:13:17.952]             }
[16:13:17.952]         }))
[16:13:17.952]     }, error = function(ex) {
[16:13:17.952]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.952]                 ...future.rng), started = ...future.startTime, 
[16:13:17.952]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.952]             version = "1.8"), class = "FutureResult")
[16:13:17.952]     }, finally = {
[16:13:17.952]         if (!identical(...future.workdir, getwd())) 
[16:13:17.952]             setwd(...future.workdir)
[16:13:17.952]         {
[16:13:17.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.952]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.952]             }
[16:13:17.952]             base::options(...future.oldOptions)
[16:13:17.952]             if (.Platform$OS.type == "windows") {
[16:13:17.952]                 old_names <- names(...future.oldEnvVars)
[16:13:17.952]                 envs <- base::Sys.getenv()
[16:13:17.952]                 names <- names(envs)
[16:13:17.952]                 common <- intersect(names, old_names)
[16:13:17.952]                 added <- setdiff(names, old_names)
[16:13:17.952]                 removed <- setdiff(old_names, names)
[16:13:17.952]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.952]                   envs[common]]
[16:13:17.952]                 NAMES <- toupper(changed)
[16:13:17.952]                 args <- list()
[16:13:17.952]                 for (kk in seq_along(NAMES)) {
[16:13:17.952]                   name <- changed[[kk]]
[16:13:17.952]                   NAME <- NAMES[[kk]]
[16:13:17.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.952]                     next
[16:13:17.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.952]                 }
[16:13:17.952]                 NAMES <- toupper(added)
[16:13:17.952]                 for (kk in seq_along(NAMES)) {
[16:13:17.952]                   name <- added[[kk]]
[16:13:17.952]                   NAME <- NAMES[[kk]]
[16:13:17.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.952]                     next
[16:13:17.952]                   args[[name]] <- ""
[16:13:17.952]                 }
[16:13:17.952]                 NAMES <- toupper(removed)
[16:13:17.952]                 for (kk in seq_along(NAMES)) {
[16:13:17.952]                   name <- removed[[kk]]
[16:13:17.952]                   NAME <- NAMES[[kk]]
[16:13:17.952]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.952]                     next
[16:13:17.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.952]                 }
[16:13:17.952]                 if (length(args) > 0) 
[16:13:17.952]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.952]             }
[16:13:17.952]             else {
[16:13:17.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.952]             }
[16:13:17.952]             {
[16:13:17.952]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.952]                   0L) {
[16:13:17.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.952]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.952]                   base::options(opts)
[16:13:17.952]                 }
[16:13:17.952]                 {
[16:13:17.952]                   {
[16:13:17.952]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:17.952]                     NULL
[16:13:17.952]                   }
[16:13:17.952]                   options(future.plan = NULL)
[16:13:17.952]                   if (is.na(NA_character_)) 
[16:13:17.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.952]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.952]                     envir = parent.frame()) 
[16:13:17.952]                   {
[16:13:17.952]                     default_workers <- missing(workers)
[16:13:17.952]                     if (is.function(workers)) 
[16:13:17.952]                       workers <- workers()
[16:13:17.952]                     workers <- structure(as.integer(workers), 
[16:13:17.952]                       class = class(workers))
[16:13:17.952]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.952]                       1L)
[16:13:17.952]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.952]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.952]                       if (default_workers) 
[16:13:17.952]                         supportsMulticore(warn = TRUE)
[16:13:17.952]                       return(sequential(..., envir = envir))
[16:13:17.952]                     }
[16:13:17.952]                     oopts <- options(mc.cores = workers)
[16:13:17.952]                     on.exit(options(oopts))
[16:13:17.952]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.952]                       envir = envir)
[16:13:17.952]                     if (!future$lazy) 
[16:13:17.952]                       future <- run(future)
[16:13:17.952]                     invisible(future)
[16:13:17.952]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.952]                     envir = parent.frame()) 
[16:13:17.952]                   {
[16:13:17.952]                     default_workers <- missing(workers)
[16:13:17.952]                     if (is.function(workers)) 
[16:13:17.952]                       workers <- workers()
[16:13:17.952]                     workers <- structure(as.integer(workers), 
[16:13:17.952]                       class = class(workers))
[16:13:17.952]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.952]                       1L)
[16:13:17.952]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.952]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.952]                       if (default_workers) 
[16:13:17.952]                         supportsMulticore(warn = TRUE)
[16:13:17.952]                       return(sequential(..., envir = envir))
[16:13:17.952]                     }
[16:13:17.952]                     oopts <- options(mc.cores = workers)
[16:13:17.952]                     on.exit(options(oopts))
[16:13:17.952]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.952]                       envir = envir)
[16:13:17.952]                     if (!future$lazy) 
[16:13:17.952]                       future <- run(future)
[16:13:17.952]                     invisible(future)
[16:13:17.952]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.952]                 }
[16:13:17.952]             }
[16:13:17.952]         }
[16:13:17.952]     })
[16:13:17.952]     if (TRUE) {
[16:13:17.952]         base::sink(type = "output", split = FALSE)
[16:13:17.952]         if (TRUE) {
[16:13:17.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.952]         }
[16:13:17.952]         else {
[16:13:17.952]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.952]         }
[16:13:17.952]         base::close(...future.stdout)
[16:13:17.952]         ...future.stdout <- NULL
[16:13:17.952]     }
[16:13:17.952]     ...future.result$conditions <- ...future.conditions
[16:13:17.952]     ...future.result$finished <- base::Sys.time()
[16:13:17.952]     ...future.result
[16:13:17.952] }
[16:13:17.955] assign_globals() ...
[16:13:17.955] List of 1
[16:13:17.955]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:17.955]   ..$ a: int [1:3] 1 2 3
[16:13:17.955]   ..$ b: int [1:3] 3 2 1
[16:13:17.955]  - attr(*, "where")=List of 1
[16:13:17.955]   ..$ data:<environment: R_EmptyEnv> 
[16:13:17.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.955]  - attr(*, "resolved")= logi FALSE
[16:13:17.955]  - attr(*, "total_size")= num 128
[16:13:17.955]  - attr(*, "already-done")= logi TRUE
[16:13:17.959] - copied ‘data’ to environment
[16:13:17.959] assign_globals() ... done
[16:13:17.959] requestCore(): workers = 2
[16:13:17.962] MulticoreFuture started
[16:13:17.962] - Launch lazy future ... done
[16:13:17.962] run() for ‘MulticoreFuture’ ... done
[16:13:17.963] plan(): Setting new future strategy stack:
[16:13:17.963] List of future strategies:
[16:13:17.963] 1. multicore:
[16:13:17.963]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:17.963]    - tweaked: FALSE
[16:13:17.963]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:17.969] plan(): nbrOfWorkers() = 1
[16:13:18.006] plan(): Setting new future strategy stack:
[16:13:18.006] List of future strategies:
[16:13:18.006] 1. multicore:
[16:13:18.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.006]    - tweaked: FALSE
[16:13:18.006]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.006] 2. multicore:
[16:13:18.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.006]    - tweaked: FALSE
[16:13:18.006]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.010] plan(): nbrOfWorkers() = 2
[16:13:18.011] signalConditions() ...
[16:13:18.011]  - include = ‘immediateCondition’
[16:13:18.011]  - exclude = 
[16:13:18.011]  - resignal = FALSE
[16:13:18.012]  - Number of conditions: 52
[16:13:18.012] signalConditions() ... done
[16:13:18.012] signalConditions() ...
[16:13:18.012]  - include = ‘immediateCondition’
[16:13:18.012]  - exclude = 
[16:13:18.012]  - resignal = FALSE
[16:13:18.012]  - Number of conditions: 52
[16:13:18.012] signalConditions() ... done
[16:13:18.013] Future state: ‘finished’
[16:13:18.013] signalConditions() ...
[16:13:18.013]  - include = ‘condition’
[16:13:18.013]  - exclude = ‘immediateCondition’
[16:13:18.013]  - resignal = TRUE
[16:13:18.013]  - Number of conditions: 52
[16:13:18.013]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.970] getGlobalsAndPackages() ...
[16:13:18.013]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.971] Searching for globals...
[16:13:18.014]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.972] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:18.014]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.973] Searching for globals ... DONE
[16:13:18.014]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.973] Resolving globals: FALSE
[16:13:18.014]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.974] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:18.014]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.974] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:18.014]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.975] - globals: [1] ‘data’
[16:13:18.015]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.975] 
[16:13:18.015]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.975] getGlobalsAndPackages() ... DONE
[16:13:18.015]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.976] run() for ‘Future’ ...
[16:13:18.015]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.976] - state: ‘created’
[16:13:18.015]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.976] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.015]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.981] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:18.016]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:18.016]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.981]   - Field: ‘label’
[16:13:18.016]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.981]   - Field: ‘local’
[16:13:18.016]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.981]   - Field: ‘owner’
[16:13:18.016]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.981]   - Field: ‘envir’
[16:13:18.016]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.982]   - Field: ‘packages’
[16:13:18.017]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.982]   - Field: ‘gc’
[16:13:18.017]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.982]   - Field: ‘conditions’
[16:13:18.017]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.982]   - Field: ‘expr’
[16:13:18.017]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.982]   - Field: ‘uuid’
[16:13:18.017]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.982]   - Field: ‘seed’
[16:13:18.017]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘version’
[16:13:18.018]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘result’
[16:13:18.018]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘asynchronous’
[16:13:18.018]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘calls’
[16:13:18.018]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘globals’
[16:13:18.018]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘stdout’
[16:13:18.018]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.983]   - Field: ‘earlySignal’
[16:13:18.018]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.984]   - Field: ‘lazy’
[16:13:18.019]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.984]   - Field: ‘state’
[16:13:18.019]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:18.019]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.984] - Launch lazy future ...
[16:13:18.019]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.984] Packages needed by the future expression (n = 0): <none>
[16:13:18.019]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.985] Packages needed by future strategies (n = 0): <none>
[16:13:18.019]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.985] {
[16:13:17.985]     {
[16:13:17.985]         {
[16:13:17.985]             ...future.startTime <- base::Sys.time()
[16:13:17.985]             {
[16:13:17.985]                 {
[16:13:17.985]                   {
[16:13:17.985]                     base::local({
[16:13:17.985]                       has_future <- base::requireNamespace("future", 
[16:13:17.985]                         quietly = TRUE)
[16:13:17.985]                       if (has_future) {
[16:13:17.985]                         ns <- base::getNamespace("future")
[16:13:17.985]                         version <- ns[[".package"]][["version"]]
[16:13:17.985]                         if (is.null(version)) 
[16:13:17.985]                           version <- utils::packageVersion("future")
[16:13:17.985]                       }
[16:13:17.985]                       else {
[16:13:17.985]                         version <- NULL
[16:13:17.985]                       }
[16:13:17.985]                       if (!has_future || version < "1.8.0") {
[16:13:17.985]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:17.985]                           "", base::R.version$version.string), 
[16:13:17.985]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:17.985]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:17.985]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:17.985]                             "release", "version")], collapse = " "), 
[16:13:17.985]                           hostname = base::Sys.info()[["nodename"]])
[16:13:17.985]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:17.985]                           info)
[16:13:17.985]                         info <- base::paste(info, collapse = "; ")
[16:13:17.985]                         if (!has_future) {
[16:13:17.985]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:17.985]                             info)
[16:13:17.985]                         }
[16:13:17.985]                         else {
[16:13:17.985]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:17.985]                             info, version)
[16:13:17.985]                         }
[16:13:17.985]                         base::stop(msg)
[16:13:17.985]                       }
[16:13:17.985]                     })
[16:13:17.985]                   }
[16:13:17.985]                   options(future.plan = NULL)
[16:13:17.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:17.985]                 }
[16:13:17.985]                 ...future.workdir <- getwd()
[16:13:17.985]             }
[16:13:17.985]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:17.985]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:17.985]         }
[16:13:17.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:17.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:17.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:17.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:17.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:17.985]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:17.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:17.985]             base::names(...future.oldOptions))
[16:13:17.985]     }
[16:13:17.985]     if (FALSE) {
[16:13:17.985]     }
[16:13:17.985]     else {
[16:13:17.985]         if (TRUE) {
[16:13:17.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:17.985]                 open = "w")
[16:13:17.985]         }
[16:13:17.985]         else {
[16:13:17.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:17.985]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:17.985]         }
[16:13:17.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:17.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:17.985]             base::sink(type = "output", split = FALSE)
[16:13:17.985]             base::close(...future.stdout)
[16:13:17.985]         }, add = TRUE)
[16:13:17.985]     }
[16:13:17.985]     ...future.frame <- base::sys.nframe()
[16:13:17.985]     ...future.conditions <- base::list()
[16:13:17.985]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:17.985]     if (FALSE) {
[16:13:17.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:17.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:17.985]     }
[16:13:17.985]     ...future.result <- base::tryCatch({
[16:13:17.985]         base::withCallingHandlers({
[16:13:17.985]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:13:17.985]                 a == 2)))
[16:13:17.985]             future::FutureResult(value = ...future.value$value, 
[16:13:17.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.985]                   ...future.rng), globalenv = if (FALSE) 
[16:13:17.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:17.985]                     ...future.globalenv.names))
[16:13:17.985]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:17.985]         }, condition = base::local({
[16:13:17.985]             c <- base::c
[16:13:17.985]             inherits <- base::inherits
[16:13:17.985]             invokeRestart <- base::invokeRestart
[16:13:17.985]             length <- base::length
[16:13:17.985]             list <- base::list
[16:13:17.985]             seq.int <- base::seq.int
[16:13:17.985]             signalCondition <- base::signalCondition
[16:13:17.985]             sys.calls <- base::sys.calls
[16:13:17.985]             `[[` <- base::`[[`
[16:13:17.985]             `+` <- base::`+`
[16:13:17.985]             `<<-` <- base::`<<-`
[16:13:17.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:17.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:17.985]                   3L)]
[16:13:17.985]             }
[16:13:17.985]             function(cond) {
[16:13:17.985]                 is_error <- inherits(cond, "error")
[16:13:17.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:17.985]                   NULL)
[16:13:17.985]                 if (is_error) {
[16:13:17.985]                   sessionInformation <- function() {
[16:13:17.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:17.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:17.985]                       search = base::search(), system = base::Sys.info())
[16:13:17.985]                   }
[16:13:17.985]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:17.985]                     cond$call), session = sessionInformation(), 
[16:13:17.985]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:17.985]                   signalCondition(cond)
[16:13:17.985]                 }
[16:13:17.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:17.985]                 "immediateCondition"))) {
[16:13:17.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:17.985]                   ...future.conditions[[length(...future.conditions) + 
[16:13:17.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:17.985]                   if (TRUE && !signal) {
[16:13:17.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.985]                     {
[16:13:17.985]                       inherits <- base::inherits
[16:13:17.985]                       invokeRestart <- base::invokeRestart
[16:13:17.985]                       is.null <- base::is.null
[16:13:17.985]                       muffled <- FALSE
[16:13:17.985]                       if (inherits(cond, "message")) {
[16:13:17.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.985]                         if (muffled) 
[16:13:17.985]                           invokeRestart("muffleMessage")
[16:13:17.985]                       }
[16:13:17.985]                       else if (inherits(cond, "warning")) {
[16:13:17.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.985]                         if (muffled) 
[16:13:17.985]                           invokeRestart("muffleWarning")
[16:13:17.985]                       }
[16:13:17.985]                       else if (inherits(cond, "condition")) {
[16:13:17.985]                         if (!is.null(pattern)) {
[16:13:17.985]                           computeRestarts <- base::computeRestarts
[16:13:17.985]                           grepl <- base::grepl
[16:13:17.985]                           restarts <- computeRestarts(cond)
[16:13:17.985]                           for (restart in restarts) {
[16:13:17.985]                             name <- restart$name
[16:13:17.985]                             if (is.null(name)) 
[16:13:17.985]                               next
[16:13:17.985]                             if (!grepl(pattern, name)) 
[16:13:17.985]                               next
[16:13:17.985]                             invokeRestart(restart)
[16:13:17.985]                             muffled <- TRUE
[16:13:17.985]                             break
[16:13:17.985]                           }
[16:13:17.985]                         }
[16:13:17.985]                       }
[16:13:17.985]                       invisible(muffled)
[16:13:17.985]                     }
[16:13:17.985]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.985]                   }
[16:13:17.985]                 }
[16:13:17.985]                 else {
[16:13:17.985]                   if (TRUE) {
[16:13:17.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:17.985]                     {
[16:13:17.985]                       inherits <- base::inherits
[16:13:17.985]                       invokeRestart <- base::invokeRestart
[16:13:17.985]                       is.null <- base::is.null
[16:13:17.985]                       muffled <- FALSE
[16:13:17.985]                       if (inherits(cond, "message")) {
[16:13:17.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:17.985]                         if (muffled) 
[16:13:17.985]                           invokeRestart("muffleMessage")
[16:13:17.985]                       }
[16:13:17.985]                       else if (inherits(cond, "warning")) {
[16:13:17.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:17.985]                         if (muffled) 
[16:13:17.985]                           invokeRestart("muffleWarning")
[16:13:17.985]                       }
[16:13:17.985]                       else if (inherits(cond, "condition")) {
[16:13:17.985]                         if (!is.null(pattern)) {
[16:13:17.985]                           computeRestarts <- base::computeRestarts
[16:13:17.985]                           grepl <- base::grepl
[16:13:17.985]                           restarts <- computeRestarts(cond)
[16:13:17.985]                           for (restart in restarts) {
[16:13:17.985]                             name <- restart$name
[16:13:17.985]                             if (is.null(name)) 
[16:13:17.985]                               next
[16:13:17.985]                             if (!grepl(pattern, name)) 
[16:13:17.985]                               next
[16:13:17.985]                             invokeRestart(restart)
[16:13:17.985]                             muffled <- TRUE
[16:13:17.985]                             break
[16:13:17.985]                           }
[16:13:17.985]                         }
[16:13:17.985]                       }
[16:13:17.985]                       invisible(muffled)
[16:13:17.985]                     }
[16:13:17.985]                     muffleCondition(cond, pattern = "^muffle")
[16:13:17.985]                   }
[16:13:17.985]                 }
[16:13:17.985]             }
[16:13:17.985]         }))
[16:13:17.985]     }, error = function(ex) {
[16:13:17.985]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:17.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:17.985]                 ...future.rng), started = ...future.startTime, 
[16:13:17.985]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:17.985]             version = "1.8"), class = "FutureResult")
[16:13:17.985]     }, finally = {
[16:13:17.985]         if (!identical(...future.workdir, getwd())) 
[16:13:17.985]             setwd(...future.workdir)
[16:13:17.985]         {
[16:13:17.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:17.985]                 ...future.oldOptions$nwarnings <- NULL
[16:13:17.985]             }
[16:13:17.985]             base::options(...future.oldOptions)
[16:13:17.985]             if (.Platform$OS.type == "windows") {
[16:13:17.985]                 old_names <- names(...future.oldEnvVars)
[16:13:17.985]                 envs <- base::Sys.getenv()
[16:13:17.985]                 names <- names(envs)
[16:13:17.985]                 common <- intersect(names, old_names)
[16:13:17.985]                 added <- setdiff(names, old_names)
[16:13:17.985]                 removed <- setdiff(old_names, names)
[16:13:17.985]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:17.985]                   envs[common]]
[16:13:17.985]                 NAMES <- toupper(changed)
[16:13:17.985]                 args <- list()
[16:13:17.985]                 for (kk in seq_along(NAMES)) {
[16:13:17.985]                   name <- changed[[kk]]
[16:13:17.985]                   NAME <- NAMES[[kk]]
[16:13:17.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.985]                     next
[16:13:17.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.985]                 }
[16:13:17.985]                 NAMES <- toupper(added)
[16:13:17.985]                 for (kk in seq_along(NAMES)) {
[16:13:17.985]                   name <- added[[kk]]
[16:13:17.985]                   NAME <- NAMES[[kk]]
[16:13:17.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.985]                     next
[16:13:17.985]                   args[[name]] <- ""
[16:13:17.985]                 }
[16:13:17.985]                 NAMES <- toupper(removed)
[16:13:17.985]                 for (kk in seq_along(NAMES)) {
[16:13:17.985]                   name <- removed[[kk]]
[16:13:17.985]                   NAME <- NAMES[[kk]]
[16:13:17.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:17.985]                     next
[16:13:17.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:17.985]                 }
[16:13:17.985]                 if (length(args) > 0) 
[16:13:17.985]                   base::do.call(base::Sys.setenv, args = args)
[16:13:17.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:17.985]             }
[16:13:17.985]             else {
[16:13:17.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:17.985]             }
[16:13:17.985]             {
[16:13:17.985]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:17.985]                   0L) {
[16:13:17.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:17.985]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:17.985]                   base::options(opts)
[16:13:17.985]                 }
[16:13:17.985]                 {
[16:13:17.985]                   {
[16:13:17.985]                     NULL
[16:13:17.985]                     RNGkind("Mersenne-Twister")
[16:13:17.985]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:17.985]                       inherits = FALSE)
[16:13:17.985]                   }
[16:13:17.985]                   options(future.plan = NULL)
[16:13:17.985]                   if (is.na(NA_character_)) 
[16:13:17.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:17.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:17.985]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:17.985]                     envir = parent.frame()) 
[16:13:17.985]                   {
[16:13:17.985]                     default_workers <- missing(workers)
[16:13:17.985]                     if (is.function(workers)) 
[16:13:17.985]                       workers <- workers()
[16:13:17.985]                     workers <- structure(as.integer(workers), 
[16:13:17.985]                       class = class(workers))
[16:13:17.985]                     stop_if_not(is.finite(workers), workers >= 
[16:13:17.985]                       1L)
[16:13:17.985]                     if ((workers == 1L && !inherits(workers, 
[16:13:17.985]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:17.985]                       if (default_workers) 
[16:13:17.985]                         supportsMulticore(warn = TRUE)
[16:13:17.985]                       return(sequential(..., envir = envir))
[16:13:17.985]                     }
[16:13:17.985]                     oopts <- options(mc.cores = workers)
[16:13:17.985]                     on.exit(options(oopts))
[16:13:17.985]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:17.985]                       envir = envir)
[16:13:17.985]                     if (!future$lazy) 
[16:13:17.985]                       future <- run(future)
[16:13:17.985]                     invisible(future)
[16:13:17.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:17.985]                 }
[16:13:17.985]             }
[16:13:17.985]         }
[16:13:17.985]     })
[16:13:17.985]     if (TRUE) {
[16:13:17.985]         base::sink(type = "output", split = FALSE)
[16:13:17.985]         if (TRUE) {
[16:13:17.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:17.985]         }
[16:13:17.985]         else {
[16:13:17.985]             ...future.result["stdout"] <- base::list(NULL)
[16:13:17.985]         }
[16:13:17.985]         base::close(...future.stdout)
[16:13:17.985]         ...future.stdout <- NULL
[16:13:17.985]     }
[16:13:17.985]     ...future.result$conditions <- ...future.conditions
[16:13:17.985]     ...future.result$finished <- base::Sys.time()
[16:13:17.985]     ...future.result
[16:13:17.985] }
[16:13:18.020]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.988] assign_globals() ...
[16:13:18.020]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.988] List of 1
[16:13:17.988]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:17.988]   ..$ a: int [1:3] 1 2 3
[16:13:17.988]   ..$ b: int [1:3] 3 2 1
[16:13:17.988]  - attr(*, "where")=List of 1
[16:13:17.988]   ..$ data:<environment: R_EmptyEnv> 
[16:13:17.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:17.988]  - attr(*, "resolved")= logi FALSE
[16:13:17.988]  - attr(*, "total_size")= num 128
[16:13:17.988]  - attr(*, "already-done")= logi TRUE
[16:13:18.020]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.993] - copied ‘data’ to environment
[16:13:18.020]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.993] assign_globals() ... done
[16:13:18.020]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.993] plan(): Setting new future strategy stack:
[16:13:18.020]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.993] List of future strategies:
[16:13:17.993] 1. sequential:
[16:13:17.993]    - args: function (..., envir = parent.frame())
[16:13:17.993]    - tweaked: FALSE
[16:13:17.993]    - call: NULL
[16:13:18.020]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.994] plan(): nbrOfWorkers() = 1
[16:13:18.021]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:17.999] plan(): Setting new future strategy stack:
[16:13:18.021]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.000] List of future strategies:
[16:13:18.000] 1. multicore:
[16:13:18.000]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.000]    - tweaked: FALSE
[16:13:18.000]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.021]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.004] plan(): nbrOfWorkers() = 1
[16:13:18.021]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.004] SequentialFuture started (and completed)
[16:13:18.021]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.005] - Launch lazy future ... done
[16:13:18.021]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.005] run() for ‘SequentialFuture’ ... done
[16:13:18.022] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[16:13:18.022] plan(): Setting new future strategy stack:
[16:13:18.022] List of future strategies:
[16:13:18.022] 1. multicore:
[16:13:18.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.022]    - tweaked: FALSE
[16:13:18.022]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.022] 2. multisession:
[16:13:18.022]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.022]    - tweaked: FALSE
[16:13:18.022]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.027] plan(): nbrOfWorkers() = 2
[16:13:18.027] getGlobalsAndPackages() ...
[16:13:18.027] Searching for globals...
[16:13:18.050] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:18.050] Searching for globals ... DONE
[16:13:18.050] Resolving globals: FALSE
[16:13:18.051] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[16:13:18.052] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:18.052] - globals: [2] ‘nested’, ‘strategy2’
[16:13:18.052] - packages: [1] ‘future’
[16:13:18.052] getGlobalsAndPackages() ... DONE
[16:13:18.053] run() for ‘Future’ ...
[16:13:18.053] - state: ‘created’
[16:13:18.053] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.057] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:18.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:18.057]   - Field: ‘label’
[16:13:18.057]   - Field: ‘local’
[16:13:18.058]   - Field: ‘owner’
[16:13:18.058]   - Field: ‘envir’
[16:13:18.058]   - Field: ‘workers’
[16:13:18.058]   - Field: ‘packages’
[16:13:18.058]   - Field: ‘gc’
[16:13:18.058]   - Field: ‘job’
[16:13:18.058]   - Field: ‘conditions’
[16:13:18.058]   - Field: ‘expr’
[16:13:18.058]   - Field: ‘uuid’
[16:13:18.059]   - Field: ‘seed’
[16:13:18.059]   - Field: ‘version’
[16:13:18.059]   - Field: ‘result’
[16:13:18.059]   - Field: ‘asynchronous’
[16:13:18.059]   - Field: ‘calls’
[16:13:18.059]   - Field: ‘globals’
[16:13:18.059]   - Field: ‘stdout’
[16:13:18.059]   - Field: ‘earlySignal’
[16:13:18.059]   - Field: ‘lazy’
[16:13:18.060]   - Field: ‘state’
[16:13:18.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:18.060] - Launch lazy future ...
[16:13:18.060] Packages needed by the future expression (n = 1): ‘future’
[16:13:18.060] Packages needed by future strategies (n = 1): ‘future’
[16:13:18.061] {
[16:13:18.061]     {
[16:13:18.061]         {
[16:13:18.061]             ...future.startTime <- base::Sys.time()
[16:13:18.061]             {
[16:13:18.061]                 {
[16:13:18.061]                   {
[16:13:18.061]                     {
[16:13:18.061]                       {
[16:13:18.061]                         base::local({
[16:13:18.061]                           has_future <- base::requireNamespace("future", 
[16:13:18.061]                             quietly = TRUE)
[16:13:18.061]                           if (has_future) {
[16:13:18.061]                             ns <- base::getNamespace("future")
[16:13:18.061]                             version <- ns[[".package"]][["version"]]
[16:13:18.061]                             if (is.null(version)) 
[16:13:18.061]                               version <- utils::packageVersion("future")
[16:13:18.061]                           }
[16:13:18.061]                           else {
[16:13:18.061]                             version <- NULL
[16:13:18.061]                           }
[16:13:18.061]                           if (!has_future || version < "1.8.0") {
[16:13:18.061]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.061]                               "", base::R.version$version.string), 
[16:13:18.061]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:18.061]                                 base::R.version$platform, 8 * 
[16:13:18.061]                                   base::.Machine$sizeof.pointer), 
[16:13:18.061]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.061]                                 "release", "version")], collapse = " "), 
[16:13:18.061]                               hostname = base::Sys.info()[["nodename"]])
[16:13:18.061]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.061]                               info)
[16:13:18.061]                             info <- base::paste(info, collapse = "; ")
[16:13:18.061]                             if (!has_future) {
[16:13:18.061]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.061]                                 info)
[16:13:18.061]                             }
[16:13:18.061]                             else {
[16:13:18.061]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.061]                                 info, version)
[16:13:18.061]                             }
[16:13:18.061]                             base::stop(msg)
[16:13:18.061]                           }
[16:13:18.061]                         })
[16:13:18.061]                       }
[16:13:18.061]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:18.061]                       base::options(mc.cores = 1L)
[16:13:18.061]                     }
[16:13:18.061]                     base::local({
[16:13:18.061]                       for (pkg in "future") {
[16:13:18.061]                         base::loadNamespace(pkg)
[16:13:18.061]                         base::library(pkg, character.only = TRUE)
[16:13:18.061]                       }
[16:13:18.061]                     })
[16:13:18.061]                   }
[16:13:18.061]                   options(future.plan = NULL)
[16:13:18.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.061]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:18.061]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.061]                     envir = parent.frame()) 
[16:13:18.061]                   {
[16:13:18.061]                     if (is.function(workers)) 
[16:13:18.061]                       workers <- workers()
[16:13:18.061]                     workers <- structure(as.integer(workers), 
[16:13:18.061]                       class = class(workers))
[16:13:18.061]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.061]                       workers >= 1)
[16:13:18.061]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.061]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.061]                     }
[16:13:18.061]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.061]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.061]                       envir = envir)
[16:13:18.061]                     if (!future$lazy) 
[16:13:18.061]                       future <- run(future)
[16:13:18.061]                     invisible(future)
[16:13:18.061]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.061]                 }
[16:13:18.061]                 ...future.workdir <- getwd()
[16:13:18.061]             }
[16:13:18.061]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.061]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.061]         }
[16:13:18.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.061]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.061]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.061]             base::names(...future.oldOptions))
[16:13:18.061]     }
[16:13:18.061]     if (FALSE) {
[16:13:18.061]     }
[16:13:18.061]     else {
[16:13:18.061]         if (TRUE) {
[16:13:18.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.061]                 open = "w")
[16:13:18.061]         }
[16:13:18.061]         else {
[16:13:18.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.061]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.061]         }
[16:13:18.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.061]             base::sink(type = "output", split = FALSE)
[16:13:18.061]             base::close(...future.stdout)
[16:13:18.061]         }, add = TRUE)
[16:13:18.061]     }
[16:13:18.061]     ...future.frame <- base::sys.nframe()
[16:13:18.061]     ...future.conditions <- base::list()
[16:13:18.061]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.061]     if (FALSE) {
[16:13:18.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.061]     }
[16:13:18.061]     ...future.result <- base::tryCatch({
[16:13:18.061]         base::withCallingHandlers({
[16:13:18.061]             ...future.value <- base::withVisible(base::local({
[16:13:18.061]                 withCallingHandlers({
[16:13:18.061]                   {
[16:13:18.061]                     a <- 1L
[16:13:18.061]                     plan_a <- unclass(future::plan("list"))
[16:13:18.061]                     nested_a <- nested[-1]
[16:13:18.061]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:18.061]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:18.061]                       strategy2))
[16:13:18.061]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:18.061]                       "init") <- NULL
[16:13:18.061]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:18.061]                       "init") <- NULL
[16:13:18.061]                     stopifnot(all.equal(plan_a, nested_a))
[16:13:18.061]                     y %<-% {
[16:13:18.061]                       b <- 2L
[16:13:18.061]                       plan_b <- future::plan("list")
[16:13:18.061]                       nested_b <- nested_a[-1]
[16:13:18.061]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:18.061]                         1L, inherits(plan_b[[1]], "future"), 
[16:13:18.061]                         inherits(future::plan("next"), "sequential"))
[16:13:18.061]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:18.061]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:18.061]                     }
[16:13:18.061]                     y
[16:13:18.061]                   }
[16:13:18.061]                 }, immediateCondition = function(cond) {
[16:13:18.061]                   save_rds <- function (object, pathname, ...) 
[16:13:18.061]                   {
[16:13:18.061]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:18.061]                     if (file_test("-f", pathname_tmp)) {
[16:13:18.061]                       fi_tmp <- file.info(pathname_tmp)
[16:13:18.061]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:18.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:18.061]                         fi_tmp[["mtime"]])
[16:13:18.061]                     }
[16:13:18.061]                     tryCatch({
[16:13:18.061]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:18.061]                     }, error = function(ex) {
[16:13:18.061]                       msg <- conditionMessage(ex)
[16:13:18.061]                       fi_tmp <- file.info(pathname_tmp)
[16:13:18.061]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:18.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:18.061]                         fi_tmp[["mtime"]], msg)
[16:13:18.061]                       ex$message <- msg
[16:13:18.061]                       stop(ex)
[16:13:18.061]                     })
[16:13:18.061]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:18.061]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:18.061]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:18.061]                       fi_tmp <- file.info(pathname_tmp)
[16:13:18.061]                       fi <- file.info(pathname)
[16:13:18.061]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:18.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:18.061]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:18.061]                         fi[["size"]], fi[["mtime"]])
[16:13:18.061]                       stop(msg)
[16:13:18.061]                     }
[16:13:18.061]                     invisible(pathname)
[16:13:18.061]                   }
[16:13:18.061]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:18.061]                     rootPath = tempdir()) 
[16:13:18.061]                   {
[16:13:18.061]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:18.061]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:18.061]                       tmpdir = path, fileext = ".rds")
[16:13:18.061]                     save_rds(obj, file)
[16:13:18.061]                   }
[16:13:18.061]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:18.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.061]                   {
[16:13:18.061]                     inherits <- base::inherits
[16:13:18.061]                     invokeRestart <- base::invokeRestart
[16:13:18.061]                     is.null <- base::is.null
[16:13:18.061]                     muffled <- FALSE
[16:13:18.061]                     if (inherits(cond, "message")) {
[16:13:18.061]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:18.061]                       if (muffled) 
[16:13:18.061]                         invokeRestart("muffleMessage")
[16:13:18.061]                     }
[16:13:18.061]                     else if (inherits(cond, "warning")) {
[16:13:18.061]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:18.061]                       if (muffled) 
[16:13:18.061]                         invokeRestart("muffleWarning")
[16:13:18.061]                     }
[16:13:18.061]                     else if (inherits(cond, "condition")) {
[16:13:18.061]                       if (!is.null(pattern)) {
[16:13:18.061]                         computeRestarts <- base::computeRestarts
[16:13:18.061]                         grepl <- base::grepl
[16:13:18.061]                         restarts <- computeRestarts(cond)
[16:13:18.061]                         for (restart in restarts) {
[16:13:18.061]                           name <- restart$name
[16:13:18.061]                           if (is.null(name)) 
[16:13:18.061]                             next
[16:13:18.061]                           if (!grepl(pattern, name)) 
[16:13:18.061]                             next
[16:13:18.061]                           invokeRestart(restart)
[16:13:18.061]                           muffled <- TRUE
[16:13:18.061]                           break
[16:13:18.061]                         }
[16:13:18.061]                       }
[16:13:18.061]                     }
[16:13:18.061]                     invisible(muffled)
[16:13:18.061]                   }
[16:13:18.061]                   muffleCondition(cond)
[16:13:18.061]                 })
[16:13:18.061]             }))
[16:13:18.061]             future::FutureResult(value = ...future.value$value, 
[16:13:18.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.061]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.061]                     ...future.globalenv.names))
[16:13:18.061]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.061]         }, condition = base::local({
[16:13:18.061]             c <- base::c
[16:13:18.061]             inherits <- base::inherits
[16:13:18.061]             invokeRestart <- base::invokeRestart
[16:13:18.061]             length <- base::length
[16:13:18.061]             list <- base::list
[16:13:18.061]             seq.int <- base::seq.int
[16:13:18.061]             signalCondition <- base::signalCondition
[16:13:18.061]             sys.calls <- base::sys.calls
[16:13:18.061]             `[[` <- base::`[[`
[16:13:18.061]             `+` <- base::`+`
[16:13:18.061]             `<<-` <- base::`<<-`
[16:13:18.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.061]                   3L)]
[16:13:18.061]             }
[16:13:18.061]             function(cond) {
[16:13:18.061]                 is_error <- inherits(cond, "error")
[16:13:18.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.061]                   NULL)
[16:13:18.061]                 if (is_error) {
[16:13:18.061]                   sessionInformation <- function() {
[16:13:18.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.061]                       search = base::search(), system = base::Sys.info())
[16:13:18.061]                   }
[16:13:18.061]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.061]                     cond$call), session = sessionInformation(), 
[16:13:18.061]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.061]                   signalCondition(cond)
[16:13:18.061]                 }
[16:13:18.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.061]                 "immediateCondition"))) {
[16:13:18.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.061]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.061]                   if (TRUE && !signal) {
[16:13:18.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.061]                     {
[16:13:18.061]                       inherits <- base::inherits
[16:13:18.061]                       invokeRestart <- base::invokeRestart
[16:13:18.061]                       is.null <- base::is.null
[16:13:18.061]                       muffled <- FALSE
[16:13:18.061]                       if (inherits(cond, "message")) {
[16:13:18.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.061]                         if (muffled) 
[16:13:18.061]                           invokeRestart("muffleMessage")
[16:13:18.061]                       }
[16:13:18.061]                       else if (inherits(cond, "warning")) {
[16:13:18.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.061]                         if (muffled) 
[16:13:18.061]                           invokeRestart("muffleWarning")
[16:13:18.061]                       }
[16:13:18.061]                       else if (inherits(cond, "condition")) {
[16:13:18.061]                         if (!is.null(pattern)) {
[16:13:18.061]                           computeRestarts <- base::computeRestarts
[16:13:18.061]                           grepl <- base::grepl
[16:13:18.061]                           restarts <- computeRestarts(cond)
[16:13:18.061]                           for (restart in restarts) {
[16:13:18.061]                             name <- restart$name
[16:13:18.061]                             if (is.null(name)) 
[16:13:18.061]                               next
[16:13:18.061]                             if (!grepl(pattern, name)) 
[16:13:18.061]                               next
[16:13:18.061]                             invokeRestart(restart)
[16:13:18.061]                             muffled <- TRUE
[16:13:18.061]                             break
[16:13:18.061]                           }
[16:13:18.061]                         }
[16:13:18.061]                       }
[16:13:18.061]                       invisible(muffled)
[16:13:18.061]                     }
[16:13:18.061]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.061]                   }
[16:13:18.061]                 }
[16:13:18.061]                 else {
[16:13:18.061]                   if (TRUE) {
[16:13:18.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.061]                     {
[16:13:18.061]                       inherits <- base::inherits
[16:13:18.061]                       invokeRestart <- base::invokeRestart
[16:13:18.061]                       is.null <- base::is.null
[16:13:18.061]                       muffled <- FALSE
[16:13:18.061]                       if (inherits(cond, "message")) {
[16:13:18.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.061]                         if (muffled) 
[16:13:18.061]                           invokeRestart("muffleMessage")
[16:13:18.061]                       }
[16:13:18.061]                       else if (inherits(cond, "warning")) {
[16:13:18.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.061]                         if (muffled) 
[16:13:18.061]                           invokeRestart("muffleWarning")
[16:13:18.061]                       }
[16:13:18.061]                       else if (inherits(cond, "condition")) {
[16:13:18.061]                         if (!is.null(pattern)) {
[16:13:18.061]                           computeRestarts <- base::computeRestarts
[16:13:18.061]                           grepl <- base::grepl
[16:13:18.061]                           restarts <- computeRestarts(cond)
[16:13:18.061]                           for (restart in restarts) {
[16:13:18.061]                             name <- restart$name
[16:13:18.061]                             if (is.null(name)) 
[16:13:18.061]                               next
[16:13:18.061]                             if (!grepl(pattern, name)) 
[16:13:18.061]                               next
[16:13:18.061]                             invokeRestart(restart)
[16:13:18.061]                             muffled <- TRUE
[16:13:18.061]                             break
[16:13:18.061]                           }
[16:13:18.061]                         }
[16:13:18.061]                       }
[16:13:18.061]                       invisible(muffled)
[16:13:18.061]                     }
[16:13:18.061]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.061]                   }
[16:13:18.061]                 }
[16:13:18.061]             }
[16:13:18.061]         }))
[16:13:18.061]     }, error = function(ex) {
[16:13:18.061]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.061]                 ...future.rng), started = ...future.startTime, 
[16:13:18.061]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.061]             version = "1.8"), class = "FutureResult")
[16:13:18.061]     }, finally = {
[16:13:18.061]         if (!identical(...future.workdir, getwd())) 
[16:13:18.061]             setwd(...future.workdir)
[16:13:18.061]         {
[16:13:18.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.061]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.061]             }
[16:13:18.061]             base::options(...future.oldOptions)
[16:13:18.061]             if (.Platform$OS.type == "windows") {
[16:13:18.061]                 old_names <- names(...future.oldEnvVars)
[16:13:18.061]                 envs <- base::Sys.getenv()
[16:13:18.061]                 names <- names(envs)
[16:13:18.061]                 common <- intersect(names, old_names)
[16:13:18.061]                 added <- setdiff(names, old_names)
[16:13:18.061]                 removed <- setdiff(old_names, names)
[16:13:18.061]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.061]                   envs[common]]
[16:13:18.061]                 NAMES <- toupper(changed)
[16:13:18.061]                 args <- list()
[16:13:18.061]                 for (kk in seq_along(NAMES)) {
[16:13:18.061]                   name <- changed[[kk]]
[16:13:18.061]                   NAME <- NAMES[[kk]]
[16:13:18.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.061]                     next
[16:13:18.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.061]                 }
[16:13:18.061]                 NAMES <- toupper(added)
[16:13:18.061]                 for (kk in seq_along(NAMES)) {
[16:13:18.061]                   name <- added[[kk]]
[16:13:18.061]                   NAME <- NAMES[[kk]]
[16:13:18.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.061]                     next
[16:13:18.061]                   args[[name]] <- ""
[16:13:18.061]                 }
[16:13:18.061]                 NAMES <- toupper(removed)
[16:13:18.061]                 for (kk in seq_along(NAMES)) {
[16:13:18.061]                   name <- removed[[kk]]
[16:13:18.061]                   NAME <- NAMES[[kk]]
[16:13:18.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.061]                     next
[16:13:18.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.061]                 }
[16:13:18.061]                 if (length(args) > 0) 
[16:13:18.061]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.061]             }
[16:13:18.061]             else {
[16:13:18.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.061]             }
[16:13:18.061]             {
[16:13:18.061]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.061]                   0L) {
[16:13:18.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.061]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.061]                   base::options(opts)
[16:13:18.061]                 }
[16:13:18.061]                 {
[16:13:18.061]                   {
[16:13:18.061]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:18.061]                     NULL
[16:13:18.061]                   }
[16:13:18.061]                   options(future.plan = NULL)
[16:13:18.061]                   if (is.na(NA_character_)) 
[16:13:18.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.061]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:18.061]                     envir = parent.frame()) 
[16:13:18.061]                   {
[16:13:18.061]                     default_workers <- missing(workers)
[16:13:18.061]                     if (is.function(workers)) 
[16:13:18.061]                       workers <- workers()
[16:13:18.061]                     workers <- structure(as.integer(workers), 
[16:13:18.061]                       class = class(workers))
[16:13:18.061]                     stop_if_not(is.finite(workers), workers >= 
[16:13:18.061]                       1L)
[16:13:18.061]                     if ((workers == 1L && !inherits(workers, 
[16:13:18.061]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:18.061]                       if (default_workers) 
[16:13:18.061]                         supportsMulticore(warn = TRUE)
[16:13:18.061]                       return(sequential(..., envir = envir))
[16:13:18.061]                     }
[16:13:18.061]                     oopts <- options(mc.cores = workers)
[16:13:18.061]                     on.exit(options(oopts))
[16:13:18.061]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:18.061]                       envir = envir)
[16:13:18.061]                     if (!future$lazy) 
[16:13:18.061]                       future <- run(future)
[16:13:18.061]                     invisible(future)
[16:13:18.061]                   }, b = function (..., workers = availableCores(), 
[16:13:18.061]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.061]                     envir = parent.frame()) 
[16:13:18.061]                   {
[16:13:18.061]                     if (is.function(workers)) 
[16:13:18.061]                       workers <- workers()
[16:13:18.061]                     workers <- structure(as.integer(workers), 
[16:13:18.061]                       class = class(workers))
[16:13:18.061]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.061]                       workers >= 1)
[16:13:18.061]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.061]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.061]                     }
[16:13:18.061]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.061]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.061]                       envir = envir)
[16:13:18.061]                     if (!future$lazy) 
[16:13:18.061]                       future <- run(future)
[16:13:18.061]                     invisible(future)
[16:13:18.061]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.061]                 }
[16:13:18.061]             }
[16:13:18.061]         }
[16:13:18.061]     })
[16:13:18.061]     if (TRUE) {
[16:13:18.061]         base::sink(type = "output", split = FALSE)
[16:13:18.061]         if (TRUE) {
[16:13:18.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.061]         }
[16:13:18.061]         else {
[16:13:18.061]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.061]         }
[16:13:18.061]         base::close(...future.stdout)
[16:13:18.061]         ...future.stdout <- NULL
[16:13:18.061]     }
[16:13:18.061]     ...future.result$conditions <- ...future.conditions
[16:13:18.061]     ...future.result$finished <- base::Sys.time()
[16:13:18.061]     ...future.result
[16:13:18.061] }
[16:13:18.064] assign_globals() ...
[16:13:18.064] List of 2
[16:13:18.064]  $ nested   :List of 2
[16:13:18.064]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[16:13:18.064]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[16:13:18.064]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:18.064]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.064]     envir = parent.frame())  
[16:13:18.064]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:13:18.064]   .. ..- attr(*, "init")= logi TRUE
[16:13:18.064]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:13:18.064]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:18.064]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:18.064]  $ strategy2: chr "multisession"
[16:13:18.064]  - attr(*, "where")=List of 2
[16:13:18.064]   ..$ nested   :<environment: R_EmptyEnv> 
[16:13:18.064]   ..$ strategy2:<environment: R_EmptyEnv> 
[16:13:18.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:18.064]  - attr(*, "resolved")= logi FALSE
[16:13:18.064]  - attr(*, "total_size")= num 92816
[16:13:18.064]  - attr(*, "already-done")= logi TRUE
[16:13:18.070] - copied ‘nested’ to environment
[16:13:18.070] - copied ‘strategy2’ to environment
[16:13:18.070] assign_globals() ... done
[16:13:18.070] requestCore(): workers = 2
[16:13:18.073] MulticoreFuture started
[16:13:18.073] - Launch lazy future ... done
[16:13:18.073] run() for ‘MulticoreFuture’ ... done
[16:13:18.074] plan(): Setting new future strategy stack:
[16:13:18.074] List of future strategies:
[16:13:18.074] 1. multisession:
[16:13:18.074]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.074]    - tweaked: FALSE
[16:13:18.074]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.080] plan(): nbrOfWorkers() = 1
[16:13:18.120] plan(): Setting new future strategy stack:
[16:13:18.120] List of future strategies:
[16:13:18.120] 1. multicore:
[16:13:18.120]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.120]    - tweaked: FALSE
[16:13:18.120]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.120] 2. multisession:
[16:13:18.120]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.120]    - tweaked: FALSE
[16:13:18.120]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.124] plan(): nbrOfWorkers() = 2
[16:13:18.126] signalConditions() ...
[16:13:18.126]  - include = ‘immediateCondition’
[16:13:18.126]  - exclude = 
[16:13:18.126]  - resignal = FALSE
[16:13:18.126]  - Number of conditions: 54
[16:13:18.126] signalConditions() ... done
[16:13:18.127] signalConditions() ...
[16:13:18.127]  - include = ‘immediateCondition’
[16:13:18.127]  - exclude = 
[16:13:18.127]  - resignal = FALSE
[16:13:18.127]  - Number of conditions: 54
[16:13:18.127] signalConditions() ... done
[16:13:18.127] Future state: ‘finished’
[16:13:18.127] signalConditions() ...
[16:13:18.128]  - include = ‘condition’
[16:13:18.128]  - exclude = ‘immediateCondition’
[16:13:18.128]  - resignal = TRUE
[16:13:18.128]  - Number of conditions: 54
[16:13:18.128]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.081] getGlobalsAndPackages() ...
[16:13:18.128]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.082] Searching for globals...
[16:13:18.128]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.089] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[16:13:18.129]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.089] Searching for globals ... DONE
[16:13:18.129]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.090] Resolving globals: FALSE
[16:13:18.129]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.091] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[16:13:18.129]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.091] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[16:13:18.129]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.092] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[16:13:18.129]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.092] 
[16:13:18.130]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.092] getGlobalsAndPackages() ... DONE
[16:13:18.130]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.093] run() for ‘Future’ ...
[16:13:18.130]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.093] - state: ‘created’
[16:13:18.130]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.130]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.097] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:18.130]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:18.130]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.097]   - Field: ‘label’
[16:13:18.131]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.097]   - Field: ‘local’
[16:13:18.131]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.098]   - Field: ‘owner’
[16:13:18.131]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.098]   - Field: ‘envir’
[16:13:18.131]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.098]   - Field: ‘packages’
[16:13:18.131]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.098]   - Field: ‘gc’
[16:13:18.131]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.098]   - Field: ‘conditions’
[16:13:18.132]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.098]   - Field: ‘expr’
[16:13:18.132]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘uuid’
[16:13:18.132]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘seed’
[16:13:18.132]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘version’
[16:13:18.132]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘result’
[16:13:18.132]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘asynchronous’
[16:13:18.133]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘calls’
[16:13:18.133]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.099]   - Field: ‘globals’
[16:13:18.133]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.100]   - Field: ‘stdout’
[16:13:18.133]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.100]   - Field: ‘earlySignal’
[16:13:18.133]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.100]   - Field: ‘lazy’
[16:13:18.133]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.100]   - Field: ‘state’
[16:13:18.134]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:18.134]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.100] - Launch lazy future ...
[16:13:18.134]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.101] Packages needed by the future expression (n = 0): <none>
[16:13:18.134]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.101] Packages needed by future strategies (n = 0): <none>
[16:13:18.134]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.102] {
[16:13:18.102]     {
[16:13:18.102]         {
[16:13:18.102]             ...future.startTime <- base::Sys.time()
[16:13:18.102]             {
[16:13:18.102]                 {
[16:13:18.102]                   {
[16:13:18.102]                     base::local({
[16:13:18.102]                       has_future <- base::requireNamespace("future", 
[16:13:18.102]                         quietly = TRUE)
[16:13:18.102]                       if (has_future) {
[16:13:18.102]                         ns <- base::getNamespace("future")
[16:13:18.102]                         version <- ns[[".package"]][["version"]]
[16:13:18.102]                         if (is.null(version)) 
[16:13:18.102]                           version <- utils::packageVersion("future")
[16:13:18.102]                       }
[16:13:18.102]                       else {
[16:13:18.102]                         version <- NULL
[16:13:18.102]                       }
[16:13:18.102]                       if (!has_future || version < "1.8.0") {
[16:13:18.102]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.102]                           "", base::R.version$version.string), 
[16:13:18.102]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:18.102]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:18.102]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.102]                             "release", "version")], collapse = " "), 
[16:13:18.102]                           hostname = base::Sys.info()[["nodename"]])
[16:13:18.102]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.102]                           info)
[16:13:18.102]                         info <- base::paste(info, collapse = "; ")
[16:13:18.102]                         if (!has_future) {
[16:13:18.102]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.102]                             info)
[16:13:18.102]                         }
[16:13:18.102]                         else {
[16:13:18.102]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.102]                             info, version)
[16:13:18.102]                         }
[16:13:18.102]                         base::stop(msg)
[16:13:18.102]                       }
[16:13:18.102]                     })
[16:13:18.102]                   }
[16:13:18.102]                   options(future.plan = NULL)
[16:13:18.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:18.102]                 }
[16:13:18.102]                 ...future.workdir <- getwd()
[16:13:18.102]             }
[16:13:18.102]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.102]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.102]         }
[16:13:18.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.102]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.102]             base::names(...future.oldOptions))
[16:13:18.102]     }
[16:13:18.102]     if (FALSE) {
[16:13:18.102]     }
[16:13:18.102]     else {
[16:13:18.102]         if (TRUE) {
[16:13:18.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.102]                 open = "w")
[16:13:18.102]         }
[16:13:18.102]         else {
[16:13:18.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.102]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.102]         }
[16:13:18.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.102]             base::sink(type = "output", split = FALSE)
[16:13:18.102]             base::close(...future.stdout)
[16:13:18.102]         }, add = TRUE)
[16:13:18.102]     }
[16:13:18.102]     ...future.frame <- base::sys.nframe()
[16:13:18.102]     ...future.conditions <- base::list()
[16:13:18.102]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.102]     if (FALSE) {
[16:13:18.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.102]     }
[16:13:18.102]     ...future.result <- base::tryCatch({
[16:13:18.102]         base::withCallingHandlers({
[16:13:18.102]             ...future.value <- base::withVisible(base::local({
[16:13:18.102]                 b <- 2L
[16:13:18.102]                 plan_b <- future::plan("list")
[16:13:18.102]                 nested_b <- nested_a[-1]
[16:13:18.102]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:18.102]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[16:13:18.102]                   "sequential"))
[16:13:18.102]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:18.102]                   b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:18.102]             }))
[16:13:18.102]             future::FutureResult(value = ...future.value$value, 
[16:13:18.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.102]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.102]                     ...future.globalenv.names))
[16:13:18.102]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.102]         }, condition = base::local({
[16:13:18.102]             c <- base::c
[16:13:18.102]             inherits <- base::inherits
[16:13:18.102]             invokeRestart <- base::invokeRestart
[16:13:18.102]             length <- base::length
[16:13:18.102]             list <- base::list
[16:13:18.102]             seq.int <- base::seq.int
[16:13:18.102]             signalCondition <- base::signalCondition
[16:13:18.102]             sys.calls <- base::sys.calls
[16:13:18.102]             `[[` <- base::`[[`
[16:13:18.102]             `+` <- base::`+`
[16:13:18.102]             `<<-` <- base::`<<-`
[16:13:18.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.102]                   3L)]
[16:13:18.102]             }
[16:13:18.102]             function(cond) {
[16:13:18.102]                 is_error <- inherits(cond, "error")
[16:13:18.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.102]                   NULL)
[16:13:18.102]                 if (is_error) {
[16:13:18.102]                   sessionInformation <- function() {
[16:13:18.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.102]                       search = base::search(), system = base::Sys.info())
[16:13:18.102]                   }
[16:13:18.102]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.102]                     cond$call), session = sessionInformation(), 
[16:13:18.102]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.102]                   signalCondition(cond)
[16:13:18.102]                 }
[16:13:18.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.102]                 "immediateCondition"))) {
[16:13:18.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.102]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.102]                   if (TRUE && !signal) {
[16:13:18.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.102]                     {
[16:13:18.102]                       inherits <- base::inherits
[16:13:18.102]                       invokeRestart <- base::invokeRestart
[16:13:18.102]                       is.null <- base::is.null
[16:13:18.102]                       muffled <- FALSE
[16:13:18.102]                       if (inherits(cond, "message")) {
[16:13:18.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.102]                         if (muffled) 
[16:13:18.102]                           invokeRestart("muffleMessage")
[16:13:18.102]                       }
[16:13:18.102]                       else if (inherits(cond, "warning")) {
[16:13:18.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.102]                         if (muffled) 
[16:13:18.102]                           invokeRestart("muffleWarning")
[16:13:18.102]                       }
[16:13:18.102]                       else if (inherits(cond, "condition")) {
[16:13:18.102]                         if (!is.null(pattern)) {
[16:13:18.102]                           computeRestarts <- base::computeRestarts
[16:13:18.102]                           grepl <- base::grepl
[16:13:18.102]                           restarts <- computeRestarts(cond)
[16:13:18.102]                           for (restart in restarts) {
[16:13:18.102]                             name <- restart$name
[16:13:18.102]                             if (is.null(name)) 
[16:13:18.102]                               next
[16:13:18.102]                             if (!grepl(pattern, name)) 
[16:13:18.102]                               next
[16:13:18.102]                             invokeRestart(restart)
[16:13:18.102]                             muffled <- TRUE
[16:13:18.102]                             break
[16:13:18.102]                           }
[16:13:18.102]                         }
[16:13:18.102]                       }
[16:13:18.102]                       invisible(muffled)
[16:13:18.102]                     }
[16:13:18.102]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.102]                   }
[16:13:18.102]                 }
[16:13:18.102]                 else {
[16:13:18.102]                   if (TRUE) {
[16:13:18.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.102]                     {
[16:13:18.102]                       inherits <- base::inherits
[16:13:18.102]                       invokeRestart <- base::invokeRestart
[16:13:18.102]                       is.null <- base::is.null
[16:13:18.102]                       muffled <- FALSE
[16:13:18.102]                       if (inherits(cond, "message")) {
[16:13:18.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.102]                         if (muffled) 
[16:13:18.102]                           invokeRestart("muffleMessage")
[16:13:18.102]                       }
[16:13:18.102]                       else if (inherits(cond, "warning")) {
[16:13:18.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.102]                         if (muffled) 
[16:13:18.102]                           invokeRestart("muffleWarning")
[16:13:18.102]                       }
[16:13:18.102]                       else if (inherits(cond, "condition")) {
[16:13:18.102]                         if (!is.null(pattern)) {
[16:13:18.102]                           computeRestarts <- base::computeRestarts
[16:13:18.102]                           grepl <- base::grepl
[16:13:18.102]                           restarts <- computeRestarts(cond)
[16:13:18.102]                           for (restart in restarts) {
[16:13:18.102]                             name <- restart$name
[16:13:18.102]                             if (is.null(name)) 
[16:13:18.102]                               next
[16:13:18.102]                             if (!grepl(pattern, name)) 
[16:13:18.102]                               next
[16:13:18.102]                             invokeRestart(restart)
[16:13:18.102]                             muffled <- TRUE
[16:13:18.102]                             break
[16:13:18.102]                           }
[16:13:18.102]                         }
[16:13:18.102]                       }
[16:13:18.102]                       invisible(muffled)
[16:13:18.102]                     }
[16:13:18.102]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.102]                   }
[16:13:18.102]                 }
[16:13:18.102]             }
[16:13:18.102]         }))
[16:13:18.102]     }, error = function(ex) {
[16:13:18.102]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.102]                 ...future.rng), started = ...future.startTime, 
[16:13:18.102]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.102]             version = "1.8"), class = "FutureResult")
[16:13:18.102]     }, finally = {
[16:13:18.102]         if (!identical(...future.workdir, getwd())) 
[16:13:18.102]             setwd(...future.workdir)
[16:13:18.102]         {
[16:13:18.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.102]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.102]             }
[16:13:18.102]             base::options(...future.oldOptions)
[16:13:18.102]             if (.Platform$OS.type == "windows") {
[16:13:18.102]                 old_names <- names(...future.oldEnvVars)
[16:13:18.102]                 envs <- base::Sys.getenv()
[16:13:18.102]                 names <- names(envs)
[16:13:18.102]                 common <- intersect(names, old_names)
[16:13:18.102]                 added <- setdiff(names, old_names)
[16:13:18.102]                 removed <- setdiff(old_names, names)
[16:13:18.102]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.102]                   envs[common]]
[16:13:18.102]                 NAMES <- toupper(changed)
[16:13:18.102]                 args <- list()
[16:13:18.102]                 for (kk in seq_along(NAMES)) {
[16:13:18.102]                   name <- changed[[kk]]
[16:13:18.102]                   NAME <- NAMES[[kk]]
[16:13:18.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.102]                     next
[16:13:18.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.102]                 }
[16:13:18.102]                 NAMES <- toupper(added)
[16:13:18.102]                 for (kk in seq_along(NAMES)) {
[16:13:18.102]                   name <- added[[kk]]
[16:13:18.102]                   NAME <- NAMES[[kk]]
[16:13:18.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.102]                     next
[16:13:18.102]                   args[[name]] <- ""
[16:13:18.102]                 }
[16:13:18.102]                 NAMES <- toupper(removed)
[16:13:18.102]                 for (kk in seq_along(NAMES)) {
[16:13:18.102]                   name <- removed[[kk]]
[16:13:18.102]                   NAME <- NAMES[[kk]]
[16:13:18.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.102]                     next
[16:13:18.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.102]                 }
[16:13:18.102]                 if (length(args) > 0) 
[16:13:18.102]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.102]             }
[16:13:18.102]             else {
[16:13:18.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.102]             }
[16:13:18.102]             {
[16:13:18.102]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.102]                   0L) {
[16:13:18.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.102]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.102]                   base::options(opts)
[16:13:18.102]                 }
[16:13:18.102]                 {
[16:13:18.102]                   {
[16:13:18.102]                     NULL
[16:13:18.102]                     RNGkind("Mersenne-Twister")
[16:13:18.102]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:18.102]                       inherits = FALSE)
[16:13:18.102]                   }
[16:13:18.102]                   options(future.plan = NULL)
[16:13:18.102]                   if (is.na(NA_character_)) 
[16:13:18.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.102]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:18.102]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.102]                     envir = parent.frame()) 
[16:13:18.102]                   {
[16:13:18.102]                     if (is.function(workers)) 
[16:13:18.102]                       workers <- workers()
[16:13:18.102]                     workers <- structure(as.integer(workers), 
[16:13:18.102]                       class = class(workers))
[16:13:18.102]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.102]                       workers >= 1)
[16:13:18.102]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.102]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.102]                     }
[16:13:18.102]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.102]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.102]                       envir = envir)
[16:13:18.102]                     if (!future$lazy) 
[16:13:18.102]                       future <- run(future)
[16:13:18.102]                     invisible(future)
[16:13:18.102]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.102]                 }
[16:13:18.102]             }
[16:13:18.102]         }
[16:13:18.102]     })
[16:13:18.102]     if (TRUE) {
[16:13:18.102]         base::sink(type = "output", split = FALSE)
[16:13:18.102]         if (TRUE) {
[16:13:18.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.102]         }
[16:13:18.102]         else {
[16:13:18.102]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.102]         }
[16:13:18.102]         base::close(...future.stdout)
[16:13:18.102]         ...future.stdout <- NULL
[16:13:18.102]     }
[16:13:18.102]     ...future.result$conditions <- ...future.conditions
[16:13:18.102]     ...future.result$finished <- base::Sys.time()
[16:13:18.102]     ...future.result
[16:13:18.102] }
[16:13:18.134]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.104] assign_globals() ...
[16:13:18.134]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.104] List of 3
[16:13:18.104]  $ nested_a:List of 1
[16:13:18.104]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.104]     envir = parent.frame())  
[16:13:18.104]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:13:18.104]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:13:18.104]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:18.104]  $ a       : int 1
[16:13:18.104]  $ plan_a  :List of 1
[16:13:18.104]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.104]     envir = parent.frame())  
[16:13:18.104]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[16:13:18.104]   .. ..- attr(*, "untweakable")= chr "persistent"
[16:13:18.104]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[16:13:18.104]  - attr(*, "where")=List of 3
[16:13:18.104]   ..$ nested_a:<environment: R_EmptyEnv> 
[16:13:18.104]   ..$ a       :<environment: R_EmptyEnv> 
[16:13:18.104]   ..$ plan_a  :<environment: R_EmptyEnv> 
[16:13:18.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:18.104]  - attr(*, "resolved")= logi FALSE
[16:13:18.104]  - attr(*, "total_size")= num 89928
[16:13:18.104]  - attr(*, "already-done")= logi TRUE
[16:13:18.135]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.112] - copied ‘nested_a’ to environment
[16:13:18.135]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.113] - copied ‘a’ to environment
[16:13:18.135]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.113] - copied ‘plan_a’ to environment
[16:13:18.135]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.113] assign_globals() ... done
[16:13:18.135]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.113] plan(): Setting new future strategy stack:
[16:13:18.135]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.113] List of future strategies:
[16:13:18.113] 1. sequential:
[16:13:18.113]    - args: function (..., envir = parent.frame())
[16:13:18.113]    - tweaked: FALSE
[16:13:18.113]    - call: NULL
[16:13:18.136]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.114] plan(): nbrOfWorkers() = 1
[16:13:18.136]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.115] plan(): Setting new future strategy stack:
[16:13:18.136]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.115] List of future strategies:
[16:13:18.115] 1. multisession:
[16:13:18.115]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.115]    - tweaked: FALSE
[16:13:18.115]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.136]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.119] plan(): nbrOfWorkers() = 1
[16:13:18.136]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.119] SequentialFuture started (and completed)
[16:13:18.136]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.119] - Launch lazy future ... done
[16:13:18.137]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.120] run() for ‘SequentialFuture’ ... done
[16:13:18.137] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:18.143] getGlobalsAndPackages() ...
[16:13:18.144] Searching for globals...
[16:13:18.145] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:18.145] Searching for globals ... DONE
[16:13:18.146] Resolving globals: FALSE
[16:13:18.146] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:18.147] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:18.147] - globals: [1] ‘data’
[16:13:18.147] - packages: [1] ‘future’
[16:13:18.147] getGlobalsAndPackages() ... DONE
[16:13:18.148] run() for ‘Future’ ...
[16:13:18.148] - state: ‘created’
[16:13:18.148] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.152] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:18.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:13:18.152]   - Field: ‘label’
[16:13:18.152]   - Field: ‘local’
[16:13:18.152]   - Field: ‘owner’
[16:13:18.152]   - Field: ‘envir’
[16:13:18.153]   - Field: ‘workers’
[16:13:18.153]   - Field: ‘packages’
[16:13:18.153]   - Field: ‘gc’
[16:13:18.153]   - Field: ‘job’
[16:13:18.153]   - Field: ‘conditions’
[16:13:18.153]   - Field: ‘expr’
[16:13:18.153]   - Field: ‘uuid’
[16:13:18.153]   - Field: ‘seed’
[16:13:18.153]   - Field: ‘version’
[16:13:18.153]   - Field: ‘result’
[16:13:18.154]   - Field: ‘asynchronous’
[16:13:18.154]   - Field: ‘calls’
[16:13:18.154]   - Field: ‘globals’
[16:13:18.154]   - Field: ‘stdout’
[16:13:18.154]   - Field: ‘earlySignal’
[16:13:18.154]   - Field: ‘lazy’
[16:13:18.154]   - Field: ‘state’
[16:13:18.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:13:18.154] - Launch lazy future ...
[16:13:18.155] Packages needed by the future expression (n = 1): ‘future’
[16:13:18.155] Packages needed by future strategies (n = 1): ‘future’
[16:13:18.156] {
[16:13:18.156]     {
[16:13:18.156]         {
[16:13:18.156]             ...future.startTime <- base::Sys.time()
[16:13:18.156]             {
[16:13:18.156]                 {
[16:13:18.156]                   {
[16:13:18.156]                     {
[16:13:18.156]                       {
[16:13:18.156]                         base::local({
[16:13:18.156]                           has_future <- base::requireNamespace("future", 
[16:13:18.156]                             quietly = TRUE)
[16:13:18.156]                           if (has_future) {
[16:13:18.156]                             ns <- base::getNamespace("future")
[16:13:18.156]                             version <- ns[[".package"]][["version"]]
[16:13:18.156]                             if (is.null(version)) 
[16:13:18.156]                               version <- utils::packageVersion("future")
[16:13:18.156]                           }
[16:13:18.156]                           else {
[16:13:18.156]                             version <- NULL
[16:13:18.156]                           }
[16:13:18.156]                           if (!has_future || version < "1.8.0") {
[16:13:18.156]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.156]                               "", base::R.version$version.string), 
[16:13:18.156]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:18.156]                                 base::R.version$platform, 8 * 
[16:13:18.156]                                   base::.Machine$sizeof.pointer), 
[16:13:18.156]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.156]                                 "release", "version")], collapse = " "), 
[16:13:18.156]                               hostname = base::Sys.info()[["nodename"]])
[16:13:18.156]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.156]                               info)
[16:13:18.156]                             info <- base::paste(info, collapse = "; ")
[16:13:18.156]                             if (!has_future) {
[16:13:18.156]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.156]                                 info)
[16:13:18.156]                             }
[16:13:18.156]                             else {
[16:13:18.156]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.156]                                 info, version)
[16:13:18.156]                             }
[16:13:18.156]                             base::stop(msg)
[16:13:18.156]                           }
[16:13:18.156]                         })
[16:13:18.156]                       }
[16:13:18.156]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:18.156]                       base::options(mc.cores = 1L)
[16:13:18.156]                     }
[16:13:18.156]                     base::local({
[16:13:18.156]                       for (pkg in "future") {
[16:13:18.156]                         base::loadNamespace(pkg)
[16:13:18.156]                         base::library(pkg, character.only = TRUE)
[16:13:18.156]                       }
[16:13:18.156]                     })
[16:13:18.156]                   }
[16:13:18.156]                   options(future.plan = NULL)
[16:13:18.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.156]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:18.156]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.156]                     envir = parent.frame()) 
[16:13:18.156]                   {
[16:13:18.156]                     if (is.function(workers)) 
[16:13:18.156]                       workers <- workers()
[16:13:18.156]                     workers <- structure(as.integer(workers), 
[16:13:18.156]                       class = class(workers))
[16:13:18.156]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.156]                       workers >= 1)
[16:13:18.156]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.156]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.156]                     }
[16:13:18.156]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.156]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.156]                       envir = envir)
[16:13:18.156]                     if (!future$lazy) 
[16:13:18.156]                       future <- run(future)
[16:13:18.156]                     invisible(future)
[16:13:18.156]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.156]                 }
[16:13:18.156]                 ...future.workdir <- getwd()
[16:13:18.156]             }
[16:13:18.156]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.156]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.156]         }
[16:13:18.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.156]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.156]             base::names(...future.oldOptions))
[16:13:18.156]     }
[16:13:18.156]     if (FALSE) {
[16:13:18.156]     }
[16:13:18.156]     else {
[16:13:18.156]         if (TRUE) {
[16:13:18.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.156]                 open = "w")
[16:13:18.156]         }
[16:13:18.156]         else {
[16:13:18.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.156]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.156]         }
[16:13:18.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.156]             base::sink(type = "output", split = FALSE)
[16:13:18.156]             base::close(...future.stdout)
[16:13:18.156]         }, add = TRUE)
[16:13:18.156]     }
[16:13:18.156]     ...future.frame <- base::sys.nframe()
[16:13:18.156]     ...future.conditions <- base::list()
[16:13:18.156]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.156]     if (FALSE) {
[16:13:18.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.156]     }
[16:13:18.156]     ...future.result <- base::tryCatch({
[16:13:18.156]         base::withCallingHandlers({
[16:13:18.156]             ...future.value <- base::withVisible(base::local({
[16:13:18.156]                 withCallingHandlers({
[16:13:18.156]                   {
[16:13:18.156]                     value(future(subset(data, a == 2)))
[16:13:18.156]                   }
[16:13:18.156]                 }, immediateCondition = function(cond) {
[16:13:18.156]                   save_rds <- function (object, pathname, ...) 
[16:13:18.156]                   {
[16:13:18.156]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:13:18.156]                     if (file_test("-f", pathname_tmp)) {
[16:13:18.156]                       fi_tmp <- file.info(pathname_tmp)
[16:13:18.156]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:13:18.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:18.156]                         fi_tmp[["mtime"]])
[16:13:18.156]                     }
[16:13:18.156]                     tryCatch({
[16:13:18.156]                       saveRDS(object, file = pathname_tmp, ...)
[16:13:18.156]                     }, error = function(ex) {
[16:13:18.156]                       msg <- conditionMessage(ex)
[16:13:18.156]                       fi_tmp <- file.info(pathname_tmp)
[16:13:18.156]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:13:18.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:18.156]                         fi_tmp[["mtime"]], msg)
[16:13:18.156]                       ex$message <- msg
[16:13:18.156]                       stop(ex)
[16:13:18.156]                     })
[16:13:18.156]                     stopifnot(file_test("-f", pathname_tmp))
[16:13:18.156]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:13:18.156]                     if (!res || file_test("-f", pathname_tmp)) {
[16:13:18.156]                       fi_tmp <- file.info(pathname_tmp)
[16:13:18.156]                       fi <- file.info(pathname)
[16:13:18.156]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:13:18.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:13:18.156]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:13:18.156]                         fi[["size"]], fi[["mtime"]])
[16:13:18.156]                       stop(msg)
[16:13:18.156]                     }
[16:13:18.156]                     invisible(pathname)
[16:13:18.156]                   }
[16:13:18.156]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:13:18.156]                     rootPath = tempdir()) 
[16:13:18.156]                   {
[16:13:18.156]                     obj <- list(time = Sys.time(), condition = cond)
[16:13:18.156]                     file <- tempfile(pattern = class(cond)[1], 
[16:13:18.156]                       tmpdir = path, fileext = ".rds")
[16:13:18.156]                     save_rds(obj, file)
[16:13:18.156]                   }
[16:13:18.156]                   saveImmediateCondition(cond, path = "/tmp/RtmpdY1hgU/.future/immediateConditions")
[16:13:18.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.156]                   {
[16:13:18.156]                     inherits <- base::inherits
[16:13:18.156]                     invokeRestart <- base::invokeRestart
[16:13:18.156]                     is.null <- base::is.null
[16:13:18.156]                     muffled <- FALSE
[16:13:18.156]                     if (inherits(cond, "message")) {
[16:13:18.156]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:18.156]                       if (muffled) 
[16:13:18.156]                         invokeRestart("muffleMessage")
[16:13:18.156]                     }
[16:13:18.156]                     else if (inherits(cond, "warning")) {
[16:13:18.156]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:18.156]                       if (muffled) 
[16:13:18.156]                         invokeRestart("muffleWarning")
[16:13:18.156]                     }
[16:13:18.156]                     else if (inherits(cond, "condition")) {
[16:13:18.156]                       if (!is.null(pattern)) {
[16:13:18.156]                         computeRestarts <- base::computeRestarts
[16:13:18.156]                         grepl <- base::grepl
[16:13:18.156]                         restarts <- computeRestarts(cond)
[16:13:18.156]                         for (restart in restarts) {
[16:13:18.156]                           name <- restart$name
[16:13:18.156]                           if (is.null(name)) 
[16:13:18.156]                             next
[16:13:18.156]                           if (!grepl(pattern, name)) 
[16:13:18.156]                             next
[16:13:18.156]                           invokeRestart(restart)
[16:13:18.156]                           muffled <- TRUE
[16:13:18.156]                           break
[16:13:18.156]                         }
[16:13:18.156]                       }
[16:13:18.156]                     }
[16:13:18.156]                     invisible(muffled)
[16:13:18.156]                   }
[16:13:18.156]                   muffleCondition(cond)
[16:13:18.156]                 })
[16:13:18.156]             }))
[16:13:18.156]             future::FutureResult(value = ...future.value$value, 
[16:13:18.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.156]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.156]                     ...future.globalenv.names))
[16:13:18.156]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.156]         }, condition = base::local({
[16:13:18.156]             c <- base::c
[16:13:18.156]             inherits <- base::inherits
[16:13:18.156]             invokeRestart <- base::invokeRestart
[16:13:18.156]             length <- base::length
[16:13:18.156]             list <- base::list
[16:13:18.156]             seq.int <- base::seq.int
[16:13:18.156]             signalCondition <- base::signalCondition
[16:13:18.156]             sys.calls <- base::sys.calls
[16:13:18.156]             `[[` <- base::`[[`
[16:13:18.156]             `+` <- base::`+`
[16:13:18.156]             `<<-` <- base::`<<-`
[16:13:18.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.156]                   3L)]
[16:13:18.156]             }
[16:13:18.156]             function(cond) {
[16:13:18.156]                 is_error <- inherits(cond, "error")
[16:13:18.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.156]                   NULL)
[16:13:18.156]                 if (is_error) {
[16:13:18.156]                   sessionInformation <- function() {
[16:13:18.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.156]                       search = base::search(), system = base::Sys.info())
[16:13:18.156]                   }
[16:13:18.156]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.156]                     cond$call), session = sessionInformation(), 
[16:13:18.156]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.156]                   signalCondition(cond)
[16:13:18.156]                 }
[16:13:18.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.156]                 "immediateCondition"))) {
[16:13:18.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.156]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.156]                   if (TRUE && !signal) {
[16:13:18.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.156]                     {
[16:13:18.156]                       inherits <- base::inherits
[16:13:18.156]                       invokeRestart <- base::invokeRestart
[16:13:18.156]                       is.null <- base::is.null
[16:13:18.156]                       muffled <- FALSE
[16:13:18.156]                       if (inherits(cond, "message")) {
[16:13:18.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.156]                         if (muffled) 
[16:13:18.156]                           invokeRestart("muffleMessage")
[16:13:18.156]                       }
[16:13:18.156]                       else if (inherits(cond, "warning")) {
[16:13:18.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.156]                         if (muffled) 
[16:13:18.156]                           invokeRestart("muffleWarning")
[16:13:18.156]                       }
[16:13:18.156]                       else if (inherits(cond, "condition")) {
[16:13:18.156]                         if (!is.null(pattern)) {
[16:13:18.156]                           computeRestarts <- base::computeRestarts
[16:13:18.156]                           grepl <- base::grepl
[16:13:18.156]                           restarts <- computeRestarts(cond)
[16:13:18.156]                           for (restart in restarts) {
[16:13:18.156]                             name <- restart$name
[16:13:18.156]                             if (is.null(name)) 
[16:13:18.156]                               next
[16:13:18.156]                             if (!grepl(pattern, name)) 
[16:13:18.156]                               next
[16:13:18.156]                             invokeRestart(restart)
[16:13:18.156]                             muffled <- TRUE
[16:13:18.156]                             break
[16:13:18.156]                           }
[16:13:18.156]                         }
[16:13:18.156]                       }
[16:13:18.156]                       invisible(muffled)
[16:13:18.156]                     }
[16:13:18.156]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.156]                   }
[16:13:18.156]                 }
[16:13:18.156]                 else {
[16:13:18.156]                   if (TRUE) {
[16:13:18.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.156]                     {
[16:13:18.156]                       inherits <- base::inherits
[16:13:18.156]                       invokeRestart <- base::invokeRestart
[16:13:18.156]                       is.null <- base::is.null
[16:13:18.156]                       muffled <- FALSE
[16:13:18.156]                       if (inherits(cond, "message")) {
[16:13:18.156]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.156]                         if (muffled) 
[16:13:18.156]                           invokeRestart("muffleMessage")
[16:13:18.156]                       }
[16:13:18.156]                       else if (inherits(cond, "warning")) {
[16:13:18.156]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.156]                         if (muffled) 
[16:13:18.156]                           invokeRestart("muffleWarning")
[16:13:18.156]                       }
[16:13:18.156]                       else if (inherits(cond, "condition")) {
[16:13:18.156]                         if (!is.null(pattern)) {
[16:13:18.156]                           computeRestarts <- base::computeRestarts
[16:13:18.156]                           grepl <- base::grepl
[16:13:18.156]                           restarts <- computeRestarts(cond)
[16:13:18.156]                           for (restart in restarts) {
[16:13:18.156]                             name <- restart$name
[16:13:18.156]                             if (is.null(name)) 
[16:13:18.156]                               next
[16:13:18.156]                             if (!grepl(pattern, name)) 
[16:13:18.156]                               next
[16:13:18.156]                             invokeRestart(restart)
[16:13:18.156]                             muffled <- TRUE
[16:13:18.156]                             break
[16:13:18.156]                           }
[16:13:18.156]                         }
[16:13:18.156]                       }
[16:13:18.156]                       invisible(muffled)
[16:13:18.156]                     }
[16:13:18.156]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.156]                   }
[16:13:18.156]                 }
[16:13:18.156]             }
[16:13:18.156]         }))
[16:13:18.156]     }, error = function(ex) {
[16:13:18.156]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.156]                 ...future.rng), started = ...future.startTime, 
[16:13:18.156]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.156]             version = "1.8"), class = "FutureResult")
[16:13:18.156]     }, finally = {
[16:13:18.156]         if (!identical(...future.workdir, getwd())) 
[16:13:18.156]             setwd(...future.workdir)
[16:13:18.156]         {
[16:13:18.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.156]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.156]             }
[16:13:18.156]             base::options(...future.oldOptions)
[16:13:18.156]             if (.Platform$OS.type == "windows") {
[16:13:18.156]                 old_names <- names(...future.oldEnvVars)
[16:13:18.156]                 envs <- base::Sys.getenv()
[16:13:18.156]                 names <- names(envs)
[16:13:18.156]                 common <- intersect(names, old_names)
[16:13:18.156]                 added <- setdiff(names, old_names)
[16:13:18.156]                 removed <- setdiff(old_names, names)
[16:13:18.156]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.156]                   envs[common]]
[16:13:18.156]                 NAMES <- toupper(changed)
[16:13:18.156]                 args <- list()
[16:13:18.156]                 for (kk in seq_along(NAMES)) {
[16:13:18.156]                   name <- changed[[kk]]
[16:13:18.156]                   NAME <- NAMES[[kk]]
[16:13:18.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.156]                     next
[16:13:18.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.156]                 }
[16:13:18.156]                 NAMES <- toupper(added)
[16:13:18.156]                 for (kk in seq_along(NAMES)) {
[16:13:18.156]                   name <- added[[kk]]
[16:13:18.156]                   NAME <- NAMES[[kk]]
[16:13:18.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.156]                     next
[16:13:18.156]                   args[[name]] <- ""
[16:13:18.156]                 }
[16:13:18.156]                 NAMES <- toupper(removed)
[16:13:18.156]                 for (kk in seq_along(NAMES)) {
[16:13:18.156]                   name <- removed[[kk]]
[16:13:18.156]                   NAME <- NAMES[[kk]]
[16:13:18.156]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.156]                     next
[16:13:18.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.156]                 }
[16:13:18.156]                 if (length(args) > 0) 
[16:13:18.156]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.156]             }
[16:13:18.156]             else {
[16:13:18.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.156]             }
[16:13:18.156]             {
[16:13:18.156]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.156]                   0L) {
[16:13:18.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.156]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.156]                   base::options(opts)
[16:13:18.156]                 }
[16:13:18.156]                 {
[16:13:18.156]                   {
[16:13:18.156]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:18.156]                     NULL
[16:13:18.156]                   }
[16:13:18.156]                   options(future.plan = NULL)
[16:13:18.156]                   if (is.na(NA_character_)) 
[16:13:18.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.156]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:18.156]                     envir = parent.frame()) 
[16:13:18.156]                   {
[16:13:18.156]                     default_workers <- missing(workers)
[16:13:18.156]                     if (is.function(workers)) 
[16:13:18.156]                       workers <- workers()
[16:13:18.156]                     workers <- structure(as.integer(workers), 
[16:13:18.156]                       class = class(workers))
[16:13:18.156]                     stop_if_not(is.finite(workers), workers >= 
[16:13:18.156]                       1L)
[16:13:18.156]                     if ((workers == 1L && !inherits(workers, 
[16:13:18.156]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:18.156]                       if (default_workers) 
[16:13:18.156]                         supportsMulticore(warn = TRUE)
[16:13:18.156]                       return(sequential(..., envir = envir))
[16:13:18.156]                     }
[16:13:18.156]                     oopts <- options(mc.cores = workers)
[16:13:18.156]                     on.exit(options(oopts))
[16:13:18.156]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:18.156]                       envir = envir)
[16:13:18.156]                     if (!future$lazy) 
[16:13:18.156]                       future <- run(future)
[16:13:18.156]                     invisible(future)
[16:13:18.156]                   }, b = function (..., workers = availableCores(), 
[16:13:18.156]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.156]                     envir = parent.frame()) 
[16:13:18.156]                   {
[16:13:18.156]                     if (is.function(workers)) 
[16:13:18.156]                       workers <- workers()
[16:13:18.156]                     workers <- structure(as.integer(workers), 
[16:13:18.156]                       class = class(workers))
[16:13:18.156]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.156]                       workers >= 1)
[16:13:18.156]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.156]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.156]                     }
[16:13:18.156]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.156]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.156]                       envir = envir)
[16:13:18.156]                     if (!future$lazy) 
[16:13:18.156]                       future <- run(future)
[16:13:18.156]                     invisible(future)
[16:13:18.156]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.156]                 }
[16:13:18.156]             }
[16:13:18.156]         }
[16:13:18.156]     })
[16:13:18.156]     if (TRUE) {
[16:13:18.156]         base::sink(type = "output", split = FALSE)
[16:13:18.156]         if (TRUE) {
[16:13:18.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.156]         }
[16:13:18.156]         else {
[16:13:18.156]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.156]         }
[16:13:18.156]         base::close(...future.stdout)
[16:13:18.156]         ...future.stdout <- NULL
[16:13:18.156]     }
[16:13:18.156]     ...future.result$conditions <- ...future.conditions
[16:13:18.156]     ...future.result$finished <- base::Sys.time()
[16:13:18.156]     ...future.result
[16:13:18.156] }
[16:13:18.159] assign_globals() ...
[16:13:18.159] List of 1
[16:13:18.159]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:18.159]   ..$ a: int [1:3] 1 2 3
[16:13:18.159]   ..$ b: int [1:3] 3 2 1
[16:13:18.159]  - attr(*, "where")=List of 1
[16:13:18.159]   ..$ data:<environment: R_EmptyEnv> 
[16:13:18.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:18.159]  - attr(*, "resolved")= logi FALSE
[16:13:18.159]  - attr(*, "total_size")= num 128
[16:13:18.159]  - attr(*, "already-done")= logi TRUE
[16:13:18.162] - copied ‘data’ to environment
[16:13:18.162] assign_globals() ... done
[16:13:18.163] requestCore(): workers = 2
[16:13:18.165] MulticoreFuture started
[16:13:18.165] - Launch lazy future ... done
[16:13:18.165] run() for ‘MulticoreFuture’ ... done
[16:13:18.166] plan(): Setting new future strategy stack:
[16:13:18.166] List of future strategies:
[16:13:18.166] 1. multisession:
[16:13:18.166]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.166]    - tweaked: FALSE
[16:13:18.166]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.172] plan(): nbrOfWorkers() = 1
[16:13:18.207] plan(): Setting new future strategy stack:
[16:13:18.207] List of future strategies:
[16:13:18.207] 1. multicore:
[16:13:18.207]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.207]    - tweaked: FALSE
[16:13:18.207]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.207] 2. multisession:
[16:13:18.207]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.207]    - tweaked: FALSE
[16:13:18.207]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.211] plan(): nbrOfWorkers() = 2
[16:13:18.212] signalConditions() ...
[16:13:18.212]  - include = ‘immediateCondition’
[16:13:18.213]  - exclude = 
[16:13:18.213]  - resignal = FALSE
[16:13:18.213]  - Number of conditions: 52
[16:13:18.213] signalConditions() ... done
[16:13:18.213] signalConditions() ...
[16:13:18.213]  - include = ‘immediateCondition’
[16:13:18.213]  - exclude = 
[16:13:18.213]  - resignal = FALSE
[16:13:18.214]  - Number of conditions: 52
[16:13:18.214] signalConditions() ... done
[16:13:18.214] Future state: ‘finished’
[16:13:18.214] signalConditions() ...
[16:13:18.214]  - include = ‘condition’
[16:13:18.214]  - exclude = ‘immediateCondition’
[16:13:18.214]  - resignal = TRUE
[16:13:18.214]  - Number of conditions: 52
[16:13:18.214]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.173] getGlobalsAndPackages() ...
[16:13:18.215]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.173] Searching for globals...
[16:13:18.215]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.174] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:18.215]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.175] Searching for globals ... DONE
[16:13:18.215]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.175] Resolving globals: FALSE
[16:13:18.215]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.176] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:18.215]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.182] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:18.216]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.182] - globals: [1] ‘data’
[16:13:18.216]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.182] 
[16:13:18.219]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.182] getGlobalsAndPackages() ... DONE
[16:13:18.219]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.183] run() for ‘Future’ ...
[16:13:18.219]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.183] - state: ‘created’
[16:13:18.220]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.220]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.187] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:18.220]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:18.220]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.188]   - Field: ‘label’
[16:13:18.220]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.188]   - Field: ‘local’
[16:13:18.220]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.188]   - Field: ‘owner’
[16:13:18.221]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.188]   - Field: ‘envir’
[16:13:18.221]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.188]   - Field: ‘packages’
[16:13:18.221]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘gc’
[16:13:18.221]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘conditions’
[16:13:18.221]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘expr’
[16:13:18.221]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘uuid’
[16:13:18.221]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘seed’
[16:13:18.222]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘version’
[16:13:18.222]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.189]   - Field: ‘result’
[16:13:18.222]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.190]   - Field: ‘asynchronous’
[16:13:18.222]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.190]   - Field: ‘calls’
[16:13:18.222]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.190]   - Field: ‘globals’
[16:13:18.222]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.190]   - Field: ‘stdout’
[16:13:18.223]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.190]   - Field: ‘earlySignal’
[16:13:18.223]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.190]   - Field: ‘lazy’
[16:13:18.223]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.191]   - Field: ‘state’
[16:13:18.223]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:18.223]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.191] - Launch lazy future ...
[16:13:18.223]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.191] Packages needed by the future expression (n = 0): <none>
[16:13:18.223]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.191] Packages needed by future strategies (n = 0): <none>
[16:13:18.224]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.192] {
[16:13:18.192]     {
[16:13:18.192]         {
[16:13:18.192]             ...future.startTime <- base::Sys.time()
[16:13:18.192]             {
[16:13:18.192]                 {
[16:13:18.192]                   {
[16:13:18.192]                     base::local({
[16:13:18.192]                       has_future <- base::requireNamespace("future", 
[16:13:18.192]                         quietly = TRUE)
[16:13:18.192]                       if (has_future) {
[16:13:18.192]                         ns <- base::getNamespace("future")
[16:13:18.192]                         version <- ns[[".package"]][["version"]]
[16:13:18.192]                         if (is.null(version)) 
[16:13:18.192]                           version <- utils::packageVersion("future")
[16:13:18.192]                       }
[16:13:18.192]                       else {
[16:13:18.192]                         version <- NULL
[16:13:18.192]                       }
[16:13:18.192]                       if (!has_future || version < "1.8.0") {
[16:13:18.192]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.192]                           "", base::R.version$version.string), 
[16:13:18.192]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:18.192]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:18.192]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.192]                             "release", "version")], collapse = " "), 
[16:13:18.192]                           hostname = base::Sys.info()[["nodename"]])
[16:13:18.192]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.192]                           info)
[16:13:18.192]                         info <- base::paste(info, collapse = "; ")
[16:13:18.192]                         if (!has_future) {
[16:13:18.192]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.192]                             info)
[16:13:18.192]                         }
[16:13:18.192]                         else {
[16:13:18.192]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.192]                             info, version)
[16:13:18.192]                         }
[16:13:18.192]                         base::stop(msg)
[16:13:18.192]                       }
[16:13:18.192]                     })
[16:13:18.192]                   }
[16:13:18.192]                   options(future.plan = NULL)
[16:13:18.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:18.192]                 }
[16:13:18.192]                 ...future.workdir <- getwd()
[16:13:18.192]             }
[16:13:18.192]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.192]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.192]         }
[16:13:18.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.192]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.192]             base::names(...future.oldOptions))
[16:13:18.192]     }
[16:13:18.192]     if (FALSE) {
[16:13:18.192]     }
[16:13:18.192]     else {
[16:13:18.192]         if (TRUE) {
[16:13:18.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.192]                 open = "w")
[16:13:18.192]         }
[16:13:18.192]         else {
[16:13:18.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.192]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.192]         }
[16:13:18.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.192]             base::sink(type = "output", split = FALSE)
[16:13:18.192]             base::close(...future.stdout)
[16:13:18.192]         }, add = TRUE)
[16:13:18.192]     }
[16:13:18.192]     ...future.frame <- base::sys.nframe()
[16:13:18.192]     ...future.conditions <- base::list()
[16:13:18.192]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.192]     if (FALSE) {
[16:13:18.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.192]     }
[16:13:18.192]     ...future.result <- base::tryCatch({
[16:13:18.192]         base::withCallingHandlers({
[16:13:18.192]             ...future.value <- base::withVisible(base::local(subset(data, 
[16:13:18.192]                 a == 2)))
[16:13:18.192]             future::FutureResult(value = ...future.value$value, 
[16:13:18.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.192]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.192]                     ...future.globalenv.names))
[16:13:18.192]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.192]         }, condition = base::local({
[16:13:18.192]             c <- base::c
[16:13:18.192]             inherits <- base::inherits
[16:13:18.192]             invokeRestart <- base::invokeRestart
[16:13:18.192]             length <- base::length
[16:13:18.192]             list <- base::list
[16:13:18.192]             seq.int <- base::seq.int
[16:13:18.192]             signalCondition <- base::signalCondition
[16:13:18.192]             sys.calls <- base::sys.calls
[16:13:18.192]             `[[` <- base::`[[`
[16:13:18.192]             `+` <- base::`+`
[16:13:18.192]             `<<-` <- base::`<<-`
[16:13:18.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.192]                   3L)]
[16:13:18.192]             }
[16:13:18.192]             function(cond) {
[16:13:18.192]                 is_error <- inherits(cond, "error")
[16:13:18.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.192]                   NULL)
[16:13:18.192]                 if (is_error) {
[16:13:18.192]                   sessionInformation <- function() {
[16:13:18.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.192]                       search = base::search(), system = base::Sys.info())
[16:13:18.192]                   }
[16:13:18.192]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.192]                     cond$call), session = sessionInformation(), 
[16:13:18.192]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.192]                   signalCondition(cond)
[16:13:18.192]                 }
[16:13:18.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.192]                 "immediateCondition"))) {
[16:13:18.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.192]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.192]                   if (TRUE && !signal) {
[16:13:18.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.192]                     {
[16:13:18.192]                       inherits <- base::inherits
[16:13:18.192]                       invokeRestart <- base::invokeRestart
[16:13:18.192]                       is.null <- base::is.null
[16:13:18.192]                       muffled <- FALSE
[16:13:18.192]                       if (inherits(cond, "message")) {
[16:13:18.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.192]                         if (muffled) 
[16:13:18.192]                           invokeRestart("muffleMessage")
[16:13:18.192]                       }
[16:13:18.192]                       else if (inherits(cond, "warning")) {
[16:13:18.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.192]                         if (muffled) 
[16:13:18.192]                           invokeRestart("muffleWarning")
[16:13:18.192]                       }
[16:13:18.192]                       else if (inherits(cond, "condition")) {
[16:13:18.192]                         if (!is.null(pattern)) {
[16:13:18.192]                           computeRestarts <- base::computeRestarts
[16:13:18.192]                           grepl <- base::grepl
[16:13:18.192]                           restarts <- computeRestarts(cond)
[16:13:18.192]                           for (restart in restarts) {
[16:13:18.192]                             name <- restart$name
[16:13:18.192]                             if (is.null(name)) 
[16:13:18.192]                               next
[16:13:18.192]                             if (!grepl(pattern, name)) 
[16:13:18.192]                               next
[16:13:18.192]                             invokeRestart(restart)
[16:13:18.192]                             muffled <- TRUE
[16:13:18.192]                             break
[16:13:18.192]                           }
[16:13:18.192]                         }
[16:13:18.192]                       }
[16:13:18.192]                       invisible(muffled)
[16:13:18.192]                     }
[16:13:18.192]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.192]                   }
[16:13:18.192]                 }
[16:13:18.192]                 else {
[16:13:18.192]                   if (TRUE) {
[16:13:18.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.192]                     {
[16:13:18.192]                       inherits <- base::inherits
[16:13:18.192]                       invokeRestart <- base::invokeRestart
[16:13:18.192]                       is.null <- base::is.null
[16:13:18.192]                       muffled <- FALSE
[16:13:18.192]                       if (inherits(cond, "message")) {
[16:13:18.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.192]                         if (muffled) 
[16:13:18.192]                           invokeRestart("muffleMessage")
[16:13:18.192]                       }
[16:13:18.192]                       else if (inherits(cond, "warning")) {
[16:13:18.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.192]                         if (muffled) 
[16:13:18.192]                           invokeRestart("muffleWarning")
[16:13:18.192]                       }
[16:13:18.192]                       else if (inherits(cond, "condition")) {
[16:13:18.192]                         if (!is.null(pattern)) {
[16:13:18.192]                           computeRestarts <- base::computeRestarts
[16:13:18.192]                           grepl <- base::grepl
[16:13:18.192]                           restarts <- computeRestarts(cond)
[16:13:18.192]                           for (restart in restarts) {
[16:13:18.192]                             name <- restart$name
[16:13:18.192]                             if (is.null(name)) 
[16:13:18.192]                               next
[16:13:18.192]                             if (!grepl(pattern, name)) 
[16:13:18.192]                               next
[16:13:18.192]                             invokeRestart(restart)
[16:13:18.192]                             muffled <- TRUE
[16:13:18.192]                             break
[16:13:18.192]                           }
[16:13:18.192]                         }
[16:13:18.192]                       }
[16:13:18.192]                       invisible(muffled)
[16:13:18.192]                     }
[16:13:18.192]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.192]                   }
[16:13:18.192]                 }
[16:13:18.192]             }
[16:13:18.192]         }))
[16:13:18.192]     }, error = function(ex) {
[16:13:18.192]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.192]                 ...future.rng), started = ...future.startTime, 
[16:13:18.192]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.192]             version = "1.8"), class = "FutureResult")
[16:13:18.192]     }, finally = {
[16:13:18.192]         if (!identical(...future.workdir, getwd())) 
[16:13:18.192]             setwd(...future.workdir)
[16:13:18.192]         {
[16:13:18.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.192]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.192]             }
[16:13:18.192]             base::options(...future.oldOptions)
[16:13:18.192]             if (.Platform$OS.type == "windows") {
[16:13:18.192]                 old_names <- names(...future.oldEnvVars)
[16:13:18.192]                 envs <- base::Sys.getenv()
[16:13:18.192]                 names <- names(envs)
[16:13:18.192]                 common <- intersect(names, old_names)
[16:13:18.192]                 added <- setdiff(names, old_names)
[16:13:18.192]                 removed <- setdiff(old_names, names)
[16:13:18.192]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.192]                   envs[common]]
[16:13:18.192]                 NAMES <- toupper(changed)
[16:13:18.192]                 args <- list()
[16:13:18.192]                 for (kk in seq_along(NAMES)) {
[16:13:18.192]                   name <- changed[[kk]]
[16:13:18.192]                   NAME <- NAMES[[kk]]
[16:13:18.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.192]                     next
[16:13:18.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.192]                 }
[16:13:18.192]                 NAMES <- toupper(added)
[16:13:18.192]                 for (kk in seq_along(NAMES)) {
[16:13:18.192]                   name <- added[[kk]]
[16:13:18.192]                   NAME <- NAMES[[kk]]
[16:13:18.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.192]                     next
[16:13:18.192]                   args[[name]] <- ""
[16:13:18.192]                 }
[16:13:18.192]                 NAMES <- toupper(removed)
[16:13:18.192]                 for (kk in seq_along(NAMES)) {
[16:13:18.192]                   name <- removed[[kk]]
[16:13:18.192]                   NAME <- NAMES[[kk]]
[16:13:18.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.192]                     next
[16:13:18.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.192]                 }
[16:13:18.192]                 if (length(args) > 0) 
[16:13:18.192]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.192]             }
[16:13:18.192]             else {
[16:13:18.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.192]             }
[16:13:18.192]             {
[16:13:18.192]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.192]                   0L) {
[16:13:18.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.192]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.192]                   base::options(opts)
[16:13:18.192]                 }
[16:13:18.192]                 {
[16:13:18.192]                   {
[16:13:18.192]                     NULL
[16:13:18.192]                     RNGkind("Mersenne-Twister")
[16:13:18.192]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:18.192]                       inherits = FALSE)
[16:13:18.192]                   }
[16:13:18.192]                   options(future.plan = NULL)
[16:13:18.192]                   if (is.na(NA_character_)) 
[16:13:18.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.192]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:18.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.192]                     envir = parent.frame()) 
[16:13:18.192]                   {
[16:13:18.192]                     if (is.function(workers)) 
[16:13:18.192]                       workers <- workers()
[16:13:18.192]                     workers <- structure(as.integer(workers), 
[16:13:18.192]                       class = class(workers))
[16:13:18.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.192]                       workers >= 1)
[16:13:18.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.192]                     }
[16:13:18.192]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.192]                       envir = envir)
[16:13:18.192]                     if (!future$lazy) 
[16:13:18.192]                       future <- run(future)
[16:13:18.192]                     invisible(future)
[16:13:18.192]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.192]                 }
[16:13:18.192]             }
[16:13:18.192]         }
[16:13:18.192]     })
[16:13:18.192]     if (TRUE) {
[16:13:18.192]         base::sink(type = "output", split = FALSE)
[16:13:18.192]         if (TRUE) {
[16:13:18.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.192]         }
[16:13:18.192]         else {
[16:13:18.192]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.192]         }
[16:13:18.192]         base::close(...future.stdout)
[16:13:18.192]         ...future.stdout <- NULL
[16:13:18.192]     }
[16:13:18.192]     ...future.result$conditions <- ...future.conditions
[16:13:18.192]     ...future.result$finished <- base::Sys.time()
[16:13:18.192]     ...future.result
[16:13:18.192] }
[16:13:18.224]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.194] assign_globals() ...
[16:13:18.224]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.194] List of 1
[16:13:18.194]  $ data:'data.frame':	3 obs. of  2 variables:
[16:13:18.194]   ..$ a: int [1:3] 1 2 3
[16:13:18.194]   ..$ b: int [1:3] 3 2 1
[16:13:18.194]  - attr(*, "where")=List of 1
[16:13:18.194]   ..$ data:<environment: R_EmptyEnv> 
[16:13:18.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:18.194]  - attr(*, "resolved")= logi FALSE
[16:13:18.194]  - attr(*, "total_size")= num 128
[16:13:18.194]  - attr(*, "already-done")= logi TRUE
[16:13:18.224]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.199] - copied ‘data’ to environment
[16:13:18.224]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.200] assign_globals() ... done
[16:13:18.224]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.200] plan(): Setting new future strategy stack:
[16:13:18.225]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.200] List of future strategies:
[16:13:18.200] 1. sequential:
[16:13:18.200]    - args: function (..., envir = parent.frame())
[16:13:18.200]    - tweaked: FALSE
[16:13:18.200]    - call: NULL
[16:13:18.225]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.201] plan(): nbrOfWorkers() = 1
[16:13:18.225]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.202] plan(): Setting new future strategy stack:
[16:13:18.225]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.202] List of future strategies:
[16:13:18.202] 1. multisession:
[16:13:18.202]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.202]    - tweaked: FALSE
[16:13:18.202]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.225]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.206] plan(): nbrOfWorkers() = 1
[16:13:18.225]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.206] SequentialFuture started (and completed)
[16:13:18.226]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.206] - Launch lazy future ... done
[16:13:18.226]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[16:13:18.206] run() for ‘SequentialFuture’ ... done
[16:13:18.226] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[16:13:18.226] plan(): Setting new future strategy stack:
[16:13:18.226] List of future strategies:
[16:13:18.226] 1. multisession:
[16:13:18.226]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.226]    - tweaked: FALSE
[16:13:18.226]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.226] 2. sequential:
[16:13:18.226]    - args: function (..., envir = parent.frame())
[16:13:18.226]    - tweaked: FALSE
[16:13:18.226]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.227] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:13:18.227] multisession:
[16:13:18.227] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.227] - tweaked: FALSE
[16:13:18.227] - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.231] getGlobalsAndPackages() ...
[16:13:18.232] Not searching for globals
[16:13:18.232] - globals: [0] <none>
[16:13:18.232] getGlobalsAndPackages() ... DONE
[16:13:18.232] [local output] makeClusterPSOCK() ...
[16:13:18.233] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:18.233] [local output] Base port: 11083
[16:13:18.234] [local output] Getting setup options for 2 cluster nodes ...
[16:13:18.234] [local output]  - Node 1 of 2 ...
[16:13:18.234] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:18.235] [local output] Rscript port: 11083

[16:13:18.235] [local output]  - Node 2 of 2 ...
[16:13:18.235] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:18.236] [local output] Rscript port: 11083

[16:13:18.236] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:18.236] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:18.237] [local output] Setting up PSOCK nodes in parallel
[16:13:18.237] List of 36
[16:13:18.237]  $ worker          : chr "localhost"
[16:13:18.237]   ..- attr(*, "localhost")= logi TRUE
[16:13:18.237]  $ master          : chr "localhost"
[16:13:18.237]  $ port            : int 11083
[16:13:18.237]  $ connectTimeout  : num 120
[16:13:18.237]  $ timeout         : num 2592000
[16:13:18.237]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:18.237]  $ homogeneous     : logi TRUE
[16:13:18.237]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:18.237]  $ rscript_envs    : NULL
[16:13:18.237]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:18.237]  $ rscript_startup : NULL
[16:13:18.237]  $ rscript_sh      : chr "sh"
[16:13:18.237]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:18.237]  $ methods         : logi TRUE
[16:13:18.237]  $ socketOptions   : chr "no-delay"
[16:13:18.237]  $ useXDR          : logi FALSE
[16:13:18.237]  $ outfile         : chr "/dev/null"
[16:13:18.237]  $ renice          : int NA
[16:13:18.237]  $ rshcmd          : NULL
[16:13:18.237]  $ user            : chr(0) 
[16:13:18.237]  $ revtunnel       : logi FALSE
[16:13:18.237]  $ rshlogfile      : NULL
[16:13:18.237]  $ rshopts         : chr(0) 
[16:13:18.237]  $ rank            : int 1
[16:13:18.237]  $ manual          : logi FALSE
[16:13:18.237]  $ dryrun          : logi FALSE
[16:13:18.237]  $ quiet           : logi FALSE
[16:13:18.237]  $ setup_strategy  : chr "parallel"
[16:13:18.237]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:18.237]  $ pidfile         : chr "/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b562aef4aef.pid"
[16:13:18.237]  $ rshcmd_label    : NULL
[16:13:18.237]  $ rsh_call        : NULL
[16:13:18.237]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:18.237]  $ localMachine    : logi TRUE
[16:13:18.237]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:18.237]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:18.237]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:18.237]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:18.237]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:18.237]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:18.237]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:18.237]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:18.237]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:18.237]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:18.237]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:18.237]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:18.237]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:18.237]  $ arguments       :List of 28
[16:13:18.237]   ..$ worker          : chr "localhost"
[16:13:18.237]   ..$ master          : NULL
[16:13:18.237]   ..$ port            : int 11083
[16:13:18.237]   ..$ connectTimeout  : num 120
[16:13:18.237]   ..$ timeout         : num 2592000
[16:13:18.237]   ..$ rscript         : NULL
[16:13:18.237]   ..$ homogeneous     : NULL
[16:13:18.237]   ..$ rscript_args    : NULL
[16:13:18.237]   ..$ rscript_envs    : NULL
[16:13:18.237]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:18.237]   ..$ rscript_startup : NULL
[16:13:18.237]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:18.237]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:18.237]   ..$ methods         : logi TRUE
[16:13:18.237]   ..$ socketOptions   : chr "no-delay"
[16:13:18.237]   ..$ useXDR          : logi FALSE
[16:13:18.237]   ..$ outfile         : chr "/dev/null"
[16:13:18.237]   ..$ renice          : int NA
[16:13:18.237]   ..$ rshcmd          : NULL
[16:13:18.237]   ..$ user            : NULL
[16:13:18.237]   ..$ revtunnel       : logi NA
[16:13:18.237]   ..$ rshlogfile      : NULL
[16:13:18.237]   ..$ rshopts         : NULL
[16:13:18.237]   ..$ rank            : int 1
[16:13:18.237]   ..$ manual          : logi FALSE
[16:13:18.237]   ..$ dryrun          : logi FALSE
[16:13:18.237]   ..$ quiet           : logi FALSE
[16:13:18.237]   ..$ setup_strategy  : chr "parallel"
[16:13:18.237]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:18.257] [local output] System call to launch all workers:
[16:13:18.258] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b562aef4aef.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11083 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:18.258] [local output] Starting PSOCK main server
[16:13:18.259] [local output] Workers launched
[16:13:18.259] [local output] Waiting for workers to connect back
[16:13:18.259]  - [local output] 0 workers out of 2 ready
[16:13:18.511]  - [local output] 0 workers out of 2 ready
[16:13:18.511]  - [local output] 1 workers out of 2 ready
[16:13:18.513]  - [local output] 1 workers out of 2 ready
[16:13:18.514]  - [local output] 2 workers out of 2 ready
[16:13:18.514] [local output] Launching of workers completed
[16:13:18.514] [local output] Collecting session information from workers
[16:13:18.515] [local output]  - Worker #1 of 2
[16:13:18.515] [local output]  - Worker #2 of 2
[16:13:18.515] [local output] makeClusterPSOCK() ... done
[16:13:18.527] Packages needed by the future expression (n = 0): <none>
[16:13:18.527] Packages needed by future strategies (n = 1): ‘future’
[16:13:18.528] {
[16:13:18.528]     {
[16:13:18.528]         {
[16:13:18.528]             ...future.startTime <- base::Sys.time()
[16:13:18.528]             {
[16:13:18.528]                 {
[16:13:18.528]                   {
[16:13:18.528]                     {
[16:13:18.528]                       {
[16:13:18.528]                         base::local({
[16:13:18.528]                           has_future <- base::requireNamespace("future", 
[16:13:18.528]                             quietly = TRUE)
[16:13:18.528]                           if (has_future) {
[16:13:18.528]                             ns <- base::getNamespace("future")
[16:13:18.528]                             version <- ns[[".package"]][["version"]]
[16:13:18.528]                             if (is.null(version)) 
[16:13:18.528]                               version <- utils::packageVersion("future")
[16:13:18.528]                           }
[16:13:18.528]                           else {
[16:13:18.528]                             version <- NULL
[16:13:18.528]                           }
[16:13:18.528]                           if (!has_future || version < "1.8.0") {
[16:13:18.528]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.528]                               "", base::R.version$version.string), 
[16:13:18.528]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:18.528]                                 base::R.version$platform, 8 * 
[16:13:18.528]                                   base::.Machine$sizeof.pointer), 
[16:13:18.528]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.528]                                 "release", "version")], collapse = " "), 
[16:13:18.528]                               hostname = base::Sys.info()[["nodename"]])
[16:13:18.528]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.528]                               info)
[16:13:18.528]                             info <- base::paste(info, collapse = "; ")
[16:13:18.528]                             if (!has_future) {
[16:13:18.528]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.528]                                 info)
[16:13:18.528]                             }
[16:13:18.528]                             else {
[16:13:18.528]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.528]                                 info, version)
[16:13:18.528]                             }
[16:13:18.528]                             base::stop(msg)
[16:13:18.528]                           }
[16:13:18.528]                         })
[16:13:18.528]                       }
[16:13:18.528]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:18.528]                       base::options(mc.cores = 1L)
[16:13:18.528]                     }
[16:13:18.528]                     base::local({
[16:13:18.528]                       for (pkg in "future") {
[16:13:18.528]                         base::loadNamespace(pkg)
[16:13:18.528]                         base::library(pkg, character.only = TRUE)
[16:13:18.528]                       }
[16:13:18.528]                     })
[16:13:18.528]                   }
[16:13:18.528]                   options(future.plan = NULL)
[16:13:18.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.528]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:18.528]                   {
[16:13:18.528]                     future <- SequentialFuture(..., envir = envir)
[16:13:18.528]                     if (!future$lazy) 
[16:13:18.528]                       future <- run(future)
[16:13:18.528]                     invisible(future)
[16:13:18.528]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.528]                 }
[16:13:18.528]                 ...future.workdir <- getwd()
[16:13:18.528]             }
[16:13:18.528]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.528]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.528]         }
[16:13:18.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.528]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.528]             base::names(...future.oldOptions))
[16:13:18.528]     }
[16:13:18.528]     if (FALSE) {
[16:13:18.528]     }
[16:13:18.528]     else {
[16:13:18.528]         if (TRUE) {
[16:13:18.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.528]                 open = "w")
[16:13:18.528]         }
[16:13:18.528]         else {
[16:13:18.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.528]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.528]         }
[16:13:18.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.528]             base::sink(type = "output", split = FALSE)
[16:13:18.528]             base::close(...future.stdout)
[16:13:18.528]         }, add = TRUE)
[16:13:18.528]     }
[16:13:18.528]     ...future.frame <- base::sys.nframe()
[16:13:18.528]     ...future.conditions <- base::list()
[16:13:18.528]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.528]     if (FALSE) {
[16:13:18.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.528]     }
[16:13:18.528]     ...future.result <- base::tryCatch({
[16:13:18.528]         base::withCallingHandlers({
[16:13:18.528]             ...future.value <- base::withVisible(base::local({
[16:13:18.528]                 ...future.makeSendCondition <- local({
[16:13:18.528]                   sendCondition <- NULL
[16:13:18.528]                   function(frame = 1L) {
[16:13:18.528]                     if (is.function(sendCondition)) 
[16:13:18.528]                       return(sendCondition)
[16:13:18.528]                     ns <- getNamespace("parallel")
[16:13:18.528]                     if (exists("sendData", mode = "function", 
[16:13:18.528]                       envir = ns)) {
[16:13:18.528]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:18.528]                         envir = ns)
[16:13:18.528]                       envir <- sys.frame(frame)
[16:13:18.528]                       master <- NULL
[16:13:18.528]                       while (!identical(envir, .GlobalEnv) && 
[16:13:18.528]                         !identical(envir, emptyenv())) {
[16:13:18.528]                         if (exists("master", mode = "list", envir = envir, 
[16:13:18.528]                           inherits = FALSE)) {
[16:13:18.528]                           master <- get("master", mode = "list", 
[16:13:18.528]                             envir = envir, inherits = FALSE)
[16:13:18.528]                           if (inherits(master, c("SOCKnode", 
[16:13:18.528]                             "SOCK0node"))) {
[16:13:18.528]                             sendCondition <<- function(cond) {
[16:13:18.528]                               data <- list(type = "VALUE", value = cond, 
[16:13:18.528]                                 success = TRUE)
[16:13:18.528]                               parallel_sendData(master, data)
[16:13:18.528]                             }
[16:13:18.528]                             return(sendCondition)
[16:13:18.528]                           }
[16:13:18.528]                         }
[16:13:18.528]                         frame <- frame + 1L
[16:13:18.528]                         envir <- sys.frame(frame)
[16:13:18.528]                       }
[16:13:18.528]                     }
[16:13:18.528]                     sendCondition <<- function(cond) NULL
[16:13:18.528]                   }
[16:13:18.528]                 })
[16:13:18.528]                 withCallingHandlers({
[16:13:18.528]                   NA
[16:13:18.528]                 }, immediateCondition = function(cond) {
[16:13:18.528]                   sendCondition <- ...future.makeSendCondition()
[16:13:18.528]                   sendCondition(cond)
[16:13:18.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.528]                   {
[16:13:18.528]                     inherits <- base::inherits
[16:13:18.528]                     invokeRestart <- base::invokeRestart
[16:13:18.528]                     is.null <- base::is.null
[16:13:18.528]                     muffled <- FALSE
[16:13:18.528]                     if (inherits(cond, "message")) {
[16:13:18.528]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:18.528]                       if (muffled) 
[16:13:18.528]                         invokeRestart("muffleMessage")
[16:13:18.528]                     }
[16:13:18.528]                     else if (inherits(cond, "warning")) {
[16:13:18.528]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:18.528]                       if (muffled) 
[16:13:18.528]                         invokeRestart("muffleWarning")
[16:13:18.528]                     }
[16:13:18.528]                     else if (inherits(cond, "condition")) {
[16:13:18.528]                       if (!is.null(pattern)) {
[16:13:18.528]                         computeRestarts <- base::computeRestarts
[16:13:18.528]                         grepl <- base::grepl
[16:13:18.528]                         restarts <- computeRestarts(cond)
[16:13:18.528]                         for (restart in restarts) {
[16:13:18.528]                           name <- restart$name
[16:13:18.528]                           if (is.null(name)) 
[16:13:18.528]                             next
[16:13:18.528]                           if (!grepl(pattern, name)) 
[16:13:18.528]                             next
[16:13:18.528]                           invokeRestart(restart)
[16:13:18.528]                           muffled <- TRUE
[16:13:18.528]                           break
[16:13:18.528]                         }
[16:13:18.528]                       }
[16:13:18.528]                     }
[16:13:18.528]                     invisible(muffled)
[16:13:18.528]                   }
[16:13:18.528]                   muffleCondition(cond)
[16:13:18.528]                 })
[16:13:18.528]             }))
[16:13:18.528]             future::FutureResult(value = ...future.value$value, 
[16:13:18.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.528]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.528]                     ...future.globalenv.names))
[16:13:18.528]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.528]         }, condition = base::local({
[16:13:18.528]             c <- base::c
[16:13:18.528]             inherits <- base::inherits
[16:13:18.528]             invokeRestart <- base::invokeRestart
[16:13:18.528]             length <- base::length
[16:13:18.528]             list <- base::list
[16:13:18.528]             seq.int <- base::seq.int
[16:13:18.528]             signalCondition <- base::signalCondition
[16:13:18.528]             sys.calls <- base::sys.calls
[16:13:18.528]             `[[` <- base::`[[`
[16:13:18.528]             `+` <- base::`+`
[16:13:18.528]             `<<-` <- base::`<<-`
[16:13:18.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.528]                   3L)]
[16:13:18.528]             }
[16:13:18.528]             function(cond) {
[16:13:18.528]                 is_error <- inherits(cond, "error")
[16:13:18.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.528]                   NULL)
[16:13:18.528]                 if (is_error) {
[16:13:18.528]                   sessionInformation <- function() {
[16:13:18.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.528]                       search = base::search(), system = base::Sys.info())
[16:13:18.528]                   }
[16:13:18.528]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.528]                     cond$call), session = sessionInformation(), 
[16:13:18.528]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.528]                   signalCondition(cond)
[16:13:18.528]                 }
[16:13:18.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.528]                 "immediateCondition"))) {
[16:13:18.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.528]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.528]                   if (TRUE && !signal) {
[16:13:18.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.528]                     {
[16:13:18.528]                       inherits <- base::inherits
[16:13:18.528]                       invokeRestart <- base::invokeRestart
[16:13:18.528]                       is.null <- base::is.null
[16:13:18.528]                       muffled <- FALSE
[16:13:18.528]                       if (inherits(cond, "message")) {
[16:13:18.528]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.528]                         if (muffled) 
[16:13:18.528]                           invokeRestart("muffleMessage")
[16:13:18.528]                       }
[16:13:18.528]                       else if (inherits(cond, "warning")) {
[16:13:18.528]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.528]                         if (muffled) 
[16:13:18.528]                           invokeRestart("muffleWarning")
[16:13:18.528]                       }
[16:13:18.528]                       else if (inherits(cond, "condition")) {
[16:13:18.528]                         if (!is.null(pattern)) {
[16:13:18.528]                           computeRestarts <- base::computeRestarts
[16:13:18.528]                           grepl <- base::grepl
[16:13:18.528]                           restarts <- computeRestarts(cond)
[16:13:18.528]                           for (restart in restarts) {
[16:13:18.528]                             name <- restart$name
[16:13:18.528]                             if (is.null(name)) 
[16:13:18.528]                               next
[16:13:18.528]                             if (!grepl(pattern, name)) 
[16:13:18.528]                               next
[16:13:18.528]                             invokeRestart(restart)
[16:13:18.528]                             muffled <- TRUE
[16:13:18.528]                             break
[16:13:18.528]                           }
[16:13:18.528]                         }
[16:13:18.528]                       }
[16:13:18.528]                       invisible(muffled)
[16:13:18.528]                     }
[16:13:18.528]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.528]                   }
[16:13:18.528]                 }
[16:13:18.528]                 else {
[16:13:18.528]                   if (TRUE) {
[16:13:18.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.528]                     {
[16:13:18.528]                       inherits <- base::inherits
[16:13:18.528]                       invokeRestart <- base::invokeRestart
[16:13:18.528]                       is.null <- base::is.null
[16:13:18.528]                       muffled <- FALSE
[16:13:18.528]                       if (inherits(cond, "message")) {
[16:13:18.528]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.528]                         if (muffled) 
[16:13:18.528]                           invokeRestart("muffleMessage")
[16:13:18.528]                       }
[16:13:18.528]                       else if (inherits(cond, "warning")) {
[16:13:18.528]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.528]                         if (muffled) 
[16:13:18.528]                           invokeRestart("muffleWarning")
[16:13:18.528]                       }
[16:13:18.528]                       else if (inherits(cond, "condition")) {
[16:13:18.528]                         if (!is.null(pattern)) {
[16:13:18.528]                           computeRestarts <- base::computeRestarts
[16:13:18.528]                           grepl <- base::grepl
[16:13:18.528]                           restarts <- computeRestarts(cond)
[16:13:18.528]                           for (restart in restarts) {
[16:13:18.528]                             name <- restart$name
[16:13:18.528]                             if (is.null(name)) 
[16:13:18.528]                               next
[16:13:18.528]                             if (!grepl(pattern, name)) 
[16:13:18.528]                               next
[16:13:18.528]                             invokeRestart(restart)
[16:13:18.528]                             muffled <- TRUE
[16:13:18.528]                             break
[16:13:18.528]                           }
[16:13:18.528]                         }
[16:13:18.528]                       }
[16:13:18.528]                       invisible(muffled)
[16:13:18.528]                     }
[16:13:18.528]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.528]                   }
[16:13:18.528]                 }
[16:13:18.528]             }
[16:13:18.528]         }))
[16:13:18.528]     }, error = function(ex) {
[16:13:18.528]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.528]                 ...future.rng), started = ...future.startTime, 
[16:13:18.528]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.528]             version = "1.8"), class = "FutureResult")
[16:13:18.528]     }, finally = {
[16:13:18.528]         if (!identical(...future.workdir, getwd())) 
[16:13:18.528]             setwd(...future.workdir)
[16:13:18.528]         {
[16:13:18.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.528]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.528]             }
[16:13:18.528]             base::options(...future.oldOptions)
[16:13:18.528]             if (.Platform$OS.type == "windows") {
[16:13:18.528]                 old_names <- names(...future.oldEnvVars)
[16:13:18.528]                 envs <- base::Sys.getenv()
[16:13:18.528]                 names <- names(envs)
[16:13:18.528]                 common <- intersect(names, old_names)
[16:13:18.528]                 added <- setdiff(names, old_names)
[16:13:18.528]                 removed <- setdiff(old_names, names)
[16:13:18.528]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.528]                   envs[common]]
[16:13:18.528]                 NAMES <- toupper(changed)
[16:13:18.528]                 args <- list()
[16:13:18.528]                 for (kk in seq_along(NAMES)) {
[16:13:18.528]                   name <- changed[[kk]]
[16:13:18.528]                   NAME <- NAMES[[kk]]
[16:13:18.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.528]                     next
[16:13:18.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.528]                 }
[16:13:18.528]                 NAMES <- toupper(added)
[16:13:18.528]                 for (kk in seq_along(NAMES)) {
[16:13:18.528]                   name <- added[[kk]]
[16:13:18.528]                   NAME <- NAMES[[kk]]
[16:13:18.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.528]                     next
[16:13:18.528]                   args[[name]] <- ""
[16:13:18.528]                 }
[16:13:18.528]                 NAMES <- toupper(removed)
[16:13:18.528]                 for (kk in seq_along(NAMES)) {
[16:13:18.528]                   name <- removed[[kk]]
[16:13:18.528]                   NAME <- NAMES[[kk]]
[16:13:18.528]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.528]                     next
[16:13:18.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.528]                 }
[16:13:18.528]                 if (length(args) > 0) 
[16:13:18.528]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.528]             }
[16:13:18.528]             else {
[16:13:18.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.528]             }
[16:13:18.528]             {
[16:13:18.528]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.528]                   0L) {
[16:13:18.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.528]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.528]                   base::options(opts)
[16:13:18.528]                 }
[16:13:18.528]                 {
[16:13:18.528]                   {
[16:13:18.528]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:18.528]                     NULL
[16:13:18.528]                   }
[16:13:18.528]                   options(future.plan = NULL)
[16:13:18.528]                   if (is.na(NA_character_)) 
[16:13:18.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.528]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:18.528]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.528]                     envir = parent.frame()) 
[16:13:18.528]                   {
[16:13:18.528]                     if (is.function(workers)) 
[16:13:18.528]                       workers <- workers()
[16:13:18.528]                     workers <- structure(as.integer(workers), 
[16:13:18.528]                       class = class(workers))
[16:13:18.528]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.528]                       workers >= 1)
[16:13:18.528]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.528]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.528]                     }
[16:13:18.528]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.528]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.528]                       envir = envir)
[16:13:18.528]                     if (!future$lazy) 
[16:13:18.528]                       future <- run(future)
[16:13:18.528]                     invisible(future)
[16:13:18.528]                   }, b = function (..., envir = parent.frame()) 
[16:13:18.528]                   {
[16:13:18.528]                     future <- SequentialFuture(..., envir = envir)
[16:13:18.528]                     if (!future$lazy) 
[16:13:18.528]                       future <- run(future)
[16:13:18.528]                     invisible(future)
[16:13:18.528]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.528]                 }
[16:13:18.528]             }
[16:13:18.528]         }
[16:13:18.528]     })
[16:13:18.528]     if (TRUE) {
[16:13:18.528]         base::sink(type = "output", split = FALSE)
[16:13:18.528]         if (TRUE) {
[16:13:18.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.528]         }
[16:13:18.528]         else {
[16:13:18.528]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.528]         }
[16:13:18.528]         base::close(...future.stdout)
[16:13:18.528]         ...future.stdout <- NULL
[16:13:18.528]     }
[16:13:18.528]     ...future.result$conditions <- ...future.conditions
[16:13:18.528]     ...future.result$finished <- base::Sys.time()
[16:13:18.528]     ...future.result
[16:13:18.528] }
[16:13:18.599] MultisessionFuture started
[16:13:18.599] result() for ClusterFuture ...
[16:13:18.599] receiveMessageFromWorker() for ClusterFuture ...
[16:13:18.599] - Validating connection of MultisessionFuture
[16:13:18.634] - received message: FutureResult
[16:13:18.634] - Received FutureResult
[16:13:18.634] - Erased future from FutureRegistry
[16:13:18.634] result() for ClusterFuture ...
[16:13:18.634] - result already collected: FutureResult
[16:13:18.634] result() for ClusterFuture ... done
[16:13:18.634] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:18.634] result() for ClusterFuture ... done
[16:13:18.635] result() for ClusterFuture ...
[16:13:18.635] - result already collected: FutureResult
[16:13:18.635] result() for ClusterFuture ... done
[16:13:18.635] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:13:18.638] plan(): nbrOfWorkers() = 2
[16:13:18.639] getGlobalsAndPackages() ...
[16:13:18.639] Searching for globals...
[16:13:18.658] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:18.658] Searching for globals ... DONE
[16:13:18.658] Resolving globals: FALSE
[16:13:18.659] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[16:13:18.659] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:18.659] - globals: [2] ‘nested’, ‘strategy2’
[16:13:18.660] - packages: [1] ‘future’
[16:13:18.660] getGlobalsAndPackages() ... DONE
[16:13:18.660] run() for ‘Future’ ...
[16:13:18.660] - state: ‘created’
[16:13:18.660] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.676] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:18.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:18.676]   - Field: ‘node’
[16:13:18.677]   - Field: ‘label’
[16:13:18.677]   - Field: ‘local’
[16:13:18.677]   - Field: ‘owner’
[16:13:18.677]   - Field: ‘envir’
[16:13:18.677]   - Field: ‘workers’
[16:13:18.677]   - Field: ‘packages’
[16:13:18.677]   - Field: ‘gc’
[16:13:18.677]   - Field: ‘conditions’
[16:13:18.677]   - Field: ‘persistent’
[16:13:18.677]   - Field: ‘expr’
[16:13:18.678]   - Field: ‘uuid’
[16:13:18.678]   - Field: ‘seed’
[16:13:18.678]   - Field: ‘version’
[16:13:18.678]   - Field: ‘result’
[16:13:18.678]   - Field: ‘asynchronous’
[16:13:18.678]   - Field: ‘calls’
[16:13:18.678]   - Field: ‘globals’
[16:13:18.678]   - Field: ‘stdout’
[16:13:18.678]   - Field: ‘earlySignal’
[16:13:18.678]   - Field: ‘lazy’
[16:13:18.678]   - Field: ‘state’
[16:13:18.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:18.679] - Launch lazy future ...
[16:13:18.679] Packages needed by the future expression (n = 1): ‘future’
[16:13:18.679] Packages needed by future strategies (n = 1): ‘future’
[16:13:18.680] {
[16:13:18.680]     {
[16:13:18.680]         {
[16:13:18.680]             ...future.startTime <- base::Sys.time()
[16:13:18.680]             {
[16:13:18.680]                 {
[16:13:18.680]                   {
[16:13:18.680]                     {
[16:13:18.680]                       {
[16:13:18.680]                         base::local({
[16:13:18.680]                           has_future <- base::requireNamespace("future", 
[16:13:18.680]                             quietly = TRUE)
[16:13:18.680]                           if (has_future) {
[16:13:18.680]                             ns <- base::getNamespace("future")
[16:13:18.680]                             version <- ns[[".package"]][["version"]]
[16:13:18.680]                             if (is.null(version)) 
[16:13:18.680]                               version <- utils::packageVersion("future")
[16:13:18.680]                           }
[16:13:18.680]                           else {
[16:13:18.680]                             version <- NULL
[16:13:18.680]                           }
[16:13:18.680]                           if (!has_future || version < "1.8.0") {
[16:13:18.680]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.680]                               "", base::R.version$version.string), 
[16:13:18.680]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:18.680]                                 base::R.version$platform, 8 * 
[16:13:18.680]                                   base::.Machine$sizeof.pointer), 
[16:13:18.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.680]                                 "release", "version")], collapse = " "), 
[16:13:18.680]                               hostname = base::Sys.info()[["nodename"]])
[16:13:18.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.680]                               info)
[16:13:18.680]                             info <- base::paste(info, collapse = "; ")
[16:13:18.680]                             if (!has_future) {
[16:13:18.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.680]                                 info)
[16:13:18.680]                             }
[16:13:18.680]                             else {
[16:13:18.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.680]                                 info, version)
[16:13:18.680]                             }
[16:13:18.680]                             base::stop(msg)
[16:13:18.680]                           }
[16:13:18.680]                         })
[16:13:18.680]                       }
[16:13:18.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:18.680]                       base::options(mc.cores = 1L)
[16:13:18.680]                     }
[16:13:18.680]                     base::local({
[16:13:18.680]                       for (pkg in "future") {
[16:13:18.680]                         base::loadNamespace(pkg)
[16:13:18.680]                         base::library(pkg, character.only = TRUE)
[16:13:18.680]                       }
[16:13:18.680]                     })
[16:13:18.680]                   }
[16:13:18.680]                   options(future.plan = NULL)
[16:13:18.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.680]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:18.680]                   {
[16:13:18.680]                     future <- SequentialFuture(..., envir = envir)
[16:13:18.680]                     if (!future$lazy) 
[16:13:18.680]                       future <- run(future)
[16:13:18.680]                     invisible(future)
[16:13:18.680]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.680]                 }
[16:13:18.680]                 ...future.workdir <- getwd()
[16:13:18.680]             }
[16:13:18.680]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.680]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.680]         }
[16:13:18.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.680]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.680]             base::names(...future.oldOptions))
[16:13:18.680]     }
[16:13:18.680]     if (FALSE) {
[16:13:18.680]     }
[16:13:18.680]     else {
[16:13:18.680]         if (TRUE) {
[16:13:18.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.680]                 open = "w")
[16:13:18.680]         }
[16:13:18.680]         else {
[16:13:18.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.680]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.680]         }
[16:13:18.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.680]             base::sink(type = "output", split = FALSE)
[16:13:18.680]             base::close(...future.stdout)
[16:13:18.680]         }, add = TRUE)
[16:13:18.680]     }
[16:13:18.680]     ...future.frame <- base::sys.nframe()
[16:13:18.680]     ...future.conditions <- base::list()
[16:13:18.680]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.680]     if (FALSE) {
[16:13:18.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.680]     }
[16:13:18.680]     ...future.result <- base::tryCatch({
[16:13:18.680]         base::withCallingHandlers({
[16:13:18.680]             ...future.value <- base::withVisible(base::local({
[16:13:18.680]                 ...future.makeSendCondition <- local({
[16:13:18.680]                   sendCondition <- NULL
[16:13:18.680]                   function(frame = 1L) {
[16:13:18.680]                     if (is.function(sendCondition)) 
[16:13:18.680]                       return(sendCondition)
[16:13:18.680]                     ns <- getNamespace("parallel")
[16:13:18.680]                     if (exists("sendData", mode = "function", 
[16:13:18.680]                       envir = ns)) {
[16:13:18.680]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:18.680]                         envir = ns)
[16:13:18.680]                       envir <- sys.frame(frame)
[16:13:18.680]                       master <- NULL
[16:13:18.680]                       while (!identical(envir, .GlobalEnv) && 
[16:13:18.680]                         !identical(envir, emptyenv())) {
[16:13:18.680]                         if (exists("master", mode = "list", envir = envir, 
[16:13:18.680]                           inherits = FALSE)) {
[16:13:18.680]                           master <- get("master", mode = "list", 
[16:13:18.680]                             envir = envir, inherits = FALSE)
[16:13:18.680]                           if (inherits(master, c("SOCKnode", 
[16:13:18.680]                             "SOCK0node"))) {
[16:13:18.680]                             sendCondition <<- function(cond) {
[16:13:18.680]                               data <- list(type = "VALUE", value = cond, 
[16:13:18.680]                                 success = TRUE)
[16:13:18.680]                               parallel_sendData(master, data)
[16:13:18.680]                             }
[16:13:18.680]                             return(sendCondition)
[16:13:18.680]                           }
[16:13:18.680]                         }
[16:13:18.680]                         frame <- frame + 1L
[16:13:18.680]                         envir <- sys.frame(frame)
[16:13:18.680]                       }
[16:13:18.680]                     }
[16:13:18.680]                     sendCondition <<- function(cond) NULL
[16:13:18.680]                   }
[16:13:18.680]                 })
[16:13:18.680]                 withCallingHandlers({
[16:13:18.680]                   {
[16:13:18.680]                     a <- 1L
[16:13:18.680]                     plan_a <- unclass(future::plan("list"))
[16:13:18.680]                     nested_a <- nested[-1]
[16:13:18.680]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:18.680]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:18.680]                       strategy2))
[16:13:18.680]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:18.680]                       "init") <- NULL
[16:13:18.680]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:18.680]                       "init") <- NULL
[16:13:18.680]                     stopifnot(all.equal(plan_a, nested_a))
[16:13:18.680]                     y %<-% {
[16:13:18.680]                       b <- 2L
[16:13:18.680]                       plan_b <- future::plan("list")
[16:13:18.680]                       nested_b <- nested_a[-1]
[16:13:18.680]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:18.680]                         1L, inherits(plan_b[[1]], "future"), 
[16:13:18.680]                         inherits(future::plan("next"), "sequential"))
[16:13:18.680]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:18.680]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:18.680]                     }
[16:13:18.680]                     y
[16:13:18.680]                   }
[16:13:18.680]                 }, immediateCondition = function(cond) {
[16:13:18.680]                   sendCondition <- ...future.makeSendCondition()
[16:13:18.680]                   sendCondition(cond)
[16:13:18.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.680]                   {
[16:13:18.680]                     inherits <- base::inherits
[16:13:18.680]                     invokeRestart <- base::invokeRestart
[16:13:18.680]                     is.null <- base::is.null
[16:13:18.680]                     muffled <- FALSE
[16:13:18.680]                     if (inherits(cond, "message")) {
[16:13:18.680]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:18.680]                       if (muffled) 
[16:13:18.680]                         invokeRestart("muffleMessage")
[16:13:18.680]                     }
[16:13:18.680]                     else if (inherits(cond, "warning")) {
[16:13:18.680]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:18.680]                       if (muffled) 
[16:13:18.680]                         invokeRestart("muffleWarning")
[16:13:18.680]                     }
[16:13:18.680]                     else if (inherits(cond, "condition")) {
[16:13:18.680]                       if (!is.null(pattern)) {
[16:13:18.680]                         computeRestarts <- base::computeRestarts
[16:13:18.680]                         grepl <- base::grepl
[16:13:18.680]                         restarts <- computeRestarts(cond)
[16:13:18.680]                         for (restart in restarts) {
[16:13:18.680]                           name <- restart$name
[16:13:18.680]                           if (is.null(name)) 
[16:13:18.680]                             next
[16:13:18.680]                           if (!grepl(pattern, name)) 
[16:13:18.680]                             next
[16:13:18.680]                           invokeRestart(restart)
[16:13:18.680]                           muffled <- TRUE
[16:13:18.680]                           break
[16:13:18.680]                         }
[16:13:18.680]                       }
[16:13:18.680]                     }
[16:13:18.680]                     invisible(muffled)
[16:13:18.680]                   }
[16:13:18.680]                   muffleCondition(cond)
[16:13:18.680]                 })
[16:13:18.680]             }))
[16:13:18.680]             future::FutureResult(value = ...future.value$value, 
[16:13:18.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.680]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.680]                     ...future.globalenv.names))
[16:13:18.680]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.680]         }, condition = base::local({
[16:13:18.680]             c <- base::c
[16:13:18.680]             inherits <- base::inherits
[16:13:18.680]             invokeRestart <- base::invokeRestart
[16:13:18.680]             length <- base::length
[16:13:18.680]             list <- base::list
[16:13:18.680]             seq.int <- base::seq.int
[16:13:18.680]             signalCondition <- base::signalCondition
[16:13:18.680]             sys.calls <- base::sys.calls
[16:13:18.680]             `[[` <- base::`[[`
[16:13:18.680]             `+` <- base::`+`
[16:13:18.680]             `<<-` <- base::`<<-`
[16:13:18.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.680]                   3L)]
[16:13:18.680]             }
[16:13:18.680]             function(cond) {
[16:13:18.680]                 is_error <- inherits(cond, "error")
[16:13:18.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.680]                   NULL)
[16:13:18.680]                 if (is_error) {
[16:13:18.680]                   sessionInformation <- function() {
[16:13:18.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.680]                       search = base::search(), system = base::Sys.info())
[16:13:18.680]                   }
[16:13:18.680]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.680]                     cond$call), session = sessionInformation(), 
[16:13:18.680]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.680]                   signalCondition(cond)
[16:13:18.680]                 }
[16:13:18.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.680]                 "immediateCondition"))) {
[16:13:18.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.680]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.680]                   if (TRUE && !signal) {
[16:13:18.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.680]                     {
[16:13:18.680]                       inherits <- base::inherits
[16:13:18.680]                       invokeRestart <- base::invokeRestart
[16:13:18.680]                       is.null <- base::is.null
[16:13:18.680]                       muffled <- FALSE
[16:13:18.680]                       if (inherits(cond, "message")) {
[16:13:18.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.680]                         if (muffled) 
[16:13:18.680]                           invokeRestart("muffleMessage")
[16:13:18.680]                       }
[16:13:18.680]                       else if (inherits(cond, "warning")) {
[16:13:18.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.680]                         if (muffled) 
[16:13:18.680]                           invokeRestart("muffleWarning")
[16:13:18.680]                       }
[16:13:18.680]                       else if (inherits(cond, "condition")) {
[16:13:18.680]                         if (!is.null(pattern)) {
[16:13:18.680]                           computeRestarts <- base::computeRestarts
[16:13:18.680]                           grepl <- base::grepl
[16:13:18.680]                           restarts <- computeRestarts(cond)
[16:13:18.680]                           for (restart in restarts) {
[16:13:18.680]                             name <- restart$name
[16:13:18.680]                             if (is.null(name)) 
[16:13:18.680]                               next
[16:13:18.680]                             if (!grepl(pattern, name)) 
[16:13:18.680]                               next
[16:13:18.680]                             invokeRestart(restart)
[16:13:18.680]                             muffled <- TRUE
[16:13:18.680]                             break
[16:13:18.680]                           }
[16:13:18.680]                         }
[16:13:18.680]                       }
[16:13:18.680]                       invisible(muffled)
[16:13:18.680]                     }
[16:13:18.680]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.680]                   }
[16:13:18.680]                 }
[16:13:18.680]                 else {
[16:13:18.680]                   if (TRUE) {
[16:13:18.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.680]                     {
[16:13:18.680]                       inherits <- base::inherits
[16:13:18.680]                       invokeRestart <- base::invokeRestart
[16:13:18.680]                       is.null <- base::is.null
[16:13:18.680]                       muffled <- FALSE
[16:13:18.680]                       if (inherits(cond, "message")) {
[16:13:18.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.680]                         if (muffled) 
[16:13:18.680]                           invokeRestart("muffleMessage")
[16:13:18.680]                       }
[16:13:18.680]                       else if (inherits(cond, "warning")) {
[16:13:18.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.680]                         if (muffled) 
[16:13:18.680]                           invokeRestart("muffleWarning")
[16:13:18.680]                       }
[16:13:18.680]                       else if (inherits(cond, "condition")) {
[16:13:18.680]                         if (!is.null(pattern)) {
[16:13:18.680]                           computeRestarts <- base::computeRestarts
[16:13:18.680]                           grepl <- base::grepl
[16:13:18.680]                           restarts <- computeRestarts(cond)
[16:13:18.680]                           for (restart in restarts) {
[16:13:18.680]                             name <- restart$name
[16:13:18.680]                             if (is.null(name)) 
[16:13:18.680]                               next
[16:13:18.680]                             if (!grepl(pattern, name)) 
[16:13:18.680]                               next
[16:13:18.680]                             invokeRestart(restart)
[16:13:18.680]                             muffled <- TRUE
[16:13:18.680]                             break
[16:13:18.680]                           }
[16:13:18.680]                         }
[16:13:18.680]                       }
[16:13:18.680]                       invisible(muffled)
[16:13:18.680]                     }
[16:13:18.680]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.680]                   }
[16:13:18.680]                 }
[16:13:18.680]             }
[16:13:18.680]         }))
[16:13:18.680]     }, error = function(ex) {
[16:13:18.680]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.680]                 ...future.rng), started = ...future.startTime, 
[16:13:18.680]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.680]             version = "1.8"), class = "FutureResult")
[16:13:18.680]     }, finally = {
[16:13:18.680]         if (!identical(...future.workdir, getwd())) 
[16:13:18.680]             setwd(...future.workdir)
[16:13:18.680]         {
[16:13:18.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.680]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.680]             }
[16:13:18.680]             base::options(...future.oldOptions)
[16:13:18.680]             if (.Platform$OS.type == "windows") {
[16:13:18.680]                 old_names <- names(...future.oldEnvVars)
[16:13:18.680]                 envs <- base::Sys.getenv()
[16:13:18.680]                 names <- names(envs)
[16:13:18.680]                 common <- intersect(names, old_names)
[16:13:18.680]                 added <- setdiff(names, old_names)
[16:13:18.680]                 removed <- setdiff(old_names, names)
[16:13:18.680]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.680]                   envs[common]]
[16:13:18.680]                 NAMES <- toupper(changed)
[16:13:18.680]                 args <- list()
[16:13:18.680]                 for (kk in seq_along(NAMES)) {
[16:13:18.680]                   name <- changed[[kk]]
[16:13:18.680]                   NAME <- NAMES[[kk]]
[16:13:18.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.680]                     next
[16:13:18.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.680]                 }
[16:13:18.680]                 NAMES <- toupper(added)
[16:13:18.680]                 for (kk in seq_along(NAMES)) {
[16:13:18.680]                   name <- added[[kk]]
[16:13:18.680]                   NAME <- NAMES[[kk]]
[16:13:18.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.680]                     next
[16:13:18.680]                   args[[name]] <- ""
[16:13:18.680]                 }
[16:13:18.680]                 NAMES <- toupper(removed)
[16:13:18.680]                 for (kk in seq_along(NAMES)) {
[16:13:18.680]                   name <- removed[[kk]]
[16:13:18.680]                   NAME <- NAMES[[kk]]
[16:13:18.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.680]                     next
[16:13:18.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.680]                 }
[16:13:18.680]                 if (length(args) > 0) 
[16:13:18.680]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.680]             }
[16:13:18.680]             else {
[16:13:18.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.680]             }
[16:13:18.680]             {
[16:13:18.680]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.680]                   0L) {
[16:13:18.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.680]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.680]                   base::options(opts)
[16:13:18.680]                 }
[16:13:18.680]                 {
[16:13:18.680]                   {
[16:13:18.680]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:18.680]                     NULL
[16:13:18.680]                   }
[16:13:18.680]                   options(future.plan = NULL)
[16:13:18.680]                   if (is.na(NA_character_)) 
[16:13:18.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.680]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:18.680]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.680]                     envir = parent.frame()) 
[16:13:18.680]                   {
[16:13:18.680]                     if (is.function(workers)) 
[16:13:18.680]                       workers <- workers()
[16:13:18.680]                     workers <- structure(as.integer(workers), 
[16:13:18.680]                       class = class(workers))
[16:13:18.680]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.680]                       workers >= 1)
[16:13:18.680]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.680]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.680]                     }
[16:13:18.680]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.680]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.680]                       envir = envir)
[16:13:18.680]                     if (!future$lazy) 
[16:13:18.680]                       future <- run(future)
[16:13:18.680]                     invisible(future)
[16:13:18.680]                   }, b = function (..., envir = parent.frame()) 
[16:13:18.680]                   {
[16:13:18.680]                     future <- SequentialFuture(..., envir = envir)
[16:13:18.680]                     if (!future$lazy) 
[16:13:18.680]                       future <- run(future)
[16:13:18.680]                     invisible(future)
[16:13:18.680]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.680]                 }
[16:13:18.680]             }
[16:13:18.680]         }
[16:13:18.680]     })
[16:13:18.680]     if (TRUE) {
[16:13:18.680]         base::sink(type = "output", split = FALSE)
[16:13:18.680]         if (TRUE) {
[16:13:18.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.680]         }
[16:13:18.680]         else {
[16:13:18.680]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.680]         }
[16:13:18.680]         base::close(...future.stdout)
[16:13:18.680]         ...future.stdout <- NULL
[16:13:18.680]     }
[16:13:18.680]     ...future.result$conditions <- ...future.conditions
[16:13:18.680]     ...future.result$finished <- base::Sys.time()
[16:13:18.680]     ...future.result
[16:13:18.680] }
[16:13:18.682] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[16:13:18.683] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[16:13:18.724] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[16:13:18.724] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:13:18.724] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:13:18.725] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[16:13:18.725] MultisessionFuture started
[16:13:18.725] - Launch lazy future ... done
[16:13:18.725] run() for ‘MultisessionFuture’ ... done
[16:13:18.726] result() for ClusterFuture ...
[16:13:18.726] receiveMessageFromWorker() for ClusterFuture ...
[16:13:18.726] - Validating connection of MultisessionFuture
[16:13:18.792] - received message: FutureResult
[16:13:18.792] - Received FutureResult
[16:13:18.792] - Erased future from FutureRegistry
[16:13:18.792] result() for ClusterFuture ...
[16:13:18.792] - result already collected: FutureResult
[16:13:18.792] result() for ClusterFuture ... done
[16:13:18.792] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:18.792] result() for ClusterFuture ... done
[16:13:18.792] result() for ClusterFuture ...
[16:13:18.793] - result already collected: FutureResult
[16:13:18.793] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:18.798] getGlobalsAndPackages() ...
[16:13:18.798] Searching for globals...
[16:13:18.799] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:18.799] Searching for globals ... DONE
[16:13:18.799] Resolving globals: FALSE
[16:13:18.800] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:18.800] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:18.800] - globals: [1] ‘data’
[16:13:18.800] - packages: [1] ‘future’
[16:13:18.800] getGlobalsAndPackages() ... DONE
[16:13:18.801] run() for ‘Future’ ...
[16:13:18.801] - state: ‘created’
[16:13:18.801] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:18.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:18.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:18.816]   - Field: ‘node’
[16:13:18.817]   - Field: ‘label’
[16:13:18.817]   - Field: ‘local’
[16:13:18.817]   - Field: ‘owner’
[16:13:18.817]   - Field: ‘envir’
[16:13:18.817]   - Field: ‘workers’
[16:13:18.817]   - Field: ‘packages’
[16:13:18.817]   - Field: ‘gc’
[16:13:18.817]   - Field: ‘conditions’
[16:13:18.817]   - Field: ‘persistent’
[16:13:18.817]   - Field: ‘expr’
[16:13:18.818]   - Field: ‘uuid’
[16:13:18.818]   - Field: ‘seed’
[16:13:18.818]   - Field: ‘version’
[16:13:18.818]   - Field: ‘result’
[16:13:18.818]   - Field: ‘asynchronous’
[16:13:18.818]   - Field: ‘calls’
[16:13:18.818]   - Field: ‘globals’
[16:13:18.818]   - Field: ‘stdout’
[16:13:18.818]   - Field: ‘earlySignal’
[16:13:18.818]   - Field: ‘lazy’
[16:13:18.818]   - Field: ‘state’
[16:13:18.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:18.819] - Launch lazy future ...
[16:13:18.819] Packages needed by the future expression (n = 1): ‘future’
[16:13:18.819] Packages needed by future strategies (n = 1): ‘future’
[16:13:18.820] {
[16:13:18.820]     {
[16:13:18.820]         {
[16:13:18.820]             ...future.startTime <- base::Sys.time()
[16:13:18.820]             {
[16:13:18.820]                 {
[16:13:18.820]                   {
[16:13:18.820]                     {
[16:13:18.820]                       {
[16:13:18.820]                         base::local({
[16:13:18.820]                           has_future <- base::requireNamespace("future", 
[16:13:18.820]                             quietly = TRUE)
[16:13:18.820]                           if (has_future) {
[16:13:18.820]                             ns <- base::getNamespace("future")
[16:13:18.820]                             version <- ns[[".package"]][["version"]]
[16:13:18.820]                             if (is.null(version)) 
[16:13:18.820]                               version <- utils::packageVersion("future")
[16:13:18.820]                           }
[16:13:18.820]                           else {
[16:13:18.820]                             version <- NULL
[16:13:18.820]                           }
[16:13:18.820]                           if (!has_future || version < "1.8.0") {
[16:13:18.820]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:18.820]                               "", base::R.version$version.string), 
[16:13:18.820]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:18.820]                                 base::R.version$platform, 8 * 
[16:13:18.820]                                   base::.Machine$sizeof.pointer), 
[16:13:18.820]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:18.820]                                 "release", "version")], collapse = " "), 
[16:13:18.820]                               hostname = base::Sys.info()[["nodename"]])
[16:13:18.820]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:18.820]                               info)
[16:13:18.820]                             info <- base::paste(info, collapse = "; ")
[16:13:18.820]                             if (!has_future) {
[16:13:18.820]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:18.820]                                 info)
[16:13:18.820]                             }
[16:13:18.820]                             else {
[16:13:18.820]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:18.820]                                 info, version)
[16:13:18.820]                             }
[16:13:18.820]                             base::stop(msg)
[16:13:18.820]                           }
[16:13:18.820]                         })
[16:13:18.820]                       }
[16:13:18.820]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:18.820]                       base::options(mc.cores = 1L)
[16:13:18.820]                     }
[16:13:18.820]                     base::local({
[16:13:18.820]                       for (pkg in "future") {
[16:13:18.820]                         base::loadNamespace(pkg)
[16:13:18.820]                         base::library(pkg, character.only = TRUE)
[16:13:18.820]                       }
[16:13:18.820]                     })
[16:13:18.820]                   }
[16:13:18.820]                   options(future.plan = NULL)
[16:13:18.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.820]                   future::plan(list(b = function (..., envir = parent.frame()) 
[16:13:18.820]                   {
[16:13:18.820]                     future <- SequentialFuture(..., envir = envir)
[16:13:18.820]                     if (!future$lazy) 
[16:13:18.820]                       future <- run(future)
[16:13:18.820]                     invisible(future)
[16:13:18.820]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.820]                 }
[16:13:18.820]                 ...future.workdir <- getwd()
[16:13:18.820]             }
[16:13:18.820]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:18.820]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:18.820]         }
[16:13:18.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:18.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:18.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:18.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:18.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:18.820]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:18.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:18.820]             base::names(...future.oldOptions))
[16:13:18.820]     }
[16:13:18.820]     if (FALSE) {
[16:13:18.820]     }
[16:13:18.820]     else {
[16:13:18.820]         if (TRUE) {
[16:13:18.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:18.820]                 open = "w")
[16:13:18.820]         }
[16:13:18.820]         else {
[16:13:18.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:18.820]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:18.820]         }
[16:13:18.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:18.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:18.820]             base::sink(type = "output", split = FALSE)
[16:13:18.820]             base::close(...future.stdout)
[16:13:18.820]         }, add = TRUE)
[16:13:18.820]     }
[16:13:18.820]     ...future.frame <- base::sys.nframe()
[16:13:18.820]     ...future.conditions <- base::list()
[16:13:18.820]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:18.820]     if (FALSE) {
[16:13:18.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:18.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:18.820]     }
[16:13:18.820]     ...future.result <- base::tryCatch({
[16:13:18.820]         base::withCallingHandlers({
[16:13:18.820]             ...future.value <- base::withVisible(base::local({
[16:13:18.820]                 ...future.makeSendCondition <- local({
[16:13:18.820]                   sendCondition <- NULL
[16:13:18.820]                   function(frame = 1L) {
[16:13:18.820]                     if (is.function(sendCondition)) 
[16:13:18.820]                       return(sendCondition)
[16:13:18.820]                     ns <- getNamespace("parallel")
[16:13:18.820]                     if (exists("sendData", mode = "function", 
[16:13:18.820]                       envir = ns)) {
[16:13:18.820]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:18.820]                         envir = ns)
[16:13:18.820]                       envir <- sys.frame(frame)
[16:13:18.820]                       master <- NULL
[16:13:18.820]                       while (!identical(envir, .GlobalEnv) && 
[16:13:18.820]                         !identical(envir, emptyenv())) {
[16:13:18.820]                         if (exists("master", mode = "list", envir = envir, 
[16:13:18.820]                           inherits = FALSE)) {
[16:13:18.820]                           master <- get("master", mode = "list", 
[16:13:18.820]                             envir = envir, inherits = FALSE)
[16:13:18.820]                           if (inherits(master, c("SOCKnode", 
[16:13:18.820]                             "SOCK0node"))) {
[16:13:18.820]                             sendCondition <<- function(cond) {
[16:13:18.820]                               data <- list(type = "VALUE", value = cond, 
[16:13:18.820]                                 success = TRUE)
[16:13:18.820]                               parallel_sendData(master, data)
[16:13:18.820]                             }
[16:13:18.820]                             return(sendCondition)
[16:13:18.820]                           }
[16:13:18.820]                         }
[16:13:18.820]                         frame <- frame + 1L
[16:13:18.820]                         envir <- sys.frame(frame)
[16:13:18.820]                       }
[16:13:18.820]                     }
[16:13:18.820]                     sendCondition <<- function(cond) NULL
[16:13:18.820]                   }
[16:13:18.820]                 })
[16:13:18.820]                 withCallingHandlers({
[16:13:18.820]                   {
[16:13:18.820]                     value(future(subset(data, a == 2)))
[16:13:18.820]                   }
[16:13:18.820]                 }, immediateCondition = function(cond) {
[16:13:18.820]                   sendCondition <- ...future.makeSendCondition()
[16:13:18.820]                   sendCondition(cond)
[16:13:18.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.820]                   {
[16:13:18.820]                     inherits <- base::inherits
[16:13:18.820]                     invokeRestart <- base::invokeRestart
[16:13:18.820]                     is.null <- base::is.null
[16:13:18.820]                     muffled <- FALSE
[16:13:18.820]                     if (inherits(cond, "message")) {
[16:13:18.820]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:18.820]                       if (muffled) 
[16:13:18.820]                         invokeRestart("muffleMessage")
[16:13:18.820]                     }
[16:13:18.820]                     else if (inherits(cond, "warning")) {
[16:13:18.820]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:18.820]                       if (muffled) 
[16:13:18.820]                         invokeRestart("muffleWarning")
[16:13:18.820]                     }
[16:13:18.820]                     else if (inherits(cond, "condition")) {
[16:13:18.820]                       if (!is.null(pattern)) {
[16:13:18.820]                         computeRestarts <- base::computeRestarts
[16:13:18.820]                         grepl <- base::grepl
[16:13:18.820]                         restarts <- computeRestarts(cond)
[16:13:18.820]                         for (restart in restarts) {
[16:13:18.820]                           name <- restart$name
[16:13:18.820]                           if (is.null(name)) 
[16:13:18.820]                             next
[16:13:18.820]                           if (!grepl(pattern, name)) 
[16:13:18.820]                             next
[16:13:18.820]                           invokeRestart(restart)
[16:13:18.820]                           muffled <- TRUE
[16:13:18.820]                           break
[16:13:18.820]                         }
[16:13:18.820]                       }
[16:13:18.820]                     }
[16:13:18.820]                     invisible(muffled)
[16:13:18.820]                   }
[16:13:18.820]                   muffleCondition(cond)
[16:13:18.820]                 })
[16:13:18.820]             }))
[16:13:18.820]             future::FutureResult(value = ...future.value$value, 
[16:13:18.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.820]                   ...future.rng), globalenv = if (FALSE) 
[16:13:18.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:18.820]                     ...future.globalenv.names))
[16:13:18.820]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:18.820]         }, condition = base::local({
[16:13:18.820]             c <- base::c
[16:13:18.820]             inherits <- base::inherits
[16:13:18.820]             invokeRestart <- base::invokeRestart
[16:13:18.820]             length <- base::length
[16:13:18.820]             list <- base::list
[16:13:18.820]             seq.int <- base::seq.int
[16:13:18.820]             signalCondition <- base::signalCondition
[16:13:18.820]             sys.calls <- base::sys.calls
[16:13:18.820]             `[[` <- base::`[[`
[16:13:18.820]             `+` <- base::`+`
[16:13:18.820]             `<<-` <- base::`<<-`
[16:13:18.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:18.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:18.820]                   3L)]
[16:13:18.820]             }
[16:13:18.820]             function(cond) {
[16:13:18.820]                 is_error <- inherits(cond, "error")
[16:13:18.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:18.820]                   NULL)
[16:13:18.820]                 if (is_error) {
[16:13:18.820]                   sessionInformation <- function() {
[16:13:18.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:18.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:18.820]                       search = base::search(), system = base::Sys.info())
[16:13:18.820]                   }
[16:13:18.820]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:18.820]                     cond$call), session = sessionInformation(), 
[16:13:18.820]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:18.820]                   signalCondition(cond)
[16:13:18.820]                 }
[16:13:18.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:18.820]                 "immediateCondition"))) {
[16:13:18.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:18.820]                   ...future.conditions[[length(...future.conditions) + 
[16:13:18.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:18.820]                   if (TRUE && !signal) {
[16:13:18.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.820]                     {
[16:13:18.820]                       inherits <- base::inherits
[16:13:18.820]                       invokeRestart <- base::invokeRestart
[16:13:18.820]                       is.null <- base::is.null
[16:13:18.820]                       muffled <- FALSE
[16:13:18.820]                       if (inherits(cond, "message")) {
[16:13:18.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.820]                         if (muffled) 
[16:13:18.820]                           invokeRestart("muffleMessage")
[16:13:18.820]                       }
[16:13:18.820]                       else if (inherits(cond, "warning")) {
[16:13:18.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.820]                         if (muffled) 
[16:13:18.820]                           invokeRestart("muffleWarning")
[16:13:18.820]                       }
[16:13:18.820]                       else if (inherits(cond, "condition")) {
[16:13:18.820]                         if (!is.null(pattern)) {
[16:13:18.820]                           computeRestarts <- base::computeRestarts
[16:13:18.820]                           grepl <- base::grepl
[16:13:18.820]                           restarts <- computeRestarts(cond)
[16:13:18.820]                           for (restart in restarts) {
[16:13:18.820]                             name <- restart$name
[16:13:18.820]                             if (is.null(name)) 
[16:13:18.820]                               next
[16:13:18.820]                             if (!grepl(pattern, name)) 
[16:13:18.820]                               next
[16:13:18.820]                             invokeRestart(restart)
[16:13:18.820]                             muffled <- TRUE
[16:13:18.820]                             break
[16:13:18.820]                           }
[16:13:18.820]                         }
[16:13:18.820]                       }
[16:13:18.820]                       invisible(muffled)
[16:13:18.820]                     }
[16:13:18.820]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.820]                   }
[16:13:18.820]                 }
[16:13:18.820]                 else {
[16:13:18.820]                   if (TRUE) {
[16:13:18.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:18.820]                     {
[16:13:18.820]                       inherits <- base::inherits
[16:13:18.820]                       invokeRestart <- base::invokeRestart
[16:13:18.820]                       is.null <- base::is.null
[16:13:18.820]                       muffled <- FALSE
[16:13:18.820]                       if (inherits(cond, "message")) {
[16:13:18.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:18.820]                         if (muffled) 
[16:13:18.820]                           invokeRestart("muffleMessage")
[16:13:18.820]                       }
[16:13:18.820]                       else if (inherits(cond, "warning")) {
[16:13:18.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:18.820]                         if (muffled) 
[16:13:18.820]                           invokeRestart("muffleWarning")
[16:13:18.820]                       }
[16:13:18.820]                       else if (inherits(cond, "condition")) {
[16:13:18.820]                         if (!is.null(pattern)) {
[16:13:18.820]                           computeRestarts <- base::computeRestarts
[16:13:18.820]                           grepl <- base::grepl
[16:13:18.820]                           restarts <- computeRestarts(cond)
[16:13:18.820]                           for (restart in restarts) {
[16:13:18.820]                             name <- restart$name
[16:13:18.820]                             if (is.null(name)) 
[16:13:18.820]                               next
[16:13:18.820]                             if (!grepl(pattern, name)) 
[16:13:18.820]                               next
[16:13:18.820]                             invokeRestart(restart)
[16:13:18.820]                             muffled <- TRUE
[16:13:18.820]                             break
[16:13:18.820]                           }
[16:13:18.820]                         }
[16:13:18.820]                       }
[16:13:18.820]                       invisible(muffled)
[16:13:18.820]                     }
[16:13:18.820]                     muffleCondition(cond, pattern = "^muffle")
[16:13:18.820]                   }
[16:13:18.820]                 }
[16:13:18.820]             }
[16:13:18.820]         }))
[16:13:18.820]     }, error = function(ex) {
[16:13:18.820]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:18.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:18.820]                 ...future.rng), started = ...future.startTime, 
[16:13:18.820]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:18.820]             version = "1.8"), class = "FutureResult")
[16:13:18.820]     }, finally = {
[16:13:18.820]         if (!identical(...future.workdir, getwd())) 
[16:13:18.820]             setwd(...future.workdir)
[16:13:18.820]         {
[16:13:18.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:18.820]                 ...future.oldOptions$nwarnings <- NULL
[16:13:18.820]             }
[16:13:18.820]             base::options(...future.oldOptions)
[16:13:18.820]             if (.Platform$OS.type == "windows") {
[16:13:18.820]                 old_names <- names(...future.oldEnvVars)
[16:13:18.820]                 envs <- base::Sys.getenv()
[16:13:18.820]                 names <- names(envs)
[16:13:18.820]                 common <- intersect(names, old_names)
[16:13:18.820]                 added <- setdiff(names, old_names)
[16:13:18.820]                 removed <- setdiff(old_names, names)
[16:13:18.820]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:18.820]                   envs[common]]
[16:13:18.820]                 NAMES <- toupper(changed)
[16:13:18.820]                 args <- list()
[16:13:18.820]                 for (kk in seq_along(NAMES)) {
[16:13:18.820]                   name <- changed[[kk]]
[16:13:18.820]                   NAME <- NAMES[[kk]]
[16:13:18.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.820]                     next
[16:13:18.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.820]                 }
[16:13:18.820]                 NAMES <- toupper(added)
[16:13:18.820]                 for (kk in seq_along(NAMES)) {
[16:13:18.820]                   name <- added[[kk]]
[16:13:18.820]                   NAME <- NAMES[[kk]]
[16:13:18.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.820]                     next
[16:13:18.820]                   args[[name]] <- ""
[16:13:18.820]                 }
[16:13:18.820]                 NAMES <- toupper(removed)
[16:13:18.820]                 for (kk in seq_along(NAMES)) {
[16:13:18.820]                   name <- removed[[kk]]
[16:13:18.820]                   NAME <- NAMES[[kk]]
[16:13:18.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:18.820]                     next
[16:13:18.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:18.820]                 }
[16:13:18.820]                 if (length(args) > 0) 
[16:13:18.820]                   base::do.call(base::Sys.setenv, args = args)
[16:13:18.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:18.820]             }
[16:13:18.820]             else {
[16:13:18.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:18.820]             }
[16:13:18.820]             {
[16:13:18.820]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:18.820]                   0L) {
[16:13:18.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:18.820]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:18.820]                   base::options(opts)
[16:13:18.820]                 }
[16:13:18.820]                 {
[16:13:18.820]                   {
[16:13:18.820]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:18.820]                     NULL
[16:13:18.820]                   }
[16:13:18.820]                   options(future.plan = NULL)
[16:13:18.820]                   if (is.na(NA_character_)) 
[16:13:18.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:18.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:18.820]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:18.820]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:18.820]                     envir = parent.frame()) 
[16:13:18.820]                   {
[16:13:18.820]                     if (is.function(workers)) 
[16:13:18.820]                       workers <- workers()
[16:13:18.820]                     workers <- structure(as.integer(workers), 
[16:13:18.820]                       class = class(workers))
[16:13:18.820]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:18.820]                       workers >= 1)
[16:13:18.820]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:18.820]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:18.820]                     }
[16:13:18.820]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:18.820]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:18.820]                       envir = envir)
[16:13:18.820]                     if (!future$lazy) 
[16:13:18.820]                       future <- run(future)
[16:13:18.820]                     invisible(future)
[16:13:18.820]                   }, b = function (..., envir = parent.frame()) 
[16:13:18.820]                   {
[16:13:18.820]                     future <- SequentialFuture(..., envir = envir)
[16:13:18.820]                     if (!future$lazy) 
[16:13:18.820]                       future <- run(future)
[16:13:18.820]                     invisible(future)
[16:13:18.820]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:18.820]                 }
[16:13:18.820]             }
[16:13:18.820]         }
[16:13:18.820]     })
[16:13:18.820]     if (TRUE) {
[16:13:18.820]         base::sink(type = "output", split = FALSE)
[16:13:18.820]         if (TRUE) {
[16:13:18.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:18.820]         }
[16:13:18.820]         else {
[16:13:18.820]             ...future.result["stdout"] <- base::list(NULL)
[16:13:18.820]         }
[16:13:18.820]         base::close(...future.stdout)
[16:13:18.820]         ...future.stdout <- NULL
[16:13:18.820]     }
[16:13:18.820]     ...future.result$conditions <- ...future.conditions
[16:13:18.820]     ...future.result$finished <- base::Sys.time()
[16:13:18.820]     ...future.result
[16:13:18.820] }
[16:13:18.822] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:13:18.823] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:13:18.823] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:13:18.823] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:13:18.824] MultisessionFuture started
[16:13:18.824] - Launch lazy future ... done
[16:13:18.824] run() for ‘MultisessionFuture’ ... done
[16:13:18.824] result() for ClusterFuture ...
[16:13:18.824] receiveMessageFromWorker() for ClusterFuture ...
[16:13:18.824] - Validating connection of MultisessionFuture
[16:13:18.879] - received message: FutureResult
[16:13:18.879] - Received FutureResult
[16:13:18.879] - Erased future from FutureRegistry
[16:13:18.879] result() for ClusterFuture ...
[16:13:18.880] - result already collected: FutureResult
[16:13:18.880] result() for ClusterFuture ... done
[16:13:18.880] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:18.880] result() for ClusterFuture ... done
[16:13:18.880] result() for ClusterFuture ...
[16:13:18.880] - result already collected: FutureResult
[16:13:18.880] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[16:13:18.881] plan(): Setting new future strategy stack:
[16:13:18.881] List of future strategies:
[16:13:18.881] 1. multisession:
[16:13:18.881]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.881]    - tweaked: FALSE
[16:13:18.881]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.881] 2. multicore:
[16:13:18.881]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:13:18.881]    - tweaked: FALSE
[16:13:18.881]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.882] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:13:18.882] multisession:
[16:13:18.882] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:18.882] - tweaked: FALSE
[16:13:18.882] - call: plan(list(a = strategy1, b = strategy2))
[16:13:18.886] getGlobalsAndPackages() ...
[16:13:18.886] Not searching for globals
[16:13:18.886] - globals: [0] <none>
[16:13:18.886] getGlobalsAndPackages() ... DONE
[16:13:18.886] [local output] makeClusterPSOCK() ...
[16:13:18.887] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:18.887] [local output] Base port: 11351
[16:13:18.887] [local output] Getting setup options for 2 cluster nodes ...
[16:13:18.887] [local output]  - Node 1 of 2 ...
[16:13:18.888] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:18.888] [local output] Rscript port: 11351

[16:13:18.889] [local output]  - Node 2 of 2 ...
[16:13:18.889] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:18.890] [local output] Rscript port: 11351

[16:13:18.890] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:18.890] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:18.890] [local output] Setting up PSOCK nodes in parallel
[16:13:18.890] List of 36
[16:13:18.890]  $ worker          : chr "localhost"
[16:13:18.890]   ..- attr(*, "localhost")= logi TRUE
[16:13:18.890]  $ master          : chr "localhost"
[16:13:18.890]  $ port            : int 11351
[16:13:18.890]  $ connectTimeout  : num 120
[16:13:18.890]  $ timeout         : num 2592000
[16:13:18.890]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:18.890]  $ homogeneous     : logi TRUE
[16:13:18.890]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:18.890]  $ rscript_envs    : NULL
[16:13:18.890]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:18.890]  $ rscript_startup : NULL
[16:13:18.890]  $ rscript_sh      : chr "sh"
[16:13:18.890]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:18.890]  $ methods         : logi TRUE
[16:13:18.890]  $ socketOptions   : chr "no-delay"
[16:13:18.890]  $ useXDR          : logi FALSE
[16:13:18.890]  $ outfile         : chr "/dev/null"
[16:13:18.890]  $ renice          : int NA
[16:13:18.890]  $ rshcmd          : NULL
[16:13:18.890]  $ user            : chr(0) 
[16:13:18.890]  $ revtunnel       : logi FALSE
[16:13:18.890]  $ rshlogfile      : NULL
[16:13:18.890]  $ rshopts         : chr(0) 
[16:13:18.890]  $ rank            : int 1
[16:13:18.890]  $ manual          : logi FALSE
[16:13:18.890]  $ dryrun          : logi FALSE
[16:13:18.890]  $ quiet           : logi FALSE
[16:13:18.890]  $ setup_strategy  : chr "parallel"
[16:13:18.890]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:18.890]  $ pidfile         : chr "/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b5652937b3b.pid"
[16:13:18.890]  $ rshcmd_label    : NULL
[16:13:18.890]  $ rsh_call        : NULL
[16:13:18.890]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:18.890]  $ localMachine    : logi TRUE
[16:13:18.890]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:18.890]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:18.890]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:18.890]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:18.890]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:18.890]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:18.890]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:18.890]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:18.890]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:18.890]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:18.890]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:18.890]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:18.890]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:18.890]  $ arguments       :List of 28
[16:13:18.890]   ..$ worker          : chr "localhost"
[16:13:18.890]   ..$ master          : NULL
[16:13:18.890]   ..$ port            : int 11351
[16:13:18.890]   ..$ connectTimeout  : num 120
[16:13:18.890]   ..$ timeout         : num 2592000
[16:13:18.890]   ..$ rscript         : NULL
[16:13:18.890]   ..$ homogeneous     : NULL
[16:13:18.890]   ..$ rscript_args    : NULL
[16:13:18.890]   ..$ rscript_envs    : NULL
[16:13:18.890]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:18.890]   ..$ rscript_startup : NULL
[16:13:18.890]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:18.890]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:18.890]   ..$ methods         : logi TRUE
[16:13:18.890]   ..$ socketOptions   : chr "no-delay"
[16:13:18.890]   ..$ useXDR          : logi FALSE
[16:13:18.890]   ..$ outfile         : chr "/dev/null"
[16:13:18.890]   ..$ renice          : int NA
[16:13:18.890]   ..$ rshcmd          : NULL
[16:13:18.890]   ..$ user            : NULL
[16:13:18.890]   ..$ revtunnel       : logi NA
[16:13:18.890]   ..$ rshlogfile      : NULL
[16:13:18.890]   ..$ rshopts         : NULL
[16:13:18.890]   ..$ rank            : int 1
[16:13:18.890]   ..$ manual          : logi FALSE
[16:13:18.890]   ..$ dryrun          : logi FALSE
[16:13:18.890]   ..$ quiet           : logi FALSE
[16:13:18.890]   ..$ setup_strategy  : chr "parallel"
[16:13:18.890]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:18.910] [local output] System call to launch all workers:
[16:13:18.910] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b5652937b3b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11351 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:18.910] [local output] Starting PSOCK main server
[16:13:18.911] [local output] Workers launched
[16:13:18.912] [local output] Waiting for workers to connect back
[16:13:18.912]  - [local output] 0 workers out of 2 ready
[16:13:19.164]  - [local output] 0 workers out of 2 ready
[16:13:19.164]  - [local output] 1 workers out of 2 ready
[16:13:19.173]  - [local output] 1 workers out of 2 ready
[16:13:19.173]  - [local output] 2 workers out of 2 ready
[16:13:19.173] [local output] Launching of workers completed
[16:13:19.173] [local output] Collecting session information from workers
[16:13:19.174] [local output]  - Worker #1 of 2
[16:13:19.174] [local output]  - Worker #2 of 2
[16:13:19.175] [local output] makeClusterPSOCK() ... done
[16:13:19.186] Packages needed by the future expression (n = 0): <none>
[16:13:19.186] Packages needed by future strategies (n = 1): ‘future’
[16:13:19.187] {
[16:13:19.187]     {
[16:13:19.187]         {
[16:13:19.187]             ...future.startTime <- base::Sys.time()
[16:13:19.187]             {
[16:13:19.187]                 {
[16:13:19.187]                   {
[16:13:19.187]                     {
[16:13:19.187]                       {
[16:13:19.187]                         base::local({
[16:13:19.187]                           has_future <- base::requireNamespace("future", 
[16:13:19.187]                             quietly = TRUE)
[16:13:19.187]                           if (has_future) {
[16:13:19.187]                             ns <- base::getNamespace("future")
[16:13:19.187]                             version <- ns[[".package"]][["version"]]
[16:13:19.187]                             if (is.null(version)) 
[16:13:19.187]                               version <- utils::packageVersion("future")
[16:13:19.187]                           }
[16:13:19.187]                           else {
[16:13:19.187]                             version <- NULL
[16:13:19.187]                           }
[16:13:19.187]                           if (!has_future || version < "1.8.0") {
[16:13:19.187]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:19.187]                               "", base::R.version$version.string), 
[16:13:19.187]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:19.187]                                 base::R.version$platform, 8 * 
[16:13:19.187]                                   base::.Machine$sizeof.pointer), 
[16:13:19.187]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:19.187]                                 "release", "version")], collapse = " "), 
[16:13:19.187]                               hostname = base::Sys.info()[["nodename"]])
[16:13:19.187]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:19.187]                               info)
[16:13:19.187]                             info <- base::paste(info, collapse = "; ")
[16:13:19.187]                             if (!has_future) {
[16:13:19.187]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:19.187]                                 info)
[16:13:19.187]                             }
[16:13:19.187]                             else {
[16:13:19.187]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:19.187]                                 info, version)
[16:13:19.187]                             }
[16:13:19.187]                             base::stop(msg)
[16:13:19.187]                           }
[16:13:19.187]                         })
[16:13:19.187]                       }
[16:13:19.187]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:19.187]                       base::options(mc.cores = 1L)
[16:13:19.187]                     }
[16:13:19.187]                     base::local({
[16:13:19.187]                       for (pkg in "future") {
[16:13:19.187]                         base::loadNamespace(pkg)
[16:13:19.187]                         base::library(pkg, character.only = TRUE)
[16:13:19.187]                       }
[16:13:19.187]                     })
[16:13:19.187]                   }
[16:13:19.187]                   options(future.plan = NULL)
[16:13:19.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.187]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:19.187]                     envir = parent.frame()) 
[16:13:19.187]                   {
[16:13:19.187]                     default_workers <- missing(workers)
[16:13:19.187]                     if (is.function(workers)) 
[16:13:19.187]                       workers <- workers()
[16:13:19.187]                     workers <- structure(as.integer(workers), 
[16:13:19.187]                       class = class(workers))
[16:13:19.187]                     stop_if_not(is.finite(workers), workers >= 
[16:13:19.187]                       1L)
[16:13:19.187]                     if ((workers == 1L && !inherits(workers, 
[16:13:19.187]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:19.187]                       if (default_workers) 
[16:13:19.187]                         supportsMulticore(warn = TRUE)
[16:13:19.187]                       return(sequential(..., envir = envir))
[16:13:19.187]                     }
[16:13:19.187]                     oopts <- options(mc.cores = workers)
[16:13:19.187]                     on.exit(options(oopts))
[16:13:19.187]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:19.187]                       envir = envir)
[16:13:19.187]                     if (!future$lazy) 
[16:13:19.187]                       future <- run(future)
[16:13:19.187]                     invisible(future)
[16:13:19.187]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.187]                 }
[16:13:19.187]                 ...future.workdir <- getwd()
[16:13:19.187]             }
[16:13:19.187]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:19.187]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:19.187]         }
[16:13:19.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:19.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:19.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:19.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:19.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:19.187]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:19.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:19.187]             base::names(...future.oldOptions))
[16:13:19.187]     }
[16:13:19.187]     if (FALSE) {
[16:13:19.187]     }
[16:13:19.187]     else {
[16:13:19.187]         if (TRUE) {
[16:13:19.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:19.187]                 open = "w")
[16:13:19.187]         }
[16:13:19.187]         else {
[16:13:19.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:19.187]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:19.187]         }
[16:13:19.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:19.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:19.187]             base::sink(type = "output", split = FALSE)
[16:13:19.187]             base::close(...future.stdout)
[16:13:19.187]         }, add = TRUE)
[16:13:19.187]     }
[16:13:19.187]     ...future.frame <- base::sys.nframe()
[16:13:19.187]     ...future.conditions <- base::list()
[16:13:19.187]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:19.187]     if (FALSE) {
[16:13:19.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:19.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:19.187]     }
[16:13:19.187]     ...future.result <- base::tryCatch({
[16:13:19.187]         base::withCallingHandlers({
[16:13:19.187]             ...future.value <- base::withVisible(base::local({
[16:13:19.187]                 ...future.makeSendCondition <- local({
[16:13:19.187]                   sendCondition <- NULL
[16:13:19.187]                   function(frame = 1L) {
[16:13:19.187]                     if (is.function(sendCondition)) 
[16:13:19.187]                       return(sendCondition)
[16:13:19.187]                     ns <- getNamespace("parallel")
[16:13:19.187]                     if (exists("sendData", mode = "function", 
[16:13:19.187]                       envir = ns)) {
[16:13:19.187]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:19.187]                         envir = ns)
[16:13:19.187]                       envir <- sys.frame(frame)
[16:13:19.187]                       master <- NULL
[16:13:19.187]                       while (!identical(envir, .GlobalEnv) && 
[16:13:19.187]                         !identical(envir, emptyenv())) {
[16:13:19.187]                         if (exists("master", mode = "list", envir = envir, 
[16:13:19.187]                           inherits = FALSE)) {
[16:13:19.187]                           master <- get("master", mode = "list", 
[16:13:19.187]                             envir = envir, inherits = FALSE)
[16:13:19.187]                           if (inherits(master, c("SOCKnode", 
[16:13:19.187]                             "SOCK0node"))) {
[16:13:19.187]                             sendCondition <<- function(cond) {
[16:13:19.187]                               data <- list(type = "VALUE", value = cond, 
[16:13:19.187]                                 success = TRUE)
[16:13:19.187]                               parallel_sendData(master, data)
[16:13:19.187]                             }
[16:13:19.187]                             return(sendCondition)
[16:13:19.187]                           }
[16:13:19.187]                         }
[16:13:19.187]                         frame <- frame + 1L
[16:13:19.187]                         envir <- sys.frame(frame)
[16:13:19.187]                       }
[16:13:19.187]                     }
[16:13:19.187]                     sendCondition <<- function(cond) NULL
[16:13:19.187]                   }
[16:13:19.187]                 })
[16:13:19.187]                 withCallingHandlers({
[16:13:19.187]                   NA
[16:13:19.187]                 }, immediateCondition = function(cond) {
[16:13:19.187]                   sendCondition <- ...future.makeSendCondition()
[16:13:19.187]                   sendCondition(cond)
[16:13:19.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.187]                   {
[16:13:19.187]                     inherits <- base::inherits
[16:13:19.187]                     invokeRestart <- base::invokeRestart
[16:13:19.187]                     is.null <- base::is.null
[16:13:19.187]                     muffled <- FALSE
[16:13:19.187]                     if (inherits(cond, "message")) {
[16:13:19.187]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:19.187]                       if (muffled) 
[16:13:19.187]                         invokeRestart("muffleMessage")
[16:13:19.187]                     }
[16:13:19.187]                     else if (inherits(cond, "warning")) {
[16:13:19.187]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:19.187]                       if (muffled) 
[16:13:19.187]                         invokeRestart("muffleWarning")
[16:13:19.187]                     }
[16:13:19.187]                     else if (inherits(cond, "condition")) {
[16:13:19.187]                       if (!is.null(pattern)) {
[16:13:19.187]                         computeRestarts <- base::computeRestarts
[16:13:19.187]                         grepl <- base::grepl
[16:13:19.187]                         restarts <- computeRestarts(cond)
[16:13:19.187]                         for (restart in restarts) {
[16:13:19.187]                           name <- restart$name
[16:13:19.187]                           if (is.null(name)) 
[16:13:19.187]                             next
[16:13:19.187]                           if (!grepl(pattern, name)) 
[16:13:19.187]                             next
[16:13:19.187]                           invokeRestart(restart)
[16:13:19.187]                           muffled <- TRUE
[16:13:19.187]                           break
[16:13:19.187]                         }
[16:13:19.187]                       }
[16:13:19.187]                     }
[16:13:19.187]                     invisible(muffled)
[16:13:19.187]                   }
[16:13:19.187]                   muffleCondition(cond)
[16:13:19.187]                 })
[16:13:19.187]             }))
[16:13:19.187]             future::FutureResult(value = ...future.value$value, 
[16:13:19.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.187]                   ...future.rng), globalenv = if (FALSE) 
[16:13:19.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:19.187]                     ...future.globalenv.names))
[16:13:19.187]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:19.187]         }, condition = base::local({
[16:13:19.187]             c <- base::c
[16:13:19.187]             inherits <- base::inherits
[16:13:19.187]             invokeRestart <- base::invokeRestart
[16:13:19.187]             length <- base::length
[16:13:19.187]             list <- base::list
[16:13:19.187]             seq.int <- base::seq.int
[16:13:19.187]             signalCondition <- base::signalCondition
[16:13:19.187]             sys.calls <- base::sys.calls
[16:13:19.187]             `[[` <- base::`[[`
[16:13:19.187]             `+` <- base::`+`
[16:13:19.187]             `<<-` <- base::`<<-`
[16:13:19.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:19.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:19.187]                   3L)]
[16:13:19.187]             }
[16:13:19.187]             function(cond) {
[16:13:19.187]                 is_error <- inherits(cond, "error")
[16:13:19.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:19.187]                   NULL)
[16:13:19.187]                 if (is_error) {
[16:13:19.187]                   sessionInformation <- function() {
[16:13:19.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:19.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:19.187]                       search = base::search(), system = base::Sys.info())
[16:13:19.187]                   }
[16:13:19.187]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:19.187]                     cond$call), session = sessionInformation(), 
[16:13:19.187]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:19.187]                   signalCondition(cond)
[16:13:19.187]                 }
[16:13:19.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:19.187]                 "immediateCondition"))) {
[16:13:19.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:19.187]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:19.187]                   if (TRUE && !signal) {
[16:13:19.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.187]                     {
[16:13:19.187]                       inherits <- base::inherits
[16:13:19.187]                       invokeRestart <- base::invokeRestart
[16:13:19.187]                       is.null <- base::is.null
[16:13:19.187]                       muffled <- FALSE
[16:13:19.187]                       if (inherits(cond, "message")) {
[16:13:19.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.187]                         if (muffled) 
[16:13:19.187]                           invokeRestart("muffleMessage")
[16:13:19.187]                       }
[16:13:19.187]                       else if (inherits(cond, "warning")) {
[16:13:19.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.187]                         if (muffled) 
[16:13:19.187]                           invokeRestart("muffleWarning")
[16:13:19.187]                       }
[16:13:19.187]                       else if (inherits(cond, "condition")) {
[16:13:19.187]                         if (!is.null(pattern)) {
[16:13:19.187]                           computeRestarts <- base::computeRestarts
[16:13:19.187]                           grepl <- base::grepl
[16:13:19.187]                           restarts <- computeRestarts(cond)
[16:13:19.187]                           for (restart in restarts) {
[16:13:19.187]                             name <- restart$name
[16:13:19.187]                             if (is.null(name)) 
[16:13:19.187]                               next
[16:13:19.187]                             if (!grepl(pattern, name)) 
[16:13:19.187]                               next
[16:13:19.187]                             invokeRestart(restart)
[16:13:19.187]                             muffled <- TRUE
[16:13:19.187]                             break
[16:13:19.187]                           }
[16:13:19.187]                         }
[16:13:19.187]                       }
[16:13:19.187]                       invisible(muffled)
[16:13:19.187]                     }
[16:13:19.187]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.187]                   }
[16:13:19.187]                 }
[16:13:19.187]                 else {
[16:13:19.187]                   if (TRUE) {
[16:13:19.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.187]                     {
[16:13:19.187]                       inherits <- base::inherits
[16:13:19.187]                       invokeRestart <- base::invokeRestart
[16:13:19.187]                       is.null <- base::is.null
[16:13:19.187]                       muffled <- FALSE
[16:13:19.187]                       if (inherits(cond, "message")) {
[16:13:19.187]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.187]                         if (muffled) 
[16:13:19.187]                           invokeRestart("muffleMessage")
[16:13:19.187]                       }
[16:13:19.187]                       else if (inherits(cond, "warning")) {
[16:13:19.187]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.187]                         if (muffled) 
[16:13:19.187]                           invokeRestart("muffleWarning")
[16:13:19.187]                       }
[16:13:19.187]                       else if (inherits(cond, "condition")) {
[16:13:19.187]                         if (!is.null(pattern)) {
[16:13:19.187]                           computeRestarts <- base::computeRestarts
[16:13:19.187]                           grepl <- base::grepl
[16:13:19.187]                           restarts <- computeRestarts(cond)
[16:13:19.187]                           for (restart in restarts) {
[16:13:19.187]                             name <- restart$name
[16:13:19.187]                             if (is.null(name)) 
[16:13:19.187]                               next
[16:13:19.187]                             if (!grepl(pattern, name)) 
[16:13:19.187]                               next
[16:13:19.187]                             invokeRestart(restart)
[16:13:19.187]                             muffled <- TRUE
[16:13:19.187]                             break
[16:13:19.187]                           }
[16:13:19.187]                         }
[16:13:19.187]                       }
[16:13:19.187]                       invisible(muffled)
[16:13:19.187]                     }
[16:13:19.187]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.187]                   }
[16:13:19.187]                 }
[16:13:19.187]             }
[16:13:19.187]         }))
[16:13:19.187]     }, error = function(ex) {
[16:13:19.187]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:19.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.187]                 ...future.rng), started = ...future.startTime, 
[16:13:19.187]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:19.187]             version = "1.8"), class = "FutureResult")
[16:13:19.187]     }, finally = {
[16:13:19.187]         if (!identical(...future.workdir, getwd())) 
[16:13:19.187]             setwd(...future.workdir)
[16:13:19.187]         {
[16:13:19.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:19.187]                 ...future.oldOptions$nwarnings <- NULL
[16:13:19.187]             }
[16:13:19.187]             base::options(...future.oldOptions)
[16:13:19.187]             if (.Platform$OS.type == "windows") {
[16:13:19.187]                 old_names <- names(...future.oldEnvVars)
[16:13:19.187]                 envs <- base::Sys.getenv()
[16:13:19.187]                 names <- names(envs)
[16:13:19.187]                 common <- intersect(names, old_names)
[16:13:19.187]                 added <- setdiff(names, old_names)
[16:13:19.187]                 removed <- setdiff(old_names, names)
[16:13:19.187]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:19.187]                   envs[common]]
[16:13:19.187]                 NAMES <- toupper(changed)
[16:13:19.187]                 args <- list()
[16:13:19.187]                 for (kk in seq_along(NAMES)) {
[16:13:19.187]                   name <- changed[[kk]]
[16:13:19.187]                   NAME <- NAMES[[kk]]
[16:13:19.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.187]                     next
[16:13:19.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.187]                 }
[16:13:19.187]                 NAMES <- toupper(added)
[16:13:19.187]                 for (kk in seq_along(NAMES)) {
[16:13:19.187]                   name <- added[[kk]]
[16:13:19.187]                   NAME <- NAMES[[kk]]
[16:13:19.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.187]                     next
[16:13:19.187]                   args[[name]] <- ""
[16:13:19.187]                 }
[16:13:19.187]                 NAMES <- toupper(removed)
[16:13:19.187]                 for (kk in seq_along(NAMES)) {
[16:13:19.187]                   name <- removed[[kk]]
[16:13:19.187]                   NAME <- NAMES[[kk]]
[16:13:19.187]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.187]                     next
[16:13:19.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.187]                 }
[16:13:19.187]                 if (length(args) > 0) 
[16:13:19.187]                   base::do.call(base::Sys.setenv, args = args)
[16:13:19.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:19.187]             }
[16:13:19.187]             else {
[16:13:19.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:19.187]             }
[16:13:19.187]             {
[16:13:19.187]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:19.187]                   0L) {
[16:13:19.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:19.187]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:19.187]                   base::options(opts)
[16:13:19.187]                 }
[16:13:19.187]                 {
[16:13:19.187]                   {
[16:13:19.187]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:19.187]                     NULL
[16:13:19.187]                   }
[16:13:19.187]                   options(future.plan = NULL)
[16:13:19.187]                   if (is.na(NA_character_)) 
[16:13:19.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:19.187]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:19.187]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.187]                     envir = parent.frame()) 
[16:13:19.187]                   {
[16:13:19.187]                     if (is.function(workers)) 
[16:13:19.187]                       workers <- workers()
[16:13:19.187]                     workers <- structure(as.integer(workers), 
[16:13:19.187]                       class = class(workers))
[16:13:19.187]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.187]                       workers >= 1)
[16:13:19.187]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.187]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.187]                     }
[16:13:19.187]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.187]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.187]                       envir = envir)
[16:13:19.187]                     if (!future$lazy) 
[16:13:19.187]                       future <- run(future)
[16:13:19.187]                     invisible(future)
[16:13:19.187]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:19.187]                     envir = parent.frame()) 
[16:13:19.187]                   {
[16:13:19.187]                     default_workers <- missing(workers)
[16:13:19.187]                     if (is.function(workers)) 
[16:13:19.187]                       workers <- workers()
[16:13:19.187]                     workers <- structure(as.integer(workers), 
[16:13:19.187]                       class = class(workers))
[16:13:19.187]                     stop_if_not(is.finite(workers), workers >= 
[16:13:19.187]                       1L)
[16:13:19.187]                     if ((workers == 1L && !inherits(workers, 
[16:13:19.187]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:19.187]                       if (default_workers) 
[16:13:19.187]                         supportsMulticore(warn = TRUE)
[16:13:19.187]                       return(sequential(..., envir = envir))
[16:13:19.187]                     }
[16:13:19.187]                     oopts <- options(mc.cores = workers)
[16:13:19.187]                     on.exit(options(oopts))
[16:13:19.187]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:19.187]                       envir = envir)
[16:13:19.187]                     if (!future$lazy) 
[16:13:19.187]                       future <- run(future)
[16:13:19.187]                     invisible(future)
[16:13:19.187]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.187]                 }
[16:13:19.187]             }
[16:13:19.187]         }
[16:13:19.187]     })
[16:13:19.187]     if (TRUE) {
[16:13:19.187]         base::sink(type = "output", split = FALSE)
[16:13:19.187]         if (TRUE) {
[16:13:19.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:19.187]         }
[16:13:19.187]         else {
[16:13:19.187]             ...future.result["stdout"] <- base::list(NULL)
[16:13:19.187]         }
[16:13:19.187]         base::close(...future.stdout)
[16:13:19.187]         ...future.stdout <- NULL
[16:13:19.187]     }
[16:13:19.187]     ...future.result$conditions <- ...future.conditions
[16:13:19.187]     ...future.result$finished <- base::Sys.time()
[16:13:19.187]     ...future.result
[16:13:19.187] }
[16:13:19.258] MultisessionFuture started
[16:13:19.258] result() for ClusterFuture ...
[16:13:19.258] receiveMessageFromWorker() for ClusterFuture ...
[16:13:19.258] - Validating connection of MultisessionFuture
[16:13:19.295] - received message: FutureResult
[16:13:19.296] - Received FutureResult
[16:13:19.296] - Erased future from FutureRegistry
[16:13:19.296] result() for ClusterFuture ...
[16:13:19.296] - result already collected: FutureResult
[16:13:19.296] result() for ClusterFuture ... done
[16:13:19.296] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:19.296] result() for ClusterFuture ... done
[16:13:19.296] result() for ClusterFuture ...
[16:13:19.297] - result already collected: FutureResult
[16:13:19.297] result() for ClusterFuture ... done
[16:13:19.297] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:13:19.300] plan(): nbrOfWorkers() = 2
[16:13:19.300] getGlobalsAndPackages() ...
[16:13:19.301] Searching for globals...
[16:13:19.319] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:19.319] Searching for globals ... DONE
[16:13:19.319] Resolving globals: FALSE
[16:13:19.320] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[16:13:19.320] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:19.321] - globals: [2] ‘nested’, ‘strategy2’
[16:13:19.321] - packages: [1] ‘future’
[16:13:19.321] getGlobalsAndPackages() ... DONE
[16:13:19.321] run() for ‘Future’ ...
[16:13:19.321] - state: ‘created’
[16:13:19.321] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:19.336] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:19.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:19.336]   - Field: ‘node’
[16:13:19.336]   - Field: ‘label’
[16:13:19.336]   - Field: ‘local’
[16:13:19.336]   - Field: ‘owner’
[16:13:19.336]   - Field: ‘envir’
[16:13:19.336]   - Field: ‘workers’
[16:13:19.336]   - Field: ‘packages’
[16:13:19.337]   - Field: ‘gc’
[16:13:19.337]   - Field: ‘conditions’
[16:13:19.337]   - Field: ‘persistent’
[16:13:19.337]   - Field: ‘expr’
[16:13:19.337]   - Field: ‘uuid’
[16:13:19.337]   - Field: ‘seed’
[16:13:19.337]   - Field: ‘version’
[16:13:19.337]   - Field: ‘result’
[16:13:19.337]   - Field: ‘asynchronous’
[16:13:19.337]   - Field: ‘calls’
[16:13:19.337]   - Field: ‘globals’
[16:13:19.338]   - Field: ‘stdout’
[16:13:19.338]   - Field: ‘earlySignal’
[16:13:19.338]   - Field: ‘lazy’
[16:13:19.338]   - Field: ‘state’
[16:13:19.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:19.338] - Launch lazy future ...
[16:13:19.338] Packages needed by the future expression (n = 1): ‘future’
[16:13:19.338] Packages needed by future strategies (n = 1): ‘future’
[16:13:19.339] {
[16:13:19.339]     {
[16:13:19.339]         {
[16:13:19.339]             ...future.startTime <- base::Sys.time()
[16:13:19.339]             {
[16:13:19.339]                 {
[16:13:19.339]                   {
[16:13:19.339]                     {
[16:13:19.339]                       {
[16:13:19.339]                         base::local({
[16:13:19.339]                           has_future <- base::requireNamespace("future", 
[16:13:19.339]                             quietly = TRUE)
[16:13:19.339]                           if (has_future) {
[16:13:19.339]                             ns <- base::getNamespace("future")
[16:13:19.339]                             version <- ns[[".package"]][["version"]]
[16:13:19.339]                             if (is.null(version)) 
[16:13:19.339]                               version <- utils::packageVersion("future")
[16:13:19.339]                           }
[16:13:19.339]                           else {
[16:13:19.339]                             version <- NULL
[16:13:19.339]                           }
[16:13:19.339]                           if (!has_future || version < "1.8.0") {
[16:13:19.339]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:19.339]                               "", base::R.version$version.string), 
[16:13:19.339]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:19.339]                                 base::R.version$platform, 8 * 
[16:13:19.339]                                   base::.Machine$sizeof.pointer), 
[16:13:19.339]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:19.339]                                 "release", "version")], collapse = " "), 
[16:13:19.339]                               hostname = base::Sys.info()[["nodename"]])
[16:13:19.339]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:19.339]                               info)
[16:13:19.339]                             info <- base::paste(info, collapse = "; ")
[16:13:19.339]                             if (!has_future) {
[16:13:19.339]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:19.339]                                 info)
[16:13:19.339]                             }
[16:13:19.339]                             else {
[16:13:19.339]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:19.339]                                 info, version)
[16:13:19.339]                             }
[16:13:19.339]                             base::stop(msg)
[16:13:19.339]                           }
[16:13:19.339]                         })
[16:13:19.339]                       }
[16:13:19.339]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:19.339]                       base::options(mc.cores = 1L)
[16:13:19.339]                     }
[16:13:19.339]                     base::local({
[16:13:19.339]                       for (pkg in "future") {
[16:13:19.339]                         base::loadNamespace(pkg)
[16:13:19.339]                         base::library(pkg, character.only = TRUE)
[16:13:19.339]                       }
[16:13:19.339]                     })
[16:13:19.339]                   }
[16:13:19.339]                   options(future.plan = NULL)
[16:13:19.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.339]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:19.339]                     envir = parent.frame()) 
[16:13:19.339]                   {
[16:13:19.339]                     default_workers <- missing(workers)
[16:13:19.339]                     if (is.function(workers)) 
[16:13:19.339]                       workers <- workers()
[16:13:19.339]                     workers <- structure(as.integer(workers), 
[16:13:19.339]                       class = class(workers))
[16:13:19.339]                     stop_if_not(is.finite(workers), workers >= 
[16:13:19.339]                       1L)
[16:13:19.339]                     if ((workers == 1L && !inherits(workers, 
[16:13:19.339]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:19.339]                       if (default_workers) 
[16:13:19.339]                         supportsMulticore(warn = TRUE)
[16:13:19.339]                       return(sequential(..., envir = envir))
[16:13:19.339]                     }
[16:13:19.339]                     oopts <- options(mc.cores = workers)
[16:13:19.339]                     on.exit(options(oopts))
[16:13:19.339]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:19.339]                       envir = envir)
[16:13:19.339]                     if (!future$lazy) 
[16:13:19.339]                       future <- run(future)
[16:13:19.339]                     invisible(future)
[16:13:19.339]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.339]                 }
[16:13:19.339]                 ...future.workdir <- getwd()
[16:13:19.339]             }
[16:13:19.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:19.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:19.339]         }
[16:13:19.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:19.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:19.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:19.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:19.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:19.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:19.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:19.339]             base::names(...future.oldOptions))
[16:13:19.339]     }
[16:13:19.339]     if (FALSE) {
[16:13:19.339]     }
[16:13:19.339]     else {
[16:13:19.339]         if (TRUE) {
[16:13:19.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:19.339]                 open = "w")
[16:13:19.339]         }
[16:13:19.339]         else {
[16:13:19.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:19.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:19.339]         }
[16:13:19.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:19.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:19.339]             base::sink(type = "output", split = FALSE)
[16:13:19.339]             base::close(...future.stdout)
[16:13:19.339]         }, add = TRUE)
[16:13:19.339]     }
[16:13:19.339]     ...future.frame <- base::sys.nframe()
[16:13:19.339]     ...future.conditions <- base::list()
[16:13:19.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:19.339]     if (FALSE) {
[16:13:19.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:19.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:19.339]     }
[16:13:19.339]     ...future.result <- base::tryCatch({
[16:13:19.339]         base::withCallingHandlers({
[16:13:19.339]             ...future.value <- base::withVisible(base::local({
[16:13:19.339]                 ...future.makeSendCondition <- local({
[16:13:19.339]                   sendCondition <- NULL
[16:13:19.339]                   function(frame = 1L) {
[16:13:19.339]                     if (is.function(sendCondition)) 
[16:13:19.339]                       return(sendCondition)
[16:13:19.339]                     ns <- getNamespace("parallel")
[16:13:19.339]                     if (exists("sendData", mode = "function", 
[16:13:19.339]                       envir = ns)) {
[16:13:19.339]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:19.339]                         envir = ns)
[16:13:19.339]                       envir <- sys.frame(frame)
[16:13:19.339]                       master <- NULL
[16:13:19.339]                       while (!identical(envir, .GlobalEnv) && 
[16:13:19.339]                         !identical(envir, emptyenv())) {
[16:13:19.339]                         if (exists("master", mode = "list", envir = envir, 
[16:13:19.339]                           inherits = FALSE)) {
[16:13:19.339]                           master <- get("master", mode = "list", 
[16:13:19.339]                             envir = envir, inherits = FALSE)
[16:13:19.339]                           if (inherits(master, c("SOCKnode", 
[16:13:19.339]                             "SOCK0node"))) {
[16:13:19.339]                             sendCondition <<- function(cond) {
[16:13:19.339]                               data <- list(type = "VALUE", value = cond, 
[16:13:19.339]                                 success = TRUE)
[16:13:19.339]                               parallel_sendData(master, data)
[16:13:19.339]                             }
[16:13:19.339]                             return(sendCondition)
[16:13:19.339]                           }
[16:13:19.339]                         }
[16:13:19.339]                         frame <- frame + 1L
[16:13:19.339]                         envir <- sys.frame(frame)
[16:13:19.339]                       }
[16:13:19.339]                     }
[16:13:19.339]                     sendCondition <<- function(cond) NULL
[16:13:19.339]                   }
[16:13:19.339]                 })
[16:13:19.339]                 withCallingHandlers({
[16:13:19.339]                   {
[16:13:19.339]                     a <- 1L
[16:13:19.339]                     plan_a <- unclass(future::plan("list"))
[16:13:19.339]                     nested_a <- nested[-1]
[16:13:19.339]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:19.339]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:19.339]                       strategy2))
[16:13:19.339]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:19.339]                       "init") <- NULL
[16:13:19.339]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:19.339]                       "init") <- NULL
[16:13:19.339]                     stopifnot(all.equal(plan_a, nested_a))
[16:13:19.339]                     y %<-% {
[16:13:19.339]                       b <- 2L
[16:13:19.339]                       plan_b <- future::plan("list")
[16:13:19.339]                       nested_b <- nested_a[-1]
[16:13:19.339]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:19.339]                         1L, inherits(plan_b[[1]], "future"), 
[16:13:19.339]                         inherits(future::plan("next"), "sequential"))
[16:13:19.339]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:19.339]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:19.339]                     }
[16:13:19.339]                     y
[16:13:19.339]                   }
[16:13:19.339]                 }, immediateCondition = function(cond) {
[16:13:19.339]                   sendCondition <- ...future.makeSendCondition()
[16:13:19.339]                   sendCondition(cond)
[16:13:19.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.339]                   {
[16:13:19.339]                     inherits <- base::inherits
[16:13:19.339]                     invokeRestart <- base::invokeRestart
[16:13:19.339]                     is.null <- base::is.null
[16:13:19.339]                     muffled <- FALSE
[16:13:19.339]                     if (inherits(cond, "message")) {
[16:13:19.339]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:19.339]                       if (muffled) 
[16:13:19.339]                         invokeRestart("muffleMessage")
[16:13:19.339]                     }
[16:13:19.339]                     else if (inherits(cond, "warning")) {
[16:13:19.339]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:19.339]                       if (muffled) 
[16:13:19.339]                         invokeRestart("muffleWarning")
[16:13:19.339]                     }
[16:13:19.339]                     else if (inherits(cond, "condition")) {
[16:13:19.339]                       if (!is.null(pattern)) {
[16:13:19.339]                         computeRestarts <- base::computeRestarts
[16:13:19.339]                         grepl <- base::grepl
[16:13:19.339]                         restarts <- computeRestarts(cond)
[16:13:19.339]                         for (restart in restarts) {
[16:13:19.339]                           name <- restart$name
[16:13:19.339]                           if (is.null(name)) 
[16:13:19.339]                             next
[16:13:19.339]                           if (!grepl(pattern, name)) 
[16:13:19.339]                             next
[16:13:19.339]                           invokeRestart(restart)
[16:13:19.339]                           muffled <- TRUE
[16:13:19.339]                           break
[16:13:19.339]                         }
[16:13:19.339]                       }
[16:13:19.339]                     }
[16:13:19.339]                     invisible(muffled)
[16:13:19.339]                   }
[16:13:19.339]                   muffleCondition(cond)
[16:13:19.339]                 })
[16:13:19.339]             }))
[16:13:19.339]             future::FutureResult(value = ...future.value$value, 
[16:13:19.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.339]                   ...future.rng), globalenv = if (FALSE) 
[16:13:19.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:19.339]                     ...future.globalenv.names))
[16:13:19.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:19.339]         }, condition = base::local({
[16:13:19.339]             c <- base::c
[16:13:19.339]             inherits <- base::inherits
[16:13:19.339]             invokeRestart <- base::invokeRestart
[16:13:19.339]             length <- base::length
[16:13:19.339]             list <- base::list
[16:13:19.339]             seq.int <- base::seq.int
[16:13:19.339]             signalCondition <- base::signalCondition
[16:13:19.339]             sys.calls <- base::sys.calls
[16:13:19.339]             `[[` <- base::`[[`
[16:13:19.339]             `+` <- base::`+`
[16:13:19.339]             `<<-` <- base::`<<-`
[16:13:19.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:19.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:19.339]                   3L)]
[16:13:19.339]             }
[16:13:19.339]             function(cond) {
[16:13:19.339]                 is_error <- inherits(cond, "error")
[16:13:19.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:19.339]                   NULL)
[16:13:19.339]                 if (is_error) {
[16:13:19.339]                   sessionInformation <- function() {
[16:13:19.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:19.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:19.339]                       search = base::search(), system = base::Sys.info())
[16:13:19.339]                   }
[16:13:19.339]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:19.339]                     cond$call), session = sessionInformation(), 
[16:13:19.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:19.339]                   signalCondition(cond)
[16:13:19.339]                 }
[16:13:19.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:19.339]                 "immediateCondition"))) {
[16:13:19.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:19.339]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:19.339]                   if (TRUE && !signal) {
[16:13:19.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.339]                     {
[16:13:19.339]                       inherits <- base::inherits
[16:13:19.339]                       invokeRestart <- base::invokeRestart
[16:13:19.339]                       is.null <- base::is.null
[16:13:19.339]                       muffled <- FALSE
[16:13:19.339]                       if (inherits(cond, "message")) {
[16:13:19.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.339]                         if (muffled) 
[16:13:19.339]                           invokeRestart("muffleMessage")
[16:13:19.339]                       }
[16:13:19.339]                       else if (inherits(cond, "warning")) {
[16:13:19.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.339]                         if (muffled) 
[16:13:19.339]                           invokeRestart("muffleWarning")
[16:13:19.339]                       }
[16:13:19.339]                       else if (inherits(cond, "condition")) {
[16:13:19.339]                         if (!is.null(pattern)) {
[16:13:19.339]                           computeRestarts <- base::computeRestarts
[16:13:19.339]                           grepl <- base::grepl
[16:13:19.339]                           restarts <- computeRestarts(cond)
[16:13:19.339]                           for (restart in restarts) {
[16:13:19.339]                             name <- restart$name
[16:13:19.339]                             if (is.null(name)) 
[16:13:19.339]                               next
[16:13:19.339]                             if (!grepl(pattern, name)) 
[16:13:19.339]                               next
[16:13:19.339]                             invokeRestart(restart)
[16:13:19.339]                             muffled <- TRUE
[16:13:19.339]                             break
[16:13:19.339]                           }
[16:13:19.339]                         }
[16:13:19.339]                       }
[16:13:19.339]                       invisible(muffled)
[16:13:19.339]                     }
[16:13:19.339]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.339]                   }
[16:13:19.339]                 }
[16:13:19.339]                 else {
[16:13:19.339]                   if (TRUE) {
[16:13:19.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.339]                     {
[16:13:19.339]                       inherits <- base::inherits
[16:13:19.339]                       invokeRestart <- base::invokeRestart
[16:13:19.339]                       is.null <- base::is.null
[16:13:19.339]                       muffled <- FALSE
[16:13:19.339]                       if (inherits(cond, "message")) {
[16:13:19.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.339]                         if (muffled) 
[16:13:19.339]                           invokeRestart("muffleMessage")
[16:13:19.339]                       }
[16:13:19.339]                       else if (inherits(cond, "warning")) {
[16:13:19.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.339]                         if (muffled) 
[16:13:19.339]                           invokeRestart("muffleWarning")
[16:13:19.339]                       }
[16:13:19.339]                       else if (inherits(cond, "condition")) {
[16:13:19.339]                         if (!is.null(pattern)) {
[16:13:19.339]                           computeRestarts <- base::computeRestarts
[16:13:19.339]                           grepl <- base::grepl
[16:13:19.339]                           restarts <- computeRestarts(cond)
[16:13:19.339]                           for (restart in restarts) {
[16:13:19.339]                             name <- restart$name
[16:13:19.339]                             if (is.null(name)) 
[16:13:19.339]                               next
[16:13:19.339]                             if (!grepl(pattern, name)) 
[16:13:19.339]                               next
[16:13:19.339]                             invokeRestart(restart)
[16:13:19.339]                             muffled <- TRUE
[16:13:19.339]                             break
[16:13:19.339]                           }
[16:13:19.339]                         }
[16:13:19.339]                       }
[16:13:19.339]                       invisible(muffled)
[16:13:19.339]                     }
[16:13:19.339]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.339]                   }
[16:13:19.339]                 }
[16:13:19.339]             }
[16:13:19.339]         }))
[16:13:19.339]     }, error = function(ex) {
[16:13:19.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:19.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.339]                 ...future.rng), started = ...future.startTime, 
[16:13:19.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:19.339]             version = "1.8"), class = "FutureResult")
[16:13:19.339]     }, finally = {
[16:13:19.339]         if (!identical(...future.workdir, getwd())) 
[16:13:19.339]             setwd(...future.workdir)
[16:13:19.339]         {
[16:13:19.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:19.339]                 ...future.oldOptions$nwarnings <- NULL
[16:13:19.339]             }
[16:13:19.339]             base::options(...future.oldOptions)
[16:13:19.339]             if (.Platform$OS.type == "windows") {
[16:13:19.339]                 old_names <- names(...future.oldEnvVars)
[16:13:19.339]                 envs <- base::Sys.getenv()
[16:13:19.339]                 names <- names(envs)
[16:13:19.339]                 common <- intersect(names, old_names)
[16:13:19.339]                 added <- setdiff(names, old_names)
[16:13:19.339]                 removed <- setdiff(old_names, names)
[16:13:19.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:19.339]                   envs[common]]
[16:13:19.339]                 NAMES <- toupper(changed)
[16:13:19.339]                 args <- list()
[16:13:19.339]                 for (kk in seq_along(NAMES)) {
[16:13:19.339]                   name <- changed[[kk]]
[16:13:19.339]                   NAME <- NAMES[[kk]]
[16:13:19.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.339]                     next
[16:13:19.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.339]                 }
[16:13:19.339]                 NAMES <- toupper(added)
[16:13:19.339]                 for (kk in seq_along(NAMES)) {
[16:13:19.339]                   name <- added[[kk]]
[16:13:19.339]                   NAME <- NAMES[[kk]]
[16:13:19.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.339]                     next
[16:13:19.339]                   args[[name]] <- ""
[16:13:19.339]                 }
[16:13:19.339]                 NAMES <- toupper(removed)
[16:13:19.339]                 for (kk in seq_along(NAMES)) {
[16:13:19.339]                   name <- removed[[kk]]
[16:13:19.339]                   NAME <- NAMES[[kk]]
[16:13:19.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.339]                     next
[16:13:19.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.339]                 }
[16:13:19.339]                 if (length(args) > 0) 
[16:13:19.339]                   base::do.call(base::Sys.setenv, args = args)
[16:13:19.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:19.339]             }
[16:13:19.339]             else {
[16:13:19.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:19.339]             }
[16:13:19.339]             {
[16:13:19.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:19.339]                   0L) {
[16:13:19.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:19.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:19.339]                   base::options(opts)
[16:13:19.339]                 }
[16:13:19.339]                 {
[16:13:19.339]                   {
[16:13:19.339]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:19.339]                     NULL
[16:13:19.339]                   }
[16:13:19.339]                   options(future.plan = NULL)
[16:13:19.339]                   if (is.na(NA_character_)) 
[16:13:19.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:19.339]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:19.339]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.339]                     envir = parent.frame()) 
[16:13:19.339]                   {
[16:13:19.339]                     if (is.function(workers)) 
[16:13:19.339]                       workers <- workers()
[16:13:19.339]                     workers <- structure(as.integer(workers), 
[16:13:19.339]                       class = class(workers))
[16:13:19.339]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.339]                       workers >= 1)
[16:13:19.339]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.339]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.339]                     }
[16:13:19.339]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.339]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.339]                       envir = envir)
[16:13:19.339]                     if (!future$lazy) 
[16:13:19.339]                       future <- run(future)
[16:13:19.339]                     invisible(future)
[16:13:19.339]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:19.339]                     envir = parent.frame()) 
[16:13:19.339]                   {
[16:13:19.339]                     default_workers <- missing(workers)
[16:13:19.339]                     if (is.function(workers)) 
[16:13:19.339]                       workers <- workers()
[16:13:19.339]                     workers <- structure(as.integer(workers), 
[16:13:19.339]                       class = class(workers))
[16:13:19.339]                     stop_if_not(is.finite(workers), workers >= 
[16:13:19.339]                       1L)
[16:13:19.339]                     if ((workers == 1L && !inherits(workers, 
[16:13:19.339]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:19.339]                       if (default_workers) 
[16:13:19.339]                         supportsMulticore(warn = TRUE)
[16:13:19.339]                       return(sequential(..., envir = envir))
[16:13:19.339]                     }
[16:13:19.339]                     oopts <- options(mc.cores = workers)
[16:13:19.339]                     on.exit(options(oopts))
[16:13:19.339]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:19.339]                       envir = envir)
[16:13:19.339]                     if (!future$lazy) 
[16:13:19.339]                       future <- run(future)
[16:13:19.339]                     invisible(future)
[16:13:19.339]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.339]                 }
[16:13:19.339]             }
[16:13:19.339]         }
[16:13:19.339]     })
[16:13:19.339]     if (TRUE) {
[16:13:19.339]         base::sink(type = "output", split = FALSE)
[16:13:19.339]         if (TRUE) {
[16:13:19.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:19.339]         }
[16:13:19.339]         else {
[16:13:19.339]             ...future.result["stdout"] <- base::list(NULL)
[16:13:19.339]         }
[16:13:19.339]         base::close(...future.stdout)
[16:13:19.339]         ...future.stdout <- NULL
[16:13:19.339]     }
[16:13:19.339]     ...future.result$conditions <- ...future.conditions
[16:13:19.339]     ...future.result$finished <- base::Sys.time()
[16:13:19.339]     ...future.result
[16:13:19.339] }
[16:13:19.342] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[16:13:19.342] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[16:13:19.384] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[16:13:19.384] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:13:19.384] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:13:19.385] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[16:13:19.385] MultisessionFuture started
[16:13:19.385] - Launch lazy future ... done
[16:13:19.386] run() for ‘MultisessionFuture’ ... done
[16:13:19.386] result() for ClusterFuture ...
[16:13:19.386] receiveMessageFromWorker() for ClusterFuture ...
[16:13:19.386] - Validating connection of MultisessionFuture
[16:13:19.464] - received message: FutureResult
[16:13:19.464] - Received FutureResult
[16:13:19.464] - Erased future from FutureRegistry
[16:13:19.464] result() for ClusterFuture ...
[16:13:19.464] - result already collected: FutureResult
[16:13:19.464] result() for ClusterFuture ... done
[16:13:19.465] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:19.465] result() for ClusterFuture ... done
[16:13:19.465] result() for ClusterFuture ...
[16:13:19.465] - result already collected: FutureResult
[16:13:19.465] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:19.470] getGlobalsAndPackages() ...
[16:13:19.470] Searching for globals...
[16:13:19.471] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:19.472] Searching for globals ... DONE
[16:13:19.472] Resolving globals: FALSE
[16:13:19.472] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:19.473] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:19.473] - globals: [1] ‘data’
[16:13:19.473] - packages: [1] ‘future’
[16:13:19.473] getGlobalsAndPackages() ... DONE
[16:13:19.473] run() for ‘Future’ ...
[16:13:19.473] - state: ‘created’
[16:13:19.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:19.488] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:19.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:19.488]   - Field: ‘node’
[16:13:19.488]   - Field: ‘label’
[16:13:19.488]   - Field: ‘local’
[16:13:19.488]   - Field: ‘owner’
[16:13:19.489]   - Field: ‘envir’
[16:13:19.489]   - Field: ‘workers’
[16:13:19.489]   - Field: ‘packages’
[16:13:19.489]   - Field: ‘gc’
[16:13:19.489]   - Field: ‘conditions’
[16:13:19.489]   - Field: ‘persistent’
[16:13:19.489]   - Field: ‘expr’
[16:13:19.489]   - Field: ‘uuid’
[16:13:19.489]   - Field: ‘seed’
[16:13:19.489]   - Field: ‘version’
[16:13:19.489]   - Field: ‘result’
[16:13:19.490]   - Field: ‘asynchronous’
[16:13:19.490]   - Field: ‘calls’
[16:13:19.490]   - Field: ‘globals’
[16:13:19.490]   - Field: ‘stdout’
[16:13:19.490]   - Field: ‘earlySignal’
[16:13:19.490]   - Field: ‘lazy’
[16:13:19.490]   - Field: ‘state’
[16:13:19.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:19.490] - Launch lazy future ...
[16:13:19.491] Packages needed by the future expression (n = 1): ‘future’
[16:13:19.491] Packages needed by future strategies (n = 1): ‘future’
[16:13:19.491] {
[16:13:19.491]     {
[16:13:19.491]         {
[16:13:19.491]             ...future.startTime <- base::Sys.time()
[16:13:19.491]             {
[16:13:19.491]                 {
[16:13:19.491]                   {
[16:13:19.491]                     {
[16:13:19.491]                       {
[16:13:19.491]                         base::local({
[16:13:19.491]                           has_future <- base::requireNamespace("future", 
[16:13:19.491]                             quietly = TRUE)
[16:13:19.491]                           if (has_future) {
[16:13:19.491]                             ns <- base::getNamespace("future")
[16:13:19.491]                             version <- ns[[".package"]][["version"]]
[16:13:19.491]                             if (is.null(version)) 
[16:13:19.491]                               version <- utils::packageVersion("future")
[16:13:19.491]                           }
[16:13:19.491]                           else {
[16:13:19.491]                             version <- NULL
[16:13:19.491]                           }
[16:13:19.491]                           if (!has_future || version < "1.8.0") {
[16:13:19.491]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:19.491]                               "", base::R.version$version.string), 
[16:13:19.491]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:19.491]                                 base::R.version$platform, 8 * 
[16:13:19.491]                                   base::.Machine$sizeof.pointer), 
[16:13:19.491]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:19.491]                                 "release", "version")], collapse = " "), 
[16:13:19.491]                               hostname = base::Sys.info()[["nodename"]])
[16:13:19.491]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:19.491]                               info)
[16:13:19.491]                             info <- base::paste(info, collapse = "; ")
[16:13:19.491]                             if (!has_future) {
[16:13:19.491]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:19.491]                                 info)
[16:13:19.491]                             }
[16:13:19.491]                             else {
[16:13:19.491]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:19.491]                                 info, version)
[16:13:19.491]                             }
[16:13:19.491]                             base::stop(msg)
[16:13:19.491]                           }
[16:13:19.491]                         })
[16:13:19.491]                       }
[16:13:19.491]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:19.491]                       base::options(mc.cores = 1L)
[16:13:19.491]                     }
[16:13:19.491]                     base::local({
[16:13:19.491]                       for (pkg in "future") {
[16:13:19.491]                         base::loadNamespace(pkg)
[16:13:19.491]                         base::library(pkg, character.only = TRUE)
[16:13:19.491]                       }
[16:13:19.491]                     })
[16:13:19.491]                   }
[16:13:19.491]                   options(future.plan = NULL)
[16:13:19.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.491]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:19.491]                     envir = parent.frame()) 
[16:13:19.491]                   {
[16:13:19.491]                     default_workers <- missing(workers)
[16:13:19.491]                     if (is.function(workers)) 
[16:13:19.491]                       workers <- workers()
[16:13:19.491]                     workers <- structure(as.integer(workers), 
[16:13:19.491]                       class = class(workers))
[16:13:19.491]                     stop_if_not(is.finite(workers), workers >= 
[16:13:19.491]                       1L)
[16:13:19.491]                     if ((workers == 1L && !inherits(workers, 
[16:13:19.491]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:19.491]                       if (default_workers) 
[16:13:19.491]                         supportsMulticore(warn = TRUE)
[16:13:19.491]                       return(sequential(..., envir = envir))
[16:13:19.491]                     }
[16:13:19.491]                     oopts <- options(mc.cores = workers)
[16:13:19.491]                     on.exit(options(oopts))
[16:13:19.491]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:19.491]                       envir = envir)
[16:13:19.491]                     if (!future$lazy) 
[16:13:19.491]                       future <- run(future)
[16:13:19.491]                     invisible(future)
[16:13:19.491]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.491]                 }
[16:13:19.491]                 ...future.workdir <- getwd()
[16:13:19.491]             }
[16:13:19.491]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:19.491]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:19.491]         }
[16:13:19.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:19.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:19.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:19.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:19.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:19.491]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:19.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:19.491]             base::names(...future.oldOptions))
[16:13:19.491]     }
[16:13:19.491]     if (FALSE) {
[16:13:19.491]     }
[16:13:19.491]     else {
[16:13:19.491]         if (TRUE) {
[16:13:19.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:19.491]                 open = "w")
[16:13:19.491]         }
[16:13:19.491]         else {
[16:13:19.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:19.491]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:19.491]         }
[16:13:19.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:19.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:19.491]             base::sink(type = "output", split = FALSE)
[16:13:19.491]             base::close(...future.stdout)
[16:13:19.491]         }, add = TRUE)
[16:13:19.491]     }
[16:13:19.491]     ...future.frame <- base::sys.nframe()
[16:13:19.491]     ...future.conditions <- base::list()
[16:13:19.491]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:19.491]     if (FALSE) {
[16:13:19.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:19.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:19.491]     }
[16:13:19.491]     ...future.result <- base::tryCatch({
[16:13:19.491]         base::withCallingHandlers({
[16:13:19.491]             ...future.value <- base::withVisible(base::local({
[16:13:19.491]                 ...future.makeSendCondition <- local({
[16:13:19.491]                   sendCondition <- NULL
[16:13:19.491]                   function(frame = 1L) {
[16:13:19.491]                     if (is.function(sendCondition)) 
[16:13:19.491]                       return(sendCondition)
[16:13:19.491]                     ns <- getNamespace("parallel")
[16:13:19.491]                     if (exists("sendData", mode = "function", 
[16:13:19.491]                       envir = ns)) {
[16:13:19.491]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:19.491]                         envir = ns)
[16:13:19.491]                       envir <- sys.frame(frame)
[16:13:19.491]                       master <- NULL
[16:13:19.491]                       while (!identical(envir, .GlobalEnv) && 
[16:13:19.491]                         !identical(envir, emptyenv())) {
[16:13:19.491]                         if (exists("master", mode = "list", envir = envir, 
[16:13:19.491]                           inherits = FALSE)) {
[16:13:19.491]                           master <- get("master", mode = "list", 
[16:13:19.491]                             envir = envir, inherits = FALSE)
[16:13:19.491]                           if (inherits(master, c("SOCKnode", 
[16:13:19.491]                             "SOCK0node"))) {
[16:13:19.491]                             sendCondition <<- function(cond) {
[16:13:19.491]                               data <- list(type = "VALUE", value = cond, 
[16:13:19.491]                                 success = TRUE)
[16:13:19.491]                               parallel_sendData(master, data)
[16:13:19.491]                             }
[16:13:19.491]                             return(sendCondition)
[16:13:19.491]                           }
[16:13:19.491]                         }
[16:13:19.491]                         frame <- frame + 1L
[16:13:19.491]                         envir <- sys.frame(frame)
[16:13:19.491]                       }
[16:13:19.491]                     }
[16:13:19.491]                     sendCondition <<- function(cond) NULL
[16:13:19.491]                   }
[16:13:19.491]                 })
[16:13:19.491]                 withCallingHandlers({
[16:13:19.491]                   {
[16:13:19.491]                     value(future(subset(data, a == 2)))
[16:13:19.491]                   }
[16:13:19.491]                 }, immediateCondition = function(cond) {
[16:13:19.491]                   sendCondition <- ...future.makeSendCondition()
[16:13:19.491]                   sendCondition(cond)
[16:13:19.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.491]                   {
[16:13:19.491]                     inherits <- base::inherits
[16:13:19.491]                     invokeRestart <- base::invokeRestart
[16:13:19.491]                     is.null <- base::is.null
[16:13:19.491]                     muffled <- FALSE
[16:13:19.491]                     if (inherits(cond, "message")) {
[16:13:19.491]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:19.491]                       if (muffled) 
[16:13:19.491]                         invokeRestart("muffleMessage")
[16:13:19.491]                     }
[16:13:19.491]                     else if (inherits(cond, "warning")) {
[16:13:19.491]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:19.491]                       if (muffled) 
[16:13:19.491]                         invokeRestart("muffleWarning")
[16:13:19.491]                     }
[16:13:19.491]                     else if (inherits(cond, "condition")) {
[16:13:19.491]                       if (!is.null(pattern)) {
[16:13:19.491]                         computeRestarts <- base::computeRestarts
[16:13:19.491]                         grepl <- base::grepl
[16:13:19.491]                         restarts <- computeRestarts(cond)
[16:13:19.491]                         for (restart in restarts) {
[16:13:19.491]                           name <- restart$name
[16:13:19.491]                           if (is.null(name)) 
[16:13:19.491]                             next
[16:13:19.491]                           if (!grepl(pattern, name)) 
[16:13:19.491]                             next
[16:13:19.491]                           invokeRestart(restart)
[16:13:19.491]                           muffled <- TRUE
[16:13:19.491]                           break
[16:13:19.491]                         }
[16:13:19.491]                       }
[16:13:19.491]                     }
[16:13:19.491]                     invisible(muffled)
[16:13:19.491]                   }
[16:13:19.491]                   muffleCondition(cond)
[16:13:19.491]                 })
[16:13:19.491]             }))
[16:13:19.491]             future::FutureResult(value = ...future.value$value, 
[16:13:19.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.491]                   ...future.rng), globalenv = if (FALSE) 
[16:13:19.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:19.491]                     ...future.globalenv.names))
[16:13:19.491]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:19.491]         }, condition = base::local({
[16:13:19.491]             c <- base::c
[16:13:19.491]             inherits <- base::inherits
[16:13:19.491]             invokeRestart <- base::invokeRestart
[16:13:19.491]             length <- base::length
[16:13:19.491]             list <- base::list
[16:13:19.491]             seq.int <- base::seq.int
[16:13:19.491]             signalCondition <- base::signalCondition
[16:13:19.491]             sys.calls <- base::sys.calls
[16:13:19.491]             `[[` <- base::`[[`
[16:13:19.491]             `+` <- base::`+`
[16:13:19.491]             `<<-` <- base::`<<-`
[16:13:19.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:19.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:19.491]                   3L)]
[16:13:19.491]             }
[16:13:19.491]             function(cond) {
[16:13:19.491]                 is_error <- inherits(cond, "error")
[16:13:19.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:19.491]                   NULL)
[16:13:19.491]                 if (is_error) {
[16:13:19.491]                   sessionInformation <- function() {
[16:13:19.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:19.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:19.491]                       search = base::search(), system = base::Sys.info())
[16:13:19.491]                   }
[16:13:19.491]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:19.491]                     cond$call), session = sessionInformation(), 
[16:13:19.491]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:19.491]                   signalCondition(cond)
[16:13:19.491]                 }
[16:13:19.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:19.491]                 "immediateCondition"))) {
[16:13:19.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:19.491]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:19.491]                   if (TRUE && !signal) {
[16:13:19.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.491]                     {
[16:13:19.491]                       inherits <- base::inherits
[16:13:19.491]                       invokeRestart <- base::invokeRestart
[16:13:19.491]                       is.null <- base::is.null
[16:13:19.491]                       muffled <- FALSE
[16:13:19.491]                       if (inherits(cond, "message")) {
[16:13:19.491]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.491]                         if (muffled) 
[16:13:19.491]                           invokeRestart("muffleMessage")
[16:13:19.491]                       }
[16:13:19.491]                       else if (inherits(cond, "warning")) {
[16:13:19.491]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.491]                         if (muffled) 
[16:13:19.491]                           invokeRestart("muffleWarning")
[16:13:19.491]                       }
[16:13:19.491]                       else if (inherits(cond, "condition")) {
[16:13:19.491]                         if (!is.null(pattern)) {
[16:13:19.491]                           computeRestarts <- base::computeRestarts
[16:13:19.491]                           grepl <- base::grepl
[16:13:19.491]                           restarts <- computeRestarts(cond)
[16:13:19.491]                           for (restart in restarts) {
[16:13:19.491]                             name <- restart$name
[16:13:19.491]                             if (is.null(name)) 
[16:13:19.491]                               next
[16:13:19.491]                             if (!grepl(pattern, name)) 
[16:13:19.491]                               next
[16:13:19.491]                             invokeRestart(restart)
[16:13:19.491]                             muffled <- TRUE
[16:13:19.491]                             break
[16:13:19.491]                           }
[16:13:19.491]                         }
[16:13:19.491]                       }
[16:13:19.491]                       invisible(muffled)
[16:13:19.491]                     }
[16:13:19.491]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.491]                   }
[16:13:19.491]                 }
[16:13:19.491]                 else {
[16:13:19.491]                   if (TRUE) {
[16:13:19.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.491]                     {
[16:13:19.491]                       inherits <- base::inherits
[16:13:19.491]                       invokeRestart <- base::invokeRestart
[16:13:19.491]                       is.null <- base::is.null
[16:13:19.491]                       muffled <- FALSE
[16:13:19.491]                       if (inherits(cond, "message")) {
[16:13:19.491]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.491]                         if (muffled) 
[16:13:19.491]                           invokeRestart("muffleMessage")
[16:13:19.491]                       }
[16:13:19.491]                       else if (inherits(cond, "warning")) {
[16:13:19.491]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.491]                         if (muffled) 
[16:13:19.491]                           invokeRestart("muffleWarning")
[16:13:19.491]                       }
[16:13:19.491]                       else if (inherits(cond, "condition")) {
[16:13:19.491]                         if (!is.null(pattern)) {
[16:13:19.491]                           computeRestarts <- base::computeRestarts
[16:13:19.491]                           grepl <- base::grepl
[16:13:19.491]                           restarts <- computeRestarts(cond)
[16:13:19.491]                           for (restart in restarts) {
[16:13:19.491]                             name <- restart$name
[16:13:19.491]                             if (is.null(name)) 
[16:13:19.491]                               next
[16:13:19.491]                             if (!grepl(pattern, name)) 
[16:13:19.491]                               next
[16:13:19.491]                             invokeRestart(restart)
[16:13:19.491]                             muffled <- TRUE
[16:13:19.491]                             break
[16:13:19.491]                           }
[16:13:19.491]                         }
[16:13:19.491]                       }
[16:13:19.491]                       invisible(muffled)
[16:13:19.491]                     }
[16:13:19.491]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.491]                   }
[16:13:19.491]                 }
[16:13:19.491]             }
[16:13:19.491]         }))
[16:13:19.491]     }, error = function(ex) {
[16:13:19.491]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:19.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.491]                 ...future.rng), started = ...future.startTime, 
[16:13:19.491]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:19.491]             version = "1.8"), class = "FutureResult")
[16:13:19.491]     }, finally = {
[16:13:19.491]         if (!identical(...future.workdir, getwd())) 
[16:13:19.491]             setwd(...future.workdir)
[16:13:19.491]         {
[16:13:19.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:19.491]                 ...future.oldOptions$nwarnings <- NULL
[16:13:19.491]             }
[16:13:19.491]             base::options(...future.oldOptions)
[16:13:19.491]             if (.Platform$OS.type == "windows") {
[16:13:19.491]                 old_names <- names(...future.oldEnvVars)
[16:13:19.491]                 envs <- base::Sys.getenv()
[16:13:19.491]                 names <- names(envs)
[16:13:19.491]                 common <- intersect(names, old_names)
[16:13:19.491]                 added <- setdiff(names, old_names)
[16:13:19.491]                 removed <- setdiff(old_names, names)
[16:13:19.491]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:19.491]                   envs[common]]
[16:13:19.491]                 NAMES <- toupper(changed)
[16:13:19.491]                 args <- list()
[16:13:19.491]                 for (kk in seq_along(NAMES)) {
[16:13:19.491]                   name <- changed[[kk]]
[16:13:19.491]                   NAME <- NAMES[[kk]]
[16:13:19.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.491]                     next
[16:13:19.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.491]                 }
[16:13:19.491]                 NAMES <- toupper(added)
[16:13:19.491]                 for (kk in seq_along(NAMES)) {
[16:13:19.491]                   name <- added[[kk]]
[16:13:19.491]                   NAME <- NAMES[[kk]]
[16:13:19.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.491]                     next
[16:13:19.491]                   args[[name]] <- ""
[16:13:19.491]                 }
[16:13:19.491]                 NAMES <- toupper(removed)
[16:13:19.491]                 for (kk in seq_along(NAMES)) {
[16:13:19.491]                   name <- removed[[kk]]
[16:13:19.491]                   NAME <- NAMES[[kk]]
[16:13:19.491]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.491]                     next
[16:13:19.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.491]                 }
[16:13:19.491]                 if (length(args) > 0) 
[16:13:19.491]                   base::do.call(base::Sys.setenv, args = args)
[16:13:19.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:19.491]             }
[16:13:19.491]             else {
[16:13:19.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:19.491]             }
[16:13:19.491]             {
[16:13:19.491]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:19.491]                   0L) {
[16:13:19.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:19.491]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:19.491]                   base::options(opts)
[16:13:19.491]                 }
[16:13:19.491]                 {
[16:13:19.491]                   {
[16:13:19.491]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:19.491]                     NULL
[16:13:19.491]                   }
[16:13:19.491]                   options(future.plan = NULL)
[16:13:19.491]                   if (is.na(NA_character_)) 
[16:13:19.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:19.491]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:19.491]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.491]                     envir = parent.frame()) 
[16:13:19.491]                   {
[16:13:19.491]                     if (is.function(workers)) 
[16:13:19.491]                       workers <- workers()
[16:13:19.491]                     workers <- structure(as.integer(workers), 
[16:13:19.491]                       class = class(workers))
[16:13:19.491]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.491]                       workers >= 1)
[16:13:19.491]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.491]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.491]                     }
[16:13:19.491]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.491]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.491]                       envir = envir)
[16:13:19.491]                     if (!future$lazy) 
[16:13:19.491]                       future <- run(future)
[16:13:19.491]                     invisible(future)
[16:13:19.491]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[16:13:19.491]                     envir = parent.frame()) 
[16:13:19.491]                   {
[16:13:19.491]                     default_workers <- missing(workers)
[16:13:19.491]                     if (is.function(workers)) 
[16:13:19.491]                       workers <- workers()
[16:13:19.491]                     workers <- structure(as.integer(workers), 
[16:13:19.491]                       class = class(workers))
[16:13:19.491]                     stop_if_not(is.finite(workers), workers >= 
[16:13:19.491]                       1L)
[16:13:19.491]                     if ((workers == 1L && !inherits(workers, 
[16:13:19.491]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:13:19.491]                       if (default_workers) 
[16:13:19.491]                         supportsMulticore(warn = TRUE)
[16:13:19.491]                       return(sequential(..., envir = envir))
[16:13:19.491]                     }
[16:13:19.491]                     oopts <- options(mc.cores = workers)
[16:13:19.491]                     on.exit(options(oopts))
[16:13:19.491]                     future <- MulticoreFuture(..., workers = workers, 
[16:13:19.491]                       envir = envir)
[16:13:19.491]                     if (!future$lazy) 
[16:13:19.491]                       future <- run(future)
[16:13:19.491]                     invisible(future)
[16:13:19.491]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.491]                 }
[16:13:19.491]             }
[16:13:19.491]         }
[16:13:19.491]     })
[16:13:19.491]     if (TRUE) {
[16:13:19.491]         base::sink(type = "output", split = FALSE)
[16:13:19.491]         if (TRUE) {
[16:13:19.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:19.491]         }
[16:13:19.491]         else {
[16:13:19.491]             ...future.result["stdout"] <- base::list(NULL)
[16:13:19.491]         }
[16:13:19.491]         base::close(...future.stdout)
[16:13:19.491]         ...future.stdout <- NULL
[16:13:19.491]     }
[16:13:19.491]     ...future.result$conditions <- ...future.conditions
[16:13:19.491]     ...future.result$finished <- base::Sys.time()
[16:13:19.491]     ...future.result
[16:13:19.491] }
[16:13:19.494] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:13:19.494] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:13:19.495] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:13:19.495] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:13:19.495] MultisessionFuture started
[16:13:19.496] - Launch lazy future ... done
[16:13:19.496] run() for ‘MultisessionFuture’ ... done
[16:13:19.496] result() for ClusterFuture ...
[16:13:19.496] receiveMessageFromWorker() for ClusterFuture ...
[16:13:19.496] - Validating connection of MultisessionFuture
[16:13:19.554] - received message: FutureResult
[16:13:19.554] - Received FutureResult
[16:13:19.554] - Erased future from FutureRegistry
[16:13:19.554] result() for ClusterFuture ...
[16:13:19.554] - result already collected: FutureResult
[16:13:19.554] result() for ClusterFuture ... done
[16:13:19.554] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:19.554] result() for ClusterFuture ... done
[16:13:19.555] result() for ClusterFuture ...
[16:13:19.555] - result already collected: FutureResult
[16:13:19.555] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[16:13:19.555] plan(): Setting new future strategy stack:
[16:13:19.555] List of future strategies:
[16:13:19.555] 1. multisession:
[16:13:19.555]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:19.555]    - tweaked: FALSE
[16:13:19.555]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:19.555] 2. multisession:
[16:13:19.555]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:19.555]    - tweaked: FALSE
[16:13:19.555]    - call: plan(list(a = strategy1, b = strategy2))
[16:13:19.556] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:13:19.556] multisession:
[16:13:19.556] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:13:19.556] - tweaked: FALSE
[16:13:19.556] - call: plan(list(a = strategy1, b = strategy2))
[16:13:19.560] getGlobalsAndPackages() ...
[16:13:19.560] Not searching for globals
[16:13:19.561] - globals: [0] <none>
[16:13:19.561] getGlobalsAndPackages() ... DONE
[16:13:19.561] [local output] makeClusterPSOCK() ...
[16:13:19.561] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:19.562] [local output] Base port: 11827
[16:13:19.562] [local output] Getting setup options for 2 cluster nodes ...
[16:13:19.562] [local output]  - Node 1 of 2 ...
[16:13:19.562] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:19.563] [local output] Rscript port: 11827

[16:13:19.563] [local output]  - Node 2 of 2 ...
[16:13:19.564] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:19.564] [local output] Rscript port: 11827

[16:13:19.565] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:19.565] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:19.565] [local output] Setting up PSOCK nodes in parallel
[16:13:19.565] List of 36
[16:13:19.565]  $ worker          : chr "localhost"
[16:13:19.565]   ..- attr(*, "localhost")= logi TRUE
[16:13:19.565]  $ master          : chr "localhost"
[16:13:19.565]  $ port            : int 11827
[16:13:19.565]  $ connectTimeout  : num 120
[16:13:19.565]  $ timeout         : num 2592000
[16:13:19.565]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:19.565]  $ homogeneous     : logi TRUE
[16:13:19.565]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:19.565]  $ rscript_envs    : NULL
[16:13:19.565]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:19.565]  $ rscript_startup : NULL
[16:13:19.565]  $ rscript_sh      : chr "sh"
[16:13:19.565]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:19.565]  $ methods         : logi TRUE
[16:13:19.565]  $ socketOptions   : chr "no-delay"
[16:13:19.565]  $ useXDR          : logi FALSE
[16:13:19.565]  $ outfile         : chr "/dev/null"
[16:13:19.565]  $ renice          : int NA
[16:13:19.565]  $ rshcmd          : NULL
[16:13:19.565]  $ user            : chr(0) 
[16:13:19.565]  $ revtunnel       : logi FALSE
[16:13:19.565]  $ rshlogfile      : NULL
[16:13:19.565]  $ rshopts         : chr(0) 
[16:13:19.565]  $ rank            : int 1
[16:13:19.565]  $ manual          : logi FALSE
[16:13:19.565]  $ dryrun          : logi FALSE
[16:13:19.565]  $ quiet           : logi FALSE
[16:13:19.565]  $ setup_strategy  : chr "parallel"
[16:13:19.565]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:19.565]  $ pidfile         : chr "/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b56290521bc.pid"
[16:13:19.565]  $ rshcmd_label    : NULL
[16:13:19.565]  $ rsh_call        : NULL
[16:13:19.565]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:19.565]  $ localMachine    : logi TRUE
[16:13:19.565]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:19.565]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:19.565]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:19.565]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:19.565]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:19.565]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:19.565]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:19.565]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:19.565]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:19.565]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:19.565]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:19.565]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:19.565]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:19.565]  $ arguments       :List of 28
[16:13:19.565]   ..$ worker          : chr "localhost"
[16:13:19.565]   ..$ master          : NULL
[16:13:19.565]   ..$ port            : int 11827
[16:13:19.565]   ..$ connectTimeout  : num 120
[16:13:19.565]   ..$ timeout         : num 2592000
[16:13:19.565]   ..$ rscript         : NULL
[16:13:19.565]   ..$ homogeneous     : NULL
[16:13:19.565]   ..$ rscript_args    : NULL
[16:13:19.565]   ..$ rscript_envs    : NULL
[16:13:19.565]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:19.565]   ..$ rscript_startup : NULL
[16:13:19.565]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:19.565]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:19.565]   ..$ methods         : logi TRUE
[16:13:19.565]   ..$ socketOptions   : chr "no-delay"
[16:13:19.565]   ..$ useXDR          : logi FALSE
[16:13:19.565]   ..$ outfile         : chr "/dev/null"
[16:13:19.565]   ..$ renice          : int NA
[16:13:19.565]   ..$ rshcmd          : NULL
[16:13:19.565]   ..$ user            : NULL
[16:13:19.565]   ..$ revtunnel       : logi NA
[16:13:19.565]   ..$ rshlogfile      : NULL
[16:13:19.565]   ..$ rshopts         : NULL
[16:13:19.565]   ..$ rank            : int 1
[16:13:19.565]   ..$ manual          : logi FALSE
[16:13:19.565]   ..$ dryrun          : logi FALSE
[16:13:19.565]   ..$ quiet           : logi FALSE
[16:13:19.565]   ..$ setup_strategy  : chr "parallel"
[16:13:19.565]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:19.586] [local output] System call to launch all workers:
[16:13:19.586] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpdY1hgU/worker.rank=1.parallelly.parent=88918.15b56290521bc.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11827 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:19.587] [local output] Starting PSOCK main server
[16:13:19.588] [local output] Workers launched
[16:13:19.588] [local output] Waiting for workers to connect back
[16:13:19.588]  - [local output] 0 workers out of 2 ready
[16:13:19.829]  - [local output] 0 workers out of 2 ready
[16:13:19.829]  - [local output] 1 workers out of 2 ready
[16:13:19.830]  - [local output] 2 workers out of 2 ready
[16:13:19.830] [local output] Launching of workers completed
[16:13:19.830] [local output] Collecting session information from workers
[16:13:19.830] [local output]  - Worker #1 of 2
[16:13:19.831] [local output]  - Worker #2 of 2
[16:13:19.831] [local output] makeClusterPSOCK() ... done
[16:13:19.842] Packages needed by the future expression (n = 0): <none>
[16:13:19.842] Packages needed by future strategies (n = 1): ‘future’
[16:13:19.843] {
[16:13:19.843]     {
[16:13:19.843]         {
[16:13:19.843]             ...future.startTime <- base::Sys.time()
[16:13:19.843]             {
[16:13:19.843]                 {
[16:13:19.843]                   {
[16:13:19.843]                     {
[16:13:19.843]                       {
[16:13:19.843]                         base::local({
[16:13:19.843]                           has_future <- base::requireNamespace("future", 
[16:13:19.843]                             quietly = TRUE)
[16:13:19.843]                           if (has_future) {
[16:13:19.843]                             ns <- base::getNamespace("future")
[16:13:19.843]                             version <- ns[[".package"]][["version"]]
[16:13:19.843]                             if (is.null(version)) 
[16:13:19.843]                               version <- utils::packageVersion("future")
[16:13:19.843]                           }
[16:13:19.843]                           else {
[16:13:19.843]                             version <- NULL
[16:13:19.843]                           }
[16:13:19.843]                           if (!has_future || version < "1.8.0") {
[16:13:19.843]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:19.843]                               "", base::R.version$version.string), 
[16:13:19.843]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:19.843]                                 base::R.version$platform, 8 * 
[16:13:19.843]                                   base::.Machine$sizeof.pointer), 
[16:13:19.843]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:19.843]                                 "release", "version")], collapse = " "), 
[16:13:19.843]                               hostname = base::Sys.info()[["nodename"]])
[16:13:19.843]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:19.843]                               info)
[16:13:19.843]                             info <- base::paste(info, collapse = "; ")
[16:13:19.843]                             if (!has_future) {
[16:13:19.843]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:19.843]                                 info)
[16:13:19.843]                             }
[16:13:19.843]                             else {
[16:13:19.843]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:19.843]                                 info, version)
[16:13:19.843]                             }
[16:13:19.843]                             base::stop(msg)
[16:13:19.843]                           }
[16:13:19.843]                         })
[16:13:19.843]                       }
[16:13:19.843]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:19.843]                       base::options(mc.cores = 1L)
[16:13:19.843]                     }
[16:13:19.843]                     base::local({
[16:13:19.843]                       for (pkg in "future") {
[16:13:19.843]                         base::loadNamespace(pkg)
[16:13:19.843]                         base::library(pkg, character.only = TRUE)
[16:13:19.843]                       }
[16:13:19.843]                     })
[16:13:19.843]                   }
[16:13:19.843]                   options(future.plan = NULL)
[16:13:19.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.843]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:19.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.843]                     envir = parent.frame()) 
[16:13:19.843]                   {
[16:13:19.843]                     if (is.function(workers)) 
[16:13:19.843]                       workers <- workers()
[16:13:19.843]                     workers <- structure(as.integer(workers), 
[16:13:19.843]                       class = class(workers))
[16:13:19.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.843]                       workers >= 1)
[16:13:19.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.843]                     }
[16:13:19.843]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.843]                       envir = envir)
[16:13:19.843]                     if (!future$lazy) 
[16:13:19.843]                       future <- run(future)
[16:13:19.843]                     invisible(future)
[16:13:19.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.843]                 }
[16:13:19.843]                 ...future.workdir <- getwd()
[16:13:19.843]             }
[16:13:19.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:19.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:19.843]         }
[16:13:19.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:19.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:19.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:19.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:19.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:19.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:19.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:19.843]             base::names(...future.oldOptions))
[16:13:19.843]     }
[16:13:19.843]     if (FALSE) {
[16:13:19.843]     }
[16:13:19.843]     else {
[16:13:19.843]         if (TRUE) {
[16:13:19.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:19.843]                 open = "w")
[16:13:19.843]         }
[16:13:19.843]         else {
[16:13:19.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:19.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:19.843]         }
[16:13:19.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:19.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:19.843]             base::sink(type = "output", split = FALSE)
[16:13:19.843]             base::close(...future.stdout)
[16:13:19.843]         }, add = TRUE)
[16:13:19.843]     }
[16:13:19.843]     ...future.frame <- base::sys.nframe()
[16:13:19.843]     ...future.conditions <- base::list()
[16:13:19.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:19.843]     if (FALSE) {
[16:13:19.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:19.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:19.843]     }
[16:13:19.843]     ...future.result <- base::tryCatch({
[16:13:19.843]         base::withCallingHandlers({
[16:13:19.843]             ...future.value <- base::withVisible(base::local({
[16:13:19.843]                 ...future.makeSendCondition <- local({
[16:13:19.843]                   sendCondition <- NULL
[16:13:19.843]                   function(frame = 1L) {
[16:13:19.843]                     if (is.function(sendCondition)) 
[16:13:19.843]                       return(sendCondition)
[16:13:19.843]                     ns <- getNamespace("parallel")
[16:13:19.843]                     if (exists("sendData", mode = "function", 
[16:13:19.843]                       envir = ns)) {
[16:13:19.843]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:19.843]                         envir = ns)
[16:13:19.843]                       envir <- sys.frame(frame)
[16:13:19.843]                       master <- NULL
[16:13:19.843]                       while (!identical(envir, .GlobalEnv) && 
[16:13:19.843]                         !identical(envir, emptyenv())) {
[16:13:19.843]                         if (exists("master", mode = "list", envir = envir, 
[16:13:19.843]                           inherits = FALSE)) {
[16:13:19.843]                           master <- get("master", mode = "list", 
[16:13:19.843]                             envir = envir, inherits = FALSE)
[16:13:19.843]                           if (inherits(master, c("SOCKnode", 
[16:13:19.843]                             "SOCK0node"))) {
[16:13:19.843]                             sendCondition <<- function(cond) {
[16:13:19.843]                               data <- list(type = "VALUE", value = cond, 
[16:13:19.843]                                 success = TRUE)
[16:13:19.843]                               parallel_sendData(master, data)
[16:13:19.843]                             }
[16:13:19.843]                             return(sendCondition)
[16:13:19.843]                           }
[16:13:19.843]                         }
[16:13:19.843]                         frame <- frame + 1L
[16:13:19.843]                         envir <- sys.frame(frame)
[16:13:19.843]                       }
[16:13:19.843]                     }
[16:13:19.843]                     sendCondition <<- function(cond) NULL
[16:13:19.843]                   }
[16:13:19.843]                 })
[16:13:19.843]                 withCallingHandlers({
[16:13:19.843]                   NA
[16:13:19.843]                 }, immediateCondition = function(cond) {
[16:13:19.843]                   sendCondition <- ...future.makeSendCondition()
[16:13:19.843]                   sendCondition(cond)
[16:13:19.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.843]                   {
[16:13:19.843]                     inherits <- base::inherits
[16:13:19.843]                     invokeRestart <- base::invokeRestart
[16:13:19.843]                     is.null <- base::is.null
[16:13:19.843]                     muffled <- FALSE
[16:13:19.843]                     if (inherits(cond, "message")) {
[16:13:19.843]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:19.843]                       if (muffled) 
[16:13:19.843]                         invokeRestart("muffleMessage")
[16:13:19.843]                     }
[16:13:19.843]                     else if (inherits(cond, "warning")) {
[16:13:19.843]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:19.843]                       if (muffled) 
[16:13:19.843]                         invokeRestart("muffleWarning")
[16:13:19.843]                     }
[16:13:19.843]                     else if (inherits(cond, "condition")) {
[16:13:19.843]                       if (!is.null(pattern)) {
[16:13:19.843]                         computeRestarts <- base::computeRestarts
[16:13:19.843]                         grepl <- base::grepl
[16:13:19.843]                         restarts <- computeRestarts(cond)
[16:13:19.843]                         for (restart in restarts) {
[16:13:19.843]                           name <- restart$name
[16:13:19.843]                           if (is.null(name)) 
[16:13:19.843]                             next
[16:13:19.843]                           if (!grepl(pattern, name)) 
[16:13:19.843]                             next
[16:13:19.843]                           invokeRestart(restart)
[16:13:19.843]                           muffled <- TRUE
[16:13:19.843]                           break
[16:13:19.843]                         }
[16:13:19.843]                       }
[16:13:19.843]                     }
[16:13:19.843]                     invisible(muffled)
[16:13:19.843]                   }
[16:13:19.843]                   muffleCondition(cond)
[16:13:19.843]                 })
[16:13:19.843]             }))
[16:13:19.843]             future::FutureResult(value = ...future.value$value, 
[16:13:19.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.843]                   ...future.rng), globalenv = if (FALSE) 
[16:13:19.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:19.843]                     ...future.globalenv.names))
[16:13:19.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:19.843]         }, condition = base::local({
[16:13:19.843]             c <- base::c
[16:13:19.843]             inherits <- base::inherits
[16:13:19.843]             invokeRestart <- base::invokeRestart
[16:13:19.843]             length <- base::length
[16:13:19.843]             list <- base::list
[16:13:19.843]             seq.int <- base::seq.int
[16:13:19.843]             signalCondition <- base::signalCondition
[16:13:19.843]             sys.calls <- base::sys.calls
[16:13:19.843]             `[[` <- base::`[[`
[16:13:19.843]             `+` <- base::`+`
[16:13:19.843]             `<<-` <- base::`<<-`
[16:13:19.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:19.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:19.843]                   3L)]
[16:13:19.843]             }
[16:13:19.843]             function(cond) {
[16:13:19.843]                 is_error <- inherits(cond, "error")
[16:13:19.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:19.843]                   NULL)
[16:13:19.843]                 if (is_error) {
[16:13:19.843]                   sessionInformation <- function() {
[16:13:19.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:19.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:19.843]                       search = base::search(), system = base::Sys.info())
[16:13:19.843]                   }
[16:13:19.843]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:19.843]                     cond$call), session = sessionInformation(), 
[16:13:19.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:19.843]                   signalCondition(cond)
[16:13:19.843]                 }
[16:13:19.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:19.843]                 "immediateCondition"))) {
[16:13:19.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:19.843]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:19.843]                   if (TRUE && !signal) {
[16:13:19.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.843]                     {
[16:13:19.843]                       inherits <- base::inherits
[16:13:19.843]                       invokeRestart <- base::invokeRestart
[16:13:19.843]                       is.null <- base::is.null
[16:13:19.843]                       muffled <- FALSE
[16:13:19.843]                       if (inherits(cond, "message")) {
[16:13:19.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.843]                         if (muffled) 
[16:13:19.843]                           invokeRestart("muffleMessage")
[16:13:19.843]                       }
[16:13:19.843]                       else if (inherits(cond, "warning")) {
[16:13:19.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.843]                         if (muffled) 
[16:13:19.843]                           invokeRestart("muffleWarning")
[16:13:19.843]                       }
[16:13:19.843]                       else if (inherits(cond, "condition")) {
[16:13:19.843]                         if (!is.null(pattern)) {
[16:13:19.843]                           computeRestarts <- base::computeRestarts
[16:13:19.843]                           grepl <- base::grepl
[16:13:19.843]                           restarts <- computeRestarts(cond)
[16:13:19.843]                           for (restart in restarts) {
[16:13:19.843]                             name <- restart$name
[16:13:19.843]                             if (is.null(name)) 
[16:13:19.843]                               next
[16:13:19.843]                             if (!grepl(pattern, name)) 
[16:13:19.843]                               next
[16:13:19.843]                             invokeRestart(restart)
[16:13:19.843]                             muffled <- TRUE
[16:13:19.843]                             break
[16:13:19.843]                           }
[16:13:19.843]                         }
[16:13:19.843]                       }
[16:13:19.843]                       invisible(muffled)
[16:13:19.843]                     }
[16:13:19.843]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.843]                   }
[16:13:19.843]                 }
[16:13:19.843]                 else {
[16:13:19.843]                   if (TRUE) {
[16:13:19.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.843]                     {
[16:13:19.843]                       inherits <- base::inherits
[16:13:19.843]                       invokeRestart <- base::invokeRestart
[16:13:19.843]                       is.null <- base::is.null
[16:13:19.843]                       muffled <- FALSE
[16:13:19.843]                       if (inherits(cond, "message")) {
[16:13:19.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.843]                         if (muffled) 
[16:13:19.843]                           invokeRestart("muffleMessage")
[16:13:19.843]                       }
[16:13:19.843]                       else if (inherits(cond, "warning")) {
[16:13:19.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.843]                         if (muffled) 
[16:13:19.843]                           invokeRestart("muffleWarning")
[16:13:19.843]                       }
[16:13:19.843]                       else if (inherits(cond, "condition")) {
[16:13:19.843]                         if (!is.null(pattern)) {
[16:13:19.843]                           computeRestarts <- base::computeRestarts
[16:13:19.843]                           grepl <- base::grepl
[16:13:19.843]                           restarts <- computeRestarts(cond)
[16:13:19.843]                           for (restart in restarts) {
[16:13:19.843]                             name <- restart$name
[16:13:19.843]                             if (is.null(name)) 
[16:13:19.843]                               next
[16:13:19.843]                             if (!grepl(pattern, name)) 
[16:13:19.843]                               next
[16:13:19.843]                             invokeRestart(restart)
[16:13:19.843]                             muffled <- TRUE
[16:13:19.843]                             break
[16:13:19.843]                           }
[16:13:19.843]                         }
[16:13:19.843]                       }
[16:13:19.843]                       invisible(muffled)
[16:13:19.843]                     }
[16:13:19.843]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.843]                   }
[16:13:19.843]                 }
[16:13:19.843]             }
[16:13:19.843]         }))
[16:13:19.843]     }, error = function(ex) {
[16:13:19.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:19.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.843]                 ...future.rng), started = ...future.startTime, 
[16:13:19.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:19.843]             version = "1.8"), class = "FutureResult")
[16:13:19.843]     }, finally = {
[16:13:19.843]         if (!identical(...future.workdir, getwd())) 
[16:13:19.843]             setwd(...future.workdir)
[16:13:19.843]         {
[16:13:19.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:19.843]                 ...future.oldOptions$nwarnings <- NULL
[16:13:19.843]             }
[16:13:19.843]             base::options(...future.oldOptions)
[16:13:19.843]             if (.Platform$OS.type == "windows") {
[16:13:19.843]                 old_names <- names(...future.oldEnvVars)
[16:13:19.843]                 envs <- base::Sys.getenv()
[16:13:19.843]                 names <- names(envs)
[16:13:19.843]                 common <- intersect(names, old_names)
[16:13:19.843]                 added <- setdiff(names, old_names)
[16:13:19.843]                 removed <- setdiff(old_names, names)
[16:13:19.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:19.843]                   envs[common]]
[16:13:19.843]                 NAMES <- toupper(changed)
[16:13:19.843]                 args <- list()
[16:13:19.843]                 for (kk in seq_along(NAMES)) {
[16:13:19.843]                   name <- changed[[kk]]
[16:13:19.843]                   NAME <- NAMES[[kk]]
[16:13:19.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.843]                     next
[16:13:19.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.843]                 }
[16:13:19.843]                 NAMES <- toupper(added)
[16:13:19.843]                 for (kk in seq_along(NAMES)) {
[16:13:19.843]                   name <- added[[kk]]
[16:13:19.843]                   NAME <- NAMES[[kk]]
[16:13:19.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.843]                     next
[16:13:19.843]                   args[[name]] <- ""
[16:13:19.843]                 }
[16:13:19.843]                 NAMES <- toupper(removed)
[16:13:19.843]                 for (kk in seq_along(NAMES)) {
[16:13:19.843]                   name <- removed[[kk]]
[16:13:19.843]                   NAME <- NAMES[[kk]]
[16:13:19.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.843]                     next
[16:13:19.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.843]                 }
[16:13:19.843]                 if (length(args) > 0) 
[16:13:19.843]                   base::do.call(base::Sys.setenv, args = args)
[16:13:19.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:19.843]             }
[16:13:19.843]             else {
[16:13:19.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:19.843]             }
[16:13:19.843]             {
[16:13:19.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:19.843]                   0L) {
[16:13:19.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:19.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:19.843]                   base::options(opts)
[16:13:19.843]                 }
[16:13:19.843]                 {
[16:13:19.843]                   {
[16:13:19.843]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:19.843]                     NULL
[16:13:19.843]                   }
[16:13:19.843]                   options(future.plan = NULL)
[16:13:19.843]                   if (is.na(NA_character_)) 
[16:13:19.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:19.843]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:19.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.843]                     envir = parent.frame()) 
[16:13:19.843]                   {
[16:13:19.843]                     if (is.function(workers)) 
[16:13:19.843]                       workers <- workers()
[16:13:19.843]                     workers <- structure(as.integer(workers), 
[16:13:19.843]                       class = class(workers))
[16:13:19.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.843]                       workers >= 1)
[16:13:19.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.843]                     }
[16:13:19.843]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.843]                       envir = envir)
[16:13:19.843]                     if (!future$lazy) 
[16:13:19.843]                       future <- run(future)
[16:13:19.843]                     invisible(future)
[16:13:19.843]                   }, b = function (..., workers = availableCores(), 
[16:13:19.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.843]                     envir = parent.frame()) 
[16:13:19.843]                   {
[16:13:19.843]                     if (is.function(workers)) 
[16:13:19.843]                       workers <- workers()
[16:13:19.843]                     workers <- structure(as.integer(workers), 
[16:13:19.843]                       class = class(workers))
[16:13:19.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.843]                       workers >= 1)
[16:13:19.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.843]                     }
[16:13:19.843]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.843]                       envir = envir)
[16:13:19.843]                     if (!future$lazy) 
[16:13:19.843]                       future <- run(future)
[16:13:19.843]                     invisible(future)
[16:13:19.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.843]                 }
[16:13:19.843]             }
[16:13:19.843]         }
[16:13:19.843]     })
[16:13:19.843]     if (TRUE) {
[16:13:19.843]         base::sink(type = "output", split = FALSE)
[16:13:19.843]         if (TRUE) {
[16:13:19.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:19.843]         }
[16:13:19.843]         else {
[16:13:19.843]             ...future.result["stdout"] <- base::list(NULL)
[16:13:19.843]         }
[16:13:19.843]         base::close(...future.stdout)
[16:13:19.843]         ...future.stdout <- NULL
[16:13:19.843]     }
[16:13:19.843]     ...future.result$conditions <- ...future.conditions
[16:13:19.843]     ...future.result$finished <- base::Sys.time()
[16:13:19.843]     ...future.result
[16:13:19.843] }
[16:13:19.913] MultisessionFuture started
[16:13:19.913] result() for ClusterFuture ...
[16:13:19.913] receiveMessageFromWorker() for ClusterFuture ...
[16:13:19.913] - Validating connection of MultisessionFuture
[16:13:19.949] - received message: FutureResult
[16:13:19.949] - Received FutureResult
[16:13:19.950] - Erased future from FutureRegistry
[16:13:19.950] result() for ClusterFuture ...
[16:13:19.950] - result already collected: FutureResult
[16:13:19.950] result() for ClusterFuture ... done
[16:13:19.950] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:19.950] result() for ClusterFuture ... done
[16:13:19.950] result() for ClusterFuture ...
[16:13:19.950] - result already collected: FutureResult
[16:13:19.950] result() for ClusterFuture ... done
[16:13:19.951] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:13:19.954] plan(): nbrOfWorkers() = 2
[16:13:19.954] getGlobalsAndPackages() ...
[16:13:19.954] Searching for globals...
[16:13:19.970] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[16:13:19.970] Searching for globals ... DONE
[16:13:19.970] Resolving globals: FALSE
[16:13:19.971] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[16:13:19.972] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[16:13:19.972] - globals: [2] ‘nested’, ‘strategy2’
[16:13:19.972] - packages: [1] ‘future’
[16:13:19.972] getGlobalsAndPackages() ... DONE
[16:13:19.973] run() for ‘Future’ ...
[16:13:19.973] - state: ‘created’
[16:13:19.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:19.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:19.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:19.987]   - Field: ‘node’
[16:13:19.987]   - Field: ‘label’
[16:13:19.987]   - Field: ‘local’
[16:13:19.987]   - Field: ‘owner’
[16:13:19.988]   - Field: ‘envir’
[16:13:19.988]   - Field: ‘workers’
[16:13:19.988]   - Field: ‘packages’
[16:13:19.988]   - Field: ‘gc’
[16:13:19.988]   - Field: ‘conditions’
[16:13:19.988]   - Field: ‘persistent’
[16:13:19.988]   - Field: ‘expr’
[16:13:19.988]   - Field: ‘uuid’
[16:13:19.988]   - Field: ‘seed’
[16:13:19.988]   - Field: ‘version’
[16:13:19.989]   - Field: ‘result’
[16:13:19.989]   - Field: ‘asynchronous’
[16:13:19.989]   - Field: ‘calls’
[16:13:19.989]   - Field: ‘globals’
[16:13:19.989]   - Field: ‘stdout’
[16:13:19.989]   - Field: ‘earlySignal’
[16:13:19.989]   - Field: ‘lazy’
[16:13:19.989]   - Field: ‘state’
[16:13:19.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:19.989] - Launch lazy future ...
[16:13:19.990] Packages needed by the future expression (n = 1): ‘future’
[16:13:19.990] Packages needed by future strategies (n = 1): ‘future’
[16:13:19.990] {
[16:13:19.990]     {
[16:13:19.990]         {
[16:13:19.990]             ...future.startTime <- base::Sys.time()
[16:13:19.990]             {
[16:13:19.990]                 {
[16:13:19.990]                   {
[16:13:19.990]                     {
[16:13:19.990]                       {
[16:13:19.990]                         base::local({
[16:13:19.990]                           has_future <- base::requireNamespace("future", 
[16:13:19.990]                             quietly = TRUE)
[16:13:19.990]                           if (has_future) {
[16:13:19.990]                             ns <- base::getNamespace("future")
[16:13:19.990]                             version <- ns[[".package"]][["version"]]
[16:13:19.990]                             if (is.null(version)) 
[16:13:19.990]                               version <- utils::packageVersion("future")
[16:13:19.990]                           }
[16:13:19.990]                           else {
[16:13:19.990]                             version <- NULL
[16:13:19.990]                           }
[16:13:19.990]                           if (!has_future || version < "1.8.0") {
[16:13:19.990]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:19.990]                               "", base::R.version$version.string), 
[16:13:19.990]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:19.990]                                 base::R.version$platform, 8 * 
[16:13:19.990]                                   base::.Machine$sizeof.pointer), 
[16:13:19.990]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:19.990]                                 "release", "version")], collapse = " "), 
[16:13:19.990]                               hostname = base::Sys.info()[["nodename"]])
[16:13:19.990]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:19.990]                               info)
[16:13:19.990]                             info <- base::paste(info, collapse = "; ")
[16:13:19.990]                             if (!has_future) {
[16:13:19.990]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:19.990]                                 info)
[16:13:19.990]                             }
[16:13:19.990]                             else {
[16:13:19.990]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:19.990]                                 info, version)
[16:13:19.990]                             }
[16:13:19.990]                             base::stop(msg)
[16:13:19.990]                           }
[16:13:19.990]                         })
[16:13:19.990]                       }
[16:13:19.990]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:19.990]                       base::options(mc.cores = 1L)
[16:13:19.990]                     }
[16:13:19.990]                     base::local({
[16:13:19.990]                       for (pkg in "future") {
[16:13:19.990]                         base::loadNamespace(pkg)
[16:13:19.990]                         base::library(pkg, character.only = TRUE)
[16:13:19.990]                       }
[16:13:19.990]                     })
[16:13:19.990]                   }
[16:13:19.990]                   options(future.plan = NULL)
[16:13:19.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.990]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:19.990]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.990]                     envir = parent.frame()) 
[16:13:19.990]                   {
[16:13:19.990]                     if (is.function(workers)) 
[16:13:19.990]                       workers <- workers()
[16:13:19.990]                     workers <- structure(as.integer(workers), 
[16:13:19.990]                       class = class(workers))
[16:13:19.990]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.990]                       workers >= 1)
[16:13:19.990]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.990]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.990]                     }
[16:13:19.990]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.990]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.990]                       envir = envir)
[16:13:19.990]                     if (!future$lazy) 
[16:13:19.990]                       future <- run(future)
[16:13:19.990]                     invisible(future)
[16:13:19.990]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.990]                 }
[16:13:19.990]                 ...future.workdir <- getwd()
[16:13:19.990]             }
[16:13:19.990]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:19.990]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:19.990]         }
[16:13:19.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:19.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:19.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:19.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:19.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:19.990]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:19.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:19.990]             base::names(...future.oldOptions))
[16:13:19.990]     }
[16:13:19.990]     if (FALSE) {
[16:13:19.990]     }
[16:13:19.990]     else {
[16:13:19.990]         if (TRUE) {
[16:13:19.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:19.990]                 open = "w")
[16:13:19.990]         }
[16:13:19.990]         else {
[16:13:19.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:19.990]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:19.990]         }
[16:13:19.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:19.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:19.990]             base::sink(type = "output", split = FALSE)
[16:13:19.990]             base::close(...future.stdout)
[16:13:19.990]         }, add = TRUE)
[16:13:19.990]     }
[16:13:19.990]     ...future.frame <- base::sys.nframe()
[16:13:19.990]     ...future.conditions <- base::list()
[16:13:19.990]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:19.990]     if (FALSE) {
[16:13:19.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:19.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:19.990]     }
[16:13:19.990]     ...future.result <- base::tryCatch({
[16:13:19.990]         base::withCallingHandlers({
[16:13:19.990]             ...future.value <- base::withVisible(base::local({
[16:13:19.990]                 ...future.makeSendCondition <- local({
[16:13:19.990]                   sendCondition <- NULL
[16:13:19.990]                   function(frame = 1L) {
[16:13:19.990]                     if (is.function(sendCondition)) 
[16:13:19.990]                       return(sendCondition)
[16:13:19.990]                     ns <- getNamespace("parallel")
[16:13:19.990]                     if (exists("sendData", mode = "function", 
[16:13:19.990]                       envir = ns)) {
[16:13:19.990]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:19.990]                         envir = ns)
[16:13:19.990]                       envir <- sys.frame(frame)
[16:13:19.990]                       master <- NULL
[16:13:19.990]                       while (!identical(envir, .GlobalEnv) && 
[16:13:19.990]                         !identical(envir, emptyenv())) {
[16:13:19.990]                         if (exists("master", mode = "list", envir = envir, 
[16:13:19.990]                           inherits = FALSE)) {
[16:13:19.990]                           master <- get("master", mode = "list", 
[16:13:19.990]                             envir = envir, inherits = FALSE)
[16:13:19.990]                           if (inherits(master, c("SOCKnode", 
[16:13:19.990]                             "SOCK0node"))) {
[16:13:19.990]                             sendCondition <<- function(cond) {
[16:13:19.990]                               data <- list(type = "VALUE", value = cond, 
[16:13:19.990]                                 success = TRUE)
[16:13:19.990]                               parallel_sendData(master, data)
[16:13:19.990]                             }
[16:13:19.990]                             return(sendCondition)
[16:13:19.990]                           }
[16:13:19.990]                         }
[16:13:19.990]                         frame <- frame + 1L
[16:13:19.990]                         envir <- sys.frame(frame)
[16:13:19.990]                       }
[16:13:19.990]                     }
[16:13:19.990]                     sendCondition <<- function(cond) NULL
[16:13:19.990]                   }
[16:13:19.990]                 })
[16:13:19.990]                 withCallingHandlers({
[16:13:19.990]                   {
[16:13:19.990]                     a <- 1L
[16:13:19.990]                     plan_a <- unclass(future::plan("list"))
[16:13:19.990]                     nested_a <- nested[-1]
[16:13:19.990]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[16:13:19.990]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[16:13:19.990]                       strategy2))
[16:13:19.990]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[16:13:19.990]                       "init") <- NULL
[16:13:19.990]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[16:13:19.990]                       "init") <- NULL
[16:13:19.990]                     stopifnot(all.equal(plan_a, nested_a))
[16:13:19.990]                     y %<-% {
[16:13:19.990]                       b <- 2L
[16:13:19.990]                       plan_b <- future::plan("list")
[16:13:19.990]                       nested_b <- nested_a[-1]
[16:13:19.990]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[16:13:19.990]                         1L, inherits(plan_b[[1]], "future"), 
[16:13:19.990]                         inherits(future::plan("next"), "sequential"))
[16:13:19.990]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[16:13:19.990]                         b = b, nested_b = nested_b, plan_b = plan_b)
[16:13:19.990]                     }
[16:13:19.990]                     y
[16:13:19.990]                   }
[16:13:19.990]                 }, immediateCondition = function(cond) {
[16:13:19.990]                   sendCondition <- ...future.makeSendCondition()
[16:13:19.990]                   sendCondition(cond)
[16:13:19.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.990]                   {
[16:13:19.990]                     inherits <- base::inherits
[16:13:19.990]                     invokeRestart <- base::invokeRestart
[16:13:19.990]                     is.null <- base::is.null
[16:13:19.990]                     muffled <- FALSE
[16:13:19.990]                     if (inherits(cond, "message")) {
[16:13:19.990]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:19.990]                       if (muffled) 
[16:13:19.990]                         invokeRestart("muffleMessage")
[16:13:19.990]                     }
[16:13:19.990]                     else if (inherits(cond, "warning")) {
[16:13:19.990]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:19.990]                       if (muffled) 
[16:13:19.990]                         invokeRestart("muffleWarning")
[16:13:19.990]                     }
[16:13:19.990]                     else if (inherits(cond, "condition")) {
[16:13:19.990]                       if (!is.null(pattern)) {
[16:13:19.990]                         computeRestarts <- base::computeRestarts
[16:13:19.990]                         grepl <- base::grepl
[16:13:19.990]                         restarts <- computeRestarts(cond)
[16:13:19.990]                         for (restart in restarts) {
[16:13:19.990]                           name <- restart$name
[16:13:19.990]                           if (is.null(name)) 
[16:13:19.990]                             next
[16:13:19.990]                           if (!grepl(pattern, name)) 
[16:13:19.990]                             next
[16:13:19.990]                           invokeRestart(restart)
[16:13:19.990]                           muffled <- TRUE
[16:13:19.990]                           break
[16:13:19.990]                         }
[16:13:19.990]                       }
[16:13:19.990]                     }
[16:13:19.990]                     invisible(muffled)
[16:13:19.990]                   }
[16:13:19.990]                   muffleCondition(cond)
[16:13:19.990]                 })
[16:13:19.990]             }))
[16:13:19.990]             future::FutureResult(value = ...future.value$value, 
[16:13:19.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.990]                   ...future.rng), globalenv = if (FALSE) 
[16:13:19.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:19.990]                     ...future.globalenv.names))
[16:13:19.990]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:19.990]         }, condition = base::local({
[16:13:19.990]             c <- base::c
[16:13:19.990]             inherits <- base::inherits
[16:13:19.990]             invokeRestart <- base::invokeRestart
[16:13:19.990]             length <- base::length
[16:13:19.990]             list <- base::list
[16:13:19.990]             seq.int <- base::seq.int
[16:13:19.990]             signalCondition <- base::signalCondition
[16:13:19.990]             sys.calls <- base::sys.calls
[16:13:19.990]             `[[` <- base::`[[`
[16:13:19.990]             `+` <- base::`+`
[16:13:19.990]             `<<-` <- base::`<<-`
[16:13:19.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:19.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:19.990]                   3L)]
[16:13:19.990]             }
[16:13:19.990]             function(cond) {
[16:13:19.990]                 is_error <- inherits(cond, "error")
[16:13:19.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:19.990]                   NULL)
[16:13:19.990]                 if (is_error) {
[16:13:19.990]                   sessionInformation <- function() {
[16:13:19.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:19.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:19.990]                       search = base::search(), system = base::Sys.info())
[16:13:19.990]                   }
[16:13:19.990]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:19.990]                     cond$call), session = sessionInformation(), 
[16:13:19.990]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:19.990]                   signalCondition(cond)
[16:13:19.990]                 }
[16:13:19.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:19.990]                 "immediateCondition"))) {
[16:13:19.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:19.990]                   ...future.conditions[[length(...future.conditions) + 
[16:13:19.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:19.990]                   if (TRUE && !signal) {
[16:13:19.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.990]                     {
[16:13:19.990]                       inherits <- base::inherits
[16:13:19.990]                       invokeRestart <- base::invokeRestart
[16:13:19.990]                       is.null <- base::is.null
[16:13:19.990]                       muffled <- FALSE
[16:13:19.990]                       if (inherits(cond, "message")) {
[16:13:19.990]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.990]                         if (muffled) 
[16:13:19.990]                           invokeRestart("muffleMessage")
[16:13:19.990]                       }
[16:13:19.990]                       else if (inherits(cond, "warning")) {
[16:13:19.990]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.990]                         if (muffled) 
[16:13:19.990]                           invokeRestart("muffleWarning")
[16:13:19.990]                       }
[16:13:19.990]                       else if (inherits(cond, "condition")) {
[16:13:19.990]                         if (!is.null(pattern)) {
[16:13:19.990]                           computeRestarts <- base::computeRestarts
[16:13:19.990]                           grepl <- base::grepl
[16:13:19.990]                           restarts <- computeRestarts(cond)
[16:13:19.990]                           for (restart in restarts) {
[16:13:19.990]                             name <- restart$name
[16:13:19.990]                             if (is.null(name)) 
[16:13:19.990]                               next
[16:13:19.990]                             if (!grepl(pattern, name)) 
[16:13:19.990]                               next
[16:13:19.990]                             invokeRestart(restart)
[16:13:19.990]                             muffled <- TRUE
[16:13:19.990]                             break
[16:13:19.990]                           }
[16:13:19.990]                         }
[16:13:19.990]                       }
[16:13:19.990]                       invisible(muffled)
[16:13:19.990]                     }
[16:13:19.990]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.990]                   }
[16:13:19.990]                 }
[16:13:19.990]                 else {
[16:13:19.990]                   if (TRUE) {
[16:13:19.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:19.990]                     {
[16:13:19.990]                       inherits <- base::inherits
[16:13:19.990]                       invokeRestart <- base::invokeRestart
[16:13:19.990]                       is.null <- base::is.null
[16:13:19.990]                       muffled <- FALSE
[16:13:19.990]                       if (inherits(cond, "message")) {
[16:13:19.990]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:19.990]                         if (muffled) 
[16:13:19.990]                           invokeRestart("muffleMessage")
[16:13:19.990]                       }
[16:13:19.990]                       else if (inherits(cond, "warning")) {
[16:13:19.990]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:19.990]                         if (muffled) 
[16:13:19.990]                           invokeRestart("muffleWarning")
[16:13:19.990]                       }
[16:13:19.990]                       else if (inherits(cond, "condition")) {
[16:13:19.990]                         if (!is.null(pattern)) {
[16:13:19.990]                           computeRestarts <- base::computeRestarts
[16:13:19.990]                           grepl <- base::grepl
[16:13:19.990]                           restarts <- computeRestarts(cond)
[16:13:19.990]                           for (restart in restarts) {
[16:13:19.990]                             name <- restart$name
[16:13:19.990]                             if (is.null(name)) 
[16:13:19.990]                               next
[16:13:19.990]                             if (!grepl(pattern, name)) 
[16:13:19.990]                               next
[16:13:19.990]                             invokeRestart(restart)
[16:13:19.990]                             muffled <- TRUE
[16:13:19.990]                             break
[16:13:19.990]                           }
[16:13:19.990]                         }
[16:13:19.990]                       }
[16:13:19.990]                       invisible(muffled)
[16:13:19.990]                     }
[16:13:19.990]                     muffleCondition(cond, pattern = "^muffle")
[16:13:19.990]                   }
[16:13:19.990]                 }
[16:13:19.990]             }
[16:13:19.990]         }))
[16:13:19.990]     }, error = function(ex) {
[16:13:19.990]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:19.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:19.990]                 ...future.rng), started = ...future.startTime, 
[16:13:19.990]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:19.990]             version = "1.8"), class = "FutureResult")
[16:13:19.990]     }, finally = {
[16:13:19.990]         if (!identical(...future.workdir, getwd())) 
[16:13:19.990]             setwd(...future.workdir)
[16:13:19.990]         {
[16:13:19.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:19.990]                 ...future.oldOptions$nwarnings <- NULL
[16:13:19.990]             }
[16:13:19.990]             base::options(...future.oldOptions)
[16:13:19.990]             if (.Platform$OS.type == "windows") {
[16:13:19.990]                 old_names <- names(...future.oldEnvVars)
[16:13:19.990]                 envs <- base::Sys.getenv()
[16:13:19.990]                 names <- names(envs)
[16:13:19.990]                 common <- intersect(names, old_names)
[16:13:19.990]                 added <- setdiff(names, old_names)
[16:13:19.990]                 removed <- setdiff(old_names, names)
[16:13:19.990]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:19.990]                   envs[common]]
[16:13:19.990]                 NAMES <- toupper(changed)
[16:13:19.990]                 args <- list()
[16:13:19.990]                 for (kk in seq_along(NAMES)) {
[16:13:19.990]                   name <- changed[[kk]]
[16:13:19.990]                   NAME <- NAMES[[kk]]
[16:13:19.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.990]                     next
[16:13:19.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.990]                 }
[16:13:19.990]                 NAMES <- toupper(added)
[16:13:19.990]                 for (kk in seq_along(NAMES)) {
[16:13:19.990]                   name <- added[[kk]]
[16:13:19.990]                   NAME <- NAMES[[kk]]
[16:13:19.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.990]                     next
[16:13:19.990]                   args[[name]] <- ""
[16:13:19.990]                 }
[16:13:19.990]                 NAMES <- toupper(removed)
[16:13:19.990]                 for (kk in seq_along(NAMES)) {
[16:13:19.990]                   name <- removed[[kk]]
[16:13:19.990]                   NAME <- NAMES[[kk]]
[16:13:19.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:19.990]                     next
[16:13:19.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:19.990]                 }
[16:13:19.990]                 if (length(args) > 0) 
[16:13:19.990]                   base::do.call(base::Sys.setenv, args = args)
[16:13:19.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:19.990]             }
[16:13:19.990]             else {
[16:13:19.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:19.990]             }
[16:13:19.990]             {
[16:13:19.990]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:19.990]                   0L) {
[16:13:19.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:19.990]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:19.990]                   base::options(opts)
[16:13:19.990]                 }
[16:13:19.990]                 {
[16:13:19.990]                   {
[16:13:19.990]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:19.990]                     NULL
[16:13:19.990]                   }
[16:13:19.990]                   options(future.plan = NULL)
[16:13:19.990]                   if (is.na(NA_character_)) 
[16:13:19.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:19.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:19.990]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:19.990]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.990]                     envir = parent.frame()) 
[16:13:19.990]                   {
[16:13:19.990]                     if (is.function(workers)) 
[16:13:19.990]                       workers <- workers()
[16:13:19.990]                     workers <- structure(as.integer(workers), 
[16:13:19.990]                       class = class(workers))
[16:13:19.990]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.990]                       workers >= 1)
[16:13:19.990]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.990]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.990]                     }
[16:13:19.990]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.990]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.990]                       envir = envir)
[16:13:19.990]                     if (!future$lazy) 
[16:13:19.990]                       future <- run(future)
[16:13:19.990]                     invisible(future)
[16:13:19.990]                   }, b = function (..., workers = availableCores(), 
[16:13:19.990]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:19.990]                     envir = parent.frame()) 
[16:13:19.990]                   {
[16:13:19.990]                     if (is.function(workers)) 
[16:13:19.990]                       workers <- workers()
[16:13:19.990]                     workers <- structure(as.integer(workers), 
[16:13:19.990]                       class = class(workers))
[16:13:19.990]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:19.990]                       workers >= 1)
[16:13:19.990]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:19.990]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:19.990]                     }
[16:13:19.990]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:19.990]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:19.990]                       envir = envir)
[16:13:19.990]                     if (!future$lazy) 
[16:13:19.990]                       future <- run(future)
[16:13:19.990]                     invisible(future)
[16:13:19.990]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:19.990]                 }
[16:13:19.990]             }
[16:13:19.990]         }
[16:13:19.990]     })
[16:13:19.990]     if (TRUE) {
[16:13:19.990]         base::sink(type = "output", split = FALSE)
[16:13:19.990]         if (TRUE) {
[16:13:19.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:19.990]         }
[16:13:19.990]         else {
[16:13:19.990]             ...future.result["stdout"] <- base::list(NULL)
[16:13:19.990]         }
[16:13:19.990]         base::close(...future.stdout)
[16:13:19.990]         ...future.stdout <- NULL
[16:13:19.990]     }
[16:13:19.990]     ...future.result$conditions <- ...future.conditions
[16:13:19.990]     ...future.result$finished <- base::Sys.time()
[16:13:19.990]     ...future.result
[16:13:19.990] }
[16:13:19.993] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[16:13:19.994] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[16:13:20.036] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[16:13:20.036] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[16:13:20.037] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[16:13:20.037] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[16:13:20.038] MultisessionFuture started
[16:13:20.038] - Launch lazy future ... done
[16:13:20.038] run() for ‘MultisessionFuture’ ... done
[16:13:20.038] result() for ClusterFuture ...
[16:13:20.038] receiveMessageFromWorker() for ClusterFuture ...
[16:13:20.039] - Validating connection of MultisessionFuture
[16:13:20.115] - received message: FutureResult
[16:13:20.115] - Received FutureResult
[16:13:20.116] - Erased future from FutureRegistry
[16:13:20.116] result() for ClusterFuture ...
[16:13:20.116] - result already collected: FutureResult
[16:13:20.116] result() for ClusterFuture ... done
[16:13:20.116] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:20.116] result() for ClusterFuture ... done
[16:13:20.116] result() for ClusterFuture ...
[16:13:20.116] - result already collected: FutureResult
[16:13:20.116] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[16:13:20.122] getGlobalsAndPackages() ...
[16:13:20.122] Searching for globals...
[16:13:20.123] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[16:13:20.123] Searching for globals ... DONE
[16:13:20.124] Resolving globals: FALSE
[16:13:20.124] The total size of the 1 globals is 128 bytes (128 bytes)
[16:13:20.125] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[16:13:20.125] - globals: [1] ‘data’
[16:13:20.125] - packages: [1] ‘future’
[16:13:20.125] getGlobalsAndPackages() ... DONE
[16:13:20.125] run() for ‘Future’ ...
[16:13:20.125] - state: ‘created’
[16:13:20.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:20.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:20.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:20.140]   - Field: ‘node’
[16:13:20.140]   - Field: ‘label’
[16:13:20.140]   - Field: ‘local’
[16:13:20.140]   - Field: ‘owner’
[16:13:20.140]   - Field: ‘envir’
[16:13:20.140]   - Field: ‘workers’
[16:13:20.140]   - Field: ‘packages’
[16:13:20.140]   - Field: ‘gc’
[16:13:20.141]   - Field: ‘conditions’
[16:13:20.141]   - Field: ‘persistent’
[16:13:20.141]   - Field: ‘expr’
[16:13:20.141]   - Field: ‘uuid’
[16:13:20.141]   - Field: ‘seed’
[16:13:20.141]   - Field: ‘version’
[16:13:20.141]   - Field: ‘result’
[16:13:20.141]   - Field: ‘asynchronous’
[16:13:20.141]   - Field: ‘calls’
[16:13:20.141]   - Field: ‘globals’
[16:13:20.141]   - Field: ‘stdout’
[16:13:20.142]   - Field: ‘earlySignal’
[16:13:20.142]   - Field: ‘lazy’
[16:13:20.142]   - Field: ‘state’
[16:13:20.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:20.142] - Launch lazy future ...
[16:13:20.142] Packages needed by the future expression (n = 1): ‘future’
[16:13:20.142] Packages needed by future strategies (n = 1): ‘future’
[16:13:20.143] {
[16:13:20.143]     {
[16:13:20.143]         {
[16:13:20.143]             ...future.startTime <- base::Sys.time()
[16:13:20.143]             {
[16:13:20.143]                 {
[16:13:20.143]                   {
[16:13:20.143]                     {
[16:13:20.143]                       {
[16:13:20.143]                         base::local({
[16:13:20.143]                           has_future <- base::requireNamespace("future", 
[16:13:20.143]                             quietly = TRUE)
[16:13:20.143]                           if (has_future) {
[16:13:20.143]                             ns <- base::getNamespace("future")
[16:13:20.143]                             version <- ns[[".package"]][["version"]]
[16:13:20.143]                             if (is.null(version)) 
[16:13:20.143]                               version <- utils::packageVersion("future")
[16:13:20.143]                           }
[16:13:20.143]                           else {
[16:13:20.143]                             version <- NULL
[16:13:20.143]                           }
[16:13:20.143]                           if (!has_future || version < "1.8.0") {
[16:13:20.143]                             info <- base::c(r_version = base::gsub("R version ", 
[16:13:20.143]                               "", base::R.version$version.string), 
[16:13:20.143]                               platform = base::sprintf("%s (%s-bit)", 
[16:13:20.143]                                 base::R.version$platform, 8 * 
[16:13:20.143]                                   base::.Machine$sizeof.pointer), 
[16:13:20.143]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:20.143]                                 "release", "version")], collapse = " "), 
[16:13:20.143]                               hostname = base::Sys.info()[["nodename"]])
[16:13:20.143]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:13:20.143]                               info)
[16:13:20.143]                             info <- base::paste(info, collapse = "; ")
[16:13:20.143]                             if (!has_future) {
[16:13:20.143]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:20.143]                                 info)
[16:13:20.143]                             }
[16:13:20.143]                             else {
[16:13:20.143]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:20.143]                                 info, version)
[16:13:20.143]                             }
[16:13:20.143]                             base::stop(msg)
[16:13:20.143]                           }
[16:13:20.143]                         })
[16:13:20.143]                       }
[16:13:20.143]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:20.143]                       base::options(mc.cores = 1L)
[16:13:20.143]                     }
[16:13:20.143]                     base::local({
[16:13:20.143]                       for (pkg in "future") {
[16:13:20.143]                         base::loadNamespace(pkg)
[16:13:20.143]                         base::library(pkg, character.only = TRUE)
[16:13:20.143]                       }
[16:13:20.143]                     })
[16:13:20.143]                   }
[16:13:20.143]                   options(future.plan = NULL)
[16:13:20.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:20.143]                   future::plan(list(b = function (..., workers = availableCores(), 
[16:13:20.143]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:20.143]                     envir = parent.frame()) 
[16:13:20.143]                   {
[16:13:20.143]                     if (is.function(workers)) 
[16:13:20.143]                       workers <- workers()
[16:13:20.143]                     workers <- structure(as.integer(workers), 
[16:13:20.143]                       class = class(workers))
[16:13:20.143]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:20.143]                       workers >= 1)
[16:13:20.143]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:20.143]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:20.143]                     }
[16:13:20.143]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:20.143]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:20.143]                       envir = envir)
[16:13:20.143]                     if (!future$lazy) 
[16:13:20.143]                       future <- run(future)
[16:13:20.143]                     invisible(future)
[16:13:20.143]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:20.143]                 }
[16:13:20.143]                 ...future.workdir <- getwd()
[16:13:20.143]             }
[16:13:20.143]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:20.143]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:20.143]         }
[16:13:20.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:20.143]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:20.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:20.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:20.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:20.143]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:20.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:20.143]             base::names(...future.oldOptions))
[16:13:20.143]     }
[16:13:20.143]     if (FALSE) {
[16:13:20.143]     }
[16:13:20.143]     else {
[16:13:20.143]         if (TRUE) {
[16:13:20.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:20.143]                 open = "w")
[16:13:20.143]         }
[16:13:20.143]         else {
[16:13:20.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:20.143]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:20.143]         }
[16:13:20.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:20.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:20.143]             base::sink(type = "output", split = FALSE)
[16:13:20.143]             base::close(...future.stdout)
[16:13:20.143]         }, add = TRUE)
[16:13:20.143]     }
[16:13:20.143]     ...future.frame <- base::sys.nframe()
[16:13:20.143]     ...future.conditions <- base::list()
[16:13:20.143]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:20.143]     if (FALSE) {
[16:13:20.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:20.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:20.143]     }
[16:13:20.143]     ...future.result <- base::tryCatch({
[16:13:20.143]         base::withCallingHandlers({
[16:13:20.143]             ...future.value <- base::withVisible(base::local({
[16:13:20.143]                 ...future.makeSendCondition <- local({
[16:13:20.143]                   sendCondition <- NULL
[16:13:20.143]                   function(frame = 1L) {
[16:13:20.143]                     if (is.function(sendCondition)) 
[16:13:20.143]                       return(sendCondition)
[16:13:20.143]                     ns <- getNamespace("parallel")
[16:13:20.143]                     if (exists("sendData", mode = "function", 
[16:13:20.143]                       envir = ns)) {
[16:13:20.143]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:20.143]                         envir = ns)
[16:13:20.143]                       envir <- sys.frame(frame)
[16:13:20.143]                       master <- NULL
[16:13:20.143]                       while (!identical(envir, .GlobalEnv) && 
[16:13:20.143]                         !identical(envir, emptyenv())) {
[16:13:20.143]                         if (exists("master", mode = "list", envir = envir, 
[16:13:20.143]                           inherits = FALSE)) {
[16:13:20.143]                           master <- get("master", mode = "list", 
[16:13:20.143]                             envir = envir, inherits = FALSE)
[16:13:20.143]                           if (inherits(master, c("SOCKnode", 
[16:13:20.143]                             "SOCK0node"))) {
[16:13:20.143]                             sendCondition <<- function(cond) {
[16:13:20.143]                               data <- list(type = "VALUE", value = cond, 
[16:13:20.143]                                 success = TRUE)
[16:13:20.143]                               parallel_sendData(master, data)
[16:13:20.143]                             }
[16:13:20.143]                             return(sendCondition)
[16:13:20.143]                           }
[16:13:20.143]                         }
[16:13:20.143]                         frame <- frame + 1L
[16:13:20.143]                         envir <- sys.frame(frame)
[16:13:20.143]                       }
[16:13:20.143]                     }
[16:13:20.143]                     sendCondition <<- function(cond) NULL
[16:13:20.143]                   }
[16:13:20.143]                 })
[16:13:20.143]                 withCallingHandlers({
[16:13:20.143]                   {
[16:13:20.143]                     value(future(subset(data, a == 2)))
[16:13:20.143]                   }
[16:13:20.143]                 }, immediateCondition = function(cond) {
[16:13:20.143]                   sendCondition <- ...future.makeSendCondition()
[16:13:20.143]                   sendCondition(cond)
[16:13:20.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:20.143]                   {
[16:13:20.143]                     inherits <- base::inherits
[16:13:20.143]                     invokeRestart <- base::invokeRestart
[16:13:20.143]                     is.null <- base::is.null
[16:13:20.143]                     muffled <- FALSE
[16:13:20.143]                     if (inherits(cond, "message")) {
[16:13:20.143]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:20.143]                       if (muffled) 
[16:13:20.143]                         invokeRestart("muffleMessage")
[16:13:20.143]                     }
[16:13:20.143]                     else if (inherits(cond, "warning")) {
[16:13:20.143]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:20.143]                       if (muffled) 
[16:13:20.143]                         invokeRestart("muffleWarning")
[16:13:20.143]                     }
[16:13:20.143]                     else if (inherits(cond, "condition")) {
[16:13:20.143]                       if (!is.null(pattern)) {
[16:13:20.143]                         computeRestarts <- base::computeRestarts
[16:13:20.143]                         grepl <- base::grepl
[16:13:20.143]                         restarts <- computeRestarts(cond)
[16:13:20.143]                         for (restart in restarts) {
[16:13:20.143]                           name <- restart$name
[16:13:20.143]                           if (is.null(name)) 
[16:13:20.143]                             next
[16:13:20.143]                           if (!grepl(pattern, name)) 
[16:13:20.143]                             next
[16:13:20.143]                           invokeRestart(restart)
[16:13:20.143]                           muffled <- TRUE
[16:13:20.143]                           break
[16:13:20.143]                         }
[16:13:20.143]                       }
[16:13:20.143]                     }
[16:13:20.143]                     invisible(muffled)
[16:13:20.143]                   }
[16:13:20.143]                   muffleCondition(cond)
[16:13:20.143]                 })
[16:13:20.143]             }))
[16:13:20.143]             future::FutureResult(value = ...future.value$value, 
[16:13:20.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:20.143]                   ...future.rng), globalenv = if (FALSE) 
[16:13:20.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:20.143]                     ...future.globalenv.names))
[16:13:20.143]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:20.143]         }, condition = base::local({
[16:13:20.143]             c <- base::c
[16:13:20.143]             inherits <- base::inherits
[16:13:20.143]             invokeRestart <- base::invokeRestart
[16:13:20.143]             length <- base::length
[16:13:20.143]             list <- base::list
[16:13:20.143]             seq.int <- base::seq.int
[16:13:20.143]             signalCondition <- base::signalCondition
[16:13:20.143]             sys.calls <- base::sys.calls
[16:13:20.143]             `[[` <- base::`[[`
[16:13:20.143]             `+` <- base::`+`
[16:13:20.143]             `<<-` <- base::`<<-`
[16:13:20.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:20.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:20.143]                   3L)]
[16:13:20.143]             }
[16:13:20.143]             function(cond) {
[16:13:20.143]                 is_error <- inherits(cond, "error")
[16:13:20.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:20.143]                   NULL)
[16:13:20.143]                 if (is_error) {
[16:13:20.143]                   sessionInformation <- function() {
[16:13:20.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:20.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:20.143]                       search = base::search(), system = base::Sys.info())
[16:13:20.143]                   }
[16:13:20.143]                   ...future.conditions[[length(...future.conditions) + 
[16:13:20.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:20.143]                     cond$call), session = sessionInformation(), 
[16:13:20.143]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:20.143]                   signalCondition(cond)
[16:13:20.143]                 }
[16:13:20.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:20.143]                 "immediateCondition"))) {
[16:13:20.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:20.143]                   ...future.conditions[[length(...future.conditions) + 
[16:13:20.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:20.143]                   if (TRUE && !signal) {
[16:13:20.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:20.143]                     {
[16:13:20.143]                       inherits <- base::inherits
[16:13:20.143]                       invokeRestart <- base::invokeRestart
[16:13:20.143]                       is.null <- base::is.null
[16:13:20.143]                       muffled <- FALSE
[16:13:20.143]                       if (inherits(cond, "message")) {
[16:13:20.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:20.143]                         if (muffled) 
[16:13:20.143]                           invokeRestart("muffleMessage")
[16:13:20.143]                       }
[16:13:20.143]                       else if (inherits(cond, "warning")) {
[16:13:20.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:20.143]                         if (muffled) 
[16:13:20.143]                           invokeRestart("muffleWarning")
[16:13:20.143]                       }
[16:13:20.143]                       else if (inherits(cond, "condition")) {
[16:13:20.143]                         if (!is.null(pattern)) {
[16:13:20.143]                           computeRestarts <- base::computeRestarts
[16:13:20.143]                           grepl <- base::grepl
[16:13:20.143]                           restarts <- computeRestarts(cond)
[16:13:20.143]                           for (restart in restarts) {
[16:13:20.143]                             name <- restart$name
[16:13:20.143]                             if (is.null(name)) 
[16:13:20.143]                               next
[16:13:20.143]                             if (!grepl(pattern, name)) 
[16:13:20.143]                               next
[16:13:20.143]                             invokeRestart(restart)
[16:13:20.143]                             muffled <- TRUE
[16:13:20.143]                             break
[16:13:20.143]                           }
[16:13:20.143]                         }
[16:13:20.143]                       }
[16:13:20.143]                       invisible(muffled)
[16:13:20.143]                     }
[16:13:20.143]                     muffleCondition(cond, pattern = "^muffle")
[16:13:20.143]                   }
[16:13:20.143]                 }
[16:13:20.143]                 else {
[16:13:20.143]                   if (TRUE) {
[16:13:20.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:20.143]                     {
[16:13:20.143]                       inherits <- base::inherits
[16:13:20.143]                       invokeRestart <- base::invokeRestart
[16:13:20.143]                       is.null <- base::is.null
[16:13:20.143]                       muffled <- FALSE
[16:13:20.143]                       if (inherits(cond, "message")) {
[16:13:20.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:20.143]                         if (muffled) 
[16:13:20.143]                           invokeRestart("muffleMessage")
[16:13:20.143]                       }
[16:13:20.143]                       else if (inherits(cond, "warning")) {
[16:13:20.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:20.143]                         if (muffled) 
[16:13:20.143]                           invokeRestart("muffleWarning")
[16:13:20.143]                       }
[16:13:20.143]                       else if (inherits(cond, "condition")) {
[16:13:20.143]                         if (!is.null(pattern)) {
[16:13:20.143]                           computeRestarts <- base::computeRestarts
[16:13:20.143]                           grepl <- base::grepl
[16:13:20.143]                           restarts <- computeRestarts(cond)
[16:13:20.143]                           for (restart in restarts) {
[16:13:20.143]                             name <- restart$name
[16:13:20.143]                             if (is.null(name)) 
[16:13:20.143]                               next
[16:13:20.143]                             if (!grepl(pattern, name)) 
[16:13:20.143]                               next
[16:13:20.143]                             invokeRestart(restart)
[16:13:20.143]                             muffled <- TRUE
[16:13:20.143]                             break
[16:13:20.143]                           }
[16:13:20.143]                         }
[16:13:20.143]                       }
[16:13:20.143]                       invisible(muffled)
[16:13:20.143]                     }
[16:13:20.143]                     muffleCondition(cond, pattern = "^muffle")
[16:13:20.143]                   }
[16:13:20.143]                 }
[16:13:20.143]             }
[16:13:20.143]         }))
[16:13:20.143]     }, error = function(ex) {
[16:13:20.143]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:20.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:20.143]                 ...future.rng), started = ...future.startTime, 
[16:13:20.143]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:20.143]             version = "1.8"), class = "FutureResult")
[16:13:20.143]     }, finally = {
[16:13:20.143]         if (!identical(...future.workdir, getwd())) 
[16:13:20.143]             setwd(...future.workdir)
[16:13:20.143]         {
[16:13:20.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:20.143]                 ...future.oldOptions$nwarnings <- NULL
[16:13:20.143]             }
[16:13:20.143]             base::options(...future.oldOptions)
[16:13:20.143]             if (.Platform$OS.type == "windows") {
[16:13:20.143]                 old_names <- names(...future.oldEnvVars)
[16:13:20.143]                 envs <- base::Sys.getenv()
[16:13:20.143]                 names <- names(envs)
[16:13:20.143]                 common <- intersect(names, old_names)
[16:13:20.143]                 added <- setdiff(names, old_names)
[16:13:20.143]                 removed <- setdiff(old_names, names)
[16:13:20.143]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:20.143]                   envs[common]]
[16:13:20.143]                 NAMES <- toupper(changed)
[16:13:20.143]                 args <- list()
[16:13:20.143]                 for (kk in seq_along(NAMES)) {
[16:13:20.143]                   name <- changed[[kk]]
[16:13:20.143]                   NAME <- NAMES[[kk]]
[16:13:20.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:20.143]                     next
[16:13:20.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:20.143]                 }
[16:13:20.143]                 NAMES <- toupper(added)
[16:13:20.143]                 for (kk in seq_along(NAMES)) {
[16:13:20.143]                   name <- added[[kk]]
[16:13:20.143]                   NAME <- NAMES[[kk]]
[16:13:20.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:20.143]                     next
[16:13:20.143]                   args[[name]] <- ""
[16:13:20.143]                 }
[16:13:20.143]                 NAMES <- toupper(removed)
[16:13:20.143]                 for (kk in seq_along(NAMES)) {
[16:13:20.143]                   name <- removed[[kk]]
[16:13:20.143]                   NAME <- NAMES[[kk]]
[16:13:20.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:20.143]                     next
[16:13:20.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:20.143]                 }
[16:13:20.143]                 if (length(args) > 0) 
[16:13:20.143]                   base::do.call(base::Sys.setenv, args = args)
[16:13:20.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:20.143]             }
[16:13:20.143]             else {
[16:13:20.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:20.143]             }
[16:13:20.143]             {
[16:13:20.143]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:20.143]                   0L) {
[16:13:20.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:20.143]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:20.143]                   base::options(opts)
[16:13:20.143]                 }
[16:13:20.143]                 {
[16:13:20.143]                   {
[16:13:20.143]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:20.143]                     NULL
[16:13:20.143]                   }
[16:13:20.143]                   options(future.plan = NULL)
[16:13:20.143]                   if (is.na(NA_character_)) 
[16:13:20.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:20.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:20.143]                   future::plan(list(a = function (..., workers = availableCores(), 
[16:13:20.143]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:20.143]                     envir = parent.frame()) 
[16:13:20.143]                   {
[16:13:20.143]                     if (is.function(workers)) 
[16:13:20.143]                       workers <- workers()
[16:13:20.143]                     workers <- structure(as.integer(workers), 
[16:13:20.143]                       class = class(workers))
[16:13:20.143]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:20.143]                       workers >= 1)
[16:13:20.143]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:20.143]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:20.143]                     }
[16:13:20.143]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:20.143]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:20.143]                       envir = envir)
[16:13:20.143]                     if (!future$lazy) 
[16:13:20.143]                       future <- run(future)
[16:13:20.143]                     invisible(future)
[16:13:20.143]                   }, b = function (..., workers = availableCores(), 
[16:13:20.143]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:13:20.143]                     envir = parent.frame()) 
[16:13:20.143]                   {
[16:13:20.143]                     if (is.function(workers)) 
[16:13:20.143]                       workers <- workers()
[16:13:20.143]                     workers <- structure(as.integer(workers), 
[16:13:20.143]                       class = class(workers))
[16:13:20.143]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:13:20.143]                       workers >= 1)
[16:13:20.143]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:13:20.143]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:13:20.143]                     }
[16:13:20.143]                     future <- MultisessionFuture(..., workers = workers, 
[16:13:20.143]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:13:20.143]                       envir = envir)
[16:13:20.143]                     if (!future$lazy) 
[16:13:20.143]                       future <- run(future)
[16:13:20.143]                     invisible(future)
[16:13:20.143]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:20.143]                 }
[16:13:20.143]             }
[16:13:20.143]         }
[16:13:20.143]     })
[16:13:20.143]     if (TRUE) {
[16:13:20.143]         base::sink(type = "output", split = FALSE)
[16:13:20.143]         if (TRUE) {
[16:13:20.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:20.143]         }
[16:13:20.143]         else {
[16:13:20.143]             ...future.result["stdout"] <- base::list(NULL)
[16:13:20.143]         }
[16:13:20.143]         base::close(...future.stdout)
[16:13:20.143]         ...future.stdout <- NULL
[16:13:20.143]     }
[16:13:20.143]     ...future.result$conditions <- ...future.conditions
[16:13:20.143]     ...future.result$finished <- base::Sys.time()
[16:13:20.143]     ...future.result
[16:13:20.143] }
[16:13:20.146] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[16:13:20.146] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[16:13:20.147] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[16:13:20.147] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[16:13:20.147] MultisessionFuture started
[16:13:20.148] - Launch lazy future ... done
[16:13:20.148] run() for ‘MultisessionFuture’ ... done
[16:13:20.148] result() for ClusterFuture ...
[16:13:20.148] receiveMessageFromWorker() for ClusterFuture ...
[16:13:20.148] - Validating connection of MultisessionFuture
[16:13:20.206] - received message: FutureResult
[16:13:20.206] - Received FutureResult
[16:13:20.206] - Erased future from FutureRegistry
[16:13:20.206] result() for ClusterFuture ...
[16:13:20.206] - result already collected: FutureResult
[16:13:20.206] result() for ClusterFuture ... done
[16:13:20.207] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:20.207] result() for ClusterFuture ... done
[16:13:20.207] result() for ClusterFuture ...
[16:13:20.207] - result already collected: FutureResult
[16:13:20.207] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[16:13:20.210] plan(): Setting new future strategy stack:
[16:13:20.210] List of future strategies:
[16:13:20.210] 1. FutureStrategy:
[16:13:20.210]    - args: function (..., envir = parent.frame())
[16:13:20.210]    - tweaked: FALSE
[16:13:20.210]    - call: future::plan(oplan)
[16:13:20.211] plan(): nbrOfWorkers() = 1
> 
