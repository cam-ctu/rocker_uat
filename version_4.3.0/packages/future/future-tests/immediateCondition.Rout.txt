
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:12:57.048] plan(): Setting new future strategy stack:
[16:12:57.049] List of future strategies:
[16:12:57.049] 1. sequential:
[16:12:57.049]    - args: function (..., envir = parent.frame())
[16:12:57.049]    - tweaked: FALSE
[16:12:57.049]    - call: future::plan("sequential")
[16:12:57.063] plan(): nbrOfWorkers() = 1
> options(future.debug = FALSE)
> 
> f_try <- function(f, ...) {
+   res <- tryCatch(..., error = identity)
+   if (inherits(res, "error")) {
+     label <- sQuote(f$label)
+     if (length(label) == 0) label <- "<none>"
+     msg <- sprintf("Test with future (%s) of class %s failed assertion: %s", label, sQuote(class(f)[1]), conditionMessage(res))
+     stop(msg, call.=FALSE)
+   }
+   res
+ }
> 
> message("*** immediateCondition:s ...")
*** immediateCondition:s ...
> 
> immediateMessage <- function(..., domain = NULL, appendLF = TRUE) {
+    msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
+    call <- sys.call()
+    m <- simpleMessage(msg, call)
+    class(m) <- c(class(m), "immediateCondition")
+    message(m)
+    invisible(m)
+ }
> 
> immediateWarning <- function(..., domain = NULL) {
+    msg <- .makeMessage(..., domain = domain)
+    call <- sys.call()
+    w <- simpleWarning(msg, call)
+    class(w) <- c(class(w), "immediateCondition")
+    warning(w)
+    invisible(w)
+ }
> 
> recordConditions <- function(expr, ...) {
+   conditions <- list()
+   withCallingHandlers(expr, condition = function(c) {
+     attr(c, "received") <- Sys.time()
+     conditions[[length(conditions) + 1L]] <<- c
+   })
+   conditions
+ }
> 
> recordMessages <- function(expr, ...) {
+   sapply(recordConditions(expr, ...), FUN = conditionMessage)
+ }
> 
> ## FIXME: Make sure to set also with cores = 2L /HB 2020-11-10
> 
> if (isTRUE(getOption("future.psock.relay.immediate"))) {
+   excl <- "cluster"
+   if (getRversion() < "3.4.0") excl <- c(excl, "multisession")
+   strategies <- supportedStrategies(cores = 2L, excl = excl)
+   strategies <- c(strategies, "sequential")
+ } else {
+   strategies <- "sequential"
+ }
> print(strategies)
[1] "sequential"
> 
> for (ss in seq_along(strategies)) {
+   strategy <- strategies[[ss]]
+   message(sprintf("Immediate relay w/ %s ...", names(strategies)[ss]))
+   plan(strategy)
+ 
+   message("* A single future ...")
+ 
+   message("- creating future")
+   msgs <- recordMessages({
+     f <- future({
+       immediateMessage("IM1")
+       message("M")
+       immediateWarning("IW")
+       immediateMessage("IM2")
+       ## RACE CONDITION IN ASSERTION:
+       ## Add some leeway for the immediateCondition files written by
+       ## multicore futures to "settle" on the file system
+       Sys.sleep(1.0)
+       42L
+     }, label = "single-future")
+   })
+   message("  class: ", paste(sQuote(class(f)), collapse = ", "))
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     if (inherits(f, "UniprocessFuture")) {
+       stopifnot(identical(msgs, c("IM1\n", "IW", "IM2\n")))
+     } else {
+       stopifnot(length(msgs) == 0L)
+     }
+   })
+   
+   message("- checking if resolved")
+   msgs <- recordMessages({
+     r <- resolved(f)
+   })
+   message("  result: ", r)
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     if (inherits(f, "MultiprocessFuture")) {
+       stopifnot(identical(msgs, c("IM1\n", "IW", "IM2\n")))
+     } else {
+       stopifnot(length(msgs) == 0L)
+     }
+   })
+ 
+   message("- resolve w/out collecting results")
+   msgs <- recordMessages({
+     f <- resolve(f)
+   })
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     stopifnot(length(msgs) == 0L)
+   })
+   
+   message("- resolve w/ collect results")
+   msgs <- recordMessages({
+     f <- resolve(f, result = TRUE)
+   })
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     if (inherits(f, c("UniprocessFuture", "MultiprocessFuture"))) {
+       stopifnot(length(msgs) == 0L)
+     } else {
+       stopifnot(identical(msgs, c("IM1\n", "IW", "IM2\n")))
+     }
+   })
+   
+   message("- getting value")
+   msgs <- recordMessages({
+     v <- value(f)
+   })
+   message("  value: ", v)
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     if (inherits(f, c("UniprocessFuture", "MultiprocessFuture"))) {
+       stopifnot(identical(msgs, "M\n"))
+     } else {
+       stopifnot(identical(msgs, c("IM1\n", "IW", "IM2\n", "M\n")))
+     }
+   })
+   
+   message("- getting value again")
+   msgs <- recordMessages({
+     v <- value(f)
+   })
+   message("  value: ", v)
+   f_try(f, {
+     stopifnot(identical(msgs, "M\n"))
+   })
+ 
+   message("* A single future ... DONE")
+ 
+ 
+   message("* Two futures ... ")
+ 
+   message("- list of two futures")
+   fs <- list()
+   msgs <- recordMessages({
+     fs[[1]] <- future({
+       immediateMessage("IM1")
+       Sys.sleep(0.1)
+       message("M1")
+       immediateWarning("IW1")
+       ## RACE CONDITION IN ASSERTION:
+       ## Add some leeway for the immediateCondition files written by
+       ## multicore futures to "settle" on the file system
+       Sys.sleep(1.0)
+       1L
+     }, label = "future-1")
+     fs[[2]] <- future({
+       immediateMessage("IM2")
+       Sys.sleep(0.1)
+       message("M2")
+       immediateWarning("IW2")
+       ## RACE CONDITION IN ASSERTION:
+       ## Add some leeway for the immediateCondition files written by
+       ## multicore futures to "settle" on the file system
+       Sys.sleep(1.0)
+       2L
+     }, label = "future-2")
+   })
+   message("  class: ", paste(sQuote(class(fs[[1]])), collapse = ", "))
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(fs[[1]], {
+     if (inherits(fs[[1]], "UniprocessFuture")) {
+       stopifnot(identical(msgs, c("IM1\n", "IW1", "IM2\n", "IW2")))
+     } else {
+       stopifnot(length(msgs) == 0L)
+     }
+   })
+ 
+   message("- check if resolved")
+   msgs <- recordMessages({
+     rs <- resolved(fs)
+   })
+   message("  result: ", paste(rs, collapse = ", "))
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     if (inherits(f, "MultiprocessFuture")) {
+       stopifnot(all(msgs %in% c("IM1\n", "IM2\n", "IW1", "IW2")))
+       if (inherits(f, "MulticoreFuture")) {
+         stopifnot(identical(msgs, c("IM1\n", "IM2\n", "IW1", "IW2")))
+       } else if (inherits(f, "MultisessionFuture")) {
+         stopifnot(identical(msgs, c("IM1\n", "IW1", "IM2\n", "IW2")))
+       }
+     } else {
+       stopifnot(length(msgs) == 0L)
+     }
+   })
+ 
+   message("- resolve w/out collecting results")
+   msgs <- recordMessages({
+     fs <- resolve(fs)
+   })
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     stopifnot(length(msgs) == 0L)
+   })
+ 
+   message("- resolve w/ collect results")
+   msgs <- recordMessages({
+     fs <- resolve(fs, result = TRUE)
+   })
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     if (inherits(fs[[1]], c("UniprocessFuture", "MultiprocessFuture", "CallrFuture", "BatchtoolsFuture"))) {
+       stopifnot(length(msgs) == 0L)
+     } else {
+       stopifnot(identical(msgs, c("IM1\n", "IW1", "IM2\n", "IW2")))
+     }
+   })
+ 
+   message("- getting value")
+   msgs <- recordMessages({
+     vs <- value(fs)
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     stopifnot(identical(msgs, c("M1\n", "M2\n")))
+   })
+   
+   message("- getting value again")
+   msgs <- recordMessages({
+     vs <- value(fs)
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   message(sprintf("  msgs [n=%d]: %s", length(msgs), paste(sQuote(msgs), collapse = ", ")))
+   f_try(f, {
+     stopifnot(identical(msgs, c("M1\n", "M2\n")))
+   })
+ 
+   message("- getting values one by one")
+   msgs <- recordMessages({
+     vs <- c(
+       value(fs[[1]]),
+       value(fs[[2]])
+     )
+   })
+   message("  values: ", paste(vs, collapse = ", "))
+   f_try(f, {
+     stopifnot(identical(msgs, c("M1\n", "M2\n")))
+   })
+ 
+   message("* Two futures ... DONE")
+ 
+   message(sprintf("Immediate relay w/ %s ... done", names(strategies)[ss]))
+ } ## for (ss ...)

* A single future ...
- creating future
IM1
Warning in immediateWarning("IW") : IW
IM2
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
  msgs [n=3]: ‘IM1
’, ‘IW’, ‘IM2
’
- checking if resolved
  result: TRUE
  msgs [n=0]: 
- resolve w/out collecting results
  msgs [n=0]: 
- resolve w/ collect results
  msgs [n=0]: 
- getting value
M
  value: 42
  msgs [n=1]: ‘M
’
- getting value again
M
  value: 42
* A single future ... DONE
* Two futures ... 
- list of two futures
IM1
Warning in immediateWarning("IW1") : IW1
IM2
Warning in immediateWarning("IW2") : IW2
  class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
  msgs [n=4]: ‘IM1
’, ‘IW1’, ‘IM2
’, ‘IW2’
- check if resolved
  result: TRUE, TRUE
  msgs [n=0]: 
- resolve w/out collecting results
  msgs [n=0]: 
- resolve w/ collect results
  msgs [n=0]: 
- getting value
M1
M2
  values: 1, 2
  msgs [n=2]: ‘M1
’, ‘M2
’
- getting value again
M1
M2
  values: 1, 2
  msgs [n=2]: ‘M1
’, ‘M2
’
- getting values one by one
M1
M2
  values: 1, 2
* Two futures ... DONE

> 
> message("*** immediateCondition:s ... DONE")
*** immediateCondition:s ... DONE
> 
> source("incl/end.R")
> 
