
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:11:55.648] plan(): Setting new future strategy stack:
[16:11:55.649] List of future strategies:
[16:11:55.649] 1. sequential:
[16:11:55.649]    - args: function (..., envir = parent.frame())
[16:11:55.649]    - tweaked: FALSE
[16:11:55.649]    - call: future::plan("sequential")
[16:11:55.662] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[16:11:55.676] plan(): Setting new future strategy stack:
[16:11:55.676] List of future strategies:
[16:11:55.676] 1. sequential:
[16:11:55.676]    - args: function (..., envir = parent.frame())
[16:11:55.676]    - tweaked: FALSE
[16:11:55.676]    - call: plan(sequential)
[16:11:55.687] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[16:11:55.696] getGlobalsAndPackages() ...
[16:11:55.696] Searching for globals...
[16:11:55.703] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.703] Searching for globals ... DONE
[16:11:55.704] Resolving globals: FALSE
[16:11:55.705] The total size of the 2 globals is 224 bytes (224 bytes)
[16:11:55.705] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 224 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (168 bytes of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.705] - globals: [2] ‘x’, ‘i’
[16:11:55.705] 
[16:11:55.706] getGlobalsAndPackages() ... DONE
[16:11:55.706] getGlobalsAndPackages() ...
[16:11:55.706] Searching for globals...
[16:11:55.708] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.708] Searching for globals ... DONE
[16:11:55.708] Resolving globals: FALSE
[16:11:55.709] The total size of the 2 globals is 8.41 KiB (8608 bytes)
[16:11:55.709] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 8.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (8.35 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.709] - globals: [2] ‘x’, ‘i’
[16:11:55.710] 
[16:11:55.710] getGlobalsAndPackages() ... DONE
[16:11:55.710] getGlobalsAndPackages() ...
[16:11:55.710] Searching for globals...
[16:11:55.712] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.712] Searching for globals ... DONE
[16:11:55.712] Resolving globals: FALSE
[16:11:55.713] The total size of the 2 globals is 16.76 KiB (17160 bytes)
[16:11:55.713] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 16.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (16.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.713] - globals: [2] ‘x’, ‘i’
[16:11:55.714] 
[16:11:55.714] getGlobalsAndPackages() ... DONE
[16:11:55.714] getGlobalsAndPackages() ...
[16:11:55.714] Searching for globals...
[16:11:55.716] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.716] Searching for globals ... DONE
[16:11:55.716] Resolving globals: FALSE
[16:11:55.717] The total size of the 2 globals is 25.11 KiB (25712 bytes)
[16:11:55.717] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 25.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (25.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.718] - globals: [2] ‘x’, ‘i’
[16:11:55.718] 
[16:11:55.718] getGlobalsAndPackages() ... DONE
[16:11:55.718] getGlobalsAndPackages() ...
[16:11:55.718] Searching for globals...
[16:11:55.720] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.720] Searching for globals ... DONE
[16:11:55.720] Resolving globals: FALSE
[16:11:55.724] The total size of the 2 globals is 33.46 KiB (34264 bytes)
[16:11:55.724] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.724] - globals: [2] ‘x’, ‘i’
[16:11:55.724] 
[16:11:55.724] getGlobalsAndPackages() ... DONE
[16:11:55.725] getGlobalsAndPackages() ...
[16:11:55.725] Searching for globals...
[16:11:55.726] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.727] Searching for globals ... DONE
[16:11:55.727] Resolving globals: FALSE
[16:11:55.729] The total size of the 2 globals is 41.81 KiB (42816 bytes)
[16:11:55.729] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 41.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (41.76 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.729] - globals: [2] ‘x’, ‘i’
[16:11:55.729] 
[16:11:55.729] getGlobalsAndPackages() ... DONE
[16:11:55.730] getGlobalsAndPackages() ...
[16:11:55.730] Searching for globals...
[16:11:55.731] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.731] Searching for globals ... DONE
[16:11:55.731] Resolving globals: FALSE
[16:11:55.733] The total size of the 2 globals is 50.16 KiB (51368 bytes)
[16:11:55.734] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 50.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (50.11 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.734] - globals: [2] ‘x’, ‘i’
[16:11:55.734] 
[16:11:55.734] getGlobalsAndPackages() ... DONE
[16:11:55.735] getGlobalsAndPackages() ...
[16:11:55.735] Searching for globals...
[16:11:55.736] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.736] Searching for globals ... DONE
[16:11:55.736] Resolving globals: FALSE
[16:11:55.739] The total size of the 2 globals is 58.52 KiB (59920 bytes)
[16:11:55.739] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 58.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (58.46 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.739] - globals: [2] ‘x’, ‘i’
[16:11:55.739] 
[16:11:55.739] getGlobalsAndPackages() ... DONE
[16:11:55.740] getGlobalsAndPackages() ...
[16:11:55.740] Searching for globals...
[16:11:55.741] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.742] Searching for globals ... DONE
[16:11:55.742] Resolving globals: FALSE
[16:11:55.745] The total size of the 2 globals is 66.87 KiB (68472 bytes)
[16:11:55.746] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 66.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (66.81 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.746] - globals: [2] ‘x’, ‘i’
[16:11:55.746] 
[16:11:55.746] getGlobalsAndPackages() ... DONE
[16:11:55.747] getGlobalsAndPackages() ...
[16:11:55.747] Searching for globals...
[16:11:55.748] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.748] Searching for globals ... DONE
[16:11:55.748] Resolving globals: FALSE
[16:11:55.751] The total size of the 2 globals is 75.22 KiB (77024 bytes)
[16:11:55.752] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 75.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (75.16 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.752] - globals: [2] ‘x’, ‘i’
[16:11:55.752] 
[16:11:55.752] getGlobalsAndPackages() ... DONE
[16:11:55.752] getGlobalsAndPackages() ...
[16:11:55.753] Searching for globals...
[16:11:55.754] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.754] Searching for globals ... DONE
[16:11:55.754] Resolving globals: FALSE
[16:11:55.757] The total size of the 2 globals is 83.57 KiB (85576 bytes)
[16:11:55.758] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 83.57 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (83.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.758] - globals: [2] ‘x’, ‘i’
[16:11:55.758] 
[16:11:55.758] getGlobalsAndPackages() ... DONE
[16:11:55.758] getGlobalsAndPackages() ...
[16:11:55.758] Searching for globals...
[16:11:55.760] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.760] Searching for globals ... DONE
[16:11:55.760] Resolving globals: FALSE
[16:11:55.763] The total size of the 2 globals is 91.92 KiB (94128 bytes)
[16:11:55.764] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 91.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (91.87 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.764] - globals: [2] ‘x’, ‘i’
[16:11:55.765] 
[16:11:55.765] getGlobalsAndPackages() ... DONE
[16:11:55.766] getGlobalsAndPackages() ...
[16:11:55.766] Searching for globals...
[16:11:55.767] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.767] Searching for globals ... DONE
[16:11:55.767] Resolving globals: FALSE
[16:11:55.771] The total size of the 2 globals is 100.27 KiB (102680 bytes)
[16:11:55.771] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 100.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (100.22 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.772] - globals: [2] ‘x’, ‘i’
[16:11:55.772] 
[16:11:55.772] getGlobalsAndPackages() ... DONE
[16:11:55.772] getGlobalsAndPackages() ...
[16:11:55.772] Searching for globals...
[16:11:55.774] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.774] Searching for globals ... DONE
[16:11:55.774] Resolving globals: FALSE
[16:11:55.778] The total size of the 2 globals is 108.62 KiB (111232 bytes)
[16:11:55.778] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 108.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (108.57 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.778] - globals: [2] ‘x’, ‘i’
[16:11:55.779] 
[16:11:55.779] getGlobalsAndPackages() ... DONE
[16:11:55.779] getGlobalsAndPackages() ...
[16:11:55.779] Searching for globals...
[16:11:55.781] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.781] Searching for globals ... DONE
[16:11:55.781] Resolving globals: FALSE
[16:11:55.786] The total size of the 2 globals is 116.98 KiB (119784 bytes)
[16:11:55.786] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 116.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (116.92 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.787] - globals: [2] ‘x’, ‘i’
[16:11:55.787] 
[16:11:55.787] getGlobalsAndPackages() ... DONE
[16:11:55.787] getGlobalsAndPackages() ...
[16:11:55.787] Searching for globals...
[16:11:55.789] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.789] Searching for globals ... DONE
[16:11:55.789] Resolving globals: FALSE
[16:11:55.793] The total size of the 2 globals is 125.33 KiB (128336 bytes)
[16:11:55.794] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 125.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (125.27 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.794] - globals: [2] ‘x’, ‘i’
[16:11:55.794] 
[16:11:55.794] getGlobalsAndPackages() ... DONE
[16:11:55.794] getGlobalsAndPackages() ...
[16:11:55.795] Searching for globals...
[16:11:55.796] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.796] Searching for globals ... DONE
[16:11:55.796] Resolving globals: FALSE
[16:11:55.801] The total size of the 2 globals is 133.68 KiB (136888 bytes)
[16:11:55.801] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 133.68 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133.62 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.801] - globals: [2] ‘x’, ‘i’
[16:11:55.801] 
[16:11:55.801] getGlobalsAndPackages() ... DONE
[16:11:55.802] getGlobalsAndPackages() ...
[16:11:55.802] Searching for globals...
[16:11:55.804] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.805] Searching for globals ... DONE
[16:11:55.805] Resolving globals: FALSE
[16:11:55.809] The total size of the 2 globals is 142.03 KiB (145440 bytes)
[16:11:55.810] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 142.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (141.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.810] - globals: [2] ‘x’, ‘i’
[16:11:55.810] 
[16:11:55.810] getGlobalsAndPackages() ... DONE
[16:11:55.811] getGlobalsAndPackages() ...
[16:11:55.811] Searching for globals...
[16:11:55.812] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.812] Searching for globals ... DONE
[16:11:55.812] Resolving globals: FALSE
[16:11:55.817] The total size of the 2 globals is 150.38 KiB (153992 bytes)
[16:11:55.818] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 150.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (150.33 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.818] - globals: [2] ‘x’, ‘i’
[16:11:55.818] 
[16:11:55.818] getGlobalsAndPackages() ... DONE
[16:11:55.819] getGlobalsAndPackages() ...
[16:11:55.819] Searching for globals...
[16:11:55.820] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.820] Searching for globals ... DONE
[16:11:55.820] Resolving globals: FALSE
[16:11:55.827] The total size of the 2 globals is 158.73 KiB (162544 bytes)
[16:11:55.827] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 158.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (158.68 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.827] - globals: [2] ‘x’, ‘i’
[16:11:55.827] 
[16:11:55.828] getGlobalsAndPackages() ... DONE
[16:11:55.828] getGlobalsAndPackages() ...
[16:11:55.828] Searching for globals...
[16:11:55.830] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.830] Searching for globals ... DONE
[16:11:55.830] Resolving globals: FALSE
[16:11:55.835] The total size of the 2 globals is 167.09 KiB (171096 bytes)
[16:11:55.836] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 167.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (167.03 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.836] - globals: [2] ‘x’, ‘i’
[16:11:55.836] 
[16:11:55.836] getGlobalsAndPackages() ... DONE
[16:11:55.836] getGlobalsAndPackages() ...
[16:11:55.837] Searching for globals...
[16:11:55.838] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.838] Searching for globals ... DONE
[16:11:55.838] Resolving globals: FALSE
[16:11:55.845] The total size of the 2 globals is 175.44 KiB (179648 bytes)
[16:11:55.845] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 175.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (175.38 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.846] - globals: [2] ‘x’, ‘i’
[16:11:55.846] 
[16:11:55.846] getGlobalsAndPackages() ... DONE
[16:11:55.846] getGlobalsAndPackages() ...
[16:11:55.846] Searching for globals...
[16:11:55.848] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.848] Searching for globals ... DONE
[16:11:55.848] Resolving globals: FALSE
[16:11:55.854] The total size of the 2 globals is 183.79 KiB (188200 bytes)
[16:11:55.854] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 183.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (183.73 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.855] - globals: [2] ‘x’, ‘i’
[16:11:55.855] 
[16:11:55.855] getGlobalsAndPackages() ... DONE
[16:11:55.855] getGlobalsAndPackages() ...
[16:11:55.855] Searching for globals...
[16:11:55.857] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.857] Searching for globals ... DONE
[16:11:55.857] Resolving globals: FALSE
[16:11:55.865] The total size of the 2 globals is 192.14 KiB (196752 bytes)
[16:11:55.865] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 192.14 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (192.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.865] - globals: [2] ‘x’, ‘i’
[16:11:55.865] 
[16:11:55.866] getGlobalsAndPackages() ... DONE
[16:11:55.866] getGlobalsAndPackages() ...
[16:11:55.866] Searching for globals...
[16:11:55.868] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.868] Searching for globals ... DONE
[16:11:55.868] Resolving globals: FALSE
[16:11:55.874] The total size of the 2 globals is 200.49 KiB (205304 bytes)
[16:11:55.875] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 200.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (200.44 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.875] - globals: [2] ‘x’, ‘i’
[16:11:55.875] 
[16:11:55.875] getGlobalsAndPackages() ... DONE
[16:11:55.876] getGlobalsAndPackages() ...
[16:11:55.877] Searching for globals...
[16:11:55.878] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.878] Searching for globals ... DONE
[16:11:55.878] Resolving globals: FALSE
[16:11:55.885] The total size of the 2 globals is 208.84 KiB (213856 bytes)
[16:11:55.886] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 208.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (208.79 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.886] - globals: [2] ‘x’, ‘i’
[16:11:55.886] 
[16:11:55.886] getGlobalsAndPackages() ... DONE
[16:11:55.886] getGlobalsAndPackages() ...
[16:11:55.886] Searching for globals...
[16:11:55.888] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.888] Searching for globals ... DONE
[16:11:55.888] Resolving globals: FALSE
[16:11:55.896] The total size of the 2 globals is 217.20 KiB (222408 bytes)
[16:11:55.897] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 217.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (217.14 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.897] - globals: [2] ‘x’, ‘i’
[16:11:55.897] 
[16:11:55.897] getGlobalsAndPackages() ... DONE
[16:11:55.897] getGlobalsAndPackages() ...
[16:11:55.897] Searching for globals...
[16:11:55.899] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.899] Searching for globals ... DONE
[16:11:55.899] Resolving globals: FALSE
[16:11:55.906] The total size of the 2 globals is 225.55 KiB (230960 bytes)
[16:11:55.907] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 225.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (225.49 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.907] - globals: [2] ‘x’, ‘i’
[16:11:55.907] 
[16:11:55.907] getGlobalsAndPackages() ... DONE
[16:11:55.907] getGlobalsAndPackages() ...
[16:11:55.908] Searching for globals...
[16:11:55.909] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.909] Searching for globals ... DONE
[16:11:55.909] Resolving globals: FALSE
[16:11:55.918] The total size of the 2 globals is 233.90 KiB (239512 bytes)
[16:11:55.918] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 233.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (233.84 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.918] - globals: [2] ‘x’, ‘i’
[16:11:55.918] 
[16:11:55.918] getGlobalsAndPackages() ... DONE
[16:11:55.919] getGlobalsAndPackages() ...
[16:11:55.919] Searching for globals...
[16:11:55.920] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.921] Searching for globals ... DONE
[16:11:55.921] Resolving globals: FALSE
[16:11:55.929] The total size of the 2 globals is 242.25 KiB (248064 bytes)
[16:11:55.930] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.930] - globals: [2] ‘x’, ‘i’
[16:11:55.930] 
[16:11:55.930] getGlobalsAndPackages() ... DONE
[16:11:55.930] getGlobalsAndPackages() ...
[16:11:55.931] Searching for globals...
[16:11:55.932] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.932] Searching for globals ... DONE
[16:11:55.932] Resolving globals: FALSE
[16:11:55.940] The total size of the 2 globals is 250.60 KiB (256616 bytes)
[16:11:55.941] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 250.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (250.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.941] - globals: [2] ‘x’, ‘i’
[16:11:55.941] 
[16:11:55.941] getGlobalsAndPackages() ... DONE
[16:11:55.941] getGlobalsAndPackages() ...
[16:11:55.942] Searching for globals...
[16:11:55.944] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.944] Searching for globals ... DONE
[16:11:55.944] Resolving globals: FALSE
[16:11:55.952] The total size of the 2 globals is 258.95 KiB (265168 bytes)
[16:11:55.953] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 258.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (258.90 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.953] - globals: [2] ‘x’, ‘i’
[16:11:55.953] 
[16:11:55.953] getGlobalsAndPackages() ... DONE
[16:11:55.954] getGlobalsAndPackages() ...
[16:11:55.954] Searching for globals...
[16:11:55.955] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.955] Searching for globals ... DONE
[16:11:55.955] Resolving globals: FALSE
[16:11:55.965] The total size of the 2 globals is 267.30 KiB (273720 bytes)
[16:11:55.965] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 267.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (267.25 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.965] - globals: [2] ‘x’, ‘i’
[16:11:55.965] 
[16:11:55.965] getGlobalsAndPackages() ... DONE
[16:11:55.966] getGlobalsAndPackages() ...
[16:11:55.966] Searching for globals...
[16:11:55.967] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.967] Searching for globals ... DONE
[16:11:55.968] Resolving globals: FALSE
[16:11:55.977] The total size of the 2 globals is 275.66 KiB (282272 bytes)
[16:11:55.978] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 275.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (275.60 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.978] - globals: [2] ‘x’, ‘i’
[16:11:55.978] 
[16:11:55.978] getGlobalsAndPackages() ... DONE
[16:11:55.979] getGlobalsAndPackages() ...
[16:11:55.979] Searching for globals...
[16:11:55.980] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.980] Searching for globals ... DONE
[16:11:55.980] Resolving globals: FALSE
[16:11:55.990] The total size of the 2 globals is 284.01 KiB (290824 bytes)
[16:11:55.990] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 284.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (283.95 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:55.990] - globals: [2] ‘x’, ‘i’
[16:11:55.990] 
[16:11:55.990] getGlobalsAndPackages() ... DONE
[16:11:55.991] getGlobalsAndPackages() ...
[16:11:55.991] Searching for globals...
[16:11:55.993] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:55.993] Searching for globals ... DONE
[16:11:55.993] Resolving globals: FALSE
[16:11:56.003] The total size of the 2 globals is 292.36 KiB (299376 bytes)
[16:11:56.003] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 292.36 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (292.30 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.003] - globals: [2] ‘x’, ‘i’
[16:11:56.003] 
[16:11:56.004] getGlobalsAndPackages() ... DONE
[16:11:56.004] getGlobalsAndPackages() ...
[16:11:56.004] Searching for globals...
[16:11:56.006] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.006] Searching for globals ... DONE
[16:11:56.006] Resolving globals: FALSE
[16:11:56.016] The total size of the 2 globals is 300.71 KiB (307928 bytes)
[16:11:56.017] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 300.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (300.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.017] - globals: [2] ‘x’, ‘i’
[16:11:56.017] 
[16:11:56.017] getGlobalsAndPackages() ... DONE
[16:11:56.017] getGlobalsAndPackages() ...
[16:11:56.018] Searching for globals...
[16:11:56.019] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.019] Searching for globals ... DONE
[16:11:56.019] Resolving globals: FALSE
[16:11:56.050] The total size of the 2 globals is 309.06 KiB (316480 bytes)
[16:11:56.050] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 309.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (309.01 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.050] - globals: [2] ‘x’, ‘i’
[16:11:56.050] 
[16:11:56.051] getGlobalsAndPackages() ... DONE
[16:11:56.051] getGlobalsAndPackages() ...
[16:11:56.051] Searching for globals...
[16:11:56.053] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.053] Searching for globals ... DONE
[16:11:56.053] Resolving globals: FALSE
[16:11:56.065] The total size of the 2 globals is 317.41 KiB (325032 bytes)
[16:11:56.065] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 317.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (317.36 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.065] - globals: [2] ‘x’, ‘i’
[16:11:56.065] 
[16:11:56.065] getGlobalsAndPackages() ... DONE
[16:11:56.066] getGlobalsAndPackages() ...
[16:11:56.066] Searching for globals...
[16:11:56.067] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.068] Searching for globals ... DONE
[16:11:56.068] Resolving globals: FALSE
[16:11:56.079] The total size of the 2 globals is 325.77 KiB (333584 bytes)
[16:11:56.080] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 325.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (325.71 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.080] - globals: [2] ‘x’, ‘i’
[16:11:56.080] 
[16:11:56.080] getGlobalsAndPackages() ... DONE
[16:11:56.081] getGlobalsAndPackages() ...
[16:11:56.081] Searching for globals...
[16:11:56.082] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.082] Searching for globals ... DONE
[16:11:56.082] Resolving globals: FALSE
[16:11:56.094] The total size of the 2 globals is 334.12 KiB (342136 bytes)
[16:11:56.094] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 334.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (334.06 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.094] - globals: [2] ‘x’, ‘i’
[16:11:56.095] 
[16:11:56.095] getGlobalsAndPackages() ... DONE
[16:11:56.095] getGlobalsAndPackages() ...
[16:11:56.096] Searching for globals...
[16:11:56.097] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.097] Searching for globals ... DONE
[16:11:56.097] Resolving globals: FALSE
[16:11:56.109] The total size of the 2 globals is 342.47 KiB (350688 bytes)
[16:11:56.109] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 342.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (342.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.109] - globals: [2] ‘x’, ‘i’
[16:11:56.109] 
[16:11:56.109] getGlobalsAndPackages() ... DONE
[16:11:56.110] getGlobalsAndPackages() ...
[16:11:56.110] Searching for globals...
[16:11:56.112] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.112] Searching for globals ... DONE
[16:11:56.112] Resolving globals: FALSE
[16:11:56.124] The total size of the 2 globals is 350.82 KiB (359240 bytes)
[16:11:56.124] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 350.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (350.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.124] - globals: [2] ‘x’, ‘i’
[16:11:56.125] 
[16:11:56.125] getGlobalsAndPackages() ... DONE
[16:11:56.125] getGlobalsAndPackages() ...
[16:11:56.125] Searching for globals...
[16:11:56.127] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.127] Searching for globals ... DONE
[16:11:56.127] Resolving globals: FALSE
[16:11:56.140] The total size of the 2 globals is 359.17 KiB (367792 bytes)
[16:11:56.140] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 359.17 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (359.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.140] - globals: [2] ‘x’, ‘i’
[16:11:56.140] 
[16:11:56.140] getGlobalsAndPackages() ... DONE
[16:11:56.141] getGlobalsAndPackages() ...
[16:11:56.141] Searching for globals...
[16:11:56.142] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.142] Searching for globals ... DONE
[16:11:56.142] Resolving globals: FALSE
[16:11:56.155] The total size of the 2 globals is 367.52 KiB (376344 bytes)
[16:11:56.156] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 367.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (367.47 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.156] - globals: [2] ‘x’, ‘i’
[16:11:56.156] 
[16:11:56.156] getGlobalsAndPackages() ... DONE
[16:11:56.157] getGlobalsAndPackages() ...
[16:11:56.157] Searching for globals...
[16:11:56.158] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.158] Searching for globals ... DONE
[16:11:56.158] Resolving globals: FALSE
[16:11:56.172] The total size of the 2 globals is 375.88 KiB (384896 bytes)
[16:11:56.173] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 375.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (375.82 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.173] - globals: [2] ‘x’, ‘i’
[16:11:56.173] 
[16:11:56.173] getGlobalsAndPackages() ... DONE
[16:11:56.174] getGlobalsAndPackages() ...
[16:11:56.174] Searching for globals...
[16:11:56.176] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.176] Searching for globals ... DONE
[16:11:56.176] Resolving globals: FALSE
[16:11:56.192] The total size of the 2 globals is 384.23 KiB (393448 bytes)
[16:11:56.192] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 384.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (384.17 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.192] - globals: [2] ‘x’, ‘i’
[16:11:56.192] 
[16:11:56.192] getGlobalsAndPackages() ... DONE
[16:11:56.193] getGlobalsAndPackages() ...
[16:11:56.193] Searching for globals...
[16:11:56.195] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.195] Searching for globals ... DONE
[16:11:56.195] Resolving globals: FALSE
[16:11:56.210] The total size of the 2 globals is 392.58 KiB (402000 bytes)
[16:11:56.211] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 392.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (392.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.211] - globals: [2] ‘x’, ‘i’
[16:11:56.211] 
[16:11:56.211] getGlobalsAndPackages() ... DONE
[16:11:56.212] getGlobalsAndPackages() ...
[16:11:56.212] Searching for globals...
[16:11:56.213] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.213] Searching for globals ... DONE
[16:11:56.213] Resolving globals: FALSE
[16:11:56.229] The total size of the 2 globals is 400.93 KiB (410552 bytes)
[16:11:56.229] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 400.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (400.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.229] - globals: [2] ‘x’, ‘i’
[16:11:56.229] 
[16:11:56.230] getGlobalsAndPackages() ... DONE
[16:11:56.230] getGlobalsAndPackages() ...
[16:11:56.230] Searching for globals...
[16:11:56.232] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.232] Searching for globals ... DONE
[16:11:56.233] Resolving globals: FALSE
[16:11:56.248] The total size of the 2 globals is 409.28 KiB (419104 bytes)
[16:11:56.248] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 409.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (409.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.248] - globals: [2] ‘x’, ‘i’
[16:11:56.248] 
[16:11:56.248] getGlobalsAndPackages() ... DONE
[16:11:56.250] getGlobalsAndPackages() ...
[16:11:56.250] Searching for globals...
[16:11:56.252] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.252] Searching for globals ... DONE
[16:11:56.252] Resolving globals: FALSE
[16:11:56.267] The total size of the 2 globals is 417.63 KiB (427656 bytes)
[16:11:56.268] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 417.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (417.58 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.268] - globals: [2] ‘x’, ‘i’
[16:11:56.268] 
[16:11:56.268] getGlobalsAndPackages() ... DONE
[16:11:56.268] getGlobalsAndPackages() ...
[16:11:56.269] Searching for globals...
[16:11:56.270] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.270] Searching for globals ... DONE
[16:11:56.270] Resolving globals: FALSE
[16:11:56.286] The total size of the 2 globals is 425.98 KiB (436208 bytes)
[16:11:56.286] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 425.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (425.93 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.286] - globals: [2] ‘x’, ‘i’
[16:11:56.286] 
[16:11:56.286] getGlobalsAndPackages() ... DONE
[16:11:56.287] getGlobalsAndPackages() ...
[16:11:56.287] Searching for globals...
[16:11:56.289] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.289] Searching for globals ... DONE
[16:11:56.289] Resolving globals: FALSE
[16:11:56.304] The total size of the 2 globals is 434.34 KiB (444760 bytes)
[16:11:56.305] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 434.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (434.28 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.305] - globals: [2] ‘x’, ‘i’
[16:11:56.305] 
[16:11:56.305] getGlobalsAndPackages() ... DONE
[16:11:56.305] getGlobalsAndPackages() ...
[16:11:56.305] Searching for globals...
[16:11:56.307] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.307] Searching for globals ... DONE
[16:11:56.307] Resolving globals: FALSE
[16:11:56.323] The total size of the 2 globals is 442.69 KiB (453312 bytes)
[16:11:56.323] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 442.69 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (442.63 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.323] - globals: [2] ‘x’, ‘i’
[16:11:56.323] 
[16:11:56.323] getGlobalsAndPackages() ... DONE
[16:11:56.324] getGlobalsAndPackages() ...
[16:11:56.324] Searching for globals...
[16:11:56.325] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.326] Searching for globals ... DONE
[16:11:56.326] Resolving globals: FALSE
[16:11:56.342] The total size of the 2 globals is 451.04 KiB (461864 bytes)
[16:11:56.342] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 451.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (450.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.342] - globals: [2] ‘x’, ‘i’
[16:11:56.342] 
[16:11:56.343] getGlobalsAndPackages() ... DONE
[16:11:56.343] getGlobalsAndPackages() ...
[16:11:56.343] Searching for globals...
[16:11:56.345] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.345] Searching for globals ... DONE
[16:11:56.345] Resolving globals: FALSE
[16:11:56.362] The total size of the 2 globals is 459.39 KiB (470416 bytes)
[16:11:56.362] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 459.39 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (459.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.362] - globals: [2] ‘x’, ‘i’
[16:11:56.362] 
[16:11:56.363] getGlobalsAndPackages() ... DONE
[16:11:56.363] getGlobalsAndPackages() ...
[16:11:56.363] Searching for globals...
[16:11:56.365] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.365] Searching for globals ... DONE
[16:11:56.365] Resolving globals: FALSE
[16:11:56.381] The total size of the 2 globals is 467.74 KiB (478968 bytes)
[16:11:56.382] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 467.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (467.69 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.382] - globals: [2] ‘x’, ‘i’
[16:11:56.382] 
[16:11:56.382] getGlobalsAndPackages() ... DONE
[16:11:56.382] getGlobalsAndPackages() ...
[16:11:56.383] Searching for globals...
[16:11:56.384] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.384] Searching for globals ... DONE
[16:11:56.384] Resolving globals: FALSE
[16:11:56.401] The total size of the 2 globals is 476.09 KiB (487520 bytes)
[16:11:56.402] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 476.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (476.04 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.402] - globals: [2] ‘x’, ‘i’
[16:11:56.402] 
[16:11:56.402] getGlobalsAndPackages() ... DONE
[16:11:56.403] getGlobalsAndPackages() ...
[16:11:56.403] Searching for globals...
[16:11:56.404] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.404] Searching for globals ... DONE
[16:11:56.404] Resolving globals: FALSE
[16:11:56.421] The total size of the 2 globals is 484.45 KiB (496072 bytes)
[16:11:56.422] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 484.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (484.39 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.422] - globals: [2] ‘x’, ‘i’
[16:11:56.422] 
[16:11:56.422] getGlobalsAndPackages() ... DONE
[16:11:56.423] getGlobalsAndPackages() ...
[16:11:56.423] Searching for globals...
[16:11:56.425] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.425] Searching for globals ... DONE
[16:11:56.425] Resolving globals: FALSE
[16:11:56.442] The total size of the 2 globals is 492.80 KiB (504624 bytes)
[16:11:56.443] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 492.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (492.74 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.443] - globals: [2] ‘x’, ‘i’
[16:11:56.443] 
[16:11:56.443] getGlobalsAndPackages() ... DONE
[16:11:56.444] getGlobalsAndPackages() ...
[16:11:56.444] Searching for globals...
[16:11:56.445] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.445] Searching for globals ... DONE
[16:11:56.445] Resolving globals: FALSE
[16:11:56.463] The total size of the 2 globals is 501.15 KiB (513176 bytes)
[16:11:56.463] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 501.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (501.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.463] - globals: [2] ‘x’, ‘i’
[16:11:56.464] 
[16:11:56.464] getGlobalsAndPackages() ... DONE
[16:11:56.464] getGlobalsAndPackages() ...
[16:11:56.464] Searching for globals...
[16:11:56.466] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.466] Searching for globals ... DONE
[16:11:56.466] Resolving globals: FALSE
[16:11:56.484] The total size of the 2 globals is 509.50 KiB (521728 bytes)
[16:11:56.484] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.45 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.484] - globals: [2] ‘x’, ‘i’
[16:11:56.484] 
[16:11:56.484] getGlobalsAndPackages() ... DONE
[16:11:56.486] getGlobalsAndPackages() ...
[16:11:56.486] Searching for globals...
[16:11:56.487] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.487] Searching for globals ... DONE
[16:11:56.487] Resolving globals: FALSE
[16:11:56.505] The total size of the 2 globals is 517.85 KiB (530280 bytes)
[16:11:56.506] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 517.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (517.80 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.506] - globals: [2] ‘x’, ‘i’
[16:11:56.506] 
[16:11:56.506] getGlobalsAndPackages() ... DONE
[16:11:56.507] getGlobalsAndPackages() ...
[16:11:56.507] Searching for globals...
[16:11:56.508] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.508] Searching for globals ... DONE
[16:11:56.508] Resolving globals: FALSE
[16:11:56.527] The total size of the 2 globals is 526.20 KiB (538832 bytes)
[16:11:56.527] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 526.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (526.15 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.527] - globals: [2] ‘x’, ‘i’
[16:11:56.528] 
[16:11:56.528] getGlobalsAndPackages() ... DONE
[16:11:56.528] getGlobalsAndPackages() ...
[16:11:56.528] Searching for globals...
[16:11:56.530] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.530] Searching for globals ... DONE
[16:11:56.530] Resolving globals: FALSE
[16:11:56.550] The total size of the 2 globals is 534.55 KiB (547384 bytes)
[16:11:56.550] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 534.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (534.50 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.550] - globals: [2] ‘x’, ‘i’
[16:11:56.550] 
[16:11:56.550] getGlobalsAndPackages() ... DONE
[16:11:56.551] getGlobalsAndPackages() ...
[16:11:56.551] Searching for globals...
[16:11:56.552] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.553] Searching for globals ... DONE
[16:11:56.553] Resolving globals: FALSE
[16:11:56.573] The total size of the 2 globals is 542.91 KiB (555936 bytes)
[16:11:56.573] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 542.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (542.85 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.573] - globals: [2] ‘x’, ‘i’
[16:11:56.574] 
[16:11:56.574] getGlobalsAndPackages() ... DONE
[16:11:56.574] getGlobalsAndPackages() ...
[16:11:56.574] Searching for globals...
[16:11:56.576] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.576] Searching for globals ... DONE
[16:11:56.576] Resolving globals: FALSE
[16:11:56.597] The total size of the 2 globals is 551.26 KiB (564488 bytes)
[16:11:56.597] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 551.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (551.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.597] - globals: [2] ‘x’, ‘i’
[16:11:56.597] 
[16:11:56.598] getGlobalsAndPackages() ... DONE
[16:11:56.598] getGlobalsAndPackages() ...
[16:11:56.598] Searching for globals...
[16:11:56.600] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.600] Searching for globals ... DONE
[16:11:56.600] Resolving globals: FALSE
[16:11:56.620] The total size of the 2 globals is 559.61 KiB (573040 bytes)
[16:11:56.620] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 559.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (559.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.620] - globals: [2] ‘x’, ‘i’
[16:11:56.620] 
[16:11:56.621] getGlobalsAndPackages() ... DONE
[16:11:56.621] getGlobalsAndPackages() ...
[16:11:56.621] Searching for globals...
[16:11:56.623] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.623] Searching for globals ... DONE
[16:11:56.623] Resolving globals: FALSE
[16:11:56.644] The total size of the 2 globals is 567.96 KiB (581592 bytes)
[16:11:56.644] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 567.96 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (567.91 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.644] - globals: [2] ‘x’, ‘i’
[16:11:56.644] 
[16:11:56.645] getGlobalsAndPackages() ... DONE
[16:11:56.645] getGlobalsAndPackages() ...
[16:11:56.645] Searching for globals...
[16:11:56.647] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.647] Searching for globals ... DONE
[16:11:56.647] Resolving globals: FALSE
[16:11:56.667] The total size of the 2 globals is 576.31 KiB (590144 bytes)
[16:11:56.667] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 576.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (576.26 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.668] - globals: [2] ‘x’, ‘i’
[16:11:56.668] 
[16:11:56.668] getGlobalsAndPackages() ... DONE
[16:11:56.669] getGlobalsAndPackages() ...
[16:11:56.669] Searching for globals...
[16:11:56.671] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.671] Searching for globals ... DONE
[16:11:56.671] Resolving globals: FALSE
[16:11:56.691] The total size of the 2 globals is 584.66 KiB (598696 bytes)
[16:11:56.692] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 584.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (584.61 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.692] - globals: [2] ‘x’, ‘i’
[16:11:56.692] 
[16:11:56.692] getGlobalsAndPackages() ... DONE
[16:11:56.693] getGlobalsAndPackages() ...
[16:11:56.693] Searching for globals...
[16:11:56.694] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.694] Searching for globals ... DONE
[16:11:56.695] Resolving globals: FALSE
[16:11:56.716] The total size of the 2 globals is 593.02 KiB (607248 bytes)
[16:11:56.717] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 593.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (592.96 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.717] - globals: [2] ‘x’, ‘i’
[16:11:56.717] 
[16:11:56.717] getGlobalsAndPackages() ... DONE
[16:11:56.718] getGlobalsAndPackages() ...
[16:11:56.718] Searching for globals...
[16:11:56.719] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.719] Searching for globals ... DONE
[16:11:56.719] Resolving globals: FALSE
[16:11:56.741] The total size of the 2 globals is 601.37 KiB (615800 bytes)
[16:11:56.741] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 601.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (601.31 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.741] - globals: [2] ‘x’, ‘i’
[16:11:56.741] 
[16:11:56.741] getGlobalsAndPackages() ... DONE
[16:11:56.742] getGlobalsAndPackages() ...
[16:11:56.742] Searching for globals...
[16:11:56.744] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.744] Searching for globals ... DONE
[16:11:56.745] Resolving globals: FALSE
[16:11:56.766] The total size of the 2 globals is 609.72 KiB (624352 bytes)
[16:11:56.766] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 609.72 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (609.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.767] - globals: [2] ‘x’, ‘i’
[16:11:56.767] 
[16:11:56.767] getGlobalsAndPackages() ... DONE
[16:11:56.767] getGlobalsAndPackages() ...
[16:11:56.767] Searching for globals...
[16:11:56.769] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.769] Searching for globals ... DONE
[16:11:56.769] Resolving globals: FALSE
[16:11:56.791] The total size of the 2 globals is 618.07 KiB (632904 bytes)
[16:11:56.792] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 618.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (618.02 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.792] - globals: [2] ‘x’, ‘i’
[16:11:56.792] 
[16:11:56.792] getGlobalsAndPackages() ... DONE
[16:11:56.793] getGlobalsAndPackages() ...
[16:11:56.793] Searching for globals...
[16:11:56.794] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.794] Searching for globals ... DONE
[16:11:56.794] Resolving globals: FALSE
[16:11:56.817] The total size of the 2 globals is 626.42 KiB (641456 bytes)
[16:11:56.817] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 626.42 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (626.37 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.817] - globals: [2] ‘x’, ‘i’
[16:11:56.817] 
[16:11:56.817] getGlobalsAndPackages() ... DONE
[16:11:56.818] getGlobalsAndPackages() ...
[16:11:56.818] Searching for globals...
[16:11:56.820] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.820] Searching for globals ... DONE
[16:11:56.820] Resolving globals: FALSE
[16:11:56.842] The total size of the 2 globals is 634.77 KiB (650008 bytes)
[16:11:56.842] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 634.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (634.72 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.842] - globals: [2] ‘x’, ‘i’
[16:11:56.842] 
[16:11:56.842] getGlobalsAndPackages() ... DONE
[16:11:56.843] getGlobalsAndPackages() ...
[16:11:56.843] Searching for globals...
[16:11:56.844] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.845] Searching for globals ... DONE
[16:11:56.845] Resolving globals: FALSE
[16:11:56.868] The total size of the 2 globals is 643.12 KiB (658560 bytes)
[16:11:56.869] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 643.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (643.07 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.869] - globals: [2] ‘x’, ‘i’
[16:11:56.869] 
[16:11:56.869] getGlobalsAndPackages() ... DONE
[16:11:56.870] getGlobalsAndPackages() ...
[16:11:56.870] Searching for globals...
[16:11:56.871] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.871] Searching for globals ... DONE
[16:11:56.872] Resolving globals: FALSE
[16:11:56.898] The total size of the 2 globals is 651.48 KiB (667112 bytes)
[16:11:56.898] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 651.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (651.42 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.898] - globals: [2] ‘x’, ‘i’
[16:11:56.898] 
[16:11:56.899] getGlobalsAndPackages() ... DONE
[16:11:56.899] getGlobalsAndPackages() ...
[16:11:56.899] Searching for globals...
[16:11:56.901] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.901] Searching for globals ... DONE
[16:11:56.901] Resolving globals: FALSE
[16:11:56.927] The total size of the 2 globals is 659.83 KiB (675664 bytes)
[16:11:56.927] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 659.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (659.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.927] - globals: [2] ‘x’, ‘i’
[16:11:56.928] 
[16:11:56.928] getGlobalsAndPackages() ... DONE
[16:11:56.928] getGlobalsAndPackages() ...
[16:11:56.928] Searching for globals...
[16:11:56.930] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.930] Searching for globals ... DONE
[16:11:56.930] Resolving globals: FALSE
[16:11:56.955] The total size of the 2 globals is 668.18 KiB (684216 bytes)
[16:11:56.956] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 668.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (668.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.956] - globals: [2] ‘x’, ‘i’
[16:11:56.956] 
[16:11:56.956] getGlobalsAndPackages() ... DONE
[16:11:56.957] getGlobalsAndPackages() ...
[16:11:56.957] Searching for globals...
[16:11:56.958] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.958] Searching for globals ... DONE
[16:11:56.958] Resolving globals: FALSE
[16:11:56.983] The total size of the 2 globals is 676.53 KiB (692768 bytes)
[16:11:56.983] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 676.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (676.48 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:56.984] - globals: [2] ‘x’, ‘i’
[16:11:56.984] 
[16:11:56.984] getGlobalsAndPackages() ... DONE
[16:11:56.984] getGlobalsAndPackages() ...
[16:11:56.984] Searching for globals...
[16:11:56.986] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:56.986] Searching for globals ... DONE
[16:11:56.986] Resolving globals: FALSE
[16:11:57.011] The total size of the 2 globals is 684.88 KiB (701320 bytes)
[16:11:57.011] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 684.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (684.83 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.011] - globals: [2] ‘x’, ‘i’
[16:11:57.012] 
[16:11:57.012] getGlobalsAndPackages() ... DONE
[16:11:57.012] getGlobalsAndPackages() ...
[16:11:57.012] Searching for globals...
[16:11:57.014] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.014] Searching for globals ... DONE
[16:11:57.014] Resolving globals: FALSE
[16:11:57.039] The total size of the 2 globals is 693.23 KiB (709872 bytes)
[16:11:57.040] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 693.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (693.18 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.040] - globals: [2] ‘x’, ‘i’
[16:11:57.040] 
[16:11:57.040] getGlobalsAndPackages() ... DONE
[16:11:57.041] getGlobalsAndPackages() ...
[16:11:57.041] Searching for globals...
[16:11:57.042] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.042] Searching for globals ... DONE
[16:11:57.043] Resolving globals: FALSE
[16:11:57.067] The total size of the 2 globals is 701.59 KiB (718424 bytes)
[16:11:57.068] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 701.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (701.53 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.069] - globals: [2] ‘x’, ‘i’
[16:11:57.069] 
[16:11:57.069] getGlobalsAndPackages() ... DONE
[16:11:57.069] getGlobalsAndPackages() ...
[16:11:57.069] Searching for globals...
[16:11:57.071] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.071] Searching for globals ... DONE
[16:11:57.071] Resolving globals: FALSE
[16:11:57.097] The total size of the 2 globals is 709.94 KiB (726976 bytes)
[16:11:57.097] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 709.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (709.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.097] - globals: [2] ‘x’, ‘i’
[16:11:57.098] 
[16:11:57.098] getGlobalsAndPackages() ... DONE
[16:11:57.098] getGlobalsAndPackages() ...
[16:11:57.098] Searching for globals...
[16:11:57.100] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.100] Searching for globals ... DONE
[16:11:57.100] Resolving globals: FALSE
[16:11:57.126] The total size of the 2 globals is 718.29 KiB (735528 bytes)
[16:11:57.127] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.127] - globals: [2] ‘x’, ‘i’
[16:11:57.127] 
[16:11:57.127] getGlobalsAndPackages() ... DONE
[16:11:57.128] getGlobalsAndPackages() ...
[16:11:57.128] Searching for globals...
[16:11:57.129] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.129] Searching for globals ... DONE
[16:11:57.129] Resolving globals: FALSE
[16:11:57.156] The total size of the 2 globals is 726.64 KiB (744080 bytes)
[16:11:57.157] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 726.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (726.59 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.157] - globals: [2] ‘x’, ‘i’
[16:11:57.157] 
[16:11:57.157] getGlobalsAndPackages() ... DONE
[16:11:57.157] getGlobalsAndPackages() ...
[16:11:57.158] Searching for globals...
[16:11:57.159] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.159] Searching for globals ... DONE
[16:11:57.159] Resolving globals: FALSE
[16:11:57.187] The total size of the 2 globals is 734.99 KiB (752632 bytes)
[16:11:57.187] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 734.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (734.94 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.187] - globals: [2] ‘x’, ‘i’
[16:11:57.187] 
[16:11:57.187] getGlobalsAndPackages() ... DONE
[16:11:57.188] getGlobalsAndPackages() ...
[16:11:57.188] Searching for globals...
[16:11:57.189] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.190] Searching for globals ... DONE
[16:11:57.190] Resolving globals: FALSE
[16:11:57.217] The total size of the 2 globals is 743.34 KiB (761184 bytes)
[16:11:57.217] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 743.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (743.29 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.217] - globals: [2] ‘x’, ‘i’
[16:11:57.217] 
[16:11:57.218] getGlobalsAndPackages() ... DONE
[16:11:57.218] getGlobalsAndPackages() ...
[16:11:57.218] Searching for globals...
[16:11:57.220] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.220] Searching for globals ... DONE
[16:11:57.220] Resolving globals: FALSE
[16:11:57.247] The total size of the 2 globals is 751.70 KiB (769736 bytes)
[16:11:57.248] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 751.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (751.64 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.248] - globals: [2] ‘x’, ‘i’
[16:11:57.248] 
[16:11:57.248] getGlobalsAndPackages() ... DONE
[16:11:57.249] getGlobalsAndPackages() ...
[16:11:57.249] Searching for globals...
[16:11:57.250] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.250] Searching for globals ... DONE
[16:11:57.250] Resolving globals: FALSE
[16:11:57.279] The total size of the 2 globals is 760.05 KiB (778288 bytes)
[16:11:57.280] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 760.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (759.99 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.280] - globals: [2] ‘x’, ‘i’
[16:11:57.280] 
[16:11:57.280] getGlobalsAndPackages() ... DONE
[16:11:57.281] getGlobalsAndPackages() ...
[16:11:57.281] Searching for globals...
[16:11:57.282] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.282] Searching for globals ... DONE
[16:11:57.283] Resolving globals: FALSE
[16:11:57.312] The total size of the 2 globals is 768.40 KiB (786840 bytes)
[16:11:57.313] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 768.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (768.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.313] - globals: [2] ‘x’, ‘i’
[16:11:57.313] 
[16:11:57.313] getGlobalsAndPackages() ... DONE
[16:11:57.314] getGlobalsAndPackages() ...
[16:11:57.314] Searching for globals...
[16:11:57.315] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.315] Searching for globals ... DONE
[16:11:57.315] Resolving globals: FALSE
[16:11:57.346] The total size of the 2 globals is 776.75 KiB (795392 bytes)
[16:11:57.347] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 776.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (776.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.347] - globals: [2] ‘x’, ‘i’
[16:11:57.347] 
[16:11:57.347] getGlobalsAndPackages() ... DONE
[16:11:57.348] getGlobalsAndPackages() ...
[16:11:57.348] Searching for globals...
[16:11:57.350] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.350] Searching for globals ... DONE
[16:11:57.350] Resolving globals: FALSE
[16:11:57.382] The total size of the 2 globals is 785.10 KiB (803944 bytes)
[16:11:57.382] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 785.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (785.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.382] - globals: [2] ‘x’, ‘i’
[16:11:57.383] 
[16:11:57.383] getGlobalsAndPackages() ... DONE
[16:11:57.383] getGlobalsAndPackages() ...
[16:11:57.383] Searching for globals...
[16:11:57.385] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.385] Searching for globals ... DONE
[16:11:57.385] Resolving globals: FALSE
[16:11:57.415] The total size of the 2 globals is 793.45 KiB (812496 bytes)
[16:11:57.415] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 793.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (793.40 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.416] - globals: [2] ‘x’, ‘i’
[16:11:57.416] 
[16:11:57.416] getGlobalsAndPackages() ... DONE
[16:11:57.416] getGlobalsAndPackages() ...
[16:11:57.416] Searching for globals...
[16:11:57.419] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.419] Searching for globals ... DONE
[16:11:57.419] Resolving globals: FALSE
[16:11:57.449] The total size of the 2 globals is 801.80 KiB (821048 bytes)
[16:11:57.449] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 801.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (801.75 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.449] - globals: [2] ‘x’, ‘i’
[16:11:57.450] 
[16:11:57.450] getGlobalsAndPackages() ... DONE
[16:11:57.450] getGlobalsAndPackages() ...
[16:11:57.450] Searching for globals...
[16:11:57.452] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[16:11:57.452] Searching for globals ... DONE
[16:11:57.452] Resolving globals: FALSE
[16:11:57.482] The total size of the 2 globals is 810.16 KiB (829600 bytes)
[16:11:57.482] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 810.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (810.10 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[16:11:57.482] - globals: [2] ‘x’, ‘i’
[16:11:57.482] 
[16:11:57.482] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[16:11:57.483] run() for ‘Future’ ...
[16:11:57.483] - state: ‘created’
[16:11:57.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:57.484] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:57.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:57.484]   - Field: ‘label’
[16:11:57.484]   - Field: ‘local’
[16:11:57.484]   - Field: ‘owner’
[16:11:57.484]   - Field: ‘envir’
[16:11:57.485]   - Field: ‘packages’
[16:11:57.485]   - Field: ‘gc’
[16:11:57.485]   - Field: ‘conditions’
[16:11:57.485]   - Field: ‘expr’
[16:11:57.485]   - Field: ‘uuid’
[16:11:57.485]   - Field: ‘seed’
[16:11:57.485]   - Field: ‘version’
[16:11:57.485]   - Field: ‘result’
[16:11:57.485]   - Field: ‘asynchronous’
[16:11:57.485]   - Field: ‘calls’
[16:11:57.485]   - Field: ‘globals’
[16:11:57.486]   - Field: ‘stdout’
[16:11:57.486]   - Field: ‘earlySignal’
[16:11:57.486]   - Field: ‘lazy’
[16:11:57.486]   - Field: ‘state’
[16:11:57.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:57.486] - Launch lazy future ...
[16:11:57.487] Packages needed by the future expression (n = 0): <none>
[16:11:57.487] Packages needed by future strategies (n = 0): <none>
[16:11:57.488] {
[16:11:57.488]     {
[16:11:57.488]         {
[16:11:57.488]             ...future.startTime <- base::Sys.time()
[16:11:57.488]             {
[16:11:57.488]                 {
[16:11:57.488]                   {
[16:11:57.488]                     base::local({
[16:11:57.488]                       has_future <- base::requireNamespace("future", 
[16:11:57.488]                         quietly = TRUE)
[16:11:57.488]                       if (has_future) {
[16:11:57.488]                         ns <- base::getNamespace("future")
[16:11:57.488]                         version <- ns[[".package"]][["version"]]
[16:11:57.488]                         if (is.null(version)) 
[16:11:57.488]                           version <- utils::packageVersion("future")
[16:11:57.488]                       }
[16:11:57.488]                       else {
[16:11:57.488]                         version <- NULL
[16:11:57.488]                       }
[16:11:57.488]                       if (!has_future || version < "1.8.0") {
[16:11:57.488]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:57.488]                           "", base::R.version$version.string), 
[16:11:57.488]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:57.488]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:57.488]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:57.488]                             "release", "version")], collapse = " "), 
[16:11:57.488]                           hostname = base::Sys.info()[["nodename"]])
[16:11:57.488]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:57.488]                           info)
[16:11:57.488]                         info <- base::paste(info, collapse = "; ")
[16:11:57.488]                         if (!has_future) {
[16:11:57.488]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:57.488]                             info)
[16:11:57.488]                         }
[16:11:57.488]                         else {
[16:11:57.488]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:57.488]                             info, version)
[16:11:57.488]                         }
[16:11:57.488]                         base::stop(msg)
[16:11:57.488]                       }
[16:11:57.488]                     })
[16:11:57.488]                   }
[16:11:57.488]                   options(future.plan = NULL)
[16:11:57.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:57.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:57.488]                 }
[16:11:57.488]                 ...future.workdir <- getwd()
[16:11:57.488]             }
[16:11:57.488]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:57.488]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:57.488]         }
[16:11:57.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:57.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:57.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:57.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:57.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:57.488]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:57.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:57.488]             base::names(...future.oldOptions))
[16:11:57.488]     }
[16:11:57.488]     if (TRUE) {
[16:11:57.488]     }
[16:11:57.488]     else {
[16:11:57.488]         if (NA) {
[16:11:57.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:57.488]                 open = "w")
[16:11:57.488]         }
[16:11:57.488]         else {
[16:11:57.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:57.488]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:57.488]         }
[16:11:57.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:57.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:57.488]             base::sink(type = "output", split = FALSE)
[16:11:57.488]             base::close(...future.stdout)
[16:11:57.488]         }, add = TRUE)
[16:11:57.488]     }
[16:11:57.488]     ...future.frame <- base::sys.nframe()
[16:11:57.488]     ...future.conditions <- base::list()
[16:11:57.488]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:57.488]     if (FALSE) {
[16:11:57.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:57.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:57.488]     }
[16:11:57.488]     ...future.result <- base::tryCatch({
[16:11:57.488]         base::withCallingHandlers({
[16:11:57.488]             ...future.value <- base::withVisible(base::local({
[16:11:57.488]                 x[[i - 2]] + x[[i - 1]]
[16:11:57.488]             }))
[16:11:57.488]             future::FutureResult(value = ...future.value$value, 
[16:11:57.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:57.488]                   ...future.rng), globalenv = if (FALSE) 
[16:11:57.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:57.488]                     ...future.globalenv.names))
[16:11:57.488]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:57.488]         }, condition = base::local({
[16:11:57.488]             c <- base::c
[16:11:57.488]             inherits <- base::inherits
[16:11:57.488]             invokeRestart <- base::invokeRestart
[16:11:57.488]             length <- base::length
[16:11:57.488]             list <- base::list
[16:11:57.488]             seq.int <- base::seq.int
[16:11:57.488]             signalCondition <- base::signalCondition
[16:11:57.488]             sys.calls <- base::sys.calls
[16:11:57.488]             `[[` <- base::`[[`
[16:11:57.488]             `+` <- base::`+`
[16:11:57.488]             `<<-` <- base::`<<-`
[16:11:57.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:57.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:57.488]                   3L)]
[16:11:57.488]             }
[16:11:57.488]             function(cond) {
[16:11:57.488]                 is_error <- inherits(cond, "error")
[16:11:57.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:57.488]                   NULL)
[16:11:57.488]                 if (is_error) {
[16:11:57.488]                   sessionInformation <- function() {
[16:11:57.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:57.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:57.488]                       search = base::search(), system = base::Sys.info())
[16:11:57.488]                   }
[16:11:57.488]                   ...future.conditions[[length(...future.conditions) + 
[16:11:57.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:57.488]                     cond$call), session = sessionInformation(), 
[16:11:57.488]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:57.488]                   signalCondition(cond)
[16:11:57.488]                 }
[16:11:57.488]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[16:11:57.488]                 "immediateCondition"))) {
[16:11:57.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:57.488]                   ...future.conditions[[length(...future.conditions) + 
[16:11:57.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:57.488]                   if (TRUE && !signal) {
[16:11:57.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:57.488]                     {
[16:11:57.488]                       inherits <- base::inherits
[16:11:57.488]                       invokeRestart <- base::invokeRestart
[16:11:57.488]                       is.null <- base::is.null
[16:11:57.488]                       muffled <- FALSE
[16:11:57.488]                       if (inherits(cond, "message")) {
[16:11:57.488]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:57.488]                         if (muffled) 
[16:11:57.488]                           invokeRestart("muffleMessage")
[16:11:57.488]                       }
[16:11:57.488]                       else if (inherits(cond, "warning")) {
[16:11:57.488]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:57.488]                         if (muffled) 
[16:11:57.488]                           invokeRestart("muffleWarning")
[16:11:57.488]                       }
[16:11:57.488]                       else if (inherits(cond, "condition")) {
[16:11:57.488]                         if (!is.null(pattern)) {
[16:11:57.488]                           computeRestarts <- base::computeRestarts
[16:11:57.488]                           grepl <- base::grepl
[16:11:57.488]                           restarts <- computeRestarts(cond)
[16:11:57.488]                           for (restart in restarts) {
[16:11:57.488]                             name <- restart$name
[16:11:57.488]                             if (is.null(name)) 
[16:11:57.488]                               next
[16:11:57.488]                             if (!grepl(pattern, name)) 
[16:11:57.488]                               next
[16:11:57.488]                             invokeRestart(restart)
[16:11:57.488]                             muffled <- TRUE
[16:11:57.488]                             break
[16:11:57.488]                           }
[16:11:57.488]                         }
[16:11:57.488]                       }
[16:11:57.488]                       invisible(muffled)
[16:11:57.488]                     }
[16:11:57.488]                     muffleCondition(cond, pattern = "^muffle")
[16:11:57.488]                   }
[16:11:57.488]                 }
[16:11:57.488]                 else {
[16:11:57.488]                   if (TRUE) {
[16:11:57.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:57.488]                     {
[16:11:57.488]                       inherits <- base::inherits
[16:11:57.488]                       invokeRestart <- base::invokeRestart
[16:11:57.488]                       is.null <- base::is.null
[16:11:57.488]                       muffled <- FALSE
[16:11:57.488]                       if (inherits(cond, "message")) {
[16:11:57.488]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:57.488]                         if (muffled) 
[16:11:57.488]                           invokeRestart("muffleMessage")
[16:11:57.488]                       }
[16:11:57.488]                       else if (inherits(cond, "warning")) {
[16:11:57.488]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:57.488]                         if (muffled) 
[16:11:57.488]                           invokeRestart("muffleWarning")
[16:11:57.488]                       }
[16:11:57.488]                       else if (inherits(cond, "condition")) {
[16:11:57.488]                         if (!is.null(pattern)) {
[16:11:57.488]                           computeRestarts <- base::computeRestarts
[16:11:57.488]                           grepl <- base::grepl
[16:11:57.488]                           restarts <- computeRestarts(cond)
[16:11:57.488]                           for (restart in restarts) {
[16:11:57.488]                             name <- restart$name
[16:11:57.488]                             if (is.null(name)) 
[16:11:57.488]                               next
[16:11:57.488]                             if (!grepl(pattern, name)) 
[16:11:57.488]                               next
[16:11:57.488]                             invokeRestart(restart)
[16:11:57.488]                             muffled <- TRUE
[16:11:57.488]                             break
[16:11:57.488]                           }
[16:11:57.488]                         }
[16:11:57.488]                       }
[16:11:57.488]                       invisible(muffled)
[16:11:57.488]                     }
[16:11:57.488]                     muffleCondition(cond, pattern = "^muffle")
[16:11:57.488]                   }
[16:11:57.488]                 }
[16:11:57.488]             }
[16:11:57.488]         }))
[16:11:57.488]     }, error = function(ex) {
[16:11:57.488]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:57.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:57.488]                 ...future.rng), started = ...future.startTime, 
[16:11:57.488]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:57.488]             version = "1.8"), class = "FutureResult")
[16:11:57.488]     }, finally = {
[16:11:57.488]         if (!identical(...future.workdir, getwd())) 
[16:11:57.488]             setwd(...future.workdir)
[16:11:57.488]         {
[16:11:57.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:57.488]                 ...future.oldOptions$nwarnings <- NULL
[16:11:57.488]             }
[16:11:57.488]             base::options(...future.oldOptions)
[16:11:57.488]             if (.Platform$OS.type == "windows") {
[16:11:57.488]                 old_names <- names(...future.oldEnvVars)
[16:11:57.488]                 envs <- base::Sys.getenv()
[16:11:57.488]                 names <- names(envs)
[16:11:57.488]                 common <- intersect(names, old_names)
[16:11:57.488]                 added <- setdiff(names, old_names)
[16:11:57.488]                 removed <- setdiff(old_names, names)
[16:11:57.488]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:57.488]                   envs[common]]
[16:11:57.488]                 NAMES <- toupper(changed)
[16:11:57.488]                 args <- list()
[16:11:57.488]                 for (kk in seq_along(NAMES)) {
[16:11:57.488]                   name <- changed[[kk]]
[16:11:57.488]                   NAME <- NAMES[[kk]]
[16:11:57.488]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:57.488]                     next
[16:11:57.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:57.488]                 }
[16:11:57.488]                 NAMES <- toupper(added)
[16:11:57.488]                 for (kk in seq_along(NAMES)) {
[16:11:57.488]                   name <- added[[kk]]
[16:11:57.488]                   NAME <- NAMES[[kk]]
[16:11:57.488]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:57.488]                     next
[16:11:57.488]                   args[[name]] <- ""
[16:11:57.488]                 }
[16:11:57.488]                 NAMES <- toupper(removed)
[16:11:57.488]                 for (kk in seq_along(NAMES)) {
[16:11:57.488]                   name <- removed[[kk]]
[16:11:57.488]                   NAME <- NAMES[[kk]]
[16:11:57.488]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:57.488]                     next
[16:11:57.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:57.488]                 }
[16:11:57.488]                 if (length(args) > 0) 
[16:11:57.488]                   base::do.call(base::Sys.setenv, args = args)
[16:11:57.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:57.488]             }
[16:11:57.488]             else {
[16:11:57.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:57.488]             }
[16:11:57.488]             {
[16:11:57.488]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:57.488]                   0L) {
[16:11:57.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:57.488]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:57.488]                   base::options(opts)
[16:11:57.488]                 }
[16:11:57.488]                 {
[16:11:57.488]                   {
[16:11:57.488]                     NULL
[16:11:57.488]                     RNGkind("Mersenne-Twister")
[16:11:57.488]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:57.488]                       inherits = FALSE)
[16:11:57.488]                   }
[16:11:57.488]                   options(future.plan = NULL)
[16:11:57.488]                   if (is.na(NA_character_)) 
[16:11:57.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:57.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:57.488]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:57.488]                   {
[16:11:57.488]                     future <- SequentialFuture(..., envir = envir)
[16:11:57.488]                     if (!future$lazy) 
[16:11:57.488]                       future <- run(future)
[16:11:57.488]                     invisible(future)
[16:11:57.488]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:57.488]                 }
[16:11:57.488]             }
[16:11:57.488]         }
[16:11:57.488]     })
[16:11:57.488]     if (FALSE) {
[16:11:57.488]         base::sink(type = "output", split = FALSE)
[16:11:57.488]         if (NA) {
[16:11:57.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:57.488]         }
[16:11:57.488]         else {
[16:11:57.488]             ...future.result["stdout"] <- base::list(NULL)
[16:11:57.488]         }
[16:11:57.488]         base::close(...future.stdout)
[16:11:57.488]         ...future.stdout <- NULL
[16:11:57.488]     }
[16:11:57.488]     ...future.result$conditions <- ...future.conditions
[16:11:57.488]     ...future.result$finished <- base::Sys.time()
[16:11:57.488]     ...future.result
[16:11:57.488] }
[16:11:57.489] assign_globals() ...
[16:11:57.490] List of 2
[16:11:57.490]  $ x:Classes 'listenv', 'environment' <environment: 0x55693b039f00> 
[16:11:57.490]  $ i: int 7
[16:11:57.490]  - attr(*, "where")=List of 2
[16:11:57.490]   ..$ x:<environment: R_EmptyEnv> 
[16:11:57.490]   ..$ i:<environment: R_EmptyEnv> 
[16:11:57.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:57.490]  - attr(*, "resolved")= logi FALSE
[16:11:57.490]  - attr(*, "total_size")= num 34264
[16:11:57.490]  - attr(*, "already-done")= logi TRUE
[16:11:57.496] - copied ‘x’ to environment
[16:11:57.496] - copied ‘i’ to environment
[16:11:57.496] assign_globals() ... done
[16:11:57.497] plan(): Setting new future strategy stack:
[16:11:57.497] List of future strategies:
[16:11:57.497] 1. sequential:
[16:11:57.497]    - args: function (..., envir = parent.frame())
[16:11:57.497]    - tweaked: FALSE
[16:11:57.497]    - call: NULL
[16:11:57.497] plan(): nbrOfWorkers() = 1
[16:11:57.575] plan(): Setting new future strategy stack:
[16:11:57.575] List of future strategies:
[16:11:57.575] 1. sequential:
[16:11:57.575]    - args: function (..., envir = parent.frame())
[16:11:57.575]    - tweaked: FALSE
[16:11:57.575]    - call: plan(sequential)
[16:11:57.575] plan(): nbrOfWorkers() = 1
[16:11:57.576] SequentialFuture started (and completed)
[16:11:57.576] - Launch lazy future ... done
[16:11:57.576] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[16:11:57.576] run() for ‘Future’ ...
[16:11:57.576] - state: ‘created’
[16:11:57.576] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:57.577] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:57.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:57.577]   - Field: ‘label’
[16:11:57.577]   - Field: ‘local’
[16:11:57.577]   - Field: ‘owner’
[16:11:57.577]   - Field: ‘envir’
[16:11:57.577]   - Field: ‘packages’
[16:11:57.577]   - Field: ‘gc’
[16:11:57.578]   - Field: ‘conditions’
[16:11:57.578]   - Field: ‘expr’
[16:11:57.578]   - Field: ‘uuid’
[16:11:57.578]   - Field: ‘seed’
[16:11:57.578]   - Field: ‘version’
[16:11:57.578]   - Field: ‘result’
[16:11:57.578]   - Field: ‘asynchronous’
[16:11:57.578]   - Field: ‘calls’
[16:11:57.578]   - Field: ‘globals’
[16:11:57.578]   - Field: ‘stdout’
[16:11:57.578]   - Field: ‘earlySignal’
[16:11:57.579]   - Field: ‘lazy’
[16:11:57.579]   - Field: ‘state’
[16:11:57.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:57.579] - Launch lazy future ...
[16:11:57.579] Packages needed by the future expression (n = 0): <none>
[16:11:57.579] Packages needed by future strategies (n = 0): <none>
[16:11:57.580] {
[16:11:57.580]     {
[16:11:57.580]         {
[16:11:57.580]             ...future.startTime <- base::Sys.time()
[16:11:57.580]             {
[16:11:57.580]                 {
[16:11:57.580]                   {
[16:11:57.580]                     base::local({
[16:11:57.580]                       has_future <- base::requireNamespace("future", 
[16:11:57.580]                         quietly = TRUE)
[16:11:57.580]                       if (has_future) {
[16:11:57.580]                         ns <- base::getNamespace("future")
[16:11:57.580]                         version <- ns[[".package"]][["version"]]
[16:11:57.580]                         if (is.null(version)) 
[16:11:57.580]                           version <- utils::packageVersion("future")
[16:11:57.580]                       }
[16:11:57.580]                       else {
[16:11:57.580]                         version <- NULL
[16:11:57.580]                       }
[16:11:57.580]                       if (!has_future || version < "1.8.0") {
[16:11:57.580]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:57.580]                           "", base::R.version$version.string), 
[16:11:57.580]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:57.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:57.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:57.580]                             "release", "version")], collapse = " "), 
[16:11:57.580]                           hostname = base::Sys.info()[["nodename"]])
[16:11:57.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:57.580]                           info)
[16:11:57.580]                         info <- base::paste(info, collapse = "; ")
[16:11:57.580]                         if (!has_future) {
[16:11:57.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:57.580]                             info)
[16:11:57.580]                         }
[16:11:57.580]                         else {
[16:11:57.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:57.580]                             info, version)
[16:11:57.580]                         }
[16:11:57.580]                         base::stop(msg)
[16:11:57.580]                       }
[16:11:57.580]                     })
[16:11:57.580]                   }
[16:11:57.580]                   options(future.plan = NULL)
[16:11:57.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:57.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:57.580]                 }
[16:11:57.580]                 ...future.workdir <- getwd()
[16:11:57.580]             }
[16:11:57.580]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:57.580]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:57.580]         }
[16:11:57.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:57.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:57.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:57.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:57.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:57.580]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:57.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:57.580]             base::names(...future.oldOptions))
[16:11:57.580]     }
[16:11:57.580]     if (TRUE) {
[16:11:57.580]     }
[16:11:57.580]     else {
[16:11:57.580]         if (NA) {
[16:11:57.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:57.580]                 open = "w")
[16:11:57.580]         }
[16:11:57.580]         else {
[16:11:57.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:57.580]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:57.580]         }
[16:11:57.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:57.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:57.580]             base::sink(type = "output", split = FALSE)
[16:11:57.580]             base::close(...future.stdout)
[16:11:57.580]         }, add = TRUE)
[16:11:57.580]     }
[16:11:57.580]     ...future.frame <- base::sys.nframe()
[16:11:57.580]     ...future.conditions <- base::list()
[16:11:57.580]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:57.580]     if (FALSE) {
[16:11:57.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:57.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:57.580]     }
[16:11:57.580]     ...future.result <- base::tryCatch({
[16:11:57.580]         base::withCallingHandlers({
[16:11:57.580]             ...future.value <- base::withVisible(base::local({
[16:11:57.580]                 x[[i - 2]] + x[[i - 1]]
[16:11:57.580]             }))
[16:11:57.580]             future::FutureResult(value = ...future.value$value, 
[16:11:57.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:57.580]                   ...future.rng), globalenv = if (FALSE) 
[16:11:57.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:57.580]                     ...future.globalenv.names))
[16:11:57.580]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:57.580]         }, condition = base::local({
[16:11:57.580]             c <- base::c
[16:11:57.580]             inherits <- base::inherits
[16:11:57.580]             invokeRestart <- base::invokeRestart
[16:11:57.580]             length <- base::length
[16:11:57.580]             list <- base::list
[16:11:57.580]             seq.int <- base::seq.int
[16:11:57.580]             signalCondition <- base::signalCondition
[16:11:57.580]             sys.calls <- base::sys.calls
[16:11:57.580]             `[[` <- base::`[[`
[16:11:57.580]             `+` <- base::`+`
[16:11:57.580]             `<<-` <- base::`<<-`
[16:11:57.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:57.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:57.580]                   3L)]
[16:11:57.580]             }
[16:11:57.580]             function(cond) {
[16:11:57.580]                 is_error <- inherits(cond, "error")
[16:11:57.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:57.580]                   NULL)
[16:11:57.580]                 if (is_error) {
[16:11:57.580]                   sessionInformation <- function() {
[16:11:57.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:57.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:57.580]                       search = base::search(), system = base::Sys.info())
[16:11:57.580]                   }
[16:11:57.580]                   ...future.conditions[[length(...future.conditions) + 
[16:11:57.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:57.580]                     cond$call), session = sessionInformation(), 
[16:11:57.580]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:57.580]                   signalCondition(cond)
[16:11:57.580]                 }
[16:11:57.580]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[16:11:57.580]                 "immediateCondition"))) {
[16:11:57.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:57.580]                   ...future.conditions[[length(...future.conditions) + 
[16:11:57.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:57.580]                   if (TRUE && !signal) {
[16:11:57.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:57.580]                     {
[16:11:57.580]                       inherits <- base::inherits
[16:11:57.580]                       invokeRestart <- base::invokeRestart
[16:11:57.580]                       is.null <- base::is.null
[16:11:57.580]                       muffled <- FALSE
[16:11:57.580]                       if (inherits(cond, "message")) {
[16:11:57.580]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:57.580]                         if (muffled) 
[16:11:57.580]                           invokeRestart("muffleMessage")
[16:11:57.580]                       }
[16:11:57.580]                       else if (inherits(cond, "warning")) {
[16:11:57.580]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:57.580]                         if (muffled) 
[16:11:57.580]                           invokeRestart("muffleWarning")
[16:11:57.580]                       }
[16:11:57.580]                       else if (inherits(cond, "condition")) {
[16:11:57.580]                         if (!is.null(pattern)) {
[16:11:57.580]                           computeRestarts <- base::computeRestarts
[16:11:57.580]                           grepl <- base::grepl
[16:11:57.580]                           restarts <- computeRestarts(cond)
[16:11:57.580]                           for (restart in restarts) {
[16:11:57.580]                             name <- restart$name
[16:11:57.580]                             if (is.null(name)) 
[16:11:57.580]                               next
[16:11:57.580]                             if (!grepl(pattern, name)) 
[16:11:57.580]                               next
[16:11:57.580]                             invokeRestart(restart)
[16:11:57.580]                             muffled <- TRUE
[16:11:57.580]                             break
[16:11:57.580]                           }
[16:11:57.580]                         }
[16:11:57.580]                       }
[16:11:57.580]                       invisible(muffled)
[16:11:57.580]                     }
[16:11:57.580]                     muffleCondition(cond, pattern = "^muffle")
[16:11:57.580]                   }
[16:11:57.580]                 }
[16:11:57.580]                 else {
[16:11:57.580]                   if (TRUE) {
[16:11:57.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:57.580]                     {
[16:11:57.580]                       inherits <- base::inherits
[16:11:57.580]                       invokeRestart <- base::invokeRestart
[16:11:57.580]                       is.null <- base::is.null
[16:11:57.580]                       muffled <- FALSE
[16:11:57.580]                       if (inherits(cond, "message")) {
[16:11:57.580]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:57.580]                         if (muffled) 
[16:11:57.580]                           invokeRestart("muffleMessage")
[16:11:57.580]                       }
[16:11:57.580]                       else if (inherits(cond, "warning")) {
[16:11:57.580]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:57.580]                         if (muffled) 
[16:11:57.580]                           invokeRestart("muffleWarning")
[16:11:57.580]                       }
[16:11:57.580]                       else if (inherits(cond, "condition")) {
[16:11:57.580]                         if (!is.null(pattern)) {
[16:11:57.580]                           computeRestarts <- base::computeRestarts
[16:11:57.580]                           grepl <- base::grepl
[16:11:57.580]                           restarts <- computeRestarts(cond)
[16:11:57.580]                           for (restart in restarts) {
[16:11:57.580]                             name <- restart$name
[16:11:57.580]                             if (is.null(name)) 
[16:11:57.580]                               next
[16:11:57.580]                             if (!grepl(pattern, name)) 
[16:11:57.580]                               next
[16:11:57.580]                             invokeRestart(restart)
[16:11:57.580]                             muffled <- TRUE
[16:11:57.580]                             break
[16:11:57.580]                           }
[16:11:57.580]                         }
[16:11:57.580]                       }
[16:11:57.580]                       invisible(muffled)
[16:11:57.580]                     }
[16:11:57.580]                     muffleCondition(cond, pattern = "^muffle")
[16:11:57.580]                   }
[16:11:57.580]                 }
[16:11:57.580]             }
[16:11:57.580]         }))
[16:11:57.580]     }, error = function(ex) {
[16:11:57.580]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:57.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:57.580]                 ...future.rng), started = ...future.startTime, 
[16:11:57.580]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:57.580]             version = "1.8"), class = "FutureResult")
[16:11:57.580]     }, finally = {
[16:11:57.580]         if (!identical(...future.workdir, getwd())) 
[16:11:57.580]             setwd(...future.workdir)
[16:11:57.580]         {
[16:11:57.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:57.580]                 ...future.oldOptions$nwarnings <- NULL
[16:11:57.580]             }
[16:11:57.580]             base::options(...future.oldOptions)
[16:11:57.580]             if (.Platform$OS.type == "windows") {
[16:11:57.580]                 old_names <- names(...future.oldEnvVars)
[16:11:57.580]                 envs <- base::Sys.getenv()
[16:11:57.580]                 names <- names(envs)
[16:11:57.580]                 common <- intersect(names, old_names)
[16:11:57.580]                 added <- setdiff(names, old_names)
[16:11:57.580]                 removed <- setdiff(old_names, names)
[16:11:57.580]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:57.580]                   envs[common]]
[16:11:57.580]                 NAMES <- toupper(changed)
[16:11:57.580]                 args <- list()
[16:11:57.580]                 for (kk in seq_along(NAMES)) {
[16:11:57.580]                   name <- changed[[kk]]
[16:11:57.580]                   NAME <- NAMES[[kk]]
[16:11:57.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:57.580]                     next
[16:11:57.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:57.580]                 }
[16:11:57.580]                 NAMES <- toupper(added)
[16:11:57.580]                 for (kk in seq_along(NAMES)) {
[16:11:57.580]                   name <- added[[kk]]
[16:11:57.580]                   NAME <- NAMES[[kk]]
[16:11:57.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:57.580]                     next
[16:11:57.580]                   args[[name]] <- ""
[16:11:57.580]                 }
[16:11:57.580]                 NAMES <- toupper(removed)
[16:11:57.580]                 for (kk in seq_along(NAMES)) {
[16:11:57.580]                   name <- removed[[kk]]
[16:11:57.580]                   NAME <- NAMES[[kk]]
[16:11:57.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:57.580]                     next
[16:11:57.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:57.580]                 }
[16:11:57.580]                 if (length(args) > 0) 
[16:11:57.580]                   base::do.call(base::Sys.setenv, args = args)
[16:11:57.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:57.580]             }
[16:11:57.580]             else {
[16:11:57.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:57.580]             }
[16:11:57.580]             {
[16:11:57.580]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:57.580]                   0L) {
[16:11:57.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:57.580]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:57.580]                   base::options(opts)
[16:11:57.580]                 }
[16:11:57.580]                 {
[16:11:57.580]                   {
[16:11:57.580]                     NULL
[16:11:57.580]                     RNGkind("Mersenne-Twister")
[16:11:57.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:57.580]                       inherits = FALSE)
[16:11:57.580]                   }
[16:11:57.580]                   options(future.plan = NULL)
[16:11:57.580]                   if (is.na(NA_character_)) 
[16:11:57.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:57.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:57.580]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:57.580]                   {
[16:11:57.580]                     future <- SequentialFuture(..., envir = envir)
[16:11:57.580]                     if (!future$lazy) 
[16:11:57.580]                       future <- run(future)
[16:11:57.580]                     invisible(future)
[16:11:57.580]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:57.580]                 }
[16:11:57.580]             }
[16:11:57.580]         }
[16:11:57.580]     })
[16:11:57.580]     if (FALSE) {
[16:11:57.580]         base::sink(type = "output", split = FALSE)
[16:11:57.580]         if (NA) {
[16:11:57.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:57.580]         }
[16:11:57.580]         else {
[16:11:57.580]             ...future.result["stdout"] <- base::list(NULL)
[16:11:57.580]         }
[16:11:57.580]         base::close(...future.stdout)
[16:11:57.580]         ...future.stdout <- NULL
[16:11:57.580]     }
[16:11:57.580]     ...future.result$conditions <- ...future.conditions
[16:11:57.580]     ...future.result$finished <- base::Sys.time()
[16:11:57.580]     ...future.result
[16:11:57.580] }
[16:11:57.581] assign_globals() ...
[16:11:57.581] List of 2
[16:11:57.581]  $ x:Classes 'listenv', 'environment' <environment: 0x55693b039f00> 
[16:11:57.581]  $ i: int 50
[16:11:57.581]  - attr(*, "where")=List of 2
[16:11:57.581]   ..$ x:<environment: R_EmptyEnv> 
[16:11:57.581]   ..$ i:<environment: R_EmptyEnv> 
[16:11:57.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:57.581]  - attr(*, "resolved")= logi FALSE
[16:11:57.581]  - attr(*, "total_size")= num 402000
[16:11:57.581]  - attr(*, "already-done")= logi TRUE
[16:11:57.586] - copied ‘x’ to environment
[16:11:57.586] - copied ‘i’ to environment
[16:11:57.586] assign_globals() ... done
[16:11:57.586] plan(): Setting new future strategy stack:
[16:11:57.586] List of future strategies:
[16:11:57.586] 1. sequential:
[16:11:57.586]    - args: function (..., envir = parent.frame())
[16:11:57.586]    - tweaked: FALSE
[16:11:57.586]    - call: NULL
[16:11:57.587] plan(): nbrOfWorkers() = 1
[16:11:58.445] plan(): Setting new future strategy stack:
[16:11:58.445] List of future strategies:
[16:11:58.445] 1. sequential:
[16:11:58.445]    - args: function (..., envir = parent.frame())
[16:11:58.445]    - tweaked: FALSE
[16:11:58.445]    - call: plan(sequential)
[16:11:58.446] plan(): nbrOfWorkers() = 1
[16:11:58.446] SequentialFuture started (and completed)
[16:11:58.446] - Launch lazy future ... done
[16:11:58.446] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[16:11:58.447] plan(): Setting new future strategy stack:
[16:11:58.447] List of future strategies:
[16:11:58.447] 1. sequential:
[16:11:58.447]    - args: function (..., envir = parent.frame())
[16:11:58.447]    - tweaked: FALSE
[16:11:58.447]    - call: future::plan("sequential")
[16:11:58.447] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[16:11:58.453] plan(): Setting new future strategy stack:
[16:11:58.453] List of future strategies:
[16:11:58.453] 1. sequential:
[16:11:58.453]    - args: function (..., envir = parent.frame())
[16:11:58.453]    - tweaked: FALSE
[16:11:58.453]    - call: plan(strategy)
[16:11:58.454] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[16:11:58.485] getGlobalsAndPackages() ...
[16:11:58.485] Searching for globals...
[16:11:58.491] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.491] Searching for globals ... DONE
[16:11:58.491] Resolving globals: FALSE
[16:11:58.492] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.492] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.492] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.493] - packages: [1] ‘future’
[16:11:58.493] getGlobalsAndPackages() ... DONE
 2[16:11:58.496] getGlobalsAndPackages() ...
[16:11:58.496] Searching for globals...
[16:11:58.500] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.500] Searching for globals ... DONE
[16:11:58.500] Resolving globals: FALSE
[16:11:58.500] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.501] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.501] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.501] - packages: [1] ‘future’
[16:11:58.501] getGlobalsAndPackages() ... DONE
 3[16:11:58.502] getGlobalsAndPackages() ...
[16:11:58.502] Searching for globals...
[16:11:58.505] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.505] Searching for globals ... DONE
[16:11:58.505] Resolving globals: FALSE
[16:11:58.506] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.506] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.506] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.506] - packages: [1] ‘future’
[16:11:58.506] getGlobalsAndPackages() ... DONE
 4[16:11:58.507] getGlobalsAndPackages() ...
[16:11:58.507] Searching for globals...
[16:11:58.510] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.510] Searching for globals ... DONE
[16:11:58.510] Resolving globals: FALSE
[16:11:58.511] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.511] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.511] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.512] - packages: [1] ‘future’
[16:11:58.512] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[16:11:58.520] resolved() for ‘Future’ ...
[16:11:58.521] - state: ‘created’
[16:11:58.521] - run: TRUE
[16:11:58.521] - run() ...
[16:11:58.521] run() for ‘Future’ ...
[16:11:58.521] - state: ‘created’
[16:11:58.521] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:58.521] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:58.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:58.522]   - Field: ‘label’
[16:11:58.522]   - Field: ‘local’
[16:11:58.522]   - Field: ‘owner’
[16:11:58.522]   - Field: ‘envir’
[16:11:58.522]   - Field: ‘packages’
[16:11:58.522]   - Field: ‘gc’
[16:11:58.522]   - Field: ‘conditions’
[16:11:58.522]   - Field: ‘expr’
[16:11:58.522]   - Field: ‘uuid’
[16:11:58.522]   - Field: ‘seed’
[16:11:58.523]   - Field: ‘version’
[16:11:58.523]   - Field: ‘result’
[16:11:58.523]   - Field: ‘asynchronous’
[16:11:58.523]   - Field: ‘calls’
[16:11:58.523]   - Field: ‘globals’
[16:11:58.523]   - Field: ‘stdout’
[16:11:58.523]   - Field: ‘earlySignal’
[16:11:58.523]   - Field: ‘lazy’
[16:11:58.523]   - Field: ‘state’
[16:11:58.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:58.524] - Launch lazy future ...
[16:11:58.524] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.524] Packages needed by future strategies (n = 0): <none>
[16:11:58.524] {
[16:11:58.524]     {
[16:11:58.524]         {
[16:11:58.524]             ...future.startTime <- base::Sys.time()
[16:11:58.524]             {
[16:11:58.524]                 {
[16:11:58.524]                   {
[16:11:58.524]                     {
[16:11:58.524]                       base::local({
[16:11:58.524]                         has_future <- base::requireNamespace("future", 
[16:11:58.524]                           quietly = TRUE)
[16:11:58.524]                         if (has_future) {
[16:11:58.524]                           ns <- base::getNamespace("future")
[16:11:58.524]                           version <- ns[[".package"]][["version"]]
[16:11:58.524]                           if (is.null(version)) 
[16:11:58.524]                             version <- utils::packageVersion("future")
[16:11:58.524]                         }
[16:11:58.524]                         else {
[16:11:58.524]                           version <- NULL
[16:11:58.524]                         }
[16:11:58.524]                         if (!has_future || version < "1.8.0") {
[16:11:58.524]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.524]                             "", base::R.version$version.string), 
[16:11:58.524]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:58.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:58.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.524]                               "release", "version")], collapse = " "), 
[16:11:58.524]                             hostname = base::Sys.info()[["nodename"]])
[16:11:58.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.524]                             info)
[16:11:58.524]                           info <- base::paste(info, collapse = "; ")
[16:11:58.524]                           if (!has_future) {
[16:11:58.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.524]                               info)
[16:11:58.524]                           }
[16:11:58.524]                           else {
[16:11:58.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.524]                               info, version)
[16:11:58.524]                           }
[16:11:58.524]                           base::stop(msg)
[16:11:58.524]                         }
[16:11:58.524]                       })
[16:11:58.524]                     }
[16:11:58.524]                     base::local({
[16:11:58.524]                       for (pkg in "future") {
[16:11:58.524]                         base::loadNamespace(pkg)
[16:11:58.524]                         base::library(pkg, character.only = TRUE)
[16:11:58.524]                       }
[16:11:58.524]                     })
[16:11:58.524]                   }
[16:11:58.524]                   options(future.plan = NULL)
[16:11:58.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.524]                 }
[16:11:58.524]                 ...future.workdir <- getwd()
[16:11:58.524]             }
[16:11:58.524]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.524]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.524]         }
[16:11:58.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.524]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.524]             base::names(...future.oldOptions))
[16:11:58.524]     }
[16:11:58.524]     if (FALSE) {
[16:11:58.524]     }
[16:11:58.524]     else {
[16:11:58.524]         if (TRUE) {
[16:11:58.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.524]                 open = "w")
[16:11:58.524]         }
[16:11:58.524]         else {
[16:11:58.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.524]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.524]         }
[16:11:58.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.524]             base::sink(type = "output", split = FALSE)
[16:11:58.524]             base::close(...future.stdout)
[16:11:58.524]         }, add = TRUE)
[16:11:58.524]     }
[16:11:58.524]     ...future.frame <- base::sys.nframe()
[16:11:58.524]     ...future.conditions <- base::list()
[16:11:58.524]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.524]     if (FALSE) {
[16:11:58.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.524]     }
[16:11:58.524]     ...future.result <- base::tryCatch({
[16:11:58.524]         base::withCallingHandlers({
[16:11:58.524]             ...future.value <- base::withVisible(base::local({
[16:11:58.524]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.524]                   ii, n), appendLF = FALSE)
[16:11:58.524]                 fit <- mandelbrot(C)
[16:11:58.524]                 delay(fit)
[16:11:58.524]                 message(" done")
[16:11:58.524]                 fit
[16:11:58.524]             }))
[16:11:58.524]             future::FutureResult(value = ...future.value$value, 
[16:11:58.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.524]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.524]                     ...future.globalenv.names))
[16:11:58.524]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.524]         }, condition = base::local({
[16:11:58.524]             c <- base::c
[16:11:58.524]             inherits <- base::inherits
[16:11:58.524]             invokeRestart <- base::invokeRestart
[16:11:58.524]             length <- base::length
[16:11:58.524]             list <- base::list
[16:11:58.524]             seq.int <- base::seq.int
[16:11:58.524]             signalCondition <- base::signalCondition
[16:11:58.524]             sys.calls <- base::sys.calls
[16:11:58.524]             `[[` <- base::`[[`
[16:11:58.524]             `+` <- base::`+`
[16:11:58.524]             `<<-` <- base::`<<-`
[16:11:58.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.524]                   3L)]
[16:11:58.524]             }
[16:11:58.524]             function(cond) {
[16:11:58.524]                 is_error <- inherits(cond, "error")
[16:11:58.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.524]                   NULL)
[16:11:58.524]                 if (is_error) {
[16:11:58.524]                   sessionInformation <- function() {
[16:11:58.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.524]                       search = base::search(), system = base::Sys.info())
[16:11:58.524]                   }
[16:11:58.524]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.524]                     cond$call), session = sessionInformation(), 
[16:11:58.524]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.524]                   signalCondition(cond)
[16:11:58.524]                 }
[16:11:58.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.524]                 "immediateCondition"))) {
[16:11:58.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.524]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.524]                   if (TRUE && !signal) {
[16:11:58.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.524]                     {
[16:11:58.524]                       inherits <- base::inherits
[16:11:58.524]                       invokeRestart <- base::invokeRestart
[16:11:58.524]                       is.null <- base::is.null
[16:11:58.524]                       muffled <- FALSE
[16:11:58.524]                       if (inherits(cond, "message")) {
[16:11:58.524]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.524]                         if (muffled) 
[16:11:58.524]                           invokeRestart("muffleMessage")
[16:11:58.524]                       }
[16:11:58.524]                       else if (inherits(cond, "warning")) {
[16:11:58.524]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.524]                         if (muffled) 
[16:11:58.524]                           invokeRestart("muffleWarning")
[16:11:58.524]                       }
[16:11:58.524]                       else if (inherits(cond, "condition")) {
[16:11:58.524]                         if (!is.null(pattern)) {
[16:11:58.524]                           computeRestarts <- base::computeRestarts
[16:11:58.524]                           grepl <- base::grepl
[16:11:58.524]                           restarts <- computeRestarts(cond)
[16:11:58.524]                           for (restart in restarts) {
[16:11:58.524]                             name <- restart$name
[16:11:58.524]                             if (is.null(name)) 
[16:11:58.524]                               next
[16:11:58.524]                             if (!grepl(pattern, name)) 
[16:11:58.524]                               next
[16:11:58.524]                             invokeRestart(restart)
[16:11:58.524]                             muffled <- TRUE
[16:11:58.524]                             break
[16:11:58.524]                           }
[16:11:58.524]                         }
[16:11:58.524]                       }
[16:11:58.524]                       invisible(muffled)
[16:11:58.524]                     }
[16:11:58.524]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.524]                   }
[16:11:58.524]                 }
[16:11:58.524]                 else {
[16:11:58.524]                   if (TRUE) {
[16:11:58.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.524]                     {
[16:11:58.524]                       inherits <- base::inherits
[16:11:58.524]                       invokeRestart <- base::invokeRestart
[16:11:58.524]                       is.null <- base::is.null
[16:11:58.524]                       muffled <- FALSE
[16:11:58.524]                       if (inherits(cond, "message")) {
[16:11:58.524]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.524]                         if (muffled) 
[16:11:58.524]                           invokeRestart("muffleMessage")
[16:11:58.524]                       }
[16:11:58.524]                       else if (inherits(cond, "warning")) {
[16:11:58.524]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.524]                         if (muffled) 
[16:11:58.524]                           invokeRestart("muffleWarning")
[16:11:58.524]                       }
[16:11:58.524]                       else if (inherits(cond, "condition")) {
[16:11:58.524]                         if (!is.null(pattern)) {
[16:11:58.524]                           computeRestarts <- base::computeRestarts
[16:11:58.524]                           grepl <- base::grepl
[16:11:58.524]                           restarts <- computeRestarts(cond)
[16:11:58.524]                           for (restart in restarts) {
[16:11:58.524]                             name <- restart$name
[16:11:58.524]                             if (is.null(name)) 
[16:11:58.524]                               next
[16:11:58.524]                             if (!grepl(pattern, name)) 
[16:11:58.524]                               next
[16:11:58.524]                             invokeRestart(restart)
[16:11:58.524]                             muffled <- TRUE
[16:11:58.524]                             break
[16:11:58.524]                           }
[16:11:58.524]                         }
[16:11:58.524]                       }
[16:11:58.524]                       invisible(muffled)
[16:11:58.524]                     }
[16:11:58.524]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.524]                   }
[16:11:58.524]                 }
[16:11:58.524]             }
[16:11:58.524]         }))
[16:11:58.524]     }, error = function(ex) {
[16:11:58.524]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.524]                 ...future.rng), started = ...future.startTime, 
[16:11:58.524]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.524]             version = "1.8"), class = "FutureResult")
[16:11:58.524]     }, finally = {
[16:11:58.524]         if (!identical(...future.workdir, getwd())) 
[16:11:58.524]             setwd(...future.workdir)
[16:11:58.524]         {
[16:11:58.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.524]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.524]             }
[16:11:58.524]             base::options(...future.oldOptions)
[16:11:58.524]             if (.Platform$OS.type == "windows") {
[16:11:58.524]                 old_names <- names(...future.oldEnvVars)
[16:11:58.524]                 envs <- base::Sys.getenv()
[16:11:58.524]                 names <- names(envs)
[16:11:58.524]                 common <- intersect(names, old_names)
[16:11:58.524]                 added <- setdiff(names, old_names)
[16:11:58.524]                 removed <- setdiff(old_names, names)
[16:11:58.524]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.524]                   envs[common]]
[16:11:58.524]                 NAMES <- toupper(changed)
[16:11:58.524]                 args <- list()
[16:11:58.524]                 for (kk in seq_along(NAMES)) {
[16:11:58.524]                   name <- changed[[kk]]
[16:11:58.524]                   NAME <- NAMES[[kk]]
[16:11:58.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.524]                     next
[16:11:58.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.524]                 }
[16:11:58.524]                 NAMES <- toupper(added)
[16:11:58.524]                 for (kk in seq_along(NAMES)) {
[16:11:58.524]                   name <- added[[kk]]
[16:11:58.524]                   NAME <- NAMES[[kk]]
[16:11:58.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.524]                     next
[16:11:58.524]                   args[[name]] <- ""
[16:11:58.524]                 }
[16:11:58.524]                 NAMES <- toupper(removed)
[16:11:58.524]                 for (kk in seq_along(NAMES)) {
[16:11:58.524]                   name <- removed[[kk]]
[16:11:58.524]                   NAME <- NAMES[[kk]]
[16:11:58.524]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.524]                     next
[16:11:58.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.524]                 }
[16:11:58.524]                 if (length(args) > 0) 
[16:11:58.524]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.524]             }
[16:11:58.524]             else {
[16:11:58.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.524]             }
[16:11:58.524]             {
[16:11:58.524]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.524]                   0L) {
[16:11:58.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.524]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.524]                   base::options(opts)
[16:11:58.524]                 }
[16:11:58.524]                 {
[16:11:58.524]                   {
[16:11:58.524]                     NULL
[16:11:58.524]                     RNGkind("Mersenne-Twister")
[16:11:58.524]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:58.524]                       inherits = FALSE)
[16:11:58.524]                   }
[16:11:58.524]                   options(future.plan = NULL)
[16:11:58.524]                   if (is.na(NA_character_)) 
[16:11:58.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.524]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:58.524]                   {
[16:11:58.524]                     future <- SequentialFuture(..., envir = envir)
[16:11:58.524]                     if (!future$lazy) 
[16:11:58.524]                       future <- run(future)
[16:11:58.524]                     invisible(future)
[16:11:58.524]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.524]                 }
[16:11:58.524]             }
[16:11:58.524]         }
[16:11:58.524]     })
[16:11:58.524]     if (TRUE) {
[16:11:58.524]         base::sink(type = "output", split = FALSE)
[16:11:58.524]         if (TRUE) {
[16:11:58.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.524]         }
[16:11:58.524]         else {
[16:11:58.524]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.524]         }
[16:11:58.524]         base::close(...future.stdout)
[16:11:58.524]         ...future.stdout <- NULL
[16:11:58.524]     }
[16:11:58.524]     ...future.result$conditions <- ...future.conditions
[16:11:58.524]     ...future.result$finished <- base::Sys.time()
[16:11:58.524]     ...future.result
[16:11:58.524] }
[16:11:58.526] assign_globals() ...
[16:11:58.526] List of 4
[16:11:58.526]  $ ii   : int 1
[16:11:58.526]  $ n    : int 4
[16:11:58.526]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[16:11:58.526]   ..- attr(*, "region")=List of 2
[16:11:58.526]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:11:58.526]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:11:58.526]   ..- attr(*, "tile")= int [1:2] 1 1
[16:11:58.526]  $ delay:function (counts)  
[16:11:58.526]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.526]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c7ad618> 
[16:11:58.526]  - attr(*, "where")=List of 4
[16:11:58.526]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.526]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.526]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.526]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.526]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.526]  - attr(*, "resolved")= logi FALSE
[16:11:58.526]  - attr(*, "total_size")= num 14584
[16:11:58.526]  - attr(*, "already-done")= logi TRUE
[16:11:58.532] - copied ‘ii’ to environment
[16:11:58.532] - copied ‘n’ to environment
[16:11:58.532] - copied ‘C’ to environment
[16:11:58.532] - reassign environment for ‘delay’
[16:11:58.533] - copied ‘delay’ to environment
[16:11:58.533] assign_globals() ... done
[16:11:58.533] plan(): Setting new future strategy stack:
[16:11:58.533] List of future strategies:
[16:11:58.533] 1. sequential:
[16:11:58.533]    - args: function (..., envir = parent.frame())
[16:11:58.533]    - tweaked: FALSE
[16:11:58.533]    - call: NULL
[16:11:58.533] plan(): nbrOfWorkers() = 1
[16:11:58.550] plan(): Setting new future strategy stack:
[16:11:58.550] List of future strategies:
[16:11:58.550] 1. sequential:
[16:11:58.550]    - args: function (..., envir = parent.frame())
[16:11:58.550]    - tweaked: FALSE
[16:11:58.550]    - call: plan(strategy)
[16:11:58.550] plan(): nbrOfWorkers() = 1
[16:11:58.550] SequentialFuture started (and completed)
[16:11:58.550] signalConditions() ...
[16:11:58.550]  - include = ‘immediateCondition’
[16:11:58.551]  - exclude = 
[16:11:58.551]  - resignal = FALSE
[16:11:58.551]  - Number of conditions: 2
[16:11:58.551] signalConditions() ... done
[16:11:58.551] - Launch lazy future ... done
[16:11:58.551] run() for ‘SequentialFuture’ ... done
[16:11:58.551] - run() ... done
[16:11:58.551] - resolved() ...
[16:11:58.551] resolved() for ‘SequentialFuture’ ...
[16:11:58.551] - state: ‘finished’
[16:11:58.552] - run: TRUE
[16:11:58.552] - result: ‘FutureResult’
[16:11:58.552] resolved() for ‘SequentialFuture’ ... done
[16:11:58.552] - resolved: TRUE
[16:11:58.552] - resolved() ... done
[16:11:58.552] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[16:11:58.552] signalConditions() ...
[16:11:58.552]  - include = ‘immediateCondition’
[16:11:58.552]  - exclude = 
[16:11:58.552]  - resignal = FALSE
[16:11:58.553]  - Number of conditions: 2
[16:11:58.553] signalConditions() ... done
[16:11:58.553] Future state: ‘finished’
[16:11:58.553] signalConditions() ...
[16:11:58.553]  - include = ‘condition’
[16:11:58.553]  - exclude = ‘immediateCondition’
[16:11:58.553]  - resignal = TRUE
[16:11:58.553]  - Number of conditions: 2
[16:11:58.553]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[16:11:58.553]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.554] signalConditions() ... done
[16:11:58.555] resolved() for ‘Future’ ...
[16:11:58.555] - state: ‘created’
[16:11:58.555] - run: TRUE
[16:11:58.555] - run() ...
[16:11:58.556] run() for ‘Future’ ...
[16:11:58.556] - state: ‘created’
[16:11:58.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:58.556] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:58.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:58.556]   - Field: ‘label’
[16:11:58.556]   - Field: ‘local’
[16:11:58.556]   - Field: ‘owner’
[16:11:58.557]   - Field: ‘envir’
[16:11:58.557]   - Field: ‘packages’
[16:11:58.557]   - Field: ‘gc’
[16:11:58.557]   - Field: ‘conditions’
[16:11:58.557]   - Field: ‘expr’
[16:11:58.557]   - Field: ‘uuid’
[16:11:58.557]   - Field: ‘seed’
[16:11:58.557]   - Field: ‘version’
[16:11:58.557]   - Field: ‘result’
[16:11:58.557]   - Field: ‘asynchronous’
[16:11:58.557]   - Field: ‘calls’
[16:11:58.558]   - Field: ‘globals’
[16:11:58.558]   - Field: ‘stdout’
[16:11:58.558]   - Field: ‘earlySignal’
[16:11:58.558]   - Field: ‘lazy’
[16:11:58.558]   - Field: ‘state’
[16:11:58.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:58.558] - Launch lazy future ...
[16:11:58.558] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.558] Packages needed by future strategies (n = 0): <none>
[16:11:58.559] {
[16:11:58.559]     {
[16:11:58.559]         {
[16:11:58.559]             ...future.startTime <- base::Sys.time()
[16:11:58.559]             {
[16:11:58.559]                 {
[16:11:58.559]                   {
[16:11:58.559]                     {
[16:11:58.559]                       base::local({
[16:11:58.559]                         has_future <- base::requireNamespace("future", 
[16:11:58.559]                           quietly = TRUE)
[16:11:58.559]                         if (has_future) {
[16:11:58.559]                           ns <- base::getNamespace("future")
[16:11:58.559]                           version <- ns[[".package"]][["version"]]
[16:11:58.559]                           if (is.null(version)) 
[16:11:58.559]                             version <- utils::packageVersion("future")
[16:11:58.559]                         }
[16:11:58.559]                         else {
[16:11:58.559]                           version <- NULL
[16:11:58.559]                         }
[16:11:58.559]                         if (!has_future || version < "1.8.0") {
[16:11:58.559]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.559]                             "", base::R.version$version.string), 
[16:11:58.559]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:58.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:58.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.559]                               "release", "version")], collapse = " "), 
[16:11:58.559]                             hostname = base::Sys.info()[["nodename"]])
[16:11:58.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.559]                             info)
[16:11:58.559]                           info <- base::paste(info, collapse = "; ")
[16:11:58.559]                           if (!has_future) {
[16:11:58.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.559]                               info)
[16:11:58.559]                           }
[16:11:58.559]                           else {
[16:11:58.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.559]                               info, version)
[16:11:58.559]                           }
[16:11:58.559]                           base::stop(msg)
[16:11:58.559]                         }
[16:11:58.559]                       })
[16:11:58.559]                     }
[16:11:58.559]                     base::local({
[16:11:58.559]                       for (pkg in "future") {
[16:11:58.559]                         base::loadNamespace(pkg)
[16:11:58.559]                         base::library(pkg, character.only = TRUE)
[16:11:58.559]                       }
[16:11:58.559]                     })
[16:11:58.559]                   }
[16:11:58.559]                   options(future.plan = NULL)
[16:11:58.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.559]                 }
[16:11:58.559]                 ...future.workdir <- getwd()
[16:11:58.559]             }
[16:11:58.559]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.559]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.559]         }
[16:11:58.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.559]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.559]             base::names(...future.oldOptions))
[16:11:58.559]     }
[16:11:58.559]     if (FALSE) {
[16:11:58.559]     }
[16:11:58.559]     else {
[16:11:58.559]         if (TRUE) {
[16:11:58.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.559]                 open = "w")
[16:11:58.559]         }
[16:11:58.559]         else {
[16:11:58.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.559]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.559]         }
[16:11:58.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.559]             base::sink(type = "output", split = FALSE)
[16:11:58.559]             base::close(...future.stdout)
[16:11:58.559]         }, add = TRUE)
[16:11:58.559]     }
[16:11:58.559]     ...future.frame <- base::sys.nframe()
[16:11:58.559]     ...future.conditions <- base::list()
[16:11:58.559]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.559]     if (FALSE) {
[16:11:58.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.559]     }
[16:11:58.559]     ...future.result <- base::tryCatch({
[16:11:58.559]         base::withCallingHandlers({
[16:11:58.559]             ...future.value <- base::withVisible(base::local({
[16:11:58.559]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.559]                   ii, n), appendLF = FALSE)
[16:11:58.559]                 fit <- mandelbrot(C)
[16:11:58.559]                 delay(fit)
[16:11:58.559]                 message(" done")
[16:11:58.559]                 fit
[16:11:58.559]             }))
[16:11:58.559]             future::FutureResult(value = ...future.value$value, 
[16:11:58.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.559]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.559]                     ...future.globalenv.names))
[16:11:58.559]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.559]         }, condition = base::local({
[16:11:58.559]             c <- base::c
[16:11:58.559]             inherits <- base::inherits
[16:11:58.559]             invokeRestart <- base::invokeRestart
[16:11:58.559]             length <- base::length
[16:11:58.559]             list <- base::list
[16:11:58.559]             seq.int <- base::seq.int
[16:11:58.559]             signalCondition <- base::signalCondition
[16:11:58.559]             sys.calls <- base::sys.calls
[16:11:58.559]             `[[` <- base::`[[`
[16:11:58.559]             `+` <- base::`+`
[16:11:58.559]             `<<-` <- base::`<<-`
[16:11:58.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.559]                   3L)]
[16:11:58.559]             }
[16:11:58.559]             function(cond) {
[16:11:58.559]                 is_error <- inherits(cond, "error")
[16:11:58.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.559]                   NULL)
[16:11:58.559]                 if (is_error) {
[16:11:58.559]                   sessionInformation <- function() {
[16:11:58.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.559]                       search = base::search(), system = base::Sys.info())
[16:11:58.559]                   }
[16:11:58.559]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.559]                     cond$call), session = sessionInformation(), 
[16:11:58.559]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.559]                   signalCondition(cond)
[16:11:58.559]                 }
[16:11:58.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.559]                 "immediateCondition"))) {
[16:11:58.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.559]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.559]                   if (TRUE && !signal) {
[16:11:58.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.559]                     {
[16:11:58.559]                       inherits <- base::inherits
[16:11:58.559]                       invokeRestart <- base::invokeRestart
[16:11:58.559]                       is.null <- base::is.null
[16:11:58.559]                       muffled <- FALSE
[16:11:58.559]                       if (inherits(cond, "message")) {
[16:11:58.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.559]                         if (muffled) 
[16:11:58.559]                           invokeRestart("muffleMessage")
[16:11:58.559]                       }
[16:11:58.559]                       else if (inherits(cond, "warning")) {
[16:11:58.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.559]                         if (muffled) 
[16:11:58.559]                           invokeRestart("muffleWarning")
[16:11:58.559]                       }
[16:11:58.559]                       else if (inherits(cond, "condition")) {
[16:11:58.559]                         if (!is.null(pattern)) {
[16:11:58.559]                           computeRestarts <- base::computeRestarts
[16:11:58.559]                           grepl <- base::grepl
[16:11:58.559]                           restarts <- computeRestarts(cond)
[16:11:58.559]                           for (restart in restarts) {
[16:11:58.559]                             name <- restart$name
[16:11:58.559]                             if (is.null(name)) 
[16:11:58.559]                               next
[16:11:58.559]                             if (!grepl(pattern, name)) 
[16:11:58.559]                               next
[16:11:58.559]                             invokeRestart(restart)
[16:11:58.559]                             muffled <- TRUE
[16:11:58.559]                             break
[16:11:58.559]                           }
[16:11:58.559]                         }
[16:11:58.559]                       }
[16:11:58.559]                       invisible(muffled)
[16:11:58.559]                     }
[16:11:58.559]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.559]                   }
[16:11:58.559]                 }
[16:11:58.559]                 else {
[16:11:58.559]                   if (TRUE) {
[16:11:58.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.559]                     {
[16:11:58.559]                       inherits <- base::inherits
[16:11:58.559]                       invokeRestart <- base::invokeRestart
[16:11:58.559]                       is.null <- base::is.null
[16:11:58.559]                       muffled <- FALSE
[16:11:58.559]                       if (inherits(cond, "message")) {
[16:11:58.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.559]                         if (muffled) 
[16:11:58.559]                           invokeRestart("muffleMessage")
[16:11:58.559]                       }
[16:11:58.559]                       else if (inherits(cond, "warning")) {
[16:11:58.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.559]                         if (muffled) 
[16:11:58.559]                           invokeRestart("muffleWarning")
[16:11:58.559]                       }
[16:11:58.559]                       else if (inherits(cond, "condition")) {
[16:11:58.559]                         if (!is.null(pattern)) {
[16:11:58.559]                           computeRestarts <- base::computeRestarts
[16:11:58.559]                           grepl <- base::grepl
[16:11:58.559]                           restarts <- computeRestarts(cond)
[16:11:58.559]                           for (restart in restarts) {
[16:11:58.559]                             name <- restart$name
[16:11:58.559]                             if (is.null(name)) 
[16:11:58.559]                               next
[16:11:58.559]                             if (!grepl(pattern, name)) 
[16:11:58.559]                               next
[16:11:58.559]                             invokeRestart(restart)
[16:11:58.559]                             muffled <- TRUE
[16:11:58.559]                             break
[16:11:58.559]                           }
[16:11:58.559]                         }
[16:11:58.559]                       }
[16:11:58.559]                       invisible(muffled)
[16:11:58.559]                     }
[16:11:58.559]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.559]                   }
[16:11:58.559]                 }
[16:11:58.559]             }
[16:11:58.559]         }))
[16:11:58.559]     }, error = function(ex) {
[16:11:58.559]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.559]                 ...future.rng), started = ...future.startTime, 
[16:11:58.559]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.559]             version = "1.8"), class = "FutureResult")
[16:11:58.559]     }, finally = {
[16:11:58.559]         if (!identical(...future.workdir, getwd())) 
[16:11:58.559]             setwd(...future.workdir)
[16:11:58.559]         {
[16:11:58.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.559]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.559]             }
[16:11:58.559]             base::options(...future.oldOptions)
[16:11:58.559]             if (.Platform$OS.type == "windows") {
[16:11:58.559]                 old_names <- names(...future.oldEnvVars)
[16:11:58.559]                 envs <- base::Sys.getenv()
[16:11:58.559]                 names <- names(envs)
[16:11:58.559]                 common <- intersect(names, old_names)
[16:11:58.559]                 added <- setdiff(names, old_names)
[16:11:58.559]                 removed <- setdiff(old_names, names)
[16:11:58.559]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.559]                   envs[common]]
[16:11:58.559]                 NAMES <- toupper(changed)
[16:11:58.559]                 args <- list()
[16:11:58.559]                 for (kk in seq_along(NAMES)) {
[16:11:58.559]                   name <- changed[[kk]]
[16:11:58.559]                   NAME <- NAMES[[kk]]
[16:11:58.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.559]                     next
[16:11:58.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.559]                 }
[16:11:58.559]                 NAMES <- toupper(added)
[16:11:58.559]                 for (kk in seq_along(NAMES)) {
[16:11:58.559]                   name <- added[[kk]]
[16:11:58.559]                   NAME <- NAMES[[kk]]
[16:11:58.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.559]                     next
[16:11:58.559]                   args[[name]] <- ""
[16:11:58.559]                 }
[16:11:58.559]                 NAMES <- toupper(removed)
[16:11:58.559]                 for (kk in seq_along(NAMES)) {
[16:11:58.559]                   name <- removed[[kk]]
[16:11:58.559]                   NAME <- NAMES[[kk]]
[16:11:58.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.559]                     next
[16:11:58.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.559]                 }
[16:11:58.559]                 if (length(args) > 0) 
[16:11:58.559]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.559]             }
[16:11:58.559]             else {
[16:11:58.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.559]             }
[16:11:58.559]             {
[16:11:58.559]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.559]                   0L) {
[16:11:58.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.559]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.559]                   base::options(opts)
[16:11:58.559]                 }
[16:11:58.559]                 {
[16:11:58.559]                   {
[16:11:58.559]                     NULL
[16:11:58.559]                     RNGkind("Mersenne-Twister")
[16:11:58.559]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:58.559]                       inherits = FALSE)
[16:11:58.559]                   }
[16:11:58.559]                   options(future.plan = NULL)
[16:11:58.559]                   if (is.na(NA_character_)) 
[16:11:58.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.559]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:58.559]                   {
[16:11:58.559]                     future <- SequentialFuture(..., envir = envir)
[16:11:58.559]                     if (!future$lazy) 
[16:11:58.559]                       future <- run(future)
[16:11:58.559]                     invisible(future)
[16:11:58.559]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.559]                 }
[16:11:58.559]             }
[16:11:58.559]         }
[16:11:58.559]     })
[16:11:58.559]     if (TRUE) {
[16:11:58.559]         base::sink(type = "output", split = FALSE)
[16:11:58.559]         if (TRUE) {
[16:11:58.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.559]         }
[16:11:58.559]         else {
[16:11:58.559]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.559]         }
[16:11:58.559]         base::close(...future.stdout)
[16:11:58.559]         ...future.stdout <- NULL
[16:11:58.559]     }
[16:11:58.559]     ...future.result$conditions <- ...future.conditions
[16:11:58.559]     ...future.result$finished <- base::Sys.time()
[16:11:58.559]     ...future.result
[16:11:58.559] }
[16:11:58.561] assign_globals() ...
[16:11:58.561] List of 4
[16:11:58.561]  $ ii   : int 2
[16:11:58.561]  $ n    : int 4
[16:11:58.561]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[16:11:58.561]   ..- attr(*, "region")=List of 2
[16:11:58.561]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:11:58.561]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:11:58.561]   ..- attr(*, "tile")= int [1:2] 1 2
[16:11:58.561]  $ delay:function (counts)  
[16:11:58.561]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.561]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c7ad618> 
[16:11:58.561]  - attr(*, "where")=List of 4
[16:11:58.561]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.561]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.561]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.561]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.561]  - attr(*, "resolved")= logi FALSE
[16:11:58.561]  - attr(*, "total_size")= num 14584
[16:11:58.561]  - attr(*, "already-done")= logi TRUE
[16:11:58.566] - copied ‘ii’ to environment
[16:11:58.567] - copied ‘n’ to environment
[16:11:58.567] - copied ‘C’ to environment
[16:11:58.567] - reassign environment for ‘delay’
[16:11:58.567] - copied ‘delay’ to environment
[16:11:58.567] assign_globals() ... done
[16:11:58.567] plan(): Setting new future strategy stack:
[16:11:58.567] List of future strategies:
[16:11:58.567] 1. sequential:
[16:11:58.567]    - args: function (..., envir = parent.frame())
[16:11:58.567]    - tweaked: FALSE
[16:11:58.567]    - call: NULL
[16:11:58.568] plan(): nbrOfWorkers() = 1
[16:11:58.582] plan(): Setting new future strategy stack:
[16:11:58.582] List of future strategies:
[16:11:58.582] 1. sequential:
[16:11:58.582]    - args: function (..., envir = parent.frame())
[16:11:58.582]    - tweaked: FALSE
[16:11:58.582]    - call: plan(strategy)
[16:11:58.583] plan(): nbrOfWorkers() = 1
[16:11:58.583] SequentialFuture started (and completed)
[16:11:58.583] signalConditions() ...
[16:11:58.583]  - include = ‘immediateCondition’
[16:11:58.583]  - exclude = 
[16:11:58.583]  - resignal = FALSE
[16:11:58.583]  - Number of conditions: 2
[16:11:58.584] signalConditions() ... done
[16:11:58.584] - Launch lazy future ... done
[16:11:58.584] run() for ‘SequentialFuture’ ... done
[16:11:58.584] - run() ... done
[16:11:58.584] - resolved() ...
[16:11:58.584] resolved() for ‘SequentialFuture’ ...
[16:11:58.584] - state: ‘finished’
[16:11:58.584] - run: TRUE
[16:11:58.584] - result: ‘FutureResult’
[16:11:58.584] resolved() for ‘SequentialFuture’ ... done
[16:11:58.584] - resolved: TRUE
[16:11:58.585] - resolved() ... done
[16:11:58.585] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[16:11:58.585] signalConditions() ...
[16:11:58.585]  - include = ‘immediateCondition’
[16:11:58.585]  - exclude = 
[16:11:58.585]  - resignal = FALSE
[16:11:58.585]  - Number of conditions: 2
[16:11:58.585] signalConditions() ... done
[16:11:58.585] Future state: ‘finished’
[16:11:58.585] signalConditions() ...
[16:11:58.586]  - include = ‘condition’
[16:11:58.586]  - exclude = ‘immediateCondition’
[16:11:58.586]  - resignal = TRUE
[16:11:58.586]  - Number of conditions: 2
[16:11:58.586]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[16:11:58.586]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.586] signalConditions() ... done
[16:11:58.587] resolved() for ‘Future’ ...
[16:11:58.587] - state: ‘created’
[16:11:58.587] - run: TRUE
[16:11:58.587] - run() ...
[16:11:58.587] run() for ‘Future’ ...
[16:11:58.587] - state: ‘created’
[16:11:58.587] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:58.588] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:58.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:58.588]   - Field: ‘label’
[16:11:58.588]   - Field: ‘local’
[16:11:58.588]   - Field: ‘owner’
[16:11:58.588]   - Field: ‘envir’
[16:11:58.588]   - Field: ‘packages’
[16:11:58.588]   - Field: ‘gc’
[16:11:58.588]   - Field: ‘conditions’
[16:11:58.589]   - Field: ‘expr’
[16:11:58.589]   - Field: ‘uuid’
[16:11:58.589]   - Field: ‘seed’
[16:11:58.589]   - Field: ‘version’
[16:11:58.589]   - Field: ‘result’
[16:11:58.589]   - Field: ‘asynchronous’
[16:11:58.589]   - Field: ‘calls’
[16:11:58.589]   - Field: ‘globals’
[16:11:58.589]   - Field: ‘stdout’
[16:11:58.589]   - Field: ‘earlySignal’
[16:11:58.589]   - Field: ‘lazy’
[16:11:58.590]   - Field: ‘state’
[16:11:58.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:58.590] - Launch lazy future ...
[16:11:58.590] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.590] Packages needed by future strategies (n = 0): <none>
[16:11:58.590] {
[16:11:58.590]     {
[16:11:58.590]         {
[16:11:58.590]             ...future.startTime <- base::Sys.time()
[16:11:58.590]             {
[16:11:58.590]                 {
[16:11:58.590]                   {
[16:11:58.590]                     {
[16:11:58.590]                       base::local({
[16:11:58.590]                         has_future <- base::requireNamespace("future", 
[16:11:58.590]                           quietly = TRUE)
[16:11:58.590]                         if (has_future) {
[16:11:58.590]                           ns <- base::getNamespace("future")
[16:11:58.590]                           version <- ns[[".package"]][["version"]]
[16:11:58.590]                           if (is.null(version)) 
[16:11:58.590]                             version <- utils::packageVersion("future")
[16:11:58.590]                         }
[16:11:58.590]                         else {
[16:11:58.590]                           version <- NULL
[16:11:58.590]                         }
[16:11:58.590]                         if (!has_future || version < "1.8.0") {
[16:11:58.590]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.590]                             "", base::R.version$version.string), 
[16:11:58.590]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:58.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:58.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.590]                               "release", "version")], collapse = " "), 
[16:11:58.590]                             hostname = base::Sys.info()[["nodename"]])
[16:11:58.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.590]                             info)
[16:11:58.590]                           info <- base::paste(info, collapse = "; ")
[16:11:58.590]                           if (!has_future) {
[16:11:58.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.590]                               info)
[16:11:58.590]                           }
[16:11:58.590]                           else {
[16:11:58.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.590]                               info, version)
[16:11:58.590]                           }
[16:11:58.590]                           base::stop(msg)
[16:11:58.590]                         }
[16:11:58.590]                       })
[16:11:58.590]                     }
[16:11:58.590]                     base::local({
[16:11:58.590]                       for (pkg in "future") {
[16:11:58.590]                         base::loadNamespace(pkg)
[16:11:58.590]                         base::library(pkg, character.only = TRUE)
[16:11:58.590]                       }
[16:11:58.590]                     })
[16:11:58.590]                   }
[16:11:58.590]                   options(future.plan = NULL)
[16:11:58.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.590]                 }
[16:11:58.590]                 ...future.workdir <- getwd()
[16:11:58.590]             }
[16:11:58.590]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.590]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.590]         }
[16:11:58.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.590]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.590]             base::names(...future.oldOptions))
[16:11:58.590]     }
[16:11:58.590]     if (FALSE) {
[16:11:58.590]     }
[16:11:58.590]     else {
[16:11:58.590]         if (TRUE) {
[16:11:58.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.590]                 open = "w")
[16:11:58.590]         }
[16:11:58.590]         else {
[16:11:58.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.590]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.590]         }
[16:11:58.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.590]             base::sink(type = "output", split = FALSE)
[16:11:58.590]             base::close(...future.stdout)
[16:11:58.590]         }, add = TRUE)
[16:11:58.590]     }
[16:11:58.590]     ...future.frame <- base::sys.nframe()
[16:11:58.590]     ...future.conditions <- base::list()
[16:11:58.590]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.590]     if (FALSE) {
[16:11:58.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.590]     }
[16:11:58.590]     ...future.result <- base::tryCatch({
[16:11:58.590]         base::withCallingHandlers({
[16:11:58.590]             ...future.value <- base::withVisible(base::local({
[16:11:58.590]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.590]                   ii, n), appendLF = FALSE)
[16:11:58.590]                 fit <- mandelbrot(C)
[16:11:58.590]                 delay(fit)
[16:11:58.590]                 message(" done")
[16:11:58.590]                 fit
[16:11:58.590]             }))
[16:11:58.590]             future::FutureResult(value = ...future.value$value, 
[16:11:58.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.590]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.590]                     ...future.globalenv.names))
[16:11:58.590]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.590]         }, condition = base::local({
[16:11:58.590]             c <- base::c
[16:11:58.590]             inherits <- base::inherits
[16:11:58.590]             invokeRestart <- base::invokeRestart
[16:11:58.590]             length <- base::length
[16:11:58.590]             list <- base::list
[16:11:58.590]             seq.int <- base::seq.int
[16:11:58.590]             signalCondition <- base::signalCondition
[16:11:58.590]             sys.calls <- base::sys.calls
[16:11:58.590]             `[[` <- base::`[[`
[16:11:58.590]             `+` <- base::`+`
[16:11:58.590]             `<<-` <- base::`<<-`
[16:11:58.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.590]                   3L)]
[16:11:58.590]             }
[16:11:58.590]             function(cond) {
[16:11:58.590]                 is_error <- inherits(cond, "error")
[16:11:58.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.590]                   NULL)
[16:11:58.590]                 if (is_error) {
[16:11:58.590]                   sessionInformation <- function() {
[16:11:58.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.590]                       search = base::search(), system = base::Sys.info())
[16:11:58.590]                   }
[16:11:58.590]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.590]                     cond$call), session = sessionInformation(), 
[16:11:58.590]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.590]                   signalCondition(cond)
[16:11:58.590]                 }
[16:11:58.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.590]                 "immediateCondition"))) {
[16:11:58.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.590]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.590]                   if (TRUE && !signal) {
[16:11:58.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.590]                     {
[16:11:58.590]                       inherits <- base::inherits
[16:11:58.590]                       invokeRestart <- base::invokeRestart
[16:11:58.590]                       is.null <- base::is.null
[16:11:58.590]                       muffled <- FALSE
[16:11:58.590]                       if (inherits(cond, "message")) {
[16:11:58.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.590]                         if (muffled) 
[16:11:58.590]                           invokeRestart("muffleMessage")
[16:11:58.590]                       }
[16:11:58.590]                       else if (inherits(cond, "warning")) {
[16:11:58.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.590]                         if (muffled) 
[16:11:58.590]                           invokeRestart("muffleWarning")
[16:11:58.590]                       }
[16:11:58.590]                       else if (inherits(cond, "condition")) {
[16:11:58.590]                         if (!is.null(pattern)) {
[16:11:58.590]                           computeRestarts <- base::computeRestarts
[16:11:58.590]                           grepl <- base::grepl
[16:11:58.590]                           restarts <- computeRestarts(cond)
[16:11:58.590]                           for (restart in restarts) {
[16:11:58.590]                             name <- restart$name
[16:11:58.590]                             if (is.null(name)) 
[16:11:58.590]                               next
[16:11:58.590]                             if (!grepl(pattern, name)) 
[16:11:58.590]                               next
[16:11:58.590]                             invokeRestart(restart)
[16:11:58.590]                             muffled <- TRUE
[16:11:58.590]                             break
[16:11:58.590]                           }
[16:11:58.590]                         }
[16:11:58.590]                       }
[16:11:58.590]                       invisible(muffled)
[16:11:58.590]                     }
[16:11:58.590]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.590]                   }
[16:11:58.590]                 }
[16:11:58.590]                 else {
[16:11:58.590]                   if (TRUE) {
[16:11:58.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.590]                     {
[16:11:58.590]                       inherits <- base::inherits
[16:11:58.590]                       invokeRestart <- base::invokeRestart
[16:11:58.590]                       is.null <- base::is.null
[16:11:58.590]                       muffled <- FALSE
[16:11:58.590]                       if (inherits(cond, "message")) {
[16:11:58.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.590]                         if (muffled) 
[16:11:58.590]                           invokeRestart("muffleMessage")
[16:11:58.590]                       }
[16:11:58.590]                       else if (inherits(cond, "warning")) {
[16:11:58.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.590]                         if (muffled) 
[16:11:58.590]                           invokeRestart("muffleWarning")
[16:11:58.590]                       }
[16:11:58.590]                       else if (inherits(cond, "condition")) {
[16:11:58.590]                         if (!is.null(pattern)) {
[16:11:58.590]                           computeRestarts <- base::computeRestarts
[16:11:58.590]                           grepl <- base::grepl
[16:11:58.590]                           restarts <- computeRestarts(cond)
[16:11:58.590]                           for (restart in restarts) {
[16:11:58.590]                             name <- restart$name
[16:11:58.590]                             if (is.null(name)) 
[16:11:58.590]                               next
[16:11:58.590]                             if (!grepl(pattern, name)) 
[16:11:58.590]                               next
[16:11:58.590]                             invokeRestart(restart)
[16:11:58.590]                             muffled <- TRUE
[16:11:58.590]                             break
[16:11:58.590]                           }
[16:11:58.590]                         }
[16:11:58.590]                       }
[16:11:58.590]                       invisible(muffled)
[16:11:58.590]                     }
[16:11:58.590]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.590]                   }
[16:11:58.590]                 }
[16:11:58.590]             }
[16:11:58.590]         }))
[16:11:58.590]     }, error = function(ex) {
[16:11:58.590]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.590]                 ...future.rng), started = ...future.startTime, 
[16:11:58.590]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.590]             version = "1.8"), class = "FutureResult")
[16:11:58.590]     }, finally = {
[16:11:58.590]         if (!identical(...future.workdir, getwd())) 
[16:11:58.590]             setwd(...future.workdir)
[16:11:58.590]         {
[16:11:58.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.590]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.590]             }
[16:11:58.590]             base::options(...future.oldOptions)
[16:11:58.590]             if (.Platform$OS.type == "windows") {
[16:11:58.590]                 old_names <- names(...future.oldEnvVars)
[16:11:58.590]                 envs <- base::Sys.getenv()
[16:11:58.590]                 names <- names(envs)
[16:11:58.590]                 common <- intersect(names, old_names)
[16:11:58.590]                 added <- setdiff(names, old_names)
[16:11:58.590]                 removed <- setdiff(old_names, names)
[16:11:58.590]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.590]                   envs[common]]
[16:11:58.590]                 NAMES <- toupper(changed)
[16:11:58.590]                 args <- list()
[16:11:58.590]                 for (kk in seq_along(NAMES)) {
[16:11:58.590]                   name <- changed[[kk]]
[16:11:58.590]                   NAME <- NAMES[[kk]]
[16:11:58.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.590]                     next
[16:11:58.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.590]                 }
[16:11:58.590]                 NAMES <- toupper(added)
[16:11:58.590]                 for (kk in seq_along(NAMES)) {
[16:11:58.590]                   name <- added[[kk]]
[16:11:58.590]                   NAME <- NAMES[[kk]]
[16:11:58.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.590]                     next
[16:11:58.590]                   args[[name]] <- ""
[16:11:58.590]                 }
[16:11:58.590]                 NAMES <- toupper(removed)
[16:11:58.590]                 for (kk in seq_along(NAMES)) {
[16:11:58.590]                   name <- removed[[kk]]
[16:11:58.590]                   NAME <- NAMES[[kk]]
[16:11:58.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.590]                     next
[16:11:58.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.590]                 }
[16:11:58.590]                 if (length(args) > 0) 
[16:11:58.590]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.590]             }
[16:11:58.590]             else {
[16:11:58.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.590]             }
[16:11:58.590]             {
[16:11:58.590]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.590]                   0L) {
[16:11:58.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.590]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.590]                   base::options(opts)
[16:11:58.590]                 }
[16:11:58.590]                 {
[16:11:58.590]                   {
[16:11:58.590]                     NULL
[16:11:58.590]                     RNGkind("Mersenne-Twister")
[16:11:58.590]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:58.590]                       inherits = FALSE)
[16:11:58.590]                   }
[16:11:58.590]                   options(future.plan = NULL)
[16:11:58.590]                   if (is.na(NA_character_)) 
[16:11:58.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.590]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:58.590]                   {
[16:11:58.590]                     future <- SequentialFuture(..., envir = envir)
[16:11:58.590]                     if (!future$lazy) 
[16:11:58.590]                       future <- run(future)
[16:11:58.590]                     invisible(future)
[16:11:58.590]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.590]                 }
[16:11:58.590]             }
[16:11:58.590]         }
[16:11:58.590]     })
[16:11:58.590]     if (TRUE) {
[16:11:58.590]         base::sink(type = "output", split = FALSE)
[16:11:58.590]         if (TRUE) {
[16:11:58.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.590]         }
[16:11:58.590]         else {
[16:11:58.590]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.590]         }
[16:11:58.590]         base::close(...future.stdout)
[16:11:58.590]         ...future.stdout <- NULL
[16:11:58.590]     }
[16:11:58.590]     ...future.result$conditions <- ...future.conditions
[16:11:58.590]     ...future.result$finished <- base::Sys.time()
[16:11:58.590]     ...future.result
[16:11:58.590] }
[16:11:58.592] assign_globals() ...
[16:11:58.592] List of 4
[16:11:58.592]  $ ii   : int 3
[16:11:58.592]  $ n    : int 4
[16:11:58.592]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[16:11:58.592]   ..- attr(*, "region")=List of 2
[16:11:58.592]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:11:58.592]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:11:58.592]   ..- attr(*, "tile")= int [1:2] 2 1
[16:11:58.592]  $ delay:function (counts)  
[16:11:58.592]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.592]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c7ad618> 
[16:11:58.592]  - attr(*, "where")=List of 4
[16:11:58.592]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.592]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.592]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.592]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.592]  - attr(*, "resolved")= logi FALSE
[16:11:58.592]  - attr(*, "total_size")= num 14584
[16:11:58.592]  - attr(*, "already-done")= logi TRUE
[16:11:58.598] - copied ‘ii’ to environment
[16:11:58.598] - copied ‘n’ to environment
[16:11:58.598] - copied ‘C’ to environment
[16:11:58.599] - reassign environment for ‘delay’
[16:11:58.599] - copied ‘delay’ to environment
[16:11:58.599] assign_globals() ... done
[16:11:58.599] plan(): Setting new future strategy stack:
[16:11:58.599] List of future strategies:
[16:11:58.599] 1. sequential:
[16:11:58.599]    - args: function (..., envir = parent.frame())
[16:11:58.599]    - tweaked: FALSE
[16:11:58.599]    - call: NULL
[16:11:58.600] plan(): nbrOfWorkers() = 1
[16:11:58.616] plan(): Setting new future strategy stack:
[16:11:58.616] List of future strategies:
[16:11:58.616] 1. sequential:
[16:11:58.616]    - args: function (..., envir = parent.frame())
[16:11:58.616]    - tweaked: FALSE
[16:11:58.616]    - call: plan(strategy)
[16:11:58.616] plan(): nbrOfWorkers() = 1
[16:11:58.617] SequentialFuture started (and completed)
[16:11:58.617] signalConditions() ...
[16:11:58.617]  - include = ‘immediateCondition’
[16:11:58.617]  - exclude = 
[16:11:58.617]  - resignal = FALSE
[16:11:58.617]  - Number of conditions: 2
[16:11:58.617] signalConditions() ... done
[16:11:58.617] - Launch lazy future ... done
[16:11:58.617] run() for ‘SequentialFuture’ ... done
[16:11:58.617] - run() ... done
[16:11:58.617] - resolved() ...
[16:11:58.618] resolved() for ‘SequentialFuture’ ...
[16:11:58.618] - state: ‘finished’
[16:11:58.618] - run: TRUE
[16:11:58.618] - result: ‘FutureResult’
[16:11:58.618] resolved() for ‘SequentialFuture’ ... done
[16:11:58.618] - resolved: TRUE
[16:11:58.618] - resolved() ... done
[16:11:58.618] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[16:11:58.618] signalConditions() ...
[16:11:58.618]  - include = ‘immediateCondition’
[16:11:58.619]  - exclude = 
[16:11:58.619]  - resignal = FALSE
[16:11:58.619]  - Number of conditions: 2
[16:11:58.619] signalConditions() ... done
[16:11:58.619] Future state: ‘finished’
[16:11:58.619] signalConditions() ...
[16:11:58.619]  - include = ‘condition’
[16:11:58.619]  - exclude = ‘immediateCondition’
[16:11:58.619]  - resignal = TRUE
[16:11:58.619]  - Number of conditions: 2
[16:11:58.619]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[16:11:58.620]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.620] signalConditions() ... done
[16:11:58.620] resolved() for ‘Future’ ...
[16:11:58.620] - state: ‘created’
[16:11:58.620] - run: TRUE
[16:11:58.621] - run() ...
[16:11:58.621] run() for ‘Future’ ...
[16:11:58.621] - state: ‘created’
[16:11:58.621] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:58.621] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:58.621] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:58.621]   - Field: ‘label’
[16:11:58.621]   - Field: ‘local’
[16:11:58.622]   - Field: ‘owner’
[16:11:58.622]   - Field: ‘envir’
[16:11:58.622]   - Field: ‘packages’
[16:11:58.622]   - Field: ‘gc’
[16:11:58.622]   - Field: ‘conditions’
[16:11:58.622]   - Field: ‘expr’
[16:11:58.622]   - Field: ‘uuid’
[16:11:58.622]   - Field: ‘seed’
[16:11:58.622]   - Field: ‘version’
[16:11:58.622]   - Field: ‘result’
[16:11:58.622]   - Field: ‘asynchronous’
[16:11:58.623]   - Field: ‘calls’
[16:11:58.623]   - Field: ‘globals’
[16:11:58.623]   - Field: ‘stdout’
[16:11:58.623]   - Field: ‘earlySignal’
[16:11:58.623]   - Field: ‘lazy’
[16:11:58.623]   - Field: ‘state’
[16:11:58.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:58.623] - Launch lazy future ...
[16:11:58.623] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.624] Packages needed by future strategies (n = 0): <none>
[16:11:58.624] {
[16:11:58.624]     {
[16:11:58.624]         {
[16:11:58.624]             ...future.startTime <- base::Sys.time()
[16:11:58.624]             {
[16:11:58.624]                 {
[16:11:58.624]                   {
[16:11:58.624]                     {
[16:11:58.624]                       base::local({
[16:11:58.624]                         has_future <- base::requireNamespace("future", 
[16:11:58.624]                           quietly = TRUE)
[16:11:58.624]                         if (has_future) {
[16:11:58.624]                           ns <- base::getNamespace("future")
[16:11:58.624]                           version <- ns[[".package"]][["version"]]
[16:11:58.624]                           if (is.null(version)) 
[16:11:58.624]                             version <- utils::packageVersion("future")
[16:11:58.624]                         }
[16:11:58.624]                         else {
[16:11:58.624]                           version <- NULL
[16:11:58.624]                         }
[16:11:58.624]                         if (!has_future || version < "1.8.0") {
[16:11:58.624]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.624]                             "", base::R.version$version.string), 
[16:11:58.624]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:58.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:58.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.624]                               "release", "version")], collapse = " "), 
[16:11:58.624]                             hostname = base::Sys.info()[["nodename"]])
[16:11:58.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.624]                             info)
[16:11:58.624]                           info <- base::paste(info, collapse = "; ")
[16:11:58.624]                           if (!has_future) {
[16:11:58.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.624]                               info)
[16:11:58.624]                           }
[16:11:58.624]                           else {
[16:11:58.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.624]                               info, version)
[16:11:58.624]                           }
[16:11:58.624]                           base::stop(msg)
[16:11:58.624]                         }
[16:11:58.624]                       })
[16:11:58.624]                     }
[16:11:58.624]                     base::local({
[16:11:58.624]                       for (pkg in "future") {
[16:11:58.624]                         base::loadNamespace(pkg)
[16:11:58.624]                         base::library(pkg, character.only = TRUE)
[16:11:58.624]                       }
[16:11:58.624]                     })
[16:11:58.624]                   }
[16:11:58.624]                   options(future.plan = NULL)
[16:11:58.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.624]                 }
[16:11:58.624]                 ...future.workdir <- getwd()
[16:11:58.624]             }
[16:11:58.624]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.624]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.624]         }
[16:11:58.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.624]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.624]             base::names(...future.oldOptions))
[16:11:58.624]     }
[16:11:58.624]     if (FALSE) {
[16:11:58.624]     }
[16:11:58.624]     else {
[16:11:58.624]         if (TRUE) {
[16:11:58.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.624]                 open = "w")
[16:11:58.624]         }
[16:11:58.624]         else {
[16:11:58.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.624]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.624]         }
[16:11:58.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.624]             base::sink(type = "output", split = FALSE)
[16:11:58.624]             base::close(...future.stdout)
[16:11:58.624]         }, add = TRUE)
[16:11:58.624]     }
[16:11:58.624]     ...future.frame <- base::sys.nframe()
[16:11:58.624]     ...future.conditions <- base::list()
[16:11:58.624]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.624]     if (FALSE) {
[16:11:58.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.624]     }
[16:11:58.624]     ...future.result <- base::tryCatch({
[16:11:58.624]         base::withCallingHandlers({
[16:11:58.624]             ...future.value <- base::withVisible(base::local({
[16:11:58.624]                 message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.624]                   ii, n), appendLF = FALSE)
[16:11:58.624]                 fit <- mandelbrot(C)
[16:11:58.624]                 delay(fit)
[16:11:58.624]                 message(" done")
[16:11:58.624]                 fit
[16:11:58.624]             }))
[16:11:58.624]             future::FutureResult(value = ...future.value$value, 
[16:11:58.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.624]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.624]                     ...future.globalenv.names))
[16:11:58.624]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.624]         }, condition = base::local({
[16:11:58.624]             c <- base::c
[16:11:58.624]             inherits <- base::inherits
[16:11:58.624]             invokeRestart <- base::invokeRestart
[16:11:58.624]             length <- base::length
[16:11:58.624]             list <- base::list
[16:11:58.624]             seq.int <- base::seq.int
[16:11:58.624]             signalCondition <- base::signalCondition
[16:11:58.624]             sys.calls <- base::sys.calls
[16:11:58.624]             `[[` <- base::`[[`
[16:11:58.624]             `+` <- base::`+`
[16:11:58.624]             `<<-` <- base::`<<-`
[16:11:58.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.624]                   3L)]
[16:11:58.624]             }
[16:11:58.624]             function(cond) {
[16:11:58.624]                 is_error <- inherits(cond, "error")
[16:11:58.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.624]                   NULL)
[16:11:58.624]                 if (is_error) {
[16:11:58.624]                   sessionInformation <- function() {
[16:11:58.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.624]                       search = base::search(), system = base::Sys.info())
[16:11:58.624]                   }
[16:11:58.624]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.624]                     cond$call), session = sessionInformation(), 
[16:11:58.624]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.624]                   signalCondition(cond)
[16:11:58.624]                 }
[16:11:58.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.624]                 "immediateCondition"))) {
[16:11:58.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.624]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.624]                   if (TRUE && !signal) {
[16:11:58.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.624]                     {
[16:11:58.624]                       inherits <- base::inherits
[16:11:58.624]                       invokeRestart <- base::invokeRestart
[16:11:58.624]                       is.null <- base::is.null
[16:11:58.624]                       muffled <- FALSE
[16:11:58.624]                       if (inherits(cond, "message")) {
[16:11:58.624]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.624]                         if (muffled) 
[16:11:58.624]                           invokeRestart("muffleMessage")
[16:11:58.624]                       }
[16:11:58.624]                       else if (inherits(cond, "warning")) {
[16:11:58.624]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.624]                         if (muffled) 
[16:11:58.624]                           invokeRestart("muffleWarning")
[16:11:58.624]                       }
[16:11:58.624]                       else if (inherits(cond, "condition")) {
[16:11:58.624]                         if (!is.null(pattern)) {
[16:11:58.624]                           computeRestarts <- base::computeRestarts
[16:11:58.624]                           grepl <- base::grepl
[16:11:58.624]                           restarts <- computeRestarts(cond)
[16:11:58.624]                           for (restart in restarts) {
[16:11:58.624]                             name <- restart$name
[16:11:58.624]                             if (is.null(name)) 
[16:11:58.624]                               next
[16:11:58.624]                             if (!grepl(pattern, name)) 
[16:11:58.624]                               next
[16:11:58.624]                             invokeRestart(restart)
[16:11:58.624]                             muffled <- TRUE
[16:11:58.624]                             break
[16:11:58.624]                           }
[16:11:58.624]                         }
[16:11:58.624]                       }
[16:11:58.624]                       invisible(muffled)
[16:11:58.624]                     }
[16:11:58.624]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.624]                   }
[16:11:58.624]                 }
[16:11:58.624]                 else {
[16:11:58.624]                   if (TRUE) {
[16:11:58.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.624]                     {
[16:11:58.624]                       inherits <- base::inherits
[16:11:58.624]                       invokeRestart <- base::invokeRestart
[16:11:58.624]                       is.null <- base::is.null
[16:11:58.624]                       muffled <- FALSE
[16:11:58.624]                       if (inherits(cond, "message")) {
[16:11:58.624]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.624]                         if (muffled) 
[16:11:58.624]                           invokeRestart("muffleMessage")
[16:11:58.624]                       }
[16:11:58.624]                       else if (inherits(cond, "warning")) {
[16:11:58.624]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.624]                         if (muffled) 
[16:11:58.624]                           invokeRestart("muffleWarning")
[16:11:58.624]                       }
[16:11:58.624]                       else if (inherits(cond, "condition")) {
[16:11:58.624]                         if (!is.null(pattern)) {
[16:11:58.624]                           computeRestarts <- base::computeRestarts
[16:11:58.624]                           grepl <- base::grepl
[16:11:58.624]                           restarts <- computeRestarts(cond)
[16:11:58.624]                           for (restart in restarts) {
[16:11:58.624]                             name <- restart$name
[16:11:58.624]                             if (is.null(name)) 
[16:11:58.624]                               next
[16:11:58.624]                             if (!grepl(pattern, name)) 
[16:11:58.624]                               next
[16:11:58.624]                             invokeRestart(restart)
[16:11:58.624]                             muffled <- TRUE
[16:11:58.624]                             break
[16:11:58.624]                           }
[16:11:58.624]                         }
[16:11:58.624]                       }
[16:11:58.624]                       invisible(muffled)
[16:11:58.624]                     }
[16:11:58.624]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.624]                   }
[16:11:58.624]                 }
[16:11:58.624]             }
[16:11:58.624]         }))
[16:11:58.624]     }, error = function(ex) {
[16:11:58.624]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.624]                 ...future.rng), started = ...future.startTime, 
[16:11:58.624]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.624]             version = "1.8"), class = "FutureResult")
[16:11:58.624]     }, finally = {
[16:11:58.624]         if (!identical(...future.workdir, getwd())) 
[16:11:58.624]             setwd(...future.workdir)
[16:11:58.624]         {
[16:11:58.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.624]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.624]             }
[16:11:58.624]             base::options(...future.oldOptions)
[16:11:58.624]             if (.Platform$OS.type == "windows") {
[16:11:58.624]                 old_names <- names(...future.oldEnvVars)
[16:11:58.624]                 envs <- base::Sys.getenv()
[16:11:58.624]                 names <- names(envs)
[16:11:58.624]                 common <- intersect(names, old_names)
[16:11:58.624]                 added <- setdiff(names, old_names)
[16:11:58.624]                 removed <- setdiff(old_names, names)
[16:11:58.624]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.624]                   envs[common]]
[16:11:58.624]                 NAMES <- toupper(changed)
[16:11:58.624]                 args <- list()
[16:11:58.624]                 for (kk in seq_along(NAMES)) {
[16:11:58.624]                   name <- changed[[kk]]
[16:11:58.624]                   NAME <- NAMES[[kk]]
[16:11:58.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.624]                     next
[16:11:58.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.624]                 }
[16:11:58.624]                 NAMES <- toupper(added)
[16:11:58.624]                 for (kk in seq_along(NAMES)) {
[16:11:58.624]                   name <- added[[kk]]
[16:11:58.624]                   NAME <- NAMES[[kk]]
[16:11:58.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.624]                     next
[16:11:58.624]                   args[[name]] <- ""
[16:11:58.624]                 }
[16:11:58.624]                 NAMES <- toupper(removed)
[16:11:58.624]                 for (kk in seq_along(NAMES)) {
[16:11:58.624]                   name <- removed[[kk]]
[16:11:58.624]                   NAME <- NAMES[[kk]]
[16:11:58.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.624]                     next
[16:11:58.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.624]                 }
[16:11:58.624]                 if (length(args) > 0) 
[16:11:58.624]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.624]             }
[16:11:58.624]             else {
[16:11:58.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.624]             }
[16:11:58.624]             {
[16:11:58.624]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.624]                   0L) {
[16:11:58.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.624]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.624]                   base::options(opts)
[16:11:58.624]                 }
[16:11:58.624]                 {
[16:11:58.624]                   {
[16:11:58.624]                     NULL
[16:11:58.624]                     RNGkind("Mersenne-Twister")
[16:11:58.624]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:58.624]                       inherits = FALSE)
[16:11:58.624]                   }
[16:11:58.624]                   options(future.plan = NULL)
[16:11:58.624]                   if (is.na(NA_character_)) 
[16:11:58.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.624]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:58.624]                   {
[16:11:58.624]                     future <- SequentialFuture(..., envir = envir)
[16:11:58.624]                     if (!future$lazy) 
[16:11:58.624]                       future <- run(future)
[16:11:58.624]                     invisible(future)
[16:11:58.624]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.624]                 }
[16:11:58.624]             }
[16:11:58.624]         }
[16:11:58.624]     })
[16:11:58.624]     if (TRUE) {
[16:11:58.624]         base::sink(type = "output", split = FALSE)
[16:11:58.624]         if (TRUE) {
[16:11:58.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.624]         }
[16:11:58.624]         else {
[16:11:58.624]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.624]         }
[16:11:58.624]         base::close(...future.stdout)
[16:11:58.624]         ...future.stdout <- NULL
[16:11:58.624]     }
[16:11:58.624]     ...future.result$conditions <- ...future.conditions
[16:11:58.624]     ...future.result$finished <- base::Sys.time()
[16:11:58.624]     ...future.result
[16:11:58.624] }
[16:11:58.626] assign_globals() ...
[16:11:58.626] List of 4
[16:11:58.626]  $ ii   : int 4
[16:11:58.626]  $ n    : int 4
[16:11:58.626]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[16:11:58.626]   ..- attr(*, "region")=List of 2
[16:11:58.626]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:11:58.626]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:11:58.626]   ..- attr(*, "tile")= int [1:2] 2 2
[16:11:58.626]  $ delay:function (counts)  
[16:11:58.626]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.626]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c7ad618> 
[16:11:58.626]  - attr(*, "where")=List of 4
[16:11:58.626]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.626]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.626]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.626]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.626]  - attr(*, "resolved")= logi FALSE
[16:11:58.626]  - attr(*, "total_size")= num 14584
[16:11:58.626]  - attr(*, "already-done")= logi TRUE
[16:11:58.632] - copied ‘ii’ to environment
[16:11:58.632] - copied ‘n’ to environment
[16:11:58.632] - copied ‘C’ to environment
[16:11:58.632] - reassign environment for ‘delay’
[16:11:58.632] - copied ‘delay’ to environment
[16:11:58.632] assign_globals() ... done
[16:11:58.633] plan(): Setting new future strategy stack:
[16:11:58.633] List of future strategies:
[16:11:58.633] 1. sequential:
[16:11:58.633]    - args: function (..., envir = parent.frame())
[16:11:58.633]    - tweaked: FALSE
[16:11:58.633]    - call: NULL
[16:11:58.633] plan(): nbrOfWorkers() = 1
[16:11:58.647] plan(): Setting new future strategy stack:
[16:11:58.647] List of future strategies:
[16:11:58.647] 1. sequential:
[16:11:58.647]    - args: function (..., envir = parent.frame())
[16:11:58.647]    - tweaked: FALSE
[16:11:58.647]    - call: plan(strategy)
[16:11:58.648] plan(): nbrOfWorkers() = 1
[16:11:58.648] SequentialFuture started (and completed)
[16:11:58.648] signalConditions() ...
[16:11:58.648]  - include = ‘immediateCondition’
[16:11:58.648]  - exclude = 
[16:11:58.648]  - resignal = FALSE
[16:11:58.648]  - Number of conditions: 2
[16:11:58.648] signalConditions() ... done
[16:11:58.648] - Launch lazy future ... done
[16:11:58.649] run() for ‘SequentialFuture’ ... done
[16:11:58.649] - run() ... done
[16:11:58.649] - resolved() ...
[16:11:58.649] resolved() for ‘SequentialFuture’ ...
[16:11:58.649] - state: ‘finished’
[16:11:58.649] - run: TRUE
[16:11:58.649] - result: ‘FutureResult’
[16:11:58.649] resolved() for ‘SequentialFuture’ ... done
[16:11:58.649] - resolved: TRUE
[16:11:58.649] - resolved() ... done
[16:11:58.649] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[16:11:58.650] signalConditions() ...
[16:11:58.650]  - include = ‘immediateCondition’
[16:11:58.650]  - exclude = 
[16:11:58.650]  - resignal = FALSE
[16:11:58.650]  - Number of conditions: 2
[16:11:58.650] signalConditions() ... done
[16:11:58.650] Future state: ‘finished’
[16:11:58.650] signalConditions() ...
[16:11:58.650]  - include = ‘condition’
[16:11:58.650]  - exclude = ‘immediateCondition’
[16:11:58.651]  - resignal = TRUE
[16:11:58.651]  - Number of conditions: 2
[16:11:58.651]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[16:11:58.651]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.651] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[16:11:58.658] plan(): Setting new future strategy stack:
[16:11:58.658] List of future strategies:
[16:11:58.658] 1. multicore:
[16:11:58.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:58.658]    - tweaked: FALSE
[16:11:58.658]    - call: plan(strategy)
[16:11:58.662] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[16:11:58.668] getGlobalsAndPackages() ...
[16:11:58.668] Searching for globals...
[16:11:58.672] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.672] Searching for globals ... DONE
[16:11:58.672] Resolving globals: FALSE
[16:11:58.673] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.673] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.673] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.673] - packages: [1] ‘future’
[16:11:58.673] getGlobalsAndPackages() ... DONE
 2[16:11:58.677] getGlobalsAndPackages() ...
[16:11:58.677] Searching for globals...
[16:11:58.681] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.681] Searching for globals ... DONE
[16:11:58.681] Resolving globals: FALSE
[16:11:58.681] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.682] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.682] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.682] - packages: [1] ‘future’
[16:11:58.682] getGlobalsAndPackages() ... DONE
 3[16:11:58.682] getGlobalsAndPackages() ...
[16:11:58.683] Searching for globals...
[16:11:58.686] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.686] Searching for globals ... DONE
[16:11:58.686] Resolving globals: FALSE
[16:11:58.687] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.687] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.687] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.687] - packages: [1] ‘future’
[16:11:58.687] getGlobalsAndPackages() ... DONE
 4[16:11:58.688] getGlobalsAndPackages() ...
[16:11:58.688] Searching for globals...
[16:11:58.691] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:58.691] Searching for globals ... DONE
[16:11:58.692] Resolving globals: FALSE
[16:11:58.692] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:58.693] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:58.693] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:58.693] - packages: [1] ‘future’
[16:11:58.693] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[16:11:58.702] resolved() for ‘Future’ ...
[16:11:58.702] - state: ‘created’
[16:11:58.702] - run: TRUE
[16:11:58.702] - run() ...
[16:11:58.702] run() for ‘Future’ ...
[16:11:58.703] - state: ‘created’
[16:11:58.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:58.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:58.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:58.707]   - Field: ‘label’
[16:11:58.707]   - Field: ‘local’
[16:11:58.707]   - Field: ‘owner’
[16:11:58.707]   - Field: ‘envir’
[16:11:58.707]   - Field: ‘workers’
[16:11:58.708]   - Field: ‘packages’
[16:11:58.708]   - Field: ‘gc’
[16:11:58.708]   - Field: ‘job’
[16:11:58.708]   - Field: ‘conditions’
[16:11:58.708]   - Field: ‘expr’
[16:11:58.708]   - Field: ‘uuid’
[16:11:58.708]   - Field: ‘seed’
[16:11:58.708]   - Field: ‘version’
[16:11:58.708]   - Field: ‘result’
[16:11:58.708]   - Field: ‘asynchronous’
[16:11:58.708]   - Field: ‘calls’
[16:11:58.709]   - Field: ‘globals’
[16:11:58.709]   - Field: ‘stdout’
[16:11:58.709]   - Field: ‘earlySignal’
[16:11:58.709]   - Field: ‘lazy’
[16:11:58.709]   - Field: ‘state’
[16:11:58.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:58.709] - Launch lazy future ...
[16:11:58.710] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.710] Packages needed by future strategies (n = 0): <none>
[16:11:58.711] {
[16:11:58.711]     {
[16:11:58.711]         {
[16:11:58.711]             ...future.startTime <- base::Sys.time()
[16:11:58.711]             {
[16:11:58.711]                 {
[16:11:58.711]                   {
[16:11:58.711]                     {
[16:11:58.711]                       {
[16:11:58.711]                         base::local({
[16:11:58.711]                           has_future <- base::requireNamespace("future", 
[16:11:58.711]                             quietly = TRUE)
[16:11:58.711]                           if (has_future) {
[16:11:58.711]                             ns <- base::getNamespace("future")
[16:11:58.711]                             version <- ns[[".package"]][["version"]]
[16:11:58.711]                             if (is.null(version)) 
[16:11:58.711]                               version <- utils::packageVersion("future")
[16:11:58.711]                           }
[16:11:58.711]                           else {
[16:11:58.711]                             version <- NULL
[16:11:58.711]                           }
[16:11:58.711]                           if (!has_future || version < "1.8.0") {
[16:11:58.711]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.711]                               "", base::R.version$version.string), 
[16:11:58.711]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:58.711]                                 base::R.version$platform, 8 * 
[16:11:58.711]                                   base::.Machine$sizeof.pointer), 
[16:11:58.711]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.711]                                 "release", "version")], collapse = " "), 
[16:11:58.711]                               hostname = base::Sys.info()[["nodename"]])
[16:11:58.711]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.711]                               info)
[16:11:58.711]                             info <- base::paste(info, collapse = "; ")
[16:11:58.711]                             if (!has_future) {
[16:11:58.711]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.711]                                 info)
[16:11:58.711]                             }
[16:11:58.711]                             else {
[16:11:58.711]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.711]                                 info, version)
[16:11:58.711]                             }
[16:11:58.711]                             base::stop(msg)
[16:11:58.711]                           }
[16:11:58.711]                         })
[16:11:58.711]                       }
[16:11:58.711]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:58.711]                       base::options(mc.cores = 1L)
[16:11:58.711]                     }
[16:11:58.711]                     base::local({
[16:11:58.711]                       for (pkg in "future") {
[16:11:58.711]                         base::loadNamespace(pkg)
[16:11:58.711]                         base::library(pkg, character.only = TRUE)
[16:11:58.711]                       }
[16:11:58.711]                     })
[16:11:58.711]                   }
[16:11:58.711]                   options(future.plan = NULL)
[16:11:58.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.711]                 }
[16:11:58.711]                 ...future.workdir <- getwd()
[16:11:58.711]             }
[16:11:58.711]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.711]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.711]         }
[16:11:58.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.711]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.711]             base::names(...future.oldOptions))
[16:11:58.711]     }
[16:11:58.711]     if (FALSE) {
[16:11:58.711]     }
[16:11:58.711]     else {
[16:11:58.711]         if (TRUE) {
[16:11:58.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.711]                 open = "w")
[16:11:58.711]         }
[16:11:58.711]         else {
[16:11:58.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.711]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.711]         }
[16:11:58.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.711]             base::sink(type = "output", split = FALSE)
[16:11:58.711]             base::close(...future.stdout)
[16:11:58.711]         }, add = TRUE)
[16:11:58.711]     }
[16:11:58.711]     ...future.frame <- base::sys.nframe()
[16:11:58.711]     ...future.conditions <- base::list()
[16:11:58.711]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.711]     if (FALSE) {
[16:11:58.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.711]     }
[16:11:58.711]     ...future.result <- base::tryCatch({
[16:11:58.711]         base::withCallingHandlers({
[16:11:58.711]             ...future.value <- base::withVisible(base::local({
[16:11:58.711]                 withCallingHandlers({
[16:11:58.711]                   {
[16:11:58.711]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.711]                       ii, n), appendLF = FALSE)
[16:11:58.711]                     fit <- mandelbrot(C)
[16:11:58.711]                     delay(fit)
[16:11:58.711]                     message(" done")
[16:11:58.711]                     fit
[16:11:58.711]                   }
[16:11:58.711]                 }, immediateCondition = function(cond) {
[16:11:58.711]                   save_rds <- function (object, pathname, ...) 
[16:11:58.711]                   {
[16:11:58.711]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:58.711]                     if (file_test("-f", pathname_tmp)) {
[16:11:58.711]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.711]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:58.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.711]                         fi_tmp[["mtime"]])
[16:11:58.711]                     }
[16:11:58.711]                     tryCatch({
[16:11:58.711]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:58.711]                     }, error = function(ex) {
[16:11:58.711]                       msg <- conditionMessage(ex)
[16:11:58.711]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.711]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:58.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.711]                         fi_tmp[["mtime"]], msg)
[16:11:58.711]                       ex$message <- msg
[16:11:58.711]                       stop(ex)
[16:11:58.711]                     })
[16:11:58.711]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:58.711]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:58.711]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:58.711]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.711]                       fi <- file.info(pathname)
[16:11:58.711]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:58.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.711]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:58.711]                         fi[["size"]], fi[["mtime"]])
[16:11:58.711]                       stop(msg)
[16:11:58.711]                     }
[16:11:58.711]                     invisible(pathname)
[16:11:58.711]                   }
[16:11:58.711]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:58.711]                     rootPath = tempdir()) 
[16:11:58.711]                   {
[16:11:58.711]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:58.711]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:58.711]                       tmpdir = path, fileext = ".rds")
[16:11:58.711]                     save_rds(obj, file)
[16:11:58.711]                   }
[16:11:58.711]                   saveImmediateCondition(cond, path = "/tmp/RtmpUMxmgv/.future/immediateConditions")
[16:11:58.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.711]                   {
[16:11:58.711]                     inherits <- base::inherits
[16:11:58.711]                     invokeRestart <- base::invokeRestart
[16:11:58.711]                     is.null <- base::is.null
[16:11:58.711]                     muffled <- FALSE
[16:11:58.711]                     if (inherits(cond, "message")) {
[16:11:58.711]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:58.711]                       if (muffled) 
[16:11:58.711]                         invokeRestart("muffleMessage")
[16:11:58.711]                     }
[16:11:58.711]                     else if (inherits(cond, "warning")) {
[16:11:58.711]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:58.711]                       if (muffled) 
[16:11:58.711]                         invokeRestart("muffleWarning")
[16:11:58.711]                     }
[16:11:58.711]                     else if (inherits(cond, "condition")) {
[16:11:58.711]                       if (!is.null(pattern)) {
[16:11:58.711]                         computeRestarts <- base::computeRestarts
[16:11:58.711]                         grepl <- base::grepl
[16:11:58.711]                         restarts <- computeRestarts(cond)
[16:11:58.711]                         for (restart in restarts) {
[16:11:58.711]                           name <- restart$name
[16:11:58.711]                           if (is.null(name)) 
[16:11:58.711]                             next
[16:11:58.711]                           if (!grepl(pattern, name)) 
[16:11:58.711]                             next
[16:11:58.711]                           invokeRestart(restart)
[16:11:58.711]                           muffled <- TRUE
[16:11:58.711]                           break
[16:11:58.711]                         }
[16:11:58.711]                       }
[16:11:58.711]                     }
[16:11:58.711]                     invisible(muffled)
[16:11:58.711]                   }
[16:11:58.711]                   muffleCondition(cond)
[16:11:58.711]                 })
[16:11:58.711]             }))
[16:11:58.711]             future::FutureResult(value = ...future.value$value, 
[16:11:58.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.711]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.711]                     ...future.globalenv.names))
[16:11:58.711]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.711]         }, condition = base::local({
[16:11:58.711]             c <- base::c
[16:11:58.711]             inherits <- base::inherits
[16:11:58.711]             invokeRestart <- base::invokeRestart
[16:11:58.711]             length <- base::length
[16:11:58.711]             list <- base::list
[16:11:58.711]             seq.int <- base::seq.int
[16:11:58.711]             signalCondition <- base::signalCondition
[16:11:58.711]             sys.calls <- base::sys.calls
[16:11:58.711]             `[[` <- base::`[[`
[16:11:58.711]             `+` <- base::`+`
[16:11:58.711]             `<<-` <- base::`<<-`
[16:11:58.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.711]                   3L)]
[16:11:58.711]             }
[16:11:58.711]             function(cond) {
[16:11:58.711]                 is_error <- inherits(cond, "error")
[16:11:58.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.711]                   NULL)
[16:11:58.711]                 if (is_error) {
[16:11:58.711]                   sessionInformation <- function() {
[16:11:58.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.711]                       search = base::search(), system = base::Sys.info())
[16:11:58.711]                   }
[16:11:58.711]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.711]                     cond$call), session = sessionInformation(), 
[16:11:58.711]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.711]                   signalCondition(cond)
[16:11:58.711]                 }
[16:11:58.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.711]                 "immediateCondition"))) {
[16:11:58.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.711]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.711]                   if (TRUE && !signal) {
[16:11:58.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.711]                     {
[16:11:58.711]                       inherits <- base::inherits
[16:11:58.711]                       invokeRestart <- base::invokeRestart
[16:11:58.711]                       is.null <- base::is.null
[16:11:58.711]                       muffled <- FALSE
[16:11:58.711]                       if (inherits(cond, "message")) {
[16:11:58.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.711]                         if (muffled) 
[16:11:58.711]                           invokeRestart("muffleMessage")
[16:11:58.711]                       }
[16:11:58.711]                       else if (inherits(cond, "warning")) {
[16:11:58.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.711]                         if (muffled) 
[16:11:58.711]                           invokeRestart("muffleWarning")
[16:11:58.711]                       }
[16:11:58.711]                       else if (inherits(cond, "condition")) {
[16:11:58.711]                         if (!is.null(pattern)) {
[16:11:58.711]                           computeRestarts <- base::computeRestarts
[16:11:58.711]                           grepl <- base::grepl
[16:11:58.711]                           restarts <- computeRestarts(cond)
[16:11:58.711]                           for (restart in restarts) {
[16:11:58.711]                             name <- restart$name
[16:11:58.711]                             if (is.null(name)) 
[16:11:58.711]                               next
[16:11:58.711]                             if (!grepl(pattern, name)) 
[16:11:58.711]                               next
[16:11:58.711]                             invokeRestart(restart)
[16:11:58.711]                             muffled <- TRUE
[16:11:58.711]                             break
[16:11:58.711]                           }
[16:11:58.711]                         }
[16:11:58.711]                       }
[16:11:58.711]                       invisible(muffled)
[16:11:58.711]                     }
[16:11:58.711]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.711]                   }
[16:11:58.711]                 }
[16:11:58.711]                 else {
[16:11:58.711]                   if (TRUE) {
[16:11:58.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.711]                     {
[16:11:58.711]                       inherits <- base::inherits
[16:11:58.711]                       invokeRestart <- base::invokeRestart
[16:11:58.711]                       is.null <- base::is.null
[16:11:58.711]                       muffled <- FALSE
[16:11:58.711]                       if (inherits(cond, "message")) {
[16:11:58.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.711]                         if (muffled) 
[16:11:58.711]                           invokeRestart("muffleMessage")
[16:11:58.711]                       }
[16:11:58.711]                       else if (inherits(cond, "warning")) {
[16:11:58.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.711]                         if (muffled) 
[16:11:58.711]                           invokeRestart("muffleWarning")
[16:11:58.711]                       }
[16:11:58.711]                       else if (inherits(cond, "condition")) {
[16:11:58.711]                         if (!is.null(pattern)) {
[16:11:58.711]                           computeRestarts <- base::computeRestarts
[16:11:58.711]                           grepl <- base::grepl
[16:11:58.711]                           restarts <- computeRestarts(cond)
[16:11:58.711]                           for (restart in restarts) {
[16:11:58.711]                             name <- restart$name
[16:11:58.711]                             if (is.null(name)) 
[16:11:58.711]                               next
[16:11:58.711]                             if (!grepl(pattern, name)) 
[16:11:58.711]                               next
[16:11:58.711]                             invokeRestart(restart)
[16:11:58.711]                             muffled <- TRUE
[16:11:58.711]                             break
[16:11:58.711]                           }
[16:11:58.711]                         }
[16:11:58.711]                       }
[16:11:58.711]                       invisible(muffled)
[16:11:58.711]                     }
[16:11:58.711]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.711]                   }
[16:11:58.711]                 }
[16:11:58.711]             }
[16:11:58.711]         }))
[16:11:58.711]     }, error = function(ex) {
[16:11:58.711]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.711]                 ...future.rng), started = ...future.startTime, 
[16:11:58.711]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.711]             version = "1.8"), class = "FutureResult")
[16:11:58.711]     }, finally = {
[16:11:58.711]         if (!identical(...future.workdir, getwd())) 
[16:11:58.711]             setwd(...future.workdir)
[16:11:58.711]         {
[16:11:58.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.711]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.711]             }
[16:11:58.711]             base::options(...future.oldOptions)
[16:11:58.711]             if (.Platform$OS.type == "windows") {
[16:11:58.711]                 old_names <- names(...future.oldEnvVars)
[16:11:58.711]                 envs <- base::Sys.getenv()
[16:11:58.711]                 names <- names(envs)
[16:11:58.711]                 common <- intersect(names, old_names)
[16:11:58.711]                 added <- setdiff(names, old_names)
[16:11:58.711]                 removed <- setdiff(old_names, names)
[16:11:58.711]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.711]                   envs[common]]
[16:11:58.711]                 NAMES <- toupper(changed)
[16:11:58.711]                 args <- list()
[16:11:58.711]                 for (kk in seq_along(NAMES)) {
[16:11:58.711]                   name <- changed[[kk]]
[16:11:58.711]                   NAME <- NAMES[[kk]]
[16:11:58.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.711]                     next
[16:11:58.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.711]                 }
[16:11:58.711]                 NAMES <- toupper(added)
[16:11:58.711]                 for (kk in seq_along(NAMES)) {
[16:11:58.711]                   name <- added[[kk]]
[16:11:58.711]                   NAME <- NAMES[[kk]]
[16:11:58.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.711]                     next
[16:11:58.711]                   args[[name]] <- ""
[16:11:58.711]                 }
[16:11:58.711]                 NAMES <- toupper(removed)
[16:11:58.711]                 for (kk in seq_along(NAMES)) {
[16:11:58.711]                   name <- removed[[kk]]
[16:11:58.711]                   NAME <- NAMES[[kk]]
[16:11:58.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.711]                     next
[16:11:58.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.711]                 }
[16:11:58.711]                 if (length(args) > 0) 
[16:11:58.711]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.711]             }
[16:11:58.711]             else {
[16:11:58.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.711]             }
[16:11:58.711]             {
[16:11:58.711]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.711]                   0L) {
[16:11:58.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.711]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.711]                   base::options(opts)
[16:11:58.711]                 }
[16:11:58.711]                 {
[16:11:58.711]                   {
[16:11:58.711]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:58.711]                     NULL
[16:11:58.711]                   }
[16:11:58.711]                   options(future.plan = NULL)
[16:11:58.711]                   if (is.na(NA_character_)) 
[16:11:58.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.711]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:58.711]                     envir = parent.frame()) 
[16:11:58.711]                   {
[16:11:58.711]                     default_workers <- missing(workers)
[16:11:58.711]                     if (is.function(workers)) 
[16:11:58.711]                       workers <- workers()
[16:11:58.711]                     workers <- structure(as.integer(workers), 
[16:11:58.711]                       class = class(workers))
[16:11:58.711]                     stop_if_not(is.finite(workers), workers >= 
[16:11:58.711]                       1L)
[16:11:58.711]                     if ((workers == 1L && !inherits(workers, 
[16:11:58.711]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:58.711]                       if (default_workers) 
[16:11:58.711]                         supportsMulticore(warn = TRUE)
[16:11:58.711]                       return(sequential(..., envir = envir))
[16:11:58.711]                     }
[16:11:58.711]                     oopts <- options(mc.cores = workers)
[16:11:58.711]                     on.exit(options(oopts))
[16:11:58.711]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:58.711]                       envir = envir)
[16:11:58.711]                     if (!future$lazy) 
[16:11:58.711]                       future <- run(future)
[16:11:58.711]                     invisible(future)
[16:11:58.711]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.711]                 }
[16:11:58.711]             }
[16:11:58.711]         }
[16:11:58.711]     })
[16:11:58.711]     if (TRUE) {
[16:11:58.711]         base::sink(type = "output", split = FALSE)
[16:11:58.711]         if (TRUE) {
[16:11:58.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.711]         }
[16:11:58.711]         else {
[16:11:58.711]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.711]         }
[16:11:58.711]         base::close(...future.stdout)
[16:11:58.711]         ...future.stdout <- NULL
[16:11:58.711]     }
[16:11:58.711]     ...future.result$conditions <- ...future.conditions
[16:11:58.711]     ...future.result$finished <- base::Sys.time()
[16:11:58.711]     ...future.result
[16:11:58.711] }
[16:11:58.713] assign_globals() ...
[16:11:58.714] List of 4
[16:11:58.714]  $ ii   : int 1
[16:11:58.714]  $ n    : int 4
[16:11:58.714]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[16:11:58.714]   ..- attr(*, "region")=List of 2
[16:11:58.714]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:11:58.714]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:11:58.714]   ..- attr(*, "tile")= int [1:2] 1 1
[16:11:58.714]  $ delay:function (counts)  
[16:11:58.714]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.714]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c92d958> 
[16:11:58.714]  - attr(*, "where")=List of 4
[16:11:58.714]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.714]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.714]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.714]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.714]  - attr(*, "resolved")= logi FALSE
[16:11:58.714]  - attr(*, "total_size")= num 14584
[16:11:58.714]  - attr(*, "already-done")= logi TRUE
[16:11:58.720] - copied ‘ii’ to environment
[16:11:58.720] - copied ‘n’ to environment
[16:11:58.720] - copied ‘C’ to environment
[16:11:58.720] - reassign environment for ‘delay’
[16:11:58.720] - copied ‘delay’ to environment
[16:11:58.720] assign_globals() ... done
[16:11:58.720] requestCore(): workers = 2
[16:11:58.723] MulticoreFuture started
[16:11:58.724] - Launch lazy future ... done
[16:11:58.724] run() for ‘MulticoreFuture’ ... done
[16:11:58.724] - run() ... done
[16:11:58.725] - resolved() ...
[16:11:58.725] plan(): Setting new future strategy stack:
[16:11:58.725] List of future strategies:
[16:11:58.725] 1. sequential:
[16:11:58.725]    - args: function (..., envir = parent.frame())
[16:11:58.725]    - tweaked: FALSE
[16:11:58.725]    - call: NULL
[16:11:58.726] plan(): nbrOfWorkers() = 1
[16:11:58.729] plan(): Setting new future strategy stack:
[16:11:58.729] List of future strategies:
[16:11:58.729] 1. multicore:
[16:11:58.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:58.729]    - tweaked: FALSE
[16:11:58.729]    - call: plan(strategy)
[16:11:58.734] plan(): nbrOfWorkers() = 2
[16:11:58.735] - resolved: TRUE
[16:11:58.735] - resolved() ... done
[16:11:58.735] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[16:11:58.741] signalConditions() ...
[16:11:58.741]  - include = ‘immediateCondition’
[16:11:58.741]  - exclude = 
[16:11:58.741]  - resignal = FALSE
[16:11:58.741]  - Number of conditions: 2
[16:11:58.741] signalConditions() ... done
[16:11:58.742] signalConditions() ...
[16:11:58.742]  - include = ‘immediateCondition’
[16:11:58.742]  - exclude = 
[16:11:58.742]  - resignal = FALSE
[16:11:58.742]  - Number of conditions: 2
[16:11:58.742] signalConditions() ... done
[16:11:58.742] Future state: ‘finished’
[16:11:58.742] signalConditions() ...
[16:11:58.742]  - include = ‘condition’
[16:11:58.743]  - exclude = ‘immediateCondition’
[16:11:58.743]  - resignal = TRUE
[16:11:58.743]  - Number of conditions: 2
[16:11:58.743]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[16:11:58.743]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.743] signalConditions() ... done
[16:11:58.744] resolved() for ‘Future’ ...
[16:11:58.744] - state: ‘created’
[16:11:58.744] - run: TRUE
[16:11:58.744] - run() ...
[16:11:58.745] run() for ‘Future’ ...
[16:11:58.745] - state: ‘created’
[16:11:58.745] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:58.749] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:58.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:58.749]   - Field: ‘label’
[16:11:58.752]   - Field: ‘local’
[16:11:58.753]   - Field: ‘owner’
[16:11:58.753]   - Field: ‘envir’
[16:11:58.753]   - Field: ‘workers’
[16:11:58.753]   - Field: ‘packages’
[16:11:58.753]   - Field: ‘gc’
[16:11:58.753]   - Field: ‘job’
[16:11:58.753]   - Field: ‘conditions’
[16:11:58.753]   - Field: ‘expr’
[16:11:58.754]   - Field: ‘uuid’
[16:11:58.754]   - Field: ‘seed’
[16:11:58.754]   - Field: ‘version’
[16:11:58.754]   - Field: ‘result’
[16:11:58.754]   - Field: ‘asynchronous’
[16:11:58.754]   - Field: ‘calls’
[16:11:58.754]   - Field: ‘globals’
[16:11:58.754]   - Field: ‘stdout’
[16:11:58.754]   - Field: ‘earlySignal’
[16:11:58.755]   - Field: ‘lazy’
[16:11:58.755]   - Field: ‘state’
[16:11:58.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:58.755] - Launch lazy future ...
[16:11:58.755] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.755] Packages needed by future strategies (n = 0): <none>
[16:11:58.756] {
[16:11:58.756]     {
[16:11:58.756]         {
[16:11:58.756]             ...future.startTime <- base::Sys.time()
[16:11:58.756]             {
[16:11:58.756]                 {
[16:11:58.756]                   {
[16:11:58.756]                     {
[16:11:58.756]                       {
[16:11:58.756]                         base::local({
[16:11:58.756]                           has_future <- base::requireNamespace("future", 
[16:11:58.756]                             quietly = TRUE)
[16:11:58.756]                           if (has_future) {
[16:11:58.756]                             ns <- base::getNamespace("future")
[16:11:58.756]                             version <- ns[[".package"]][["version"]]
[16:11:58.756]                             if (is.null(version)) 
[16:11:58.756]                               version <- utils::packageVersion("future")
[16:11:58.756]                           }
[16:11:58.756]                           else {
[16:11:58.756]                             version <- NULL
[16:11:58.756]                           }
[16:11:58.756]                           if (!has_future || version < "1.8.0") {
[16:11:58.756]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.756]                               "", base::R.version$version.string), 
[16:11:58.756]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:58.756]                                 base::R.version$platform, 8 * 
[16:11:58.756]                                   base::.Machine$sizeof.pointer), 
[16:11:58.756]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.756]                                 "release", "version")], collapse = " "), 
[16:11:58.756]                               hostname = base::Sys.info()[["nodename"]])
[16:11:58.756]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.756]                               info)
[16:11:58.756]                             info <- base::paste(info, collapse = "; ")
[16:11:58.756]                             if (!has_future) {
[16:11:58.756]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.756]                                 info)
[16:11:58.756]                             }
[16:11:58.756]                             else {
[16:11:58.756]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.756]                                 info, version)
[16:11:58.756]                             }
[16:11:58.756]                             base::stop(msg)
[16:11:58.756]                           }
[16:11:58.756]                         })
[16:11:58.756]                       }
[16:11:58.756]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:58.756]                       base::options(mc.cores = 1L)
[16:11:58.756]                     }
[16:11:58.756]                     base::local({
[16:11:58.756]                       for (pkg in "future") {
[16:11:58.756]                         base::loadNamespace(pkg)
[16:11:58.756]                         base::library(pkg, character.only = TRUE)
[16:11:58.756]                       }
[16:11:58.756]                     })
[16:11:58.756]                   }
[16:11:58.756]                   options(future.plan = NULL)
[16:11:58.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.756]                 }
[16:11:58.756]                 ...future.workdir <- getwd()
[16:11:58.756]             }
[16:11:58.756]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.756]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.756]         }
[16:11:58.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.756]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.756]             base::names(...future.oldOptions))
[16:11:58.756]     }
[16:11:58.756]     if (FALSE) {
[16:11:58.756]     }
[16:11:58.756]     else {
[16:11:58.756]         if (TRUE) {
[16:11:58.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.756]                 open = "w")
[16:11:58.756]         }
[16:11:58.756]         else {
[16:11:58.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.756]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.756]         }
[16:11:58.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.756]             base::sink(type = "output", split = FALSE)
[16:11:58.756]             base::close(...future.stdout)
[16:11:58.756]         }, add = TRUE)
[16:11:58.756]     }
[16:11:58.756]     ...future.frame <- base::sys.nframe()
[16:11:58.756]     ...future.conditions <- base::list()
[16:11:58.756]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.756]     if (FALSE) {
[16:11:58.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.756]     }
[16:11:58.756]     ...future.result <- base::tryCatch({
[16:11:58.756]         base::withCallingHandlers({
[16:11:58.756]             ...future.value <- base::withVisible(base::local({
[16:11:58.756]                 withCallingHandlers({
[16:11:58.756]                   {
[16:11:58.756]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.756]                       ii, n), appendLF = FALSE)
[16:11:58.756]                     fit <- mandelbrot(C)
[16:11:58.756]                     delay(fit)
[16:11:58.756]                     message(" done")
[16:11:58.756]                     fit
[16:11:58.756]                   }
[16:11:58.756]                 }, immediateCondition = function(cond) {
[16:11:58.756]                   save_rds <- function (object, pathname, ...) 
[16:11:58.756]                   {
[16:11:58.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:58.756]                     if (file_test("-f", pathname_tmp)) {
[16:11:58.756]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:58.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.756]                         fi_tmp[["mtime"]])
[16:11:58.756]                     }
[16:11:58.756]                     tryCatch({
[16:11:58.756]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:58.756]                     }, error = function(ex) {
[16:11:58.756]                       msg <- conditionMessage(ex)
[16:11:58.756]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:58.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.756]                         fi_tmp[["mtime"]], msg)
[16:11:58.756]                       ex$message <- msg
[16:11:58.756]                       stop(ex)
[16:11:58.756]                     })
[16:11:58.756]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:58.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:58.756]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:58.756]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.756]                       fi <- file.info(pathname)
[16:11:58.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:58.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:58.756]                         fi[["size"]], fi[["mtime"]])
[16:11:58.756]                       stop(msg)
[16:11:58.756]                     }
[16:11:58.756]                     invisible(pathname)
[16:11:58.756]                   }
[16:11:58.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:58.756]                     rootPath = tempdir()) 
[16:11:58.756]                   {
[16:11:58.756]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:58.756]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:58.756]                       tmpdir = path, fileext = ".rds")
[16:11:58.756]                     save_rds(obj, file)
[16:11:58.756]                   }
[16:11:58.756]                   saveImmediateCondition(cond, path = "/tmp/RtmpUMxmgv/.future/immediateConditions")
[16:11:58.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.756]                   {
[16:11:58.756]                     inherits <- base::inherits
[16:11:58.756]                     invokeRestart <- base::invokeRestart
[16:11:58.756]                     is.null <- base::is.null
[16:11:58.756]                     muffled <- FALSE
[16:11:58.756]                     if (inherits(cond, "message")) {
[16:11:58.756]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:58.756]                       if (muffled) 
[16:11:58.756]                         invokeRestart("muffleMessage")
[16:11:58.756]                     }
[16:11:58.756]                     else if (inherits(cond, "warning")) {
[16:11:58.756]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:58.756]                       if (muffled) 
[16:11:58.756]                         invokeRestart("muffleWarning")
[16:11:58.756]                     }
[16:11:58.756]                     else if (inherits(cond, "condition")) {
[16:11:58.756]                       if (!is.null(pattern)) {
[16:11:58.756]                         computeRestarts <- base::computeRestarts
[16:11:58.756]                         grepl <- base::grepl
[16:11:58.756]                         restarts <- computeRestarts(cond)
[16:11:58.756]                         for (restart in restarts) {
[16:11:58.756]                           name <- restart$name
[16:11:58.756]                           if (is.null(name)) 
[16:11:58.756]                             next
[16:11:58.756]                           if (!grepl(pattern, name)) 
[16:11:58.756]                             next
[16:11:58.756]                           invokeRestart(restart)
[16:11:58.756]                           muffled <- TRUE
[16:11:58.756]                           break
[16:11:58.756]                         }
[16:11:58.756]                       }
[16:11:58.756]                     }
[16:11:58.756]                     invisible(muffled)
[16:11:58.756]                   }
[16:11:58.756]                   muffleCondition(cond)
[16:11:58.756]                 })
[16:11:58.756]             }))
[16:11:58.756]             future::FutureResult(value = ...future.value$value, 
[16:11:58.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.756]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.756]                     ...future.globalenv.names))
[16:11:58.756]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.756]         }, condition = base::local({
[16:11:58.756]             c <- base::c
[16:11:58.756]             inherits <- base::inherits
[16:11:58.756]             invokeRestart <- base::invokeRestart
[16:11:58.756]             length <- base::length
[16:11:58.756]             list <- base::list
[16:11:58.756]             seq.int <- base::seq.int
[16:11:58.756]             signalCondition <- base::signalCondition
[16:11:58.756]             sys.calls <- base::sys.calls
[16:11:58.756]             `[[` <- base::`[[`
[16:11:58.756]             `+` <- base::`+`
[16:11:58.756]             `<<-` <- base::`<<-`
[16:11:58.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.756]                   3L)]
[16:11:58.756]             }
[16:11:58.756]             function(cond) {
[16:11:58.756]                 is_error <- inherits(cond, "error")
[16:11:58.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.756]                   NULL)
[16:11:58.756]                 if (is_error) {
[16:11:58.756]                   sessionInformation <- function() {
[16:11:58.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.756]                       search = base::search(), system = base::Sys.info())
[16:11:58.756]                   }
[16:11:58.756]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.756]                     cond$call), session = sessionInformation(), 
[16:11:58.756]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.756]                   signalCondition(cond)
[16:11:58.756]                 }
[16:11:58.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.756]                 "immediateCondition"))) {
[16:11:58.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.756]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.756]                   if (TRUE && !signal) {
[16:11:58.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.756]                     {
[16:11:58.756]                       inherits <- base::inherits
[16:11:58.756]                       invokeRestart <- base::invokeRestart
[16:11:58.756]                       is.null <- base::is.null
[16:11:58.756]                       muffled <- FALSE
[16:11:58.756]                       if (inherits(cond, "message")) {
[16:11:58.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.756]                         if (muffled) 
[16:11:58.756]                           invokeRestart("muffleMessage")
[16:11:58.756]                       }
[16:11:58.756]                       else if (inherits(cond, "warning")) {
[16:11:58.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.756]                         if (muffled) 
[16:11:58.756]                           invokeRestart("muffleWarning")
[16:11:58.756]                       }
[16:11:58.756]                       else if (inherits(cond, "condition")) {
[16:11:58.756]                         if (!is.null(pattern)) {
[16:11:58.756]                           computeRestarts <- base::computeRestarts
[16:11:58.756]                           grepl <- base::grepl
[16:11:58.756]                           restarts <- computeRestarts(cond)
[16:11:58.756]                           for (restart in restarts) {
[16:11:58.756]                             name <- restart$name
[16:11:58.756]                             if (is.null(name)) 
[16:11:58.756]                               next
[16:11:58.756]                             if (!grepl(pattern, name)) 
[16:11:58.756]                               next
[16:11:58.756]                             invokeRestart(restart)
[16:11:58.756]                             muffled <- TRUE
[16:11:58.756]                             break
[16:11:58.756]                           }
[16:11:58.756]                         }
[16:11:58.756]                       }
[16:11:58.756]                       invisible(muffled)
[16:11:58.756]                     }
[16:11:58.756]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.756]                   }
[16:11:58.756]                 }
[16:11:58.756]                 else {
[16:11:58.756]                   if (TRUE) {
[16:11:58.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.756]                     {
[16:11:58.756]                       inherits <- base::inherits
[16:11:58.756]                       invokeRestart <- base::invokeRestart
[16:11:58.756]                       is.null <- base::is.null
[16:11:58.756]                       muffled <- FALSE
[16:11:58.756]                       if (inherits(cond, "message")) {
[16:11:58.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.756]                         if (muffled) 
[16:11:58.756]                           invokeRestart("muffleMessage")
[16:11:58.756]                       }
[16:11:58.756]                       else if (inherits(cond, "warning")) {
[16:11:58.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.756]                         if (muffled) 
[16:11:58.756]                           invokeRestart("muffleWarning")
[16:11:58.756]                       }
[16:11:58.756]                       else if (inherits(cond, "condition")) {
[16:11:58.756]                         if (!is.null(pattern)) {
[16:11:58.756]                           computeRestarts <- base::computeRestarts
[16:11:58.756]                           grepl <- base::grepl
[16:11:58.756]                           restarts <- computeRestarts(cond)
[16:11:58.756]                           for (restart in restarts) {
[16:11:58.756]                             name <- restart$name
[16:11:58.756]                             if (is.null(name)) 
[16:11:58.756]                               next
[16:11:58.756]                             if (!grepl(pattern, name)) 
[16:11:58.756]                               next
[16:11:58.756]                             invokeRestart(restart)
[16:11:58.756]                             muffled <- TRUE
[16:11:58.756]                             break
[16:11:58.756]                           }
[16:11:58.756]                         }
[16:11:58.756]                       }
[16:11:58.756]                       invisible(muffled)
[16:11:58.756]                     }
[16:11:58.756]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.756]                   }
[16:11:58.756]                 }
[16:11:58.756]             }
[16:11:58.756]         }))
[16:11:58.756]     }, error = function(ex) {
[16:11:58.756]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.756]                 ...future.rng), started = ...future.startTime, 
[16:11:58.756]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.756]             version = "1.8"), class = "FutureResult")
[16:11:58.756]     }, finally = {
[16:11:58.756]         if (!identical(...future.workdir, getwd())) 
[16:11:58.756]             setwd(...future.workdir)
[16:11:58.756]         {
[16:11:58.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.756]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.756]             }
[16:11:58.756]             base::options(...future.oldOptions)
[16:11:58.756]             if (.Platform$OS.type == "windows") {
[16:11:58.756]                 old_names <- names(...future.oldEnvVars)
[16:11:58.756]                 envs <- base::Sys.getenv()
[16:11:58.756]                 names <- names(envs)
[16:11:58.756]                 common <- intersect(names, old_names)
[16:11:58.756]                 added <- setdiff(names, old_names)
[16:11:58.756]                 removed <- setdiff(old_names, names)
[16:11:58.756]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.756]                   envs[common]]
[16:11:58.756]                 NAMES <- toupper(changed)
[16:11:58.756]                 args <- list()
[16:11:58.756]                 for (kk in seq_along(NAMES)) {
[16:11:58.756]                   name <- changed[[kk]]
[16:11:58.756]                   NAME <- NAMES[[kk]]
[16:11:58.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.756]                     next
[16:11:58.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.756]                 }
[16:11:58.756]                 NAMES <- toupper(added)
[16:11:58.756]                 for (kk in seq_along(NAMES)) {
[16:11:58.756]                   name <- added[[kk]]
[16:11:58.756]                   NAME <- NAMES[[kk]]
[16:11:58.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.756]                     next
[16:11:58.756]                   args[[name]] <- ""
[16:11:58.756]                 }
[16:11:58.756]                 NAMES <- toupper(removed)
[16:11:58.756]                 for (kk in seq_along(NAMES)) {
[16:11:58.756]                   name <- removed[[kk]]
[16:11:58.756]                   NAME <- NAMES[[kk]]
[16:11:58.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.756]                     next
[16:11:58.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.756]                 }
[16:11:58.756]                 if (length(args) > 0) 
[16:11:58.756]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.756]             }
[16:11:58.756]             else {
[16:11:58.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.756]             }
[16:11:58.756]             {
[16:11:58.756]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.756]                   0L) {
[16:11:58.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.756]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.756]                   base::options(opts)
[16:11:58.756]                 }
[16:11:58.756]                 {
[16:11:58.756]                   {
[16:11:58.756]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:58.756]                     NULL
[16:11:58.756]                   }
[16:11:58.756]                   options(future.plan = NULL)
[16:11:58.756]                   if (is.na(NA_character_)) 
[16:11:58.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.756]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:58.756]                     envir = parent.frame()) 
[16:11:58.756]                   {
[16:11:58.756]                     default_workers <- missing(workers)
[16:11:58.756]                     if (is.function(workers)) 
[16:11:58.756]                       workers <- workers()
[16:11:58.756]                     workers <- structure(as.integer(workers), 
[16:11:58.756]                       class = class(workers))
[16:11:58.756]                     stop_if_not(is.finite(workers), workers >= 
[16:11:58.756]                       1L)
[16:11:58.756]                     if ((workers == 1L && !inherits(workers, 
[16:11:58.756]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:58.756]                       if (default_workers) 
[16:11:58.756]                         supportsMulticore(warn = TRUE)
[16:11:58.756]                       return(sequential(..., envir = envir))
[16:11:58.756]                     }
[16:11:58.756]                     oopts <- options(mc.cores = workers)
[16:11:58.756]                     on.exit(options(oopts))
[16:11:58.756]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:58.756]                       envir = envir)
[16:11:58.756]                     if (!future$lazy) 
[16:11:58.756]                       future <- run(future)
[16:11:58.756]                     invisible(future)
[16:11:58.756]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.756]                 }
[16:11:58.756]             }
[16:11:58.756]         }
[16:11:58.756]     })
[16:11:58.756]     if (TRUE) {
[16:11:58.756]         base::sink(type = "output", split = FALSE)
[16:11:58.756]         if (TRUE) {
[16:11:58.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.756]         }
[16:11:58.756]         else {
[16:11:58.756]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.756]         }
[16:11:58.756]         base::close(...future.stdout)
[16:11:58.756]         ...future.stdout <- NULL
[16:11:58.756]     }
[16:11:58.756]     ...future.result$conditions <- ...future.conditions
[16:11:58.756]     ...future.result$finished <- base::Sys.time()
[16:11:58.756]     ...future.result
[16:11:58.756] }
[16:11:58.759] assign_globals() ...
[16:11:58.759] List of 4
[16:11:58.759]  $ ii   : int 2
[16:11:58.759]  $ n    : int 4
[16:11:58.759]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[16:11:58.759]   ..- attr(*, "region")=List of 2
[16:11:58.759]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:11:58.759]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[16:11:58.759]   ..- attr(*, "tile")= int [1:2] 1 2
[16:11:58.759]  $ delay:function (counts)  
[16:11:58.759]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.759]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c92d958> 
[16:11:58.759]  - attr(*, "where")=List of 4
[16:11:58.759]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.759]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.759]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.759]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.759]  - attr(*, "resolved")= logi FALSE
[16:11:58.759]  - attr(*, "total_size")= num 14584
[16:11:58.759]  - attr(*, "already-done")= logi TRUE
[16:11:58.766] - copied ‘ii’ to environment
[16:11:58.766] - copied ‘n’ to environment
[16:11:58.766] - copied ‘C’ to environment
[16:11:58.766] - reassign environment for ‘delay’
[16:11:58.766] - copied ‘delay’ to environment
[16:11:58.766] assign_globals() ... done
[16:11:58.767] requestCore(): workers = 2
[16:11:58.769] MulticoreFuture started
[16:11:58.769] - Launch lazy future ... done
[16:11:58.769] run() for ‘MulticoreFuture’ ... done
[16:11:58.769] - run() ... done
[16:11:58.770] - resolved() ...
[16:11:58.770] plan(): Setting new future strategy stack:
[16:11:58.770] List of future strategies:
[16:11:58.770] 1. sequential:
[16:11:58.770]    - args: function (..., envir = parent.frame())
[16:11:58.770]    - tweaked: FALSE
[16:11:58.770]    - call: NULL
[16:11:58.771] plan(): nbrOfWorkers() = 1
[16:11:58.776] plan(): Setting new future strategy stack:
[16:11:58.776] List of future strategies:
[16:11:58.776] 1. multicore:
[16:11:58.776]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:58.776]    - tweaked: FALSE
[16:11:58.776]    - call: plan(strategy)
[16:11:58.780] - resolved: FALSE
[16:11:58.780] - resolved() ... done
[16:11:58.780] resolved() for ‘MulticoreFuture’ ... done
[16:11:58.781] resolved() for ‘Future’ ...
[16:11:58.781] - state: ‘created’
[16:11:58.781] - run: TRUE
[16:11:58.781] - run() ...
[16:11:58.781] run() for ‘Future’ ...
[16:11:58.781] - state: ‘created’
[16:11:58.781] plan(): nbrOfWorkers() = 2
[16:11:58.781] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:58.786] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:58.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:58.786]   - Field: ‘label’
[16:11:58.786]   - Field: ‘local’
[16:11:58.786]   - Field: ‘owner’
[16:11:58.787]   - Field: ‘envir’
[16:11:58.787]   - Field: ‘workers’
[16:11:58.787]   - Field: ‘packages’
[16:11:58.787]   - Field: ‘gc’
[16:11:58.787]   - Field: ‘job’
[16:11:58.787]   - Field: ‘conditions’
[16:11:58.788]   - Field: ‘expr’
[16:11:58.788]   - Field: ‘uuid’
[16:11:58.788]   - Field: ‘seed’
[16:11:58.788]   - Field: ‘version’
[16:11:58.788]   - Field: ‘result’
[16:11:58.788]   - Field: ‘asynchronous’
[16:11:58.789]   - Field: ‘calls’
[16:11:58.789]   - Field: ‘globals’
[16:11:58.789]   - Field: ‘stdout’
[16:11:58.789]   - Field: ‘earlySignal’
[16:11:58.789]   - Field: ‘lazy’
[16:11:58.789]   - Field: ‘state’
[16:11:58.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:58.790] - Launch lazy future ...
[16:11:58.790] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.790] Packages needed by future strategies (n = 0): <none>
[16:11:58.791] {
[16:11:58.791]     {
[16:11:58.791]         {
[16:11:58.791]             ...future.startTime <- base::Sys.time()
[16:11:58.791]             {
[16:11:58.791]                 {
[16:11:58.791]                   {
[16:11:58.791]                     {
[16:11:58.791]                       {
[16:11:58.791]                         base::local({
[16:11:58.791]                           has_future <- base::requireNamespace("future", 
[16:11:58.791]                             quietly = TRUE)
[16:11:58.791]                           if (has_future) {
[16:11:58.791]                             ns <- base::getNamespace("future")
[16:11:58.791]                             version <- ns[[".package"]][["version"]]
[16:11:58.791]                             if (is.null(version)) 
[16:11:58.791]                               version <- utils::packageVersion("future")
[16:11:58.791]                           }
[16:11:58.791]                           else {
[16:11:58.791]                             version <- NULL
[16:11:58.791]                           }
[16:11:58.791]                           if (!has_future || version < "1.8.0") {
[16:11:58.791]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.791]                               "", base::R.version$version.string), 
[16:11:58.791]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:58.791]                                 base::R.version$platform, 8 * 
[16:11:58.791]                                   base::.Machine$sizeof.pointer), 
[16:11:58.791]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.791]                                 "release", "version")], collapse = " "), 
[16:11:58.791]                               hostname = base::Sys.info()[["nodename"]])
[16:11:58.791]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.791]                               info)
[16:11:58.791]                             info <- base::paste(info, collapse = "; ")
[16:11:58.791]                             if (!has_future) {
[16:11:58.791]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.791]                                 info)
[16:11:58.791]                             }
[16:11:58.791]                             else {
[16:11:58.791]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.791]                                 info, version)
[16:11:58.791]                             }
[16:11:58.791]                             base::stop(msg)
[16:11:58.791]                           }
[16:11:58.791]                         })
[16:11:58.791]                       }
[16:11:58.791]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:58.791]                       base::options(mc.cores = 1L)
[16:11:58.791]                     }
[16:11:58.791]                     base::local({
[16:11:58.791]                       for (pkg in "future") {
[16:11:58.791]                         base::loadNamespace(pkg)
[16:11:58.791]                         base::library(pkg, character.only = TRUE)
[16:11:58.791]                       }
[16:11:58.791]                     })
[16:11:58.791]                   }
[16:11:58.791]                   options(future.plan = NULL)
[16:11:58.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.791]                 }
[16:11:58.791]                 ...future.workdir <- getwd()
[16:11:58.791]             }
[16:11:58.791]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.791]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.791]         }
[16:11:58.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.791]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.791]             base::names(...future.oldOptions))
[16:11:58.791]     }
[16:11:58.791]     if (FALSE) {
[16:11:58.791]     }
[16:11:58.791]     else {
[16:11:58.791]         if (TRUE) {
[16:11:58.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.791]                 open = "w")
[16:11:58.791]         }
[16:11:58.791]         else {
[16:11:58.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.791]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.791]         }
[16:11:58.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.791]             base::sink(type = "output", split = FALSE)
[16:11:58.791]             base::close(...future.stdout)
[16:11:58.791]         }, add = TRUE)
[16:11:58.791]     }
[16:11:58.791]     ...future.frame <- base::sys.nframe()
[16:11:58.791]     ...future.conditions <- base::list()
[16:11:58.791]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.791]     if (FALSE) {
[16:11:58.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.791]     }
[16:11:58.791]     ...future.result <- base::tryCatch({
[16:11:58.791]         base::withCallingHandlers({
[16:11:58.791]             ...future.value <- base::withVisible(base::local({
[16:11:58.791]                 withCallingHandlers({
[16:11:58.791]                   {
[16:11:58.791]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.791]                       ii, n), appendLF = FALSE)
[16:11:58.791]                     fit <- mandelbrot(C)
[16:11:58.791]                     delay(fit)
[16:11:58.791]                     message(" done")
[16:11:58.791]                     fit
[16:11:58.791]                   }
[16:11:58.791]                 }, immediateCondition = function(cond) {
[16:11:58.791]                   save_rds <- function (object, pathname, ...) 
[16:11:58.791]                   {
[16:11:58.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:58.791]                     if (file_test("-f", pathname_tmp)) {
[16:11:58.791]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:58.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.791]                         fi_tmp[["mtime"]])
[16:11:58.791]                     }
[16:11:58.791]                     tryCatch({
[16:11:58.791]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:58.791]                     }, error = function(ex) {
[16:11:58.791]                       msg <- conditionMessage(ex)
[16:11:58.791]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:58.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.791]                         fi_tmp[["mtime"]], msg)
[16:11:58.791]                       ex$message <- msg
[16:11:58.791]                       stop(ex)
[16:11:58.791]                     })
[16:11:58.791]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:58.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:58.791]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:58.791]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.791]                       fi <- file.info(pathname)
[16:11:58.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:58.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:58.791]                         fi[["size"]], fi[["mtime"]])
[16:11:58.791]                       stop(msg)
[16:11:58.791]                     }
[16:11:58.791]                     invisible(pathname)
[16:11:58.791]                   }
[16:11:58.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:58.791]                     rootPath = tempdir()) 
[16:11:58.791]                   {
[16:11:58.791]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:58.791]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:58.791]                       tmpdir = path, fileext = ".rds")
[16:11:58.791]                     save_rds(obj, file)
[16:11:58.791]                   }
[16:11:58.791]                   saveImmediateCondition(cond, path = "/tmp/RtmpUMxmgv/.future/immediateConditions")
[16:11:58.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.791]                   {
[16:11:58.791]                     inherits <- base::inherits
[16:11:58.791]                     invokeRestart <- base::invokeRestart
[16:11:58.791]                     is.null <- base::is.null
[16:11:58.791]                     muffled <- FALSE
[16:11:58.791]                     if (inherits(cond, "message")) {
[16:11:58.791]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:58.791]                       if (muffled) 
[16:11:58.791]                         invokeRestart("muffleMessage")
[16:11:58.791]                     }
[16:11:58.791]                     else if (inherits(cond, "warning")) {
[16:11:58.791]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:58.791]                       if (muffled) 
[16:11:58.791]                         invokeRestart("muffleWarning")
[16:11:58.791]                     }
[16:11:58.791]                     else if (inherits(cond, "condition")) {
[16:11:58.791]                       if (!is.null(pattern)) {
[16:11:58.791]                         computeRestarts <- base::computeRestarts
[16:11:58.791]                         grepl <- base::grepl
[16:11:58.791]                         restarts <- computeRestarts(cond)
[16:11:58.791]                         for (restart in restarts) {
[16:11:58.791]                           name <- restart$name
[16:11:58.791]                           if (is.null(name)) 
[16:11:58.791]                             next
[16:11:58.791]                           if (!grepl(pattern, name)) 
[16:11:58.791]                             next
[16:11:58.791]                           invokeRestart(restart)
[16:11:58.791]                           muffled <- TRUE
[16:11:58.791]                           break
[16:11:58.791]                         }
[16:11:58.791]                       }
[16:11:58.791]                     }
[16:11:58.791]                     invisible(muffled)
[16:11:58.791]                   }
[16:11:58.791]                   muffleCondition(cond)
[16:11:58.791]                 })
[16:11:58.791]             }))
[16:11:58.791]             future::FutureResult(value = ...future.value$value, 
[16:11:58.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.791]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.791]                     ...future.globalenv.names))
[16:11:58.791]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.791]         }, condition = base::local({
[16:11:58.791]             c <- base::c
[16:11:58.791]             inherits <- base::inherits
[16:11:58.791]             invokeRestart <- base::invokeRestart
[16:11:58.791]             length <- base::length
[16:11:58.791]             list <- base::list
[16:11:58.791]             seq.int <- base::seq.int
[16:11:58.791]             signalCondition <- base::signalCondition
[16:11:58.791]             sys.calls <- base::sys.calls
[16:11:58.791]             `[[` <- base::`[[`
[16:11:58.791]             `+` <- base::`+`
[16:11:58.791]             `<<-` <- base::`<<-`
[16:11:58.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.791]                   3L)]
[16:11:58.791]             }
[16:11:58.791]             function(cond) {
[16:11:58.791]                 is_error <- inherits(cond, "error")
[16:11:58.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.791]                   NULL)
[16:11:58.791]                 if (is_error) {
[16:11:58.791]                   sessionInformation <- function() {
[16:11:58.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.791]                       search = base::search(), system = base::Sys.info())
[16:11:58.791]                   }
[16:11:58.791]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.791]                     cond$call), session = sessionInformation(), 
[16:11:58.791]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.791]                   signalCondition(cond)
[16:11:58.791]                 }
[16:11:58.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.791]                 "immediateCondition"))) {
[16:11:58.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.791]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.791]                   if (TRUE && !signal) {
[16:11:58.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.791]                     {
[16:11:58.791]                       inherits <- base::inherits
[16:11:58.791]                       invokeRestart <- base::invokeRestart
[16:11:58.791]                       is.null <- base::is.null
[16:11:58.791]                       muffled <- FALSE
[16:11:58.791]                       if (inherits(cond, "message")) {
[16:11:58.791]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.791]                         if (muffled) 
[16:11:58.791]                           invokeRestart("muffleMessage")
[16:11:58.791]                       }
[16:11:58.791]                       else if (inherits(cond, "warning")) {
[16:11:58.791]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.791]                         if (muffled) 
[16:11:58.791]                           invokeRestart("muffleWarning")
[16:11:58.791]                       }
[16:11:58.791]                       else if (inherits(cond, "condition")) {
[16:11:58.791]                         if (!is.null(pattern)) {
[16:11:58.791]                           computeRestarts <- base::computeRestarts
[16:11:58.791]                           grepl <- base::grepl
[16:11:58.791]                           restarts <- computeRestarts(cond)
[16:11:58.791]                           for (restart in restarts) {
[16:11:58.791]                             name <- restart$name
[16:11:58.791]                             if (is.null(name)) 
[16:11:58.791]                               next
[16:11:58.791]                             if (!grepl(pattern, name)) 
[16:11:58.791]                               next
[16:11:58.791]                             invokeRestart(restart)
[16:11:58.791]                             muffled <- TRUE
[16:11:58.791]                             break
[16:11:58.791]                           }
[16:11:58.791]                         }
[16:11:58.791]                       }
[16:11:58.791]                       invisible(muffled)
[16:11:58.791]                     }
[16:11:58.791]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.791]                   }
[16:11:58.791]                 }
[16:11:58.791]                 else {
[16:11:58.791]                   if (TRUE) {
[16:11:58.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.791]                     {
[16:11:58.791]                       inherits <- base::inherits
[16:11:58.791]                       invokeRestart <- base::invokeRestart
[16:11:58.791]                       is.null <- base::is.null
[16:11:58.791]                       muffled <- FALSE
[16:11:58.791]                       if (inherits(cond, "message")) {
[16:11:58.791]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.791]                         if (muffled) 
[16:11:58.791]                           invokeRestart("muffleMessage")
[16:11:58.791]                       }
[16:11:58.791]                       else if (inherits(cond, "warning")) {
[16:11:58.791]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.791]                         if (muffled) 
[16:11:58.791]                           invokeRestart("muffleWarning")
[16:11:58.791]                       }
[16:11:58.791]                       else if (inherits(cond, "condition")) {
[16:11:58.791]                         if (!is.null(pattern)) {
[16:11:58.791]                           computeRestarts <- base::computeRestarts
[16:11:58.791]                           grepl <- base::grepl
[16:11:58.791]                           restarts <- computeRestarts(cond)
[16:11:58.791]                           for (restart in restarts) {
[16:11:58.791]                             name <- restart$name
[16:11:58.791]                             if (is.null(name)) 
[16:11:58.791]                               next
[16:11:58.791]                             if (!grepl(pattern, name)) 
[16:11:58.791]                               next
[16:11:58.791]                             invokeRestart(restart)
[16:11:58.791]                             muffled <- TRUE
[16:11:58.791]                             break
[16:11:58.791]                           }
[16:11:58.791]                         }
[16:11:58.791]                       }
[16:11:58.791]                       invisible(muffled)
[16:11:58.791]                     }
[16:11:58.791]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.791]                   }
[16:11:58.791]                 }
[16:11:58.791]             }
[16:11:58.791]         }))
[16:11:58.791]     }, error = function(ex) {
[16:11:58.791]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.791]                 ...future.rng), started = ...future.startTime, 
[16:11:58.791]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.791]             version = "1.8"), class = "FutureResult")
[16:11:58.791]     }, finally = {
[16:11:58.791]         if (!identical(...future.workdir, getwd())) 
[16:11:58.791]             setwd(...future.workdir)
[16:11:58.791]         {
[16:11:58.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.791]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.791]             }
[16:11:58.791]             base::options(...future.oldOptions)
[16:11:58.791]             if (.Platform$OS.type == "windows") {
[16:11:58.791]                 old_names <- names(...future.oldEnvVars)
[16:11:58.791]                 envs <- base::Sys.getenv()
[16:11:58.791]                 names <- names(envs)
[16:11:58.791]                 common <- intersect(names, old_names)
[16:11:58.791]                 added <- setdiff(names, old_names)
[16:11:58.791]                 removed <- setdiff(old_names, names)
[16:11:58.791]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.791]                   envs[common]]
[16:11:58.791]                 NAMES <- toupper(changed)
[16:11:58.791]                 args <- list()
[16:11:58.791]                 for (kk in seq_along(NAMES)) {
[16:11:58.791]                   name <- changed[[kk]]
[16:11:58.791]                   NAME <- NAMES[[kk]]
[16:11:58.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.791]                     next
[16:11:58.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.791]                 }
[16:11:58.791]                 NAMES <- toupper(added)
[16:11:58.791]                 for (kk in seq_along(NAMES)) {
[16:11:58.791]                   name <- added[[kk]]
[16:11:58.791]                   NAME <- NAMES[[kk]]
[16:11:58.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.791]                     next
[16:11:58.791]                   args[[name]] <- ""
[16:11:58.791]                 }
[16:11:58.791]                 NAMES <- toupper(removed)
[16:11:58.791]                 for (kk in seq_along(NAMES)) {
[16:11:58.791]                   name <- removed[[kk]]
[16:11:58.791]                   NAME <- NAMES[[kk]]
[16:11:58.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.791]                     next
[16:11:58.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.791]                 }
[16:11:58.791]                 if (length(args) > 0) 
[16:11:58.791]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.791]             }
[16:11:58.791]             else {
[16:11:58.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.791]             }
[16:11:58.791]             {
[16:11:58.791]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.791]                   0L) {
[16:11:58.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.791]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.791]                   base::options(opts)
[16:11:58.791]                 }
[16:11:58.791]                 {
[16:11:58.791]                   {
[16:11:58.791]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:58.791]                     NULL
[16:11:58.791]                   }
[16:11:58.791]                   options(future.plan = NULL)
[16:11:58.791]                   if (is.na(NA_character_)) 
[16:11:58.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.791]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:58.791]                     envir = parent.frame()) 
[16:11:58.791]                   {
[16:11:58.791]                     default_workers <- missing(workers)
[16:11:58.791]                     if (is.function(workers)) 
[16:11:58.791]                       workers <- workers()
[16:11:58.791]                     workers <- structure(as.integer(workers), 
[16:11:58.791]                       class = class(workers))
[16:11:58.791]                     stop_if_not(is.finite(workers), workers >= 
[16:11:58.791]                       1L)
[16:11:58.791]                     if ((workers == 1L && !inherits(workers, 
[16:11:58.791]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:58.791]                       if (default_workers) 
[16:11:58.791]                         supportsMulticore(warn = TRUE)
[16:11:58.791]                       return(sequential(..., envir = envir))
[16:11:58.791]                     }
[16:11:58.791]                     oopts <- options(mc.cores = workers)
[16:11:58.791]                     on.exit(options(oopts))
[16:11:58.791]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:58.791]                       envir = envir)
[16:11:58.791]                     if (!future$lazy) 
[16:11:58.791]                       future <- run(future)
[16:11:58.791]                     invisible(future)
[16:11:58.791]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.791]                 }
[16:11:58.791]             }
[16:11:58.791]         }
[16:11:58.791]     })
[16:11:58.791]     if (TRUE) {
[16:11:58.791]         base::sink(type = "output", split = FALSE)
[16:11:58.791]         if (TRUE) {
[16:11:58.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.791]         }
[16:11:58.791]         else {
[16:11:58.791]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.791]         }
[16:11:58.791]         base::close(...future.stdout)
[16:11:58.791]         ...future.stdout <- NULL
[16:11:58.791]     }
[16:11:58.791]     ...future.result$conditions <- ...future.conditions
[16:11:58.791]     ...future.result$finished <- base::Sys.time()
[16:11:58.791]     ...future.result
[16:11:58.791] }
[16:11:58.795] assign_globals() ...
[16:11:58.795] List of 4
[16:11:58.795]  $ ii   : int 3
[16:11:58.795]  $ n    : int 4
[16:11:58.795]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[16:11:58.795]   ..- attr(*, "region")=List of 2
[16:11:58.795]   .. ..$ xrange: num [1:2] -2.25 -0.781
[16:11:58.795]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:11:58.795]   ..- attr(*, "tile")= int [1:2] 2 1
[16:11:58.795]  $ delay:function (counts)  
[16:11:58.795]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.795]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c92d958> 
[16:11:58.795]  - attr(*, "where")=List of 4
[16:11:58.795]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.795]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.795]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.795]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.795]  - attr(*, "resolved")= logi FALSE
[16:11:58.795]  - attr(*, "total_size")= num 14584
[16:11:58.795]  - attr(*, "already-done")= logi TRUE
[16:11:58.805] - copied ‘ii’ to environment
[16:11:58.805] - copied ‘n’ to environment
[16:11:58.805] - copied ‘C’ to environment
[16:11:58.805] - reassign environment for ‘delay’
[16:11:58.806] - copied ‘delay’ to environment
[16:11:58.806] assign_globals() ... done
[16:11:58.806] requestCore(): workers = 2
[16:11:58.808] MulticoreFuture started
[16:11:58.809] - Launch lazy future ... done
[16:11:58.809] run() for ‘MulticoreFuture’ ... done
[16:11:58.809] - run() ... done
[16:11:58.809] - resolved() ...
[16:11:58.810] plan(): Setting new future strategy stack:
[16:11:58.810] List of future strategies:
[16:11:58.810] 1. sequential:
[16:11:58.810]    - args: function (..., envir = parent.frame())
[16:11:58.810]    - tweaked: FALSE
[16:11:58.810]    - call: NULL
[16:11:58.811] plan(): nbrOfWorkers() = 1
[16:11:58.815] plan(): Setting new future strategy stack:
[16:11:58.815] List of future strategies:
[16:11:58.815] 1. multicore:
[16:11:58.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:58.815]    - tweaked: FALSE
[16:11:58.815]    - call: plan(strategy)
[16:11:58.820] - resolved: FALSE
[16:11:58.820] - resolved() ... done
[16:11:58.820] resolved() for ‘MulticoreFuture’ ... done
[16:11:58.820] resolved() for ‘Future’ ...
[16:11:58.820] - state: ‘created’
[16:11:58.820] plan(): nbrOfWorkers() = 2
[16:11:58.821] - run: TRUE
[16:11:58.821] - run() ...
[16:11:58.821] run() for ‘Future’ ...
[16:11:58.821] - state: ‘created’
[16:11:58.821] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:58.827] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:58.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:58.827]   - Field: ‘label’
[16:11:58.827]   - Field: ‘local’
[16:11:58.827]   - Field: ‘owner’
[16:11:58.827]   - Field: ‘envir’
[16:11:58.828]   - Field: ‘workers’
[16:11:58.828]   - Field: ‘packages’
[16:11:58.828]   - Field: ‘gc’
[16:11:58.828]   - Field: ‘job’
[16:11:58.828]   - Field: ‘conditions’
[16:11:58.828]   - Field: ‘expr’
[16:11:58.828]   - Field: ‘uuid’
[16:11:58.829]   - Field: ‘seed’
[16:11:58.829]   - Field: ‘version’
[16:11:58.829]   - Field: ‘result’
[16:11:58.829]   - Field: ‘asynchronous’
[16:11:58.829]   - Field: ‘calls’
[16:11:58.829]   - Field: ‘globals’
[16:11:58.829]   - Field: ‘stdout’
[16:11:58.830]   - Field: ‘earlySignal’
[16:11:58.830]   - Field: ‘lazy’
[16:11:58.830]   - Field: ‘state’
[16:11:58.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:58.830] - Launch lazy future ...
[16:11:58.831] Packages needed by the future expression (n = 1): ‘future’
[16:11:58.831] Packages needed by future strategies (n = 0): <none>
[16:11:58.832] {
[16:11:58.832]     {
[16:11:58.832]         {
[16:11:58.832]             ...future.startTime <- base::Sys.time()
[16:11:58.832]             {
[16:11:58.832]                 {
[16:11:58.832]                   {
[16:11:58.832]                     {
[16:11:58.832]                       {
[16:11:58.832]                         base::local({
[16:11:58.832]                           has_future <- base::requireNamespace("future", 
[16:11:58.832]                             quietly = TRUE)
[16:11:58.832]                           if (has_future) {
[16:11:58.832]                             ns <- base::getNamespace("future")
[16:11:58.832]                             version <- ns[[".package"]][["version"]]
[16:11:58.832]                             if (is.null(version)) 
[16:11:58.832]                               version <- utils::packageVersion("future")
[16:11:58.832]                           }
[16:11:58.832]                           else {
[16:11:58.832]                             version <- NULL
[16:11:58.832]                           }
[16:11:58.832]                           if (!has_future || version < "1.8.0") {
[16:11:58.832]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:58.832]                               "", base::R.version$version.string), 
[16:11:58.832]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:58.832]                                 base::R.version$platform, 8 * 
[16:11:58.832]                                   base::.Machine$sizeof.pointer), 
[16:11:58.832]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:58.832]                                 "release", "version")], collapse = " "), 
[16:11:58.832]                               hostname = base::Sys.info()[["nodename"]])
[16:11:58.832]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:58.832]                               info)
[16:11:58.832]                             info <- base::paste(info, collapse = "; ")
[16:11:58.832]                             if (!has_future) {
[16:11:58.832]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:58.832]                                 info)
[16:11:58.832]                             }
[16:11:58.832]                             else {
[16:11:58.832]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:58.832]                                 info, version)
[16:11:58.832]                             }
[16:11:58.832]                             base::stop(msg)
[16:11:58.832]                           }
[16:11:58.832]                         })
[16:11:58.832]                       }
[16:11:58.832]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:58.832]                       base::options(mc.cores = 1L)
[16:11:58.832]                     }
[16:11:58.832]                     base::local({
[16:11:58.832]                       for (pkg in "future") {
[16:11:58.832]                         base::loadNamespace(pkg)
[16:11:58.832]                         base::library(pkg, character.only = TRUE)
[16:11:58.832]                       }
[16:11:58.832]                     })
[16:11:58.832]                   }
[16:11:58.832]                   options(future.plan = NULL)
[16:11:58.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:58.832]                 }
[16:11:58.832]                 ...future.workdir <- getwd()
[16:11:58.832]             }
[16:11:58.832]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:58.832]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:58.832]         }
[16:11:58.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:58.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:58.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:58.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:58.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:58.832]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:58.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:58.832]             base::names(...future.oldOptions))
[16:11:58.832]     }
[16:11:58.832]     if (FALSE) {
[16:11:58.832]     }
[16:11:58.832]     else {
[16:11:58.832]         if (TRUE) {
[16:11:58.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:58.832]                 open = "w")
[16:11:58.832]         }
[16:11:58.832]         else {
[16:11:58.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:58.832]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:58.832]         }
[16:11:58.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:58.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:58.832]             base::sink(type = "output", split = FALSE)
[16:11:58.832]             base::close(...future.stdout)
[16:11:58.832]         }, add = TRUE)
[16:11:58.832]     }
[16:11:58.832]     ...future.frame <- base::sys.nframe()
[16:11:58.832]     ...future.conditions <- base::list()
[16:11:58.832]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:58.832]     if (FALSE) {
[16:11:58.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:58.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:58.832]     }
[16:11:58.832]     ...future.result <- base::tryCatch({
[16:11:58.832]         base::withCallingHandlers({
[16:11:58.832]             ...future.value <- base::withVisible(base::local({
[16:11:58.832]                 withCallingHandlers({
[16:11:58.832]                   {
[16:11:58.832]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:58.832]                       ii, n), appendLF = FALSE)
[16:11:58.832]                     fit <- mandelbrot(C)
[16:11:58.832]                     delay(fit)
[16:11:58.832]                     message(" done")
[16:11:58.832]                     fit
[16:11:58.832]                   }
[16:11:58.832]                 }, immediateCondition = function(cond) {
[16:11:58.832]                   save_rds <- function (object, pathname, ...) 
[16:11:58.832]                   {
[16:11:58.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:58.832]                     if (file_test("-f", pathname_tmp)) {
[16:11:58.832]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:58.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.832]                         fi_tmp[["mtime"]])
[16:11:58.832]                     }
[16:11:58.832]                     tryCatch({
[16:11:58.832]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:58.832]                     }, error = function(ex) {
[16:11:58.832]                       msg <- conditionMessage(ex)
[16:11:58.832]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:58.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.832]                         fi_tmp[["mtime"]], msg)
[16:11:58.832]                       ex$message <- msg
[16:11:58.832]                       stop(ex)
[16:11:58.832]                     })
[16:11:58.832]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:58.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:58.832]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:58.832]                       fi_tmp <- file.info(pathname_tmp)
[16:11:58.832]                       fi <- file.info(pathname)
[16:11:58.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:58.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:58.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:58.832]                         fi[["size"]], fi[["mtime"]])
[16:11:58.832]                       stop(msg)
[16:11:58.832]                     }
[16:11:58.832]                     invisible(pathname)
[16:11:58.832]                   }
[16:11:58.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:58.832]                     rootPath = tempdir()) 
[16:11:58.832]                   {
[16:11:58.832]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:58.832]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:58.832]                       tmpdir = path, fileext = ".rds")
[16:11:58.832]                     save_rds(obj, file)
[16:11:58.832]                   }
[16:11:58.832]                   saveImmediateCondition(cond, path = "/tmp/RtmpUMxmgv/.future/immediateConditions")
[16:11:58.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.832]                   {
[16:11:58.832]                     inherits <- base::inherits
[16:11:58.832]                     invokeRestart <- base::invokeRestart
[16:11:58.832]                     is.null <- base::is.null
[16:11:58.832]                     muffled <- FALSE
[16:11:58.832]                     if (inherits(cond, "message")) {
[16:11:58.832]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:58.832]                       if (muffled) 
[16:11:58.832]                         invokeRestart("muffleMessage")
[16:11:58.832]                     }
[16:11:58.832]                     else if (inherits(cond, "warning")) {
[16:11:58.832]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:58.832]                       if (muffled) 
[16:11:58.832]                         invokeRestart("muffleWarning")
[16:11:58.832]                     }
[16:11:58.832]                     else if (inherits(cond, "condition")) {
[16:11:58.832]                       if (!is.null(pattern)) {
[16:11:58.832]                         computeRestarts <- base::computeRestarts
[16:11:58.832]                         grepl <- base::grepl
[16:11:58.832]                         restarts <- computeRestarts(cond)
[16:11:58.832]                         for (restart in restarts) {
[16:11:58.832]                           name <- restart$name
[16:11:58.832]                           if (is.null(name)) 
[16:11:58.832]                             next
[16:11:58.832]                           if (!grepl(pattern, name)) 
[16:11:58.832]                             next
[16:11:58.832]                           invokeRestart(restart)
[16:11:58.832]                           muffled <- TRUE
[16:11:58.832]                           break
[16:11:58.832]                         }
[16:11:58.832]                       }
[16:11:58.832]                     }
[16:11:58.832]                     invisible(muffled)
[16:11:58.832]                   }
[16:11:58.832]                   muffleCondition(cond)
[16:11:58.832]                 })
[16:11:58.832]             }))
[16:11:58.832]             future::FutureResult(value = ...future.value$value, 
[16:11:58.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.832]                   ...future.rng), globalenv = if (FALSE) 
[16:11:58.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:58.832]                     ...future.globalenv.names))
[16:11:58.832]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:58.832]         }, condition = base::local({
[16:11:58.832]             c <- base::c
[16:11:58.832]             inherits <- base::inherits
[16:11:58.832]             invokeRestart <- base::invokeRestart
[16:11:58.832]             length <- base::length
[16:11:58.832]             list <- base::list
[16:11:58.832]             seq.int <- base::seq.int
[16:11:58.832]             signalCondition <- base::signalCondition
[16:11:58.832]             sys.calls <- base::sys.calls
[16:11:58.832]             `[[` <- base::`[[`
[16:11:58.832]             `+` <- base::`+`
[16:11:58.832]             `<<-` <- base::`<<-`
[16:11:58.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:58.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:58.832]                   3L)]
[16:11:58.832]             }
[16:11:58.832]             function(cond) {
[16:11:58.832]                 is_error <- inherits(cond, "error")
[16:11:58.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:58.832]                   NULL)
[16:11:58.832]                 if (is_error) {
[16:11:58.832]                   sessionInformation <- function() {
[16:11:58.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:58.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:58.832]                       search = base::search(), system = base::Sys.info())
[16:11:58.832]                   }
[16:11:58.832]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:58.832]                     cond$call), session = sessionInformation(), 
[16:11:58.832]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:58.832]                   signalCondition(cond)
[16:11:58.832]                 }
[16:11:58.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:58.832]                 "immediateCondition"))) {
[16:11:58.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:58.832]                   ...future.conditions[[length(...future.conditions) + 
[16:11:58.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:58.832]                   if (TRUE && !signal) {
[16:11:58.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.832]                     {
[16:11:58.832]                       inherits <- base::inherits
[16:11:58.832]                       invokeRestart <- base::invokeRestart
[16:11:58.832]                       is.null <- base::is.null
[16:11:58.832]                       muffled <- FALSE
[16:11:58.832]                       if (inherits(cond, "message")) {
[16:11:58.832]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.832]                         if (muffled) 
[16:11:58.832]                           invokeRestart("muffleMessage")
[16:11:58.832]                       }
[16:11:58.832]                       else if (inherits(cond, "warning")) {
[16:11:58.832]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.832]                         if (muffled) 
[16:11:58.832]                           invokeRestart("muffleWarning")
[16:11:58.832]                       }
[16:11:58.832]                       else if (inherits(cond, "condition")) {
[16:11:58.832]                         if (!is.null(pattern)) {
[16:11:58.832]                           computeRestarts <- base::computeRestarts
[16:11:58.832]                           grepl <- base::grepl
[16:11:58.832]                           restarts <- computeRestarts(cond)
[16:11:58.832]                           for (restart in restarts) {
[16:11:58.832]                             name <- restart$name
[16:11:58.832]                             if (is.null(name)) 
[16:11:58.832]                               next
[16:11:58.832]                             if (!grepl(pattern, name)) 
[16:11:58.832]                               next
[16:11:58.832]                             invokeRestart(restart)
[16:11:58.832]                             muffled <- TRUE
[16:11:58.832]                             break
[16:11:58.832]                           }
[16:11:58.832]                         }
[16:11:58.832]                       }
[16:11:58.832]                       invisible(muffled)
[16:11:58.832]                     }
[16:11:58.832]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.832]                   }
[16:11:58.832]                 }
[16:11:58.832]                 else {
[16:11:58.832]                   if (TRUE) {
[16:11:58.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:58.832]                     {
[16:11:58.832]                       inherits <- base::inherits
[16:11:58.832]                       invokeRestart <- base::invokeRestart
[16:11:58.832]                       is.null <- base::is.null
[16:11:58.832]                       muffled <- FALSE
[16:11:58.832]                       if (inherits(cond, "message")) {
[16:11:58.832]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:58.832]                         if (muffled) 
[16:11:58.832]                           invokeRestart("muffleMessage")
[16:11:58.832]                       }
[16:11:58.832]                       else if (inherits(cond, "warning")) {
[16:11:58.832]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:58.832]                         if (muffled) 
[16:11:58.832]                           invokeRestart("muffleWarning")
[16:11:58.832]                       }
[16:11:58.832]                       else if (inherits(cond, "condition")) {
[16:11:58.832]                         if (!is.null(pattern)) {
[16:11:58.832]                           computeRestarts <- base::computeRestarts
[16:11:58.832]                           grepl <- base::grepl
[16:11:58.832]                           restarts <- computeRestarts(cond)
[16:11:58.832]                           for (restart in restarts) {
[16:11:58.832]                             name <- restart$name
[16:11:58.832]                             if (is.null(name)) 
[16:11:58.832]                               next
[16:11:58.832]                             if (!grepl(pattern, name)) 
[16:11:58.832]                               next
[16:11:58.832]                             invokeRestart(restart)
[16:11:58.832]                             muffled <- TRUE
[16:11:58.832]                             break
[16:11:58.832]                           }
[16:11:58.832]                         }
[16:11:58.832]                       }
[16:11:58.832]                       invisible(muffled)
[16:11:58.832]                     }
[16:11:58.832]                     muffleCondition(cond, pattern = "^muffle")
[16:11:58.832]                   }
[16:11:58.832]                 }
[16:11:58.832]             }
[16:11:58.832]         }))
[16:11:58.832]     }, error = function(ex) {
[16:11:58.832]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:58.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:58.832]                 ...future.rng), started = ...future.startTime, 
[16:11:58.832]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:58.832]             version = "1.8"), class = "FutureResult")
[16:11:58.832]     }, finally = {
[16:11:58.832]         if (!identical(...future.workdir, getwd())) 
[16:11:58.832]             setwd(...future.workdir)
[16:11:58.832]         {
[16:11:58.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:58.832]                 ...future.oldOptions$nwarnings <- NULL
[16:11:58.832]             }
[16:11:58.832]             base::options(...future.oldOptions)
[16:11:58.832]             if (.Platform$OS.type == "windows") {
[16:11:58.832]                 old_names <- names(...future.oldEnvVars)
[16:11:58.832]                 envs <- base::Sys.getenv()
[16:11:58.832]                 names <- names(envs)
[16:11:58.832]                 common <- intersect(names, old_names)
[16:11:58.832]                 added <- setdiff(names, old_names)
[16:11:58.832]                 removed <- setdiff(old_names, names)
[16:11:58.832]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:58.832]                   envs[common]]
[16:11:58.832]                 NAMES <- toupper(changed)
[16:11:58.832]                 args <- list()
[16:11:58.832]                 for (kk in seq_along(NAMES)) {
[16:11:58.832]                   name <- changed[[kk]]
[16:11:58.832]                   NAME <- NAMES[[kk]]
[16:11:58.832]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.832]                     next
[16:11:58.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.832]                 }
[16:11:58.832]                 NAMES <- toupper(added)
[16:11:58.832]                 for (kk in seq_along(NAMES)) {
[16:11:58.832]                   name <- added[[kk]]
[16:11:58.832]                   NAME <- NAMES[[kk]]
[16:11:58.832]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.832]                     next
[16:11:58.832]                   args[[name]] <- ""
[16:11:58.832]                 }
[16:11:58.832]                 NAMES <- toupper(removed)
[16:11:58.832]                 for (kk in seq_along(NAMES)) {
[16:11:58.832]                   name <- removed[[kk]]
[16:11:58.832]                   NAME <- NAMES[[kk]]
[16:11:58.832]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:58.832]                     next
[16:11:58.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:58.832]                 }
[16:11:58.832]                 if (length(args) > 0) 
[16:11:58.832]                   base::do.call(base::Sys.setenv, args = args)
[16:11:58.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:58.832]             }
[16:11:58.832]             else {
[16:11:58.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:58.832]             }
[16:11:58.832]             {
[16:11:58.832]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:58.832]                   0L) {
[16:11:58.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:58.832]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:58.832]                   base::options(opts)
[16:11:58.832]                 }
[16:11:58.832]                 {
[16:11:58.832]                   {
[16:11:58.832]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:58.832]                     NULL
[16:11:58.832]                   }
[16:11:58.832]                   options(future.plan = NULL)
[16:11:58.832]                   if (is.na(NA_character_)) 
[16:11:58.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:58.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:58.832]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:58.832]                     envir = parent.frame()) 
[16:11:58.832]                   {
[16:11:58.832]                     default_workers <- missing(workers)
[16:11:58.832]                     if (is.function(workers)) 
[16:11:58.832]                       workers <- workers()
[16:11:58.832]                     workers <- structure(as.integer(workers), 
[16:11:58.832]                       class = class(workers))
[16:11:58.832]                     stop_if_not(is.finite(workers), workers >= 
[16:11:58.832]                       1L)
[16:11:58.832]                     if ((workers == 1L && !inherits(workers, 
[16:11:58.832]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:58.832]                       if (default_workers) 
[16:11:58.832]                         supportsMulticore(warn = TRUE)
[16:11:58.832]                       return(sequential(..., envir = envir))
[16:11:58.832]                     }
[16:11:58.832]                     oopts <- options(mc.cores = workers)
[16:11:58.832]                     on.exit(options(oopts))
[16:11:58.832]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:58.832]                       envir = envir)
[16:11:58.832]                     if (!future$lazy) 
[16:11:58.832]                       future <- run(future)
[16:11:58.832]                     invisible(future)
[16:11:58.832]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:58.832]                 }
[16:11:58.832]             }
[16:11:58.832]         }
[16:11:58.832]     })
[16:11:58.832]     if (TRUE) {
[16:11:58.832]         base::sink(type = "output", split = FALSE)
[16:11:58.832]         if (TRUE) {
[16:11:58.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:58.832]         }
[16:11:58.832]         else {
[16:11:58.832]             ...future.result["stdout"] <- base::list(NULL)
[16:11:58.832]         }
[16:11:58.832]         base::close(...future.stdout)
[16:11:58.832]         ...future.stdout <- NULL
[16:11:58.832]     }
[16:11:58.832]     ...future.result$conditions <- ...future.conditions
[16:11:58.832]     ...future.result$finished <- base::Sys.time()
[16:11:58.832]     ...future.result
[16:11:58.832] }
[16:11:58.835] assign_globals() ...
[16:11:58.835] List of 4
[16:11:58.835]  $ ii   : int 4
[16:11:58.835]  $ n    : int 4
[16:11:58.835]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[16:11:58.835]   ..- attr(*, "region")=List of 2
[16:11:58.835]   .. ..$ xrange: num [1:2] -0.719 0.75
[16:11:58.835]   .. ..$ yrange: num [1:2] 0.0306 1.5
[16:11:58.835]   ..- attr(*, "tile")= int [1:2] 2 2
[16:11:58.835]  $ delay:function (counts)  
[16:11:58.835]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[16:11:58.835]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55693c92d958> 
[16:11:58.835]  - attr(*, "where")=List of 4
[16:11:58.835]   ..$ ii   :<environment: R_EmptyEnv> 
[16:11:58.835]   ..$ n    :<environment: R_EmptyEnv> 
[16:11:58.835]   ..$ C    :<environment: R_EmptyEnv> 
[16:11:58.835]   ..$ delay:<environment: R_EmptyEnv> 
[16:11:58.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:58.835]  - attr(*, "resolved")= logi FALSE
[16:11:58.835]  - attr(*, "total_size")= num 14584
[16:11:58.835]  - attr(*, "already-done")= logi TRUE
[16:11:58.844] - copied ‘ii’ to environment
[16:11:58.844] - copied ‘n’ to environment
[16:11:58.845] - copied ‘C’ to environment
[16:11:58.845] - reassign environment for ‘delay’
[16:11:58.845] - copied ‘delay’ to environment
[16:11:58.845] assign_globals() ... done
[16:11:58.845] requestCore(): workers = 2
[16:11:58.846] Poll #1 (0): usedCores() = 2, workers = 2
[16:11:58.857] signalConditions() ...
[16:11:58.857]  - include = ‘immediateCondition’
[16:11:58.857]  - exclude = 
[16:11:58.858]  - resignal = FALSE
[16:11:58.858]  - Number of conditions: 2
[16:11:58.858] signalConditions() ... done
[16:11:58.858] signalConditions() ...
[16:11:58.858]  - include = ‘immediateCondition’
[16:11:58.858]  - exclude = 
[16:11:58.858]  - resignal = FALSE
[16:11:58.858]  - Number of conditions: 2
[16:11:58.859] signalConditions() ... done
[16:11:58.861] MulticoreFuture started
[16:11:58.862] - Launch lazy future ... done
[16:11:58.862] run() for ‘MulticoreFuture’ ... done
[16:11:58.862] - run() ... done
[16:11:58.862] - resolved() ...
[16:11:58.863] plan(): Setting new future strategy stack:
[16:11:58.863] List of future strategies:
[16:11:58.863] 1. sequential:
[16:11:58.863]    - args: function (..., envir = parent.frame())
[16:11:58.863]    - tweaked: FALSE
[16:11:58.863]    - call: NULL
[16:11:58.864] plan(): nbrOfWorkers() = 1
[16:11:58.869] plan(): Setting new future strategy stack:
[16:11:58.869] List of future strategies:
[16:11:58.869] 1. multicore:
[16:11:58.869]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:58.869]    - tweaked: FALSE
[16:11:58.869]    - call: plan(strategy)
[16:11:58.873] - resolved: FALSE
[16:11:58.873] - resolved() ... done
[16:11:58.873] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[16:11:58.874] signalConditions() ...
[16:11:58.874]  - include = ‘immediateCondition’
[16:11:58.874]  - exclude = 
[16:11:58.874]  - resignal = FALSE
[16:11:58.874]  - Number of conditions: 2
[16:11:58.874] signalConditions() ... done
[16:11:58.874] plan(): nbrOfWorkers() = 2
[16:11:58.875] Future state: ‘finished’
[16:11:58.875] signalConditions() ...
[16:11:58.875]  - include = ‘condition’
[16:11:58.875]  - exclude = ‘immediateCondition’
[16:11:58.875]  - resignal = TRUE
[16:11:58.875]  - Number of conditions: 2
[16:11:58.875]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[16:11:58.876]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.876] signalConditions() ... done
Plotting tile #3 of 4 ...
[16:11:58.878] signalConditions() ...
[16:11:58.879]  - include = ‘immediateCondition’
[16:11:58.879]  - exclude = 
[16:11:58.879]  - resignal = FALSE
[16:11:58.879]  - Number of conditions: 2
[16:11:58.879] signalConditions() ... done
[16:11:58.879] signalConditions() ...
[16:11:58.879]  - include = ‘immediateCondition’
[16:11:58.880]  - exclude = 
[16:11:58.880]  - resignal = FALSE
[16:11:58.880]  - Number of conditions: 2
[16:11:58.880] signalConditions() ... done
[16:11:58.880] Future state: ‘finished’
[16:11:58.880] signalConditions() ...
[16:11:58.880]  - include = ‘condition’
[16:11:58.881]  - exclude = ‘immediateCondition’
[16:11:58.881]  - resignal = TRUE
[16:11:58.881]  - Number of conditions: 2
[16:11:58.881]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[16:11:58.881]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.881] signalConditions() ... done
Plotting tile #4 of 4 ...
[16:11:58.883] signalConditions() ...
[16:11:58.883]  - include = ‘immediateCondition’
[16:11:58.883]  - exclude = 
[16:11:58.884]  - resignal = FALSE
[16:11:58.884]  - Number of conditions: 2
[16:11:58.884] signalConditions() ... done
[16:11:58.884] signalConditions() ...
[16:11:58.884]  - include = ‘immediateCondition’
[16:11:58.884]  - exclude = 
[16:11:58.884]  - resignal = FALSE
[16:11:58.885]  - Number of conditions: 2
[16:11:58.885] signalConditions() ... done
[16:11:58.885] Future state: ‘finished’
[16:11:58.885] signalConditions() ...
[16:11:58.885]  - include = ‘condition’
[16:11:58.885]  - exclude = ‘immediateCondition’
[16:11:58.885]  - resignal = TRUE
[16:11:58.885]  - Number of conditions: 2
[16:11:58.885]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[16:11:58.886]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:11:58.886] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[16:11:58.888] plan(): Setting new future strategy stack:
[16:11:58.888] List of future strategies:
[16:11:58.888] 1. multisession:
[16:11:58.888]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:58.888]    - tweaked: FALSE
[16:11:58.888]    - call: plan(strategy)
[16:11:58.888] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:11:58.889] multisession:
[16:11:58.889] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:58.889] - tweaked: FALSE
[16:11:58.889] - call: plan(strategy)
[16:11:58.895] getGlobalsAndPackages() ...
[16:11:58.895] Not searching for globals
[16:11:58.896] - globals: [0] <none>
[16:11:58.896] getGlobalsAndPackages() ... DONE
[16:11:58.897] [local output] makeClusterPSOCK() ...
[16:11:58.950] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:11:58.955] [local output] Base port: 11942
[16:11:58.956] [local output] Getting setup options for 2 cluster nodes ...
[16:11:58.956] [local output]  - Node 1 of 2 ...
[16:11:58.956] [local output] localMachine=TRUE => revtunnel=FALSE

[16:11:58.957] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpUMxmgv/worker.rank=1.parallelly.parent=81015.13c772c2b9ee8.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpUMxmgv/worker.rank=1.parallelly.parent=81015.13c772c2b9ee8.pid")'’
[16:11:59.143] - Possible to infer worker's PID: TRUE
[16:11:59.143] [local output] Rscript port: 11942

[16:11:59.144] [local output]  - Node 2 of 2 ...
[16:11:59.144] [local output] localMachine=TRUE => revtunnel=FALSE

[16:11:59.145] [local output] Rscript port: 11942

[16:11:59.145] [local output] Getting setup options for 2 cluster nodes ... done
[16:11:59.145] [local output]  - Parallel setup requested for some PSOCK nodes
[16:11:59.146] [local output] Setting up PSOCK nodes in parallel
[16:11:59.146] List of 36
[16:11:59.146]  $ worker          : chr "localhost"
[16:11:59.146]   ..- attr(*, "localhost")= logi TRUE
[16:11:59.146]  $ master          : chr "localhost"
[16:11:59.146]  $ port            : int 11942
[16:11:59.146]  $ connectTimeout  : num 120
[16:11:59.146]  $ timeout         : num 2592000
[16:11:59.146]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:11:59.146]  $ homogeneous     : logi TRUE
[16:11:59.146]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:11:59.146]  $ rscript_envs    : NULL
[16:11:59.146]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:11:59.146]  $ rscript_startup : NULL
[16:11:59.146]  $ rscript_sh      : chr "sh"
[16:11:59.146]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:11:59.146]  $ methods         : logi TRUE
[16:11:59.146]  $ socketOptions   : chr "no-delay"
[16:11:59.146]  $ useXDR          : logi FALSE
[16:11:59.146]  $ outfile         : chr "/dev/null"
[16:11:59.146]  $ renice          : int NA
[16:11:59.146]  $ rshcmd          : NULL
[16:11:59.146]  $ user            : chr(0) 
[16:11:59.146]  $ revtunnel       : logi FALSE
[16:11:59.146]  $ rshlogfile      : NULL
[16:11:59.146]  $ rshopts         : chr(0) 
[16:11:59.146]  $ rank            : int 1
[16:11:59.146]  $ manual          : logi FALSE
[16:11:59.146]  $ dryrun          : logi FALSE
[16:11:59.146]  $ quiet           : logi FALSE
[16:11:59.146]  $ setup_strategy  : chr "parallel"
[16:11:59.146]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:11:59.146]  $ pidfile         : chr "/tmp/RtmpUMxmgv/worker.rank=1.parallelly.parent=81015.13c772c2b9ee8.pid"
[16:11:59.146]  $ rshcmd_label    : NULL
[16:11:59.146]  $ rsh_call        : NULL
[16:11:59.146]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:11:59.146]  $ localMachine    : logi TRUE
[16:11:59.146]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:11:59.146]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:11:59.146]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:11:59.146]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:11:59.146]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:11:59.146]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:11:59.146]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:11:59.146]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:11:59.146]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:11:59.146]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:11:59.146]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:11:59.146]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:11:59.146]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:11:59.146]  $ arguments       :List of 28
[16:11:59.146]   ..$ worker          : chr "localhost"
[16:11:59.146]   ..$ master          : NULL
[16:11:59.146]   ..$ port            : int 11942
[16:11:59.146]   ..$ connectTimeout  : num 120
[16:11:59.146]   ..$ timeout         : num 2592000
[16:11:59.146]   ..$ rscript         : NULL
[16:11:59.146]   ..$ homogeneous     : NULL
[16:11:59.146]   ..$ rscript_args    : NULL
[16:11:59.146]   ..$ rscript_envs    : NULL
[16:11:59.146]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:11:59.146]   ..$ rscript_startup : NULL
[16:11:59.146]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:11:59.146]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:11:59.146]   ..$ methods         : logi TRUE
[16:11:59.146]   ..$ socketOptions   : chr "no-delay"
[16:11:59.146]   ..$ useXDR          : logi FALSE
[16:11:59.146]   ..$ outfile         : chr "/dev/null"
[16:11:59.146]   ..$ renice          : int NA
[16:11:59.146]   ..$ rshcmd          : NULL
[16:11:59.146]   ..$ user            : NULL
[16:11:59.146]   ..$ revtunnel       : logi NA
[16:11:59.146]   ..$ rshlogfile      : NULL
[16:11:59.146]   ..$ rshopts         : NULL
[16:11:59.146]   ..$ rank            : int 1
[16:11:59.146]   ..$ manual          : logi FALSE
[16:11:59.146]   ..$ dryrun          : logi FALSE
[16:11:59.146]   ..$ quiet           : logi FALSE
[16:11:59.146]   ..$ setup_strategy  : chr "parallel"
[16:11:59.146]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:11:59.163] [local output] System call to launch all workers:
[16:11:59.163] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpUMxmgv/worker.rank=1.parallelly.parent=81015.13c772c2b9ee8.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11942 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:11:59.163] [local output] Starting PSOCK main server
[16:11:59.164] [local output] Workers launched
[16:11:59.164] [local output] Waiting for workers to connect back
[16:11:59.165]  - [local output] 0 workers out of 2 ready
[16:11:59.427]  - [local output] 0 workers out of 2 ready
[16:11:59.427]  - [local output] 1 workers out of 2 ready
[16:11:59.429]  - [local output] 1 workers out of 2 ready
[16:11:59.430]  - [local output] 2 workers out of 2 ready
[16:11:59.430] [local output] Launching of workers completed
[16:11:59.430] [local output] Collecting session information from workers
[16:11:59.431] [local output]  - Worker #1 of 2
[16:11:59.431] [local output]  - Worker #2 of 2
[16:11:59.431] [local output] makeClusterPSOCK() ... done
[16:11:59.443] Packages needed by the future expression (n = 0): <none>
[16:11:59.443] Packages needed by future strategies (n = 0): <none>
[16:11:59.443] {
[16:11:59.443]     {
[16:11:59.443]         {
[16:11:59.443]             ...future.startTime <- base::Sys.time()
[16:11:59.443]             {
[16:11:59.443]                 {
[16:11:59.443]                   {
[16:11:59.443]                     {
[16:11:59.443]                       base::local({
[16:11:59.443]                         has_future <- base::requireNamespace("future", 
[16:11:59.443]                           quietly = TRUE)
[16:11:59.443]                         if (has_future) {
[16:11:59.443]                           ns <- base::getNamespace("future")
[16:11:59.443]                           version <- ns[[".package"]][["version"]]
[16:11:59.443]                           if (is.null(version)) 
[16:11:59.443]                             version <- utils::packageVersion("future")
[16:11:59.443]                         }
[16:11:59.443]                         else {
[16:11:59.443]                           version <- NULL
[16:11:59.443]                         }
[16:11:59.443]                         if (!has_future || version < "1.8.0") {
[16:11:59.443]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:59.443]                             "", base::R.version$version.string), 
[16:11:59.443]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:59.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:59.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:59.443]                               "release", "version")], collapse = " "), 
[16:11:59.443]                             hostname = base::Sys.info()[["nodename"]])
[16:11:59.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:59.443]                             info)
[16:11:59.443]                           info <- base::paste(info, collapse = "; ")
[16:11:59.443]                           if (!has_future) {
[16:11:59.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:59.443]                               info)
[16:11:59.443]                           }
[16:11:59.443]                           else {
[16:11:59.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:59.443]                               info, version)
[16:11:59.443]                           }
[16:11:59.443]                           base::stop(msg)
[16:11:59.443]                         }
[16:11:59.443]                       })
[16:11:59.443]                     }
[16:11:59.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:59.443]                     base::options(mc.cores = 1L)
[16:11:59.443]                   }
[16:11:59.443]                   options(future.plan = NULL)
[16:11:59.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:59.443]                 }
[16:11:59.443]                 ...future.workdir <- getwd()
[16:11:59.443]             }
[16:11:59.443]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:59.443]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:59.443]         }
[16:11:59.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:59.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:59.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:59.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:59.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:59.443]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:59.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:59.443]             base::names(...future.oldOptions))
[16:11:59.443]     }
[16:11:59.443]     if (FALSE) {
[16:11:59.443]     }
[16:11:59.443]     else {
[16:11:59.443]         if (TRUE) {
[16:11:59.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:59.443]                 open = "w")
[16:11:59.443]         }
[16:11:59.443]         else {
[16:11:59.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:59.443]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:59.443]         }
[16:11:59.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:59.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:59.443]             base::sink(type = "output", split = FALSE)
[16:11:59.443]             base::close(...future.stdout)
[16:11:59.443]         }, add = TRUE)
[16:11:59.443]     }
[16:11:59.443]     ...future.frame <- base::sys.nframe()
[16:11:59.443]     ...future.conditions <- base::list()
[16:11:59.443]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:59.443]     if (FALSE) {
[16:11:59.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:59.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:59.443]     }
[16:11:59.443]     ...future.result <- base::tryCatch({
[16:11:59.443]         base::withCallingHandlers({
[16:11:59.443]             ...future.value <- base::withVisible(base::local({
[16:11:59.443]                 ...future.makeSendCondition <- local({
[16:11:59.443]                   sendCondition <- NULL
[16:11:59.443]                   function(frame = 1L) {
[16:11:59.443]                     if (is.function(sendCondition)) 
[16:11:59.443]                       return(sendCondition)
[16:11:59.443]                     ns <- getNamespace("parallel")
[16:11:59.443]                     if (exists("sendData", mode = "function", 
[16:11:59.443]                       envir = ns)) {
[16:11:59.443]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:59.443]                         envir = ns)
[16:11:59.443]                       envir <- sys.frame(frame)
[16:11:59.443]                       master <- NULL
[16:11:59.443]                       while (!identical(envir, .GlobalEnv) && 
[16:11:59.443]                         !identical(envir, emptyenv())) {
[16:11:59.443]                         if (exists("master", mode = "list", envir = envir, 
[16:11:59.443]                           inherits = FALSE)) {
[16:11:59.443]                           master <- get("master", mode = "list", 
[16:11:59.443]                             envir = envir, inherits = FALSE)
[16:11:59.443]                           if (inherits(master, c("SOCKnode", 
[16:11:59.443]                             "SOCK0node"))) {
[16:11:59.443]                             sendCondition <<- function(cond) {
[16:11:59.443]                               data <- list(type = "VALUE", value = cond, 
[16:11:59.443]                                 success = TRUE)
[16:11:59.443]                               parallel_sendData(master, data)
[16:11:59.443]                             }
[16:11:59.443]                             return(sendCondition)
[16:11:59.443]                           }
[16:11:59.443]                         }
[16:11:59.443]                         frame <- frame + 1L
[16:11:59.443]                         envir <- sys.frame(frame)
[16:11:59.443]                       }
[16:11:59.443]                     }
[16:11:59.443]                     sendCondition <<- function(cond) NULL
[16:11:59.443]                   }
[16:11:59.443]                 })
[16:11:59.443]                 withCallingHandlers({
[16:11:59.443]                   NA
[16:11:59.443]                 }, immediateCondition = function(cond) {
[16:11:59.443]                   sendCondition <- ...future.makeSendCondition()
[16:11:59.443]                   sendCondition(cond)
[16:11:59.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.443]                   {
[16:11:59.443]                     inherits <- base::inherits
[16:11:59.443]                     invokeRestart <- base::invokeRestart
[16:11:59.443]                     is.null <- base::is.null
[16:11:59.443]                     muffled <- FALSE
[16:11:59.443]                     if (inherits(cond, "message")) {
[16:11:59.443]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:59.443]                       if (muffled) 
[16:11:59.443]                         invokeRestart("muffleMessage")
[16:11:59.443]                     }
[16:11:59.443]                     else if (inherits(cond, "warning")) {
[16:11:59.443]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:59.443]                       if (muffled) 
[16:11:59.443]                         invokeRestart("muffleWarning")
[16:11:59.443]                     }
[16:11:59.443]                     else if (inherits(cond, "condition")) {
[16:11:59.443]                       if (!is.null(pattern)) {
[16:11:59.443]                         computeRestarts <- base::computeRestarts
[16:11:59.443]                         grepl <- base::grepl
[16:11:59.443]                         restarts <- computeRestarts(cond)
[16:11:59.443]                         for (restart in restarts) {
[16:11:59.443]                           name <- restart$name
[16:11:59.443]                           if (is.null(name)) 
[16:11:59.443]                             next
[16:11:59.443]                           if (!grepl(pattern, name)) 
[16:11:59.443]                             next
[16:11:59.443]                           invokeRestart(restart)
[16:11:59.443]                           muffled <- TRUE
[16:11:59.443]                           break
[16:11:59.443]                         }
[16:11:59.443]                       }
[16:11:59.443]                     }
[16:11:59.443]                     invisible(muffled)
[16:11:59.443]                   }
[16:11:59.443]                   muffleCondition(cond)
[16:11:59.443]                 })
[16:11:59.443]             }))
[16:11:59.443]             future::FutureResult(value = ...future.value$value, 
[16:11:59.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.443]                   ...future.rng), globalenv = if (FALSE) 
[16:11:59.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:59.443]                     ...future.globalenv.names))
[16:11:59.443]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:59.443]         }, condition = base::local({
[16:11:59.443]             c <- base::c
[16:11:59.443]             inherits <- base::inherits
[16:11:59.443]             invokeRestart <- base::invokeRestart
[16:11:59.443]             length <- base::length
[16:11:59.443]             list <- base::list
[16:11:59.443]             seq.int <- base::seq.int
[16:11:59.443]             signalCondition <- base::signalCondition
[16:11:59.443]             sys.calls <- base::sys.calls
[16:11:59.443]             `[[` <- base::`[[`
[16:11:59.443]             `+` <- base::`+`
[16:11:59.443]             `<<-` <- base::`<<-`
[16:11:59.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:59.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:59.443]                   3L)]
[16:11:59.443]             }
[16:11:59.443]             function(cond) {
[16:11:59.443]                 is_error <- inherits(cond, "error")
[16:11:59.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:59.443]                   NULL)
[16:11:59.443]                 if (is_error) {
[16:11:59.443]                   sessionInformation <- function() {
[16:11:59.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:59.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:59.443]                       search = base::search(), system = base::Sys.info())
[16:11:59.443]                   }
[16:11:59.443]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:59.443]                     cond$call), session = sessionInformation(), 
[16:11:59.443]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:59.443]                   signalCondition(cond)
[16:11:59.443]                 }
[16:11:59.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:59.443]                 "immediateCondition"))) {
[16:11:59.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:59.443]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:59.443]                   if (TRUE && !signal) {
[16:11:59.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.443]                     {
[16:11:59.443]                       inherits <- base::inherits
[16:11:59.443]                       invokeRestart <- base::invokeRestart
[16:11:59.443]                       is.null <- base::is.null
[16:11:59.443]                       muffled <- FALSE
[16:11:59.443]                       if (inherits(cond, "message")) {
[16:11:59.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.443]                         if (muffled) 
[16:11:59.443]                           invokeRestart("muffleMessage")
[16:11:59.443]                       }
[16:11:59.443]                       else if (inherits(cond, "warning")) {
[16:11:59.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.443]                         if (muffled) 
[16:11:59.443]                           invokeRestart("muffleWarning")
[16:11:59.443]                       }
[16:11:59.443]                       else if (inherits(cond, "condition")) {
[16:11:59.443]                         if (!is.null(pattern)) {
[16:11:59.443]                           computeRestarts <- base::computeRestarts
[16:11:59.443]                           grepl <- base::grepl
[16:11:59.443]                           restarts <- computeRestarts(cond)
[16:11:59.443]                           for (restart in restarts) {
[16:11:59.443]                             name <- restart$name
[16:11:59.443]                             if (is.null(name)) 
[16:11:59.443]                               next
[16:11:59.443]                             if (!grepl(pattern, name)) 
[16:11:59.443]                               next
[16:11:59.443]                             invokeRestart(restart)
[16:11:59.443]                             muffled <- TRUE
[16:11:59.443]                             break
[16:11:59.443]                           }
[16:11:59.443]                         }
[16:11:59.443]                       }
[16:11:59.443]                       invisible(muffled)
[16:11:59.443]                     }
[16:11:59.443]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.443]                   }
[16:11:59.443]                 }
[16:11:59.443]                 else {
[16:11:59.443]                   if (TRUE) {
[16:11:59.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.443]                     {
[16:11:59.443]                       inherits <- base::inherits
[16:11:59.443]                       invokeRestart <- base::invokeRestart
[16:11:59.443]                       is.null <- base::is.null
[16:11:59.443]                       muffled <- FALSE
[16:11:59.443]                       if (inherits(cond, "message")) {
[16:11:59.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.443]                         if (muffled) 
[16:11:59.443]                           invokeRestart("muffleMessage")
[16:11:59.443]                       }
[16:11:59.443]                       else if (inherits(cond, "warning")) {
[16:11:59.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.443]                         if (muffled) 
[16:11:59.443]                           invokeRestart("muffleWarning")
[16:11:59.443]                       }
[16:11:59.443]                       else if (inherits(cond, "condition")) {
[16:11:59.443]                         if (!is.null(pattern)) {
[16:11:59.443]                           computeRestarts <- base::computeRestarts
[16:11:59.443]                           grepl <- base::grepl
[16:11:59.443]                           restarts <- computeRestarts(cond)
[16:11:59.443]                           for (restart in restarts) {
[16:11:59.443]                             name <- restart$name
[16:11:59.443]                             if (is.null(name)) 
[16:11:59.443]                               next
[16:11:59.443]                             if (!grepl(pattern, name)) 
[16:11:59.443]                               next
[16:11:59.443]                             invokeRestart(restart)
[16:11:59.443]                             muffled <- TRUE
[16:11:59.443]                             break
[16:11:59.443]                           }
[16:11:59.443]                         }
[16:11:59.443]                       }
[16:11:59.443]                       invisible(muffled)
[16:11:59.443]                     }
[16:11:59.443]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.443]                   }
[16:11:59.443]                 }
[16:11:59.443]             }
[16:11:59.443]         }))
[16:11:59.443]     }, error = function(ex) {
[16:11:59.443]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:59.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.443]                 ...future.rng), started = ...future.startTime, 
[16:11:59.443]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:59.443]             version = "1.8"), class = "FutureResult")
[16:11:59.443]     }, finally = {
[16:11:59.443]         if (!identical(...future.workdir, getwd())) 
[16:11:59.443]             setwd(...future.workdir)
[16:11:59.443]         {
[16:11:59.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:59.443]                 ...future.oldOptions$nwarnings <- NULL
[16:11:59.443]             }
[16:11:59.443]             base::options(...future.oldOptions)
[16:11:59.443]             if (.Platform$OS.type == "windows") {
[16:11:59.443]                 old_names <- names(...future.oldEnvVars)
[16:11:59.443]                 envs <- base::Sys.getenv()
[16:11:59.443]                 names <- names(envs)
[16:11:59.443]                 common <- intersect(names, old_names)
[16:11:59.443]                 added <- setdiff(names, old_names)
[16:11:59.443]                 removed <- setdiff(old_names, names)
[16:11:59.443]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:59.443]                   envs[common]]
[16:11:59.443]                 NAMES <- toupper(changed)
[16:11:59.443]                 args <- list()
[16:11:59.443]                 for (kk in seq_along(NAMES)) {
[16:11:59.443]                   name <- changed[[kk]]
[16:11:59.443]                   NAME <- NAMES[[kk]]
[16:11:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.443]                     next
[16:11:59.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.443]                 }
[16:11:59.443]                 NAMES <- toupper(added)
[16:11:59.443]                 for (kk in seq_along(NAMES)) {
[16:11:59.443]                   name <- added[[kk]]
[16:11:59.443]                   NAME <- NAMES[[kk]]
[16:11:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.443]                     next
[16:11:59.443]                   args[[name]] <- ""
[16:11:59.443]                 }
[16:11:59.443]                 NAMES <- toupper(removed)
[16:11:59.443]                 for (kk in seq_along(NAMES)) {
[16:11:59.443]                   name <- removed[[kk]]
[16:11:59.443]                   NAME <- NAMES[[kk]]
[16:11:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.443]                     next
[16:11:59.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.443]                 }
[16:11:59.443]                 if (length(args) > 0) 
[16:11:59.443]                   base::do.call(base::Sys.setenv, args = args)
[16:11:59.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:59.443]             }
[16:11:59.443]             else {
[16:11:59.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:59.443]             }
[16:11:59.443]             {
[16:11:59.443]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:59.443]                   0L) {
[16:11:59.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:59.443]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:59.443]                   base::options(opts)
[16:11:59.443]                 }
[16:11:59.443]                 {
[16:11:59.443]                   {
[16:11:59.443]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:59.443]                     NULL
[16:11:59.443]                   }
[16:11:59.443]                   options(future.plan = NULL)
[16:11:59.443]                   if (is.na(NA_character_)) 
[16:11:59.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:59.443]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:59.443]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:59.443]                     envir = parent.frame()) 
[16:11:59.443]                   {
[16:11:59.443]                     if (is.function(workers)) 
[16:11:59.443]                       workers <- workers()
[16:11:59.443]                     workers <- structure(as.integer(workers), 
[16:11:59.443]                       class = class(workers))
[16:11:59.443]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:59.443]                       workers >= 1)
[16:11:59.443]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:59.443]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:59.443]                     }
[16:11:59.443]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:59.443]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:59.443]                       envir = envir)
[16:11:59.443]                     if (!future$lazy) 
[16:11:59.443]                       future <- run(future)
[16:11:59.443]                     invisible(future)
[16:11:59.443]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:59.443]                 }
[16:11:59.443]             }
[16:11:59.443]         }
[16:11:59.443]     })
[16:11:59.443]     if (TRUE) {
[16:11:59.443]         base::sink(type = "output", split = FALSE)
[16:11:59.443]         if (TRUE) {
[16:11:59.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:59.443]         }
[16:11:59.443]         else {
[16:11:59.443]             ...future.result["stdout"] <- base::list(NULL)
[16:11:59.443]         }
[16:11:59.443]         base::close(...future.stdout)
[16:11:59.443]         ...future.stdout <- NULL
[16:11:59.443]     }
[16:11:59.443]     ...future.result$conditions <- ...future.conditions
[16:11:59.443]     ...future.result$finished <- base::Sys.time()
[16:11:59.443]     ...future.result
[16:11:59.443] }
[16:11:59.514] MultisessionFuture started
[16:11:59.514] result() for ClusterFuture ...
[16:11:59.514] receiveMessageFromWorker() for ClusterFuture ...
[16:11:59.515] - Validating connection of MultisessionFuture
[16:11:59.546] - received message: FutureResult
[16:11:59.546] - Received FutureResult
[16:11:59.547] - Erased future from FutureRegistry
[16:11:59.547] result() for ClusterFuture ...
[16:11:59.547] - result already collected: FutureResult
[16:11:59.547] result() for ClusterFuture ... done
[16:11:59.547] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:59.547] result() for ClusterFuture ... done
[16:11:59.547] result() for ClusterFuture ...
[16:11:59.547] - result already collected: FutureResult
[16:11:59.547] result() for ClusterFuture ... done
[16:11:59.547] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:11:59.551] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[16:11:59.555] getGlobalsAndPackages() ...
[16:11:59.555] Searching for globals...
[16:11:59.558] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:59.558] Searching for globals ... DONE
[16:11:59.559] Resolving globals: FALSE
[16:11:59.559] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:59.559] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:59.560] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:59.560] - packages: [1] ‘future’
[16:11:59.560] getGlobalsAndPackages() ... DONE
 2[16:11:59.564] getGlobalsAndPackages() ...
[16:11:59.564] Searching for globals...
[16:11:59.567] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:59.567] Searching for globals ... DONE
[16:11:59.567] Resolving globals: FALSE
[16:11:59.568] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:59.568] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:59.569] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:59.569] - packages: [1] ‘future’
[16:11:59.569] getGlobalsAndPackages() ... DONE
 3[16:11:59.569] getGlobalsAndPackages() ...
[16:11:59.569] Searching for globals...
[16:11:59.572] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:59.573] Searching for globals ... DONE
[16:11:59.573] Resolving globals: FALSE
[16:11:59.573] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:59.574] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:59.574] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:59.574] - packages: [1] ‘future’
[16:11:59.574] getGlobalsAndPackages() ... DONE
 4[16:11:59.574] getGlobalsAndPackages() ...
[16:11:59.574] Searching for globals...
[16:11:59.577] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[16:11:59.578] Searching for globals ... DONE
[16:11:59.578] Resolving globals: FALSE
[16:11:59.578] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[16:11:59.579] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[16:11:59.579] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[16:11:59.579] - packages: [1] ‘future’
[16:11:59.579] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[16:11:59.590] resolved() for ‘Future’ ...
[16:11:59.590] - state: ‘created’
[16:11:59.590] - run: TRUE
[16:11:59.590] - run() ...
[16:11:59.590] run() for ‘Future’ ...
[16:11:59.590] - state: ‘created’
[16:11:59.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:59.605] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:59.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:59.605]   - Field: ‘node’
[16:11:59.605]   - Field: ‘label’
[16:11:59.605]   - Field: ‘local’
[16:11:59.605]   - Field: ‘owner’
[16:11:59.605]   - Field: ‘envir’
[16:11:59.605]   - Field: ‘workers’
[16:11:59.605]   - Field: ‘packages’
[16:11:59.606]   - Field: ‘gc’
[16:11:59.606]   - Field: ‘conditions’
[16:11:59.606]   - Field: ‘persistent’
[16:11:59.606]   - Field: ‘expr’
[16:11:59.606]   - Field: ‘uuid’
[16:11:59.606]   - Field: ‘seed’
[16:11:59.606]   - Field: ‘version’
[16:11:59.606]   - Field: ‘result’
[16:11:59.606]   - Field: ‘asynchronous’
[16:11:59.606]   - Field: ‘calls’
[16:11:59.606]   - Field: ‘globals’
[16:11:59.606]   - Field: ‘stdout’
[16:11:59.607]   - Field: ‘earlySignal’
[16:11:59.607]   - Field: ‘lazy’
[16:11:59.607]   - Field: ‘state’
[16:11:59.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:59.607] - Launch lazy future ...
[16:11:59.607] Packages needed by the future expression (n = 1): ‘future’
[16:11:59.607] Packages needed by future strategies (n = 0): <none>
[16:11:59.608] {
[16:11:59.608]     {
[16:11:59.608]         {
[16:11:59.608]             ...future.startTime <- base::Sys.time()
[16:11:59.608]             {
[16:11:59.608]                 {
[16:11:59.608]                   {
[16:11:59.608]                     {
[16:11:59.608]                       {
[16:11:59.608]                         base::local({
[16:11:59.608]                           has_future <- base::requireNamespace("future", 
[16:11:59.608]                             quietly = TRUE)
[16:11:59.608]                           if (has_future) {
[16:11:59.608]                             ns <- base::getNamespace("future")
[16:11:59.608]                             version <- ns[[".package"]][["version"]]
[16:11:59.608]                             if (is.null(version)) 
[16:11:59.608]                               version <- utils::packageVersion("future")
[16:11:59.608]                           }
[16:11:59.608]                           else {
[16:11:59.608]                             version <- NULL
[16:11:59.608]                           }
[16:11:59.608]                           if (!has_future || version < "1.8.0") {
[16:11:59.608]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:59.608]                               "", base::R.version$version.string), 
[16:11:59.608]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:59.608]                                 base::R.version$platform, 8 * 
[16:11:59.608]                                   base::.Machine$sizeof.pointer), 
[16:11:59.608]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:59.608]                                 "release", "version")], collapse = " "), 
[16:11:59.608]                               hostname = base::Sys.info()[["nodename"]])
[16:11:59.608]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:59.608]                               info)
[16:11:59.608]                             info <- base::paste(info, collapse = "; ")
[16:11:59.608]                             if (!has_future) {
[16:11:59.608]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:59.608]                                 info)
[16:11:59.608]                             }
[16:11:59.608]                             else {
[16:11:59.608]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:59.608]                                 info, version)
[16:11:59.608]                             }
[16:11:59.608]                             base::stop(msg)
[16:11:59.608]                           }
[16:11:59.608]                         })
[16:11:59.608]                       }
[16:11:59.608]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:59.608]                       base::options(mc.cores = 1L)
[16:11:59.608]                     }
[16:11:59.608]                     base::local({
[16:11:59.608]                       for (pkg in "future") {
[16:11:59.608]                         base::loadNamespace(pkg)
[16:11:59.608]                         base::library(pkg, character.only = TRUE)
[16:11:59.608]                       }
[16:11:59.608]                     })
[16:11:59.608]                   }
[16:11:59.608]                   options(future.plan = NULL)
[16:11:59.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:59.608]                 }
[16:11:59.608]                 ...future.workdir <- getwd()
[16:11:59.608]             }
[16:11:59.608]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:59.608]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:59.608]         }
[16:11:59.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:59.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:59.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:59.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:59.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:59.608]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:59.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:59.608]             base::names(...future.oldOptions))
[16:11:59.608]     }
[16:11:59.608]     if (FALSE) {
[16:11:59.608]     }
[16:11:59.608]     else {
[16:11:59.608]         if (TRUE) {
[16:11:59.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:59.608]                 open = "w")
[16:11:59.608]         }
[16:11:59.608]         else {
[16:11:59.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:59.608]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:59.608]         }
[16:11:59.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:59.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:59.608]             base::sink(type = "output", split = FALSE)
[16:11:59.608]             base::close(...future.stdout)
[16:11:59.608]         }, add = TRUE)
[16:11:59.608]     }
[16:11:59.608]     ...future.frame <- base::sys.nframe()
[16:11:59.608]     ...future.conditions <- base::list()
[16:11:59.608]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:59.608]     if (FALSE) {
[16:11:59.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:59.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:59.608]     }
[16:11:59.608]     ...future.result <- base::tryCatch({
[16:11:59.608]         base::withCallingHandlers({
[16:11:59.608]             ...future.value <- base::withVisible(base::local({
[16:11:59.608]                 ...future.makeSendCondition <- local({
[16:11:59.608]                   sendCondition <- NULL
[16:11:59.608]                   function(frame = 1L) {
[16:11:59.608]                     if (is.function(sendCondition)) 
[16:11:59.608]                       return(sendCondition)
[16:11:59.608]                     ns <- getNamespace("parallel")
[16:11:59.608]                     if (exists("sendData", mode = "function", 
[16:11:59.608]                       envir = ns)) {
[16:11:59.608]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:59.608]                         envir = ns)
[16:11:59.608]                       envir <- sys.frame(frame)
[16:11:59.608]                       master <- NULL
[16:11:59.608]                       while (!identical(envir, .GlobalEnv) && 
[16:11:59.608]                         !identical(envir, emptyenv())) {
[16:11:59.608]                         if (exists("master", mode = "list", envir = envir, 
[16:11:59.608]                           inherits = FALSE)) {
[16:11:59.608]                           master <- get("master", mode = "list", 
[16:11:59.608]                             envir = envir, inherits = FALSE)
[16:11:59.608]                           if (inherits(master, c("SOCKnode", 
[16:11:59.608]                             "SOCK0node"))) {
[16:11:59.608]                             sendCondition <<- function(cond) {
[16:11:59.608]                               data <- list(type = "VALUE", value = cond, 
[16:11:59.608]                                 success = TRUE)
[16:11:59.608]                               parallel_sendData(master, data)
[16:11:59.608]                             }
[16:11:59.608]                             return(sendCondition)
[16:11:59.608]                           }
[16:11:59.608]                         }
[16:11:59.608]                         frame <- frame + 1L
[16:11:59.608]                         envir <- sys.frame(frame)
[16:11:59.608]                       }
[16:11:59.608]                     }
[16:11:59.608]                     sendCondition <<- function(cond) NULL
[16:11:59.608]                   }
[16:11:59.608]                 })
[16:11:59.608]                 withCallingHandlers({
[16:11:59.608]                   {
[16:11:59.608]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:59.608]                       ii, n), appendLF = FALSE)
[16:11:59.608]                     fit <- mandelbrot(C)
[16:11:59.608]                     delay(fit)
[16:11:59.608]                     message(" done")
[16:11:59.608]                     fit
[16:11:59.608]                   }
[16:11:59.608]                 }, immediateCondition = function(cond) {
[16:11:59.608]                   sendCondition <- ...future.makeSendCondition()
[16:11:59.608]                   sendCondition(cond)
[16:11:59.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.608]                   {
[16:11:59.608]                     inherits <- base::inherits
[16:11:59.608]                     invokeRestart <- base::invokeRestart
[16:11:59.608]                     is.null <- base::is.null
[16:11:59.608]                     muffled <- FALSE
[16:11:59.608]                     if (inherits(cond, "message")) {
[16:11:59.608]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:59.608]                       if (muffled) 
[16:11:59.608]                         invokeRestart("muffleMessage")
[16:11:59.608]                     }
[16:11:59.608]                     else if (inherits(cond, "warning")) {
[16:11:59.608]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:59.608]                       if (muffled) 
[16:11:59.608]                         invokeRestart("muffleWarning")
[16:11:59.608]                     }
[16:11:59.608]                     else if (inherits(cond, "condition")) {
[16:11:59.608]                       if (!is.null(pattern)) {
[16:11:59.608]                         computeRestarts <- base::computeRestarts
[16:11:59.608]                         grepl <- base::grepl
[16:11:59.608]                         restarts <- computeRestarts(cond)
[16:11:59.608]                         for (restart in restarts) {
[16:11:59.608]                           name <- restart$name
[16:11:59.608]                           if (is.null(name)) 
[16:11:59.608]                             next
[16:11:59.608]                           if (!grepl(pattern, name)) 
[16:11:59.608]                             next
[16:11:59.608]                           invokeRestart(restart)
[16:11:59.608]                           muffled <- TRUE
[16:11:59.608]                           break
[16:11:59.608]                         }
[16:11:59.608]                       }
[16:11:59.608]                     }
[16:11:59.608]                     invisible(muffled)
[16:11:59.608]                   }
[16:11:59.608]                   muffleCondition(cond)
[16:11:59.608]                 })
[16:11:59.608]             }))
[16:11:59.608]             future::FutureResult(value = ...future.value$value, 
[16:11:59.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.608]                   ...future.rng), globalenv = if (FALSE) 
[16:11:59.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:59.608]                     ...future.globalenv.names))
[16:11:59.608]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:59.608]         }, condition = base::local({
[16:11:59.608]             c <- base::c
[16:11:59.608]             inherits <- base::inherits
[16:11:59.608]             invokeRestart <- base::invokeRestart
[16:11:59.608]             length <- base::length
[16:11:59.608]             list <- base::list
[16:11:59.608]             seq.int <- base::seq.int
[16:11:59.608]             signalCondition <- base::signalCondition
[16:11:59.608]             sys.calls <- base::sys.calls
[16:11:59.608]             `[[` <- base::`[[`
[16:11:59.608]             `+` <- base::`+`
[16:11:59.608]             `<<-` <- base::`<<-`
[16:11:59.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:59.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:59.608]                   3L)]
[16:11:59.608]             }
[16:11:59.608]             function(cond) {
[16:11:59.608]                 is_error <- inherits(cond, "error")
[16:11:59.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:59.608]                   NULL)
[16:11:59.608]                 if (is_error) {
[16:11:59.608]                   sessionInformation <- function() {
[16:11:59.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:59.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:59.608]                       search = base::search(), system = base::Sys.info())
[16:11:59.608]                   }
[16:11:59.608]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:59.608]                     cond$call), session = sessionInformation(), 
[16:11:59.608]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:59.608]                   signalCondition(cond)
[16:11:59.608]                 }
[16:11:59.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:59.608]                 "immediateCondition"))) {
[16:11:59.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:59.608]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:59.608]                   if (TRUE && !signal) {
[16:11:59.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.608]                     {
[16:11:59.608]                       inherits <- base::inherits
[16:11:59.608]                       invokeRestart <- base::invokeRestart
[16:11:59.608]                       is.null <- base::is.null
[16:11:59.608]                       muffled <- FALSE
[16:11:59.608]                       if (inherits(cond, "message")) {
[16:11:59.608]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.608]                         if (muffled) 
[16:11:59.608]                           invokeRestart("muffleMessage")
[16:11:59.608]                       }
[16:11:59.608]                       else if (inherits(cond, "warning")) {
[16:11:59.608]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.608]                         if (muffled) 
[16:11:59.608]                           invokeRestart("muffleWarning")
[16:11:59.608]                       }
[16:11:59.608]                       else if (inherits(cond, "condition")) {
[16:11:59.608]                         if (!is.null(pattern)) {
[16:11:59.608]                           computeRestarts <- base::computeRestarts
[16:11:59.608]                           grepl <- base::grepl
[16:11:59.608]                           restarts <- computeRestarts(cond)
[16:11:59.608]                           for (restart in restarts) {
[16:11:59.608]                             name <- restart$name
[16:11:59.608]                             if (is.null(name)) 
[16:11:59.608]                               next
[16:11:59.608]                             if (!grepl(pattern, name)) 
[16:11:59.608]                               next
[16:11:59.608]                             invokeRestart(restart)
[16:11:59.608]                             muffled <- TRUE
[16:11:59.608]                             break
[16:11:59.608]                           }
[16:11:59.608]                         }
[16:11:59.608]                       }
[16:11:59.608]                       invisible(muffled)
[16:11:59.608]                     }
[16:11:59.608]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.608]                   }
[16:11:59.608]                 }
[16:11:59.608]                 else {
[16:11:59.608]                   if (TRUE) {
[16:11:59.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.608]                     {
[16:11:59.608]                       inherits <- base::inherits
[16:11:59.608]                       invokeRestart <- base::invokeRestart
[16:11:59.608]                       is.null <- base::is.null
[16:11:59.608]                       muffled <- FALSE
[16:11:59.608]                       if (inherits(cond, "message")) {
[16:11:59.608]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.608]                         if (muffled) 
[16:11:59.608]                           invokeRestart("muffleMessage")
[16:11:59.608]                       }
[16:11:59.608]                       else if (inherits(cond, "warning")) {
[16:11:59.608]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.608]                         if (muffled) 
[16:11:59.608]                           invokeRestart("muffleWarning")
[16:11:59.608]                       }
[16:11:59.608]                       else if (inherits(cond, "condition")) {
[16:11:59.608]                         if (!is.null(pattern)) {
[16:11:59.608]                           computeRestarts <- base::computeRestarts
[16:11:59.608]                           grepl <- base::grepl
[16:11:59.608]                           restarts <- computeRestarts(cond)
[16:11:59.608]                           for (restart in restarts) {
[16:11:59.608]                             name <- restart$name
[16:11:59.608]                             if (is.null(name)) 
[16:11:59.608]                               next
[16:11:59.608]                             if (!grepl(pattern, name)) 
[16:11:59.608]                               next
[16:11:59.608]                             invokeRestart(restart)
[16:11:59.608]                             muffled <- TRUE
[16:11:59.608]                             break
[16:11:59.608]                           }
[16:11:59.608]                         }
[16:11:59.608]                       }
[16:11:59.608]                       invisible(muffled)
[16:11:59.608]                     }
[16:11:59.608]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.608]                   }
[16:11:59.608]                 }
[16:11:59.608]             }
[16:11:59.608]         }))
[16:11:59.608]     }, error = function(ex) {
[16:11:59.608]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:59.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.608]                 ...future.rng), started = ...future.startTime, 
[16:11:59.608]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:59.608]             version = "1.8"), class = "FutureResult")
[16:11:59.608]     }, finally = {
[16:11:59.608]         if (!identical(...future.workdir, getwd())) 
[16:11:59.608]             setwd(...future.workdir)
[16:11:59.608]         {
[16:11:59.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:59.608]                 ...future.oldOptions$nwarnings <- NULL
[16:11:59.608]             }
[16:11:59.608]             base::options(...future.oldOptions)
[16:11:59.608]             if (.Platform$OS.type == "windows") {
[16:11:59.608]                 old_names <- names(...future.oldEnvVars)
[16:11:59.608]                 envs <- base::Sys.getenv()
[16:11:59.608]                 names <- names(envs)
[16:11:59.608]                 common <- intersect(names, old_names)
[16:11:59.608]                 added <- setdiff(names, old_names)
[16:11:59.608]                 removed <- setdiff(old_names, names)
[16:11:59.608]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:59.608]                   envs[common]]
[16:11:59.608]                 NAMES <- toupper(changed)
[16:11:59.608]                 args <- list()
[16:11:59.608]                 for (kk in seq_along(NAMES)) {
[16:11:59.608]                   name <- changed[[kk]]
[16:11:59.608]                   NAME <- NAMES[[kk]]
[16:11:59.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.608]                     next
[16:11:59.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.608]                 }
[16:11:59.608]                 NAMES <- toupper(added)
[16:11:59.608]                 for (kk in seq_along(NAMES)) {
[16:11:59.608]                   name <- added[[kk]]
[16:11:59.608]                   NAME <- NAMES[[kk]]
[16:11:59.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.608]                     next
[16:11:59.608]                   args[[name]] <- ""
[16:11:59.608]                 }
[16:11:59.608]                 NAMES <- toupper(removed)
[16:11:59.608]                 for (kk in seq_along(NAMES)) {
[16:11:59.608]                   name <- removed[[kk]]
[16:11:59.608]                   NAME <- NAMES[[kk]]
[16:11:59.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.608]                     next
[16:11:59.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.608]                 }
[16:11:59.608]                 if (length(args) > 0) 
[16:11:59.608]                   base::do.call(base::Sys.setenv, args = args)
[16:11:59.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:59.608]             }
[16:11:59.608]             else {
[16:11:59.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:59.608]             }
[16:11:59.608]             {
[16:11:59.608]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:59.608]                   0L) {
[16:11:59.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:59.608]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:59.608]                   base::options(opts)
[16:11:59.608]                 }
[16:11:59.608]                 {
[16:11:59.608]                   {
[16:11:59.608]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:59.608]                     NULL
[16:11:59.608]                   }
[16:11:59.608]                   options(future.plan = NULL)
[16:11:59.608]                   if (is.na(NA_character_)) 
[16:11:59.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:59.608]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:59.608]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:59.608]                     envir = parent.frame()) 
[16:11:59.608]                   {
[16:11:59.608]                     if (is.function(workers)) 
[16:11:59.608]                       workers <- workers()
[16:11:59.608]                     workers <- structure(as.integer(workers), 
[16:11:59.608]                       class = class(workers))
[16:11:59.608]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:59.608]                       workers >= 1)
[16:11:59.608]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:59.608]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:59.608]                     }
[16:11:59.608]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:59.608]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:59.608]                       envir = envir)
[16:11:59.608]                     if (!future$lazy) 
[16:11:59.608]                       future <- run(future)
[16:11:59.608]                     invisible(future)
[16:11:59.608]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:59.608]                 }
[16:11:59.608]             }
[16:11:59.608]         }
[16:11:59.608]     })
[16:11:59.608]     if (TRUE) {
[16:11:59.608]         base::sink(type = "output", split = FALSE)
[16:11:59.608]         if (TRUE) {
[16:11:59.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:59.608]         }
[16:11:59.608]         else {
[16:11:59.608]             ...future.result["stdout"] <- base::list(NULL)
[16:11:59.608]         }
[16:11:59.608]         base::close(...future.stdout)
[16:11:59.608]         ...future.stdout <- NULL
[16:11:59.608]     }
[16:11:59.608]     ...future.result$conditions <- ...future.conditions
[16:11:59.608]     ...future.result$finished <- base::Sys.time()
[16:11:59.608]     ...future.result
[16:11:59.608] }
[16:11:59.611] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[16:11:59.611] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:11:59.611] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:59.611] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[16:11:59.612] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[16:11:59.612] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[16:11:59.656] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[16:11:59.656] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[16:11:59.700] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[16:11:59.700] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[16:11:59.701] MultisessionFuture started
[16:11:59.701] - Launch lazy future ... done
[16:11:59.701] run() for ‘MultisessionFuture’ ... done
[16:11:59.701] - run() ... done
[16:11:59.701] - resolved() ...
[16:11:59.712] - resolved: FALSE
[16:11:59.712] - resolved() ... done
[16:11:59.712] resolved() for ‘MultisessionFuture’ ... done
[16:11:59.712] resolved() for ‘Future’ ...
[16:11:59.713] - state: ‘created’
[16:11:59.713] - run: TRUE
[16:11:59.713] - run() ...
[16:11:59.713] run() for ‘Future’ ...
[16:11:59.713] - state: ‘created’
[16:11:59.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:59.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:59.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:59.727]   - Field: ‘node’
[16:11:59.728]   - Field: ‘label’
[16:11:59.728]   - Field: ‘local’
[16:11:59.728]   - Field: ‘owner’
[16:11:59.728]   - Field: ‘envir’
[16:11:59.728]   - Field: ‘workers’
[16:11:59.728]   - Field: ‘packages’
[16:11:59.728]   - Field: ‘gc’
[16:11:59.728]   - Field: ‘conditions’
[16:11:59.728]   - Field: ‘persistent’
[16:11:59.728]   - Field: ‘expr’
[16:11:59.728]   - Field: ‘uuid’
[16:11:59.729]   - Field: ‘seed’
[16:11:59.729]   - Field: ‘version’
[16:11:59.729]   - Field: ‘result’
[16:11:59.729]   - Field: ‘asynchronous’
[16:11:59.729]   - Field: ‘calls’
[16:11:59.729]   - Field: ‘globals’
[16:11:59.729]   - Field: ‘stdout’
[16:11:59.729]   - Field: ‘earlySignal’
[16:11:59.729]   - Field: ‘lazy’
[16:11:59.729]   - Field: ‘state’
[16:11:59.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:59.730] - Launch lazy future ...
[16:11:59.730] Packages needed by the future expression (n = 1): ‘future’
[16:11:59.730] Packages needed by future strategies (n = 0): <none>
[16:11:59.730] {
[16:11:59.730]     {
[16:11:59.730]         {
[16:11:59.730]             ...future.startTime <- base::Sys.time()
[16:11:59.730]             {
[16:11:59.730]                 {
[16:11:59.730]                   {
[16:11:59.730]                     {
[16:11:59.730]                       {
[16:11:59.730]                         base::local({
[16:11:59.730]                           has_future <- base::requireNamespace("future", 
[16:11:59.730]                             quietly = TRUE)
[16:11:59.730]                           if (has_future) {
[16:11:59.730]                             ns <- base::getNamespace("future")
[16:11:59.730]                             version <- ns[[".package"]][["version"]]
[16:11:59.730]                             if (is.null(version)) 
[16:11:59.730]                               version <- utils::packageVersion("future")
[16:11:59.730]                           }
[16:11:59.730]                           else {
[16:11:59.730]                             version <- NULL
[16:11:59.730]                           }
[16:11:59.730]                           if (!has_future || version < "1.8.0") {
[16:11:59.730]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:59.730]                               "", base::R.version$version.string), 
[16:11:59.730]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:59.730]                                 base::R.version$platform, 8 * 
[16:11:59.730]                                   base::.Machine$sizeof.pointer), 
[16:11:59.730]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:59.730]                                 "release", "version")], collapse = " "), 
[16:11:59.730]                               hostname = base::Sys.info()[["nodename"]])
[16:11:59.730]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:59.730]                               info)
[16:11:59.730]                             info <- base::paste(info, collapse = "; ")
[16:11:59.730]                             if (!has_future) {
[16:11:59.730]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:59.730]                                 info)
[16:11:59.730]                             }
[16:11:59.730]                             else {
[16:11:59.730]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:59.730]                                 info, version)
[16:11:59.730]                             }
[16:11:59.730]                             base::stop(msg)
[16:11:59.730]                           }
[16:11:59.730]                         })
[16:11:59.730]                       }
[16:11:59.730]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:59.730]                       base::options(mc.cores = 1L)
[16:11:59.730]                     }
[16:11:59.730]                     base::local({
[16:11:59.730]                       for (pkg in "future") {
[16:11:59.730]                         base::loadNamespace(pkg)
[16:11:59.730]                         base::library(pkg, character.only = TRUE)
[16:11:59.730]                       }
[16:11:59.730]                     })
[16:11:59.730]                   }
[16:11:59.730]                   options(future.plan = NULL)
[16:11:59.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:59.730]                 }
[16:11:59.730]                 ...future.workdir <- getwd()
[16:11:59.730]             }
[16:11:59.730]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:59.730]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:59.730]         }
[16:11:59.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:59.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:59.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:59.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:59.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:59.730]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:59.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:59.730]             base::names(...future.oldOptions))
[16:11:59.730]     }
[16:11:59.730]     if (FALSE) {
[16:11:59.730]     }
[16:11:59.730]     else {
[16:11:59.730]         if (TRUE) {
[16:11:59.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:59.730]                 open = "w")
[16:11:59.730]         }
[16:11:59.730]         else {
[16:11:59.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:59.730]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:59.730]         }
[16:11:59.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:59.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:59.730]             base::sink(type = "output", split = FALSE)
[16:11:59.730]             base::close(...future.stdout)
[16:11:59.730]         }, add = TRUE)
[16:11:59.730]     }
[16:11:59.730]     ...future.frame <- base::sys.nframe()
[16:11:59.730]     ...future.conditions <- base::list()
[16:11:59.730]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:59.730]     if (FALSE) {
[16:11:59.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:59.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:59.730]     }
[16:11:59.730]     ...future.result <- base::tryCatch({
[16:11:59.730]         base::withCallingHandlers({
[16:11:59.730]             ...future.value <- base::withVisible(base::local({
[16:11:59.730]                 ...future.makeSendCondition <- local({
[16:11:59.730]                   sendCondition <- NULL
[16:11:59.730]                   function(frame = 1L) {
[16:11:59.730]                     if (is.function(sendCondition)) 
[16:11:59.730]                       return(sendCondition)
[16:11:59.730]                     ns <- getNamespace("parallel")
[16:11:59.730]                     if (exists("sendData", mode = "function", 
[16:11:59.730]                       envir = ns)) {
[16:11:59.730]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:59.730]                         envir = ns)
[16:11:59.730]                       envir <- sys.frame(frame)
[16:11:59.730]                       master <- NULL
[16:11:59.730]                       while (!identical(envir, .GlobalEnv) && 
[16:11:59.730]                         !identical(envir, emptyenv())) {
[16:11:59.730]                         if (exists("master", mode = "list", envir = envir, 
[16:11:59.730]                           inherits = FALSE)) {
[16:11:59.730]                           master <- get("master", mode = "list", 
[16:11:59.730]                             envir = envir, inherits = FALSE)
[16:11:59.730]                           if (inherits(master, c("SOCKnode", 
[16:11:59.730]                             "SOCK0node"))) {
[16:11:59.730]                             sendCondition <<- function(cond) {
[16:11:59.730]                               data <- list(type = "VALUE", value = cond, 
[16:11:59.730]                                 success = TRUE)
[16:11:59.730]                               parallel_sendData(master, data)
[16:11:59.730]                             }
[16:11:59.730]                             return(sendCondition)
[16:11:59.730]                           }
[16:11:59.730]                         }
[16:11:59.730]                         frame <- frame + 1L
[16:11:59.730]                         envir <- sys.frame(frame)
[16:11:59.730]                       }
[16:11:59.730]                     }
[16:11:59.730]                     sendCondition <<- function(cond) NULL
[16:11:59.730]                   }
[16:11:59.730]                 })
[16:11:59.730]                 withCallingHandlers({
[16:11:59.730]                   {
[16:11:59.730]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:59.730]                       ii, n), appendLF = FALSE)
[16:11:59.730]                     fit <- mandelbrot(C)
[16:11:59.730]                     delay(fit)
[16:11:59.730]                     message(" done")
[16:11:59.730]                     fit
[16:11:59.730]                   }
[16:11:59.730]                 }, immediateCondition = function(cond) {
[16:11:59.730]                   sendCondition <- ...future.makeSendCondition()
[16:11:59.730]                   sendCondition(cond)
[16:11:59.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.730]                   {
[16:11:59.730]                     inherits <- base::inherits
[16:11:59.730]                     invokeRestart <- base::invokeRestart
[16:11:59.730]                     is.null <- base::is.null
[16:11:59.730]                     muffled <- FALSE
[16:11:59.730]                     if (inherits(cond, "message")) {
[16:11:59.730]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:59.730]                       if (muffled) 
[16:11:59.730]                         invokeRestart("muffleMessage")
[16:11:59.730]                     }
[16:11:59.730]                     else if (inherits(cond, "warning")) {
[16:11:59.730]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:59.730]                       if (muffled) 
[16:11:59.730]                         invokeRestart("muffleWarning")
[16:11:59.730]                     }
[16:11:59.730]                     else if (inherits(cond, "condition")) {
[16:11:59.730]                       if (!is.null(pattern)) {
[16:11:59.730]                         computeRestarts <- base::computeRestarts
[16:11:59.730]                         grepl <- base::grepl
[16:11:59.730]                         restarts <- computeRestarts(cond)
[16:11:59.730]                         for (restart in restarts) {
[16:11:59.730]                           name <- restart$name
[16:11:59.730]                           if (is.null(name)) 
[16:11:59.730]                             next
[16:11:59.730]                           if (!grepl(pattern, name)) 
[16:11:59.730]                             next
[16:11:59.730]                           invokeRestart(restart)
[16:11:59.730]                           muffled <- TRUE
[16:11:59.730]                           break
[16:11:59.730]                         }
[16:11:59.730]                       }
[16:11:59.730]                     }
[16:11:59.730]                     invisible(muffled)
[16:11:59.730]                   }
[16:11:59.730]                   muffleCondition(cond)
[16:11:59.730]                 })
[16:11:59.730]             }))
[16:11:59.730]             future::FutureResult(value = ...future.value$value, 
[16:11:59.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.730]                   ...future.rng), globalenv = if (FALSE) 
[16:11:59.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:59.730]                     ...future.globalenv.names))
[16:11:59.730]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:59.730]         }, condition = base::local({
[16:11:59.730]             c <- base::c
[16:11:59.730]             inherits <- base::inherits
[16:11:59.730]             invokeRestart <- base::invokeRestart
[16:11:59.730]             length <- base::length
[16:11:59.730]             list <- base::list
[16:11:59.730]             seq.int <- base::seq.int
[16:11:59.730]             signalCondition <- base::signalCondition
[16:11:59.730]             sys.calls <- base::sys.calls
[16:11:59.730]             `[[` <- base::`[[`
[16:11:59.730]             `+` <- base::`+`
[16:11:59.730]             `<<-` <- base::`<<-`
[16:11:59.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:59.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:59.730]                   3L)]
[16:11:59.730]             }
[16:11:59.730]             function(cond) {
[16:11:59.730]                 is_error <- inherits(cond, "error")
[16:11:59.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:59.730]                   NULL)
[16:11:59.730]                 if (is_error) {
[16:11:59.730]                   sessionInformation <- function() {
[16:11:59.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:59.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:59.730]                       search = base::search(), system = base::Sys.info())
[16:11:59.730]                   }
[16:11:59.730]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:59.730]                     cond$call), session = sessionInformation(), 
[16:11:59.730]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:59.730]                   signalCondition(cond)
[16:11:59.730]                 }
[16:11:59.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:59.730]                 "immediateCondition"))) {
[16:11:59.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:59.730]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:59.730]                   if (TRUE && !signal) {
[16:11:59.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.730]                     {
[16:11:59.730]                       inherits <- base::inherits
[16:11:59.730]                       invokeRestart <- base::invokeRestart
[16:11:59.730]                       is.null <- base::is.null
[16:11:59.730]                       muffled <- FALSE
[16:11:59.730]                       if (inherits(cond, "message")) {
[16:11:59.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.730]                         if (muffled) 
[16:11:59.730]                           invokeRestart("muffleMessage")
[16:11:59.730]                       }
[16:11:59.730]                       else if (inherits(cond, "warning")) {
[16:11:59.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.730]                         if (muffled) 
[16:11:59.730]                           invokeRestart("muffleWarning")
[16:11:59.730]                       }
[16:11:59.730]                       else if (inherits(cond, "condition")) {
[16:11:59.730]                         if (!is.null(pattern)) {
[16:11:59.730]                           computeRestarts <- base::computeRestarts
[16:11:59.730]                           grepl <- base::grepl
[16:11:59.730]                           restarts <- computeRestarts(cond)
[16:11:59.730]                           for (restart in restarts) {
[16:11:59.730]                             name <- restart$name
[16:11:59.730]                             if (is.null(name)) 
[16:11:59.730]                               next
[16:11:59.730]                             if (!grepl(pattern, name)) 
[16:11:59.730]                               next
[16:11:59.730]                             invokeRestart(restart)
[16:11:59.730]                             muffled <- TRUE
[16:11:59.730]                             break
[16:11:59.730]                           }
[16:11:59.730]                         }
[16:11:59.730]                       }
[16:11:59.730]                       invisible(muffled)
[16:11:59.730]                     }
[16:11:59.730]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.730]                   }
[16:11:59.730]                 }
[16:11:59.730]                 else {
[16:11:59.730]                   if (TRUE) {
[16:11:59.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.730]                     {
[16:11:59.730]                       inherits <- base::inherits
[16:11:59.730]                       invokeRestart <- base::invokeRestart
[16:11:59.730]                       is.null <- base::is.null
[16:11:59.730]                       muffled <- FALSE
[16:11:59.730]                       if (inherits(cond, "message")) {
[16:11:59.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.730]                         if (muffled) 
[16:11:59.730]                           invokeRestart("muffleMessage")
[16:11:59.730]                       }
[16:11:59.730]                       else if (inherits(cond, "warning")) {
[16:11:59.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.730]                         if (muffled) 
[16:11:59.730]                           invokeRestart("muffleWarning")
[16:11:59.730]                       }
[16:11:59.730]                       else if (inherits(cond, "condition")) {
[16:11:59.730]                         if (!is.null(pattern)) {
[16:11:59.730]                           computeRestarts <- base::computeRestarts
[16:11:59.730]                           grepl <- base::grepl
[16:11:59.730]                           restarts <- computeRestarts(cond)
[16:11:59.730]                           for (restart in restarts) {
[16:11:59.730]                             name <- restart$name
[16:11:59.730]                             if (is.null(name)) 
[16:11:59.730]                               next
[16:11:59.730]                             if (!grepl(pattern, name)) 
[16:11:59.730]                               next
[16:11:59.730]                             invokeRestart(restart)
[16:11:59.730]                             muffled <- TRUE
[16:11:59.730]                             break
[16:11:59.730]                           }
[16:11:59.730]                         }
[16:11:59.730]                       }
[16:11:59.730]                       invisible(muffled)
[16:11:59.730]                     }
[16:11:59.730]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.730]                   }
[16:11:59.730]                 }
[16:11:59.730]             }
[16:11:59.730]         }))
[16:11:59.730]     }, error = function(ex) {
[16:11:59.730]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:59.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.730]                 ...future.rng), started = ...future.startTime, 
[16:11:59.730]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:59.730]             version = "1.8"), class = "FutureResult")
[16:11:59.730]     }, finally = {
[16:11:59.730]         if (!identical(...future.workdir, getwd())) 
[16:11:59.730]             setwd(...future.workdir)
[16:11:59.730]         {
[16:11:59.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:59.730]                 ...future.oldOptions$nwarnings <- NULL
[16:11:59.730]             }
[16:11:59.730]             base::options(...future.oldOptions)
[16:11:59.730]             if (.Platform$OS.type == "windows") {
[16:11:59.730]                 old_names <- names(...future.oldEnvVars)
[16:11:59.730]                 envs <- base::Sys.getenv()
[16:11:59.730]                 names <- names(envs)
[16:11:59.730]                 common <- intersect(names, old_names)
[16:11:59.730]                 added <- setdiff(names, old_names)
[16:11:59.730]                 removed <- setdiff(old_names, names)
[16:11:59.730]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:59.730]                   envs[common]]
[16:11:59.730]                 NAMES <- toupper(changed)
[16:11:59.730]                 args <- list()
[16:11:59.730]                 for (kk in seq_along(NAMES)) {
[16:11:59.730]                   name <- changed[[kk]]
[16:11:59.730]                   NAME <- NAMES[[kk]]
[16:11:59.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.730]                     next
[16:11:59.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.730]                 }
[16:11:59.730]                 NAMES <- toupper(added)
[16:11:59.730]                 for (kk in seq_along(NAMES)) {
[16:11:59.730]                   name <- added[[kk]]
[16:11:59.730]                   NAME <- NAMES[[kk]]
[16:11:59.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.730]                     next
[16:11:59.730]                   args[[name]] <- ""
[16:11:59.730]                 }
[16:11:59.730]                 NAMES <- toupper(removed)
[16:11:59.730]                 for (kk in seq_along(NAMES)) {
[16:11:59.730]                   name <- removed[[kk]]
[16:11:59.730]                   NAME <- NAMES[[kk]]
[16:11:59.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.730]                     next
[16:11:59.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.730]                 }
[16:11:59.730]                 if (length(args) > 0) 
[16:11:59.730]                   base::do.call(base::Sys.setenv, args = args)
[16:11:59.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:59.730]             }
[16:11:59.730]             else {
[16:11:59.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:59.730]             }
[16:11:59.730]             {
[16:11:59.730]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:59.730]                   0L) {
[16:11:59.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:59.730]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:59.730]                   base::options(opts)
[16:11:59.730]                 }
[16:11:59.730]                 {
[16:11:59.730]                   {
[16:11:59.730]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:59.730]                     NULL
[16:11:59.730]                   }
[16:11:59.730]                   options(future.plan = NULL)
[16:11:59.730]                   if (is.na(NA_character_)) 
[16:11:59.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:59.730]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:59.730]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:59.730]                     envir = parent.frame()) 
[16:11:59.730]                   {
[16:11:59.730]                     if (is.function(workers)) 
[16:11:59.730]                       workers <- workers()
[16:11:59.730]                     workers <- structure(as.integer(workers), 
[16:11:59.730]                       class = class(workers))
[16:11:59.730]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:59.730]                       workers >= 1)
[16:11:59.730]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:59.730]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:59.730]                     }
[16:11:59.730]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:59.730]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:59.730]                       envir = envir)
[16:11:59.730]                     if (!future$lazy) 
[16:11:59.730]                       future <- run(future)
[16:11:59.730]                     invisible(future)
[16:11:59.730]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:59.730]                 }
[16:11:59.730]             }
[16:11:59.730]         }
[16:11:59.730]     })
[16:11:59.730]     if (TRUE) {
[16:11:59.730]         base::sink(type = "output", split = FALSE)
[16:11:59.730]         if (TRUE) {
[16:11:59.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:59.730]         }
[16:11:59.730]         else {
[16:11:59.730]             ...future.result["stdout"] <- base::list(NULL)
[16:11:59.730]         }
[16:11:59.730]         base::close(...future.stdout)
[16:11:59.730]         ...future.stdout <- NULL
[16:11:59.730]     }
[16:11:59.730]     ...future.result$conditions <- ...future.conditions
[16:11:59.730]     ...future.result$finished <- base::Sys.time()
[16:11:59.730]     ...future.result
[16:11:59.730] }
[16:11:59.814] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[16:11:59.814] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:11:59.815] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:11:59.815] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[16:11:59.815] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[16:11:59.815] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[16:11:59.860] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[16:11:59.860] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[16:11:59.904] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[16:11:59.904] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[16:11:59.905] MultisessionFuture started
[16:11:59.905] - Launch lazy future ... done
[16:11:59.905] run() for ‘MultisessionFuture’ ... done
[16:11:59.905] - run() ... done
[16:11:59.905] - resolved() ...
[16:11:59.916] - resolved: FALSE
[16:11:59.916] - resolved() ... done
[16:11:59.916] resolved() for ‘MultisessionFuture’ ... done
[16:11:59.916] resolved() for ‘Future’ ...
[16:11:59.916] - state: ‘created’
[16:11:59.916] - run: TRUE
[16:11:59.917] - run() ...
[16:11:59.917] run() for ‘Future’ ...
[16:11:59.917] - state: ‘created’
[16:11:59.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:59.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:59.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:59.931]   - Field: ‘node’
[16:11:59.932]   - Field: ‘label’
[16:11:59.932]   - Field: ‘local’
[16:11:59.932]   - Field: ‘owner’
[16:11:59.932]   - Field: ‘envir’
[16:11:59.932]   - Field: ‘workers’
[16:11:59.932]   - Field: ‘packages’
[16:11:59.932]   - Field: ‘gc’
[16:11:59.932]   - Field: ‘conditions’
[16:11:59.932]   - Field: ‘persistent’
[16:11:59.932]   - Field: ‘expr’
[16:11:59.932]   - Field: ‘uuid’
[16:11:59.933]   - Field: ‘seed’
[16:11:59.933]   - Field: ‘version’
[16:11:59.933]   - Field: ‘result’
[16:11:59.933]   - Field: ‘asynchronous’
[16:11:59.933]   - Field: ‘calls’
[16:11:59.933]   - Field: ‘globals’
[16:11:59.933]   - Field: ‘stdout’
[16:11:59.933]   - Field: ‘earlySignal’
[16:11:59.933]   - Field: ‘lazy’
[16:11:59.933]   - Field: ‘state’
[16:11:59.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:59.934] - Launch lazy future ...
[16:11:59.934] Packages needed by the future expression (n = 1): ‘future’
[16:11:59.934] Packages needed by future strategies (n = 0): <none>
[16:11:59.934] {
[16:11:59.934]     {
[16:11:59.934]         {
[16:11:59.934]             ...future.startTime <- base::Sys.time()
[16:11:59.934]             {
[16:11:59.934]                 {
[16:11:59.934]                   {
[16:11:59.934]                     {
[16:11:59.934]                       {
[16:11:59.934]                         base::local({
[16:11:59.934]                           has_future <- base::requireNamespace("future", 
[16:11:59.934]                             quietly = TRUE)
[16:11:59.934]                           if (has_future) {
[16:11:59.934]                             ns <- base::getNamespace("future")
[16:11:59.934]                             version <- ns[[".package"]][["version"]]
[16:11:59.934]                             if (is.null(version)) 
[16:11:59.934]                               version <- utils::packageVersion("future")
[16:11:59.934]                           }
[16:11:59.934]                           else {
[16:11:59.934]                             version <- NULL
[16:11:59.934]                           }
[16:11:59.934]                           if (!has_future || version < "1.8.0") {
[16:11:59.934]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:59.934]                               "", base::R.version$version.string), 
[16:11:59.934]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:59.934]                                 base::R.version$platform, 8 * 
[16:11:59.934]                                   base::.Machine$sizeof.pointer), 
[16:11:59.934]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:59.934]                                 "release", "version")], collapse = " "), 
[16:11:59.934]                               hostname = base::Sys.info()[["nodename"]])
[16:11:59.934]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:59.934]                               info)
[16:11:59.934]                             info <- base::paste(info, collapse = "; ")
[16:11:59.934]                             if (!has_future) {
[16:11:59.934]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:59.934]                                 info)
[16:11:59.934]                             }
[16:11:59.934]                             else {
[16:11:59.934]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:59.934]                                 info, version)
[16:11:59.934]                             }
[16:11:59.934]                             base::stop(msg)
[16:11:59.934]                           }
[16:11:59.934]                         })
[16:11:59.934]                       }
[16:11:59.934]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:59.934]                       base::options(mc.cores = 1L)
[16:11:59.934]                     }
[16:11:59.934]                     base::local({
[16:11:59.934]                       for (pkg in "future") {
[16:11:59.934]                         base::loadNamespace(pkg)
[16:11:59.934]                         base::library(pkg, character.only = TRUE)
[16:11:59.934]                       }
[16:11:59.934]                     })
[16:11:59.934]                   }
[16:11:59.934]                   options(future.plan = NULL)
[16:11:59.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:59.934]                 }
[16:11:59.934]                 ...future.workdir <- getwd()
[16:11:59.934]             }
[16:11:59.934]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:59.934]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:59.934]         }
[16:11:59.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:59.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:59.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:59.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:59.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:59.934]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:59.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:59.934]             base::names(...future.oldOptions))
[16:11:59.934]     }
[16:11:59.934]     if (FALSE) {
[16:11:59.934]     }
[16:11:59.934]     else {
[16:11:59.934]         if (TRUE) {
[16:11:59.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:59.934]                 open = "w")
[16:11:59.934]         }
[16:11:59.934]         else {
[16:11:59.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:59.934]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:59.934]         }
[16:11:59.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:59.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:59.934]             base::sink(type = "output", split = FALSE)
[16:11:59.934]             base::close(...future.stdout)
[16:11:59.934]         }, add = TRUE)
[16:11:59.934]     }
[16:11:59.934]     ...future.frame <- base::sys.nframe()
[16:11:59.934]     ...future.conditions <- base::list()
[16:11:59.934]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:59.934]     if (FALSE) {
[16:11:59.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:59.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:59.934]     }
[16:11:59.934]     ...future.result <- base::tryCatch({
[16:11:59.934]         base::withCallingHandlers({
[16:11:59.934]             ...future.value <- base::withVisible(base::local({
[16:11:59.934]                 ...future.makeSendCondition <- local({
[16:11:59.934]                   sendCondition <- NULL
[16:11:59.934]                   function(frame = 1L) {
[16:11:59.934]                     if (is.function(sendCondition)) 
[16:11:59.934]                       return(sendCondition)
[16:11:59.934]                     ns <- getNamespace("parallel")
[16:11:59.934]                     if (exists("sendData", mode = "function", 
[16:11:59.934]                       envir = ns)) {
[16:11:59.934]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:59.934]                         envir = ns)
[16:11:59.934]                       envir <- sys.frame(frame)
[16:11:59.934]                       master <- NULL
[16:11:59.934]                       while (!identical(envir, .GlobalEnv) && 
[16:11:59.934]                         !identical(envir, emptyenv())) {
[16:11:59.934]                         if (exists("master", mode = "list", envir = envir, 
[16:11:59.934]                           inherits = FALSE)) {
[16:11:59.934]                           master <- get("master", mode = "list", 
[16:11:59.934]                             envir = envir, inherits = FALSE)
[16:11:59.934]                           if (inherits(master, c("SOCKnode", 
[16:11:59.934]                             "SOCK0node"))) {
[16:11:59.934]                             sendCondition <<- function(cond) {
[16:11:59.934]                               data <- list(type = "VALUE", value = cond, 
[16:11:59.934]                                 success = TRUE)
[16:11:59.934]                               parallel_sendData(master, data)
[16:11:59.934]                             }
[16:11:59.934]                             return(sendCondition)
[16:11:59.934]                           }
[16:11:59.934]                         }
[16:11:59.934]                         frame <- frame + 1L
[16:11:59.934]                         envir <- sys.frame(frame)
[16:11:59.934]                       }
[16:11:59.934]                     }
[16:11:59.934]                     sendCondition <<- function(cond) NULL
[16:11:59.934]                   }
[16:11:59.934]                 })
[16:11:59.934]                 withCallingHandlers({
[16:11:59.934]                   {
[16:11:59.934]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:11:59.934]                       ii, n), appendLF = FALSE)
[16:11:59.934]                     fit <- mandelbrot(C)
[16:11:59.934]                     delay(fit)
[16:11:59.934]                     message(" done")
[16:11:59.934]                     fit
[16:11:59.934]                   }
[16:11:59.934]                 }, immediateCondition = function(cond) {
[16:11:59.934]                   sendCondition <- ...future.makeSendCondition()
[16:11:59.934]                   sendCondition(cond)
[16:11:59.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.934]                   {
[16:11:59.934]                     inherits <- base::inherits
[16:11:59.934]                     invokeRestart <- base::invokeRestart
[16:11:59.934]                     is.null <- base::is.null
[16:11:59.934]                     muffled <- FALSE
[16:11:59.934]                     if (inherits(cond, "message")) {
[16:11:59.934]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:59.934]                       if (muffled) 
[16:11:59.934]                         invokeRestart("muffleMessage")
[16:11:59.934]                     }
[16:11:59.934]                     else if (inherits(cond, "warning")) {
[16:11:59.934]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:59.934]                       if (muffled) 
[16:11:59.934]                         invokeRestart("muffleWarning")
[16:11:59.934]                     }
[16:11:59.934]                     else if (inherits(cond, "condition")) {
[16:11:59.934]                       if (!is.null(pattern)) {
[16:11:59.934]                         computeRestarts <- base::computeRestarts
[16:11:59.934]                         grepl <- base::grepl
[16:11:59.934]                         restarts <- computeRestarts(cond)
[16:11:59.934]                         for (restart in restarts) {
[16:11:59.934]                           name <- restart$name
[16:11:59.934]                           if (is.null(name)) 
[16:11:59.934]                             next
[16:11:59.934]                           if (!grepl(pattern, name)) 
[16:11:59.934]                             next
[16:11:59.934]                           invokeRestart(restart)
[16:11:59.934]                           muffled <- TRUE
[16:11:59.934]                           break
[16:11:59.934]                         }
[16:11:59.934]                       }
[16:11:59.934]                     }
[16:11:59.934]                     invisible(muffled)
[16:11:59.934]                   }
[16:11:59.934]                   muffleCondition(cond)
[16:11:59.934]                 })
[16:11:59.934]             }))
[16:11:59.934]             future::FutureResult(value = ...future.value$value, 
[16:11:59.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.934]                   ...future.rng), globalenv = if (FALSE) 
[16:11:59.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:59.934]                     ...future.globalenv.names))
[16:11:59.934]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:59.934]         }, condition = base::local({
[16:11:59.934]             c <- base::c
[16:11:59.934]             inherits <- base::inherits
[16:11:59.934]             invokeRestart <- base::invokeRestart
[16:11:59.934]             length <- base::length
[16:11:59.934]             list <- base::list
[16:11:59.934]             seq.int <- base::seq.int
[16:11:59.934]             signalCondition <- base::signalCondition
[16:11:59.934]             sys.calls <- base::sys.calls
[16:11:59.934]             `[[` <- base::`[[`
[16:11:59.934]             `+` <- base::`+`
[16:11:59.934]             `<<-` <- base::`<<-`
[16:11:59.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:59.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:59.934]                   3L)]
[16:11:59.934]             }
[16:11:59.934]             function(cond) {
[16:11:59.934]                 is_error <- inherits(cond, "error")
[16:11:59.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:59.934]                   NULL)
[16:11:59.934]                 if (is_error) {
[16:11:59.934]                   sessionInformation <- function() {
[16:11:59.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:59.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:59.934]                       search = base::search(), system = base::Sys.info())
[16:11:59.934]                   }
[16:11:59.934]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:59.934]                     cond$call), session = sessionInformation(), 
[16:11:59.934]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:59.934]                   signalCondition(cond)
[16:11:59.934]                 }
[16:11:59.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:59.934]                 "immediateCondition"))) {
[16:11:59.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:59.934]                   ...future.conditions[[length(...future.conditions) + 
[16:11:59.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:59.934]                   if (TRUE && !signal) {
[16:11:59.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.934]                     {
[16:11:59.934]                       inherits <- base::inherits
[16:11:59.934]                       invokeRestart <- base::invokeRestart
[16:11:59.934]                       is.null <- base::is.null
[16:11:59.934]                       muffled <- FALSE
[16:11:59.934]                       if (inherits(cond, "message")) {
[16:11:59.934]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.934]                         if (muffled) 
[16:11:59.934]                           invokeRestart("muffleMessage")
[16:11:59.934]                       }
[16:11:59.934]                       else if (inherits(cond, "warning")) {
[16:11:59.934]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.934]                         if (muffled) 
[16:11:59.934]                           invokeRestart("muffleWarning")
[16:11:59.934]                       }
[16:11:59.934]                       else if (inherits(cond, "condition")) {
[16:11:59.934]                         if (!is.null(pattern)) {
[16:11:59.934]                           computeRestarts <- base::computeRestarts
[16:11:59.934]                           grepl <- base::grepl
[16:11:59.934]                           restarts <- computeRestarts(cond)
[16:11:59.934]                           for (restart in restarts) {
[16:11:59.934]                             name <- restart$name
[16:11:59.934]                             if (is.null(name)) 
[16:11:59.934]                               next
[16:11:59.934]                             if (!grepl(pattern, name)) 
[16:11:59.934]                               next
[16:11:59.934]                             invokeRestart(restart)
[16:11:59.934]                             muffled <- TRUE
[16:11:59.934]                             break
[16:11:59.934]                           }
[16:11:59.934]                         }
[16:11:59.934]                       }
[16:11:59.934]                       invisible(muffled)
[16:11:59.934]                     }
[16:11:59.934]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.934]                   }
[16:11:59.934]                 }
[16:11:59.934]                 else {
[16:11:59.934]                   if (TRUE) {
[16:11:59.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:59.934]                     {
[16:11:59.934]                       inherits <- base::inherits
[16:11:59.934]                       invokeRestart <- base::invokeRestart
[16:11:59.934]                       is.null <- base::is.null
[16:11:59.934]                       muffled <- FALSE
[16:11:59.934]                       if (inherits(cond, "message")) {
[16:11:59.934]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:59.934]                         if (muffled) 
[16:11:59.934]                           invokeRestart("muffleMessage")
[16:11:59.934]                       }
[16:11:59.934]                       else if (inherits(cond, "warning")) {
[16:11:59.934]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:59.934]                         if (muffled) 
[16:11:59.934]                           invokeRestart("muffleWarning")
[16:11:59.934]                       }
[16:11:59.934]                       else if (inherits(cond, "condition")) {
[16:11:59.934]                         if (!is.null(pattern)) {
[16:11:59.934]                           computeRestarts <- base::computeRestarts
[16:11:59.934]                           grepl <- base::grepl
[16:11:59.934]                           restarts <- computeRestarts(cond)
[16:11:59.934]                           for (restart in restarts) {
[16:11:59.934]                             name <- restart$name
[16:11:59.934]                             if (is.null(name)) 
[16:11:59.934]                               next
[16:11:59.934]                             if (!grepl(pattern, name)) 
[16:11:59.934]                               next
[16:11:59.934]                             invokeRestart(restart)
[16:11:59.934]                             muffled <- TRUE
[16:11:59.934]                             break
[16:11:59.934]                           }
[16:11:59.934]                         }
[16:11:59.934]                       }
[16:11:59.934]                       invisible(muffled)
[16:11:59.934]                     }
[16:11:59.934]                     muffleCondition(cond, pattern = "^muffle")
[16:11:59.934]                   }
[16:11:59.934]                 }
[16:11:59.934]             }
[16:11:59.934]         }))
[16:11:59.934]     }, error = function(ex) {
[16:11:59.934]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:59.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:59.934]                 ...future.rng), started = ...future.startTime, 
[16:11:59.934]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:59.934]             version = "1.8"), class = "FutureResult")
[16:11:59.934]     }, finally = {
[16:11:59.934]         if (!identical(...future.workdir, getwd())) 
[16:11:59.934]             setwd(...future.workdir)
[16:11:59.934]         {
[16:11:59.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:59.934]                 ...future.oldOptions$nwarnings <- NULL
[16:11:59.934]             }
[16:11:59.934]             base::options(...future.oldOptions)
[16:11:59.934]             if (.Platform$OS.type == "windows") {
[16:11:59.934]                 old_names <- names(...future.oldEnvVars)
[16:11:59.934]                 envs <- base::Sys.getenv()
[16:11:59.934]                 names <- names(envs)
[16:11:59.934]                 common <- intersect(names, old_names)
[16:11:59.934]                 added <- setdiff(names, old_names)
[16:11:59.934]                 removed <- setdiff(old_names, names)
[16:11:59.934]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:59.934]                   envs[common]]
[16:11:59.934]                 NAMES <- toupper(changed)
[16:11:59.934]                 args <- list()
[16:11:59.934]                 for (kk in seq_along(NAMES)) {
[16:11:59.934]                   name <- changed[[kk]]
[16:11:59.934]                   NAME <- NAMES[[kk]]
[16:11:59.934]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.934]                     next
[16:11:59.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.934]                 }
[16:11:59.934]                 NAMES <- toupper(added)
[16:11:59.934]                 for (kk in seq_along(NAMES)) {
[16:11:59.934]                   name <- added[[kk]]
[16:11:59.934]                   NAME <- NAMES[[kk]]
[16:11:59.934]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.934]                     next
[16:11:59.934]                   args[[name]] <- ""
[16:11:59.934]                 }
[16:11:59.934]                 NAMES <- toupper(removed)
[16:11:59.934]                 for (kk in seq_along(NAMES)) {
[16:11:59.934]                   name <- removed[[kk]]
[16:11:59.934]                   NAME <- NAMES[[kk]]
[16:11:59.934]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:59.934]                     next
[16:11:59.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:59.934]                 }
[16:11:59.934]                 if (length(args) > 0) 
[16:11:59.934]                   base::do.call(base::Sys.setenv, args = args)
[16:11:59.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:59.934]             }
[16:11:59.934]             else {
[16:11:59.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:59.934]             }
[16:11:59.934]             {
[16:11:59.934]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:59.934]                   0L) {
[16:11:59.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:59.934]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:59.934]                   base::options(opts)
[16:11:59.934]                 }
[16:11:59.934]                 {
[16:11:59.934]                   {
[16:11:59.934]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:59.934]                     NULL
[16:11:59.934]                   }
[16:11:59.934]                   options(future.plan = NULL)
[16:11:59.934]                   if (is.na(NA_character_)) 
[16:11:59.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:59.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:59.934]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:59.934]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:59.934]                     envir = parent.frame()) 
[16:11:59.934]                   {
[16:11:59.934]                     if (is.function(workers)) 
[16:11:59.934]                       workers <- workers()
[16:11:59.934]                     workers <- structure(as.integer(workers), 
[16:11:59.934]                       class = class(workers))
[16:11:59.934]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:59.934]                       workers >= 1)
[16:11:59.934]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:59.934]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:59.934]                     }
[16:11:59.934]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:59.934]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:59.934]                       envir = envir)
[16:11:59.934]                     if (!future$lazy) 
[16:11:59.934]                       future <- run(future)
[16:11:59.934]                     invisible(future)
[16:11:59.934]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:59.934]                 }
[16:11:59.934]             }
[16:11:59.934]         }
[16:11:59.934]     })
[16:11:59.934]     if (TRUE) {
[16:11:59.934]         base::sink(type = "output", split = FALSE)
[16:11:59.934]         if (TRUE) {
[16:11:59.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:59.934]         }
[16:11:59.934]         else {
[16:11:59.934]             ...future.result["stdout"] <- base::list(NULL)
[16:11:59.934]         }
[16:11:59.934]         base::close(...future.stdout)
[16:11:59.934]         ...future.stdout <- NULL
[16:11:59.934]     }
[16:11:59.934]     ...future.result$conditions <- ...future.conditions
[16:11:59.934]     ...future.result$finished <- base::Sys.time()
[16:11:59.934]     ...future.result
[16:11:59.934] }
[16:11:59.937] Poll #1 (0): usedNodes() = 2, workers = 2
[16:11:59.955] receiveMessageFromWorker() for ClusterFuture ...
[16:11:59.955] - Validating connection of MultisessionFuture
[16:11:59.956] - received message: FutureResult
[16:11:59.956] - Received FutureResult
[16:11:59.956] - Erased future from FutureRegistry
[16:11:59.956] result() for ClusterFuture ...
[16:11:59.956] - result already collected: FutureResult
[16:11:59.956] result() for ClusterFuture ... done
[16:11:59.957] signalConditions() ...
[16:11:59.957]  - include = ‘immediateCondition’
[16:11:59.957]  - exclude = 
[16:11:59.957]  - resignal = FALSE
[16:11:59.957]  - Number of conditions: 2
[16:11:59.957] signalConditions() ... done
[16:11:59.957] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:59.957] result() for ClusterFuture ...
[16:11:59.957] - result already collected: FutureResult
[16:11:59.957] result() for ClusterFuture ... done
[16:11:59.957] result() for ClusterFuture ...
[16:11:59.958] - result already collected: FutureResult
[16:11:59.958] result() for ClusterFuture ... done
[16:11:59.958] signalConditions() ...
[16:11:59.958]  - include = ‘immediateCondition’
[16:11:59.958]  - exclude = 
[16:11:59.958]  - resignal = FALSE
[16:11:59.958]  - Number of conditions: 2
[16:11:59.958] signalConditions() ... done
[16:11:59.959] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[16:11:59.959] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:11:59.959] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:59.960] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[16:11:59.960] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[16:11:59.960] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[16:12:00.004] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[16:12:00.004] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[16:12:00.048] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[16:12:00.048] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[16:12:00.049] MultisessionFuture started
[16:12:00.049] - Launch lazy future ... done
[16:12:00.049] run() for ‘MultisessionFuture’ ... done
[16:12:00.049] - run() ... done
[16:12:00.049] - resolved() ...
[16:12:00.060] - resolved: FALSE
[16:12:00.060] - resolved() ... done
[16:12:00.060] resolved() for ‘MultisessionFuture’ ... done
[16:12:00.060] resolved() for ‘Future’ ...
[16:12:00.060] - state: ‘created’
[16:12:00.061] - run: TRUE
[16:12:00.061] - run() ...
[16:12:00.061] run() for ‘Future’ ...
[16:12:00.061] - state: ‘created’
[16:12:00.061] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:00.075] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:00.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:00.076]   - Field: ‘node’
[16:12:00.076]   - Field: ‘label’
[16:12:00.076]   - Field: ‘local’
[16:12:00.076]   - Field: ‘owner’
[16:12:00.076]   - Field: ‘envir’
[16:12:00.076]   - Field: ‘workers’
[16:12:00.076]   - Field: ‘packages’
[16:12:00.076]   - Field: ‘gc’
[16:12:00.077]   - Field: ‘conditions’
[16:12:00.077]   - Field: ‘persistent’
[16:12:00.077]   - Field: ‘expr’
[16:12:00.077]   - Field: ‘uuid’
[16:12:00.077]   - Field: ‘seed’
[16:12:00.077]   - Field: ‘version’
[16:12:00.077]   - Field: ‘result’
[16:12:00.077]   - Field: ‘asynchronous’
[16:12:00.077]   - Field: ‘calls’
[16:12:00.077]   - Field: ‘globals’
[16:12:00.078]   - Field: ‘stdout’
[16:12:00.078]   - Field: ‘earlySignal’
[16:12:00.078]   - Field: ‘lazy’
[16:12:00.078]   - Field: ‘state’
[16:12:00.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:00.078] - Launch lazy future ...
[16:12:00.078] Packages needed by the future expression (n = 1): ‘future’
[16:12:00.078] Packages needed by future strategies (n = 0): <none>
[16:12:00.079] {
[16:12:00.079]     {
[16:12:00.079]         {
[16:12:00.079]             ...future.startTime <- base::Sys.time()
[16:12:00.079]             {
[16:12:00.079]                 {
[16:12:00.079]                   {
[16:12:00.079]                     {
[16:12:00.079]                       {
[16:12:00.079]                         base::local({
[16:12:00.079]                           has_future <- base::requireNamespace("future", 
[16:12:00.079]                             quietly = TRUE)
[16:12:00.079]                           if (has_future) {
[16:12:00.079]                             ns <- base::getNamespace("future")
[16:12:00.079]                             version <- ns[[".package"]][["version"]]
[16:12:00.079]                             if (is.null(version)) 
[16:12:00.079]                               version <- utils::packageVersion("future")
[16:12:00.079]                           }
[16:12:00.079]                           else {
[16:12:00.079]                             version <- NULL
[16:12:00.079]                           }
[16:12:00.079]                           if (!has_future || version < "1.8.0") {
[16:12:00.079]                             info <- base::c(r_version = base::gsub("R version ", 
[16:12:00.079]                               "", base::R.version$version.string), 
[16:12:00.079]                               platform = base::sprintf("%s (%s-bit)", 
[16:12:00.079]                                 base::R.version$platform, 8 * 
[16:12:00.079]                                   base::.Machine$sizeof.pointer), 
[16:12:00.079]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:00.079]                                 "release", "version")], collapse = " "), 
[16:12:00.079]                               hostname = base::Sys.info()[["nodename"]])
[16:12:00.079]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:12:00.079]                               info)
[16:12:00.079]                             info <- base::paste(info, collapse = "; ")
[16:12:00.079]                             if (!has_future) {
[16:12:00.079]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:00.079]                                 info)
[16:12:00.079]                             }
[16:12:00.079]                             else {
[16:12:00.079]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:00.079]                                 info, version)
[16:12:00.079]                             }
[16:12:00.079]                             base::stop(msg)
[16:12:00.079]                           }
[16:12:00.079]                         })
[16:12:00.079]                       }
[16:12:00.079]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:00.079]                       base::options(mc.cores = 1L)
[16:12:00.079]                     }
[16:12:00.079]                     base::local({
[16:12:00.079]                       for (pkg in "future") {
[16:12:00.079]                         base::loadNamespace(pkg)
[16:12:00.079]                         base::library(pkg, character.only = TRUE)
[16:12:00.079]                       }
[16:12:00.079]                     })
[16:12:00.079]                   }
[16:12:00.079]                   options(future.plan = NULL)
[16:12:00.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:00.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:00.079]                 }
[16:12:00.079]                 ...future.workdir <- getwd()
[16:12:00.079]             }
[16:12:00.079]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:00.079]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:00.079]         }
[16:12:00.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:00.079]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:00.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:00.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:00.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:00.079]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:00.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:00.079]             base::names(...future.oldOptions))
[16:12:00.079]     }
[16:12:00.079]     if (FALSE) {
[16:12:00.079]     }
[16:12:00.079]     else {
[16:12:00.079]         if (TRUE) {
[16:12:00.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:00.079]                 open = "w")
[16:12:00.079]         }
[16:12:00.079]         else {
[16:12:00.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:00.079]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:00.079]         }
[16:12:00.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:00.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:00.079]             base::sink(type = "output", split = FALSE)
[16:12:00.079]             base::close(...future.stdout)
[16:12:00.079]         }, add = TRUE)
[16:12:00.079]     }
[16:12:00.079]     ...future.frame <- base::sys.nframe()
[16:12:00.079]     ...future.conditions <- base::list()
[16:12:00.079]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:00.079]     if (FALSE) {
[16:12:00.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:00.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:00.079]     }
[16:12:00.079]     ...future.result <- base::tryCatch({
[16:12:00.079]         base::withCallingHandlers({
[16:12:00.079]             ...future.value <- base::withVisible(base::local({
[16:12:00.079]                 ...future.makeSendCondition <- local({
[16:12:00.079]                   sendCondition <- NULL
[16:12:00.079]                   function(frame = 1L) {
[16:12:00.079]                     if (is.function(sendCondition)) 
[16:12:00.079]                       return(sendCondition)
[16:12:00.079]                     ns <- getNamespace("parallel")
[16:12:00.079]                     if (exists("sendData", mode = "function", 
[16:12:00.079]                       envir = ns)) {
[16:12:00.079]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:00.079]                         envir = ns)
[16:12:00.079]                       envir <- sys.frame(frame)
[16:12:00.079]                       master <- NULL
[16:12:00.079]                       while (!identical(envir, .GlobalEnv) && 
[16:12:00.079]                         !identical(envir, emptyenv())) {
[16:12:00.079]                         if (exists("master", mode = "list", envir = envir, 
[16:12:00.079]                           inherits = FALSE)) {
[16:12:00.079]                           master <- get("master", mode = "list", 
[16:12:00.079]                             envir = envir, inherits = FALSE)
[16:12:00.079]                           if (inherits(master, c("SOCKnode", 
[16:12:00.079]                             "SOCK0node"))) {
[16:12:00.079]                             sendCondition <<- function(cond) {
[16:12:00.079]                               data <- list(type = "VALUE", value = cond, 
[16:12:00.079]                                 success = TRUE)
[16:12:00.079]                               parallel_sendData(master, data)
[16:12:00.079]                             }
[16:12:00.079]                             return(sendCondition)
[16:12:00.079]                           }
[16:12:00.079]                         }
[16:12:00.079]                         frame <- frame + 1L
[16:12:00.079]                         envir <- sys.frame(frame)
[16:12:00.079]                       }
[16:12:00.079]                     }
[16:12:00.079]                     sendCondition <<- function(cond) NULL
[16:12:00.079]                   }
[16:12:00.079]                 })
[16:12:00.079]                 withCallingHandlers({
[16:12:00.079]                   {
[16:12:00.079]                     message(sprintf("Calculating tile #%d of %d ...", 
[16:12:00.079]                       ii, n), appendLF = FALSE)
[16:12:00.079]                     fit <- mandelbrot(C)
[16:12:00.079]                     delay(fit)
[16:12:00.079]                     message(" done")
[16:12:00.079]                     fit
[16:12:00.079]                   }
[16:12:00.079]                 }, immediateCondition = function(cond) {
[16:12:00.079]                   sendCondition <- ...future.makeSendCondition()
[16:12:00.079]                   sendCondition(cond)
[16:12:00.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:00.079]                   {
[16:12:00.079]                     inherits <- base::inherits
[16:12:00.079]                     invokeRestart <- base::invokeRestart
[16:12:00.079]                     is.null <- base::is.null
[16:12:00.079]                     muffled <- FALSE
[16:12:00.079]                     if (inherits(cond, "message")) {
[16:12:00.079]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:00.079]                       if (muffled) 
[16:12:00.079]                         invokeRestart("muffleMessage")
[16:12:00.079]                     }
[16:12:00.079]                     else if (inherits(cond, "warning")) {
[16:12:00.079]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:00.079]                       if (muffled) 
[16:12:00.079]                         invokeRestart("muffleWarning")
[16:12:00.079]                     }
[16:12:00.079]                     else if (inherits(cond, "condition")) {
[16:12:00.079]                       if (!is.null(pattern)) {
[16:12:00.079]                         computeRestarts <- base::computeRestarts
[16:12:00.079]                         grepl <- base::grepl
[16:12:00.079]                         restarts <- computeRestarts(cond)
[16:12:00.079]                         for (restart in restarts) {
[16:12:00.079]                           name <- restart$name
[16:12:00.079]                           if (is.null(name)) 
[16:12:00.079]                             next
[16:12:00.079]                           if (!grepl(pattern, name)) 
[16:12:00.079]                             next
[16:12:00.079]                           invokeRestart(restart)
[16:12:00.079]                           muffled <- TRUE
[16:12:00.079]                           break
[16:12:00.079]                         }
[16:12:00.079]                       }
[16:12:00.079]                     }
[16:12:00.079]                     invisible(muffled)
[16:12:00.079]                   }
[16:12:00.079]                   muffleCondition(cond)
[16:12:00.079]                 })
[16:12:00.079]             }))
[16:12:00.079]             future::FutureResult(value = ...future.value$value, 
[16:12:00.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:00.079]                   ...future.rng), globalenv = if (FALSE) 
[16:12:00.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:00.079]                     ...future.globalenv.names))
[16:12:00.079]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:00.079]         }, condition = base::local({
[16:12:00.079]             c <- base::c
[16:12:00.079]             inherits <- base::inherits
[16:12:00.079]             invokeRestart <- base::invokeRestart
[16:12:00.079]             length <- base::length
[16:12:00.079]             list <- base::list
[16:12:00.079]             seq.int <- base::seq.int
[16:12:00.079]             signalCondition <- base::signalCondition
[16:12:00.079]             sys.calls <- base::sys.calls
[16:12:00.079]             `[[` <- base::`[[`
[16:12:00.079]             `+` <- base::`+`
[16:12:00.079]             `<<-` <- base::`<<-`
[16:12:00.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:00.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:00.079]                   3L)]
[16:12:00.079]             }
[16:12:00.079]             function(cond) {
[16:12:00.079]                 is_error <- inherits(cond, "error")
[16:12:00.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:00.079]                   NULL)
[16:12:00.079]                 if (is_error) {
[16:12:00.079]                   sessionInformation <- function() {
[16:12:00.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:00.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:00.079]                       search = base::search(), system = base::Sys.info())
[16:12:00.079]                   }
[16:12:00.079]                   ...future.conditions[[length(...future.conditions) + 
[16:12:00.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:00.079]                     cond$call), session = sessionInformation(), 
[16:12:00.079]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:00.079]                   signalCondition(cond)
[16:12:00.079]                 }
[16:12:00.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:00.079]                 "immediateCondition"))) {
[16:12:00.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:00.079]                   ...future.conditions[[length(...future.conditions) + 
[16:12:00.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:00.079]                   if (TRUE && !signal) {
[16:12:00.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:00.079]                     {
[16:12:00.079]                       inherits <- base::inherits
[16:12:00.079]                       invokeRestart <- base::invokeRestart
[16:12:00.079]                       is.null <- base::is.null
[16:12:00.079]                       muffled <- FALSE
[16:12:00.079]                       if (inherits(cond, "message")) {
[16:12:00.079]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:00.079]                         if (muffled) 
[16:12:00.079]                           invokeRestart("muffleMessage")
[16:12:00.079]                       }
[16:12:00.079]                       else if (inherits(cond, "warning")) {
[16:12:00.079]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:00.079]                         if (muffled) 
[16:12:00.079]                           invokeRestart("muffleWarning")
[16:12:00.079]                       }
[16:12:00.079]                       else if (inherits(cond, "condition")) {
[16:12:00.079]                         if (!is.null(pattern)) {
[16:12:00.079]                           computeRestarts <- base::computeRestarts
[16:12:00.079]                           grepl <- base::grepl
[16:12:00.079]                           restarts <- computeRestarts(cond)
[16:12:00.079]                           for (restart in restarts) {
[16:12:00.079]                             name <- restart$name
[16:12:00.079]                             if (is.null(name)) 
[16:12:00.079]                               next
[16:12:00.079]                             if (!grepl(pattern, name)) 
[16:12:00.079]                               next
[16:12:00.079]                             invokeRestart(restart)
[16:12:00.079]                             muffled <- TRUE
[16:12:00.079]                             break
[16:12:00.079]                           }
[16:12:00.079]                         }
[16:12:00.079]                       }
[16:12:00.079]                       invisible(muffled)
[16:12:00.079]                     }
[16:12:00.079]                     muffleCondition(cond, pattern = "^muffle")
[16:12:00.079]                   }
[16:12:00.079]                 }
[16:12:00.079]                 else {
[16:12:00.079]                   if (TRUE) {
[16:12:00.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:00.079]                     {
[16:12:00.079]                       inherits <- base::inherits
[16:12:00.079]                       invokeRestart <- base::invokeRestart
[16:12:00.079]                       is.null <- base::is.null
[16:12:00.079]                       muffled <- FALSE
[16:12:00.079]                       if (inherits(cond, "message")) {
[16:12:00.079]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:00.079]                         if (muffled) 
[16:12:00.079]                           invokeRestart("muffleMessage")
[16:12:00.079]                       }
[16:12:00.079]                       else if (inherits(cond, "warning")) {
[16:12:00.079]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:00.079]                         if (muffled) 
[16:12:00.079]                           invokeRestart("muffleWarning")
[16:12:00.079]                       }
[16:12:00.079]                       else if (inherits(cond, "condition")) {
[16:12:00.079]                         if (!is.null(pattern)) {
[16:12:00.079]                           computeRestarts <- base::computeRestarts
[16:12:00.079]                           grepl <- base::grepl
[16:12:00.079]                           restarts <- computeRestarts(cond)
[16:12:00.079]                           for (restart in restarts) {
[16:12:00.079]                             name <- restart$name
[16:12:00.079]                             if (is.null(name)) 
[16:12:00.079]                               next
[16:12:00.079]                             if (!grepl(pattern, name)) 
[16:12:00.079]                               next
[16:12:00.079]                             invokeRestart(restart)
[16:12:00.079]                             muffled <- TRUE
[16:12:00.079]                             break
[16:12:00.079]                           }
[16:12:00.079]                         }
[16:12:00.079]                       }
[16:12:00.079]                       invisible(muffled)
[16:12:00.079]                     }
[16:12:00.079]                     muffleCondition(cond, pattern = "^muffle")
[16:12:00.079]                   }
[16:12:00.079]                 }
[16:12:00.079]             }
[16:12:00.079]         }))
[16:12:00.079]     }, error = function(ex) {
[16:12:00.079]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:00.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:00.079]                 ...future.rng), started = ...future.startTime, 
[16:12:00.079]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:00.079]             version = "1.8"), class = "FutureResult")
[16:12:00.079]     }, finally = {
[16:12:00.079]         if (!identical(...future.workdir, getwd())) 
[16:12:00.079]             setwd(...future.workdir)
[16:12:00.079]         {
[16:12:00.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:00.079]                 ...future.oldOptions$nwarnings <- NULL
[16:12:00.079]             }
[16:12:00.079]             base::options(...future.oldOptions)
[16:12:00.079]             if (.Platform$OS.type == "windows") {
[16:12:00.079]                 old_names <- names(...future.oldEnvVars)
[16:12:00.079]                 envs <- base::Sys.getenv()
[16:12:00.079]                 names <- names(envs)
[16:12:00.079]                 common <- intersect(names, old_names)
[16:12:00.079]                 added <- setdiff(names, old_names)
[16:12:00.079]                 removed <- setdiff(old_names, names)
[16:12:00.079]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:00.079]                   envs[common]]
[16:12:00.079]                 NAMES <- toupper(changed)
[16:12:00.079]                 args <- list()
[16:12:00.079]                 for (kk in seq_along(NAMES)) {
[16:12:00.079]                   name <- changed[[kk]]
[16:12:00.079]                   NAME <- NAMES[[kk]]
[16:12:00.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:00.079]                     next
[16:12:00.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:00.079]                 }
[16:12:00.079]                 NAMES <- toupper(added)
[16:12:00.079]                 for (kk in seq_along(NAMES)) {
[16:12:00.079]                   name <- added[[kk]]
[16:12:00.079]                   NAME <- NAMES[[kk]]
[16:12:00.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:00.079]                     next
[16:12:00.079]                   args[[name]] <- ""
[16:12:00.079]                 }
[16:12:00.079]                 NAMES <- toupper(removed)
[16:12:00.079]                 for (kk in seq_along(NAMES)) {
[16:12:00.079]                   name <- removed[[kk]]
[16:12:00.079]                   NAME <- NAMES[[kk]]
[16:12:00.079]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:00.079]                     next
[16:12:00.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:00.079]                 }
[16:12:00.079]                 if (length(args) > 0) 
[16:12:00.079]                   base::do.call(base::Sys.setenv, args = args)
[16:12:00.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:00.079]             }
[16:12:00.079]             else {
[16:12:00.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:00.079]             }
[16:12:00.079]             {
[16:12:00.079]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:00.079]                   0L) {
[16:12:00.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:00.079]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:00.079]                   base::options(opts)
[16:12:00.079]                 }
[16:12:00.079]                 {
[16:12:00.079]                   {
[16:12:00.079]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:00.079]                     NULL
[16:12:00.079]                   }
[16:12:00.079]                   options(future.plan = NULL)
[16:12:00.079]                   if (is.na(NA_character_)) 
[16:12:00.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:00.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:00.079]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:00.079]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:00.079]                     envir = parent.frame()) 
[16:12:00.079]                   {
[16:12:00.079]                     if (is.function(workers)) 
[16:12:00.079]                       workers <- workers()
[16:12:00.079]                     workers <- structure(as.integer(workers), 
[16:12:00.079]                       class = class(workers))
[16:12:00.079]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:00.079]                       workers >= 1)
[16:12:00.079]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:00.079]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:00.079]                     }
[16:12:00.079]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:00.079]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:00.079]                       envir = envir)
[16:12:00.079]                     if (!future$lazy) 
[16:12:00.079]                       future <- run(future)
[16:12:00.079]                     invisible(future)
[16:12:00.079]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:00.079]                 }
[16:12:00.079]             }
[16:12:00.079]         }
[16:12:00.079]     })
[16:12:00.079]     if (TRUE) {
[16:12:00.079]         base::sink(type = "output", split = FALSE)
[16:12:00.079]         if (TRUE) {
[16:12:00.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:00.079]         }
[16:12:00.079]         else {
[16:12:00.079]             ...future.result["stdout"] <- base::list(NULL)
[16:12:00.079]         }
[16:12:00.079]         base::close(...future.stdout)
[16:12:00.079]         ...future.stdout <- NULL
[16:12:00.079]     }
[16:12:00.079]     ...future.result$conditions <- ...future.conditions
[16:12:00.079]     ...future.result$finished <- base::Sys.time()
[16:12:00.079]     ...future.result
[16:12:00.079] }
[16:12:00.081] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:00.092] receiveMessageFromWorker() for ClusterFuture ...
[16:12:00.092] - Validating connection of MultisessionFuture
[16:12:00.093] - received message: FutureResult
[16:12:00.093] - Received FutureResult
[16:12:00.093] - Erased future from FutureRegistry
[16:12:00.093] result() for ClusterFuture ...
[16:12:00.093] - result already collected: FutureResult
[16:12:00.093] result() for ClusterFuture ... done
[16:12:00.093] signalConditions() ...
[16:12:00.093]  - include = ‘immediateCondition’
[16:12:00.093]  - exclude = 
[16:12:00.094]  - resignal = FALSE
[16:12:00.094]  - Number of conditions: 2
[16:12:00.094] signalConditions() ... done
[16:12:00.094] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:00.094] result() for ClusterFuture ...
[16:12:00.094] - result already collected: FutureResult
[16:12:00.094] result() for ClusterFuture ... done
[16:12:00.094] result() for ClusterFuture ...
[16:12:00.094] - result already collected: FutureResult
[16:12:00.094] result() for ClusterFuture ... done
[16:12:00.094] signalConditions() ...
[16:12:00.095]  - include = ‘immediateCondition’
[16:12:00.095]  - exclude = 
[16:12:00.095]  - resignal = FALSE
[16:12:00.095]  - Number of conditions: 2
[16:12:00.095] signalConditions() ... done
[16:12:00.095] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[16:12:00.096] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:12:00.096] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:12:00.096] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[16:12:00.097] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[16:12:00.097] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[16:12:00.140] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[16:12:00.140] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[16:12:00.184] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[16:12:00.184] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[16:12:00.185] MultisessionFuture started
[16:12:00.185] - Launch lazy future ... done
[16:12:00.185] run() for ‘MultisessionFuture’ ... done
[16:12:00.185] - run() ... done
[16:12:00.185] - resolved() ...
[16:12:00.196] - resolved: FALSE
[16:12:00.196] - resolved() ... done
[16:12:00.196] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[16:12:00.196] result() for ClusterFuture ...
[16:12:00.196] - result already collected: FutureResult
[16:12:00.197] result() for ClusterFuture ... done
[16:12:00.197] result() for ClusterFuture ...
[16:12:00.197] - result already collected: FutureResult
[16:12:00.197] result() for ClusterFuture ... done
[16:12:00.197] signalConditions() ...
[16:12:00.197]  - include = ‘immediateCondition’
[16:12:00.197]  - exclude = 
[16:12:00.197]  - resignal = FALSE
[16:12:00.197]  - Number of conditions: 2
[16:12:00.197] signalConditions() ... done
[16:12:00.198] Future state: ‘finished’
[16:12:00.198] result() for ClusterFuture ...
[16:12:00.198] - result already collected: FutureResult
[16:12:00.198] result() for ClusterFuture ... done
[16:12:00.198] signalConditions() ...
[16:12:00.198]  - include = ‘condition’
[16:12:00.198]  - exclude = ‘immediateCondition’
[16:12:00.198]  - resignal = TRUE
[16:12:00.198]  - Number of conditions: 2
[16:12:00.198]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[16:12:00.198]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:12:00.199] signalConditions() ... done
Plotting tile #2 of 4 ...
[16:12:00.202] result() for ClusterFuture ...
[16:12:00.202] - result already collected: FutureResult
[16:12:00.202] result() for ClusterFuture ... done
[16:12:00.202] result() for ClusterFuture ...
[16:12:00.202] - result already collected: FutureResult
[16:12:00.202] result() for ClusterFuture ... done
[16:12:00.202] signalConditions() ...
[16:12:00.202]  - include = ‘immediateCondition’
[16:12:00.202]  - exclude = 
[16:12:00.202]  - resignal = FALSE
[16:12:00.202]  - Number of conditions: 2
[16:12:00.203] signalConditions() ... done
[16:12:00.203] Future state: ‘finished’
[16:12:00.203] result() for ClusterFuture ...
[16:12:00.203] - result already collected: FutureResult
[16:12:00.203] result() for ClusterFuture ... done
[16:12:00.203] signalConditions() ...
[16:12:00.203]  - include = ‘condition’
[16:12:00.203]  - exclude = ‘immediateCondition’
[16:12:00.203]  - resignal = TRUE
[16:12:00.203]  - Number of conditions: 2
[16:12:00.203]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[16:12:00.204]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:12:00.204] signalConditions() ... done
[16:12:00.205] receiveMessageFromWorker() for ClusterFuture ...
[16:12:00.205] - Validating connection of MultisessionFuture
[16:12:00.205] - received message: FutureResult
[16:12:00.205] - Received FutureResult
[16:12:00.205] - Erased future from FutureRegistry
[16:12:00.206] result() for ClusterFuture ...
[16:12:00.206] - result already collected: FutureResult
[16:12:00.206] result() for ClusterFuture ... done
[16:12:00.206] signalConditions() ...
[16:12:00.206]  - include = ‘immediateCondition’
[16:12:00.206]  - exclude = 
[16:12:00.206]  - resignal = FALSE
[16:12:00.206]  - Number of conditions: 2
[16:12:00.206] signalConditions() ... done
[16:12:00.206] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[16:12:00.206] result() for ClusterFuture ...
[16:12:00.207] - result already collected: FutureResult
[16:12:00.207] result() for ClusterFuture ... done
[16:12:00.207] result() for ClusterFuture ...
[16:12:00.207] - result already collected: FutureResult
[16:12:00.207] result() for ClusterFuture ... done
[16:12:00.207] signalConditions() ...
[16:12:00.207]  - include = ‘immediateCondition’
[16:12:00.207]  - exclude = 
[16:12:00.207]  - resignal = FALSE
[16:12:00.207]  - Number of conditions: 2
[16:12:00.207] signalConditions() ... done
[16:12:00.207] Future state: ‘finished’
[16:12:00.208] result() for ClusterFuture ...
[16:12:00.208] - result already collected: FutureResult
[16:12:00.208] result() for ClusterFuture ... done
[16:12:00.208] signalConditions() ...
[16:12:00.208]  - include = ‘condition’
[16:12:00.208]  - exclude = ‘immediateCondition’
[16:12:00.208]  - resignal = TRUE
[16:12:00.208]  - Number of conditions: 2
[16:12:00.208]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[16:12:00.208]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:12:00.209] signalConditions() ... done
[16:12:00.248] receiveMessageFromWorker() for ClusterFuture ...
[16:12:00.249] - Validating connection of MultisessionFuture
[16:12:00.249] - received message: FutureResult
[16:12:00.249] - Received FutureResult
[16:12:00.249] - Erased future from FutureRegistry
[16:12:00.249] result() for ClusterFuture ...
[16:12:00.249] - result already collected: FutureResult
[16:12:00.249] result() for ClusterFuture ... done
[16:12:00.250] signalConditions() ...
[16:12:00.250]  - include = ‘immediateCondition’
[16:12:00.250]  - exclude = 
[16:12:00.250]  - resignal = FALSE
[16:12:00.250]  - Number of conditions: 2
[16:12:00.250] signalConditions() ... done
[16:12:00.250] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[16:12:00.250] result() for ClusterFuture ...
[16:12:00.250] - result already collected: FutureResult
[16:12:00.250] result() for ClusterFuture ... done
[16:12:00.251] result() for ClusterFuture ...
[16:12:00.251] - result already collected: FutureResult
[16:12:00.251] result() for ClusterFuture ... done
[16:12:00.251] signalConditions() ...
[16:12:00.251]  - include = ‘immediateCondition’
[16:12:00.251]  - exclude = 
[16:12:00.251]  - resignal = FALSE
[16:12:00.251]  - Number of conditions: 2
[16:12:00.251] signalConditions() ... done
[16:12:00.251] Future state: ‘finished’
[16:12:00.251] result() for ClusterFuture ...
[16:12:00.251] - result already collected: FutureResult
[16:12:00.252] result() for ClusterFuture ... done
[16:12:00.252] signalConditions() ...
[16:12:00.252]  - include = ‘condition’
[16:12:00.252]  - exclude = ‘immediateCondition’
[16:12:00.252]  - resignal = TRUE
[16:12:00.252]  - Number of conditions: 2
[16:12:00.252]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[16:12:00.252]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[16:12:00.252] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[16:12:00.254] plan(): Setting new future strategy stack:
[16:12:00.254] List of future strategies:
[16:12:00.254] 1. sequential:
[16:12:00.254]    - args: function (..., envir = parent.frame())
[16:12:00.254]    - tweaked: FALSE
[16:12:00.254]    - call: future::plan("sequential")
[16:12:00.255] plan(): nbrOfWorkers() = 1
> 
