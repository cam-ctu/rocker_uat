
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:19:53.732] plan(): Setting new future strategy stack:
[13:19:53.733] List of future strategies:
[13:19:53.733] 1. sequential:
[13:19:53.733]    - args: function (..., envir = parent.frame())
[13:19:53.733]    - tweaked: FALSE
[13:19:53.733]    - call: future::plan("sequential")
[13:19:53.747] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[13:19:53.762] plan(): Setting new future strategy stack:
[13:19:53.762] List of future strategies:
[13:19:53.762] 1. sequential:
[13:19:53.762]    - args: function (..., envir = parent.frame())
[13:19:53.762]    - tweaked: FALSE
[13:19:53.762]    - call: plan(sequential)
[13:19:53.773] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[13:19:53.783] getGlobalsAndPackages() ...
[13:19:53.783] Searching for globals...
[13:19:53.791] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.791] Searching for globals ... DONE
[13:19:53.791] Resolving globals: FALSE
[13:19:53.793] The total size of the 2 globals is 224 bytes (224 bytes)
[13:19:53.793] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 224 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (168 bytes of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.793] - globals: [2] ‘x’, ‘i’
[13:19:53.793] 
[13:19:53.794] getGlobalsAndPackages() ... DONE
[13:19:53.795] getGlobalsAndPackages() ...
[13:19:53.795] Searching for globals...
[13:19:53.796] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.796] Searching for globals ... DONE
[13:19:53.796] Resolving globals: FALSE
[13:19:53.797] The total size of the 2 globals is 8.41 KiB (8608 bytes)
[13:19:53.798] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 8.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (8.35 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.798] - globals: [2] ‘x’, ‘i’
[13:19:53.798] 
[13:19:53.798] getGlobalsAndPackages() ... DONE
[13:19:53.798] getGlobalsAndPackages() ...
[13:19:53.799] Searching for globals...
[13:19:53.800] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.800] Searching for globals ... DONE
[13:19:53.800] Resolving globals: FALSE
[13:19:53.801] The total size of the 2 globals is 16.76 KiB (17160 bytes)
[13:19:53.802] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 16.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (16.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.802] - globals: [2] ‘x’, ‘i’
[13:19:53.802] 
[13:19:53.802] getGlobalsAndPackages() ... DONE
[13:19:53.803] getGlobalsAndPackages() ...
[13:19:53.803] Searching for globals...
[13:19:53.804] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.804] Searching for globals ... DONE
[13:19:53.804] Resolving globals: FALSE
[13:19:53.806] The total size of the 2 globals is 25.11 KiB (25712 bytes)
[13:19:53.806] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 25.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (25.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.806] - globals: [2] ‘x’, ‘i’
[13:19:53.806] 
[13:19:53.806] getGlobalsAndPackages() ... DONE
[13:19:53.807] getGlobalsAndPackages() ...
[13:19:53.807] Searching for globals...
[13:19:53.808] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.808] Searching for globals ... DONE
[13:19:53.809] Resolving globals: FALSE
[13:19:53.812] The total size of the 2 globals is 33.46 KiB (34264 bytes)
[13:19:53.813] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.813] - globals: [2] ‘x’, ‘i’
[13:19:53.813] 
[13:19:53.813] getGlobalsAndPackages() ... DONE
[13:19:53.814] getGlobalsAndPackages() ...
[13:19:53.814] Searching for globals...
[13:19:53.815] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.816] Searching for globals ... DONE
[13:19:53.816] Resolving globals: FALSE
[13:19:53.818] The total size of the 2 globals is 41.81 KiB (42816 bytes)
[13:19:53.818] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 41.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (41.76 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.818] - globals: [2] ‘x’, ‘i’
[13:19:53.818] 
[13:19:53.818] getGlobalsAndPackages() ... DONE
[13:19:53.819] getGlobalsAndPackages() ...
[13:19:53.819] Searching for globals...
[13:19:53.821] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.821] Searching for globals ... DONE
[13:19:53.821] Resolving globals: FALSE
[13:19:53.823] The total size of the 2 globals is 50.16 KiB (51368 bytes)
[13:19:53.823] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 50.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (50.11 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.823] - globals: [2] ‘x’, ‘i’
[13:19:53.823] 
[13:19:53.824] getGlobalsAndPackages() ... DONE
[13:19:53.824] getGlobalsAndPackages() ...
[13:19:53.824] Searching for globals...
[13:19:53.826] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.826] Searching for globals ... DONE
[13:19:53.826] Resolving globals: FALSE
[13:19:53.828] The total size of the 2 globals is 58.52 KiB (59920 bytes)
[13:19:53.829] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 58.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (58.46 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.829] - globals: [2] ‘x’, ‘i’
[13:19:53.829] 
[13:19:53.829] getGlobalsAndPackages() ... DONE
[13:19:53.830] getGlobalsAndPackages() ...
[13:19:53.830] Searching for globals...
[13:19:53.831] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.831] Searching for globals ... DONE
[13:19:53.831] Resolving globals: FALSE
[13:19:53.836] The total size of the 2 globals is 66.87 KiB (68472 bytes)
[13:19:53.836] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 66.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (66.81 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.836] - globals: [2] ‘x’, ‘i’
[13:19:53.836] 
[13:19:53.836] getGlobalsAndPackages() ... DONE
[13:19:53.837] getGlobalsAndPackages() ...
[13:19:53.837] Searching for globals...
[13:19:53.839] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.839] Searching for globals ... DONE
[13:19:53.839] Resolving globals: FALSE
[13:19:53.842] The total size of the 2 globals is 75.22 KiB (77024 bytes)
[13:19:53.842] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 75.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (75.16 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.842] - globals: [2] ‘x’, ‘i’
[13:19:53.842] 
[13:19:53.842] getGlobalsAndPackages() ... DONE
[13:19:53.843] getGlobalsAndPackages() ...
[13:19:53.843] Searching for globals...
[13:19:53.845] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.845] Searching for globals ... DONE
[13:19:53.845] Resolving globals: FALSE
[13:19:53.848] The total size of the 2 globals is 83.57 KiB (85576 bytes)
[13:19:53.848] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 83.57 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (83.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.848] - globals: [2] ‘x’, ‘i’
[13:19:53.849] 
[13:19:53.849] getGlobalsAndPackages() ... DONE
[13:19:53.849] getGlobalsAndPackages() ...
[13:19:53.849] Searching for globals...
[13:19:53.851] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.851] Searching for globals ... DONE
[13:19:53.851] Resolving globals: FALSE
[13:19:53.854] The total size of the 2 globals is 91.92 KiB (94128 bytes)
[13:19:53.855] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 91.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (91.87 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.855] - globals: [2] ‘x’, ‘i’
[13:19:53.857] 
[13:19:53.857] getGlobalsAndPackages() ... DONE
[13:19:53.857] getGlobalsAndPackages() ...
[13:19:53.858] Searching for globals...
[13:19:53.859] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.859] Searching for globals ... DONE
[13:19:53.859] Resolving globals: FALSE
[13:19:53.863] The total size of the 2 globals is 100.27 KiB (102680 bytes)
[13:19:53.863] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 100.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (100.22 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.864] - globals: [2] ‘x’, ‘i’
[13:19:53.864] 
[13:19:53.864] getGlobalsAndPackages() ... DONE
[13:19:53.865] getGlobalsAndPackages() ...
[13:19:53.865] Searching for globals...
[13:19:53.867] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.867] Searching for globals ... DONE
[13:19:53.867] Resolving globals: FALSE
[13:19:53.871] The total size of the 2 globals is 108.62 KiB (111232 bytes)
[13:19:53.871] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 108.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (108.57 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.871] - globals: [2] ‘x’, ‘i’
[13:19:53.871] 
[13:19:53.872] getGlobalsAndPackages() ... DONE
[13:19:53.872] getGlobalsAndPackages() ...
[13:19:53.872] Searching for globals...
[13:19:53.874] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.874] Searching for globals ... DONE
[13:19:53.874] Resolving globals: FALSE
[13:19:53.880] The total size of the 2 globals is 116.98 KiB (119784 bytes)
[13:19:53.880] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 116.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (116.92 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.880] - globals: [2] ‘x’, ‘i’
[13:19:53.880] 
[13:19:53.880] getGlobalsAndPackages() ... DONE
[13:19:53.881] getGlobalsAndPackages() ...
[13:19:53.881] Searching for globals...
[13:19:53.883] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.883] Searching for globals ... DONE
[13:19:53.883] Resolving globals: FALSE
[13:19:53.887] The total size of the 2 globals is 125.33 KiB (128336 bytes)
[13:19:53.888] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 125.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (125.27 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.888] - globals: [2] ‘x’, ‘i’
[13:19:53.888] 
[13:19:53.888] getGlobalsAndPackages() ... DONE
[13:19:53.889] getGlobalsAndPackages() ...
[13:19:53.889] Searching for globals...
[13:19:53.890] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.890] Searching for globals ... DONE
[13:19:53.891] Resolving globals: FALSE
[13:19:53.895] The total size of the 2 globals is 133.68 KiB (136888 bytes)
[13:19:53.895] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 133.68 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133.62 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.896] - globals: [2] ‘x’, ‘i’
[13:19:53.896] 
[13:19:53.896] getGlobalsAndPackages() ... DONE
[13:19:53.896] getGlobalsAndPackages() ...
[13:19:53.896] Searching for globals...
[13:19:53.899] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.900] Searching for globals ... DONE
[13:19:53.900] Resolving globals: FALSE
[13:19:53.905] The total size of the 2 globals is 142.03 KiB (145440 bytes)
[13:19:53.905] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 142.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (141.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.905] - globals: [2] ‘x’, ‘i’
[13:19:53.905] 
[13:19:53.905] getGlobalsAndPackages() ... DONE
[13:19:53.906] getGlobalsAndPackages() ...
[13:19:53.906] Searching for globals...
[13:19:53.908] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.908] Searching for globals ... DONE
[13:19:53.908] Resolving globals: FALSE
[13:19:53.913] The total size of the 2 globals is 150.38 KiB (153992 bytes)
[13:19:53.913] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 150.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (150.33 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.914] - globals: [2] ‘x’, ‘i’
[13:19:53.914] 
[13:19:53.914] getGlobalsAndPackages() ... DONE
[13:19:53.914] getGlobalsAndPackages() ...
[13:19:53.914] Searching for globals...
[13:19:53.916] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.916] Searching for globals ... DONE
[13:19:53.916] Resolving globals: FALSE
[13:19:53.923] The total size of the 2 globals is 158.73 KiB (162544 bytes)
[13:19:53.923] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 158.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (158.68 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.924] - globals: [2] ‘x’, ‘i’
[13:19:53.924] 
[13:19:53.924] getGlobalsAndPackages() ... DONE
[13:19:53.924] getGlobalsAndPackages() ...
[13:19:53.924] Searching for globals...
[13:19:53.926] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.926] Searching for globals ... DONE
[13:19:53.926] Resolving globals: FALSE
[13:19:53.932] The total size of the 2 globals is 167.09 KiB (171096 bytes)
[13:19:53.932] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 167.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (167.03 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.932] - globals: [2] ‘x’, ‘i’
[13:19:53.933] 
[13:19:53.933] getGlobalsAndPackages() ... DONE
[13:19:53.933] getGlobalsAndPackages() ...
[13:19:53.933] Searching for globals...
[13:19:53.935] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.935] Searching for globals ... DONE
[13:19:53.935] Resolving globals: FALSE
[13:19:53.943] The total size of the 2 globals is 175.44 KiB (179648 bytes)
[13:19:53.943] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 175.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (175.38 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.943] - globals: [2] ‘x’, ‘i’
[13:19:53.943] 
[13:19:53.943] getGlobalsAndPackages() ... DONE
[13:19:53.944] getGlobalsAndPackages() ...
[13:19:53.944] Searching for globals...
[13:19:53.946] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.946] Searching for globals ... DONE
[13:19:53.946] Resolving globals: FALSE
[13:19:53.952] The total size of the 2 globals is 183.79 KiB (188200 bytes)
[13:19:53.952] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 183.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (183.73 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.953] - globals: [2] ‘x’, ‘i’
[13:19:53.953] 
[13:19:53.953] getGlobalsAndPackages() ... DONE
[13:19:53.953] getGlobalsAndPackages() ...
[13:19:53.953] Searching for globals...
[13:19:53.955] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.955] Searching for globals ... DONE
[13:19:53.955] Resolving globals: FALSE
[13:19:53.963] The total size of the 2 globals is 192.14 KiB (196752 bytes)
[13:19:53.964] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 192.14 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (192.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.964] - globals: [2] ‘x’, ‘i’
[13:19:53.964] 
[13:19:53.964] getGlobalsAndPackages() ... DONE
[13:19:53.964] getGlobalsAndPackages() ...
[13:19:53.965] Searching for globals...
[13:19:53.966] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.966] Searching for globals ... DONE
[13:19:53.966] Resolving globals: FALSE
[13:19:53.973] The total size of the 2 globals is 200.49 KiB (205304 bytes)
[13:19:53.973] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 200.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (200.44 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.973] - globals: [2] ‘x’, ‘i’
[13:19:53.974] 
[13:19:53.974] getGlobalsAndPackages() ... DONE
[13:19:53.975] getGlobalsAndPackages() ...
[13:19:53.976] Searching for globals...
[13:19:53.977] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.977] Searching for globals ... DONE
[13:19:53.977] Resolving globals: FALSE
[13:19:53.984] The total size of the 2 globals is 208.84 KiB (213856 bytes)
[13:19:53.985] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 208.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (208.79 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.985] - globals: [2] ‘x’, ‘i’
[13:19:53.985] 
[13:19:53.985] getGlobalsAndPackages() ... DONE
[13:19:53.986] getGlobalsAndPackages() ...
[13:19:53.986] Searching for globals...
[13:19:53.987] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.987] Searching for globals ... DONE
[13:19:53.987] Resolving globals: FALSE
[13:19:53.996] The total size of the 2 globals is 217.20 KiB (222408 bytes)
[13:19:53.997] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 217.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (217.14 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:53.997] - globals: [2] ‘x’, ‘i’
[13:19:53.997] 
[13:19:53.997] getGlobalsAndPackages() ... DONE
[13:19:53.997] getGlobalsAndPackages() ...
[13:19:53.998] Searching for globals...
[13:19:53.999] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:53.999] Searching for globals ... DONE
[13:19:53.999] Resolving globals: FALSE
[13:19:54.007] The total size of the 2 globals is 225.55 KiB (230960 bytes)
[13:19:54.007] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 225.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (225.49 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.007] - globals: [2] ‘x’, ‘i’
[13:19:54.008] 
[13:19:54.008] getGlobalsAndPackages() ... DONE
[13:19:54.008] getGlobalsAndPackages() ...
[13:19:54.008] Searching for globals...
[13:19:54.010] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.010] Searching for globals ... DONE
[13:19:54.010] Resolving globals: FALSE
[13:19:54.020] The total size of the 2 globals is 233.90 KiB (239512 bytes)
[13:19:54.020] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 233.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (233.84 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.020] - globals: [2] ‘x’, ‘i’
[13:19:54.020] 
[13:19:54.020] getGlobalsAndPackages() ... DONE
[13:19:54.021] getGlobalsAndPackages() ...
[13:19:54.021] Searching for globals...
[13:19:54.023] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.023] Searching for globals ... DONE
[13:19:54.023] Resolving globals: FALSE
[13:19:54.032] The total size of the 2 globals is 242.25 KiB (248064 bytes)
[13:19:54.033] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.033] - globals: [2] ‘x’, ‘i’
[13:19:54.033] 
[13:19:54.033] getGlobalsAndPackages() ... DONE
[13:19:54.034] getGlobalsAndPackages() ...
[13:19:54.034] Searching for globals...
[13:19:54.035] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.035] Searching for globals ... DONE
[13:19:54.035] Resolving globals: FALSE
[13:19:54.044] The total size of the 2 globals is 250.60 KiB (256616 bytes)
[13:19:54.044] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 250.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (250.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.044] - globals: [2] ‘x’, ‘i’
[13:19:54.044] 
[13:19:54.045] getGlobalsAndPackages() ... DONE
[13:19:54.045] getGlobalsAndPackages() ...
[13:19:54.045] Searching for globals...
[13:19:54.048] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.048] Searching for globals ... DONE
[13:19:54.048] Resolving globals: FALSE
[13:19:54.057] The total size of the 2 globals is 258.95 KiB (265168 bytes)
[13:19:54.057] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 258.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (258.90 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.057] - globals: [2] ‘x’, ‘i’
[13:19:54.058] 
[13:19:54.058] getGlobalsAndPackages() ... DONE
[13:19:54.058] getGlobalsAndPackages() ...
[13:19:54.058] Searching for globals...
[13:19:54.060] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.060] Searching for globals ... DONE
[13:19:54.060] Resolving globals: FALSE
[13:19:54.070] The total size of the 2 globals is 267.30 KiB (273720 bytes)
[13:19:54.071] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 267.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (267.25 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.071] - globals: [2] ‘x’, ‘i’
[13:19:54.071] 
[13:19:54.071] getGlobalsAndPackages() ... DONE
[13:19:54.072] getGlobalsAndPackages() ...
[13:19:54.072] Searching for globals...
[13:19:54.073] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.074] Searching for globals ... DONE
[13:19:54.074] Resolving globals: FALSE
[13:19:54.084] The total size of the 2 globals is 275.66 KiB (282272 bytes)
[13:19:54.085] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 275.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (275.60 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.085] - globals: [2] ‘x’, ‘i’
[13:19:54.085] 
[13:19:54.085] getGlobalsAndPackages() ... DONE
[13:19:54.086] getGlobalsAndPackages() ...
[13:19:54.086] Searching for globals...
[13:19:54.087] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.087] Searching for globals ... DONE
[13:19:54.088] Resolving globals: FALSE
[13:19:54.097] The total size of the 2 globals is 284.01 KiB (290824 bytes)
[13:19:54.097] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 284.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (283.95 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.098] - globals: [2] ‘x’, ‘i’
[13:19:54.098] 
[13:19:54.098] getGlobalsAndPackages() ... DONE
[13:19:54.098] getGlobalsAndPackages() ...
[13:19:54.098] Searching for globals...
[13:19:54.101] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.102] Searching for globals ... DONE
[13:19:54.102] Resolving globals: FALSE
[13:19:54.112] The total size of the 2 globals is 292.36 KiB (299376 bytes)
[13:19:54.112] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 292.36 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (292.30 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.112] - globals: [2] ‘x’, ‘i’
[13:19:54.112] 
[13:19:54.112] getGlobalsAndPackages() ... DONE
[13:19:54.113] getGlobalsAndPackages() ...
[13:19:54.113] Searching for globals...
[13:19:54.115] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.115] Searching for globals ... DONE
[13:19:54.115] Resolving globals: FALSE
[13:19:54.127] The total size of the 2 globals is 300.71 KiB (307928 bytes)
[13:19:54.127] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 300.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (300.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.127] - globals: [2] ‘x’, ‘i’
[13:19:54.127] 
[13:19:54.127] getGlobalsAndPackages() ... DONE
[13:19:54.128] getGlobalsAndPackages() ...
[13:19:54.128] Searching for globals...
[13:19:54.130] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.130] Searching for globals ... DONE
[13:19:54.130] Resolving globals: FALSE
[13:19:54.168] The total size of the 2 globals is 309.06 KiB (316480 bytes)
[13:19:54.169] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 309.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (309.01 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.169] - globals: [2] ‘x’, ‘i’
[13:19:54.169] 
[13:19:54.169] getGlobalsAndPackages() ... DONE
[13:19:54.170] getGlobalsAndPackages() ...
[13:19:54.170] Searching for globals...
[13:19:54.171] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.171] Searching for globals ... DONE
[13:19:54.172] Resolving globals: FALSE
[13:19:54.184] The total size of the 2 globals is 317.41 KiB (325032 bytes)
[13:19:54.185] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 317.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (317.36 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.185] - globals: [2] ‘x’, ‘i’
[13:19:54.185] 
[13:19:54.185] getGlobalsAndPackages() ... DONE
[13:19:54.186] getGlobalsAndPackages() ...
[13:19:54.186] Searching for globals...
[13:19:54.187] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.188] Searching for globals ... DONE
[13:19:54.188] Resolving globals: FALSE
[13:19:54.200] The total size of the 2 globals is 325.77 KiB (333584 bytes)
[13:19:54.201] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 325.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (325.71 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.201] - globals: [2] ‘x’, ‘i’
[13:19:54.201] 
[13:19:54.201] getGlobalsAndPackages() ... DONE
[13:19:54.202] getGlobalsAndPackages() ...
[13:19:54.202] Searching for globals...
[13:19:54.204] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.204] Searching for globals ... DONE
[13:19:54.204] Resolving globals: FALSE
[13:19:54.215] The total size of the 2 globals is 334.12 KiB (342136 bytes)
[13:19:54.216] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 334.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (334.06 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.216] - globals: [2] ‘x’, ‘i’
[13:19:54.217] 
[13:19:54.217] getGlobalsAndPackages() ... DONE
[13:19:54.218] getGlobalsAndPackages() ...
[13:19:54.218] Searching for globals...
[13:19:54.220] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.220] Searching for globals ... DONE
[13:19:54.220] Resolving globals: FALSE
[13:19:54.232] The total size of the 2 globals is 342.47 KiB (350688 bytes)
[13:19:54.232] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 342.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (342.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.232] - globals: [2] ‘x’, ‘i’
[13:19:54.233] 
[13:19:54.233] getGlobalsAndPackages() ... DONE
[13:19:54.233] getGlobalsAndPackages() ...
[13:19:54.234] Searching for globals...
[13:19:54.237] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.237] Searching for globals ... DONE
[13:19:54.237] Resolving globals: FALSE
[13:19:54.249] The total size of the 2 globals is 350.82 KiB (359240 bytes)
[13:19:54.250] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 350.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (350.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.250] - globals: [2] ‘x’, ‘i’
[13:19:54.250] 
[13:19:54.250] getGlobalsAndPackages() ... DONE
[13:19:54.251] getGlobalsAndPackages() ...
[13:19:54.251] Searching for globals...
[13:19:54.253] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.253] Searching for globals ... DONE
[13:19:54.253] Resolving globals: FALSE
[13:19:54.267] The total size of the 2 globals is 359.17 KiB (367792 bytes)
[13:19:54.267] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 359.17 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (359.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.267] - globals: [2] ‘x’, ‘i’
[13:19:54.267] 
[13:19:54.268] getGlobalsAndPackages() ... DONE
[13:19:54.268] getGlobalsAndPackages() ...
[13:19:54.268] Searching for globals...
[13:19:54.270] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.270] Searching for globals ... DONE
[13:19:54.270] Resolving globals: FALSE
[13:19:54.284] The total size of the 2 globals is 367.52 KiB (376344 bytes)
[13:19:54.284] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 367.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (367.47 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.284] - globals: [2] ‘x’, ‘i’
[13:19:54.285] 
[13:19:54.285] getGlobalsAndPackages() ... DONE
[13:19:54.285] getGlobalsAndPackages() ...
[13:19:54.285] Searching for globals...
[13:19:54.287] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.287] Searching for globals ... DONE
[13:19:54.287] Resolving globals: FALSE
[13:19:54.301] The total size of the 2 globals is 375.88 KiB (384896 bytes)
[13:19:54.301] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 375.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (375.82 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.301] - globals: [2] ‘x’, ‘i’
[13:19:54.301] 
[13:19:54.302] getGlobalsAndPackages() ... DONE
[13:19:54.302] getGlobalsAndPackages() ...
[13:19:54.302] Searching for globals...
[13:19:54.304] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.304] Searching for globals ... DONE
[13:19:54.304] Resolving globals: FALSE
[13:19:54.318] The total size of the 2 globals is 384.23 KiB (393448 bytes)
[13:19:54.318] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 384.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (384.17 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.318] - globals: [2] ‘x’, ‘i’
[13:19:54.318] 
[13:19:54.319] getGlobalsAndPackages() ... DONE
[13:19:54.319] getGlobalsAndPackages() ...
[13:19:54.319] Searching for globals...
[13:19:54.321] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.321] Searching for globals ... DONE
[13:19:54.321] Resolving globals: FALSE
[13:19:54.335] The total size of the 2 globals is 392.58 KiB (402000 bytes)
[13:19:54.335] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 392.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (392.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.335] - globals: [2] ‘x’, ‘i’
[13:19:54.335] 
[13:19:54.335] getGlobalsAndPackages() ... DONE
[13:19:54.336] getGlobalsAndPackages() ...
[13:19:54.336] Searching for globals...
[13:19:54.338] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.338] Searching for globals ... DONE
[13:19:54.338] Resolving globals: FALSE
[13:19:54.352] The total size of the 2 globals is 400.93 KiB (410552 bytes)
[13:19:54.352] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 400.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (400.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.352] - globals: [2] ‘x’, ‘i’
[13:19:54.352] 
[13:19:54.352] getGlobalsAndPackages() ... DONE
[13:19:54.353] getGlobalsAndPackages() ...
[13:19:54.353] Searching for globals...
[13:19:54.355] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.355] Searching for globals ... DONE
[13:19:54.356] Resolving globals: FALSE
[13:19:54.369] The total size of the 2 globals is 409.28 KiB (419104 bytes)
[13:19:54.369] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 409.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (409.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.369] - globals: [2] ‘x’, ‘i’
[13:19:54.369] 
[13:19:54.370] getGlobalsAndPackages() ... DONE
[13:19:54.371] getGlobalsAndPackages() ...
[13:19:54.371] Searching for globals...
[13:19:54.372] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.372] Searching for globals ... DONE
[13:19:54.373] Resolving globals: FALSE
[13:19:54.387] The total size of the 2 globals is 417.63 KiB (427656 bytes)
[13:19:54.387] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 417.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (417.58 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.387] - globals: [2] ‘x’, ‘i’
[13:19:54.387] 
[13:19:54.387] getGlobalsAndPackages() ... DONE
[13:19:54.388] getGlobalsAndPackages() ...
[13:19:54.388] Searching for globals...
[13:19:54.389] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.390] Searching for globals ... DONE
[13:19:54.390] Resolving globals: FALSE
[13:19:54.404] The total size of the 2 globals is 425.98 KiB (436208 bytes)
[13:19:54.405] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 425.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (425.93 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.405] - globals: [2] ‘x’, ‘i’
[13:19:54.405] 
[13:19:54.405] getGlobalsAndPackages() ... DONE
[13:19:54.405] getGlobalsAndPackages() ...
[13:19:54.406] Searching for globals...
[13:19:54.407] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.407] Searching for globals ... DONE
[13:19:54.407] Resolving globals: FALSE
[13:19:54.422] The total size of the 2 globals is 434.34 KiB (444760 bytes)
[13:19:54.422] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 434.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (434.28 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.422] - globals: [2] ‘x’, ‘i’
[13:19:54.423] 
[13:19:54.423] getGlobalsAndPackages() ... DONE
[13:19:54.423] getGlobalsAndPackages() ...
[13:19:54.423] Searching for globals...
[13:19:54.425] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.425] Searching for globals ... DONE
[13:19:54.425] Resolving globals: FALSE
[13:19:54.440] The total size of the 2 globals is 442.69 KiB (453312 bytes)
[13:19:54.440] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 442.69 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (442.63 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.441] - globals: [2] ‘x’, ‘i’
[13:19:54.441] 
[13:19:54.441] getGlobalsAndPackages() ... DONE
[13:19:54.441] getGlobalsAndPackages() ...
[13:19:54.441] Searching for globals...
[13:19:54.443] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.443] Searching for globals ... DONE
[13:19:54.443] Resolving globals: FALSE
[13:19:54.459] The total size of the 2 globals is 451.04 KiB (461864 bytes)
[13:19:54.460] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 451.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (450.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.460] - globals: [2] ‘x’, ‘i’
[13:19:54.460] 
[13:19:54.460] getGlobalsAndPackages() ... DONE
[13:19:54.461] getGlobalsAndPackages() ...
[13:19:54.461] Searching for globals...
[13:19:54.462] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.463] Searching for globals ... DONE
[13:19:54.463] Resolving globals: FALSE
[13:19:54.481] The total size of the 2 globals is 459.39 KiB (470416 bytes)
[13:19:54.481] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 459.39 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (459.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.481] - globals: [2] ‘x’, ‘i’
[13:19:54.481] 
[13:19:54.482] getGlobalsAndPackages() ... DONE
[13:19:54.482] getGlobalsAndPackages() ...
[13:19:54.482] Searching for globals...
[13:19:54.484] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.484] Searching for globals ... DONE
[13:19:54.484] Resolving globals: FALSE
[13:19:54.500] The total size of the 2 globals is 467.74 KiB (478968 bytes)
[13:19:54.500] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 467.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (467.69 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.500] - globals: [2] ‘x’, ‘i’
[13:19:54.501] 
[13:19:54.501] getGlobalsAndPackages() ... DONE
[13:19:54.501] getGlobalsAndPackages() ...
[13:19:54.501] Searching for globals...
[13:19:54.503] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.503] Searching for globals ... DONE
[13:19:54.503] Resolving globals: FALSE
[13:19:54.521] The total size of the 2 globals is 476.09 KiB (487520 bytes)
[13:19:54.522] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 476.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (476.04 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.522] - globals: [2] ‘x’, ‘i’
[13:19:54.522] 
[13:19:54.522] getGlobalsAndPackages() ... DONE
[13:19:54.523] getGlobalsAndPackages() ...
[13:19:54.523] Searching for globals...
[13:19:54.524] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.525] Searching for globals ... DONE
[13:19:54.525] Resolving globals: FALSE
[13:19:54.543] The total size of the 2 globals is 484.45 KiB (496072 bytes)
[13:19:54.544] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 484.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (484.39 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.544] - globals: [2] ‘x’, ‘i’
[13:19:54.544] 
[13:19:54.544] getGlobalsAndPackages() ... DONE
[13:19:54.545] getGlobalsAndPackages() ...
[13:19:54.545] Searching for globals...
[13:19:54.548] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.548] Searching for globals ... DONE
[13:19:54.548] Resolving globals: FALSE
[13:19:54.567] The total size of the 2 globals is 492.80 KiB (504624 bytes)
[13:19:54.567] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 492.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (492.74 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.567] - globals: [2] ‘x’, ‘i’
[13:19:54.567] 
[13:19:54.567] getGlobalsAndPackages() ... DONE
[13:19:54.568] getGlobalsAndPackages() ...
[13:19:54.568] Searching for globals...
[13:19:54.570] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.570] Searching for globals ... DONE
[13:19:54.570] Resolving globals: FALSE
[13:19:54.588] The total size of the 2 globals is 501.15 KiB (513176 bytes)
[13:19:54.588] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 501.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (501.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.588] - globals: [2] ‘x’, ‘i’
[13:19:54.589] 
[13:19:54.589] getGlobalsAndPackages() ... DONE
[13:19:54.589] getGlobalsAndPackages() ...
[13:19:54.589] Searching for globals...
[13:19:54.591] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.591] Searching for globals ... DONE
[13:19:54.591] Resolving globals: FALSE
[13:19:54.609] The total size of the 2 globals is 509.50 KiB (521728 bytes)
[13:19:54.610] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.45 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.610] - globals: [2] ‘x’, ‘i’
[13:19:54.610] 
[13:19:54.610] getGlobalsAndPackages() ... DONE
[13:19:54.612] getGlobalsAndPackages() ...
[13:19:54.612] Searching for globals...
[13:19:54.614] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.614] Searching for globals ... DONE
[13:19:54.614] Resolving globals: FALSE
[13:19:54.634] The total size of the 2 globals is 517.85 KiB (530280 bytes)
[13:19:54.634] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 517.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (517.80 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.634] - globals: [2] ‘x’, ‘i’
[13:19:54.635] 
[13:19:54.635] getGlobalsAndPackages() ... DONE
[13:19:54.635] getGlobalsAndPackages() ...
[13:19:54.635] Searching for globals...
[13:19:54.637] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.637] Searching for globals ... DONE
[13:19:54.637] Resolving globals: FALSE
[13:19:54.657] The total size of the 2 globals is 526.20 KiB (538832 bytes)
[13:19:54.658] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 526.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (526.15 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.658] - globals: [2] ‘x’, ‘i’
[13:19:54.658] 
[13:19:54.658] getGlobalsAndPackages() ... DONE
[13:19:54.659] getGlobalsAndPackages() ...
[13:19:54.659] Searching for globals...
[13:19:54.660] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.660] Searching for globals ... DONE
[13:19:54.661] Resolving globals: FALSE
[13:19:54.683] The total size of the 2 globals is 534.55 KiB (547384 bytes)
[13:19:54.683] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 534.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (534.50 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.684] - globals: [2] ‘x’, ‘i’
[13:19:54.684] 
[13:19:54.684] getGlobalsAndPackages() ... DONE
[13:19:54.685] getGlobalsAndPackages() ...
[13:19:54.685] Searching for globals...
[13:19:54.686] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.686] Searching for globals ... DONE
[13:19:54.687] Resolving globals: FALSE
[13:19:54.707] The total size of the 2 globals is 542.91 KiB (555936 bytes)
[13:19:54.708] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 542.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (542.85 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.708] - globals: [2] ‘x’, ‘i’
[13:19:54.708] 
[13:19:54.708] getGlobalsAndPackages() ... DONE
[13:19:54.709] getGlobalsAndPackages() ...
[13:19:54.709] Searching for globals...
[13:19:54.710] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.711] Searching for globals ... DONE
[13:19:54.711] Resolving globals: FALSE
[13:19:54.733] The total size of the 2 globals is 551.26 KiB (564488 bytes)
[13:19:54.733] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 551.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (551.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.733] - globals: [2] ‘x’, ‘i’
[13:19:54.734] 
[13:19:54.734] getGlobalsAndPackages() ... DONE
[13:19:54.734] getGlobalsAndPackages() ...
[13:19:54.734] Searching for globals...
[13:19:54.736] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.736] Searching for globals ... DONE
[13:19:54.736] Resolving globals: FALSE
[13:19:54.756] The total size of the 2 globals is 559.61 KiB (573040 bytes)
[13:19:54.757] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 559.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (559.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.757] - globals: [2] ‘x’, ‘i’
[13:19:54.757] 
[13:19:54.757] getGlobalsAndPackages() ... DONE
[13:19:54.758] getGlobalsAndPackages() ...
[13:19:54.758] Searching for globals...
[13:19:54.759] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.759] Searching for globals ... DONE
[13:19:54.759] Resolving globals: FALSE
[13:19:54.781] The total size of the 2 globals is 567.96 KiB (581592 bytes)
[13:19:54.781] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 567.96 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (567.91 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.781] - globals: [2] ‘x’, ‘i’
[13:19:54.781] 
[13:19:54.782] getGlobalsAndPackages() ... DONE
[13:19:54.782] getGlobalsAndPackages() ...
[13:19:54.782] Searching for globals...
[13:19:54.784] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.784] Searching for globals ... DONE
[13:19:54.784] Resolving globals: FALSE
[13:19:54.805] The total size of the 2 globals is 576.31 KiB (590144 bytes)
[13:19:54.805] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 576.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (576.26 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.806] - globals: [2] ‘x’, ‘i’
[13:19:54.806] 
[13:19:54.806] getGlobalsAndPackages() ... DONE
[13:19:54.807] getGlobalsAndPackages() ...
[13:19:54.808] Searching for globals...
[13:19:54.809] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.809] Searching for globals ... DONE
[13:19:54.809] Resolving globals: FALSE
[13:19:54.831] The total size of the 2 globals is 584.66 KiB (598696 bytes)
[13:19:54.831] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 584.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (584.61 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.831] - globals: [2] ‘x’, ‘i’
[13:19:54.831] 
[13:19:54.831] getGlobalsAndPackages() ... DONE
[13:19:54.832] getGlobalsAndPackages() ...
[13:19:54.832] Searching for globals...
[13:19:54.834] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.834] Searching for globals ... DONE
[13:19:54.834] Resolving globals: FALSE
[13:19:54.856] The total size of the 2 globals is 593.02 KiB (607248 bytes)
[13:19:54.857] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 593.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (592.96 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.857] - globals: [2] ‘x’, ‘i’
[13:19:54.857] 
[13:19:54.857] getGlobalsAndPackages() ... DONE
[13:19:54.857] getGlobalsAndPackages() ...
[13:19:54.858] Searching for globals...
[13:19:54.859] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.859] Searching for globals ... DONE
[13:19:54.859] Resolving globals: FALSE
[13:19:54.880] The total size of the 2 globals is 601.37 KiB (615800 bytes)
[13:19:54.881] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 601.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (601.31 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.881] - globals: [2] ‘x’, ‘i’
[13:19:54.881] 
[13:19:54.881] getGlobalsAndPackages() ... DONE
[13:19:54.882] getGlobalsAndPackages() ...
[13:19:54.882] Searching for globals...
[13:19:54.884] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.884] Searching for globals ... DONE
[13:19:54.885] Resolving globals: FALSE
[13:19:54.906] The total size of the 2 globals is 609.72 KiB (624352 bytes)
[13:19:54.906] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 609.72 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (609.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.906] - globals: [2] ‘x’, ‘i’
[13:19:54.907] 
[13:19:54.907] getGlobalsAndPackages() ... DONE
[13:19:54.907] getGlobalsAndPackages() ...
[13:19:54.907] Searching for globals...
[13:19:54.909] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.909] Searching for globals ... DONE
[13:19:54.909] Resolving globals: FALSE
[13:19:54.932] The total size of the 2 globals is 618.07 KiB (632904 bytes)
[13:19:54.932] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 618.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (618.02 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.932] - globals: [2] ‘x’, ‘i’
[13:19:54.932] 
[13:19:54.933] getGlobalsAndPackages() ... DONE
[13:19:54.933] getGlobalsAndPackages() ...
[13:19:54.933] Searching for globals...
[13:19:54.935] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.935] Searching for globals ... DONE
[13:19:54.935] Resolving globals: FALSE
[13:19:54.958] The total size of the 2 globals is 626.42 KiB (641456 bytes)
[13:19:54.958] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 626.42 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (626.37 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.958] - globals: [2] ‘x’, ‘i’
[13:19:54.959] 
[13:19:54.959] getGlobalsAndPackages() ... DONE
[13:19:54.959] getGlobalsAndPackages() ...
[13:19:54.959] Searching for globals...
[13:19:54.961] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.961] Searching for globals ... DONE
[13:19:54.961] Resolving globals: FALSE
[13:19:54.984] The total size of the 2 globals is 634.77 KiB (650008 bytes)
[13:19:54.985] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 634.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (634.72 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:54.985] - globals: [2] ‘x’, ‘i’
[13:19:54.985] 
[13:19:54.985] getGlobalsAndPackages() ... DONE
[13:19:54.985] getGlobalsAndPackages() ...
[13:19:54.986] Searching for globals...
[13:19:54.987] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:54.987] Searching for globals ... DONE
[13:19:54.987] Resolving globals: FALSE
[13:19:55.012] The total size of the 2 globals is 643.12 KiB (658560 bytes)
[13:19:55.012] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 643.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (643.07 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.012] - globals: [2] ‘x’, ‘i’
[13:19:55.012] 
[13:19:55.013] getGlobalsAndPackages() ... DONE
[13:19:55.013] getGlobalsAndPackages() ...
[13:19:55.013] Searching for globals...
[13:19:55.015] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.015] Searching for globals ... DONE
[13:19:55.015] Resolving globals: FALSE
[13:19:55.040] The total size of the 2 globals is 651.48 KiB (667112 bytes)
[13:19:55.040] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 651.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (651.42 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.040] - globals: [2] ‘x’, ‘i’
[13:19:55.040] 
[13:19:55.040] getGlobalsAndPackages() ... DONE
[13:19:55.041] getGlobalsAndPackages() ...
[13:19:55.041] Searching for globals...
[13:19:55.043] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.043] Searching for globals ... DONE
[13:19:55.043] Resolving globals: FALSE
[13:19:55.068] The total size of the 2 globals is 659.83 KiB (675664 bytes)
[13:19:55.068] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 659.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (659.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.068] - globals: [2] ‘x’, ‘i’
[13:19:55.069] 
[13:19:55.069] getGlobalsAndPackages() ... DONE
[13:19:55.069] getGlobalsAndPackages() ...
[13:19:55.069] Searching for globals...
[13:19:55.071] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.071] Searching for globals ... DONE
[13:19:55.071] Resolving globals: FALSE
[13:19:55.098] The total size of the 2 globals is 668.18 KiB (684216 bytes)
[13:19:55.099] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 668.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (668.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.099] - globals: [2] ‘x’, ‘i’
[13:19:55.099] 
[13:19:55.099] getGlobalsAndPackages() ... DONE
[13:19:55.100] getGlobalsAndPackages() ...
[13:19:55.100] Searching for globals...
[13:19:55.101] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.101] Searching for globals ... DONE
[13:19:55.102] Resolving globals: FALSE
[13:19:55.128] The total size of the 2 globals is 676.53 KiB (692768 bytes)
[13:19:55.128] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 676.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (676.48 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.128] - globals: [2] ‘x’, ‘i’
[13:19:55.129] 
[13:19:55.129] getGlobalsAndPackages() ... DONE
[13:19:55.129] getGlobalsAndPackages() ...
[13:19:55.129] Searching for globals...
[13:19:55.131] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.131] Searching for globals ... DONE
[13:19:55.131] Resolving globals: FALSE
[13:19:55.159] The total size of the 2 globals is 684.88 KiB (701320 bytes)
[13:19:55.159] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 684.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (684.83 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.159] - globals: [2] ‘x’, ‘i’
[13:19:55.159] 
[13:19:55.160] getGlobalsAndPackages() ... DONE
[13:19:55.160] getGlobalsAndPackages() ...
[13:19:55.160] Searching for globals...
[13:19:55.162] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.162] Searching for globals ... DONE
[13:19:55.162] Resolving globals: FALSE
[13:19:55.190] The total size of the 2 globals is 693.23 KiB (709872 bytes)
[13:19:55.191] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 693.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (693.18 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.191] - globals: [2] ‘x’, ‘i’
[13:19:55.191] 
[13:19:55.191] getGlobalsAndPackages() ... DONE
[13:19:55.192] getGlobalsAndPackages() ...
[13:19:55.192] Searching for globals...
[13:19:55.194] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.194] Searching for globals ... DONE
[13:19:55.194] Resolving globals: FALSE
[13:19:55.221] The total size of the 2 globals is 701.59 KiB (718424 bytes)
[13:19:55.221] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 701.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (701.53 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.221] - globals: [2] ‘x’, ‘i’
[13:19:55.221] 
[13:19:55.221] getGlobalsAndPackages() ... DONE
[13:19:55.222] getGlobalsAndPackages() ...
[13:19:55.222] Searching for globals...
[13:19:55.224] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.224] Searching for globals ... DONE
[13:19:55.224] Resolving globals: FALSE
[13:19:55.252] The total size of the 2 globals is 709.94 KiB (726976 bytes)
[13:19:55.252] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 709.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (709.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.253] - globals: [2] ‘x’, ‘i’
[13:19:55.253] 
[13:19:55.253] getGlobalsAndPackages() ... DONE
[13:19:55.254] getGlobalsAndPackages() ...
[13:19:55.254] Searching for globals...
[13:19:55.255] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.256] Searching for globals ... DONE
[13:19:55.256] Resolving globals: FALSE
[13:19:55.284] The total size of the 2 globals is 718.29 KiB (735528 bytes)
[13:19:55.284] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.284] - globals: [2] ‘x’, ‘i’
[13:19:55.285] 
[13:19:55.285] getGlobalsAndPackages() ... DONE
[13:19:55.285] getGlobalsAndPackages() ...
[13:19:55.285] Searching for globals...
[13:19:55.287] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.287] Searching for globals ... DONE
[13:19:55.287] Resolving globals: FALSE
[13:19:55.316] The total size of the 2 globals is 726.64 KiB (744080 bytes)
[13:19:55.317] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 726.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (726.59 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.317] - globals: [2] ‘x’, ‘i’
[13:19:55.317] 
[13:19:55.317] getGlobalsAndPackages() ... DONE
[13:19:55.318] getGlobalsAndPackages() ...
[13:19:55.318] Searching for globals...
[13:19:55.320] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.320] Searching for globals ... DONE
[13:19:55.320] Resolving globals: FALSE
[13:19:55.350] The total size of the 2 globals is 734.99 KiB (752632 bytes)
[13:19:55.350] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 734.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (734.94 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.351] - globals: [2] ‘x’, ‘i’
[13:19:55.351] 
[13:19:55.351] getGlobalsAndPackages() ... DONE
[13:19:55.351] getGlobalsAndPackages() ...
[13:19:55.352] Searching for globals...
[13:19:55.353] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.353] Searching for globals ... DONE
[13:19:55.353] Resolving globals: FALSE
[13:19:55.383] The total size of the 2 globals is 743.34 KiB (761184 bytes)
[13:19:55.383] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 743.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (743.29 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.384] - globals: [2] ‘x’, ‘i’
[13:19:55.384] 
[13:19:55.384] getGlobalsAndPackages() ... DONE
[13:19:55.384] getGlobalsAndPackages() ...
[13:19:55.384] Searching for globals...
[13:19:55.386] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.386] Searching for globals ... DONE
[13:19:55.386] Resolving globals: FALSE
[13:19:55.417] The total size of the 2 globals is 751.70 KiB (769736 bytes)
[13:19:55.418] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 751.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (751.64 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.418] - globals: [2] ‘x’, ‘i’
[13:19:55.418] 
[13:19:55.418] getGlobalsAndPackages() ... DONE
[13:19:55.419] getGlobalsAndPackages() ...
[13:19:55.419] Searching for globals...
[13:19:55.421] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.421] Searching for globals ... DONE
[13:19:55.421] Resolving globals: FALSE
[13:19:55.453] The total size of the 2 globals is 760.05 KiB (778288 bytes)
[13:19:55.453] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 760.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (759.99 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.454] - globals: [2] ‘x’, ‘i’
[13:19:55.454] 
[13:19:55.454] getGlobalsAndPackages() ... DONE
[13:19:55.454] getGlobalsAndPackages() ...
[13:19:55.455] Searching for globals...
[13:19:55.456] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.456] Searching for globals ... DONE
[13:19:55.456] Resolving globals: FALSE
[13:19:55.489] The total size of the 2 globals is 768.40 KiB (786840 bytes)
[13:19:55.489] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 768.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (768.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.489] - globals: [2] ‘x’, ‘i’
[13:19:55.489] 
[13:19:55.489] getGlobalsAndPackages() ... DONE
[13:19:55.490] getGlobalsAndPackages() ...
[13:19:55.490] Searching for globals...
[13:19:55.492] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.492] Searching for globals ... DONE
[13:19:55.492] Resolving globals: FALSE
[13:19:55.524] The total size of the 2 globals is 776.75 KiB (795392 bytes)
[13:19:55.524] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 776.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (776.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.524] - globals: [2] ‘x’, ‘i’
[13:19:55.524] 
[13:19:55.524] getGlobalsAndPackages() ... DONE
[13:19:55.525] getGlobalsAndPackages() ...
[13:19:55.525] Searching for globals...
[13:19:55.527] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.527] Searching for globals ... DONE
[13:19:55.527] Resolving globals: FALSE
[13:19:55.558] The total size of the 2 globals is 785.10 KiB (803944 bytes)
[13:19:55.558] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 785.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (785.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.558] - globals: [2] ‘x’, ‘i’
[13:19:55.558] 
[13:19:55.558] getGlobalsAndPackages() ... DONE
[13:19:55.559] getGlobalsAndPackages() ...
[13:19:55.559] Searching for globals...
[13:19:55.561] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.561] Searching for globals ... DONE
[13:19:55.561] Resolving globals: FALSE
[13:19:55.591] The total size of the 2 globals is 793.45 KiB (812496 bytes)
[13:19:55.591] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 793.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (793.40 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.591] - globals: [2] ‘x’, ‘i’
[13:19:55.591] 
[13:19:55.592] getGlobalsAndPackages() ... DONE
[13:19:55.592] getGlobalsAndPackages() ...
[13:19:55.592] Searching for globals...
[13:19:55.595] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.595] Searching for globals ... DONE
[13:19:55.595] Resolving globals: FALSE
[13:19:55.625] The total size of the 2 globals is 801.80 KiB (821048 bytes)
[13:19:55.625] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 801.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (801.75 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.625] - globals: [2] ‘x’, ‘i’
[13:19:55.625] 
[13:19:55.626] getGlobalsAndPackages() ... DONE
[13:19:55.626] getGlobalsAndPackages() ...
[13:19:55.626] Searching for globals...
[13:19:55.628] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[13:19:55.628] Searching for globals ... DONE
[13:19:55.628] Resolving globals: FALSE
[13:19:55.660] The total size of the 2 globals is 810.16 KiB (829600 bytes)
[13:19:55.660] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 810.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (810.10 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[13:19:55.660] - globals: [2] ‘x’, ‘i’
[13:19:55.661] 
[13:19:55.661] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[13:19:55.662] run() for ‘Future’ ...
[13:19:55.662] - state: ‘created’
[13:19:55.662] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:55.662] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:55.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:55.663]   - Field: ‘label’
[13:19:55.663]   - Field: ‘local’
[13:19:55.663]   - Field: ‘owner’
[13:19:55.663]   - Field: ‘envir’
[13:19:55.663]   - Field: ‘packages’
[13:19:55.663]   - Field: ‘gc’
[13:19:55.663]   - Field: ‘conditions’
[13:19:55.663]   - Field: ‘expr’
[13:19:55.663]   - Field: ‘uuid’
[13:19:55.663]   - Field: ‘seed’
[13:19:55.664]   - Field: ‘version’
[13:19:55.664]   - Field: ‘result’
[13:19:55.664]   - Field: ‘asynchronous’
[13:19:55.664]   - Field: ‘calls’
[13:19:55.664]   - Field: ‘globals’
[13:19:55.664]   - Field: ‘stdout’
[13:19:55.664]   - Field: ‘earlySignal’
[13:19:55.664]   - Field: ‘lazy’
[13:19:55.664]   - Field: ‘state’
[13:19:55.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:55.664] - Launch lazy future ...
[13:19:55.665] Packages needed by the future expression (n = 0): <none>
[13:19:55.665] Packages needed by future strategies (n = 0): <none>
[13:19:55.666] {
[13:19:55.666]     {
[13:19:55.666]         {
[13:19:55.666]             ...future.startTime <- base::Sys.time()
[13:19:55.666]             {
[13:19:55.666]                 {
[13:19:55.666]                   {
[13:19:55.666]                     base::local({
[13:19:55.666]                       has_future <- base::requireNamespace("future", 
[13:19:55.666]                         quietly = TRUE)
[13:19:55.666]                       if (has_future) {
[13:19:55.666]                         ns <- base::getNamespace("future")
[13:19:55.666]                         version <- ns[[".package"]][["version"]]
[13:19:55.666]                         if (is.null(version)) 
[13:19:55.666]                           version <- utils::packageVersion("future")
[13:19:55.666]                       }
[13:19:55.666]                       else {
[13:19:55.666]                         version <- NULL
[13:19:55.666]                       }
[13:19:55.666]                       if (!has_future || version < "1.8.0") {
[13:19:55.666]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:55.666]                           "", base::R.version$version.string), 
[13:19:55.666]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:55.666]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:55.666]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:55.666]                             "release", "version")], collapse = " "), 
[13:19:55.666]                           hostname = base::Sys.info()[["nodename"]])
[13:19:55.666]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:55.666]                           info)
[13:19:55.666]                         info <- base::paste(info, collapse = "; ")
[13:19:55.666]                         if (!has_future) {
[13:19:55.666]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:55.666]                             info)
[13:19:55.666]                         }
[13:19:55.666]                         else {
[13:19:55.666]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:55.666]                             info, version)
[13:19:55.666]                         }
[13:19:55.666]                         base::stop(msg)
[13:19:55.666]                       }
[13:19:55.666]                     })
[13:19:55.666]                   }
[13:19:55.666]                   options(future.plan = NULL)
[13:19:55.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:55.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:55.666]                 }
[13:19:55.666]                 ...future.workdir <- getwd()
[13:19:55.666]             }
[13:19:55.666]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:55.666]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:55.666]         }
[13:19:55.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:55.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:55.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:55.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:55.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:55.666]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:55.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:55.666]             base::names(...future.oldOptions))
[13:19:55.666]     }
[13:19:55.666]     if (TRUE) {
[13:19:55.666]     }
[13:19:55.666]     else {
[13:19:55.666]         if (NA) {
[13:19:55.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:55.666]                 open = "w")
[13:19:55.666]         }
[13:19:55.666]         else {
[13:19:55.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:55.666]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:55.666]         }
[13:19:55.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:55.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:55.666]             base::sink(type = "output", split = FALSE)
[13:19:55.666]             base::close(...future.stdout)
[13:19:55.666]         }, add = TRUE)
[13:19:55.666]     }
[13:19:55.666]     ...future.frame <- base::sys.nframe()
[13:19:55.666]     ...future.conditions <- base::list()
[13:19:55.666]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:55.666]     if (FALSE) {
[13:19:55.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:55.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:55.666]     }
[13:19:55.666]     ...future.result <- base::tryCatch({
[13:19:55.666]         base::withCallingHandlers({
[13:19:55.666]             ...future.value <- base::withVisible(base::local({
[13:19:55.666]                 x[[i - 2]] + x[[i - 1]]
[13:19:55.666]             }))
[13:19:55.666]             future::FutureResult(value = ...future.value$value, 
[13:19:55.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:55.666]                   ...future.rng), globalenv = if (FALSE) 
[13:19:55.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:55.666]                     ...future.globalenv.names))
[13:19:55.666]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:55.666]         }, condition = base::local({
[13:19:55.666]             c <- base::c
[13:19:55.666]             inherits <- base::inherits
[13:19:55.666]             invokeRestart <- base::invokeRestart
[13:19:55.666]             length <- base::length
[13:19:55.666]             list <- base::list
[13:19:55.666]             seq.int <- base::seq.int
[13:19:55.666]             signalCondition <- base::signalCondition
[13:19:55.666]             sys.calls <- base::sys.calls
[13:19:55.666]             `[[` <- base::`[[`
[13:19:55.666]             `+` <- base::`+`
[13:19:55.666]             `<<-` <- base::`<<-`
[13:19:55.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:55.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:55.666]                   3L)]
[13:19:55.666]             }
[13:19:55.666]             function(cond) {
[13:19:55.666]                 is_error <- inherits(cond, "error")
[13:19:55.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:55.666]                   NULL)
[13:19:55.666]                 if (is_error) {
[13:19:55.666]                   sessionInformation <- function() {
[13:19:55.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:55.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:55.666]                       search = base::search(), system = base::Sys.info())
[13:19:55.666]                   }
[13:19:55.666]                   ...future.conditions[[length(...future.conditions) + 
[13:19:55.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:55.666]                     cond$call), session = sessionInformation(), 
[13:19:55.666]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:55.666]                   signalCondition(cond)
[13:19:55.666]                 }
[13:19:55.666]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[13:19:55.666]                 "immediateCondition"))) {
[13:19:55.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:55.666]                   ...future.conditions[[length(...future.conditions) + 
[13:19:55.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:55.666]                   if (TRUE && !signal) {
[13:19:55.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:55.666]                     {
[13:19:55.666]                       inherits <- base::inherits
[13:19:55.666]                       invokeRestart <- base::invokeRestart
[13:19:55.666]                       is.null <- base::is.null
[13:19:55.666]                       muffled <- FALSE
[13:19:55.666]                       if (inherits(cond, "message")) {
[13:19:55.666]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:55.666]                         if (muffled) 
[13:19:55.666]                           invokeRestart("muffleMessage")
[13:19:55.666]                       }
[13:19:55.666]                       else if (inherits(cond, "warning")) {
[13:19:55.666]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:55.666]                         if (muffled) 
[13:19:55.666]                           invokeRestart("muffleWarning")
[13:19:55.666]                       }
[13:19:55.666]                       else if (inherits(cond, "condition")) {
[13:19:55.666]                         if (!is.null(pattern)) {
[13:19:55.666]                           computeRestarts <- base::computeRestarts
[13:19:55.666]                           grepl <- base::grepl
[13:19:55.666]                           restarts <- computeRestarts(cond)
[13:19:55.666]                           for (restart in restarts) {
[13:19:55.666]                             name <- restart$name
[13:19:55.666]                             if (is.null(name)) 
[13:19:55.666]                               next
[13:19:55.666]                             if (!grepl(pattern, name)) 
[13:19:55.666]                               next
[13:19:55.666]                             invokeRestart(restart)
[13:19:55.666]                             muffled <- TRUE
[13:19:55.666]                             break
[13:19:55.666]                           }
[13:19:55.666]                         }
[13:19:55.666]                       }
[13:19:55.666]                       invisible(muffled)
[13:19:55.666]                     }
[13:19:55.666]                     muffleCondition(cond, pattern = "^muffle")
[13:19:55.666]                   }
[13:19:55.666]                 }
[13:19:55.666]                 else {
[13:19:55.666]                   if (TRUE) {
[13:19:55.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:55.666]                     {
[13:19:55.666]                       inherits <- base::inherits
[13:19:55.666]                       invokeRestart <- base::invokeRestart
[13:19:55.666]                       is.null <- base::is.null
[13:19:55.666]                       muffled <- FALSE
[13:19:55.666]                       if (inherits(cond, "message")) {
[13:19:55.666]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:55.666]                         if (muffled) 
[13:19:55.666]                           invokeRestart("muffleMessage")
[13:19:55.666]                       }
[13:19:55.666]                       else if (inherits(cond, "warning")) {
[13:19:55.666]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:55.666]                         if (muffled) 
[13:19:55.666]                           invokeRestart("muffleWarning")
[13:19:55.666]                       }
[13:19:55.666]                       else if (inherits(cond, "condition")) {
[13:19:55.666]                         if (!is.null(pattern)) {
[13:19:55.666]                           computeRestarts <- base::computeRestarts
[13:19:55.666]                           grepl <- base::grepl
[13:19:55.666]                           restarts <- computeRestarts(cond)
[13:19:55.666]                           for (restart in restarts) {
[13:19:55.666]                             name <- restart$name
[13:19:55.666]                             if (is.null(name)) 
[13:19:55.666]                               next
[13:19:55.666]                             if (!grepl(pattern, name)) 
[13:19:55.666]                               next
[13:19:55.666]                             invokeRestart(restart)
[13:19:55.666]                             muffled <- TRUE
[13:19:55.666]                             break
[13:19:55.666]                           }
[13:19:55.666]                         }
[13:19:55.666]                       }
[13:19:55.666]                       invisible(muffled)
[13:19:55.666]                     }
[13:19:55.666]                     muffleCondition(cond, pattern = "^muffle")
[13:19:55.666]                   }
[13:19:55.666]                 }
[13:19:55.666]             }
[13:19:55.666]         }))
[13:19:55.666]     }, error = function(ex) {
[13:19:55.666]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:55.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:55.666]                 ...future.rng), started = ...future.startTime, 
[13:19:55.666]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:55.666]             version = "1.8"), class = "FutureResult")
[13:19:55.666]     }, finally = {
[13:19:55.666]         if (!identical(...future.workdir, getwd())) 
[13:19:55.666]             setwd(...future.workdir)
[13:19:55.666]         {
[13:19:55.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:55.666]                 ...future.oldOptions$nwarnings <- NULL
[13:19:55.666]             }
[13:19:55.666]             base::options(...future.oldOptions)
[13:19:55.666]             if (.Platform$OS.type == "windows") {
[13:19:55.666]                 old_names <- names(...future.oldEnvVars)
[13:19:55.666]                 envs <- base::Sys.getenv()
[13:19:55.666]                 names <- names(envs)
[13:19:55.666]                 common <- intersect(names, old_names)
[13:19:55.666]                 added <- setdiff(names, old_names)
[13:19:55.666]                 removed <- setdiff(old_names, names)
[13:19:55.666]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:55.666]                   envs[common]]
[13:19:55.666]                 NAMES <- toupper(changed)
[13:19:55.666]                 args <- list()
[13:19:55.666]                 for (kk in seq_along(NAMES)) {
[13:19:55.666]                   name <- changed[[kk]]
[13:19:55.666]                   NAME <- NAMES[[kk]]
[13:19:55.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:55.666]                     next
[13:19:55.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:55.666]                 }
[13:19:55.666]                 NAMES <- toupper(added)
[13:19:55.666]                 for (kk in seq_along(NAMES)) {
[13:19:55.666]                   name <- added[[kk]]
[13:19:55.666]                   NAME <- NAMES[[kk]]
[13:19:55.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:55.666]                     next
[13:19:55.666]                   args[[name]] <- ""
[13:19:55.666]                 }
[13:19:55.666]                 NAMES <- toupper(removed)
[13:19:55.666]                 for (kk in seq_along(NAMES)) {
[13:19:55.666]                   name <- removed[[kk]]
[13:19:55.666]                   NAME <- NAMES[[kk]]
[13:19:55.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:55.666]                     next
[13:19:55.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:55.666]                 }
[13:19:55.666]                 if (length(args) > 0) 
[13:19:55.666]                   base::do.call(base::Sys.setenv, args = args)
[13:19:55.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:55.666]             }
[13:19:55.666]             else {
[13:19:55.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:55.666]             }
[13:19:55.666]             {
[13:19:55.666]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:55.666]                   0L) {
[13:19:55.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:55.666]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:55.666]                   base::options(opts)
[13:19:55.666]                 }
[13:19:55.666]                 {
[13:19:55.666]                   {
[13:19:55.666]                     NULL
[13:19:55.666]                     RNGkind("Mersenne-Twister")
[13:19:55.666]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:55.666]                       inherits = FALSE)
[13:19:55.666]                   }
[13:19:55.666]                   options(future.plan = NULL)
[13:19:55.666]                   if (is.na(NA_character_)) 
[13:19:55.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:55.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:55.666]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:55.666]                   {
[13:19:55.666]                     future <- SequentialFuture(..., envir = envir)
[13:19:55.666]                     if (!future$lazy) 
[13:19:55.666]                       future <- run(future)
[13:19:55.666]                     invisible(future)
[13:19:55.666]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:55.666]                 }
[13:19:55.666]             }
[13:19:55.666]         }
[13:19:55.666]     })
[13:19:55.666]     if (FALSE) {
[13:19:55.666]         base::sink(type = "output", split = FALSE)
[13:19:55.666]         if (NA) {
[13:19:55.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:55.666]         }
[13:19:55.666]         else {
[13:19:55.666]             ...future.result["stdout"] <- base::list(NULL)
[13:19:55.666]         }
[13:19:55.666]         base::close(...future.stdout)
[13:19:55.666]         ...future.stdout <- NULL
[13:19:55.666]     }
[13:19:55.666]     ...future.result$conditions <- ...future.conditions
[13:19:55.666]     ...future.result$finished <- base::Sys.time()
[13:19:55.666]     ...future.result
[13:19:55.666] }
[13:19:55.668] assign_globals() ...
[13:19:55.668] List of 2
[13:19:55.668]  $ x:Classes 'listenv', 'environment' <environment: 0x55d3b760cf00> 
[13:19:55.668]  $ i: int 7
[13:19:55.668]  - attr(*, "where")=List of 2
[13:19:55.668]   ..$ x:<environment: R_EmptyEnv> 
[13:19:55.668]   ..$ i:<environment: R_EmptyEnv> 
[13:19:55.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:55.668]  - attr(*, "resolved")= logi FALSE
[13:19:55.668]  - attr(*, "total_size")= num 34264
[13:19:55.668]  - attr(*, "already-done")= logi TRUE
[13:19:55.675] - copied ‘x’ to environment
[13:19:55.675] - copied ‘i’ to environment
[13:19:55.676] assign_globals() ... done
[13:19:55.676] plan(): Setting new future strategy stack:
[13:19:55.676] List of future strategies:
[13:19:55.676] 1. sequential:
[13:19:55.676]    - args: function (..., envir = parent.frame())
[13:19:55.676]    - tweaked: FALSE
[13:19:55.676]    - call: NULL
[13:19:55.676] plan(): nbrOfWorkers() = 1
[13:19:55.758] plan(): Setting new future strategy stack:
[13:19:55.758] List of future strategies:
[13:19:55.758] 1. sequential:
[13:19:55.758]    - args: function (..., envir = parent.frame())
[13:19:55.758]    - tweaked: FALSE
[13:19:55.758]    - call: plan(sequential)
[13:19:55.759] plan(): nbrOfWorkers() = 1
[13:19:55.759] SequentialFuture started (and completed)
[13:19:55.759] - Launch lazy future ... done
[13:19:55.759] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[13:19:55.759] run() for ‘Future’ ...
[13:19:55.759] - state: ‘created’
[13:19:55.760] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:55.760] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:55.760] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:55.760]   - Field: ‘label’
[13:19:55.760]   - Field: ‘local’
[13:19:55.760]   - Field: ‘owner’
[13:19:55.760]   - Field: ‘envir’
[13:19:55.760]   - Field: ‘packages’
[13:19:55.761]   - Field: ‘gc’
[13:19:55.761]   - Field: ‘conditions’
[13:19:55.761]   - Field: ‘expr’
[13:19:55.761]   - Field: ‘uuid’
[13:19:55.761]   - Field: ‘seed’
[13:19:55.761]   - Field: ‘version’
[13:19:55.761]   - Field: ‘result’
[13:19:55.761]   - Field: ‘asynchronous’
[13:19:55.761]   - Field: ‘calls’
[13:19:55.761]   - Field: ‘globals’
[13:19:55.762]   - Field: ‘stdout’
[13:19:55.762]   - Field: ‘earlySignal’
[13:19:55.762]   - Field: ‘lazy’
[13:19:55.762]   - Field: ‘state’
[13:19:55.762] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:55.762] - Launch lazy future ...
[13:19:55.762] Packages needed by the future expression (n = 0): <none>
[13:19:55.762] Packages needed by future strategies (n = 0): <none>
[13:19:55.763] {
[13:19:55.763]     {
[13:19:55.763]         {
[13:19:55.763]             ...future.startTime <- base::Sys.time()
[13:19:55.763]             {
[13:19:55.763]                 {
[13:19:55.763]                   {
[13:19:55.763]                     base::local({
[13:19:55.763]                       has_future <- base::requireNamespace("future", 
[13:19:55.763]                         quietly = TRUE)
[13:19:55.763]                       if (has_future) {
[13:19:55.763]                         ns <- base::getNamespace("future")
[13:19:55.763]                         version <- ns[[".package"]][["version"]]
[13:19:55.763]                         if (is.null(version)) 
[13:19:55.763]                           version <- utils::packageVersion("future")
[13:19:55.763]                       }
[13:19:55.763]                       else {
[13:19:55.763]                         version <- NULL
[13:19:55.763]                       }
[13:19:55.763]                       if (!has_future || version < "1.8.0") {
[13:19:55.763]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:55.763]                           "", base::R.version$version.string), 
[13:19:55.763]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:55.763]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:55.763]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:55.763]                             "release", "version")], collapse = " "), 
[13:19:55.763]                           hostname = base::Sys.info()[["nodename"]])
[13:19:55.763]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:55.763]                           info)
[13:19:55.763]                         info <- base::paste(info, collapse = "; ")
[13:19:55.763]                         if (!has_future) {
[13:19:55.763]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:55.763]                             info)
[13:19:55.763]                         }
[13:19:55.763]                         else {
[13:19:55.763]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:55.763]                             info, version)
[13:19:55.763]                         }
[13:19:55.763]                         base::stop(msg)
[13:19:55.763]                       }
[13:19:55.763]                     })
[13:19:55.763]                   }
[13:19:55.763]                   options(future.plan = NULL)
[13:19:55.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:55.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:55.763]                 }
[13:19:55.763]                 ...future.workdir <- getwd()
[13:19:55.763]             }
[13:19:55.763]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:55.763]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:55.763]         }
[13:19:55.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:55.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:55.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:55.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:55.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:55.763]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:55.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:55.763]             base::names(...future.oldOptions))
[13:19:55.763]     }
[13:19:55.763]     if (TRUE) {
[13:19:55.763]     }
[13:19:55.763]     else {
[13:19:55.763]         if (NA) {
[13:19:55.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:55.763]                 open = "w")
[13:19:55.763]         }
[13:19:55.763]         else {
[13:19:55.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:55.763]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:55.763]         }
[13:19:55.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:55.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:55.763]             base::sink(type = "output", split = FALSE)
[13:19:55.763]             base::close(...future.stdout)
[13:19:55.763]         }, add = TRUE)
[13:19:55.763]     }
[13:19:55.763]     ...future.frame <- base::sys.nframe()
[13:19:55.763]     ...future.conditions <- base::list()
[13:19:55.763]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:55.763]     if (FALSE) {
[13:19:55.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:55.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:55.763]     }
[13:19:55.763]     ...future.result <- base::tryCatch({
[13:19:55.763]         base::withCallingHandlers({
[13:19:55.763]             ...future.value <- base::withVisible(base::local({
[13:19:55.763]                 x[[i - 2]] + x[[i - 1]]
[13:19:55.763]             }))
[13:19:55.763]             future::FutureResult(value = ...future.value$value, 
[13:19:55.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:55.763]                   ...future.rng), globalenv = if (FALSE) 
[13:19:55.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:55.763]                     ...future.globalenv.names))
[13:19:55.763]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:55.763]         }, condition = base::local({
[13:19:55.763]             c <- base::c
[13:19:55.763]             inherits <- base::inherits
[13:19:55.763]             invokeRestart <- base::invokeRestart
[13:19:55.763]             length <- base::length
[13:19:55.763]             list <- base::list
[13:19:55.763]             seq.int <- base::seq.int
[13:19:55.763]             signalCondition <- base::signalCondition
[13:19:55.763]             sys.calls <- base::sys.calls
[13:19:55.763]             `[[` <- base::`[[`
[13:19:55.763]             `+` <- base::`+`
[13:19:55.763]             `<<-` <- base::`<<-`
[13:19:55.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:55.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:55.763]                   3L)]
[13:19:55.763]             }
[13:19:55.763]             function(cond) {
[13:19:55.763]                 is_error <- inherits(cond, "error")
[13:19:55.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:55.763]                   NULL)
[13:19:55.763]                 if (is_error) {
[13:19:55.763]                   sessionInformation <- function() {
[13:19:55.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:55.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:55.763]                       search = base::search(), system = base::Sys.info())
[13:19:55.763]                   }
[13:19:55.763]                   ...future.conditions[[length(...future.conditions) + 
[13:19:55.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:55.763]                     cond$call), session = sessionInformation(), 
[13:19:55.763]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:55.763]                   signalCondition(cond)
[13:19:55.763]                 }
[13:19:55.763]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[13:19:55.763]                 "immediateCondition"))) {
[13:19:55.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:55.763]                   ...future.conditions[[length(...future.conditions) + 
[13:19:55.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:55.763]                   if (TRUE && !signal) {
[13:19:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:55.763]                     {
[13:19:55.763]                       inherits <- base::inherits
[13:19:55.763]                       invokeRestart <- base::invokeRestart
[13:19:55.763]                       is.null <- base::is.null
[13:19:55.763]                       muffled <- FALSE
[13:19:55.763]                       if (inherits(cond, "message")) {
[13:19:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:55.763]                         if (muffled) 
[13:19:55.763]                           invokeRestart("muffleMessage")
[13:19:55.763]                       }
[13:19:55.763]                       else if (inherits(cond, "warning")) {
[13:19:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:55.763]                         if (muffled) 
[13:19:55.763]                           invokeRestart("muffleWarning")
[13:19:55.763]                       }
[13:19:55.763]                       else if (inherits(cond, "condition")) {
[13:19:55.763]                         if (!is.null(pattern)) {
[13:19:55.763]                           computeRestarts <- base::computeRestarts
[13:19:55.763]                           grepl <- base::grepl
[13:19:55.763]                           restarts <- computeRestarts(cond)
[13:19:55.763]                           for (restart in restarts) {
[13:19:55.763]                             name <- restart$name
[13:19:55.763]                             if (is.null(name)) 
[13:19:55.763]                               next
[13:19:55.763]                             if (!grepl(pattern, name)) 
[13:19:55.763]                               next
[13:19:55.763]                             invokeRestart(restart)
[13:19:55.763]                             muffled <- TRUE
[13:19:55.763]                             break
[13:19:55.763]                           }
[13:19:55.763]                         }
[13:19:55.763]                       }
[13:19:55.763]                       invisible(muffled)
[13:19:55.763]                     }
[13:19:55.763]                     muffleCondition(cond, pattern = "^muffle")
[13:19:55.763]                   }
[13:19:55.763]                 }
[13:19:55.763]                 else {
[13:19:55.763]                   if (TRUE) {
[13:19:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:55.763]                     {
[13:19:55.763]                       inherits <- base::inherits
[13:19:55.763]                       invokeRestart <- base::invokeRestart
[13:19:55.763]                       is.null <- base::is.null
[13:19:55.763]                       muffled <- FALSE
[13:19:55.763]                       if (inherits(cond, "message")) {
[13:19:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:55.763]                         if (muffled) 
[13:19:55.763]                           invokeRestart("muffleMessage")
[13:19:55.763]                       }
[13:19:55.763]                       else if (inherits(cond, "warning")) {
[13:19:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:55.763]                         if (muffled) 
[13:19:55.763]                           invokeRestart("muffleWarning")
[13:19:55.763]                       }
[13:19:55.763]                       else if (inherits(cond, "condition")) {
[13:19:55.763]                         if (!is.null(pattern)) {
[13:19:55.763]                           computeRestarts <- base::computeRestarts
[13:19:55.763]                           grepl <- base::grepl
[13:19:55.763]                           restarts <- computeRestarts(cond)
[13:19:55.763]                           for (restart in restarts) {
[13:19:55.763]                             name <- restart$name
[13:19:55.763]                             if (is.null(name)) 
[13:19:55.763]                               next
[13:19:55.763]                             if (!grepl(pattern, name)) 
[13:19:55.763]                               next
[13:19:55.763]                             invokeRestart(restart)
[13:19:55.763]                             muffled <- TRUE
[13:19:55.763]                             break
[13:19:55.763]                           }
[13:19:55.763]                         }
[13:19:55.763]                       }
[13:19:55.763]                       invisible(muffled)
[13:19:55.763]                     }
[13:19:55.763]                     muffleCondition(cond, pattern = "^muffle")
[13:19:55.763]                   }
[13:19:55.763]                 }
[13:19:55.763]             }
[13:19:55.763]         }))
[13:19:55.763]     }, error = function(ex) {
[13:19:55.763]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:55.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:55.763]                 ...future.rng), started = ...future.startTime, 
[13:19:55.763]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:55.763]             version = "1.8"), class = "FutureResult")
[13:19:55.763]     }, finally = {
[13:19:55.763]         if (!identical(...future.workdir, getwd())) 
[13:19:55.763]             setwd(...future.workdir)
[13:19:55.763]         {
[13:19:55.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:55.763]                 ...future.oldOptions$nwarnings <- NULL
[13:19:55.763]             }
[13:19:55.763]             base::options(...future.oldOptions)
[13:19:55.763]             if (.Platform$OS.type == "windows") {
[13:19:55.763]                 old_names <- names(...future.oldEnvVars)
[13:19:55.763]                 envs <- base::Sys.getenv()
[13:19:55.763]                 names <- names(envs)
[13:19:55.763]                 common <- intersect(names, old_names)
[13:19:55.763]                 added <- setdiff(names, old_names)
[13:19:55.763]                 removed <- setdiff(old_names, names)
[13:19:55.763]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:55.763]                   envs[common]]
[13:19:55.763]                 NAMES <- toupper(changed)
[13:19:55.763]                 args <- list()
[13:19:55.763]                 for (kk in seq_along(NAMES)) {
[13:19:55.763]                   name <- changed[[kk]]
[13:19:55.763]                   NAME <- NAMES[[kk]]
[13:19:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:55.763]                     next
[13:19:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:55.763]                 }
[13:19:55.763]                 NAMES <- toupper(added)
[13:19:55.763]                 for (kk in seq_along(NAMES)) {
[13:19:55.763]                   name <- added[[kk]]
[13:19:55.763]                   NAME <- NAMES[[kk]]
[13:19:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:55.763]                     next
[13:19:55.763]                   args[[name]] <- ""
[13:19:55.763]                 }
[13:19:55.763]                 NAMES <- toupper(removed)
[13:19:55.763]                 for (kk in seq_along(NAMES)) {
[13:19:55.763]                   name <- removed[[kk]]
[13:19:55.763]                   NAME <- NAMES[[kk]]
[13:19:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:55.763]                     next
[13:19:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:55.763]                 }
[13:19:55.763]                 if (length(args) > 0) 
[13:19:55.763]                   base::do.call(base::Sys.setenv, args = args)
[13:19:55.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:55.763]             }
[13:19:55.763]             else {
[13:19:55.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:55.763]             }
[13:19:55.763]             {
[13:19:55.763]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:55.763]                   0L) {
[13:19:55.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:55.763]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:55.763]                   base::options(opts)
[13:19:55.763]                 }
[13:19:55.763]                 {
[13:19:55.763]                   {
[13:19:55.763]                     NULL
[13:19:55.763]                     RNGkind("Mersenne-Twister")
[13:19:55.763]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:55.763]                       inherits = FALSE)
[13:19:55.763]                   }
[13:19:55.763]                   options(future.plan = NULL)
[13:19:55.763]                   if (is.na(NA_character_)) 
[13:19:55.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:55.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:55.763]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:55.763]                   {
[13:19:55.763]                     future <- SequentialFuture(..., envir = envir)
[13:19:55.763]                     if (!future$lazy) 
[13:19:55.763]                       future <- run(future)
[13:19:55.763]                     invisible(future)
[13:19:55.763]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:55.763]                 }
[13:19:55.763]             }
[13:19:55.763]         }
[13:19:55.763]     })
[13:19:55.763]     if (FALSE) {
[13:19:55.763]         base::sink(type = "output", split = FALSE)
[13:19:55.763]         if (NA) {
[13:19:55.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:55.763]         }
[13:19:55.763]         else {
[13:19:55.763]             ...future.result["stdout"] <- base::list(NULL)
[13:19:55.763]         }
[13:19:55.763]         base::close(...future.stdout)
[13:19:55.763]         ...future.stdout <- NULL
[13:19:55.763]     }
[13:19:55.763]     ...future.result$conditions <- ...future.conditions
[13:19:55.763]     ...future.result$finished <- base::Sys.time()
[13:19:55.763]     ...future.result
[13:19:55.763] }
[13:19:55.764] assign_globals() ...
[13:19:55.764] List of 2
[13:19:55.764]  $ x:Classes 'listenv', 'environment' <environment: 0x55d3b760cf00> 
[13:19:55.764]  $ i: int 50
[13:19:55.764]  - attr(*, "where")=List of 2
[13:19:55.764]   ..$ x:<environment: R_EmptyEnv> 
[13:19:55.764]   ..$ i:<environment: R_EmptyEnv> 
[13:19:55.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:55.764]  - attr(*, "resolved")= logi FALSE
[13:19:55.764]  - attr(*, "total_size")= num 402000
[13:19:55.764]  - attr(*, "already-done")= logi TRUE
[13:19:55.769] - copied ‘x’ to environment
[13:19:55.769] - copied ‘i’ to environment
[13:19:55.769] assign_globals() ... done
[13:19:55.770] plan(): Setting new future strategy stack:
[13:19:55.770] List of future strategies:
[13:19:55.770] 1. sequential:
[13:19:55.770]    - args: function (..., envir = parent.frame())
[13:19:55.770]    - tweaked: FALSE
[13:19:55.770]    - call: NULL
[13:19:55.770] plan(): nbrOfWorkers() = 1
[13:19:56.662] plan(): Setting new future strategy stack:
[13:19:56.662] List of future strategies:
[13:19:56.662] 1. sequential:
[13:19:56.662]    - args: function (..., envir = parent.frame())
[13:19:56.662]    - tweaked: FALSE
[13:19:56.662]    - call: plan(sequential)
[13:19:56.663] plan(): nbrOfWorkers() = 1
[13:19:56.663] SequentialFuture started (and completed)
[13:19:56.663] - Launch lazy future ... done
[13:19:56.663] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[13:19:56.663] plan(): Setting new future strategy stack:
[13:19:56.663] List of future strategies:
[13:19:56.663] 1. sequential:
[13:19:56.663]    - args: function (..., envir = parent.frame())
[13:19:56.663]    - tweaked: FALSE
[13:19:56.663]    - call: future::plan("sequential")
[13:19:56.664] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[13:19:56.670] plan(): Setting new future strategy stack:
[13:19:56.671] List of future strategies:
[13:19:56.671] 1. sequential:
[13:19:56.671]    - args: function (..., envir = parent.frame())
[13:19:56.671]    - tweaked: FALSE
[13:19:56.671]    - call: plan(strategy)
[13:19:56.671] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[13:19:56.701] getGlobalsAndPackages() ...
[13:19:56.704] Searching for globals...
[13:19:56.709] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.709] Searching for globals ... DONE
[13:19:56.709] Resolving globals: FALSE
[13:19:56.709] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.710] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.710] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.710] - packages: [1] ‘future’
[13:19:56.710] getGlobalsAndPackages() ... DONE
 2[13:19:56.714] getGlobalsAndPackages() ...
[13:19:56.714] Searching for globals...
[13:19:56.718] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.718] Searching for globals ... DONE
[13:19:56.718] Resolving globals: FALSE
[13:19:56.718] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.719] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.719] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.719] - packages: [1] ‘future’
[13:19:56.719] getGlobalsAndPackages() ... DONE
 3[13:19:56.720] getGlobalsAndPackages() ...
[13:19:56.720] Searching for globals...
[13:19:56.723] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.723] Searching for globals ... DONE
[13:19:56.723] Resolving globals: FALSE
[13:19:56.724] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.724] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.724] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.725] - packages: [1] ‘future’
[13:19:56.725] getGlobalsAndPackages() ... DONE
 4[13:19:56.725] getGlobalsAndPackages() ...
[13:19:56.725] Searching for globals...
[13:19:56.728] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.729] Searching for globals ... DONE
[13:19:56.729] Resolving globals: FALSE
[13:19:56.729] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.730] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.730] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.730] - packages: [1] ‘future’
[13:19:56.730] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[13:19:56.740] resolved() for ‘Future’ ...
[13:19:56.740] - state: ‘created’
[13:19:56.740] - run: TRUE
[13:19:56.740] - run() ...
[13:19:56.740] run() for ‘Future’ ...
[13:19:56.740] - state: ‘created’
[13:19:56.740] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.741] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.741]   - Field: ‘label’
[13:19:56.741]   - Field: ‘local’
[13:19:56.741]   - Field: ‘owner’
[13:19:56.741]   - Field: ‘envir’
[13:19:56.741]   - Field: ‘packages’
[13:19:56.741]   - Field: ‘gc’
[13:19:56.742]   - Field: ‘conditions’
[13:19:56.742]   - Field: ‘expr’
[13:19:56.742]   - Field: ‘uuid’
[13:19:56.742]   - Field: ‘seed’
[13:19:56.742]   - Field: ‘version’
[13:19:56.742]   - Field: ‘result’
[13:19:56.742]   - Field: ‘asynchronous’
[13:19:56.742]   - Field: ‘calls’
[13:19:56.742]   - Field: ‘globals’
[13:19:56.742]   - Field: ‘stdout’
[13:19:56.742]   - Field: ‘earlySignal’
[13:19:56.743]   - Field: ‘lazy’
[13:19:56.743]   - Field: ‘state’
[13:19:56.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.743] - Launch lazy future ...
[13:19:56.743] Packages needed by the future expression (n = 1): ‘future’
[13:19:56.743] Packages needed by future strategies (n = 0): <none>
[13:19:56.744] {
[13:19:56.744]     {
[13:19:56.744]         {
[13:19:56.744]             ...future.startTime <- base::Sys.time()
[13:19:56.744]             {
[13:19:56.744]                 {
[13:19:56.744]                   {
[13:19:56.744]                     {
[13:19:56.744]                       base::local({
[13:19:56.744]                         has_future <- base::requireNamespace("future", 
[13:19:56.744]                           quietly = TRUE)
[13:19:56.744]                         if (has_future) {
[13:19:56.744]                           ns <- base::getNamespace("future")
[13:19:56.744]                           version <- ns[[".package"]][["version"]]
[13:19:56.744]                           if (is.null(version)) 
[13:19:56.744]                             version <- utils::packageVersion("future")
[13:19:56.744]                         }
[13:19:56.744]                         else {
[13:19:56.744]                           version <- NULL
[13:19:56.744]                         }
[13:19:56.744]                         if (!has_future || version < "1.8.0") {
[13:19:56.744]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.744]                             "", base::R.version$version.string), 
[13:19:56.744]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:56.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.744]                               "release", "version")], collapse = " "), 
[13:19:56.744]                             hostname = base::Sys.info()[["nodename"]])
[13:19:56.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.744]                             info)
[13:19:56.744]                           info <- base::paste(info, collapse = "; ")
[13:19:56.744]                           if (!has_future) {
[13:19:56.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.744]                               info)
[13:19:56.744]                           }
[13:19:56.744]                           else {
[13:19:56.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.744]                               info, version)
[13:19:56.744]                           }
[13:19:56.744]                           base::stop(msg)
[13:19:56.744]                         }
[13:19:56.744]                       })
[13:19:56.744]                     }
[13:19:56.744]                     base::local({
[13:19:56.744]                       for (pkg in "future") {
[13:19:56.744]                         base::loadNamespace(pkg)
[13:19:56.744]                         base::library(pkg, character.only = TRUE)
[13:19:56.744]                       }
[13:19:56.744]                     })
[13:19:56.744]                   }
[13:19:56.744]                   options(future.plan = NULL)
[13:19:56.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.744]                 }
[13:19:56.744]                 ...future.workdir <- getwd()
[13:19:56.744]             }
[13:19:56.744]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.744]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.744]         }
[13:19:56.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.744]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:56.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.744]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.744]             base::names(...future.oldOptions))
[13:19:56.744]     }
[13:19:56.744]     if (FALSE) {
[13:19:56.744]     }
[13:19:56.744]     else {
[13:19:56.744]         if (TRUE) {
[13:19:56.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.744]                 open = "w")
[13:19:56.744]         }
[13:19:56.744]         else {
[13:19:56.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.744]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.744]         }
[13:19:56.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.744]             base::sink(type = "output", split = FALSE)
[13:19:56.744]             base::close(...future.stdout)
[13:19:56.744]         }, add = TRUE)
[13:19:56.744]     }
[13:19:56.744]     ...future.frame <- base::sys.nframe()
[13:19:56.744]     ...future.conditions <- base::list()
[13:19:56.744]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.744]     if (FALSE) {
[13:19:56.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.744]     }
[13:19:56.744]     ...future.result <- base::tryCatch({
[13:19:56.744]         base::withCallingHandlers({
[13:19:56.744]             ...future.value <- base::withVisible(base::local({
[13:19:56.744]                 message(sprintf("Calculating tile #%d of %d ...", 
[13:19:56.744]                   ii, n), appendLF = FALSE)
[13:19:56.744]                 fit <- mandelbrot(C)
[13:19:56.744]                 delay(fit)
[13:19:56.744]                 message(" done")
[13:19:56.744]                 fit
[13:19:56.744]             }))
[13:19:56.744]             future::FutureResult(value = ...future.value$value, 
[13:19:56.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.744]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.744]                     ...future.globalenv.names))
[13:19:56.744]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.744]         }, condition = base::local({
[13:19:56.744]             c <- base::c
[13:19:56.744]             inherits <- base::inherits
[13:19:56.744]             invokeRestart <- base::invokeRestart
[13:19:56.744]             length <- base::length
[13:19:56.744]             list <- base::list
[13:19:56.744]             seq.int <- base::seq.int
[13:19:56.744]             signalCondition <- base::signalCondition
[13:19:56.744]             sys.calls <- base::sys.calls
[13:19:56.744]             `[[` <- base::`[[`
[13:19:56.744]             `+` <- base::`+`
[13:19:56.744]             `<<-` <- base::`<<-`
[13:19:56.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.744]                   3L)]
[13:19:56.744]             }
[13:19:56.744]             function(cond) {
[13:19:56.744]                 is_error <- inherits(cond, "error")
[13:19:56.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.744]                   NULL)
[13:19:56.744]                 if (is_error) {
[13:19:56.744]                   sessionInformation <- function() {
[13:19:56.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.744]                       search = base::search(), system = base::Sys.info())
[13:19:56.744]                   }
[13:19:56.744]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.744]                     cond$call), session = sessionInformation(), 
[13:19:56.744]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.744]                   signalCondition(cond)
[13:19:56.744]                 }
[13:19:56.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.744]                 "immediateCondition"))) {
[13:19:56.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.744]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.744]                   if (TRUE && !signal) {
[13:19:56.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.744]                     {
[13:19:56.744]                       inherits <- base::inherits
[13:19:56.744]                       invokeRestart <- base::invokeRestart
[13:19:56.744]                       is.null <- base::is.null
[13:19:56.744]                       muffled <- FALSE
[13:19:56.744]                       if (inherits(cond, "message")) {
[13:19:56.744]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.744]                         if (muffled) 
[13:19:56.744]                           invokeRestart("muffleMessage")
[13:19:56.744]                       }
[13:19:56.744]                       else if (inherits(cond, "warning")) {
[13:19:56.744]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.744]                         if (muffled) 
[13:19:56.744]                           invokeRestart("muffleWarning")
[13:19:56.744]                       }
[13:19:56.744]                       else if (inherits(cond, "condition")) {
[13:19:56.744]                         if (!is.null(pattern)) {
[13:19:56.744]                           computeRestarts <- base::computeRestarts
[13:19:56.744]                           grepl <- base::grepl
[13:19:56.744]                           restarts <- computeRestarts(cond)
[13:19:56.744]                           for (restart in restarts) {
[13:19:56.744]                             name <- restart$name
[13:19:56.744]                             if (is.null(name)) 
[13:19:56.744]                               next
[13:19:56.744]                             if (!grepl(pattern, name)) 
[13:19:56.744]                               next
[13:19:56.744]                             invokeRestart(restart)
[13:19:56.744]                             muffled <- TRUE
[13:19:56.744]                             break
[13:19:56.744]                           }
[13:19:56.744]                         }
[13:19:56.744]                       }
[13:19:56.744]                       invisible(muffled)
[13:19:56.744]                     }
[13:19:56.744]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.744]                   }
[13:19:56.744]                 }
[13:19:56.744]                 else {
[13:19:56.744]                   if (TRUE) {
[13:19:56.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.744]                     {
[13:19:56.744]                       inherits <- base::inherits
[13:19:56.744]                       invokeRestart <- base::invokeRestart
[13:19:56.744]                       is.null <- base::is.null
[13:19:56.744]                       muffled <- FALSE
[13:19:56.744]                       if (inherits(cond, "message")) {
[13:19:56.744]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.744]                         if (muffled) 
[13:19:56.744]                           invokeRestart("muffleMessage")
[13:19:56.744]                       }
[13:19:56.744]                       else if (inherits(cond, "warning")) {
[13:19:56.744]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.744]                         if (muffled) 
[13:19:56.744]                           invokeRestart("muffleWarning")
[13:19:56.744]                       }
[13:19:56.744]                       else if (inherits(cond, "condition")) {
[13:19:56.744]                         if (!is.null(pattern)) {
[13:19:56.744]                           computeRestarts <- base::computeRestarts
[13:19:56.744]                           grepl <- base::grepl
[13:19:56.744]                           restarts <- computeRestarts(cond)
[13:19:56.744]                           for (restart in restarts) {
[13:19:56.744]                             name <- restart$name
[13:19:56.744]                             if (is.null(name)) 
[13:19:56.744]                               next
[13:19:56.744]                             if (!grepl(pattern, name)) 
[13:19:56.744]                               next
[13:19:56.744]                             invokeRestart(restart)
[13:19:56.744]                             muffled <- TRUE
[13:19:56.744]                             break
[13:19:56.744]                           }
[13:19:56.744]                         }
[13:19:56.744]                       }
[13:19:56.744]                       invisible(muffled)
[13:19:56.744]                     }
[13:19:56.744]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.744]                   }
[13:19:56.744]                 }
[13:19:56.744]             }
[13:19:56.744]         }))
[13:19:56.744]     }, error = function(ex) {
[13:19:56.744]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.744]                 ...future.rng), started = ...future.startTime, 
[13:19:56.744]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.744]             version = "1.8"), class = "FutureResult")
[13:19:56.744]     }, finally = {
[13:19:56.744]         if (!identical(...future.workdir, getwd())) 
[13:19:56.744]             setwd(...future.workdir)
[13:19:56.744]         {
[13:19:56.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.744]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.744]             }
[13:19:56.744]             base::options(...future.oldOptions)
[13:19:56.744]             if (.Platform$OS.type == "windows") {
[13:19:56.744]                 old_names <- names(...future.oldEnvVars)
[13:19:56.744]                 envs <- base::Sys.getenv()
[13:19:56.744]                 names <- names(envs)
[13:19:56.744]                 common <- intersect(names, old_names)
[13:19:56.744]                 added <- setdiff(names, old_names)
[13:19:56.744]                 removed <- setdiff(old_names, names)
[13:19:56.744]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.744]                   envs[common]]
[13:19:56.744]                 NAMES <- toupper(changed)
[13:19:56.744]                 args <- list()
[13:19:56.744]                 for (kk in seq_along(NAMES)) {
[13:19:56.744]                   name <- changed[[kk]]
[13:19:56.744]                   NAME <- NAMES[[kk]]
[13:19:56.744]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.744]                     next
[13:19:56.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.744]                 }
[13:19:56.744]                 NAMES <- toupper(added)
[13:19:56.744]                 for (kk in seq_along(NAMES)) {
[13:19:56.744]                   name <- added[[kk]]
[13:19:56.744]                   NAME <- NAMES[[kk]]
[13:19:56.744]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.744]                     next
[13:19:56.744]                   args[[name]] <- ""
[13:19:56.744]                 }
[13:19:56.744]                 NAMES <- toupper(removed)
[13:19:56.744]                 for (kk in seq_along(NAMES)) {
[13:19:56.744]                   name <- removed[[kk]]
[13:19:56.744]                   NAME <- NAMES[[kk]]
[13:19:56.744]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.744]                     next
[13:19:56.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.744]                 }
[13:19:56.744]                 if (length(args) > 0) 
[13:19:56.744]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.744]             }
[13:19:56.744]             else {
[13:19:56.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.744]             }
[13:19:56.744]             {
[13:19:56.744]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.744]                   0L) {
[13:19:56.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.744]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.744]                   base::options(opts)
[13:19:56.744]                 }
[13:19:56.744]                 {
[13:19:56.744]                   {
[13:19:56.744]                     NULL
[13:19:56.744]                     RNGkind("Mersenne-Twister")
[13:19:56.744]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.744]                       inherits = FALSE)
[13:19:56.744]                   }
[13:19:56.744]                   options(future.plan = NULL)
[13:19:56.744]                   if (is.na(NA_character_)) 
[13:19:56.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.744]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.744]                   {
[13:19:56.744]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.744]                     if (!future$lazy) 
[13:19:56.744]                       future <- run(future)
[13:19:56.744]                     invisible(future)
[13:19:56.744]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.744]                 }
[13:19:56.744]             }
[13:19:56.744]         }
[13:19:56.744]     })
[13:19:56.744]     if (TRUE) {
[13:19:56.744]         base::sink(type = "output", split = FALSE)
[13:19:56.744]         if (TRUE) {
[13:19:56.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.744]         }
[13:19:56.744]         else {
[13:19:56.744]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.744]         }
[13:19:56.744]         base::close(...future.stdout)
[13:19:56.744]         ...future.stdout <- NULL
[13:19:56.744]     }
[13:19:56.744]     ...future.result$conditions <- ...future.conditions
[13:19:56.744]     ...future.result$finished <- base::Sys.time()
[13:19:56.744]     ...future.result
[13:19:56.744] }
[13:19:56.746] assign_globals() ...
[13:19:56.746] List of 4
[13:19:56.746]  $ ii   : int 1
[13:19:56.746]  $ n    : int 4
[13:19:56.746]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[13:19:56.746]   ..- attr(*, "region")=List of 2
[13:19:56.746]   .. ..$ xrange: num [1:2] -2.25 -0.781
[13:19:56.746]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[13:19:56.746]   ..- attr(*, "tile")= int [1:2] 1 1
[13:19:56.746]  $ delay:function (counts)  
[13:19:56.746]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:56.746]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8d92688> 
[13:19:56.746]  - attr(*, "where")=List of 4
[13:19:56.746]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:56.746]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:56.746]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:56.746]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:56.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.746]  - attr(*, "resolved")= logi FALSE
[13:19:56.746]  - attr(*, "total_size")= num 14584
[13:19:56.746]  - attr(*, "already-done")= logi TRUE
[13:19:56.752] - copied ‘ii’ to environment
[13:19:56.752] - copied ‘n’ to environment
[13:19:56.752] - copied ‘C’ to environment
[13:19:56.753] - reassign environment for ‘delay’
[13:19:56.753] - copied ‘delay’ to environment
[13:19:56.753] assign_globals() ... done
[13:19:56.753] plan(): Setting new future strategy stack:
[13:19:56.753] List of future strategies:
[13:19:56.753] 1. sequential:
[13:19:56.753]    - args: function (..., envir = parent.frame())
[13:19:56.753]    - tweaked: FALSE
[13:19:56.753]    - call: NULL
[13:19:56.754] plan(): nbrOfWorkers() = 1
[13:19:56.771] plan(): Setting new future strategy stack:
[13:19:56.771] List of future strategies:
[13:19:56.771] 1. sequential:
[13:19:56.771]    - args: function (..., envir = parent.frame())
[13:19:56.771]    - tweaked: FALSE
[13:19:56.771]    - call: plan(strategy)
[13:19:56.771] plan(): nbrOfWorkers() = 1
[13:19:56.772] SequentialFuture started (and completed)
[13:19:56.772] signalConditions() ...
[13:19:56.772]  - include = ‘immediateCondition’
[13:19:56.772]  - exclude = 
[13:19:56.772]  - resignal = FALSE
[13:19:56.772]  - Number of conditions: 2
[13:19:56.772] signalConditions() ... done
[13:19:56.772] - Launch lazy future ... done
[13:19:56.772] run() for ‘SequentialFuture’ ... done
[13:19:56.773] - run() ... done
[13:19:56.773] - resolved() ...
[13:19:56.773] resolved() for ‘SequentialFuture’ ...
[13:19:56.773] - state: ‘finished’
[13:19:56.773] - run: TRUE
[13:19:56.773] - result: ‘FutureResult’
[13:19:56.773] resolved() for ‘SequentialFuture’ ... done
[13:19:56.773] - resolved: TRUE
[13:19:56.773] - resolved() ... done
[13:19:56.773] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[13:19:56.774] signalConditions() ...
[13:19:56.774]  - include = ‘immediateCondition’
[13:19:56.774]  - exclude = 
[13:19:56.774]  - resignal = FALSE
[13:19:56.774]  - Number of conditions: 2
[13:19:56.774] signalConditions() ... done
[13:19:56.774] Future state: ‘finished’
[13:19:56.774] signalConditions() ...
[13:19:56.774]  - include = ‘condition’
[13:19:56.774]  - exclude = ‘immediateCondition’
[13:19:56.775]  - resignal = TRUE
[13:19:56.775]  - Number of conditions: 2
[13:19:56.775]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[13:19:56.775]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:56.775] signalConditions() ... done
[13:19:56.777] resolved() for ‘Future’ ...
[13:19:56.777] - state: ‘created’
[13:19:56.777] - run: TRUE
[13:19:56.777] - run() ...
[13:19:56.777] run() for ‘Future’ ...
[13:19:56.777] - state: ‘created’
[13:19:56.777] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.778] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.778]   - Field: ‘label’
[13:19:56.778]   - Field: ‘local’
[13:19:56.778]   - Field: ‘owner’
[13:19:56.778]   - Field: ‘envir’
[13:19:56.778]   - Field: ‘packages’
[13:19:56.778]   - Field: ‘gc’
[13:19:56.778]   - Field: ‘conditions’
[13:19:56.778]   - Field: ‘expr’
[13:19:56.779]   - Field: ‘uuid’
[13:19:56.779]   - Field: ‘seed’
[13:19:56.779]   - Field: ‘version’
[13:19:56.779]   - Field: ‘result’
[13:19:56.779]   - Field: ‘asynchronous’
[13:19:56.779]   - Field: ‘calls’
[13:19:56.779]   - Field: ‘globals’
[13:19:56.779]   - Field: ‘stdout’
[13:19:56.779]   - Field: ‘earlySignal’
[13:19:56.779]   - Field: ‘lazy’
[13:19:56.779]   - Field: ‘state’
[13:19:56.780] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.780] - Launch lazy future ...
[13:19:56.780] Packages needed by the future expression (n = 1): ‘future’
[13:19:56.780] Packages needed by future strategies (n = 0): <none>
[13:19:56.781] {
[13:19:56.781]     {
[13:19:56.781]         {
[13:19:56.781]             ...future.startTime <- base::Sys.time()
[13:19:56.781]             {
[13:19:56.781]                 {
[13:19:56.781]                   {
[13:19:56.781]                     {
[13:19:56.781]                       base::local({
[13:19:56.781]                         has_future <- base::requireNamespace("future", 
[13:19:56.781]                           quietly = TRUE)
[13:19:56.781]                         if (has_future) {
[13:19:56.781]                           ns <- base::getNamespace("future")
[13:19:56.781]                           version <- ns[[".package"]][["version"]]
[13:19:56.781]                           if (is.null(version)) 
[13:19:56.781]                             version <- utils::packageVersion("future")
[13:19:56.781]                         }
[13:19:56.781]                         else {
[13:19:56.781]                           version <- NULL
[13:19:56.781]                         }
[13:19:56.781]                         if (!has_future || version < "1.8.0") {
[13:19:56.781]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.781]                             "", base::R.version$version.string), 
[13:19:56.781]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:56.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.781]                               "release", "version")], collapse = " "), 
[13:19:56.781]                             hostname = base::Sys.info()[["nodename"]])
[13:19:56.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.781]                             info)
[13:19:56.781]                           info <- base::paste(info, collapse = "; ")
[13:19:56.781]                           if (!has_future) {
[13:19:56.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.781]                               info)
[13:19:56.781]                           }
[13:19:56.781]                           else {
[13:19:56.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.781]                               info, version)
[13:19:56.781]                           }
[13:19:56.781]                           base::stop(msg)
[13:19:56.781]                         }
[13:19:56.781]                       })
[13:19:56.781]                     }
[13:19:56.781]                     base::local({
[13:19:56.781]                       for (pkg in "future") {
[13:19:56.781]                         base::loadNamespace(pkg)
[13:19:56.781]                         base::library(pkg, character.only = TRUE)
[13:19:56.781]                       }
[13:19:56.781]                     })
[13:19:56.781]                   }
[13:19:56.781]                   options(future.plan = NULL)
[13:19:56.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.781]                 }
[13:19:56.781]                 ...future.workdir <- getwd()
[13:19:56.781]             }
[13:19:56.781]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.781]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.781]         }
[13:19:56.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:56.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.781]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.781]             base::names(...future.oldOptions))
[13:19:56.781]     }
[13:19:56.781]     if (FALSE) {
[13:19:56.781]     }
[13:19:56.781]     else {
[13:19:56.781]         if (TRUE) {
[13:19:56.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.781]                 open = "w")
[13:19:56.781]         }
[13:19:56.781]         else {
[13:19:56.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.781]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.781]         }
[13:19:56.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.781]             base::sink(type = "output", split = FALSE)
[13:19:56.781]             base::close(...future.stdout)
[13:19:56.781]         }, add = TRUE)
[13:19:56.781]     }
[13:19:56.781]     ...future.frame <- base::sys.nframe()
[13:19:56.781]     ...future.conditions <- base::list()
[13:19:56.781]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.781]     if (FALSE) {
[13:19:56.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.781]     }
[13:19:56.781]     ...future.result <- base::tryCatch({
[13:19:56.781]         base::withCallingHandlers({
[13:19:56.781]             ...future.value <- base::withVisible(base::local({
[13:19:56.781]                 message(sprintf("Calculating tile #%d of %d ...", 
[13:19:56.781]                   ii, n), appendLF = FALSE)
[13:19:56.781]                 fit <- mandelbrot(C)
[13:19:56.781]                 delay(fit)
[13:19:56.781]                 message(" done")
[13:19:56.781]                 fit
[13:19:56.781]             }))
[13:19:56.781]             future::FutureResult(value = ...future.value$value, 
[13:19:56.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.781]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.781]                     ...future.globalenv.names))
[13:19:56.781]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.781]         }, condition = base::local({
[13:19:56.781]             c <- base::c
[13:19:56.781]             inherits <- base::inherits
[13:19:56.781]             invokeRestart <- base::invokeRestart
[13:19:56.781]             length <- base::length
[13:19:56.781]             list <- base::list
[13:19:56.781]             seq.int <- base::seq.int
[13:19:56.781]             signalCondition <- base::signalCondition
[13:19:56.781]             sys.calls <- base::sys.calls
[13:19:56.781]             `[[` <- base::`[[`
[13:19:56.781]             `+` <- base::`+`
[13:19:56.781]             `<<-` <- base::`<<-`
[13:19:56.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.781]                   3L)]
[13:19:56.781]             }
[13:19:56.781]             function(cond) {
[13:19:56.781]                 is_error <- inherits(cond, "error")
[13:19:56.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.781]                   NULL)
[13:19:56.781]                 if (is_error) {
[13:19:56.781]                   sessionInformation <- function() {
[13:19:56.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.781]                       search = base::search(), system = base::Sys.info())
[13:19:56.781]                   }
[13:19:56.781]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.781]                     cond$call), session = sessionInformation(), 
[13:19:56.781]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.781]                   signalCondition(cond)
[13:19:56.781]                 }
[13:19:56.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.781]                 "immediateCondition"))) {
[13:19:56.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.781]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.781]                   if (TRUE && !signal) {
[13:19:56.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.781]                     {
[13:19:56.781]                       inherits <- base::inherits
[13:19:56.781]                       invokeRestart <- base::invokeRestart
[13:19:56.781]                       is.null <- base::is.null
[13:19:56.781]                       muffled <- FALSE
[13:19:56.781]                       if (inherits(cond, "message")) {
[13:19:56.781]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.781]                         if (muffled) 
[13:19:56.781]                           invokeRestart("muffleMessage")
[13:19:56.781]                       }
[13:19:56.781]                       else if (inherits(cond, "warning")) {
[13:19:56.781]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.781]                         if (muffled) 
[13:19:56.781]                           invokeRestart("muffleWarning")
[13:19:56.781]                       }
[13:19:56.781]                       else if (inherits(cond, "condition")) {
[13:19:56.781]                         if (!is.null(pattern)) {
[13:19:56.781]                           computeRestarts <- base::computeRestarts
[13:19:56.781]                           grepl <- base::grepl
[13:19:56.781]                           restarts <- computeRestarts(cond)
[13:19:56.781]                           for (restart in restarts) {
[13:19:56.781]                             name <- restart$name
[13:19:56.781]                             if (is.null(name)) 
[13:19:56.781]                               next
[13:19:56.781]                             if (!grepl(pattern, name)) 
[13:19:56.781]                               next
[13:19:56.781]                             invokeRestart(restart)
[13:19:56.781]                             muffled <- TRUE
[13:19:56.781]                             break
[13:19:56.781]                           }
[13:19:56.781]                         }
[13:19:56.781]                       }
[13:19:56.781]                       invisible(muffled)
[13:19:56.781]                     }
[13:19:56.781]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.781]                   }
[13:19:56.781]                 }
[13:19:56.781]                 else {
[13:19:56.781]                   if (TRUE) {
[13:19:56.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.781]                     {
[13:19:56.781]                       inherits <- base::inherits
[13:19:56.781]                       invokeRestart <- base::invokeRestart
[13:19:56.781]                       is.null <- base::is.null
[13:19:56.781]                       muffled <- FALSE
[13:19:56.781]                       if (inherits(cond, "message")) {
[13:19:56.781]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.781]                         if (muffled) 
[13:19:56.781]                           invokeRestart("muffleMessage")
[13:19:56.781]                       }
[13:19:56.781]                       else if (inherits(cond, "warning")) {
[13:19:56.781]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.781]                         if (muffled) 
[13:19:56.781]                           invokeRestart("muffleWarning")
[13:19:56.781]                       }
[13:19:56.781]                       else if (inherits(cond, "condition")) {
[13:19:56.781]                         if (!is.null(pattern)) {
[13:19:56.781]                           computeRestarts <- base::computeRestarts
[13:19:56.781]                           grepl <- base::grepl
[13:19:56.781]                           restarts <- computeRestarts(cond)
[13:19:56.781]                           for (restart in restarts) {
[13:19:56.781]                             name <- restart$name
[13:19:56.781]                             if (is.null(name)) 
[13:19:56.781]                               next
[13:19:56.781]                             if (!grepl(pattern, name)) 
[13:19:56.781]                               next
[13:19:56.781]                             invokeRestart(restart)
[13:19:56.781]                             muffled <- TRUE
[13:19:56.781]                             break
[13:19:56.781]                           }
[13:19:56.781]                         }
[13:19:56.781]                       }
[13:19:56.781]                       invisible(muffled)
[13:19:56.781]                     }
[13:19:56.781]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.781]                   }
[13:19:56.781]                 }
[13:19:56.781]             }
[13:19:56.781]         }))
[13:19:56.781]     }, error = function(ex) {
[13:19:56.781]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.781]                 ...future.rng), started = ...future.startTime, 
[13:19:56.781]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.781]             version = "1.8"), class = "FutureResult")
[13:19:56.781]     }, finally = {
[13:19:56.781]         if (!identical(...future.workdir, getwd())) 
[13:19:56.781]             setwd(...future.workdir)
[13:19:56.781]         {
[13:19:56.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.781]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.781]             }
[13:19:56.781]             base::options(...future.oldOptions)
[13:19:56.781]             if (.Platform$OS.type == "windows") {
[13:19:56.781]                 old_names <- names(...future.oldEnvVars)
[13:19:56.781]                 envs <- base::Sys.getenv()
[13:19:56.781]                 names <- names(envs)
[13:19:56.781]                 common <- intersect(names, old_names)
[13:19:56.781]                 added <- setdiff(names, old_names)
[13:19:56.781]                 removed <- setdiff(old_names, names)
[13:19:56.781]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.781]                   envs[common]]
[13:19:56.781]                 NAMES <- toupper(changed)
[13:19:56.781]                 args <- list()
[13:19:56.781]                 for (kk in seq_along(NAMES)) {
[13:19:56.781]                   name <- changed[[kk]]
[13:19:56.781]                   NAME <- NAMES[[kk]]
[13:19:56.781]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.781]                     next
[13:19:56.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.781]                 }
[13:19:56.781]                 NAMES <- toupper(added)
[13:19:56.781]                 for (kk in seq_along(NAMES)) {
[13:19:56.781]                   name <- added[[kk]]
[13:19:56.781]                   NAME <- NAMES[[kk]]
[13:19:56.781]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.781]                     next
[13:19:56.781]                   args[[name]] <- ""
[13:19:56.781]                 }
[13:19:56.781]                 NAMES <- toupper(removed)
[13:19:56.781]                 for (kk in seq_along(NAMES)) {
[13:19:56.781]                   name <- removed[[kk]]
[13:19:56.781]                   NAME <- NAMES[[kk]]
[13:19:56.781]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.781]                     next
[13:19:56.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.781]                 }
[13:19:56.781]                 if (length(args) > 0) 
[13:19:56.781]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.781]             }
[13:19:56.781]             else {
[13:19:56.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.781]             }
[13:19:56.781]             {
[13:19:56.781]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.781]                   0L) {
[13:19:56.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.781]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.781]                   base::options(opts)
[13:19:56.781]                 }
[13:19:56.781]                 {
[13:19:56.781]                   {
[13:19:56.781]                     NULL
[13:19:56.781]                     RNGkind("Mersenne-Twister")
[13:19:56.781]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.781]                       inherits = FALSE)
[13:19:56.781]                   }
[13:19:56.781]                   options(future.plan = NULL)
[13:19:56.781]                   if (is.na(NA_character_)) 
[13:19:56.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.781]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.781]                   {
[13:19:56.781]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.781]                     if (!future$lazy) 
[13:19:56.781]                       future <- run(future)
[13:19:56.781]                     invisible(future)
[13:19:56.781]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.781]                 }
[13:19:56.781]             }
[13:19:56.781]         }
[13:19:56.781]     })
[13:19:56.781]     if (TRUE) {
[13:19:56.781]         base::sink(type = "output", split = FALSE)
[13:19:56.781]         if (TRUE) {
[13:19:56.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.781]         }
[13:19:56.781]         else {
[13:19:56.781]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.781]         }
[13:19:56.781]         base::close(...future.stdout)
[13:19:56.781]         ...future.stdout <- NULL
[13:19:56.781]     }
[13:19:56.781]     ...future.result$conditions <- ...future.conditions
[13:19:56.781]     ...future.result$finished <- base::Sys.time()
[13:19:56.781]     ...future.result
[13:19:56.781] }
[13:19:56.782] assign_globals() ...
[13:19:56.782] List of 4
[13:19:56.782]  $ ii   : int 2
[13:19:56.782]  $ n    : int 4
[13:19:56.782]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[13:19:56.782]   ..- attr(*, "region")=List of 2
[13:19:56.782]   .. ..$ xrange: num [1:2] -0.719 0.75
[13:19:56.782]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[13:19:56.782]   ..- attr(*, "tile")= int [1:2] 1 2
[13:19:56.782]  $ delay:function (counts)  
[13:19:56.782]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:56.782]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8d92688> 
[13:19:56.782]  - attr(*, "where")=List of 4
[13:19:56.782]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:56.782]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:56.782]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:56.782]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:56.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.782]  - attr(*, "resolved")= logi FALSE
[13:19:56.782]  - attr(*, "total_size")= num 14584
[13:19:56.782]  - attr(*, "already-done")= logi TRUE
[13:19:56.789] - copied ‘ii’ to environment
[13:19:56.789] - copied ‘n’ to environment
[13:19:56.789] - copied ‘C’ to environment
[13:19:56.789] - reassign environment for ‘delay’
[13:19:56.789] - copied ‘delay’ to environment
[13:19:56.789] assign_globals() ... done
[13:19:56.790] plan(): Setting new future strategy stack:
[13:19:56.790] List of future strategies:
[13:19:56.790] 1. sequential:
[13:19:56.790]    - args: function (..., envir = parent.frame())
[13:19:56.790]    - tweaked: FALSE
[13:19:56.790]    - call: NULL
[13:19:56.790] plan(): nbrOfWorkers() = 1
[13:19:56.805] plan(): Setting new future strategy stack:
[13:19:56.806] List of future strategies:
[13:19:56.806] 1. sequential:
[13:19:56.806]    - args: function (..., envir = parent.frame())
[13:19:56.806]    - tweaked: FALSE
[13:19:56.806]    - call: plan(strategy)
[13:19:56.806] plan(): nbrOfWorkers() = 1
[13:19:56.806] SequentialFuture started (and completed)
[13:19:56.806] signalConditions() ...
[13:19:56.806]  - include = ‘immediateCondition’
[13:19:56.806]  - exclude = 
[13:19:56.807]  - resignal = FALSE
[13:19:56.807]  - Number of conditions: 2
[13:19:56.807] signalConditions() ... done
[13:19:56.807] - Launch lazy future ... done
[13:19:56.807] run() for ‘SequentialFuture’ ... done
[13:19:56.807] - run() ... done
[13:19:56.807] - resolved() ...
[13:19:56.807] resolved() for ‘SequentialFuture’ ...
[13:19:56.807] - state: ‘finished’
[13:19:56.807] - run: TRUE
[13:19:56.808] - result: ‘FutureResult’
[13:19:56.808] resolved() for ‘SequentialFuture’ ... done
[13:19:56.808] - resolved: TRUE
[13:19:56.808] - resolved() ... done
[13:19:56.808] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[13:19:56.808] signalConditions() ...
[13:19:56.808]  - include = ‘immediateCondition’
[13:19:56.808]  - exclude = 
[13:19:56.808]  - resignal = FALSE
[13:19:56.808]  - Number of conditions: 2
[13:19:56.809] signalConditions() ... done
[13:19:56.809] Future state: ‘finished’
[13:19:56.809] signalConditions() ...
[13:19:56.809]  - include = ‘condition’
[13:19:56.809]  - exclude = ‘immediateCondition’
[13:19:56.809]  - resignal = TRUE
[13:19:56.809]  - Number of conditions: 2
[13:19:56.809]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[13:19:56.809]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:56.810] signalConditions() ... done
[13:19:56.810] resolved() for ‘Future’ ...
[13:19:56.810] - state: ‘created’
[13:19:56.810] - run: TRUE
[13:19:56.811] - run() ...
[13:19:56.811] run() for ‘Future’ ...
[13:19:56.811] - state: ‘created’
[13:19:56.811] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.811] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.811]   - Field: ‘label’
[13:19:56.812]   - Field: ‘local’
[13:19:56.812]   - Field: ‘owner’
[13:19:56.812]   - Field: ‘envir’
[13:19:56.812]   - Field: ‘packages’
[13:19:56.812]   - Field: ‘gc’
[13:19:56.812]   - Field: ‘conditions’
[13:19:56.812]   - Field: ‘expr’
[13:19:56.812]   - Field: ‘uuid’
[13:19:56.812]   - Field: ‘seed’
[13:19:56.812]   - Field: ‘version’
[13:19:56.813]   - Field: ‘result’
[13:19:56.813]   - Field: ‘asynchronous’
[13:19:56.813]   - Field: ‘calls’
[13:19:56.813]   - Field: ‘globals’
[13:19:56.813]   - Field: ‘stdout’
[13:19:56.813]   - Field: ‘earlySignal’
[13:19:56.813]   - Field: ‘lazy’
[13:19:56.813]   - Field: ‘state’
[13:19:56.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.814] - Launch lazy future ...
[13:19:56.814] Packages needed by the future expression (n = 1): ‘future’
[13:19:56.814] Packages needed by future strategies (n = 0): <none>
[13:19:56.814] {
[13:19:56.814]     {
[13:19:56.814]         {
[13:19:56.814]             ...future.startTime <- base::Sys.time()
[13:19:56.814]             {
[13:19:56.814]                 {
[13:19:56.814]                   {
[13:19:56.814]                     {
[13:19:56.814]                       base::local({
[13:19:56.814]                         has_future <- base::requireNamespace("future", 
[13:19:56.814]                           quietly = TRUE)
[13:19:56.814]                         if (has_future) {
[13:19:56.814]                           ns <- base::getNamespace("future")
[13:19:56.814]                           version <- ns[[".package"]][["version"]]
[13:19:56.814]                           if (is.null(version)) 
[13:19:56.814]                             version <- utils::packageVersion("future")
[13:19:56.814]                         }
[13:19:56.814]                         else {
[13:19:56.814]                           version <- NULL
[13:19:56.814]                         }
[13:19:56.814]                         if (!has_future || version < "1.8.0") {
[13:19:56.814]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.814]                             "", base::R.version$version.string), 
[13:19:56.814]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:56.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.814]                               "release", "version")], collapse = " "), 
[13:19:56.814]                             hostname = base::Sys.info()[["nodename"]])
[13:19:56.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.814]                             info)
[13:19:56.814]                           info <- base::paste(info, collapse = "; ")
[13:19:56.814]                           if (!has_future) {
[13:19:56.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.814]                               info)
[13:19:56.814]                           }
[13:19:56.814]                           else {
[13:19:56.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.814]                               info, version)
[13:19:56.814]                           }
[13:19:56.814]                           base::stop(msg)
[13:19:56.814]                         }
[13:19:56.814]                       })
[13:19:56.814]                     }
[13:19:56.814]                     base::local({
[13:19:56.814]                       for (pkg in "future") {
[13:19:56.814]                         base::loadNamespace(pkg)
[13:19:56.814]                         base::library(pkg, character.only = TRUE)
[13:19:56.814]                       }
[13:19:56.814]                     })
[13:19:56.814]                   }
[13:19:56.814]                   options(future.plan = NULL)
[13:19:56.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.814]                 }
[13:19:56.814]                 ...future.workdir <- getwd()
[13:19:56.814]             }
[13:19:56.814]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.814]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.814]         }
[13:19:56.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:56.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.814]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.814]             base::names(...future.oldOptions))
[13:19:56.814]     }
[13:19:56.814]     if (FALSE) {
[13:19:56.814]     }
[13:19:56.814]     else {
[13:19:56.814]         if (TRUE) {
[13:19:56.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.814]                 open = "w")
[13:19:56.814]         }
[13:19:56.814]         else {
[13:19:56.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.814]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.814]         }
[13:19:56.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.814]             base::sink(type = "output", split = FALSE)
[13:19:56.814]             base::close(...future.stdout)
[13:19:56.814]         }, add = TRUE)
[13:19:56.814]     }
[13:19:56.814]     ...future.frame <- base::sys.nframe()
[13:19:56.814]     ...future.conditions <- base::list()
[13:19:56.814]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.814]     if (FALSE) {
[13:19:56.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.814]     }
[13:19:56.814]     ...future.result <- base::tryCatch({
[13:19:56.814]         base::withCallingHandlers({
[13:19:56.814]             ...future.value <- base::withVisible(base::local({
[13:19:56.814]                 message(sprintf("Calculating tile #%d of %d ...", 
[13:19:56.814]                   ii, n), appendLF = FALSE)
[13:19:56.814]                 fit <- mandelbrot(C)
[13:19:56.814]                 delay(fit)
[13:19:56.814]                 message(" done")
[13:19:56.814]                 fit
[13:19:56.814]             }))
[13:19:56.814]             future::FutureResult(value = ...future.value$value, 
[13:19:56.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.814]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.814]                     ...future.globalenv.names))
[13:19:56.814]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.814]         }, condition = base::local({
[13:19:56.814]             c <- base::c
[13:19:56.814]             inherits <- base::inherits
[13:19:56.814]             invokeRestart <- base::invokeRestart
[13:19:56.814]             length <- base::length
[13:19:56.814]             list <- base::list
[13:19:56.814]             seq.int <- base::seq.int
[13:19:56.814]             signalCondition <- base::signalCondition
[13:19:56.814]             sys.calls <- base::sys.calls
[13:19:56.814]             `[[` <- base::`[[`
[13:19:56.814]             `+` <- base::`+`
[13:19:56.814]             `<<-` <- base::`<<-`
[13:19:56.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.814]                   3L)]
[13:19:56.814]             }
[13:19:56.814]             function(cond) {
[13:19:56.814]                 is_error <- inherits(cond, "error")
[13:19:56.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.814]                   NULL)
[13:19:56.814]                 if (is_error) {
[13:19:56.814]                   sessionInformation <- function() {
[13:19:56.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.814]                       search = base::search(), system = base::Sys.info())
[13:19:56.814]                   }
[13:19:56.814]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.814]                     cond$call), session = sessionInformation(), 
[13:19:56.814]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.814]                   signalCondition(cond)
[13:19:56.814]                 }
[13:19:56.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.814]                 "immediateCondition"))) {
[13:19:56.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.814]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.814]                   if (TRUE && !signal) {
[13:19:56.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.814]                     {
[13:19:56.814]                       inherits <- base::inherits
[13:19:56.814]                       invokeRestart <- base::invokeRestart
[13:19:56.814]                       is.null <- base::is.null
[13:19:56.814]                       muffled <- FALSE
[13:19:56.814]                       if (inherits(cond, "message")) {
[13:19:56.814]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.814]                         if (muffled) 
[13:19:56.814]                           invokeRestart("muffleMessage")
[13:19:56.814]                       }
[13:19:56.814]                       else if (inherits(cond, "warning")) {
[13:19:56.814]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.814]                         if (muffled) 
[13:19:56.814]                           invokeRestart("muffleWarning")
[13:19:56.814]                       }
[13:19:56.814]                       else if (inherits(cond, "condition")) {
[13:19:56.814]                         if (!is.null(pattern)) {
[13:19:56.814]                           computeRestarts <- base::computeRestarts
[13:19:56.814]                           grepl <- base::grepl
[13:19:56.814]                           restarts <- computeRestarts(cond)
[13:19:56.814]                           for (restart in restarts) {
[13:19:56.814]                             name <- restart$name
[13:19:56.814]                             if (is.null(name)) 
[13:19:56.814]                               next
[13:19:56.814]                             if (!grepl(pattern, name)) 
[13:19:56.814]                               next
[13:19:56.814]                             invokeRestart(restart)
[13:19:56.814]                             muffled <- TRUE
[13:19:56.814]                             break
[13:19:56.814]                           }
[13:19:56.814]                         }
[13:19:56.814]                       }
[13:19:56.814]                       invisible(muffled)
[13:19:56.814]                     }
[13:19:56.814]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.814]                   }
[13:19:56.814]                 }
[13:19:56.814]                 else {
[13:19:56.814]                   if (TRUE) {
[13:19:56.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.814]                     {
[13:19:56.814]                       inherits <- base::inherits
[13:19:56.814]                       invokeRestart <- base::invokeRestart
[13:19:56.814]                       is.null <- base::is.null
[13:19:56.814]                       muffled <- FALSE
[13:19:56.814]                       if (inherits(cond, "message")) {
[13:19:56.814]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.814]                         if (muffled) 
[13:19:56.814]                           invokeRestart("muffleMessage")
[13:19:56.814]                       }
[13:19:56.814]                       else if (inherits(cond, "warning")) {
[13:19:56.814]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.814]                         if (muffled) 
[13:19:56.814]                           invokeRestart("muffleWarning")
[13:19:56.814]                       }
[13:19:56.814]                       else if (inherits(cond, "condition")) {
[13:19:56.814]                         if (!is.null(pattern)) {
[13:19:56.814]                           computeRestarts <- base::computeRestarts
[13:19:56.814]                           grepl <- base::grepl
[13:19:56.814]                           restarts <- computeRestarts(cond)
[13:19:56.814]                           for (restart in restarts) {
[13:19:56.814]                             name <- restart$name
[13:19:56.814]                             if (is.null(name)) 
[13:19:56.814]                               next
[13:19:56.814]                             if (!grepl(pattern, name)) 
[13:19:56.814]                               next
[13:19:56.814]                             invokeRestart(restart)
[13:19:56.814]                             muffled <- TRUE
[13:19:56.814]                             break
[13:19:56.814]                           }
[13:19:56.814]                         }
[13:19:56.814]                       }
[13:19:56.814]                       invisible(muffled)
[13:19:56.814]                     }
[13:19:56.814]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.814]                   }
[13:19:56.814]                 }
[13:19:56.814]             }
[13:19:56.814]         }))
[13:19:56.814]     }, error = function(ex) {
[13:19:56.814]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.814]                 ...future.rng), started = ...future.startTime, 
[13:19:56.814]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.814]             version = "1.8"), class = "FutureResult")
[13:19:56.814]     }, finally = {
[13:19:56.814]         if (!identical(...future.workdir, getwd())) 
[13:19:56.814]             setwd(...future.workdir)
[13:19:56.814]         {
[13:19:56.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.814]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.814]             }
[13:19:56.814]             base::options(...future.oldOptions)
[13:19:56.814]             if (.Platform$OS.type == "windows") {
[13:19:56.814]                 old_names <- names(...future.oldEnvVars)
[13:19:56.814]                 envs <- base::Sys.getenv()
[13:19:56.814]                 names <- names(envs)
[13:19:56.814]                 common <- intersect(names, old_names)
[13:19:56.814]                 added <- setdiff(names, old_names)
[13:19:56.814]                 removed <- setdiff(old_names, names)
[13:19:56.814]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.814]                   envs[common]]
[13:19:56.814]                 NAMES <- toupper(changed)
[13:19:56.814]                 args <- list()
[13:19:56.814]                 for (kk in seq_along(NAMES)) {
[13:19:56.814]                   name <- changed[[kk]]
[13:19:56.814]                   NAME <- NAMES[[kk]]
[13:19:56.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.814]                     next
[13:19:56.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.814]                 }
[13:19:56.814]                 NAMES <- toupper(added)
[13:19:56.814]                 for (kk in seq_along(NAMES)) {
[13:19:56.814]                   name <- added[[kk]]
[13:19:56.814]                   NAME <- NAMES[[kk]]
[13:19:56.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.814]                     next
[13:19:56.814]                   args[[name]] <- ""
[13:19:56.814]                 }
[13:19:56.814]                 NAMES <- toupper(removed)
[13:19:56.814]                 for (kk in seq_along(NAMES)) {
[13:19:56.814]                   name <- removed[[kk]]
[13:19:56.814]                   NAME <- NAMES[[kk]]
[13:19:56.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.814]                     next
[13:19:56.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.814]                 }
[13:19:56.814]                 if (length(args) > 0) 
[13:19:56.814]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.814]             }
[13:19:56.814]             else {
[13:19:56.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.814]             }
[13:19:56.814]             {
[13:19:56.814]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.814]                   0L) {
[13:19:56.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.814]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.814]                   base::options(opts)
[13:19:56.814]                 }
[13:19:56.814]                 {
[13:19:56.814]                   {
[13:19:56.814]                     NULL
[13:19:56.814]                     RNGkind("Mersenne-Twister")
[13:19:56.814]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.814]                       inherits = FALSE)
[13:19:56.814]                   }
[13:19:56.814]                   options(future.plan = NULL)
[13:19:56.814]                   if (is.na(NA_character_)) 
[13:19:56.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.814]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.814]                   {
[13:19:56.814]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.814]                     if (!future$lazy) 
[13:19:56.814]                       future <- run(future)
[13:19:56.814]                     invisible(future)
[13:19:56.814]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.814]                 }
[13:19:56.814]             }
[13:19:56.814]         }
[13:19:56.814]     })
[13:19:56.814]     if (TRUE) {
[13:19:56.814]         base::sink(type = "output", split = FALSE)
[13:19:56.814]         if (TRUE) {
[13:19:56.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.814]         }
[13:19:56.814]         else {
[13:19:56.814]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.814]         }
[13:19:56.814]         base::close(...future.stdout)
[13:19:56.814]         ...future.stdout <- NULL
[13:19:56.814]     }
[13:19:56.814]     ...future.result$conditions <- ...future.conditions
[13:19:56.814]     ...future.result$finished <- base::Sys.time()
[13:19:56.814]     ...future.result
[13:19:56.814] }
[13:19:56.816] assign_globals() ...
[13:19:56.816] List of 4
[13:19:56.816]  $ ii   : int 3
[13:19:56.816]  $ n    : int 4
[13:19:56.816]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[13:19:56.816]   ..- attr(*, "region")=List of 2
[13:19:56.816]   .. ..$ xrange: num [1:2] -2.25 -0.781
[13:19:56.816]   .. ..$ yrange: num [1:2] 0.0306 1.5
[13:19:56.816]   ..- attr(*, "tile")= int [1:2] 2 1
[13:19:56.816]  $ delay:function (counts)  
[13:19:56.816]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:56.816]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8d92688> 
[13:19:56.816]  - attr(*, "where")=List of 4
[13:19:56.816]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:56.816]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:56.816]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:56.816]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:56.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.816]  - attr(*, "resolved")= logi FALSE
[13:19:56.816]  - attr(*, "total_size")= num 14584
[13:19:56.816]  - attr(*, "already-done")= logi TRUE
[13:19:56.823] - copied ‘ii’ to environment
[13:19:56.823] - copied ‘n’ to environment
[13:19:56.823] - copied ‘C’ to environment
[13:19:56.823] - reassign environment for ‘delay’
[13:19:56.823] - copied ‘delay’ to environment
[13:19:56.823] assign_globals() ... done
[13:19:56.824] plan(): Setting new future strategy stack:
[13:19:56.824] List of future strategies:
[13:19:56.824] 1. sequential:
[13:19:56.824]    - args: function (..., envir = parent.frame())
[13:19:56.824]    - tweaked: FALSE
[13:19:56.824]    - call: NULL
[13:19:56.824] plan(): nbrOfWorkers() = 1
[13:19:56.842] plan(): Setting new future strategy stack:
[13:19:56.842] List of future strategies:
[13:19:56.842] 1. sequential:
[13:19:56.842]    - args: function (..., envir = parent.frame())
[13:19:56.842]    - tweaked: FALSE
[13:19:56.842]    - call: plan(strategy)
[13:19:56.842] plan(): nbrOfWorkers() = 1
[13:19:56.842] SequentialFuture started (and completed)
[13:19:56.842] signalConditions() ...
[13:19:56.843]  - include = ‘immediateCondition’
[13:19:56.843]  - exclude = 
[13:19:56.843]  - resignal = FALSE
[13:19:56.843]  - Number of conditions: 2
[13:19:56.843] signalConditions() ... done
[13:19:56.843] - Launch lazy future ... done
[13:19:56.843] run() for ‘SequentialFuture’ ... done
[13:19:56.843] - run() ... done
[13:19:56.843] - resolved() ...
[13:19:56.843] resolved() for ‘SequentialFuture’ ...
[13:19:56.844] - state: ‘finished’
[13:19:56.844] - run: TRUE
[13:19:56.844] - result: ‘FutureResult’
[13:19:56.844] resolved() for ‘SequentialFuture’ ... done
[13:19:56.844] - resolved: TRUE
[13:19:56.844] - resolved() ... done
[13:19:56.844] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[13:19:56.844] signalConditions() ...
[13:19:56.844]  - include = ‘immediateCondition’
[13:19:56.844]  - exclude = 
[13:19:56.845]  - resignal = FALSE
[13:19:56.845]  - Number of conditions: 2
[13:19:56.845] signalConditions() ... done
[13:19:56.845] Future state: ‘finished’
[13:19:56.845] signalConditions() ...
[13:19:56.845]  - include = ‘condition’
[13:19:56.845]  - exclude = ‘immediateCondition’
[13:19:56.845]  - resignal = TRUE
[13:19:56.845]  - Number of conditions: 2
[13:19:56.845]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[13:19:56.846]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:56.846] signalConditions() ... done
[13:19:56.846] resolved() for ‘Future’ ...
[13:19:56.846] - state: ‘created’
[13:19:56.847] - run: TRUE
[13:19:56.847] - run() ...
[13:19:56.847] run() for ‘Future’ ...
[13:19:56.847] - state: ‘created’
[13:19:56.847] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:56.847] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:56.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:56.848]   - Field: ‘label’
[13:19:56.848]   - Field: ‘local’
[13:19:56.848]   - Field: ‘owner’
[13:19:56.848]   - Field: ‘envir’
[13:19:56.848]   - Field: ‘packages’
[13:19:56.848]   - Field: ‘gc’
[13:19:56.848]   - Field: ‘conditions’
[13:19:56.848]   - Field: ‘expr’
[13:19:56.848]   - Field: ‘uuid’
[13:19:56.848]   - Field: ‘seed’
[13:19:56.849]   - Field: ‘version’
[13:19:56.849]   - Field: ‘result’
[13:19:56.849]   - Field: ‘asynchronous’
[13:19:56.849]   - Field: ‘calls’
[13:19:56.849]   - Field: ‘globals’
[13:19:56.849]   - Field: ‘stdout’
[13:19:56.849]   - Field: ‘earlySignal’
[13:19:56.849]   - Field: ‘lazy’
[13:19:56.849]   - Field: ‘state’
[13:19:56.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:56.850] - Launch lazy future ...
[13:19:56.850] Packages needed by the future expression (n = 1): ‘future’
[13:19:56.850] Packages needed by future strategies (n = 0): <none>
[13:19:56.850] {
[13:19:56.850]     {
[13:19:56.850]         {
[13:19:56.850]             ...future.startTime <- base::Sys.time()
[13:19:56.850]             {
[13:19:56.850]                 {
[13:19:56.850]                   {
[13:19:56.850]                     {
[13:19:56.850]                       base::local({
[13:19:56.850]                         has_future <- base::requireNamespace("future", 
[13:19:56.850]                           quietly = TRUE)
[13:19:56.850]                         if (has_future) {
[13:19:56.850]                           ns <- base::getNamespace("future")
[13:19:56.850]                           version <- ns[[".package"]][["version"]]
[13:19:56.850]                           if (is.null(version)) 
[13:19:56.850]                             version <- utils::packageVersion("future")
[13:19:56.850]                         }
[13:19:56.850]                         else {
[13:19:56.850]                           version <- NULL
[13:19:56.850]                         }
[13:19:56.850]                         if (!has_future || version < "1.8.0") {
[13:19:56.850]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.850]                             "", base::R.version$version.string), 
[13:19:56.850]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:56.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:56.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.850]                               "release", "version")], collapse = " "), 
[13:19:56.850]                             hostname = base::Sys.info()[["nodename"]])
[13:19:56.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.850]                             info)
[13:19:56.850]                           info <- base::paste(info, collapse = "; ")
[13:19:56.850]                           if (!has_future) {
[13:19:56.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.850]                               info)
[13:19:56.850]                           }
[13:19:56.850]                           else {
[13:19:56.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.850]                               info, version)
[13:19:56.850]                           }
[13:19:56.850]                           base::stop(msg)
[13:19:56.850]                         }
[13:19:56.850]                       })
[13:19:56.850]                     }
[13:19:56.850]                     base::local({
[13:19:56.850]                       for (pkg in "future") {
[13:19:56.850]                         base::loadNamespace(pkg)
[13:19:56.850]                         base::library(pkg, character.only = TRUE)
[13:19:56.850]                       }
[13:19:56.850]                     })
[13:19:56.850]                   }
[13:19:56.850]                   options(future.plan = NULL)
[13:19:56.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.850]                 }
[13:19:56.850]                 ...future.workdir <- getwd()
[13:19:56.850]             }
[13:19:56.850]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.850]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.850]         }
[13:19:56.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:56.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.850]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.850]             base::names(...future.oldOptions))
[13:19:56.850]     }
[13:19:56.850]     if (FALSE) {
[13:19:56.850]     }
[13:19:56.850]     else {
[13:19:56.850]         if (TRUE) {
[13:19:56.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.850]                 open = "w")
[13:19:56.850]         }
[13:19:56.850]         else {
[13:19:56.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.850]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.850]         }
[13:19:56.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.850]             base::sink(type = "output", split = FALSE)
[13:19:56.850]             base::close(...future.stdout)
[13:19:56.850]         }, add = TRUE)
[13:19:56.850]     }
[13:19:56.850]     ...future.frame <- base::sys.nframe()
[13:19:56.850]     ...future.conditions <- base::list()
[13:19:56.850]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.850]     if (FALSE) {
[13:19:56.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.850]     }
[13:19:56.850]     ...future.result <- base::tryCatch({
[13:19:56.850]         base::withCallingHandlers({
[13:19:56.850]             ...future.value <- base::withVisible(base::local({
[13:19:56.850]                 message(sprintf("Calculating tile #%d of %d ...", 
[13:19:56.850]                   ii, n), appendLF = FALSE)
[13:19:56.850]                 fit <- mandelbrot(C)
[13:19:56.850]                 delay(fit)
[13:19:56.850]                 message(" done")
[13:19:56.850]                 fit
[13:19:56.850]             }))
[13:19:56.850]             future::FutureResult(value = ...future.value$value, 
[13:19:56.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.850]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.850]                     ...future.globalenv.names))
[13:19:56.850]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.850]         }, condition = base::local({
[13:19:56.850]             c <- base::c
[13:19:56.850]             inherits <- base::inherits
[13:19:56.850]             invokeRestart <- base::invokeRestart
[13:19:56.850]             length <- base::length
[13:19:56.850]             list <- base::list
[13:19:56.850]             seq.int <- base::seq.int
[13:19:56.850]             signalCondition <- base::signalCondition
[13:19:56.850]             sys.calls <- base::sys.calls
[13:19:56.850]             `[[` <- base::`[[`
[13:19:56.850]             `+` <- base::`+`
[13:19:56.850]             `<<-` <- base::`<<-`
[13:19:56.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.850]                   3L)]
[13:19:56.850]             }
[13:19:56.850]             function(cond) {
[13:19:56.850]                 is_error <- inherits(cond, "error")
[13:19:56.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.850]                   NULL)
[13:19:56.850]                 if (is_error) {
[13:19:56.850]                   sessionInformation <- function() {
[13:19:56.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.850]                       search = base::search(), system = base::Sys.info())
[13:19:56.850]                   }
[13:19:56.850]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.850]                     cond$call), session = sessionInformation(), 
[13:19:56.850]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.850]                   signalCondition(cond)
[13:19:56.850]                 }
[13:19:56.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.850]                 "immediateCondition"))) {
[13:19:56.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.850]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.850]                   if (TRUE && !signal) {
[13:19:56.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.850]                     {
[13:19:56.850]                       inherits <- base::inherits
[13:19:56.850]                       invokeRestart <- base::invokeRestart
[13:19:56.850]                       is.null <- base::is.null
[13:19:56.850]                       muffled <- FALSE
[13:19:56.850]                       if (inherits(cond, "message")) {
[13:19:56.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.850]                         if (muffled) 
[13:19:56.850]                           invokeRestart("muffleMessage")
[13:19:56.850]                       }
[13:19:56.850]                       else if (inherits(cond, "warning")) {
[13:19:56.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.850]                         if (muffled) 
[13:19:56.850]                           invokeRestart("muffleWarning")
[13:19:56.850]                       }
[13:19:56.850]                       else if (inherits(cond, "condition")) {
[13:19:56.850]                         if (!is.null(pattern)) {
[13:19:56.850]                           computeRestarts <- base::computeRestarts
[13:19:56.850]                           grepl <- base::grepl
[13:19:56.850]                           restarts <- computeRestarts(cond)
[13:19:56.850]                           for (restart in restarts) {
[13:19:56.850]                             name <- restart$name
[13:19:56.850]                             if (is.null(name)) 
[13:19:56.850]                               next
[13:19:56.850]                             if (!grepl(pattern, name)) 
[13:19:56.850]                               next
[13:19:56.850]                             invokeRestart(restart)
[13:19:56.850]                             muffled <- TRUE
[13:19:56.850]                             break
[13:19:56.850]                           }
[13:19:56.850]                         }
[13:19:56.850]                       }
[13:19:56.850]                       invisible(muffled)
[13:19:56.850]                     }
[13:19:56.850]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.850]                   }
[13:19:56.850]                 }
[13:19:56.850]                 else {
[13:19:56.850]                   if (TRUE) {
[13:19:56.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.850]                     {
[13:19:56.850]                       inherits <- base::inherits
[13:19:56.850]                       invokeRestart <- base::invokeRestart
[13:19:56.850]                       is.null <- base::is.null
[13:19:56.850]                       muffled <- FALSE
[13:19:56.850]                       if (inherits(cond, "message")) {
[13:19:56.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.850]                         if (muffled) 
[13:19:56.850]                           invokeRestart("muffleMessage")
[13:19:56.850]                       }
[13:19:56.850]                       else if (inherits(cond, "warning")) {
[13:19:56.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.850]                         if (muffled) 
[13:19:56.850]                           invokeRestart("muffleWarning")
[13:19:56.850]                       }
[13:19:56.850]                       else if (inherits(cond, "condition")) {
[13:19:56.850]                         if (!is.null(pattern)) {
[13:19:56.850]                           computeRestarts <- base::computeRestarts
[13:19:56.850]                           grepl <- base::grepl
[13:19:56.850]                           restarts <- computeRestarts(cond)
[13:19:56.850]                           for (restart in restarts) {
[13:19:56.850]                             name <- restart$name
[13:19:56.850]                             if (is.null(name)) 
[13:19:56.850]                               next
[13:19:56.850]                             if (!grepl(pattern, name)) 
[13:19:56.850]                               next
[13:19:56.850]                             invokeRestart(restart)
[13:19:56.850]                             muffled <- TRUE
[13:19:56.850]                             break
[13:19:56.850]                           }
[13:19:56.850]                         }
[13:19:56.850]                       }
[13:19:56.850]                       invisible(muffled)
[13:19:56.850]                     }
[13:19:56.850]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.850]                   }
[13:19:56.850]                 }
[13:19:56.850]             }
[13:19:56.850]         }))
[13:19:56.850]     }, error = function(ex) {
[13:19:56.850]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.850]                 ...future.rng), started = ...future.startTime, 
[13:19:56.850]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.850]             version = "1.8"), class = "FutureResult")
[13:19:56.850]     }, finally = {
[13:19:56.850]         if (!identical(...future.workdir, getwd())) 
[13:19:56.850]             setwd(...future.workdir)
[13:19:56.850]         {
[13:19:56.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.850]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.850]             }
[13:19:56.850]             base::options(...future.oldOptions)
[13:19:56.850]             if (.Platform$OS.type == "windows") {
[13:19:56.850]                 old_names <- names(...future.oldEnvVars)
[13:19:56.850]                 envs <- base::Sys.getenv()
[13:19:56.850]                 names <- names(envs)
[13:19:56.850]                 common <- intersect(names, old_names)
[13:19:56.850]                 added <- setdiff(names, old_names)
[13:19:56.850]                 removed <- setdiff(old_names, names)
[13:19:56.850]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.850]                   envs[common]]
[13:19:56.850]                 NAMES <- toupper(changed)
[13:19:56.850]                 args <- list()
[13:19:56.850]                 for (kk in seq_along(NAMES)) {
[13:19:56.850]                   name <- changed[[kk]]
[13:19:56.850]                   NAME <- NAMES[[kk]]
[13:19:56.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.850]                     next
[13:19:56.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.850]                 }
[13:19:56.850]                 NAMES <- toupper(added)
[13:19:56.850]                 for (kk in seq_along(NAMES)) {
[13:19:56.850]                   name <- added[[kk]]
[13:19:56.850]                   NAME <- NAMES[[kk]]
[13:19:56.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.850]                     next
[13:19:56.850]                   args[[name]] <- ""
[13:19:56.850]                 }
[13:19:56.850]                 NAMES <- toupper(removed)
[13:19:56.850]                 for (kk in seq_along(NAMES)) {
[13:19:56.850]                   name <- removed[[kk]]
[13:19:56.850]                   NAME <- NAMES[[kk]]
[13:19:56.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.850]                     next
[13:19:56.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.850]                 }
[13:19:56.850]                 if (length(args) > 0) 
[13:19:56.850]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.850]             }
[13:19:56.850]             else {
[13:19:56.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.850]             }
[13:19:56.850]             {
[13:19:56.850]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.850]                   0L) {
[13:19:56.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.850]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.850]                   base::options(opts)
[13:19:56.850]                 }
[13:19:56.850]                 {
[13:19:56.850]                   {
[13:19:56.850]                     NULL
[13:19:56.850]                     RNGkind("Mersenne-Twister")
[13:19:56.850]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:56.850]                       inherits = FALSE)
[13:19:56.850]                   }
[13:19:56.850]                   options(future.plan = NULL)
[13:19:56.850]                   if (is.na(NA_character_)) 
[13:19:56.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.850]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:56.850]                   {
[13:19:56.850]                     future <- SequentialFuture(..., envir = envir)
[13:19:56.850]                     if (!future$lazy) 
[13:19:56.850]                       future <- run(future)
[13:19:56.850]                     invisible(future)
[13:19:56.850]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.850]                 }
[13:19:56.850]             }
[13:19:56.850]         }
[13:19:56.850]     })
[13:19:56.850]     if (TRUE) {
[13:19:56.850]         base::sink(type = "output", split = FALSE)
[13:19:56.850]         if (TRUE) {
[13:19:56.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.850]         }
[13:19:56.850]         else {
[13:19:56.850]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.850]         }
[13:19:56.850]         base::close(...future.stdout)
[13:19:56.850]         ...future.stdout <- NULL
[13:19:56.850]     }
[13:19:56.850]     ...future.result$conditions <- ...future.conditions
[13:19:56.850]     ...future.result$finished <- base::Sys.time()
[13:19:56.850]     ...future.result
[13:19:56.850] }
[13:19:56.852] assign_globals() ...
[13:19:56.852] List of 4
[13:19:56.852]  $ ii   : int 4
[13:19:56.852]  $ n    : int 4
[13:19:56.852]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[13:19:56.852]   ..- attr(*, "region")=List of 2
[13:19:56.852]   .. ..$ xrange: num [1:2] -0.719 0.75
[13:19:56.852]   .. ..$ yrange: num [1:2] 0.0306 1.5
[13:19:56.852]   ..- attr(*, "tile")= int [1:2] 2 2
[13:19:56.852]  $ delay:function (counts)  
[13:19:56.852]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:56.852]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8d92688> 
[13:19:56.852]  - attr(*, "where")=List of 4
[13:19:56.852]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:56.852]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:56.852]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:56.852]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:56.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.852]  - attr(*, "resolved")= logi FALSE
[13:19:56.852]  - attr(*, "total_size")= num 14584
[13:19:56.852]  - attr(*, "already-done")= logi TRUE
[13:19:56.859] - copied ‘ii’ to environment
[13:19:56.859] - copied ‘n’ to environment
[13:19:56.859] - copied ‘C’ to environment
[13:19:56.859] - reassign environment for ‘delay’
[13:19:56.859] - copied ‘delay’ to environment
[13:19:56.859] assign_globals() ... done
[13:19:56.859] plan(): Setting new future strategy stack:
[13:19:56.860] List of future strategies:
[13:19:56.860] 1. sequential:
[13:19:56.860]    - args: function (..., envir = parent.frame())
[13:19:56.860]    - tweaked: FALSE
[13:19:56.860]    - call: NULL
[13:19:56.860] plan(): nbrOfWorkers() = 1
[13:19:56.875] plan(): Setting new future strategy stack:
[13:19:56.875] List of future strategies:
[13:19:56.875] 1. sequential:
[13:19:56.875]    - args: function (..., envir = parent.frame())
[13:19:56.875]    - tweaked: FALSE
[13:19:56.875]    - call: plan(strategy)
[13:19:56.875] plan(): nbrOfWorkers() = 1
[13:19:56.876] SequentialFuture started (and completed)
[13:19:56.876] signalConditions() ...
[13:19:56.876]  - include = ‘immediateCondition’
[13:19:56.876]  - exclude = 
[13:19:56.876]  - resignal = FALSE
[13:19:56.876]  - Number of conditions: 2
[13:19:56.876] signalConditions() ... done
[13:19:56.876] - Launch lazy future ... done
[13:19:56.876] run() for ‘SequentialFuture’ ... done
[13:19:56.877] - run() ... done
[13:19:56.877] - resolved() ...
[13:19:56.877] resolved() for ‘SequentialFuture’ ...
[13:19:56.877] - state: ‘finished’
[13:19:56.877] - run: TRUE
[13:19:56.877] - result: ‘FutureResult’
[13:19:56.877] resolved() for ‘SequentialFuture’ ... done
[13:19:56.877] - resolved: TRUE
[13:19:56.877] - resolved() ... done
[13:19:56.877] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[13:19:56.878] signalConditions() ...
[13:19:56.878]  - include = ‘immediateCondition’
[13:19:56.878]  - exclude = 
[13:19:56.878]  - resignal = FALSE
[13:19:56.878]  - Number of conditions: 2
[13:19:56.878] signalConditions() ... done
[13:19:56.878] Future state: ‘finished’
[13:19:56.878] signalConditions() ...
[13:19:56.878]  - include = ‘condition’
[13:19:56.878]  - exclude = ‘immediateCondition’
[13:19:56.879]  - resignal = TRUE
[13:19:56.879]  - Number of conditions: 2
[13:19:56.879]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[13:19:56.879]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:56.879] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[13:19:56.886] plan(): Setting new future strategy stack:
[13:19:56.886] List of future strategies:
[13:19:56.886] 1. multicore:
[13:19:56.886]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:56.886]    - tweaked: FALSE
[13:19:56.886]    - call: plan(strategy)
[13:19:56.890] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[13:19:56.896] getGlobalsAndPackages() ...
[13:19:56.896] Searching for globals...
[13:19:56.900] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.900] Searching for globals ... DONE
[13:19:56.900] Resolving globals: FALSE
[13:19:56.901] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.901] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.901] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.901] - packages: [1] ‘future’
[13:19:56.902] getGlobalsAndPackages() ... DONE
 2[13:19:56.905] getGlobalsAndPackages() ...
[13:19:56.906] Searching for globals...
[13:19:56.909] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.909] Searching for globals ... DONE
[13:19:56.909] Resolving globals: FALSE
[13:19:56.910] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.910] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.910] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.910] - packages: [1] ‘future’
[13:19:56.910] getGlobalsAndPackages() ... DONE
 3[13:19:56.911] getGlobalsAndPackages() ...
[13:19:56.911] Searching for globals...
[13:19:56.914] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.914] Searching for globals ... DONE
[13:19:56.915] Resolving globals: FALSE
[13:19:56.915] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.915] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.916] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.916] - packages: [1] ‘future’
[13:19:56.916] getGlobalsAndPackages() ... DONE
 4[13:19:56.916] getGlobalsAndPackages() ...
[13:19:56.916] Searching for globals...
[13:19:56.920] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:56.920] Searching for globals ... DONE
[13:19:56.920] Resolving globals: FALSE
[13:19:56.920] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:56.921] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:56.921] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:56.921] - packages: [1] ‘future’
[13:19:56.921] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[13:19:56.930] resolved() for ‘Future’ ...
[13:19:56.930] - state: ‘created’
[13:19:56.930] - run: TRUE
[13:19:56.930] - run() ...
[13:19:56.931] run() for ‘Future’ ...
[13:19:56.931] - state: ‘created’
[13:19:56.931] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:56.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:56.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:56.935]   - Field: ‘label’
[13:19:56.935]   - Field: ‘local’
[13:19:56.935]   - Field: ‘owner’
[13:19:56.935]   - Field: ‘envir’
[13:19:56.936]   - Field: ‘workers’
[13:19:56.936]   - Field: ‘packages’
[13:19:56.936]   - Field: ‘gc’
[13:19:56.936]   - Field: ‘job’
[13:19:56.936]   - Field: ‘conditions’
[13:19:56.936]   - Field: ‘expr’
[13:19:56.936]   - Field: ‘uuid’
[13:19:56.936]   - Field: ‘seed’
[13:19:56.936]   - Field: ‘version’
[13:19:56.936]   - Field: ‘result’
[13:19:56.937]   - Field: ‘asynchronous’
[13:19:56.937]   - Field: ‘calls’
[13:19:56.937]   - Field: ‘globals’
[13:19:56.937]   - Field: ‘stdout’
[13:19:56.937]   - Field: ‘earlySignal’
[13:19:56.937]   - Field: ‘lazy’
[13:19:56.937]   - Field: ‘state’
[13:19:56.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:56.937] - Launch lazy future ...
[13:19:56.938] Packages needed by the future expression (n = 1): ‘future’
[13:19:56.939] Packages needed by future strategies (n = 0): <none>
[13:19:56.939] {
[13:19:56.939]     {
[13:19:56.939]         {
[13:19:56.939]             ...future.startTime <- base::Sys.time()
[13:19:56.939]             {
[13:19:56.939]                 {
[13:19:56.939]                   {
[13:19:56.939]                     {
[13:19:56.939]                       {
[13:19:56.939]                         base::local({
[13:19:56.939]                           has_future <- base::requireNamespace("future", 
[13:19:56.939]                             quietly = TRUE)
[13:19:56.939]                           if (has_future) {
[13:19:56.939]                             ns <- base::getNamespace("future")
[13:19:56.939]                             version <- ns[[".package"]][["version"]]
[13:19:56.939]                             if (is.null(version)) 
[13:19:56.939]                               version <- utils::packageVersion("future")
[13:19:56.939]                           }
[13:19:56.939]                           else {
[13:19:56.939]                             version <- NULL
[13:19:56.939]                           }
[13:19:56.939]                           if (!has_future || version < "1.8.0") {
[13:19:56.939]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.939]                               "", base::R.version$version.string), 
[13:19:56.939]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:56.939]                                 base::R.version$platform, 8 * 
[13:19:56.939]                                   base::.Machine$sizeof.pointer), 
[13:19:56.939]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.939]                                 "release", "version")], collapse = " "), 
[13:19:56.939]                               hostname = base::Sys.info()[["nodename"]])
[13:19:56.939]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.939]                               info)
[13:19:56.939]                             info <- base::paste(info, collapse = "; ")
[13:19:56.939]                             if (!has_future) {
[13:19:56.939]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.939]                                 info)
[13:19:56.939]                             }
[13:19:56.939]                             else {
[13:19:56.939]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.939]                                 info, version)
[13:19:56.939]                             }
[13:19:56.939]                             base::stop(msg)
[13:19:56.939]                           }
[13:19:56.939]                         })
[13:19:56.939]                       }
[13:19:56.939]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:56.939]                       base::options(mc.cores = 1L)
[13:19:56.939]                     }
[13:19:56.939]                     base::local({
[13:19:56.939]                       for (pkg in "future") {
[13:19:56.939]                         base::loadNamespace(pkg)
[13:19:56.939]                         base::library(pkg, character.only = TRUE)
[13:19:56.939]                       }
[13:19:56.939]                     })
[13:19:56.939]                   }
[13:19:56.939]                   options(future.plan = NULL)
[13:19:56.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.939]                 }
[13:19:56.939]                 ...future.workdir <- getwd()
[13:19:56.939]             }
[13:19:56.939]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.939]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.939]         }
[13:19:56.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.939]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:56.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.939]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.939]             base::names(...future.oldOptions))
[13:19:56.939]     }
[13:19:56.939]     if (FALSE) {
[13:19:56.939]     }
[13:19:56.939]     else {
[13:19:56.939]         if (TRUE) {
[13:19:56.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.939]                 open = "w")
[13:19:56.939]         }
[13:19:56.939]         else {
[13:19:56.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.939]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.939]         }
[13:19:56.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.939]             base::sink(type = "output", split = FALSE)
[13:19:56.939]             base::close(...future.stdout)
[13:19:56.939]         }, add = TRUE)
[13:19:56.939]     }
[13:19:56.939]     ...future.frame <- base::sys.nframe()
[13:19:56.939]     ...future.conditions <- base::list()
[13:19:56.939]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.939]     if (FALSE) {
[13:19:56.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.939]     }
[13:19:56.939]     ...future.result <- base::tryCatch({
[13:19:56.939]         base::withCallingHandlers({
[13:19:56.939]             ...future.value <- base::withVisible(base::local({
[13:19:56.939]                 withCallingHandlers({
[13:19:56.939]                   {
[13:19:56.939]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:56.939]                       ii, n), appendLF = FALSE)
[13:19:56.939]                     fit <- mandelbrot(C)
[13:19:56.939]                     delay(fit)
[13:19:56.939]                     message(" done")
[13:19:56.939]                     fit
[13:19:56.939]                   }
[13:19:56.939]                 }, immediateCondition = function(cond) {
[13:19:56.939]                   save_rds <- function (object, pathname, ...) 
[13:19:56.939]                   {
[13:19:56.939]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:56.939]                     if (file_test("-f", pathname_tmp)) {
[13:19:56.939]                       fi_tmp <- file.info(pathname_tmp)
[13:19:56.939]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:56.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:56.939]                         fi_tmp[["mtime"]])
[13:19:56.939]                     }
[13:19:56.939]                     tryCatch({
[13:19:56.939]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:56.939]                     }, error = function(ex) {
[13:19:56.939]                       msg <- conditionMessage(ex)
[13:19:56.939]                       fi_tmp <- file.info(pathname_tmp)
[13:19:56.939]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:56.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:56.939]                         fi_tmp[["mtime"]], msg)
[13:19:56.939]                       ex$message <- msg
[13:19:56.939]                       stop(ex)
[13:19:56.939]                     })
[13:19:56.939]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:56.939]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:56.939]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:56.939]                       fi_tmp <- file.info(pathname_tmp)
[13:19:56.939]                       fi <- file.info(pathname)
[13:19:56.939]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:56.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:56.939]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:56.939]                         fi[["size"]], fi[["mtime"]])
[13:19:56.939]                       stop(msg)
[13:19:56.939]                     }
[13:19:56.939]                     invisible(pathname)
[13:19:56.939]                   }
[13:19:56.939]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:56.939]                     rootPath = tempdir()) 
[13:19:56.939]                   {
[13:19:56.939]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:56.939]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:56.939]                       tmpdir = path, fileext = ".rds")
[13:19:56.939]                     save_rds(obj, file)
[13:19:56.939]                   }
[13:19:56.939]                   saveImmediateCondition(cond, path = "/tmp/RtmpuMztud/.future/immediateConditions")
[13:19:56.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.939]                   {
[13:19:56.939]                     inherits <- base::inherits
[13:19:56.939]                     invokeRestart <- base::invokeRestart
[13:19:56.939]                     is.null <- base::is.null
[13:19:56.939]                     muffled <- FALSE
[13:19:56.939]                     if (inherits(cond, "message")) {
[13:19:56.939]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:56.939]                       if (muffled) 
[13:19:56.939]                         invokeRestart("muffleMessage")
[13:19:56.939]                     }
[13:19:56.939]                     else if (inherits(cond, "warning")) {
[13:19:56.939]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:56.939]                       if (muffled) 
[13:19:56.939]                         invokeRestart("muffleWarning")
[13:19:56.939]                     }
[13:19:56.939]                     else if (inherits(cond, "condition")) {
[13:19:56.939]                       if (!is.null(pattern)) {
[13:19:56.939]                         computeRestarts <- base::computeRestarts
[13:19:56.939]                         grepl <- base::grepl
[13:19:56.939]                         restarts <- computeRestarts(cond)
[13:19:56.939]                         for (restart in restarts) {
[13:19:56.939]                           name <- restart$name
[13:19:56.939]                           if (is.null(name)) 
[13:19:56.939]                             next
[13:19:56.939]                           if (!grepl(pattern, name)) 
[13:19:56.939]                             next
[13:19:56.939]                           invokeRestart(restart)
[13:19:56.939]                           muffled <- TRUE
[13:19:56.939]                           break
[13:19:56.939]                         }
[13:19:56.939]                       }
[13:19:56.939]                     }
[13:19:56.939]                     invisible(muffled)
[13:19:56.939]                   }
[13:19:56.939]                   muffleCondition(cond)
[13:19:56.939]                 })
[13:19:56.939]             }))
[13:19:56.939]             future::FutureResult(value = ...future.value$value, 
[13:19:56.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.939]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.939]                     ...future.globalenv.names))
[13:19:56.939]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.939]         }, condition = base::local({
[13:19:56.939]             c <- base::c
[13:19:56.939]             inherits <- base::inherits
[13:19:56.939]             invokeRestart <- base::invokeRestart
[13:19:56.939]             length <- base::length
[13:19:56.939]             list <- base::list
[13:19:56.939]             seq.int <- base::seq.int
[13:19:56.939]             signalCondition <- base::signalCondition
[13:19:56.939]             sys.calls <- base::sys.calls
[13:19:56.939]             `[[` <- base::`[[`
[13:19:56.939]             `+` <- base::`+`
[13:19:56.939]             `<<-` <- base::`<<-`
[13:19:56.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.939]                   3L)]
[13:19:56.939]             }
[13:19:56.939]             function(cond) {
[13:19:56.939]                 is_error <- inherits(cond, "error")
[13:19:56.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.939]                   NULL)
[13:19:56.939]                 if (is_error) {
[13:19:56.939]                   sessionInformation <- function() {
[13:19:56.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.939]                       search = base::search(), system = base::Sys.info())
[13:19:56.939]                   }
[13:19:56.939]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.939]                     cond$call), session = sessionInformation(), 
[13:19:56.939]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.939]                   signalCondition(cond)
[13:19:56.939]                 }
[13:19:56.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.939]                 "immediateCondition"))) {
[13:19:56.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.939]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.939]                   if (TRUE && !signal) {
[13:19:56.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.939]                     {
[13:19:56.939]                       inherits <- base::inherits
[13:19:56.939]                       invokeRestart <- base::invokeRestart
[13:19:56.939]                       is.null <- base::is.null
[13:19:56.939]                       muffled <- FALSE
[13:19:56.939]                       if (inherits(cond, "message")) {
[13:19:56.939]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.939]                         if (muffled) 
[13:19:56.939]                           invokeRestart("muffleMessage")
[13:19:56.939]                       }
[13:19:56.939]                       else if (inherits(cond, "warning")) {
[13:19:56.939]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.939]                         if (muffled) 
[13:19:56.939]                           invokeRestart("muffleWarning")
[13:19:56.939]                       }
[13:19:56.939]                       else if (inherits(cond, "condition")) {
[13:19:56.939]                         if (!is.null(pattern)) {
[13:19:56.939]                           computeRestarts <- base::computeRestarts
[13:19:56.939]                           grepl <- base::grepl
[13:19:56.939]                           restarts <- computeRestarts(cond)
[13:19:56.939]                           for (restart in restarts) {
[13:19:56.939]                             name <- restart$name
[13:19:56.939]                             if (is.null(name)) 
[13:19:56.939]                               next
[13:19:56.939]                             if (!grepl(pattern, name)) 
[13:19:56.939]                               next
[13:19:56.939]                             invokeRestart(restart)
[13:19:56.939]                             muffled <- TRUE
[13:19:56.939]                             break
[13:19:56.939]                           }
[13:19:56.939]                         }
[13:19:56.939]                       }
[13:19:56.939]                       invisible(muffled)
[13:19:56.939]                     }
[13:19:56.939]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.939]                   }
[13:19:56.939]                 }
[13:19:56.939]                 else {
[13:19:56.939]                   if (TRUE) {
[13:19:56.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.939]                     {
[13:19:56.939]                       inherits <- base::inherits
[13:19:56.939]                       invokeRestart <- base::invokeRestart
[13:19:56.939]                       is.null <- base::is.null
[13:19:56.939]                       muffled <- FALSE
[13:19:56.939]                       if (inherits(cond, "message")) {
[13:19:56.939]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.939]                         if (muffled) 
[13:19:56.939]                           invokeRestart("muffleMessage")
[13:19:56.939]                       }
[13:19:56.939]                       else if (inherits(cond, "warning")) {
[13:19:56.939]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.939]                         if (muffled) 
[13:19:56.939]                           invokeRestart("muffleWarning")
[13:19:56.939]                       }
[13:19:56.939]                       else if (inherits(cond, "condition")) {
[13:19:56.939]                         if (!is.null(pattern)) {
[13:19:56.939]                           computeRestarts <- base::computeRestarts
[13:19:56.939]                           grepl <- base::grepl
[13:19:56.939]                           restarts <- computeRestarts(cond)
[13:19:56.939]                           for (restart in restarts) {
[13:19:56.939]                             name <- restart$name
[13:19:56.939]                             if (is.null(name)) 
[13:19:56.939]                               next
[13:19:56.939]                             if (!grepl(pattern, name)) 
[13:19:56.939]                               next
[13:19:56.939]                             invokeRestart(restart)
[13:19:56.939]                             muffled <- TRUE
[13:19:56.939]                             break
[13:19:56.939]                           }
[13:19:56.939]                         }
[13:19:56.939]                       }
[13:19:56.939]                       invisible(muffled)
[13:19:56.939]                     }
[13:19:56.939]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.939]                   }
[13:19:56.939]                 }
[13:19:56.939]             }
[13:19:56.939]         }))
[13:19:56.939]     }, error = function(ex) {
[13:19:56.939]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.939]                 ...future.rng), started = ...future.startTime, 
[13:19:56.939]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.939]             version = "1.8"), class = "FutureResult")
[13:19:56.939]     }, finally = {
[13:19:56.939]         if (!identical(...future.workdir, getwd())) 
[13:19:56.939]             setwd(...future.workdir)
[13:19:56.939]         {
[13:19:56.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.939]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.939]             }
[13:19:56.939]             base::options(...future.oldOptions)
[13:19:56.939]             if (.Platform$OS.type == "windows") {
[13:19:56.939]                 old_names <- names(...future.oldEnvVars)
[13:19:56.939]                 envs <- base::Sys.getenv()
[13:19:56.939]                 names <- names(envs)
[13:19:56.939]                 common <- intersect(names, old_names)
[13:19:56.939]                 added <- setdiff(names, old_names)
[13:19:56.939]                 removed <- setdiff(old_names, names)
[13:19:56.939]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.939]                   envs[common]]
[13:19:56.939]                 NAMES <- toupper(changed)
[13:19:56.939]                 args <- list()
[13:19:56.939]                 for (kk in seq_along(NAMES)) {
[13:19:56.939]                   name <- changed[[kk]]
[13:19:56.939]                   NAME <- NAMES[[kk]]
[13:19:56.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.939]                     next
[13:19:56.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.939]                 }
[13:19:56.939]                 NAMES <- toupper(added)
[13:19:56.939]                 for (kk in seq_along(NAMES)) {
[13:19:56.939]                   name <- added[[kk]]
[13:19:56.939]                   NAME <- NAMES[[kk]]
[13:19:56.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.939]                     next
[13:19:56.939]                   args[[name]] <- ""
[13:19:56.939]                 }
[13:19:56.939]                 NAMES <- toupper(removed)
[13:19:56.939]                 for (kk in seq_along(NAMES)) {
[13:19:56.939]                   name <- removed[[kk]]
[13:19:56.939]                   NAME <- NAMES[[kk]]
[13:19:56.939]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.939]                     next
[13:19:56.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.939]                 }
[13:19:56.939]                 if (length(args) > 0) 
[13:19:56.939]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.939]             }
[13:19:56.939]             else {
[13:19:56.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.939]             }
[13:19:56.939]             {
[13:19:56.939]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.939]                   0L) {
[13:19:56.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.939]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.939]                   base::options(opts)
[13:19:56.939]                 }
[13:19:56.939]                 {
[13:19:56.939]                   {
[13:19:56.939]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:56.939]                     NULL
[13:19:56.939]                   }
[13:19:56.939]                   options(future.plan = NULL)
[13:19:56.939]                   if (is.na(NA_character_)) 
[13:19:56.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.939]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:56.939]                     envir = parent.frame()) 
[13:19:56.939]                   {
[13:19:56.939]                     default_workers <- missing(workers)
[13:19:56.939]                     if (is.function(workers)) 
[13:19:56.939]                       workers <- workers()
[13:19:56.939]                     workers <- structure(as.integer(workers), 
[13:19:56.939]                       class = class(workers))
[13:19:56.939]                     stop_if_not(is.finite(workers), workers >= 
[13:19:56.939]                       1L)
[13:19:56.939]                     if ((workers == 1L && !inherits(workers, 
[13:19:56.939]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:56.939]                       if (default_workers) 
[13:19:56.939]                         supportsMulticore(warn = TRUE)
[13:19:56.939]                       return(sequential(..., envir = envir))
[13:19:56.939]                     }
[13:19:56.939]                     oopts <- options(mc.cores = workers)
[13:19:56.939]                     on.exit(options(oopts))
[13:19:56.939]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:56.939]                       envir = envir)
[13:19:56.939]                     if (!future$lazy) 
[13:19:56.939]                       future <- run(future)
[13:19:56.939]                     invisible(future)
[13:19:56.939]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.939]                 }
[13:19:56.939]             }
[13:19:56.939]         }
[13:19:56.939]     })
[13:19:56.939]     if (TRUE) {
[13:19:56.939]         base::sink(type = "output", split = FALSE)
[13:19:56.939]         if (TRUE) {
[13:19:56.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.939]         }
[13:19:56.939]         else {
[13:19:56.939]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.939]         }
[13:19:56.939]         base::close(...future.stdout)
[13:19:56.939]         ...future.stdout <- NULL
[13:19:56.939]     }
[13:19:56.939]     ...future.result$conditions <- ...future.conditions
[13:19:56.939]     ...future.result$finished <- base::Sys.time()
[13:19:56.939]     ...future.result
[13:19:56.939] }
[13:19:56.942] assign_globals() ...
[13:19:56.942] List of 4
[13:19:56.942]  $ ii   : int 1
[13:19:56.942]  $ n    : int 4
[13:19:56.942]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[13:19:56.942]   ..- attr(*, "region")=List of 2
[13:19:56.942]   .. ..$ xrange: num [1:2] -2.25 -0.781
[13:19:56.942]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[13:19:56.942]   ..- attr(*, "tile")= int [1:2] 1 1
[13:19:56.942]  $ delay:function (counts)  
[13:19:56.942]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:56.942]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8ef43f8> 
[13:19:56.942]  - attr(*, "where")=List of 4
[13:19:56.942]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:56.942]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:56.942]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:56.942]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:56.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.942]  - attr(*, "resolved")= logi FALSE
[13:19:56.942]  - attr(*, "total_size")= num 14584
[13:19:56.942]  - attr(*, "already-done")= logi TRUE
[13:19:56.948] - copied ‘ii’ to environment
[13:19:56.948] - copied ‘n’ to environment
[13:19:56.948] - copied ‘C’ to environment
[13:19:56.948] - reassign environment for ‘delay’
[13:19:56.948] - copied ‘delay’ to environment
[13:19:56.949] assign_globals() ... done
[13:19:56.949] requestCore(): workers = 2
[13:19:56.952] MulticoreFuture started
[13:19:56.953] - Launch lazy future ... done
[13:19:56.953] run() for ‘MulticoreFuture’ ... done
[13:19:56.953] - run() ... done
[13:19:56.953] - resolved() ...
[13:19:56.953] plan(): Setting new future strategy stack:
[13:19:56.954] List of future strategies:
[13:19:56.954] 1. sequential:
[13:19:56.954]    - args: function (..., envir = parent.frame())
[13:19:56.954]    - tweaked: FALSE
[13:19:56.954]    - call: NULL
[13:19:56.955] plan(): nbrOfWorkers() = 1
[13:19:56.958] plan(): Setting new future strategy stack:
[13:19:56.958] List of future strategies:
[13:19:56.958] 1. multicore:
[13:19:56.958]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:56.958]    - tweaked: FALSE
[13:19:56.958]    - call: plan(strategy)
[13:19:56.963] plan(): nbrOfWorkers() = 2
[13:19:56.965] - resolved: TRUE
[13:19:56.965] - resolved() ... done
[13:19:56.965] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[13:19:56.971] signalConditions() ...
[13:19:56.971]  - include = ‘immediateCondition’
[13:19:56.971]  - exclude = 
[13:19:56.971]  - resignal = FALSE
[13:19:56.971]  - Number of conditions: 2
[13:19:56.971] signalConditions() ... done
[13:19:56.972] signalConditions() ...
[13:19:56.972]  - include = ‘immediateCondition’
[13:19:56.972]  - exclude = 
[13:19:56.972]  - resignal = FALSE
[13:19:56.972]  - Number of conditions: 2
[13:19:56.972] signalConditions() ... done
[13:19:56.972] Future state: ‘finished’
[13:19:56.972] signalConditions() ...
[13:19:56.972]  - include = ‘condition’
[13:19:56.973]  - exclude = ‘immediateCondition’
[13:19:56.973]  - resignal = TRUE
[13:19:56.973]  - Number of conditions: 2
[13:19:56.973]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[13:19:56.973]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:56.973] signalConditions() ... done
[13:19:56.974] resolved() for ‘Future’ ...
[13:19:56.974] - state: ‘created’
[13:19:56.974] - run: TRUE
[13:19:56.974] - run() ...
[13:19:56.975] run() for ‘Future’ ...
[13:19:56.975] - state: ‘created’
[13:19:56.975] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:56.980] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:56.980] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:56.980]   - Field: ‘label’
[13:19:56.980]   - Field: ‘local’
[13:19:56.980]   - Field: ‘owner’
[13:19:56.984]   - Field: ‘envir’
[13:19:56.984]   - Field: ‘workers’
[13:19:56.984]   - Field: ‘packages’
[13:19:56.984]   - Field: ‘gc’
[13:19:56.984]   - Field: ‘job’
[13:19:56.984]   - Field: ‘conditions’
[13:19:56.985]   - Field: ‘expr’
[13:19:56.985]   - Field: ‘uuid’
[13:19:56.985]   - Field: ‘seed’
[13:19:56.985]   - Field: ‘version’
[13:19:56.985]   - Field: ‘result’
[13:19:56.985]   - Field: ‘asynchronous’
[13:19:56.985]   - Field: ‘calls’
[13:19:56.985]   - Field: ‘globals’
[13:19:56.986]   - Field: ‘stdout’
[13:19:56.986]   - Field: ‘earlySignal’
[13:19:56.986]   - Field: ‘lazy’
[13:19:56.986]   - Field: ‘state’
[13:19:56.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:56.986] - Launch lazy future ...
[13:19:56.986] Packages needed by the future expression (n = 1): ‘future’
[13:19:56.987] Packages needed by future strategies (n = 0): <none>
[13:19:56.987] {
[13:19:56.987]     {
[13:19:56.987]         {
[13:19:56.987]             ...future.startTime <- base::Sys.time()
[13:19:56.987]             {
[13:19:56.987]                 {
[13:19:56.987]                   {
[13:19:56.987]                     {
[13:19:56.987]                       {
[13:19:56.987]                         base::local({
[13:19:56.987]                           has_future <- base::requireNamespace("future", 
[13:19:56.987]                             quietly = TRUE)
[13:19:56.987]                           if (has_future) {
[13:19:56.987]                             ns <- base::getNamespace("future")
[13:19:56.987]                             version <- ns[[".package"]][["version"]]
[13:19:56.987]                             if (is.null(version)) 
[13:19:56.987]                               version <- utils::packageVersion("future")
[13:19:56.987]                           }
[13:19:56.987]                           else {
[13:19:56.987]                             version <- NULL
[13:19:56.987]                           }
[13:19:56.987]                           if (!has_future || version < "1.8.0") {
[13:19:56.987]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:56.987]                               "", base::R.version$version.string), 
[13:19:56.987]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:56.987]                                 base::R.version$platform, 8 * 
[13:19:56.987]                                   base::.Machine$sizeof.pointer), 
[13:19:56.987]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:56.987]                                 "release", "version")], collapse = " "), 
[13:19:56.987]                               hostname = base::Sys.info()[["nodename"]])
[13:19:56.987]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:56.987]                               info)
[13:19:56.987]                             info <- base::paste(info, collapse = "; ")
[13:19:56.987]                             if (!has_future) {
[13:19:56.987]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:56.987]                                 info)
[13:19:56.987]                             }
[13:19:56.987]                             else {
[13:19:56.987]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:56.987]                                 info, version)
[13:19:56.987]                             }
[13:19:56.987]                             base::stop(msg)
[13:19:56.987]                           }
[13:19:56.987]                         })
[13:19:56.987]                       }
[13:19:56.987]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:56.987]                       base::options(mc.cores = 1L)
[13:19:56.987]                     }
[13:19:56.987]                     base::local({
[13:19:56.987]                       for (pkg in "future") {
[13:19:56.987]                         base::loadNamespace(pkg)
[13:19:56.987]                         base::library(pkg, character.only = TRUE)
[13:19:56.987]                       }
[13:19:56.987]                     })
[13:19:56.987]                   }
[13:19:56.987]                   options(future.plan = NULL)
[13:19:56.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:56.987]                 }
[13:19:56.987]                 ...future.workdir <- getwd()
[13:19:56.987]             }
[13:19:56.987]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:56.987]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:56.987]         }
[13:19:56.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:56.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:56.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:56.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:56.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:56.987]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:56.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:56.987]             base::names(...future.oldOptions))
[13:19:56.987]     }
[13:19:56.987]     if (FALSE) {
[13:19:56.987]     }
[13:19:56.987]     else {
[13:19:56.987]         if (TRUE) {
[13:19:56.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:56.987]                 open = "w")
[13:19:56.987]         }
[13:19:56.987]         else {
[13:19:56.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:56.987]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:56.987]         }
[13:19:56.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:56.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:56.987]             base::sink(type = "output", split = FALSE)
[13:19:56.987]             base::close(...future.stdout)
[13:19:56.987]         }, add = TRUE)
[13:19:56.987]     }
[13:19:56.987]     ...future.frame <- base::sys.nframe()
[13:19:56.987]     ...future.conditions <- base::list()
[13:19:56.987]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:56.987]     if (FALSE) {
[13:19:56.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:56.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:56.987]     }
[13:19:56.987]     ...future.result <- base::tryCatch({
[13:19:56.987]         base::withCallingHandlers({
[13:19:56.987]             ...future.value <- base::withVisible(base::local({
[13:19:56.987]                 withCallingHandlers({
[13:19:56.987]                   {
[13:19:56.987]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:56.987]                       ii, n), appendLF = FALSE)
[13:19:56.987]                     fit <- mandelbrot(C)
[13:19:56.987]                     delay(fit)
[13:19:56.987]                     message(" done")
[13:19:56.987]                     fit
[13:19:56.987]                   }
[13:19:56.987]                 }, immediateCondition = function(cond) {
[13:19:56.987]                   save_rds <- function (object, pathname, ...) 
[13:19:56.987]                   {
[13:19:56.987]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:56.987]                     if (file_test("-f", pathname_tmp)) {
[13:19:56.987]                       fi_tmp <- file.info(pathname_tmp)
[13:19:56.987]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:56.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:56.987]                         fi_tmp[["mtime"]])
[13:19:56.987]                     }
[13:19:56.987]                     tryCatch({
[13:19:56.987]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:56.987]                     }, error = function(ex) {
[13:19:56.987]                       msg <- conditionMessage(ex)
[13:19:56.987]                       fi_tmp <- file.info(pathname_tmp)
[13:19:56.987]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:56.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:56.987]                         fi_tmp[["mtime"]], msg)
[13:19:56.987]                       ex$message <- msg
[13:19:56.987]                       stop(ex)
[13:19:56.987]                     })
[13:19:56.987]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:56.987]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:56.987]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:56.987]                       fi_tmp <- file.info(pathname_tmp)
[13:19:56.987]                       fi <- file.info(pathname)
[13:19:56.987]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:56.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:56.987]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:56.987]                         fi[["size"]], fi[["mtime"]])
[13:19:56.987]                       stop(msg)
[13:19:56.987]                     }
[13:19:56.987]                     invisible(pathname)
[13:19:56.987]                   }
[13:19:56.987]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:56.987]                     rootPath = tempdir()) 
[13:19:56.987]                   {
[13:19:56.987]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:56.987]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:56.987]                       tmpdir = path, fileext = ".rds")
[13:19:56.987]                     save_rds(obj, file)
[13:19:56.987]                   }
[13:19:56.987]                   saveImmediateCondition(cond, path = "/tmp/RtmpuMztud/.future/immediateConditions")
[13:19:56.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.987]                   {
[13:19:56.987]                     inherits <- base::inherits
[13:19:56.987]                     invokeRestart <- base::invokeRestart
[13:19:56.987]                     is.null <- base::is.null
[13:19:56.987]                     muffled <- FALSE
[13:19:56.987]                     if (inherits(cond, "message")) {
[13:19:56.987]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:56.987]                       if (muffled) 
[13:19:56.987]                         invokeRestart("muffleMessage")
[13:19:56.987]                     }
[13:19:56.987]                     else if (inherits(cond, "warning")) {
[13:19:56.987]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:56.987]                       if (muffled) 
[13:19:56.987]                         invokeRestart("muffleWarning")
[13:19:56.987]                     }
[13:19:56.987]                     else if (inherits(cond, "condition")) {
[13:19:56.987]                       if (!is.null(pattern)) {
[13:19:56.987]                         computeRestarts <- base::computeRestarts
[13:19:56.987]                         grepl <- base::grepl
[13:19:56.987]                         restarts <- computeRestarts(cond)
[13:19:56.987]                         for (restart in restarts) {
[13:19:56.987]                           name <- restart$name
[13:19:56.987]                           if (is.null(name)) 
[13:19:56.987]                             next
[13:19:56.987]                           if (!grepl(pattern, name)) 
[13:19:56.987]                             next
[13:19:56.987]                           invokeRestart(restart)
[13:19:56.987]                           muffled <- TRUE
[13:19:56.987]                           break
[13:19:56.987]                         }
[13:19:56.987]                       }
[13:19:56.987]                     }
[13:19:56.987]                     invisible(muffled)
[13:19:56.987]                   }
[13:19:56.987]                   muffleCondition(cond)
[13:19:56.987]                 })
[13:19:56.987]             }))
[13:19:56.987]             future::FutureResult(value = ...future.value$value, 
[13:19:56.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.987]                   ...future.rng), globalenv = if (FALSE) 
[13:19:56.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:56.987]                     ...future.globalenv.names))
[13:19:56.987]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:56.987]         }, condition = base::local({
[13:19:56.987]             c <- base::c
[13:19:56.987]             inherits <- base::inherits
[13:19:56.987]             invokeRestart <- base::invokeRestart
[13:19:56.987]             length <- base::length
[13:19:56.987]             list <- base::list
[13:19:56.987]             seq.int <- base::seq.int
[13:19:56.987]             signalCondition <- base::signalCondition
[13:19:56.987]             sys.calls <- base::sys.calls
[13:19:56.987]             `[[` <- base::`[[`
[13:19:56.987]             `+` <- base::`+`
[13:19:56.987]             `<<-` <- base::`<<-`
[13:19:56.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:56.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:56.987]                   3L)]
[13:19:56.987]             }
[13:19:56.987]             function(cond) {
[13:19:56.987]                 is_error <- inherits(cond, "error")
[13:19:56.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:56.987]                   NULL)
[13:19:56.987]                 if (is_error) {
[13:19:56.987]                   sessionInformation <- function() {
[13:19:56.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:56.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:56.987]                       search = base::search(), system = base::Sys.info())
[13:19:56.987]                   }
[13:19:56.987]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:56.987]                     cond$call), session = sessionInformation(), 
[13:19:56.987]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:56.987]                   signalCondition(cond)
[13:19:56.987]                 }
[13:19:56.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:56.987]                 "immediateCondition"))) {
[13:19:56.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:56.987]                   ...future.conditions[[length(...future.conditions) + 
[13:19:56.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:56.987]                   if (TRUE && !signal) {
[13:19:56.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.987]                     {
[13:19:56.987]                       inherits <- base::inherits
[13:19:56.987]                       invokeRestart <- base::invokeRestart
[13:19:56.987]                       is.null <- base::is.null
[13:19:56.987]                       muffled <- FALSE
[13:19:56.987]                       if (inherits(cond, "message")) {
[13:19:56.987]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.987]                         if (muffled) 
[13:19:56.987]                           invokeRestart("muffleMessage")
[13:19:56.987]                       }
[13:19:56.987]                       else if (inherits(cond, "warning")) {
[13:19:56.987]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.987]                         if (muffled) 
[13:19:56.987]                           invokeRestart("muffleWarning")
[13:19:56.987]                       }
[13:19:56.987]                       else if (inherits(cond, "condition")) {
[13:19:56.987]                         if (!is.null(pattern)) {
[13:19:56.987]                           computeRestarts <- base::computeRestarts
[13:19:56.987]                           grepl <- base::grepl
[13:19:56.987]                           restarts <- computeRestarts(cond)
[13:19:56.987]                           for (restart in restarts) {
[13:19:56.987]                             name <- restart$name
[13:19:56.987]                             if (is.null(name)) 
[13:19:56.987]                               next
[13:19:56.987]                             if (!grepl(pattern, name)) 
[13:19:56.987]                               next
[13:19:56.987]                             invokeRestart(restart)
[13:19:56.987]                             muffled <- TRUE
[13:19:56.987]                             break
[13:19:56.987]                           }
[13:19:56.987]                         }
[13:19:56.987]                       }
[13:19:56.987]                       invisible(muffled)
[13:19:56.987]                     }
[13:19:56.987]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.987]                   }
[13:19:56.987]                 }
[13:19:56.987]                 else {
[13:19:56.987]                   if (TRUE) {
[13:19:56.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:56.987]                     {
[13:19:56.987]                       inherits <- base::inherits
[13:19:56.987]                       invokeRestart <- base::invokeRestart
[13:19:56.987]                       is.null <- base::is.null
[13:19:56.987]                       muffled <- FALSE
[13:19:56.987]                       if (inherits(cond, "message")) {
[13:19:56.987]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:56.987]                         if (muffled) 
[13:19:56.987]                           invokeRestart("muffleMessage")
[13:19:56.987]                       }
[13:19:56.987]                       else if (inherits(cond, "warning")) {
[13:19:56.987]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:56.987]                         if (muffled) 
[13:19:56.987]                           invokeRestart("muffleWarning")
[13:19:56.987]                       }
[13:19:56.987]                       else if (inherits(cond, "condition")) {
[13:19:56.987]                         if (!is.null(pattern)) {
[13:19:56.987]                           computeRestarts <- base::computeRestarts
[13:19:56.987]                           grepl <- base::grepl
[13:19:56.987]                           restarts <- computeRestarts(cond)
[13:19:56.987]                           for (restart in restarts) {
[13:19:56.987]                             name <- restart$name
[13:19:56.987]                             if (is.null(name)) 
[13:19:56.987]                               next
[13:19:56.987]                             if (!grepl(pattern, name)) 
[13:19:56.987]                               next
[13:19:56.987]                             invokeRestart(restart)
[13:19:56.987]                             muffled <- TRUE
[13:19:56.987]                             break
[13:19:56.987]                           }
[13:19:56.987]                         }
[13:19:56.987]                       }
[13:19:56.987]                       invisible(muffled)
[13:19:56.987]                     }
[13:19:56.987]                     muffleCondition(cond, pattern = "^muffle")
[13:19:56.987]                   }
[13:19:56.987]                 }
[13:19:56.987]             }
[13:19:56.987]         }))
[13:19:56.987]     }, error = function(ex) {
[13:19:56.987]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:56.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:56.987]                 ...future.rng), started = ...future.startTime, 
[13:19:56.987]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:56.987]             version = "1.8"), class = "FutureResult")
[13:19:56.987]     }, finally = {
[13:19:56.987]         if (!identical(...future.workdir, getwd())) 
[13:19:56.987]             setwd(...future.workdir)
[13:19:56.987]         {
[13:19:56.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:56.987]                 ...future.oldOptions$nwarnings <- NULL
[13:19:56.987]             }
[13:19:56.987]             base::options(...future.oldOptions)
[13:19:56.987]             if (.Platform$OS.type == "windows") {
[13:19:56.987]                 old_names <- names(...future.oldEnvVars)
[13:19:56.987]                 envs <- base::Sys.getenv()
[13:19:56.987]                 names <- names(envs)
[13:19:56.987]                 common <- intersect(names, old_names)
[13:19:56.987]                 added <- setdiff(names, old_names)
[13:19:56.987]                 removed <- setdiff(old_names, names)
[13:19:56.987]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:56.987]                   envs[common]]
[13:19:56.987]                 NAMES <- toupper(changed)
[13:19:56.987]                 args <- list()
[13:19:56.987]                 for (kk in seq_along(NAMES)) {
[13:19:56.987]                   name <- changed[[kk]]
[13:19:56.987]                   NAME <- NAMES[[kk]]
[13:19:56.987]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.987]                     next
[13:19:56.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.987]                 }
[13:19:56.987]                 NAMES <- toupper(added)
[13:19:56.987]                 for (kk in seq_along(NAMES)) {
[13:19:56.987]                   name <- added[[kk]]
[13:19:56.987]                   NAME <- NAMES[[kk]]
[13:19:56.987]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.987]                     next
[13:19:56.987]                   args[[name]] <- ""
[13:19:56.987]                 }
[13:19:56.987]                 NAMES <- toupper(removed)
[13:19:56.987]                 for (kk in seq_along(NAMES)) {
[13:19:56.987]                   name <- removed[[kk]]
[13:19:56.987]                   NAME <- NAMES[[kk]]
[13:19:56.987]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:56.987]                     next
[13:19:56.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:56.987]                 }
[13:19:56.987]                 if (length(args) > 0) 
[13:19:56.987]                   base::do.call(base::Sys.setenv, args = args)
[13:19:56.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:56.987]             }
[13:19:56.987]             else {
[13:19:56.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:56.987]             }
[13:19:56.987]             {
[13:19:56.987]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:56.987]                   0L) {
[13:19:56.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:56.987]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:56.987]                   base::options(opts)
[13:19:56.987]                 }
[13:19:56.987]                 {
[13:19:56.987]                   {
[13:19:56.987]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:56.987]                     NULL
[13:19:56.987]                   }
[13:19:56.987]                   options(future.plan = NULL)
[13:19:56.987]                   if (is.na(NA_character_)) 
[13:19:56.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:56.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:56.987]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:56.987]                     envir = parent.frame()) 
[13:19:56.987]                   {
[13:19:56.987]                     default_workers <- missing(workers)
[13:19:56.987]                     if (is.function(workers)) 
[13:19:56.987]                       workers <- workers()
[13:19:56.987]                     workers <- structure(as.integer(workers), 
[13:19:56.987]                       class = class(workers))
[13:19:56.987]                     stop_if_not(is.finite(workers), workers >= 
[13:19:56.987]                       1L)
[13:19:56.987]                     if ((workers == 1L && !inherits(workers, 
[13:19:56.987]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:56.987]                       if (default_workers) 
[13:19:56.987]                         supportsMulticore(warn = TRUE)
[13:19:56.987]                       return(sequential(..., envir = envir))
[13:19:56.987]                     }
[13:19:56.987]                     oopts <- options(mc.cores = workers)
[13:19:56.987]                     on.exit(options(oopts))
[13:19:56.987]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:56.987]                       envir = envir)
[13:19:56.987]                     if (!future$lazy) 
[13:19:56.987]                       future <- run(future)
[13:19:56.987]                     invisible(future)
[13:19:56.987]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:56.987]                 }
[13:19:56.987]             }
[13:19:56.987]         }
[13:19:56.987]     })
[13:19:56.987]     if (TRUE) {
[13:19:56.987]         base::sink(type = "output", split = FALSE)
[13:19:56.987]         if (TRUE) {
[13:19:56.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:56.987]         }
[13:19:56.987]         else {
[13:19:56.987]             ...future.result["stdout"] <- base::list(NULL)
[13:19:56.987]         }
[13:19:56.987]         base::close(...future.stdout)
[13:19:56.987]         ...future.stdout <- NULL
[13:19:56.987]     }
[13:19:56.987]     ...future.result$conditions <- ...future.conditions
[13:19:56.987]     ...future.result$finished <- base::Sys.time()
[13:19:56.987]     ...future.result
[13:19:56.987] }
[13:19:56.990] assign_globals() ...
[13:19:56.990] List of 4
[13:19:56.990]  $ ii   : int 2
[13:19:56.990]  $ n    : int 4
[13:19:56.990]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[13:19:56.990]   ..- attr(*, "region")=List of 2
[13:19:56.990]   .. ..$ xrange: num [1:2] -0.719 0.75
[13:19:56.990]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[13:19:56.990]   ..- attr(*, "tile")= int [1:2] 1 2
[13:19:56.990]  $ delay:function (counts)  
[13:19:56.990]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:56.990]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8ef43f8> 
[13:19:56.990]  - attr(*, "where")=List of 4
[13:19:56.990]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:56.990]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:56.990]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:56.990]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:56.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:56.990]  - attr(*, "resolved")= logi FALSE
[13:19:56.990]  - attr(*, "total_size")= num 14584
[13:19:56.990]  - attr(*, "already-done")= logi TRUE
[13:19:56.998] - copied ‘ii’ to environment
[13:19:56.998] - copied ‘n’ to environment
[13:19:56.998] - copied ‘C’ to environment
[13:19:56.998] - reassign environment for ‘delay’
[13:19:56.998] - copied ‘delay’ to environment
[13:19:56.998] assign_globals() ... done
[13:19:56.998] requestCore(): workers = 2
[13:19:57.001] MulticoreFuture started
[13:19:57.001] - Launch lazy future ... done
[13:19:57.001] run() for ‘MulticoreFuture’ ... done
[13:19:57.002] - run() ... done
[13:19:57.002] - resolved() ...
[13:19:57.002] plan(): Setting new future strategy stack:
[13:19:57.003] List of future strategies:
[13:19:57.003] 1. sequential:
[13:19:57.003]    - args: function (..., envir = parent.frame())
[13:19:57.003]    - tweaked: FALSE
[13:19:57.003]    - call: NULL
[13:19:57.004] plan(): nbrOfWorkers() = 1
[13:19:57.009] plan(): Setting new future strategy stack:
[13:19:57.009] List of future strategies:
[13:19:57.009] 1. multicore:
[13:19:57.009]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.009]    - tweaked: FALSE
[13:19:57.009]    - call: plan(strategy)
[13:19:57.012] - resolved: FALSE
[13:19:57.013] - resolved() ... done
[13:19:57.013] resolved() for ‘MulticoreFuture’ ... done
[13:19:57.013] resolved() for ‘Future’ ...
[13:19:57.013] - state: ‘created’
[13:19:57.013] - run: TRUE
[13:19:57.013] - run() ...
[13:19:57.014] run() for ‘Future’ ...
[13:19:57.014] - state: ‘created’
[13:19:57.014] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.015] plan(): nbrOfWorkers() = 2
[13:19:57.018] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.019] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.019]   - Field: ‘label’
[13:19:57.019]   - Field: ‘local’
[13:19:57.019]   - Field: ‘owner’
[13:19:57.019]   - Field: ‘envir’
[13:19:57.019]   - Field: ‘workers’
[13:19:57.019]   - Field: ‘packages’
[13:19:57.020]   - Field: ‘gc’
[13:19:57.020]   - Field: ‘job’
[13:19:57.020]   - Field: ‘conditions’
[13:19:57.020]   - Field: ‘expr’
[13:19:57.020]   - Field: ‘uuid’
[13:19:57.020]   - Field: ‘seed’
[13:19:57.021]   - Field: ‘version’
[13:19:57.021]   - Field: ‘result’
[13:19:57.021]   - Field: ‘asynchronous’
[13:19:57.021]   - Field: ‘calls’
[13:19:57.021]   - Field: ‘globals’
[13:19:57.021]   - Field: ‘stdout’
[13:19:57.022]   - Field: ‘earlySignal’
[13:19:57.022]   - Field: ‘lazy’
[13:19:57.022]   - Field: ‘state’
[13:19:57.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.022] - Launch lazy future ...
[13:19:57.023] Packages needed by the future expression (n = 1): ‘future’
[13:19:57.023] Packages needed by future strategies (n = 0): <none>
[13:19:57.024] {
[13:19:57.024]     {
[13:19:57.024]         {
[13:19:57.024]             ...future.startTime <- base::Sys.time()
[13:19:57.024]             {
[13:19:57.024]                 {
[13:19:57.024]                   {
[13:19:57.024]                     {
[13:19:57.024]                       {
[13:19:57.024]                         base::local({
[13:19:57.024]                           has_future <- base::requireNamespace("future", 
[13:19:57.024]                             quietly = TRUE)
[13:19:57.024]                           if (has_future) {
[13:19:57.024]                             ns <- base::getNamespace("future")
[13:19:57.024]                             version <- ns[[".package"]][["version"]]
[13:19:57.024]                             if (is.null(version)) 
[13:19:57.024]                               version <- utils::packageVersion("future")
[13:19:57.024]                           }
[13:19:57.024]                           else {
[13:19:57.024]                             version <- NULL
[13:19:57.024]                           }
[13:19:57.024]                           if (!has_future || version < "1.8.0") {
[13:19:57.024]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.024]                               "", base::R.version$version.string), 
[13:19:57.024]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:57.024]                                 base::R.version$platform, 8 * 
[13:19:57.024]                                   base::.Machine$sizeof.pointer), 
[13:19:57.024]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.024]                                 "release", "version")], collapse = " "), 
[13:19:57.024]                               hostname = base::Sys.info()[["nodename"]])
[13:19:57.024]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.024]                               info)
[13:19:57.024]                             info <- base::paste(info, collapse = "; ")
[13:19:57.024]                             if (!has_future) {
[13:19:57.024]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.024]                                 info)
[13:19:57.024]                             }
[13:19:57.024]                             else {
[13:19:57.024]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.024]                                 info, version)
[13:19:57.024]                             }
[13:19:57.024]                             base::stop(msg)
[13:19:57.024]                           }
[13:19:57.024]                         })
[13:19:57.024]                       }
[13:19:57.024]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.024]                       base::options(mc.cores = 1L)
[13:19:57.024]                     }
[13:19:57.024]                     base::local({
[13:19:57.024]                       for (pkg in "future") {
[13:19:57.024]                         base::loadNamespace(pkg)
[13:19:57.024]                         base::library(pkg, character.only = TRUE)
[13:19:57.024]                       }
[13:19:57.024]                     })
[13:19:57.024]                   }
[13:19:57.024]                   options(future.plan = NULL)
[13:19:57.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.024]                 }
[13:19:57.024]                 ...future.workdir <- getwd()
[13:19:57.024]             }
[13:19:57.024]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.024]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.024]         }
[13:19:57.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:57.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.024]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.024]             base::names(...future.oldOptions))
[13:19:57.024]     }
[13:19:57.024]     if (FALSE) {
[13:19:57.024]     }
[13:19:57.024]     else {
[13:19:57.024]         if (TRUE) {
[13:19:57.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.024]                 open = "w")
[13:19:57.024]         }
[13:19:57.024]         else {
[13:19:57.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.024]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.024]         }
[13:19:57.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.024]             base::sink(type = "output", split = FALSE)
[13:19:57.024]             base::close(...future.stdout)
[13:19:57.024]         }, add = TRUE)
[13:19:57.024]     }
[13:19:57.024]     ...future.frame <- base::sys.nframe()
[13:19:57.024]     ...future.conditions <- base::list()
[13:19:57.024]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.024]     if (FALSE) {
[13:19:57.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.024]     }
[13:19:57.024]     ...future.result <- base::tryCatch({
[13:19:57.024]         base::withCallingHandlers({
[13:19:57.024]             ...future.value <- base::withVisible(base::local({
[13:19:57.024]                 withCallingHandlers({
[13:19:57.024]                   {
[13:19:57.024]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:57.024]                       ii, n), appendLF = FALSE)
[13:19:57.024]                     fit <- mandelbrot(C)
[13:19:57.024]                     delay(fit)
[13:19:57.024]                     message(" done")
[13:19:57.024]                     fit
[13:19:57.024]                   }
[13:19:57.024]                 }, immediateCondition = function(cond) {
[13:19:57.024]                   save_rds <- function (object, pathname, ...) 
[13:19:57.024]                   {
[13:19:57.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.024]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.024]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.024]                         fi_tmp[["mtime"]])
[13:19:57.024]                     }
[13:19:57.024]                     tryCatch({
[13:19:57.024]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.024]                     }, error = function(ex) {
[13:19:57.024]                       msg <- conditionMessage(ex)
[13:19:57.024]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.024]                         fi_tmp[["mtime"]], msg)
[13:19:57.024]                       ex$message <- msg
[13:19:57.024]                       stop(ex)
[13:19:57.024]                     })
[13:19:57.024]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.024]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.024]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.024]                       fi <- file.info(pathname)
[13:19:57.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.024]                         fi[["size"]], fi[["mtime"]])
[13:19:57.024]                       stop(msg)
[13:19:57.024]                     }
[13:19:57.024]                     invisible(pathname)
[13:19:57.024]                   }
[13:19:57.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.024]                     rootPath = tempdir()) 
[13:19:57.024]                   {
[13:19:57.024]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.024]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.024]                       tmpdir = path, fileext = ".rds")
[13:19:57.024]                     save_rds(obj, file)
[13:19:57.024]                   }
[13:19:57.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpuMztud/.future/immediateConditions")
[13:19:57.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.024]                   {
[13:19:57.024]                     inherits <- base::inherits
[13:19:57.024]                     invokeRestart <- base::invokeRestart
[13:19:57.024]                     is.null <- base::is.null
[13:19:57.024]                     muffled <- FALSE
[13:19:57.024]                     if (inherits(cond, "message")) {
[13:19:57.024]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.024]                       if (muffled) 
[13:19:57.024]                         invokeRestart("muffleMessage")
[13:19:57.024]                     }
[13:19:57.024]                     else if (inherits(cond, "warning")) {
[13:19:57.024]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.024]                       if (muffled) 
[13:19:57.024]                         invokeRestart("muffleWarning")
[13:19:57.024]                     }
[13:19:57.024]                     else if (inherits(cond, "condition")) {
[13:19:57.024]                       if (!is.null(pattern)) {
[13:19:57.024]                         computeRestarts <- base::computeRestarts
[13:19:57.024]                         grepl <- base::grepl
[13:19:57.024]                         restarts <- computeRestarts(cond)
[13:19:57.024]                         for (restart in restarts) {
[13:19:57.024]                           name <- restart$name
[13:19:57.024]                           if (is.null(name)) 
[13:19:57.024]                             next
[13:19:57.024]                           if (!grepl(pattern, name)) 
[13:19:57.024]                             next
[13:19:57.024]                           invokeRestart(restart)
[13:19:57.024]                           muffled <- TRUE
[13:19:57.024]                           break
[13:19:57.024]                         }
[13:19:57.024]                       }
[13:19:57.024]                     }
[13:19:57.024]                     invisible(muffled)
[13:19:57.024]                   }
[13:19:57.024]                   muffleCondition(cond)
[13:19:57.024]                 })
[13:19:57.024]             }))
[13:19:57.024]             future::FutureResult(value = ...future.value$value, 
[13:19:57.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.024]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.024]                     ...future.globalenv.names))
[13:19:57.024]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.024]         }, condition = base::local({
[13:19:57.024]             c <- base::c
[13:19:57.024]             inherits <- base::inherits
[13:19:57.024]             invokeRestart <- base::invokeRestart
[13:19:57.024]             length <- base::length
[13:19:57.024]             list <- base::list
[13:19:57.024]             seq.int <- base::seq.int
[13:19:57.024]             signalCondition <- base::signalCondition
[13:19:57.024]             sys.calls <- base::sys.calls
[13:19:57.024]             `[[` <- base::`[[`
[13:19:57.024]             `+` <- base::`+`
[13:19:57.024]             `<<-` <- base::`<<-`
[13:19:57.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.024]                   3L)]
[13:19:57.024]             }
[13:19:57.024]             function(cond) {
[13:19:57.024]                 is_error <- inherits(cond, "error")
[13:19:57.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.024]                   NULL)
[13:19:57.024]                 if (is_error) {
[13:19:57.024]                   sessionInformation <- function() {
[13:19:57.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.024]                       search = base::search(), system = base::Sys.info())
[13:19:57.024]                   }
[13:19:57.024]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.024]                     cond$call), session = sessionInformation(), 
[13:19:57.024]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.024]                   signalCondition(cond)
[13:19:57.024]                 }
[13:19:57.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.024]                 "immediateCondition"))) {
[13:19:57.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.024]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.024]                   if (TRUE && !signal) {
[13:19:57.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.024]                     {
[13:19:57.024]                       inherits <- base::inherits
[13:19:57.024]                       invokeRestart <- base::invokeRestart
[13:19:57.024]                       is.null <- base::is.null
[13:19:57.024]                       muffled <- FALSE
[13:19:57.024]                       if (inherits(cond, "message")) {
[13:19:57.024]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.024]                         if (muffled) 
[13:19:57.024]                           invokeRestart("muffleMessage")
[13:19:57.024]                       }
[13:19:57.024]                       else if (inherits(cond, "warning")) {
[13:19:57.024]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.024]                         if (muffled) 
[13:19:57.024]                           invokeRestart("muffleWarning")
[13:19:57.024]                       }
[13:19:57.024]                       else if (inherits(cond, "condition")) {
[13:19:57.024]                         if (!is.null(pattern)) {
[13:19:57.024]                           computeRestarts <- base::computeRestarts
[13:19:57.024]                           grepl <- base::grepl
[13:19:57.024]                           restarts <- computeRestarts(cond)
[13:19:57.024]                           for (restart in restarts) {
[13:19:57.024]                             name <- restart$name
[13:19:57.024]                             if (is.null(name)) 
[13:19:57.024]                               next
[13:19:57.024]                             if (!grepl(pattern, name)) 
[13:19:57.024]                               next
[13:19:57.024]                             invokeRestart(restart)
[13:19:57.024]                             muffled <- TRUE
[13:19:57.024]                             break
[13:19:57.024]                           }
[13:19:57.024]                         }
[13:19:57.024]                       }
[13:19:57.024]                       invisible(muffled)
[13:19:57.024]                     }
[13:19:57.024]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.024]                   }
[13:19:57.024]                 }
[13:19:57.024]                 else {
[13:19:57.024]                   if (TRUE) {
[13:19:57.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.024]                     {
[13:19:57.024]                       inherits <- base::inherits
[13:19:57.024]                       invokeRestart <- base::invokeRestart
[13:19:57.024]                       is.null <- base::is.null
[13:19:57.024]                       muffled <- FALSE
[13:19:57.024]                       if (inherits(cond, "message")) {
[13:19:57.024]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.024]                         if (muffled) 
[13:19:57.024]                           invokeRestart("muffleMessage")
[13:19:57.024]                       }
[13:19:57.024]                       else if (inherits(cond, "warning")) {
[13:19:57.024]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.024]                         if (muffled) 
[13:19:57.024]                           invokeRestart("muffleWarning")
[13:19:57.024]                       }
[13:19:57.024]                       else if (inherits(cond, "condition")) {
[13:19:57.024]                         if (!is.null(pattern)) {
[13:19:57.024]                           computeRestarts <- base::computeRestarts
[13:19:57.024]                           grepl <- base::grepl
[13:19:57.024]                           restarts <- computeRestarts(cond)
[13:19:57.024]                           for (restart in restarts) {
[13:19:57.024]                             name <- restart$name
[13:19:57.024]                             if (is.null(name)) 
[13:19:57.024]                               next
[13:19:57.024]                             if (!grepl(pattern, name)) 
[13:19:57.024]                               next
[13:19:57.024]                             invokeRestart(restart)
[13:19:57.024]                             muffled <- TRUE
[13:19:57.024]                             break
[13:19:57.024]                           }
[13:19:57.024]                         }
[13:19:57.024]                       }
[13:19:57.024]                       invisible(muffled)
[13:19:57.024]                     }
[13:19:57.024]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.024]                   }
[13:19:57.024]                 }
[13:19:57.024]             }
[13:19:57.024]         }))
[13:19:57.024]     }, error = function(ex) {
[13:19:57.024]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.024]                 ...future.rng), started = ...future.startTime, 
[13:19:57.024]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.024]             version = "1.8"), class = "FutureResult")
[13:19:57.024]     }, finally = {
[13:19:57.024]         if (!identical(...future.workdir, getwd())) 
[13:19:57.024]             setwd(...future.workdir)
[13:19:57.024]         {
[13:19:57.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.024]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.024]             }
[13:19:57.024]             base::options(...future.oldOptions)
[13:19:57.024]             if (.Platform$OS.type == "windows") {
[13:19:57.024]                 old_names <- names(...future.oldEnvVars)
[13:19:57.024]                 envs <- base::Sys.getenv()
[13:19:57.024]                 names <- names(envs)
[13:19:57.024]                 common <- intersect(names, old_names)
[13:19:57.024]                 added <- setdiff(names, old_names)
[13:19:57.024]                 removed <- setdiff(old_names, names)
[13:19:57.024]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.024]                   envs[common]]
[13:19:57.024]                 NAMES <- toupper(changed)
[13:19:57.024]                 args <- list()
[13:19:57.024]                 for (kk in seq_along(NAMES)) {
[13:19:57.024]                   name <- changed[[kk]]
[13:19:57.024]                   NAME <- NAMES[[kk]]
[13:19:57.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.024]                     next
[13:19:57.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.024]                 }
[13:19:57.024]                 NAMES <- toupper(added)
[13:19:57.024]                 for (kk in seq_along(NAMES)) {
[13:19:57.024]                   name <- added[[kk]]
[13:19:57.024]                   NAME <- NAMES[[kk]]
[13:19:57.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.024]                     next
[13:19:57.024]                   args[[name]] <- ""
[13:19:57.024]                 }
[13:19:57.024]                 NAMES <- toupper(removed)
[13:19:57.024]                 for (kk in seq_along(NAMES)) {
[13:19:57.024]                   name <- removed[[kk]]
[13:19:57.024]                   NAME <- NAMES[[kk]]
[13:19:57.024]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.024]                     next
[13:19:57.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.024]                 }
[13:19:57.024]                 if (length(args) > 0) 
[13:19:57.024]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.024]             }
[13:19:57.024]             else {
[13:19:57.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.024]             }
[13:19:57.024]             {
[13:19:57.024]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.024]                   0L) {
[13:19:57.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.024]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.024]                   base::options(opts)
[13:19:57.024]                 }
[13:19:57.024]                 {
[13:19:57.024]                   {
[13:19:57.024]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.024]                     NULL
[13:19:57.024]                   }
[13:19:57.024]                   options(future.plan = NULL)
[13:19:57.024]                   if (is.na(NA_character_)) 
[13:19:57.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.024]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.024]                     envir = parent.frame()) 
[13:19:57.024]                   {
[13:19:57.024]                     default_workers <- missing(workers)
[13:19:57.024]                     if (is.function(workers)) 
[13:19:57.024]                       workers <- workers()
[13:19:57.024]                     workers <- structure(as.integer(workers), 
[13:19:57.024]                       class = class(workers))
[13:19:57.024]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.024]                       1L)
[13:19:57.024]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.024]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.024]                       if (default_workers) 
[13:19:57.024]                         supportsMulticore(warn = TRUE)
[13:19:57.024]                       return(sequential(..., envir = envir))
[13:19:57.024]                     }
[13:19:57.024]                     oopts <- options(mc.cores = workers)
[13:19:57.024]                     on.exit(options(oopts))
[13:19:57.024]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.024]                       envir = envir)
[13:19:57.024]                     if (!future$lazy) 
[13:19:57.024]                       future <- run(future)
[13:19:57.024]                     invisible(future)
[13:19:57.024]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.024]                 }
[13:19:57.024]             }
[13:19:57.024]         }
[13:19:57.024]     })
[13:19:57.024]     if (TRUE) {
[13:19:57.024]         base::sink(type = "output", split = FALSE)
[13:19:57.024]         if (TRUE) {
[13:19:57.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.024]         }
[13:19:57.024]         else {
[13:19:57.024]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.024]         }
[13:19:57.024]         base::close(...future.stdout)
[13:19:57.024]         ...future.stdout <- NULL
[13:19:57.024]     }
[13:19:57.024]     ...future.result$conditions <- ...future.conditions
[13:19:57.024]     ...future.result$finished <- base::Sys.time()
[13:19:57.024]     ...future.result
[13:19:57.024] }
[13:19:57.027] assign_globals() ...
[13:19:57.028] List of 4
[13:19:57.028]  $ ii   : int 3
[13:19:57.028]  $ n    : int 4
[13:19:57.028]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[13:19:57.028]   ..- attr(*, "region")=List of 2
[13:19:57.028]   .. ..$ xrange: num [1:2] -2.25 -0.781
[13:19:57.028]   .. ..$ yrange: num [1:2] 0.0306 1.5
[13:19:57.028]   ..- attr(*, "tile")= int [1:2] 2 1
[13:19:57.028]  $ delay:function (counts)  
[13:19:57.028]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:57.028]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8ef43f8> 
[13:19:57.028]  - attr(*, "where")=List of 4
[13:19:57.028]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:57.028]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:57.028]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:57.028]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:57.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.028]  - attr(*, "resolved")= logi FALSE
[13:19:57.028]  - attr(*, "total_size")= num 14584
[13:19:57.028]  - attr(*, "already-done")= logi TRUE
[13:19:57.038] - copied ‘ii’ to environment
[13:19:57.038] - copied ‘n’ to environment
[13:19:57.038] - copied ‘C’ to environment
[13:19:57.039] - reassign environment for ‘delay’
[13:19:57.039] - copied ‘delay’ to environment
[13:19:57.039] assign_globals() ... done
[13:19:57.039] requestCore(): workers = 2
[13:19:57.042] MulticoreFuture started
[13:19:57.042] - Launch lazy future ... done
[13:19:57.042] run() for ‘MulticoreFuture’ ... done
[13:19:57.042] - run() ... done
[13:19:57.042] - resolved() ...
[13:19:57.043] plan(): Setting new future strategy stack:
[13:19:57.043] List of future strategies:
[13:19:57.043] 1. sequential:
[13:19:57.043]    - args: function (..., envir = parent.frame())
[13:19:57.043]    - tweaked: FALSE
[13:19:57.043]    - call: NULL
[13:19:57.044] plan(): nbrOfWorkers() = 1
[13:19:57.048] plan(): Setting new future strategy stack:
[13:19:57.048] List of future strategies:
[13:19:57.048] 1. multicore:
[13:19:57.048]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.048]    - tweaked: FALSE
[13:19:57.048]    - call: plan(strategy)
[13:19:57.053] - resolved: FALSE
[13:19:57.053] - resolved() ... done
[13:19:57.053] resolved() for ‘MulticoreFuture’ ... done
[13:19:57.054] resolved() for ‘Future’ ...
[13:19:57.054] - state: ‘created’
[13:19:57.054] - run: TRUE
[13:19:57.054] - run() ...
[13:19:57.054] run() for ‘Future’ ...
[13:19:57.054] - state: ‘created’
[13:19:57.054] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.055] plan(): nbrOfWorkers() = 2
[13:19:57.060] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:57.060]   - Field: ‘label’
[13:19:57.061]   - Field: ‘local’
[13:19:57.061]   - Field: ‘owner’
[13:19:57.061]   - Field: ‘envir’
[13:19:57.061]   - Field: ‘workers’
[13:19:57.061]   - Field: ‘packages’
[13:19:57.061]   - Field: ‘gc’
[13:19:57.061]   - Field: ‘job’
[13:19:57.062]   - Field: ‘conditions’
[13:19:57.062]   - Field: ‘expr’
[13:19:57.062]   - Field: ‘uuid’
[13:19:57.062]   - Field: ‘seed’
[13:19:57.062]   - Field: ‘version’
[13:19:57.062]   - Field: ‘result’
[13:19:57.062]   - Field: ‘asynchronous’
[13:19:57.063]   - Field: ‘calls’
[13:19:57.063]   - Field: ‘globals’
[13:19:57.063]   - Field: ‘stdout’
[13:19:57.063]   - Field: ‘earlySignal’
[13:19:57.063]   - Field: ‘lazy’
[13:19:57.063]   - Field: ‘state’
[13:19:57.063] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:57.064] - Launch lazy future ...
[13:19:57.064] Packages needed by the future expression (n = 1): ‘future’
[13:19:57.064] Packages needed by future strategies (n = 0): <none>
[13:19:57.065] {
[13:19:57.065]     {
[13:19:57.065]         {
[13:19:57.065]             ...future.startTime <- base::Sys.time()
[13:19:57.065]             {
[13:19:57.065]                 {
[13:19:57.065]                   {
[13:19:57.065]                     {
[13:19:57.065]                       {
[13:19:57.065]                         base::local({
[13:19:57.065]                           has_future <- base::requireNamespace("future", 
[13:19:57.065]                             quietly = TRUE)
[13:19:57.065]                           if (has_future) {
[13:19:57.065]                             ns <- base::getNamespace("future")
[13:19:57.065]                             version <- ns[[".package"]][["version"]]
[13:19:57.065]                             if (is.null(version)) 
[13:19:57.065]                               version <- utils::packageVersion("future")
[13:19:57.065]                           }
[13:19:57.065]                           else {
[13:19:57.065]                             version <- NULL
[13:19:57.065]                           }
[13:19:57.065]                           if (!has_future || version < "1.8.0") {
[13:19:57.065]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.065]                               "", base::R.version$version.string), 
[13:19:57.065]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:57.065]                                 base::R.version$platform, 8 * 
[13:19:57.065]                                   base::.Machine$sizeof.pointer), 
[13:19:57.065]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.065]                                 "release", "version")], collapse = " "), 
[13:19:57.065]                               hostname = base::Sys.info()[["nodename"]])
[13:19:57.065]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.065]                               info)
[13:19:57.065]                             info <- base::paste(info, collapse = "; ")
[13:19:57.065]                             if (!has_future) {
[13:19:57.065]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.065]                                 info)
[13:19:57.065]                             }
[13:19:57.065]                             else {
[13:19:57.065]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.065]                                 info, version)
[13:19:57.065]                             }
[13:19:57.065]                             base::stop(msg)
[13:19:57.065]                           }
[13:19:57.065]                         })
[13:19:57.065]                       }
[13:19:57.065]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.065]                       base::options(mc.cores = 1L)
[13:19:57.065]                     }
[13:19:57.065]                     base::local({
[13:19:57.065]                       for (pkg in "future") {
[13:19:57.065]                         base::loadNamespace(pkg)
[13:19:57.065]                         base::library(pkg, character.only = TRUE)
[13:19:57.065]                       }
[13:19:57.065]                     })
[13:19:57.065]                   }
[13:19:57.065]                   options(future.plan = NULL)
[13:19:57.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.065]                 }
[13:19:57.065]                 ...future.workdir <- getwd()
[13:19:57.065]             }
[13:19:57.065]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.065]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.065]         }
[13:19:57.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:57.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.065]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.065]             base::names(...future.oldOptions))
[13:19:57.065]     }
[13:19:57.065]     if (FALSE) {
[13:19:57.065]     }
[13:19:57.065]     else {
[13:19:57.065]         if (TRUE) {
[13:19:57.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.065]                 open = "w")
[13:19:57.065]         }
[13:19:57.065]         else {
[13:19:57.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.065]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.065]         }
[13:19:57.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.065]             base::sink(type = "output", split = FALSE)
[13:19:57.065]             base::close(...future.stdout)
[13:19:57.065]         }, add = TRUE)
[13:19:57.065]     }
[13:19:57.065]     ...future.frame <- base::sys.nframe()
[13:19:57.065]     ...future.conditions <- base::list()
[13:19:57.065]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.065]     if (FALSE) {
[13:19:57.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.065]     }
[13:19:57.065]     ...future.result <- base::tryCatch({
[13:19:57.065]         base::withCallingHandlers({
[13:19:57.065]             ...future.value <- base::withVisible(base::local({
[13:19:57.065]                 withCallingHandlers({
[13:19:57.065]                   {
[13:19:57.065]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:57.065]                       ii, n), appendLF = FALSE)
[13:19:57.065]                     fit <- mandelbrot(C)
[13:19:57.065]                     delay(fit)
[13:19:57.065]                     message(" done")
[13:19:57.065]                     fit
[13:19:57.065]                   }
[13:19:57.065]                 }, immediateCondition = function(cond) {
[13:19:57.065]                   save_rds <- function (object, pathname, ...) 
[13:19:57.065]                   {
[13:19:57.065]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:57.065]                     if (file_test("-f", pathname_tmp)) {
[13:19:57.065]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.065]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:57.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.065]                         fi_tmp[["mtime"]])
[13:19:57.065]                     }
[13:19:57.065]                     tryCatch({
[13:19:57.065]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:57.065]                     }, error = function(ex) {
[13:19:57.065]                       msg <- conditionMessage(ex)
[13:19:57.065]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.065]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:57.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.065]                         fi_tmp[["mtime"]], msg)
[13:19:57.065]                       ex$message <- msg
[13:19:57.065]                       stop(ex)
[13:19:57.065]                     })
[13:19:57.065]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:57.065]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:57.065]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:57.065]                       fi_tmp <- file.info(pathname_tmp)
[13:19:57.065]                       fi <- file.info(pathname)
[13:19:57.065]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:57.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:57.065]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:57.065]                         fi[["size"]], fi[["mtime"]])
[13:19:57.065]                       stop(msg)
[13:19:57.065]                     }
[13:19:57.065]                     invisible(pathname)
[13:19:57.065]                   }
[13:19:57.065]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:57.065]                     rootPath = tempdir()) 
[13:19:57.065]                   {
[13:19:57.065]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:57.065]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:57.065]                       tmpdir = path, fileext = ".rds")
[13:19:57.065]                     save_rds(obj, file)
[13:19:57.065]                   }
[13:19:57.065]                   saveImmediateCondition(cond, path = "/tmp/RtmpuMztud/.future/immediateConditions")
[13:19:57.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.065]                   {
[13:19:57.065]                     inherits <- base::inherits
[13:19:57.065]                     invokeRestart <- base::invokeRestart
[13:19:57.065]                     is.null <- base::is.null
[13:19:57.065]                     muffled <- FALSE
[13:19:57.065]                     if (inherits(cond, "message")) {
[13:19:57.065]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.065]                       if (muffled) 
[13:19:57.065]                         invokeRestart("muffleMessage")
[13:19:57.065]                     }
[13:19:57.065]                     else if (inherits(cond, "warning")) {
[13:19:57.065]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.065]                       if (muffled) 
[13:19:57.065]                         invokeRestart("muffleWarning")
[13:19:57.065]                     }
[13:19:57.065]                     else if (inherits(cond, "condition")) {
[13:19:57.065]                       if (!is.null(pattern)) {
[13:19:57.065]                         computeRestarts <- base::computeRestarts
[13:19:57.065]                         grepl <- base::grepl
[13:19:57.065]                         restarts <- computeRestarts(cond)
[13:19:57.065]                         for (restart in restarts) {
[13:19:57.065]                           name <- restart$name
[13:19:57.065]                           if (is.null(name)) 
[13:19:57.065]                             next
[13:19:57.065]                           if (!grepl(pattern, name)) 
[13:19:57.065]                             next
[13:19:57.065]                           invokeRestart(restart)
[13:19:57.065]                           muffled <- TRUE
[13:19:57.065]                           break
[13:19:57.065]                         }
[13:19:57.065]                       }
[13:19:57.065]                     }
[13:19:57.065]                     invisible(muffled)
[13:19:57.065]                   }
[13:19:57.065]                   muffleCondition(cond)
[13:19:57.065]                 })
[13:19:57.065]             }))
[13:19:57.065]             future::FutureResult(value = ...future.value$value, 
[13:19:57.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.065]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.065]                     ...future.globalenv.names))
[13:19:57.065]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.065]         }, condition = base::local({
[13:19:57.065]             c <- base::c
[13:19:57.065]             inherits <- base::inherits
[13:19:57.065]             invokeRestart <- base::invokeRestart
[13:19:57.065]             length <- base::length
[13:19:57.065]             list <- base::list
[13:19:57.065]             seq.int <- base::seq.int
[13:19:57.065]             signalCondition <- base::signalCondition
[13:19:57.065]             sys.calls <- base::sys.calls
[13:19:57.065]             `[[` <- base::`[[`
[13:19:57.065]             `+` <- base::`+`
[13:19:57.065]             `<<-` <- base::`<<-`
[13:19:57.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.065]                   3L)]
[13:19:57.065]             }
[13:19:57.065]             function(cond) {
[13:19:57.065]                 is_error <- inherits(cond, "error")
[13:19:57.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.065]                   NULL)
[13:19:57.065]                 if (is_error) {
[13:19:57.065]                   sessionInformation <- function() {
[13:19:57.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.065]                       search = base::search(), system = base::Sys.info())
[13:19:57.065]                   }
[13:19:57.065]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.065]                     cond$call), session = sessionInformation(), 
[13:19:57.065]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.065]                   signalCondition(cond)
[13:19:57.065]                 }
[13:19:57.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.065]                 "immediateCondition"))) {
[13:19:57.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.065]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.065]                   if (TRUE && !signal) {
[13:19:57.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.065]                     {
[13:19:57.065]                       inherits <- base::inherits
[13:19:57.065]                       invokeRestart <- base::invokeRestart
[13:19:57.065]                       is.null <- base::is.null
[13:19:57.065]                       muffled <- FALSE
[13:19:57.065]                       if (inherits(cond, "message")) {
[13:19:57.065]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.065]                         if (muffled) 
[13:19:57.065]                           invokeRestart("muffleMessage")
[13:19:57.065]                       }
[13:19:57.065]                       else if (inherits(cond, "warning")) {
[13:19:57.065]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.065]                         if (muffled) 
[13:19:57.065]                           invokeRestart("muffleWarning")
[13:19:57.065]                       }
[13:19:57.065]                       else if (inherits(cond, "condition")) {
[13:19:57.065]                         if (!is.null(pattern)) {
[13:19:57.065]                           computeRestarts <- base::computeRestarts
[13:19:57.065]                           grepl <- base::grepl
[13:19:57.065]                           restarts <- computeRestarts(cond)
[13:19:57.065]                           for (restart in restarts) {
[13:19:57.065]                             name <- restart$name
[13:19:57.065]                             if (is.null(name)) 
[13:19:57.065]                               next
[13:19:57.065]                             if (!grepl(pattern, name)) 
[13:19:57.065]                               next
[13:19:57.065]                             invokeRestart(restart)
[13:19:57.065]                             muffled <- TRUE
[13:19:57.065]                             break
[13:19:57.065]                           }
[13:19:57.065]                         }
[13:19:57.065]                       }
[13:19:57.065]                       invisible(muffled)
[13:19:57.065]                     }
[13:19:57.065]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.065]                   }
[13:19:57.065]                 }
[13:19:57.065]                 else {
[13:19:57.065]                   if (TRUE) {
[13:19:57.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.065]                     {
[13:19:57.065]                       inherits <- base::inherits
[13:19:57.065]                       invokeRestart <- base::invokeRestart
[13:19:57.065]                       is.null <- base::is.null
[13:19:57.065]                       muffled <- FALSE
[13:19:57.065]                       if (inherits(cond, "message")) {
[13:19:57.065]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.065]                         if (muffled) 
[13:19:57.065]                           invokeRestart("muffleMessage")
[13:19:57.065]                       }
[13:19:57.065]                       else if (inherits(cond, "warning")) {
[13:19:57.065]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.065]                         if (muffled) 
[13:19:57.065]                           invokeRestart("muffleWarning")
[13:19:57.065]                       }
[13:19:57.065]                       else if (inherits(cond, "condition")) {
[13:19:57.065]                         if (!is.null(pattern)) {
[13:19:57.065]                           computeRestarts <- base::computeRestarts
[13:19:57.065]                           grepl <- base::grepl
[13:19:57.065]                           restarts <- computeRestarts(cond)
[13:19:57.065]                           for (restart in restarts) {
[13:19:57.065]                             name <- restart$name
[13:19:57.065]                             if (is.null(name)) 
[13:19:57.065]                               next
[13:19:57.065]                             if (!grepl(pattern, name)) 
[13:19:57.065]                               next
[13:19:57.065]                             invokeRestart(restart)
[13:19:57.065]                             muffled <- TRUE
[13:19:57.065]                             break
[13:19:57.065]                           }
[13:19:57.065]                         }
[13:19:57.065]                       }
[13:19:57.065]                       invisible(muffled)
[13:19:57.065]                     }
[13:19:57.065]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.065]                   }
[13:19:57.065]                 }
[13:19:57.065]             }
[13:19:57.065]         }))
[13:19:57.065]     }, error = function(ex) {
[13:19:57.065]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.065]                 ...future.rng), started = ...future.startTime, 
[13:19:57.065]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.065]             version = "1.8"), class = "FutureResult")
[13:19:57.065]     }, finally = {
[13:19:57.065]         if (!identical(...future.workdir, getwd())) 
[13:19:57.065]             setwd(...future.workdir)
[13:19:57.065]         {
[13:19:57.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.065]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.065]             }
[13:19:57.065]             base::options(...future.oldOptions)
[13:19:57.065]             if (.Platform$OS.type == "windows") {
[13:19:57.065]                 old_names <- names(...future.oldEnvVars)
[13:19:57.065]                 envs <- base::Sys.getenv()
[13:19:57.065]                 names <- names(envs)
[13:19:57.065]                 common <- intersect(names, old_names)
[13:19:57.065]                 added <- setdiff(names, old_names)
[13:19:57.065]                 removed <- setdiff(old_names, names)
[13:19:57.065]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.065]                   envs[common]]
[13:19:57.065]                 NAMES <- toupper(changed)
[13:19:57.065]                 args <- list()
[13:19:57.065]                 for (kk in seq_along(NAMES)) {
[13:19:57.065]                   name <- changed[[kk]]
[13:19:57.065]                   NAME <- NAMES[[kk]]
[13:19:57.065]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.065]                     next
[13:19:57.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.065]                 }
[13:19:57.065]                 NAMES <- toupper(added)
[13:19:57.065]                 for (kk in seq_along(NAMES)) {
[13:19:57.065]                   name <- added[[kk]]
[13:19:57.065]                   NAME <- NAMES[[kk]]
[13:19:57.065]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.065]                     next
[13:19:57.065]                   args[[name]] <- ""
[13:19:57.065]                 }
[13:19:57.065]                 NAMES <- toupper(removed)
[13:19:57.065]                 for (kk in seq_along(NAMES)) {
[13:19:57.065]                   name <- removed[[kk]]
[13:19:57.065]                   NAME <- NAMES[[kk]]
[13:19:57.065]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.065]                     next
[13:19:57.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.065]                 }
[13:19:57.065]                 if (length(args) > 0) 
[13:19:57.065]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.065]             }
[13:19:57.065]             else {
[13:19:57.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.065]             }
[13:19:57.065]             {
[13:19:57.065]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.065]                   0L) {
[13:19:57.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.065]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.065]                   base::options(opts)
[13:19:57.065]                 }
[13:19:57.065]                 {
[13:19:57.065]                   {
[13:19:57.065]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.065]                     NULL
[13:19:57.065]                   }
[13:19:57.065]                   options(future.plan = NULL)
[13:19:57.065]                   if (is.na(NA_character_)) 
[13:19:57.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.065]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:57.065]                     envir = parent.frame()) 
[13:19:57.065]                   {
[13:19:57.065]                     default_workers <- missing(workers)
[13:19:57.065]                     if (is.function(workers)) 
[13:19:57.065]                       workers <- workers()
[13:19:57.065]                     workers <- structure(as.integer(workers), 
[13:19:57.065]                       class = class(workers))
[13:19:57.065]                     stop_if_not(is.finite(workers), workers >= 
[13:19:57.065]                       1L)
[13:19:57.065]                     if ((workers == 1L && !inherits(workers, 
[13:19:57.065]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:57.065]                       if (default_workers) 
[13:19:57.065]                         supportsMulticore(warn = TRUE)
[13:19:57.065]                       return(sequential(..., envir = envir))
[13:19:57.065]                     }
[13:19:57.065]                     oopts <- options(mc.cores = workers)
[13:19:57.065]                     on.exit(options(oopts))
[13:19:57.065]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:57.065]                       envir = envir)
[13:19:57.065]                     if (!future$lazy) 
[13:19:57.065]                       future <- run(future)
[13:19:57.065]                     invisible(future)
[13:19:57.065]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.065]                 }
[13:19:57.065]             }
[13:19:57.065]         }
[13:19:57.065]     })
[13:19:57.065]     if (TRUE) {
[13:19:57.065]         base::sink(type = "output", split = FALSE)
[13:19:57.065]         if (TRUE) {
[13:19:57.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.065]         }
[13:19:57.065]         else {
[13:19:57.065]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.065]         }
[13:19:57.065]         base::close(...future.stdout)
[13:19:57.065]         ...future.stdout <- NULL
[13:19:57.065]     }
[13:19:57.065]     ...future.result$conditions <- ...future.conditions
[13:19:57.065]     ...future.result$finished <- base::Sys.time()
[13:19:57.065]     ...future.result
[13:19:57.065] }
[13:19:57.069] assign_globals() ...
[13:19:57.069] List of 4
[13:19:57.069]  $ ii   : int 4
[13:19:57.069]  $ n    : int 4
[13:19:57.069]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[13:19:57.069]   ..- attr(*, "region")=List of 2
[13:19:57.069]   .. ..$ xrange: num [1:2] -0.719 0.75
[13:19:57.069]   .. ..$ yrange: num [1:2] 0.0306 1.5
[13:19:57.069]   ..- attr(*, "tile")= int [1:2] 2 2
[13:19:57.069]  $ delay:function (counts)  
[13:19:57.069]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[13:19:57.069]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x55d3b8ef43f8> 
[13:19:57.069]  - attr(*, "where")=List of 4
[13:19:57.069]   ..$ ii   :<environment: R_EmptyEnv> 
[13:19:57.069]   ..$ n    :<environment: R_EmptyEnv> 
[13:19:57.069]   ..$ C    :<environment: R_EmptyEnv> 
[13:19:57.069]   ..$ delay:<environment: R_EmptyEnv> 
[13:19:57.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:57.069]  - attr(*, "resolved")= logi FALSE
[13:19:57.069]  - attr(*, "total_size")= num 14584
[13:19:57.069]  - attr(*, "already-done")= logi TRUE
[13:19:57.078] - copied ‘ii’ to environment
[13:19:57.078] - copied ‘n’ to environment
[13:19:57.078] - copied ‘C’ to environment
[13:19:57.078] - reassign environment for ‘delay’
[13:19:57.079] - copied ‘delay’ to environment
[13:19:57.079] assign_globals() ... done
[13:19:57.079] requestCore(): workers = 2
[13:19:57.079] Poll #1 (0): usedCores() = 2, workers = 2
[13:19:57.091] signalConditions() ...
[13:19:57.091]  - include = ‘immediateCondition’
[13:19:57.091]  - exclude = 
[13:19:57.091]  - resignal = FALSE
[13:19:57.092]  - Number of conditions: 2
[13:19:57.092] signalConditions() ... done
[13:19:57.092] signalConditions() ...
[13:19:57.092]  - include = ‘immediateCondition’
[13:19:57.092]  - exclude = 
[13:19:57.093]  - resignal = FALSE
[13:19:57.093]  - Number of conditions: 2
[13:19:57.093] signalConditions() ... done
[13:19:57.096] MulticoreFuture started
[13:19:57.097] - Launch lazy future ... done
[13:19:57.097] run() for ‘MulticoreFuture’ ... done
[13:19:57.097] - run() ... done
[13:19:57.097] - resolved() ...
[13:19:57.098] plan(): Setting new future strategy stack:
[13:19:57.098] List of future strategies:
[13:19:57.098] 1. sequential:
[13:19:57.098]    - args: function (..., envir = parent.frame())
[13:19:57.098]    - tweaked: FALSE
[13:19:57.098]    - call: NULL
[13:19:57.099] plan(): nbrOfWorkers() = 1
[13:19:57.104] plan(): Setting new future strategy stack:
[13:19:57.104] List of future strategies:
[13:19:57.104] 1. multicore:
[13:19:57.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:57.104]    - tweaked: FALSE
[13:19:57.104]    - call: plan(strategy)
[13:19:57.108] - resolved: FALSE
[13:19:57.108] - resolved() ... done
[13:19:57.108] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[13:19:57.109] plan(): nbrOfWorkers() = 2
[13:19:57.109] signalConditions() ...
[13:19:57.109]  - include = ‘immediateCondition’
[13:19:57.109]  - exclude = 
[13:19:57.110]  - resignal = FALSE
[13:19:57.110]  - Number of conditions: 2
[13:19:57.110] signalConditions() ... done
[13:19:57.110] Future state: ‘finished’
[13:19:57.110] signalConditions() ...
[13:19:57.110]  - include = ‘condition’
[13:19:57.111]  - exclude = ‘immediateCondition’
[13:19:57.111]  - resignal = TRUE
[13:19:57.111]  - Number of conditions: 2
[13:19:57.111]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[13:19:57.111]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:57.111] signalConditions() ... done
Plotting tile #3 of 4 ...
[13:19:57.114] signalConditions() ...
[13:19:57.114]  - include = ‘immediateCondition’
[13:19:57.114]  - exclude = 
[13:19:57.114]  - resignal = FALSE
[13:19:57.114]  - Number of conditions: 2
[13:19:57.115] signalConditions() ... done
[13:19:57.115] signalConditions() ...
[13:19:57.115]  - include = ‘immediateCondition’
[13:19:57.115]  - exclude = 
[13:19:57.115]  - resignal = FALSE
[13:19:57.115]  - Number of conditions: 2
[13:19:57.115] signalConditions() ... done
[13:19:57.116] Future state: ‘finished’
[13:19:57.116] signalConditions() ...
[13:19:57.116]  - include = ‘condition’
[13:19:57.116]  - exclude = ‘immediateCondition’
[13:19:57.116]  - resignal = TRUE
[13:19:57.116]  - Number of conditions: 2
[13:19:57.116]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[13:19:57.117]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:57.117] signalConditions() ... done
Plotting tile #4 of 4 ...
[13:19:57.119] signalConditions() ...
[13:19:57.119]  - include = ‘immediateCondition’
[13:19:57.119]  - exclude = 
[13:19:57.119]  - resignal = FALSE
[13:19:57.119]  - Number of conditions: 2
[13:19:57.119] signalConditions() ... done
[13:19:57.119] signalConditions() ...
[13:19:57.119]  - include = ‘immediateCondition’
[13:19:57.120]  - exclude = 
[13:19:57.120]  - resignal = FALSE
[13:19:57.120]  - Number of conditions: 2
[13:19:57.120] signalConditions() ... done
[13:19:57.120] Future state: ‘finished’
[13:19:57.120] signalConditions() ...
[13:19:57.120]  - include = ‘condition’
[13:19:57.120]  - exclude = ‘immediateCondition’
[13:19:57.121]  - resignal = TRUE
[13:19:57.121]  - Number of conditions: 2
[13:19:57.121]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[13:19:57.121]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:57.121] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[13:19:57.123] plan(): Setting new future strategy stack:
[13:19:57.123] List of future strategies:
[13:19:57.123] 1. multisession:
[13:19:57.123]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:57.123]    - tweaked: FALSE
[13:19:57.123]    - call: plan(strategy)
[13:19:57.124] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:19:57.124] multisession:
[13:19:57.124] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:57.124] - tweaked: FALSE
[13:19:57.124] - call: plan(strategy)
[13:19:57.131] getGlobalsAndPackages() ...
[13:19:57.131] Not searching for globals
[13:19:57.131] - globals: [0] <none>
[13:19:57.131] getGlobalsAndPackages() ... DONE
[13:19:57.132] [local output] makeClusterPSOCK() ...
[13:19:57.186] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:19:57.192] [local output] Base port: 11694
[13:19:57.192] [local output] Getting setup options for 2 cluster nodes ...
[13:19:57.192] [local output]  - Node 1 of 2 ...
[13:19:57.193] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:57.193] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuMztud/worker.rank=1.parallelly.parent=82133.140d537d20581.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpuMztud/worker.rank=1.parallelly.parent=82133.140d537d20581.pid")'’
[13:19:57.386] - Possible to infer worker's PID: TRUE
[13:19:57.386] [local output] Rscript port: 11694

[13:19:57.387] [local output]  - Node 2 of 2 ...
[13:19:57.387] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:57.388] [local output] Rscript port: 11694

[13:19:57.388] [local output] Getting setup options for 2 cluster nodes ... done
[13:19:57.388] [local output]  - Parallel setup requested for some PSOCK nodes
[13:19:57.389] [local output] Setting up PSOCK nodes in parallel
[13:19:57.389] List of 36
[13:19:57.389]  $ worker          : chr "localhost"
[13:19:57.389]   ..- attr(*, "localhost")= logi TRUE
[13:19:57.389]  $ master          : chr "localhost"
[13:19:57.389]  $ port            : int 11694
[13:19:57.389]  $ connectTimeout  : num 120
[13:19:57.389]  $ timeout         : num 2592000
[13:19:57.389]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:19:57.389]  $ homogeneous     : logi TRUE
[13:19:57.389]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:19:57.389]  $ rscript_envs    : NULL
[13:19:57.389]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:57.389]  $ rscript_startup : NULL
[13:19:57.389]  $ rscript_sh      : chr "sh"
[13:19:57.389]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:57.389]  $ methods         : logi TRUE
[13:19:57.389]  $ socketOptions   : chr "no-delay"
[13:19:57.389]  $ useXDR          : logi FALSE
[13:19:57.389]  $ outfile         : chr "/dev/null"
[13:19:57.389]  $ renice          : int NA
[13:19:57.389]  $ rshcmd          : NULL
[13:19:57.389]  $ user            : chr(0) 
[13:19:57.389]  $ revtunnel       : logi FALSE
[13:19:57.389]  $ rshlogfile      : NULL
[13:19:57.389]  $ rshopts         : chr(0) 
[13:19:57.389]  $ rank            : int 1
[13:19:57.389]  $ manual          : logi FALSE
[13:19:57.389]  $ dryrun          : logi FALSE
[13:19:57.389]  $ quiet           : logi FALSE
[13:19:57.389]  $ setup_strategy  : chr "parallel"
[13:19:57.389]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:57.389]  $ pidfile         : chr "/tmp/RtmpuMztud/worker.rank=1.parallelly.parent=82133.140d537d20581.pid"
[13:19:57.389]  $ rshcmd_label    : NULL
[13:19:57.389]  $ rsh_call        : NULL
[13:19:57.389]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:57.389]  $ localMachine    : logi TRUE
[13:19:57.389]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:19:57.389]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:19:57.389]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:19:57.389]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:19:57.389]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:19:57.389]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:19:57.389]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:19:57.389]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:19:57.389]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:19:57.389]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:19:57.389]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:19:57.389]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:19:57.389]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:19:57.389]  $ arguments       :List of 28
[13:19:57.389]   ..$ worker          : chr "localhost"
[13:19:57.389]   ..$ master          : NULL
[13:19:57.389]   ..$ port            : int 11694
[13:19:57.389]   ..$ connectTimeout  : num 120
[13:19:57.389]   ..$ timeout         : num 2592000
[13:19:57.389]   ..$ rscript         : NULL
[13:19:57.389]   ..$ homogeneous     : NULL
[13:19:57.389]   ..$ rscript_args    : NULL
[13:19:57.389]   ..$ rscript_envs    : NULL
[13:19:57.389]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:57.389]   ..$ rscript_startup : NULL
[13:19:57.389]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:19:57.389]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:57.389]   ..$ methods         : logi TRUE
[13:19:57.389]   ..$ socketOptions   : chr "no-delay"
[13:19:57.389]   ..$ useXDR          : logi FALSE
[13:19:57.389]   ..$ outfile         : chr "/dev/null"
[13:19:57.389]   ..$ renice          : int NA
[13:19:57.389]   ..$ rshcmd          : NULL
[13:19:57.389]   ..$ user            : NULL
[13:19:57.389]   ..$ revtunnel       : logi NA
[13:19:57.389]   ..$ rshlogfile      : NULL
[13:19:57.389]   ..$ rshopts         : NULL
[13:19:57.389]   ..$ rank            : int 1
[13:19:57.389]   ..$ manual          : logi FALSE
[13:19:57.389]   ..$ dryrun          : logi FALSE
[13:19:57.389]   ..$ quiet           : logi FALSE
[13:19:57.389]   ..$ setup_strategy  : chr "parallel"
[13:19:57.389]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:19:57.406] [local output] System call to launch all workers:
[13:19:57.406] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuMztud/worker.rank=1.parallelly.parent=82133.140d537d20581.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11694 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:19:57.406] [local output] Starting PSOCK main server
[13:19:57.408] [local output] Workers launched
[13:19:57.408] [local output] Waiting for workers to connect back
[13:19:57.408]  - [local output] 0 workers out of 2 ready
[13:19:57.689]  - [local output] 0 workers out of 2 ready
[13:19:57.690]  - [local output] 1 workers out of 2 ready
[13:19:57.699]  - [local output] 1 workers out of 2 ready
[13:19:57.699]  - [local output] 2 workers out of 2 ready
[13:19:57.700] [local output] Launching of workers completed
[13:19:57.700] [local output] Collecting session information from workers
[13:19:57.701] [local output]  - Worker #1 of 2
[13:19:57.701] [local output]  - Worker #2 of 2
[13:19:57.701] [local output] makeClusterPSOCK() ... done
[13:19:57.713] Packages needed by the future expression (n = 0): <none>
[13:19:57.713] Packages needed by future strategies (n = 0): <none>
[13:19:57.713] {
[13:19:57.713]     {
[13:19:57.713]         {
[13:19:57.713]             ...future.startTime <- base::Sys.time()
[13:19:57.713]             {
[13:19:57.713]                 {
[13:19:57.713]                   {
[13:19:57.713]                     {
[13:19:57.713]                       base::local({
[13:19:57.713]                         has_future <- base::requireNamespace("future", 
[13:19:57.713]                           quietly = TRUE)
[13:19:57.713]                         if (has_future) {
[13:19:57.713]                           ns <- base::getNamespace("future")
[13:19:57.713]                           version <- ns[[".package"]][["version"]]
[13:19:57.713]                           if (is.null(version)) 
[13:19:57.713]                             version <- utils::packageVersion("future")
[13:19:57.713]                         }
[13:19:57.713]                         else {
[13:19:57.713]                           version <- NULL
[13:19:57.713]                         }
[13:19:57.713]                         if (!has_future || version < "1.8.0") {
[13:19:57.713]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.713]                             "", base::R.version$version.string), 
[13:19:57.713]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:57.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:57.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.713]                               "release", "version")], collapse = " "), 
[13:19:57.713]                             hostname = base::Sys.info()[["nodename"]])
[13:19:57.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.713]                             info)
[13:19:57.713]                           info <- base::paste(info, collapse = "; ")
[13:19:57.713]                           if (!has_future) {
[13:19:57.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.713]                               info)
[13:19:57.713]                           }
[13:19:57.713]                           else {
[13:19:57.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.713]                               info, version)
[13:19:57.713]                           }
[13:19:57.713]                           base::stop(msg)
[13:19:57.713]                         }
[13:19:57.713]                       })
[13:19:57.713]                     }
[13:19:57.713]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.713]                     base::options(mc.cores = 1L)
[13:19:57.713]                   }
[13:19:57.713]                   options(future.plan = NULL)
[13:19:57.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.713]                 }
[13:19:57.713]                 ...future.workdir <- getwd()
[13:19:57.713]             }
[13:19:57.713]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.713]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.713]         }
[13:19:57.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:57.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.713]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.713]             base::names(...future.oldOptions))
[13:19:57.713]     }
[13:19:57.713]     if (FALSE) {
[13:19:57.713]     }
[13:19:57.713]     else {
[13:19:57.713]         if (TRUE) {
[13:19:57.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.713]                 open = "w")
[13:19:57.713]         }
[13:19:57.713]         else {
[13:19:57.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.713]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.713]         }
[13:19:57.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.713]             base::sink(type = "output", split = FALSE)
[13:19:57.713]             base::close(...future.stdout)
[13:19:57.713]         }, add = TRUE)
[13:19:57.713]     }
[13:19:57.713]     ...future.frame <- base::sys.nframe()
[13:19:57.713]     ...future.conditions <- base::list()
[13:19:57.713]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.713]     if (FALSE) {
[13:19:57.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.713]     }
[13:19:57.713]     ...future.result <- base::tryCatch({
[13:19:57.713]         base::withCallingHandlers({
[13:19:57.713]             ...future.value <- base::withVisible(base::local({
[13:19:57.713]                 ...future.makeSendCondition <- local({
[13:19:57.713]                   sendCondition <- NULL
[13:19:57.713]                   function(frame = 1L) {
[13:19:57.713]                     if (is.function(sendCondition)) 
[13:19:57.713]                       return(sendCondition)
[13:19:57.713]                     ns <- getNamespace("parallel")
[13:19:57.713]                     if (exists("sendData", mode = "function", 
[13:19:57.713]                       envir = ns)) {
[13:19:57.713]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:57.713]                         envir = ns)
[13:19:57.713]                       envir <- sys.frame(frame)
[13:19:57.713]                       master <- NULL
[13:19:57.713]                       while (!identical(envir, .GlobalEnv) && 
[13:19:57.713]                         !identical(envir, emptyenv())) {
[13:19:57.713]                         if (exists("master", mode = "list", envir = envir, 
[13:19:57.713]                           inherits = FALSE)) {
[13:19:57.713]                           master <- get("master", mode = "list", 
[13:19:57.713]                             envir = envir, inherits = FALSE)
[13:19:57.713]                           if (inherits(master, c("SOCKnode", 
[13:19:57.713]                             "SOCK0node"))) {
[13:19:57.713]                             sendCondition <<- function(cond) {
[13:19:57.713]                               data <- list(type = "VALUE", value = cond, 
[13:19:57.713]                                 success = TRUE)
[13:19:57.713]                               parallel_sendData(master, data)
[13:19:57.713]                             }
[13:19:57.713]                             return(sendCondition)
[13:19:57.713]                           }
[13:19:57.713]                         }
[13:19:57.713]                         frame <- frame + 1L
[13:19:57.713]                         envir <- sys.frame(frame)
[13:19:57.713]                       }
[13:19:57.713]                     }
[13:19:57.713]                     sendCondition <<- function(cond) NULL
[13:19:57.713]                   }
[13:19:57.713]                 })
[13:19:57.713]                 withCallingHandlers({
[13:19:57.713]                   NA
[13:19:57.713]                 }, immediateCondition = function(cond) {
[13:19:57.713]                   sendCondition <- ...future.makeSendCondition()
[13:19:57.713]                   sendCondition(cond)
[13:19:57.713]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.713]                   {
[13:19:57.713]                     inherits <- base::inherits
[13:19:57.713]                     invokeRestart <- base::invokeRestart
[13:19:57.713]                     is.null <- base::is.null
[13:19:57.713]                     muffled <- FALSE
[13:19:57.713]                     if (inherits(cond, "message")) {
[13:19:57.713]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.713]                       if (muffled) 
[13:19:57.713]                         invokeRestart("muffleMessage")
[13:19:57.713]                     }
[13:19:57.713]                     else if (inherits(cond, "warning")) {
[13:19:57.713]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.713]                       if (muffled) 
[13:19:57.713]                         invokeRestart("muffleWarning")
[13:19:57.713]                     }
[13:19:57.713]                     else if (inherits(cond, "condition")) {
[13:19:57.713]                       if (!is.null(pattern)) {
[13:19:57.713]                         computeRestarts <- base::computeRestarts
[13:19:57.713]                         grepl <- base::grepl
[13:19:57.713]                         restarts <- computeRestarts(cond)
[13:19:57.713]                         for (restart in restarts) {
[13:19:57.713]                           name <- restart$name
[13:19:57.713]                           if (is.null(name)) 
[13:19:57.713]                             next
[13:19:57.713]                           if (!grepl(pattern, name)) 
[13:19:57.713]                             next
[13:19:57.713]                           invokeRestart(restart)
[13:19:57.713]                           muffled <- TRUE
[13:19:57.713]                           break
[13:19:57.713]                         }
[13:19:57.713]                       }
[13:19:57.713]                     }
[13:19:57.713]                     invisible(muffled)
[13:19:57.713]                   }
[13:19:57.713]                   muffleCondition(cond)
[13:19:57.713]                 })
[13:19:57.713]             }))
[13:19:57.713]             future::FutureResult(value = ...future.value$value, 
[13:19:57.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.713]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.713]                     ...future.globalenv.names))
[13:19:57.713]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.713]         }, condition = base::local({
[13:19:57.713]             c <- base::c
[13:19:57.713]             inherits <- base::inherits
[13:19:57.713]             invokeRestart <- base::invokeRestart
[13:19:57.713]             length <- base::length
[13:19:57.713]             list <- base::list
[13:19:57.713]             seq.int <- base::seq.int
[13:19:57.713]             signalCondition <- base::signalCondition
[13:19:57.713]             sys.calls <- base::sys.calls
[13:19:57.713]             `[[` <- base::`[[`
[13:19:57.713]             `+` <- base::`+`
[13:19:57.713]             `<<-` <- base::`<<-`
[13:19:57.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.713]                   3L)]
[13:19:57.713]             }
[13:19:57.713]             function(cond) {
[13:19:57.713]                 is_error <- inherits(cond, "error")
[13:19:57.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.713]                   NULL)
[13:19:57.713]                 if (is_error) {
[13:19:57.713]                   sessionInformation <- function() {
[13:19:57.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.713]                       search = base::search(), system = base::Sys.info())
[13:19:57.713]                   }
[13:19:57.713]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.713]                     cond$call), session = sessionInformation(), 
[13:19:57.713]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.713]                   signalCondition(cond)
[13:19:57.713]                 }
[13:19:57.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.713]                 "immediateCondition"))) {
[13:19:57.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.713]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.713]                   if (TRUE && !signal) {
[13:19:57.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.713]                     {
[13:19:57.713]                       inherits <- base::inherits
[13:19:57.713]                       invokeRestart <- base::invokeRestart
[13:19:57.713]                       is.null <- base::is.null
[13:19:57.713]                       muffled <- FALSE
[13:19:57.713]                       if (inherits(cond, "message")) {
[13:19:57.713]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.713]                         if (muffled) 
[13:19:57.713]                           invokeRestart("muffleMessage")
[13:19:57.713]                       }
[13:19:57.713]                       else if (inherits(cond, "warning")) {
[13:19:57.713]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.713]                         if (muffled) 
[13:19:57.713]                           invokeRestart("muffleWarning")
[13:19:57.713]                       }
[13:19:57.713]                       else if (inherits(cond, "condition")) {
[13:19:57.713]                         if (!is.null(pattern)) {
[13:19:57.713]                           computeRestarts <- base::computeRestarts
[13:19:57.713]                           grepl <- base::grepl
[13:19:57.713]                           restarts <- computeRestarts(cond)
[13:19:57.713]                           for (restart in restarts) {
[13:19:57.713]                             name <- restart$name
[13:19:57.713]                             if (is.null(name)) 
[13:19:57.713]                               next
[13:19:57.713]                             if (!grepl(pattern, name)) 
[13:19:57.713]                               next
[13:19:57.713]                             invokeRestart(restart)
[13:19:57.713]                             muffled <- TRUE
[13:19:57.713]                             break
[13:19:57.713]                           }
[13:19:57.713]                         }
[13:19:57.713]                       }
[13:19:57.713]                       invisible(muffled)
[13:19:57.713]                     }
[13:19:57.713]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.713]                   }
[13:19:57.713]                 }
[13:19:57.713]                 else {
[13:19:57.713]                   if (TRUE) {
[13:19:57.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.713]                     {
[13:19:57.713]                       inherits <- base::inherits
[13:19:57.713]                       invokeRestart <- base::invokeRestart
[13:19:57.713]                       is.null <- base::is.null
[13:19:57.713]                       muffled <- FALSE
[13:19:57.713]                       if (inherits(cond, "message")) {
[13:19:57.713]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.713]                         if (muffled) 
[13:19:57.713]                           invokeRestart("muffleMessage")
[13:19:57.713]                       }
[13:19:57.713]                       else if (inherits(cond, "warning")) {
[13:19:57.713]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.713]                         if (muffled) 
[13:19:57.713]                           invokeRestart("muffleWarning")
[13:19:57.713]                       }
[13:19:57.713]                       else if (inherits(cond, "condition")) {
[13:19:57.713]                         if (!is.null(pattern)) {
[13:19:57.713]                           computeRestarts <- base::computeRestarts
[13:19:57.713]                           grepl <- base::grepl
[13:19:57.713]                           restarts <- computeRestarts(cond)
[13:19:57.713]                           for (restart in restarts) {
[13:19:57.713]                             name <- restart$name
[13:19:57.713]                             if (is.null(name)) 
[13:19:57.713]                               next
[13:19:57.713]                             if (!grepl(pattern, name)) 
[13:19:57.713]                               next
[13:19:57.713]                             invokeRestart(restart)
[13:19:57.713]                             muffled <- TRUE
[13:19:57.713]                             break
[13:19:57.713]                           }
[13:19:57.713]                         }
[13:19:57.713]                       }
[13:19:57.713]                       invisible(muffled)
[13:19:57.713]                     }
[13:19:57.713]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.713]                   }
[13:19:57.713]                 }
[13:19:57.713]             }
[13:19:57.713]         }))
[13:19:57.713]     }, error = function(ex) {
[13:19:57.713]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.713]                 ...future.rng), started = ...future.startTime, 
[13:19:57.713]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.713]             version = "1.8"), class = "FutureResult")
[13:19:57.713]     }, finally = {
[13:19:57.713]         if (!identical(...future.workdir, getwd())) 
[13:19:57.713]             setwd(...future.workdir)
[13:19:57.713]         {
[13:19:57.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.713]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.713]             }
[13:19:57.713]             base::options(...future.oldOptions)
[13:19:57.713]             if (.Platform$OS.type == "windows") {
[13:19:57.713]                 old_names <- names(...future.oldEnvVars)
[13:19:57.713]                 envs <- base::Sys.getenv()
[13:19:57.713]                 names <- names(envs)
[13:19:57.713]                 common <- intersect(names, old_names)
[13:19:57.713]                 added <- setdiff(names, old_names)
[13:19:57.713]                 removed <- setdiff(old_names, names)
[13:19:57.713]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.713]                   envs[common]]
[13:19:57.713]                 NAMES <- toupper(changed)
[13:19:57.713]                 args <- list()
[13:19:57.713]                 for (kk in seq_along(NAMES)) {
[13:19:57.713]                   name <- changed[[kk]]
[13:19:57.713]                   NAME <- NAMES[[kk]]
[13:19:57.713]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.713]                     next
[13:19:57.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.713]                 }
[13:19:57.713]                 NAMES <- toupper(added)
[13:19:57.713]                 for (kk in seq_along(NAMES)) {
[13:19:57.713]                   name <- added[[kk]]
[13:19:57.713]                   NAME <- NAMES[[kk]]
[13:19:57.713]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.713]                     next
[13:19:57.713]                   args[[name]] <- ""
[13:19:57.713]                 }
[13:19:57.713]                 NAMES <- toupper(removed)
[13:19:57.713]                 for (kk in seq_along(NAMES)) {
[13:19:57.713]                   name <- removed[[kk]]
[13:19:57.713]                   NAME <- NAMES[[kk]]
[13:19:57.713]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.713]                     next
[13:19:57.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.713]                 }
[13:19:57.713]                 if (length(args) > 0) 
[13:19:57.713]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.713]             }
[13:19:57.713]             else {
[13:19:57.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.713]             }
[13:19:57.713]             {
[13:19:57.713]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.713]                   0L) {
[13:19:57.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.713]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.713]                   base::options(opts)
[13:19:57.713]                 }
[13:19:57.713]                 {
[13:19:57.713]                   {
[13:19:57.713]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.713]                     NULL
[13:19:57.713]                   }
[13:19:57.713]                   options(future.plan = NULL)
[13:19:57.713]                   if (is.na(NA_character_)) 
[13:19:57.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.713]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:57.713]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:57.713]                     envir = parent.frame()) 
[13:19:57.713]                   {
[13:19:57.713]                     if (is.function(workers)) 
[13:19:57.713]                       workers <- workers()
[13:19:57.713]                     workers <- structure(as.integer(workers), 
[13:19:57.713]                       class = class(workers))
[13:19:57.713]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:57.713]                       workers >= 1)
[13:19:57.713]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:57.713]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:57.713]                     }
[13:19:57.713]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:57.713]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:57.713]                       envir = envir)
[13:19:57.713]                     if (!future$lazy) 
[13:19:57.713]                       future <- run(future)
[13:19:57.713]                     invisible(future)
[13:19:57.713]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.713]                 }
[13:19:57.713]             }
[13:19:57.713]         }
[13:19:57.713]     })
[13:19:57.713]     if (TRUE) {
[13:19:57.713]         base::sink(type = "output", split = FALSE)
[13:19:57.713]         if (TRUE) {
[13:19:57.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.713]         }
[13:19:57.713]         else {
[13:19:57.713]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.713]         }
[13:19:57.713]         base::close(...future.stdout)
[13:19:57.713]         ...future.stdout <- NULL
[13:19:57.713]     }
[13:19:57.713]     ...future.result$conditions <- ...future.conditions
[13:19:57.713]     ...future.result$finished <- base::Sys.time()
[13:19:57.713]     ...future.result
[13:19:57.713] }
[13:19:57.786] MultisessionFuture started
[13:19:57.786] result() for ClusterFuture ...
[13:19:57.787] receiveMessageFromWorker() for ClusterFuture ...
[13:19:57.787] - Validating connection of MultisessionFuture
[13:19:57.820] - received message: FutureResult
[13:19:57.820] - Received FutureResult
[13:19:57.820] - Erased future from FutureRegistry
[13:19:57.820] result() for ClusterFuture ...
[13:19:57.820] - result already collected: FutureResult
[13:19:57.820] result() for ClusterFuture ... done
[13:19:57.820] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:57.821] result() for ClusterFuture ... done
[13:19:57.821] result() for ClusterFuture ...
[13:19:57.821] - result already collected: FutureResult
[13:19:57.821] result() for ClusterFuture ... done
[13:19:57.821] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:19:57.825] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[13:19:57.828] getGlobalsAndPackages() ...
[13:19:57.829] Searching for globals...
[13:19:57.832] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:57.832] Searching for globals ... DONE
[13:19:57.832] Resolving globals: FALSE
[13:19:57.833] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:57.833] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:57.834] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:57.834] - packages: [1] ‘future’
[13:19:57.834] getGlobalsAndPackages() ... DONE
 2[13:19:57.838] getGlobalsAndPackages() ...
[13:19:57.838] Searching for globals...
[13:19:57.841] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:57.842] Searching for globals ... DONE
[13:19:57.842] Resolving globals: FALSE
[13:19:57.842] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:57.843] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:57.843] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:57.843] - packages: [1] ‘future’
[13:19:57.843] getGlobalsAndPackages() ... DONE
 3[13:19:57.843] getGlobalsAndPackages() ...
[13:19:57.843] Searching for globals...
[13:19:57.847] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:57.847] Searching for globals ... DONE
[13:19:57.847] Resolving globals: FALSE
[13:19:57.847] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:57.848] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:57.848] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:57.848] - packages: [1] ‘future’
[13:19:57.848] getGlobalsAndPackages() ... DONE
 4[13:19:57.849] getGlobalsAndPackages() ...
[13:19:57.849] Searching for globals...
[13:19:57.852] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[13:19:57.852] Searching for globals ... DONE
[13:19:57.852] Resolving globals: FALSE
[13:19:57.853] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[13:19:57.853] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[13:19:57.853] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[13:19:57.854] - packages: [1] ‘future’
[13:19:57.854] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[13:19:57.865] resolved() for ‘Future’ ...
[13:19:57.865] - state: ‘created’
[13:19:57.865] - run: TRUE
[13:19:57.865] - run() ...
[13:19:57.865] run() for ‘Future’ ...
[13:19:57.865] - state: ‘created’
[13:19:57.865] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:57.880] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:57.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:57.880]   - Field: ‘node’
[13:19:57.881]   - Field: ‘label’
[13:19:57.881]   - Field: ‘local’
[13:19:57.881]   - Field: ‘owner’
[13:19:57.881]   - Field: ‘envir’
[13:19:57.881]   - Field: ‘workers’
[13:19:57.881]   - Field: ‘packages’
[13:19:57.881]   - Field: ‘gc’
[13:19:57.881]   - Field: ‘conditions’
[13:19:57.881]   - Field: ‘persistent’
[13:19:57.881]   - Field: ‘expr’
[13:19:57.882]   - Field: ‘uuid’
[13:19:57.882]   - Field: ‘seed’
[13:19:57.882]   - Field: ‘version’
[13:19:57.882]   - Field: ‘result’
[13:19:57.882]   - Field: ‘asynchronous’
[13:19:57.882]   - Field: ‘calls’
[13:19:57.882]   - Field: ‘globals’
[13:19:57.882]   - Field: ‘stdout’
[13:19:57.882]   - Field: ‘earlySignal’
[13:19:57.882]   - Field: ‘lazy’
[13:19:57.882]   - Field: ‘state’
[13:19:57.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:57.883] - Launch lazy future ...
[13:19:57.883] Packages needed by the future expression (n = 1): ‘future’
[13:19:57.883] Packages needed by future strategies (n = 0): <none>
[13:19:57.884] {
[13:19:57.884]     {
[13:19:57.884]         {
[13:19:57.884]             ...future.startTime <- base::Sys.time()
[13:19:57.884]             {
[13:19:57.884]                 {
[13:19:57.884]                   {
[13:19:57.884]                     {
[13:19:57.884]                       {
[13:19:57.884]                         base::local({
[13:19:57.884]                           has_future <- base::requireNamespace("future", 
[13:19:57.884]                             quietly = TRUE)
[13:19:57.884]                           if (has_future) {
[13:19:57.884]                             ns <- base::getNamespace("future")
[13:19:57.884]                             version <- ns[[".package"]][["version"]]
[13:19:57.884]                             if (is.null(version)) 
[13:19:57.884]                               version <- utils::packageVersion("future")
[13:19:57.884]                           }
[13:19:57.884]                           else {
[13:19:57.884]                             version <- NULL
[13:19:57.884]                           }
[13:19:57.884]                           if (!has_future || version < "1.8.0") {
[13:19:57.884]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:57.884]                               "", base::R.version$version.string), 
[13:19:57.884]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:57.884]                                 base::R.version$platform, 8 * 
[13:19:57.884]                                   base::.Machine$sizeof.pointer), 
[13:19:57.884]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:57.884]                                 "release", "version")], collapse = " "), 
[13:19:57.884]                               hostname = base::Sys.info()[["nodename"]])
[13:19:57.884]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:57.884]                               info)
[13:19:57.884]                             info <- base::paste(info, collapse = "; ")
[13:19:57.884]                             if (!has_future) {
[13:19:57.884]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:57.884]                                 info)
[13:19:57.884]                             }
[13:19:57.884]                             else {
[13:19:57.884]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:57.884]                                 info, version)
[13:19:57.884]                             }
[13:19:57.884]                             base::stop(msg)
[13:19:57.884]                           }
[13:19:57.884]                         })
[13:19:57.884]                       }
[13:19:57.884]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:57.884]                       base::options(mc.cores = 1L)
[13:19:57.884]                     }
[13:19:57.884]                     base::local({
[13:19:57.884]                       for (pkg in "future") {
[13:19:57.884]                         base::loadNamespace(pkg)
[13:19:57.884]                         base::library(pkg, character.only = TRUE)
[13:19:57.884]                       }
[13:19:57.884]                     })
[13:19:57.884]                   }
[13:19:57.884]                   options(future.plan = NULL)
[13:19:57.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:57.884]                 }
[13:19:57.884]                 ...future.workdir <- getwd()
[13:19:57.884]             }
[13:19:57.884]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:57.884]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:57.884]         }
[13:19:57.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:57.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:57.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:57.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:57.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:57.884]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:57.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:57.884]             base::names(...future.oldOptions))
[13:19:57.884]     }
[13:19:57.884]     if (FALSE) {
[13:19:57.884]     }
[13:19:57.884]     else {
[13:19:57.884]         if (TRUE) {
[13:19:57.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:57.884]                 open = "w")
[13:19:57.884]         }
[13:19:57.884]         else {
[13:19:57.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:57.884]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:57.884]         }
[13:19:57.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:57.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:57.884]             base::sink(type = "output", split = FALSE)
[13:19:57.884]             base::close(...future.stdout)
[13:19:57.884]         }, add = TRUE)
[13:19:57.884]     }
[13:19:57.884]     ...future.frame <- base::sys.nframe()
[13:19:57.884]     ...future.conditions <- base::list()
[13:19:57.884]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:57.884]     if (FALSE) {
[13:19:57.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:57.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:57.884]     }
[13:19:57.884]     ...future.result <- base::tryCatch({
[13:19:57.884]         base::withCallingHandlers({
[13:19:57.884]             ...future.value <- base::withVisible(base::local({
[13:19:57.884]                 ...future.makeSendCondition <- local({
[13:19:57.884]                   sendCondition <- NULL
[13:19:57.884]                   function(frame = 1L) {
[13:19:57.884]                     if (is.function(sendCondition)) 
[13:19:57.884]                       return(sendCondition)
[13:19:57.884]                     ns <- getNamespace("parallel")
[13:19:57.884]                     if (exists("sendData", mode = "function", 
[13:19:57.884]                       envir = ns)) {
[13:19:57.884]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:57.884]                         envir = ns)
[13:19:57.884]                       envir <- sys.frame(frame)
[13:19:57.884]                       master <- NULL
[13:19:57.884]                       while (!identical(envir, .GlobalEnv) && 
[13:19:57.884]                         !identical(envir, emptyenv())) {
[13:19:57.884]                         if (exists("master", mode = "list", envir = envir, 
[13:19:57.884]                           inherits = FALSE)) {
[13:19:57.884]                           master <- get("master", mode = "list", 
[13:19:57.884]                             envir = envir, inherits = FALSE)
[13:19:57.884]                           if (inherits(master, c("SOCKnode", 
[13:19:57.884]                             "SOCK0node"))) {
[13:19:57.884]                             sendCondition <<- function(cond) {
[13:19:57.884]                               data <- list(type = "VALUE", value = cond, 
[13:19:57.884]                                 success = TRUE)
[13:19:57.884]                               parallel_sendData(master, data)
[13:19:57.884]                             }
[13:19:57.884]                             return(sendCondition)
[13:19:57.884]                           }
[13:19:57.884]                         }
[13:19:57.884]                         frame <- frame + 1L
[13:19:57.884]                         envir <- sys.frame(frame)
[13:19:57.884]                       }
[13:19:57.884]                     }
[13:19:57.884]                     sendCondition <<- function(cond) NULL
[13:19:57.884]                   }
[13:19:57.884]                 })
[13:19:57.884]                 withCallingHandlers({
[13:19:57.884]                   {
[13:19:57.884]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:57.884]                       ii, n), appendLF = FALSE)
[13:19:57.884]                     fit <- mandelbrot(C)
[13:19:57.884]                     delay(fit)
[13:19:57.884]                     message(" done")
[13:19:57.884]                     fit
[13:19:57.884]                   }
[13:19:57.884]                 }, immediateCondition = function(cond) {
[13:19:57.884]                   sendCondition <- ...future.makeSendCondition()
[13:19:57.884]                   sendCondition(cond)
[13:19:57.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.884]                   {
[13:19:57.884]                     inherits <- base::inherits
[13:19:57.884]                     invokeRestart <- base::invokeRestart
[13:19:57.884]                     is.null <- base::is.null
[13:19:57.884]                     muffled <- FALSE
[13:19:57.884]                     if (inherits(cond, "message")) {
[13:19:57.884]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:57.884]                       if (muffled) 
[13:19:57.884]                         invokeRestart("muffleMessage")
[13:19:57.884]                     }
[13:19:57.884]                     else if (inherits(cond, "warning")) {
[13:19:57.884]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:57.884]                       if (muffled) 
[13:19:57.884]                         invokeRestart("muffleWarning")
[13:19:57.884]                     }
[13:19:57.884]                     else if (inherits(cond, "condition")) {
[13:19:57.884]                       if (!is.null(pattern)) {
[13:19:57.884]                         computeRestarts <- base::computeRestarts
[13:19:57.884]                         grepl <- base::grepl
[13:19:57.884]                         restarts <- computeRestarts(cond)
[13:19:57.884]                         for (restart in restarts) {
[13:19:57.884]                           name <- restart$name
[13:19:57.884]                           if (is.null(name)) 
[13:19:57.884]                             next
[13:19:57.884]                           if (!grepl(pattern, name)) 
[13:19:57.884]                             next
[13:19:57.884]                           invokeRestart(restart)
[13:19:57.884]                           muffled <- TRUE
[13:19:57.884]                           break
[13:19:57.884]                         }
[13:19:57.884]                       }
[13:19:57.884]                     }
[13:19:57.884]                     invisible(muffled)
[13:19:57.884]                   }
[13:19:57.884]                   muffleCondition(cond)
[13:19:57.884]                 })
[13:19:57.884]             }))
[13:19:57.884]             future::FutureResult(value = ...future.value$value, 
[13:19:57.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.884]                   ...future.rng), globalenv = if (FALSE) 
[13:19:57.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:57.884]                     ...future.globalenv.names))
[13:19:57.884]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:57.884]         }, condition = base::local({
[13:19:57.884]             c <- base::c
[13:19:57.884]             inherits <- base::inherits
[13:19:57.884]             invokeRestart <- base::invokeRestart
[13:19:57.884]             length <- base::length
[13:19:57.884]             list <- base::list
[13:19:57.884]             seq.int <- base::seq.int
[13:19:57.884]             signalCondition <- base::signalCondition
[13:19:57.884]             sys.calls <- base::sys.calls
[13:19:57.884]             `[[` <- base::`[[`
[13:19:57.884]             `+` <- base::`+`
[13:19:57.884]             `<<-` <- base::`<<-`
[13:19:57.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:57.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:57.884]                   3L)]
[13:19:57.884]             }
[13:19:57.884]             function(cond) {
[13:19:57.884]                 is_error <- inherits(cond, "error")
[13:19:57.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:57.884]                   NULL)
[13:19:57.884]                 if (is_error) {
[13:19:57.884]                   sessionInformation <- function() {
[13:19:57.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:57.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:57.884]                       search = base::search(), system = base::Sys.info())
[13:19:57.884]                   }
[13:19:57.884]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:57.884]                     cond$call), session = sessionInformation(), 
[13:19:57.884]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:57.884]                   signalCondition(cond)
[13:19:57.884]                 }
[13:19:57.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:57.884]                 "immediateCondition"))) {
[13:19:57.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:57.884]                   ...future.conditions[[length(...future.conditions) + 
[13:19:57.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:57.884]                   if (TRUE && !signal) {
[13:19:57.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.884]                     {
[13:19:57.884]                       inherits <- base::inherits
[13:19:57.884]                       invokeRestart <- base::invokeRestart
[13:19:57.884]                       is.null <- base::is.null
[13:19:57.884]                       muffled <- FALSE
[13:19:57.884]                       if (inherits(cond, "message")) {
[13:19:57.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.884]                         if (muffled) 
[13:19:57.884]                           invokeRestart("muffleMessage")
[13:19:57.884]                       }
[13:19:57.884]                       else if (inherits(cond, "warning")) {
[13:19:57.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.884]                         if (muffled) 
[13:19:57.884]                           invokeRestart("muffleWarning")
[13:19:57.884]                       }
[13:19:57.884]                       else if (inherits(cond, "condition")) {
[13:19:57.884]                         if (!is.null(pattern)) {
[13:19:57.884]                           computeRestarts <- base::computeRestarts
[13:19:57.884]                           grepl <- base::grepl
[13:19:57.884]                           restarts <- computeRestarts(cond)
[13:19:57.884]                           for (restart in restarts) {
[13:19:57.884]                             name <- restart$name
[13:19:57.884]                             if (is.null(name)) 
[13:19:57.884]                               next
[13:19:57.884]                             if (!grepl(pattern, name)) 
[13:19:57.884]                               next
[13:19:57.884]                             invokeRestart(restart)
[13:19:57.884]                             muffled <- TRUE
[13:19:57.884]                             break
[13:19:57.884]                           }
[13:19:57.884]                         }
[13:19:57.884]                       }
[13:19:57.884]                       invisible(muffled)
[13:19:57.884]                     }
[13:19:57.884]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.884]                   }
[13:19:57.884]                 }
[13:19:57.884]                 else {
[13:19:57.884]                   if (TRUE) {
[13:19:57.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:57.884]                     {
[13:19:57.884]                       inherits <- base::inherits
[13:19:57.884]                       invokeRestart <- base::invokeRestart
[13:19:57.884]                       is.null <- base::is.null
[13:19:57.884]                       muffled <- FALSE
[13:19:57.884]                       if (inherits(cond, "message")) {
[13:19:57.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:57.884]                         if (muffled) 
[13:19:57.884]                           invokeRestart("muffleMessage")
[13:19:57.884]                       }
[13:19:57.884]                       else if (inherits(cond, "warning")) {
[13:19:57.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:57.884]                         if (muffled) 
[13:19:57.884]                           invokeRestart("muffleWarning")
[13:19:57.884]                       }
[13:19:57.884]                       else if (inherits(cond, "condition")) {
[13:19:57.884]                         if (!is.null(pattern)) {
[13:19:57.884]                           computeRestarts <- base::computeRestarts
[13:19:57.884]                           grepl <- base::grepl
[13:19:57.884]                           restarts <- computeRestarts(cond)
[13:19:57.884]                           for (restart in restarts) {
[13:19:57.884]                             name <- restart$name
[13:19:57.884]                             if (is.null(name)) 
[13:19:57.884]                               next
[13:19:57.884]                             if (!grepl(pattern, name)) 
[13:19:57.884]                               next
[13:19:57.884]                             invokeRestart(restart)
[13:19:57.884]                             muffled <- TRUE
[13:19:57.884]                             break
[13:19:57.884]                           }
[13:19:57.884]                         }
[13:19:57.884]                       }
[13:19:57.884]                       invisible(muffled)
[13:19:57.884]                     }
[13:19:57.884]                     muffleCondition(cond, pattern = "^muffle")
[13:19:57.884]                   }
[13:19:57.884]                 }
[13:19:57.884]             }
[13:19:57.884]         }))
[13:19:57.884]     }, error = function(ex) {
[13:19:57.884]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:57.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:57.884]                 ...future.rng), started = ...future.startTime, 
[13:19:57.884]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:57.884]             version = "1.8"), class = "FutureResult")
[13:19:57.884]     }, finally = {
[13:19:57.884]         if (!identical(...future.workdir, getwd())) 
[13:19:57.884]             setwd(...future.workdir)
[13:19:57.884]         {
[13:19:57.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:57.884]                 ...future.oldOptions$nwarnings <- NULL
[13:19:57.884]             }
[13:19:57.884]             base::options(...future.oldOptions)
[13:19:57.884]             if (.Platform$OS.type == "windows") {
[13:19:57.884]                 old_names <- names(...future.oldEnvVars)
[13:19:57.884]                 envs <- base::Sys.getenv()
[13:19:57.884]                 names <- names(envs)
[13:19:57.884]                 common <- intersect(names, old_names)
[13:19:57.884]                 added <- setdiff(names, old_names)
[13:19:57.884]                 removed <- setdiff(old_names, names)
[13:19:57.884]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:57.884]                   envs[common]]
[13:19:57.884]                 NAMES <- toupper(changed)
[13:19:57.884]                 args <- list()
[13:19:57.884]                 for (kk in seq_along(NAMES)) {
[13:19:57.884]                   name <- changed[[kk]]
[13:19:57.884]                   NAME <- NAMES[[kk]]
[13:19:57.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.884]                     next
[13:19:57.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.884]                 }
[13:19:57.884]                 NAMES <- toupper(added)
[13:19:57.884]                 for (kk in seq_along(NAMES)) {
[13:19:57.884]                   name <- added[[kk]]
[13:19:57.884]                   NAME <- NAMES[[kk]]
[13:19:57.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.884]                     next
[13:19:57.884]                   args[[name]] <- ""
[13:19:57.884]                 }
[13:19:57.884]                 NAMES <- toupper(removed)
[13:19:57.884]                 for (kk in seq_along(NAMES)) {
[13:19:57.884]                   name <- removed[[kk]]
[13:19:57.884]                   NAME <- NAMES[[kk]]
[13:19:57.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:57.884]                     next
[13:19:57.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:57.884]                 }
[13:19:57.884]                 if (length(args) > 0) 
[13:19:57.884]                   base::do.call(base::Sys.setenv, args = args)
[13:19:57.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:57.884]             }
[13:19:57.884]             else {
[13:19:57.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:57.884]             }
[13:19:57.884]             {
[13:19:57.884]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:57.884]                   0L) {
[13:19:57.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:57.884]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:57.884]                   base::options(opts)
[13:19:57.884]                 }
[13:19:57.884]                 {
[13:19:57.884]                   {
[13:19:57.884]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:57.884]                     NULL
[13:19:57.884]                   }
[13:19:57.884]                   options(future.plan = NULL)
[13:19:57.884]                   if (is.na(NA_character_)) 
[13:19:57.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:57.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:57.884]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:57.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:57.884]                     envir = parent.frame()) 
[13:19:57.884]                   {
[13:19:57.884]                     if (is.function(workers)) 
[13:19:57.884]                       workers <- workers()
[13:19:57.884]                     workers <- structure(as.integer(workers), 
[13:19:57.884]                       class = class(workers))
[13:19:57.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:57.884]                       workers >= 1)
[13:19:57.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:57.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:57.884]                     }
[13:19:57.884]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:57.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:57.884]                       envir = envir)
[13:19:57.884]                     if (!future$lazy) 
[13:19:57.884]                       future <- run(future)
[13:19:57.884]                     invisible(future)
[13:19:57.884]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:57.884]                 }
[13:19:57.884]             }
[13:19:57.884]         }
[13:19:57.884]     })
[13:19:57.884]     if (TRUE) {
[13:19:57.884]         base::sink(type = "output", split = FALSE)
[13:19:57.884]         if (TRUE) {
[13:19:57.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:57.884]         }
[13:19:57.884]         else {
[13:19:57.884]             ...future.result["stdout"] <- base::list(NULL)
[13:19:57.884]         }
[13:19:57.884]         base::close(...future.stdout)
[13:19:57.884]         ...future.stdout <- NULL
[13:19:57.884]     }
[13:19:57.884]     ...future.result$conditions <- ...future.conditions
[13:19:57.884]     ...future.result$finished <- base::Sys.time()
[13:19:57.884]     ...future.result
[13:19:57.884] }
[13:19:57.887] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[13:19:57.887] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:19:57.887] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:57.888] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[13:19:57.888] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[13:19:57.888] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[13:19:57.929] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[13:19:57.929] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[13:19:57.973] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[13:19:57.973] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[13:19:57.974] MultisessionFuture started
[13:19:57.974] - Launch lazy future ... done
[13:19:57.974] run() for ‘MultisessionFuture’ ... done
[13:19:57.975] - run() ... done
[13:19:57.975] - resolved() ...
[13:19:57.986] - resolved: FALSE
[13:19:57.986] - resolved() ... done
[13:19:57.986] resolved() for ‘MultisessionFuture’ ... done
[13:19:57.986] resolved() for ‘Future’ ...
[13:19:57.986] - state: ‘created’
[13:19:57.986] - run: TRUE
[13:19:57.986] - run() ...
[13:19:57.986] run() for ‘Future’ ...
[13:19:57.986] - state: ‘created’
[13:19:57.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.001] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:58.001]   - Field: ‘node’
[13:19:58.001]   - Field: ‘label’
[13:19:58.002]   - Field: ‘local’
[13:19:58.002]   - Field: ‘owner’
[13:19:58.002]   - Field: ‘envir’
[13:19:58.002]   - Field: ‘workers’
[13:19:58.002]   - Field: ‘packages’
[13:19:58.002]   - Field: ‘gc’
[13:19:58.002]   - Field: ‘conditions’
[13:19:58.002]   - Field: ‘persistent’
[13:19:58.002]   - Field: ‘expr’
[13:19:58.002]   - Field: ‘uuid’
[13:19:58.002]   - Field: ‘seed’
[13:19:58.003]   - Field: ‘version’
[13:19:58.003]   - Field: ‘result’
[13:19:58.003]   - Field: ‘asynchronous’
[13:19:58.003]   - Field: ‘calls’
[13:19:58.003]   - Field: ‘globals’
[13:19:58.003]   - Field: ‘stdout’
[13:19:58.003]   - Field: ‘earlySignal’
[13:19:58.003]   - Field: ‘lazy’
[13:19:58.003]   - Field: ‘state’
[13:19:58.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:58.003] - Launch lazy future ...
[13:19:58.004] Packages needed by the future expression (n = 1): ‘future’
[13:19:58.004] Packages needed by future strategies (n = 0): <none>
[13:19:58.004] {
[13:19:58.004]     {
[13:19:58.004]         {
[13:19:58.004]             ...future.startTime <- base::Sys.time()
[13:19:58.004]             {
[13:19:58.004]                 {
[13:19:58.004]                   {
[13:19:58.004]                     {
[13:19:58.004]                       {
[13:19:58.004]                         base::local({
[13:19:58.004]                           has_future <- base::requireNamespace("future", 
[13:19:58.004]                             quietly = TRUE)
[13:19:58.004]                           if (has_future) {
[13:19:58.004]                             ns <- base::getNamespace("future")
[13:19:58.004]                             version <- ns[[".package"]][["version"]]
[13:19:58.004]                             if (is.null(version)) 
[13:19:58.004]                               version <- utils::packageVersion("future")
[13:19:58.004]                           }
[13:19:58.004]                           else {
[13:19:58.004]                             version <- NULL
[13:19:58.004]                           }
[13:19:58.004]                           if (!has_future || version < "1.8.0") {
[13:19:58.004]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.004]                               "", base::R.version$version.string), 
[13:19:58.004]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:58.004]                                 base::R.version$platform, 8 * 
[13:19:58.004]                                   base::.Machine$sizeof.pointer), 
[13:19:58.004]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.004]                                 "release", "version")], collapse = " "), 
[13:19:58.004]                               hostname = base::Sys.info()[["nodename"]])
[13:19:58.004]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.004]                               info)
[13:19:58.004]                             info <- base::paste(info, collapse = "; ")
[13:19:58.004]                             if (!has_future) {
[13:19:58.004]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.004]                                 info)
[13:19:58.004]                             }
[13:19:58.004]                             else {
[13:19:58.004]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.004]                                 info, version)
[13:19:58.004]                             }
[13:19:58.004]                             base::stop(msg)
[13:19:58.004]                           }
[13:19:58.004]                         })
[13:19:58.004]                       }
[13:19:58.004]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.004]                       base::options(mc.cores = 1L)
[13:19:58.004]                     }
[13:19:58.004]                     base::local({
[13:19:58.004]                       for (pkg in "future") {
[13:19:58.004]                         base::loadNamespace(pkg)
[13:19:58.004]                         base::library(pkg, character.only = TRUE)
[13:19:58.004]                       }
[13:19:58.004]                     })
[13:19:58.004]                   }
[13:19:58.004]                   options(future.plan = NULL)
[13:19:58.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.004]                 }
[13:19:58.004]                 ...future.workdir <- getwd()
[13:19:58.004]             }
[13:19:58.004]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.004]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.004]         }
[13:19:58.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.004]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.004]             base::names(...future.oldOptions))
[13:19:58.004]     }
[13:19:58.004]     if (FALSE) {
[13:19:58.004]     }
[13:19:58.004]     else {
[13:19:58.004]         if (TRUE) {
[13:19:58.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.004]                 open = "w")
[13:19:58.004]         }
[13:19:58.004]         else {
[13:19:58.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.004]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.004]         }
[13:19:58.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.004]             base::sink(type = "output", split = FALSE)
[13:19:58.004]             base::close(...future.stdout)
[13:19:58.004]         }, add = TRUE)
[13:19:58.004]     }
[13:19:58.004]     ...future.frame <- base::sys.nframe()
[13:19:58.004]     ...future.conditions <- base::list()
[13:19:58.004]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.004]     if (FALSE) {
[13:19:58.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.004]     }
[13:19:58.004]     ...future.result <- base::tryCatch({
[13:19:58.004]         base::withCallingHandlers({
[13:19:58.004]             ...future.value <- base::withVisible(base::local({
[13:19:58.004]                 ...future.makeSendCondition <- local({
[13:19:58.004]                   sendCondition <- NULL
[13:19:58.004]                   function(frame = 1L) {
[13:19:58.004]                     if (is.function(sendCondition)) 
[13:19:58.004]                       return(sendCondition)
[13:19:58.004]                     ns <- getNamespace("parallel")
[13:19:58.004]                     if (exists("sendData", mode = "function", 
[13:19:58.004]                       envir = ns)) {
[13:19:58.004]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:58.004]                         envir = ns)
[13:19:58.004]                       envir <- sys.frame(frame)
[13:19:58.004]                       master <- NULL
[13:19:58.004]                       while (!identical(envir, .GlobalEnv) && 
[13:19:58.004]                         !identical(envir, emptyenv())) {
[13:19:58.004]                         if (exists("master", mode = "list", envir = envir, 
[13:19:58.004]                           inherits = FALSE)) {
[13:19:58.004]                           master <- get("master", mode = "list", 
[13:19:58.004]                             envir = envir, inherits = FALSE)
[13:19:58.004]                           if (inherits(master, c("SOCKnode", 
[13:19:58.004]                             "SOCK0node"))) {
[13:19:58.004]                             sendCondition <<- function(cond) {
[13:19:58.004]                               data <- list(type = "VALUE", value = cond, 
[13:19:58.004]                                 success = TRUE)
[13:19:58.004]                               parallel_sendData(master, data)
[13:19:58.004]                             }
[13:19:58.004]                             return(sendCondition)
[13:19:58.004]                           }
[13:19:58.004]                         }
[13:19:58.004]                         frame <- frame + 1L
[13:19:58.004]                         envir <- sys.frame(frame)
[13:19:58.004]                       }
[13:19:58.004]                     }
[13:19:58.004]                     sendCondition <<- function(cond) NULL
[13:19:58.004]                   }
[13:19:58.004]                 })
[13:19:58.004]                 withCallingHandlers({
[13:19:58.004]                   {
[13:19:58.004]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:58.004]                       ii, n), appendLF = FALSE)
[13:19:58.004]                     fit <- mandelbrot(C)
[13:19:58.004]                     delay(fit)
[13:19:58.004]                     message(" done")
[13:19:58.004]                     fit
[13:19:58.004]                   }
[13:19:58.004]                 }, immediateCondition = function(cond) {
[13:19:58.004]                   sendCondition <- ...future.makeSendCondition()
[13:19:58.004]                   sendCondition(cond)
[13:19:58.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.004]                   {
[13:19:58.004]                     inherits <- base::inherits
[13:19:58.004]                     invokeRestart <- base::invokeRestart
[13:19:58.004]                     is.null <- base::is.null
[13:19:58.004]                     muffled <- FALSE
[13:19:58.004]                     if (inherits(cond, "message")) {
[13:19:58.004]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.004]                       if (muffled) 
[13:19:58.004]                         invokeRestart("muffleMessage")
[13:19:58.004]                     }
[13:19:58.004]                     else if (inherits(cond, "warning")) {
[13:19:58.004]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.004]                       if (muffled) 
[13:19:58.004]                         invokeRestart("muffleWarning")
[13:19:58.004]                     }
[13:19:58.004]                     else if (inherits(cond, "condition")) {
[13:19:58.004]                       if (!is.null(pattern)) {
[13:19:58.004]                         computeRestarts <- base::computeRestarts
[13:19:58.004]                         grepl <- base::grepl
[13:19:58.004]                         restarts <- computeRestarts(cond)
[13:19:58.004]                         for (restart in restarts) {
[13:19:58.004]                           name <- restart$name
[13:19:58.004]                           if (is.null(name)) 
[13:19:58.004]                             next
[13:19:58.004]                           if (!grepl(pattern, name)) 
[13:19:58.004]                             next
[13:19:58.004]                           invokeRestart(restart)
[13:19:58.004]                           muffled <- TRUE
[13:19:58.004]                           break
[13:19:58.004]                         }
[13:19:58.004]                       }
[13:19:58.004]                     }
[13:19:58.004]                     invisible(muffled)
[13:19:58.004]                   }
[13:19:58.004]                   muffleCondition(cond)
[13:19:58.004]                 })
[13:19:58.004]             }))
[13:19:58.004]             future::FutureResult(value = ...future.value$value, 
[13:19:58.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.004]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.004]                     ...future.globalenv.names))
[13:19:58.004]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.004]         }, condition = base::local({
[13:19:58.004]             c <- base::c
[13:19:58.004]             inherits <- base::inherits
[13:19:58.004]             invokeRestart <- base::invokeRestart
[13:19:58.004]             length <- base::length
[13:19:58.004]             list <- base::list
[13:19:58.004]             seq.int <- base::seq.int
[13:19:58.004]             signalCondition <- base::signalCondition
[13:19:58.004]             sys.calls <- base::sys.calls
[13:19:58.004]             `[[` <- base::`[[`
[13:19:58.004]             `+` <- base::`+`
[13:19:58.004]             `<<-` <- base::`<<-`
[13:19:58.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.004]                   3L)]
[13:19:58.004]             }
[13:19:58.004]             function(cond) {
[13:19:58.004]                 is_error <- inherits(cond, "error")
[13:19:58.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.004]                   NULL)
[13:19:58.004]                 if (is_error) {
[13:19:58.004]                   sessionInformation <- function() {
[13:19:58.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.004]                       search = base::search(), system = base::Sys.info())
[13:19:58.004]                   }
[13:19:58.004]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.004]                     cond$call), session = sessionInformation(), 
[13:19:58.004]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.004]                   signalCondition(cond)
[13:19:58.004]                 }
[13:19:58.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.004]                 "immediateCondition"))) {
[13:19:58.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.004]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.004]                   if (TRUE && !signal) {
[13:19:58.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.004]                     {
[13:19:58.004]                       inherits <- base::inherits
[13:19:58.004]                       invokeRestart <- base::invokeRestart
[13:19:58.004]                       is.null <- base::is.null
[13:19:58.004]                       muffled <- FALSE
[13:19:58.004]                       if (inherits(cond, "message")) {
[13:19:58.004]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.004]                         if (muffled) 
[13:19:58.004]                           invokeRestart("muffleMessage")
[13:19:58.004]                       }
[13:19:58.004]                       else if (inherits(cond, "warning")) {
[13:19:58.004]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.004]                         if (muffled) 
[13:19:58.004]                           invokeRestart("muffleWarning")
[13:19:58.004]                       }
[13:19:58.004]                       else if (inherits(cond, "condition")) {
[13:19:58.004]                         if (!is.null(pattern)) {
[13:19:58.004]                           computeRestarts <- base::computeRestarts
[13:19:58.004]                           grepl <- base::grepl
[13:19:58.004]                           restarts <- computeRestarts(cond)
[13:19:58.004]                           for (restart in restarts) {
[13:19:58.004]                             name <- restart$name
[13:19:58.004]                             if (is.null(name)) 
[13:19:58.004]                               next
[13:19:58.004]                             if (!grepl(pattern, name)) 
[13:19:58.004]                               next
[13:19:58.004]                             invokeRestart(restart)
[13:19:58.004]                             muffled <- TRUE
[13:19:58.004]                             break
[13:19:58.004]                           }
[13:19:58.004]                         }
[13:19:58.004]                       }
[13:19:58.004]                       invisible(muffled)
[13:19:58.004]                     }
[13:19:58.004]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.004]                   }
[13:19:58.004]                 }
[13:19:58.004]                 else {
[13:19:58.004]                   if (TRUE) {
[13:19:58.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.004]                     {
[13:19:58.004]                       inherits <- base::inherits
[13:19:58.004]                       invokeRestart <- base::invokeRestart
[13:19:58.004]                       is.null <- base::is.null
[13:19:58.004]                       muffled <- FALSE
[13:19:58.004]                       if (inherits(cond, "message")) {
[13:19:58.004]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.004]                         if (muffled) 
[13:19:58.004]                           invokeRestart("muffleMessage")
[13:19:58.004]                       }
[13:19:58.004]                       else if (inherits(cond, "warning")) {
[13:19:58.004]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.004]                         if (muffled) 
[13:19:58.004]                           invokeRestart("muffleWarning")
[13:19:58.004]                       }
[13:19:58.004]                       else if (inherits(cond, "condition")) {
[13:19:58.004]                         if (!is.null(pattern)) {
[13:19:58.004]                           computeRestarts <- base::computeRestarts
[13:19:58.004]                           grepl <- base::grepl
[13:19:58.004]                           restarts <- computeRestarts(cond)
[13:19:58.004]                           for (restart in restarts) {
[13:19:58.004]                             name <- restart$name
[13:19:58.004]                             if (is.null(name)) 
[13:19:58.004]                               next
[13:19:58.004]                             if (!grepl(pattern, name)) 
[13:19:58.004]                               next
[13:19:58.004]                             invokeRestart(restart)
[13:19:58.004]                             muffled <- TRUE
[13:19:58.004]                             break
[13:19:58.004]                           }
[13:19:58.004]                         }
[13:19:58.004]                       }
[13:19:58.004]                       invisible(muffled)
[13:19:58.004]                     }
[13:19:58.004]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.004]                   }
[13:19:58.004]                 }
[13:19:58.004]             }
[13:19:58.004]         }))
[13:19:58.004]     }, error = function(ex) {
[13:19:58.004]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.004]                 ...future.rng), started = ...future.startTime, 
[13:19:58.004]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.004]             version = "1.8"), class = "FutureResult")
[13:19:58.004]     }, finally = {
[13:19:58.004]         if (!identical(...future.workdir, getwd())) 
[13:19:58.004]             setwd(...future.workdir)
[13:19:58.004]         {
[13:19:58.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.004]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.004]             }
[13:19:58.004]             base::options(...future.oldOptions)
[13:19:58.004]             if (.Platform$OS.type == "windows") {
[13:19:58.004]                 old_names <- names(...future.oldEnvVars)
[13:19:58.004]                 envs <- base::Sys.getenv()
[13:19:58.004]                 names <- names(envs)
[13:19:58.004]                 common <- intersect(names, old_names)
[13:19:58.004]                 added <- setdiff(names, old_names)
[13:19:58.004]                 removed <- setdiff(old_names, names)
[13:19:58.004]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.004]                   envs[common]]
[13:19:58.004]                 NAMES <- toupper(changed)
[13:19:58.004]                 args <- list()
[13:19:58.004]                 for (kk in seq_along(NAMES)) {
[13:19:58.004]                   name <- changed[[kk]]
[13:19:58.004]                   NAME <- NAMES[[kk]]
[13:19:58.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.004]                     next
[13:19:58.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.004]                 }
[13:19:58.004]                 NAMES <- toupper(added)
[13:19:58.004]                 for (kk in seq_along(NAMES)) {
[13:19:58.004]                   name <- added[[kk]]
[13:19:58.004]                   NAME <- NAMES[[kk]]
[13:19:58.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.004]                     next
[13:19:58.004]                   args[[name]] <- ""
[13:19:58.004]                 }
[13:19:58.004]                 NAMES <- toupper(removed)
[13:19:58.004]                 for (kk in seq_along(NAMES)) {
[13:19:58.004]                   name <- removed[[kk]]
[13:19:58.004]                   NAME <- NAMES[[kk]]
[13:19:58.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.004]                     next
[13:19:58.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.004]                 }
[13:19:58.004]                 if (length(args) > 0) 
[13:19:58.004]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.004]             }
[13:19:58.004]             else {
[13:19:58.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.004]             }
[13:19:58.004]             {
[13:19:58.004]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.004]                   0L) {
[13:19:58.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.004]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.004]                   base::options(opts)
[13:19:58.004]                 }
[13:19:58.004]                 {
[13:19:58.004]                   {
[13:19:58.004]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.004]                     NULL
[13:19:58.004]                   }
[13:19:58.004]                   options(future.plan = NULL)
[13:19:58.004]                   if (is.na(NA_character_)) 
[13:19:58.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.004]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:58.004]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:58.004]                     envir = parent.frame()) 
[13:19:58.004]                   {
[13:19:58.004]                     if (is.function(workers)) 
[13:19:58.004]                       workers <- workers()
[13:19:58.004]                     workers <- structure(as.integer(workers), 
[13:19:58.004]                       class = class(workers))
[13:19:58.004]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:58.004]                       workers >= 1)
[13:19:58.004]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:58.004]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:58.004]                     }
[13:19:58.004]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:58.004]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:58.004]                       envir = envir)
[13:19:58.004]                     if (!future$lazy) 
[13:19:58.004]                       future <- run(future)
[13:19:58.004]                     invisible(future)
[13:19:58.004]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.004]                 }
[13:19:58.004]             }
[13:19:58.004]         }
[13:19:58.004]     })
[13:19:58.004]     if (TRUE) {
[13:19:58.004]         base::sink(type = "output", split = FALSE)
[13:19:58.004]         if (TRUE) {
[13:19:58.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.004]         }
[13:19:58.004]         else {
[13:19:58.004]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.004]         }
[13:19:58.004]         base::close(...future.stdout)
[13:19:58.004]         ...future.stdout <- NULL
[13:19:58.004]     }
[13:19:58.004]     ...future.result$conditions <- ...future.conditions
[13:19:58.004]     ...future.result$finished <- base::Sys.time()
[13:19:58.004]     ...future.result
[13:19:58.004] }
[13:19:58.078] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[13:19:58.078] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:19:58.078] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:19:58.078] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[13:19:58.079] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[13:19:58.079] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[13:19:58.121] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[13:19:58.121] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[13:19:58.165] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[13:19:58.165] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[13:19:58.166] MultisessionFuture started
[13:19:58.166] - Launch lazy future ... done
[13:19:58.166] run() for ‘MultisessionFuture’ ... done
[13:19:58.166] - run() ... done
[13:19:58.167] - resolved() ...
[13:19:58.177] - resolved: FALSE
[13:19:58.177] - resolved() ... done
[13:19:58.177] resolved() for ‘MultisessionFuture’ ... done
[13:19:58.178] resolved() for ‘Future’ ...
[13:19:58.178] - state: ‘created’
[13:19:58.178] - run: TRUE
[13:19:58.178] - run() ...
[13:19:58.178] run() for ‘Future’ ...
[13:19:58.178] - state: ‘created’
[13:19:58.178] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:58.194]   - Field: ‘node’
[13:19:58.194]   - Field: ‘label’
[13:19:58.194]   - Field: ‘local’
[13:19:58.194]   - Field: ‘owner’
[13:19:58.194]   - Field: ‘envir’
[13:19:58.194]   - Field: ‘workers’
[13:19:58.194]   - Field: ‘packages’
[13:19:58.194]   - Field: ‘gc’
[13:19:58.194]   - Field: ‘conditions’
[13:19:58.194]   - Field: ‘persistent’
[13:19:58.195]   - Field: ‘expr’
[13:19:58.195]   - Field: ‘uuid’
[13:19:58.195]   - Field: ‘seed’
[13:19:58.195]   - Field: ‘version’
[13:19:58.195]   - Field: ‘result’
[13:19:58.195]   - Field: ‘asynchronous’
[13:19:58.195]   - Field: ‘calls’
[13:19:58.195]   - Field: ‘globals’
[13:19:58.195]   - Field: ‘stdout’
[13:19:58.195]   - Field: ‘earlySignal’
[13:19:58.195]   - Field: ‘lazy’
[13:19:58.196]   - Field: ‘state’
[13:19:58.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:58.196] - Launch lazy future ...
[13:19:58.196] Packages needed by the future expression (n = 1): ‘future’
[13:19:58.196] Packages needed by future strategies (n = 0): <none>
[13:19:58.197] {
[13:19:58.197]     {
[13:19:58.197]         {
[13:19:58.197]             ...future.startTime <- base::Sys.time()
[13:19:58.197]             {
[13:19:58.197]                 {
[13:19:58.197]                   {
[13:19:58.197]                     {
[13:19:58.197]                       {
[13:19:58.197]                         base::local({
[13:19:58.197]                           has_future <- base::requireNamespace("future", 
[13:19:58.197]                             quietly = TRUE)
[13:19:58.197]                           if (has_future) {
[13:19:58.197]                             ns <- base::getNamespace("future")
[13:19:58.197]                             version <- ns[[".package"]][["version"]]
[13:19:58.197]                             if (is.null(version)) 
[13:19:58.197]                               version <- utils::packageVersion("future")
[13:19:58.197]                           }
[13:19:58.197]                           else {
[13:19:58.197]                             version <- NULL
[13:19:58.197]                           }
[13:19:58.197]                           if (!has_future || version < "1.8.0") {
[13:19:58.197]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.197]                               "", base::R.version$version.string), 
[13:19:58.197]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:58.197]                                 base::R.version$platform, 8 * 
[13:19:58.197]                                   base::.Machine$sizeof.pointer), 
[13:19:58.197]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.197]                                 "release", "version")], collapse = " "), 
[13:19:58.197]                               hostname = base::Sys.info()[["nodename"]])
[13:19:58.197]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.197]                               info)
[13:19:58.197]                             info <- base::paste(info, collapse = "; ")
[13:19:58.197]                             if (!has_future) {
[13:19:58.197]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.197]                                 info)
[13:19:58.197]                             }
[13:19:58.197]                             else {
[13:19:58.197]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.197]                                 info, version)
[13:19:58.197]                             }
[13:19:58.197]                             base::stop(msg)
[13:19:58.197]                           }
[13:19:58.197]                         })
[13:19:58.197]                       }
[13:19:58.197]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.197]                       base::options(mc.cores = 1L)
[13:19:58.197]                     }
[13:19:58.197]                     base::local({
[13:19:58.197]                       for (pkg in "future") {
[13:19:58.197]                         base::loadNamespace(pkg)
[13:19:58.197]                         base::library(pkg, character.only = TRUE)
[13:19:58.197]                       }
[13:19:58.197]                     })
[13:19:58.197]                   }
[13:19:58.197]                   options(future.plan = NULL)
[13:19:58.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.197]                 }
[13:19:58.197]                 ...future.workdir <- getwd()
[13:19:58.197]             }
[13:19:58.197]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.197]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.197]         }
[13:19:58.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.197]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.197]             base::names(...future.oldOptions))
[13:19:58.197]     }
[13:19:58.197]     if (FALSE) {
[13:19:58.197]     }
[13:19:58.197]     else {
[13:19:58.197]         if (TRUE) {
[13:19:58.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.197]                 open = "w")
[13:19:58.197]         }
[13:19:58.197]         else {
[13:19:58.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.197]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.197]         }
[13:19:58.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.197]             base::sink(type = "output", split = FALSE)
[13:19:58.197]             base::close(...future.stdout)
[13:19:58.197]         }, add = TRUE)
[13:19:58.197]     }
[13:19:58.197]     ...future.frame <- base::sys.nframe()
[13:19:58.197]     ...future.conditions <- base::list()
[13:19:58.197]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.197]     if (FALSE) {
[13:19:58.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.197]     }
[13:19:58.197]     ...future.result <- base::tryCatch({
[13:19:58.197]         base::withCallingHandlers({
[13:19:58.197]             ...future.value <- base::withVisible(base::local({
[13:19:58.197]                 ...future.makeSendCondition <- local({
[13:19:58.197]                   sendCondition <- NULL
[13:19:58.197]                   function(frame = 1L) {
[13:19:58.197]                     if (is.function(sendCondition)) 
[13:19:58.197]                       return(sendCondition)
[13:19:58.197]                     ns <- getNamespace("parallel")
[13:19:58.197]                     if (exists("sendData", mode = "function", 
[13:19:58.197]                       envir = ns)) {
[13:19:58.197]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:58.197]                         envir = ns)
[13:19:58.197]                       envir <- sys.frame(frame)
[13:19:58.197]                       master <- NULL
[13:19:58.197]                       while (!identical(envir, .GlobalEnv) && 
[13:19:58.197]                         !identical(envir, emptyenv())) {
[13:19:58.197]                         if (exists("master", mode = "list", envir = envir, 
[13:19:58.197]                           inherits = FALSE)) {
[13:19:58.197]                           master <- get("master", mode = "list", 
[13:19:58.197]                             envir = envir, inherits = FALSE)
[13:19:58.197]                           if (inherits(master, c("SOCKnode", 
[13:19:58.197]                             "SOCK0node"))) {
[13:19:58.197]                             sendCondition <<- function(cond) {
[13:19:58.197]                               data <- list(type = "VALUE", value = cond, 
[13:19:58.197]                                 success = TRUE)
[13:19:58.197]                               parallel_sendData(master, data)
[13:19:58.197]                             }
[13:19:58.197]                             return(sendCondition)
[13:19:58.197]                           }
[13:19:58.197]                         }
[13:19:58.197]                         frame <- frame + 1L
[13:19:58.197]                         envir <- sys.frame(frame)
[13:19:58.197]                       }
[13:19:58.197]                     }
[13:19:58.197]                     sendCondition <<- function(cond) NULL
[13:19:58.197]                   }
[13:19:58.197]                 })
[13:19:58.197]                 withCallingHandlers({
[13:19:58.197]                   {
[13:19:58.197]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:58.197]                       ii, n), appendLF = FALSE)
[13:19:58.197]                     fit <- mandelbrot(C)
[13:19:58.197]                     delay(fit)
[13:19:58.197]                     message(" done")
[13:19:58.197]                     fit
[13:19:58.197]                   }
[13:19:58.197]                 }, immediateCondition = function(cond) {
[13:19:58.197]                   sendCondition <- ...future.makeSendCondition()
[13:19:58.197]                   sendCondition(cond)
[13:19:58.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.197]                   {
[13:19:58.197]                     inherits <- base::inherits
[13:19:58.197]                     invokeRestart <- base::invokeRestart
[13:19:58.197]                     is.null <- base::is.null
[13:19:58.197]                     muffled <- FALSE
[13:19:58.197]                     if (inherits(cond, "message")) {
[13:19:58.197]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.197]                       if (muffled) 
[13:19:58.197]                         invokeRestart("muffleMessage")
[13:19:58.197]                     }
[13:19:58.197]                     else if (inherits(cond, "warning")) {
[13:19:58.197]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.197]                       if (muffled) 
[13:19:58.197]                         invokeRestart("muffleWarning")
[13:19:58.197]                     }
[13:19:58.197]                     else if (inherits(cond, "condition")) {
[13:19:58.197]                       if (!is.null(pattern)) {
[13:19:58.197]                         computeRestarts <- base::computeRestarts
[13:19:58.197]                         grepl <- base::grepl
[13:19:58.197]                         restarts <- computeRestarts(cond)
[13:19:58.197]                         for (restart in restarts) {
[13:19:58.197]                           name <- restart$name
[13:19:58.197]                           if (is.null(name)) 
[13:19:58.197]                             next
[13:19:58.197]                           if (!grepl(pattern, name)) 
[13:19:58.197]                             next
[13:19:58.197]                           invokeRestart(restart)
[13:19:58.197]                           muffled <- TRUE
[13:19:58.197]                           break
[13:19:58.197]                         }
[13:19:58.197]                       }
[13:19:58.197]                     }
[13:19:58.197]                     invisible(muffled)
[13:19:58.197]                   }
[13:19:58.197]                   muffleCondition(cond)
[13:19:58.197]                 })
[13:19:58.197]             }))
[13:19:58.197]             future::FutureResult(value = ...future.value$value, 
[13:19:58.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.197]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.197]                     ...future.globalenv.names))
[13:19:58.197]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.197]         }, condition = base::local({
[13:19:58.197]             c <- base::c
[13:19:58.197]             inherits <- base::inherits
[13:19:58.197]             invokeRestart <- base::invokeRestart
[13:19:58.197]             length <- base::length
[13:19:58.197]             list <- base::list
[13:19:58.197]             seq.int <- base::seq.int
[13:19:58.197]             signalCondition <- base::signalCondition
[13:19:58.197]             sys.calls <- base::sys.calls
[13:19:58.197]             `[[` <- base::`[[`
[13:19:58.197]             `+` <- base::`+`
[13:19:58.197]             `<<-` <- base::`<<-`
[13:19:58.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.197]                   3L)]
[13:19:58.197]             }
[13:19:58.197]             function(cond) {
[13:19:58.197]                 is_error <- inherits(cond, "error")
[13:19:58.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.197]                   NULL)
[13:19:58.197]                 if (is_error) {
[13:19:58.197]                   sessionInformation <- function() {
[13:19:58.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.197]                       search = base::search(), system = base::Sys.info())
[13:19:58.197]                   }
[13:19:58.197]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.197]                     cond$call), session = sessionInformation(), 
[13:19:58.197]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.197]                   signalCondition(cond)
[13:19:58.197]                 }
[13:19:58.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.197]                 "immediateCondition"))) {
[13:19:58.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.197]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.197]                   if (TRUE && !signal) {
[13:19:58.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.197]                     {
[13:19:58.197]                       inherits <- base::inherits
[13:19:58.197]                       invokeRestart <- base::invokeRestart
[13:19:58.197]                       is.null <- base::is.null
[13:19:58.197]                       muffled <- FALSE
[13:19:58.197]                       if (inherits(cond, "message")) {
[13:19:58.197]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.197]                         if (muffled) 
[13:19:58.197]                           invokeRestart("muffleMessage")
[13:19:58.197]                       }
[13:19:58.197]                       else if (inherits(cond, "warning")) {
[13:19:58.197]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.197]                         if (muffled) 
[13:19:58.197]                           invokeRestart("muffleWarning")
[13:19:58.197]                       }
[13:19:58.197]                       else if (inherits(cond, "condition")) {
[13:19:58.197]                         if (!is.null(pattern)) {
[13:19:58.197]                           computeRestarts <- base::computeRestarts
[13:19:58.197]                           grepl <- base::grepl
[13:19:58.197]                           restarts <- computeRestarts(cond)
[13:19:58.197]                           for (restart in restarts) {
[13:19:58.197]                             name <- restart$name
[13:19:58.197]                             if (is.null(name)) 
[13:19:58.197]                               next
[13:19:58.197]                             if (!grepl(pattern, name)) 
[13:19:58.197]                               next
[13:19:58.197]                             invokeRestart(restart)
[13:19:58.197]                             muffled <- TRUE
[13:19:58.197]                             break
[13:19:58.197]                           }
[13:19:58.197]                         }
[13:19:58.197]                       }
[13:19:58.197]                       invisible(muffled)
[13:19:58.197]                     }
[13:19:58.197]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.197]                   }
[13:19:58.197]                 }
[13:19:58.197]                 else {
[13:19:58.197]                   if (TRUE) {
[13:19:58.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.197]                     {
[13:19:58.197]                       inherits <- base::inherits
[13:19:58.197]                       invokeRestart <- base::invokeRestart
[13:19:58.197]                       is.null <- base::is.null
[13:19:58.197]                       muffled <- FALSE
[13:19:58.197]                       if (inherits(cond, "message")) {
[13:19:58.197]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.197]                         if (muffled) 
[13:19:58.197]                           invokeRestart("muffleMessage")
[13:19:58.197]                       }
[13:19:58.197]                       else if (inherits(cond, "warning")) {
[13:19:58.197]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.197]                         if (muffled) 
[13:19:58.197]                           invokeRestart("muffleWarning")
[13:19:58.197]                       }
[13:19:58.197]                       else if (inherits(cond, "condition")) {
[13:19:58.197]                         if (!is.null(pattern)) {
[13:19:58.197]                           computeRestarts <- base::computeRestarts
[13:19:58.197]                           grepl <- base::grepl
[13:19:58.197]                           restarts <- computeRestarts(cond)
[13:19:58.197]                           for (restart in restarts) {
[13:19:58.197]                             name <- restart$name
[13:19:58.197]                             if (is.null(name)) 
[13:19:58.197]                               next
[13:19:58.197]                             if (!grepl(pattern, name)) 
[13:19:58.197]                               next
[13:19:58.197]                             invokeRestart(restart)
[13:19:58.197]                             muffled <- TRUE
[13:19:58.197]                             break
[13:19:58.197]                           }
[13:19:58.197]                         }
[13:19:58.197]                       }
[13:19:58.197]                       invisible(muffled)
[13:19:58.197]                     }
[13:19:58.197]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.197]                   }
[13:19:58.197]                 }
[13:19:58.197]             }
[13:19:58.197]         }))
[13:19:58.197]     }, error = function(ex) {
[13:19:58.197]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.197]                 ...future.rng), started = ...future.startTime, 
[13:19:58.197]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.197]             version = "1.8"), class = "FutureResult")
[13:19:58.197]     }, finally = {
[13:19:58.197]         if (!identical(...future.workdir, getwd())) 
[13:19:58.197]             setwd(...future.workdir)
[13:19:58.197]         {
[13:19:58.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.197]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.197]             }
[13:19:58.197]             base::options(...future.oldOptions)
[13:19:58.197]             if (.Platform$OS.type == "windows") {
[13:19:58.197]                 old_names <- names(...future.oldEnvVars)
[13:19:58.197]                 envs <- base::Sys.getenv()
[13:19:58.197]                 names <- names(envs)
[13:19:58.197]                 common <- intersect(names, old_names)
[13:19:58.197]                 added <- setdiff(names, old_names)
[13:19:58.197]                 removed <- setdiff(old_names, names)
[13:19:58.197]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.197]                   envs[common]]
[13:19:58.197]                 NAMES <- toupper(changed)
[13:19:58.197]                 args <- list()
[13:19:58.197]                 for (kk in seq_along(NAMES)) {
[13:19:58.197]                   name <- changed[[kk]]
[13:19:58.197]                   NAME <- NAMES[[kk]]
[13:19:58.197]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.197]                     next
[13:19:58.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.197]                 }
[13:19:58.197]                 NAMES <- toupper(added)
[13:19:58.197]                 for (kk in seq_along(NAMES)) {
[13:19:58.197]                   name <- added[[kk]]
[13:19:58.197]                   NAME <- NAMES[[kk]]
[13:19:58.197]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.197]                     next
[13:19:58.197]                   args[[name]] <- ""
[13:19:58.197]                 }
[13:19:58.197]                 NAMES <- toupper(removed)
[13:19:58.197]                 for (kk in seq_along(NAMES)) {
[13:19:58.197]                   name <- removed[[kk]]
[13:19:58.197]                   NAME <- NAMES[[kk]]
[13:19:58.197]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.197]                     next
[13:19:58.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.197]                 }
[13:19:58.197]                 if (length(args) > 0) 
[13:19:58.197]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.197]             }
[13:19:58.197]             else {
[13:19:58.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.197]             }
[13:19:58.197]             {
[13:19:58.197]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.197]                   0L) {
[13:19:58.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.197]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.197]                   base::options(opts)
[13:19:58.197]                 }
[13:19:58.197]                 {
[13:19:58.197]                   {
[13:19:58.197]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.197]                     NULL
[13:19:58.197]                   }
[13:19:58.197]                   options(future.plan = NULL)
[13:19:58.197]                   if (is.na(NA_character_)) 
[13:19:58.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.197]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:58.197]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:58.197]                     envir = parent.frame()) 
[13:19:58.197]                   {
[13:19:58.197]                     if (is.function(workers)) 
[13:19:58.197]                       workers <- workers()
[13:19:58.197]                     workers <- structure(as.integer(workers), 
[13:19:58.197]                       class = class(workers))
[13:19:58.197]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:58.197]                       workers >= 1)
[13:19:58.197]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:58.197]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:58.197]                     }
[13:19:58.197]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:58.197]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:58.197]                       envir = envir)
[13:19:58.197]                     if (!future$lazy) 
[13:19:58.197]                       future <- run(future)
[13:19:58.197]                     invisible(future)
[13:19:58.197]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.197]                 }
[13:19:58.197]             }
[13:19:58.197]         }
[13:19:58.197]     })
[13:19:58.197]     if (TRUE) {
[13:19:58.197]         base::sink(type = "output", split = FALSE)
[13:19:58.197]         if (TRUE) {
[13:19:58.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.197]         }
[13:19:58.197]         else {
[13:19:58.197]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.197]         }
[13:19:58.197]         base::close(...future.stdout)
[13:19:58.197]         ...future.stdout <- NULL
[13:19:58.197]     }
[13:19:58.197]     ...future.result$conditions <- ...future.conditions
[13:19:58.197]     ...future.result$finished <- base::Sys.time()
[13:19:58.197]     ...future.result
[13:19:58.197] }
[13:19:58.199] Poll #1 (0): usedNodes() = 2, workers = 2
[13:19:58.218] receiveMessageFromWorker() for ClusterFuture ...
[13:19:58.218] - Validating connection of MultisessionFuture
[13:19:58.218] - received message: FutureResult
[13:19:58.219] - Received FutureResult
[13:19:58.219] - Erased future from FutureRegistry
[13:19:58.219] result() for ClusterFuture ...
[13:19:58.219] - result already collected: FutureResult
[13:19:58.219] result() for ClusterFuture ... done
[13:19:58.219] signalConditions() ...
[13:19:58.219]  - include = ‘immediateCondition’
[13:19:58.219]  - exclude = 
[13:19:58.219]  - resignal = FALSE
[13:19:58.219]  - Number of conditions: 2
[13:19:58.219] signalConditions() ... done
[13:19:58.220] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:58.220] result() for ClusterFuture ...
[13:19:58.220] - result already collected: FutureResult
[13:19:58.220] result() for ClusterFuture ... done
[13:19:58.220] result() for ClusterFuture ...
[13:19:58.220] - result already collected: FutureResult
[13:19:58.220] result() for ClusterFuture ... done
[13:19:58.220] signalConditions() ...
[13:19:58.220]  - include = ‘immediateCondition’
[13:19:58.220]  - exclude = 
[13:19:58.220]  - resignal = FALSE
[13:19:58.220]  - Number of conditions: 2
[13:19:58.221] signalConditions() ... done
[13:19:58.221] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[13:19:58.222] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:19:58.222] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:58.222] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[13:19:58.222] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[13:19:58.223] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[13:19:58.269] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[13:19:58.269] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[13:19:58.313] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[13:19:58.313] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[13:19:58.314] MultisessionFuture started
[13:19:58.314] - Launch lazy future ... done
[13:19:58.314] run() for ‘MultisessionFuture’ ... done
[13:19:58.314] - run() ... done
[13:19:58.315] - resolved() ...
[13:19:58.325] - resolved: FALSE
[13:19:58.325] - resolved() ... done
[13:19:58.325] resolved() for ‘MultisessionFuture’ ... done
[13:19:58.326] resolved() for ‘Future’ ...
[13:19:58.326] - state: ‘created’
[13:19:58.326] - run: TRUE
[13:19:58.326] - run() ...
[13:19:58.326] run() for ‘Future’ ...
[13:19:58.326] - state: ‘created’
[13:19:58.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:58.341] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:58.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:58.342]   - Field: ‘node’
[13:19:58.342]   - Field: ‘label’
[13:19:58.342]   - Field: ‘local’
[13:19:58.342]   - Field: ‘owner’
[13:19:58.342]   - Field: ‘envir’
[13:19:58.342]   - Field: ‘workers’
[13:19:58.342]   - Field: ‘packages’
[13:19:58.342]   - Field: ‘gc’
[13:19:58.342]   - Field: ‘conditions’
[13:19:58.342]   - Field: ‘persistent’
[13:19:58.343]   - Field: ‘expr’
[13:19:58.343]   - Field: ‘uuid’
[13:19:58.343]   - Field: ‘seed’
[13:19:58.343]   - Field: ‘version’
[13:19:58.343]   - Field: ‘result’
[13:19:58.343]   - Field: ‘asynchronous’
[13:19:58.343]   - Field: ‘calls’
[13:19:58.343]   - Field: ‘globals’
[13:19:58.343]   - Field: ‘stdout’
[13:19:58.343]   - Field: ‘earlySignal’
[13:19:58.343]   - Field: ‘lazy’
[13:19:58.344]   - Field: ‘state’
[13:19:58.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:58.344] - Launch lazy future ...
[13:19:58.344] Packages needed by the future expression (n = 1): ‘future’
[13:19:58.344] Packages needed by future strategies (n = 0): <none>
[13:19:58.345] {
[13:19:58.345]     {
[13:19:58.345]         {
[13:19:58.345]             ...future.startTime <- base::Sys.time()
[13:19:58.345]             {
[13:19:58.345]                 {
[13:19:58.345]                   {
[13:19:58.345]                     {
[13:19:58.345]                       {
[13:19:58.345]                         base::local({
[13:19:58.345]                           has_future <- base::requireNamespace("future", 
[13:19:58.345]                             quietly = TRUE)
[13:19:58.345]                           if (has_future) {
[13:19:58.345]                             ns <- base::getNamespace("future")
[13:19:58.345]                             version <- ns[[".package"]][["version"]]
[13:19:58.345]                             if (is.null(version)) 
[13:19:58.345]                               version <- utils::packageVersion("future")
[13:19:58.345]                           }
[13:19:58.345]                           else {
[13:19:58.345]                             version <- NULL
[13:19:58.345]                           }
[13:19:58.345]                           if (!has_future || version < "1.8.0") {
[13:19:58.345]                             info <- base::c(r_version = base::gsub("R version ", 
[13:19:58.345]                               "", base::R.version$version.string), 
[13:19:58.345]                               platform = base::sprintf("%s (%s-bit)", 
[13:19:58.345]                                 base::R.version$platform, 8 * 
[13:19:58.345]                                   base::.Machine$sizeof.pointer), 
[13:19:58.345]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:58.345]                                 "release", "version")], collapse = " "), 
[13:19:58.345]                               hostname = base::Sys.info()[["nodename"]])
[13:19:58.345]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:19:58.345]                               info)
[13:19:58.345]                             info <- base::paste(info, collapse = "; ")
[13:19:58.345]                             if (!has_future) {
[13:19:58.345]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:58.345]                                 info)
[13:19:58.345]                             }
[13:19:58.345]                             else {
[13:19:58.345]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:58.345]                                 info, version)
[13:19:58.345]                             }
[13:19:58.345]                             base::stop(msg)
[13:19:58.345]                           }
[13:19:58.345]                         })
[13:19:58.345]                       }
[13:19:58.345]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:58.345]                       base::options(mc.cores = 1L)
[13:19:58.345]                     }
[13:19:58.345]                     base::local({
[13:19:58.345]                       for (pkg in "future") {
[13:19:58.345]                         base::loadNamespace(pkg)
[13:19:58.345]                         base::library(pkg, character.only = TRUE)
[13:19:58.345]                       }
[13:19:58.345]                     })
[13:19:58.345]                   }
[13:19:58.345]                   options(future.plan = NULL)
[13:19:58.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:58.345]                 }
[13:19:58.345]                 ...future.workdir <- getwd()
[13:19:58.345]             }
[13:19:58.345]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:58.345]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:58.345]         }
[13:19:58.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:58.345]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:58.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:58.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:58.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:58.345]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:58.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:58.345]             base::names(...future.oldOptions))
[13:19:58.345]     }
[13:19:58.345]     if (FALSE) {
[13:19:58.345]     }
[13:19:58.345]     else {
[13:19:58.345]         if (TRUE) {
[13:19:58.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:58.345]                 open = "w")
[13:19:58.345]         }
[13:19:58.345]         else {
[13:19:58.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:58.345]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:58.345]         }
[13:19:58.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:58.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:58.345]             base::sink(type = "output", split = FALSE)
[13:19:58.345]             base::close(...future.stdout)
[13:19:58.345]         }, add = TRUE)
[13:19:58.345]     }
[13:19:58.345]     ...future.frame <- base::sys.nframe()
[13:19:58.345]     ...future.conditions <- base::list()
[13:19:58.345]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:58.345]     if (FALSE) {
[13:19:58.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:58.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:58.345]     }
[13:19:58.345]     ...future.result <- base::tryCatch({
[13:19:58.345]         base::withCallingHandlers({
[13:19:58.345]             ...future.value <- base::withVisible(base::local({
[13:19:58.345]                 ...future.makeSendCondition <- local({
[13:19:58.345]                   sendCondition <- NULL
[13:19:58.345]                   function(frame = 1L) {
[13:19:58.345]                     if (is.function(sendCondition)) 
[13:19:58.345]                       return(sendCondition)
[13:19:58.345]                     ns <- getNamespace("parallel")
[13:19:58.345]                     if (exists("sendData", mode = "function", 
[13:19:58.345]                       envir = ns)) {
[13:19:58.345]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:58.345]                         envir = ns)
[13:19:58.345]                       envir <- sys.frame(frame)
[13:19:58.345]                       master <- NULL
[13:19:58.345]                       while (!identical(envir, .GlobalEnv) && 
[13:19:58.345]                         !identical(envir, emptyenv())) {
[13:19:58.345]                         if (exists("master", mode = "list", envir = envir, 
[13:19:58.345]                           inherits = FALSE)) {
[13:19:58.345]                           master <- get("master", mode = "list", 
[13:19:58.345]                             envir = envir, inherits = FALSE)
[13:19:58.345]                           if (inherits(master, c("SOCKnode", 
[13:19:58.345]                             "SOCK0node"))) {
[13:19:58.345]                             sendCondition <<- function(cond) {
[13:19:58.345]                               data <- list(type = "VALUE", value = cond, 
[13:19:58.345]                                 success = TRUE)
[13:19:58.345]                               parallel_sendData(master, data)
[13:19:58.345]                             }
[13:19:58.345]                             return(sendCondition)
[13:19:58.345]                           }
[13:19:58.345]                         }
[13:19:58.345]                         frame <- frame + 1L
[13:19:58.345]                         envir <- sys.frame(frame)
[13:19:58.345]                       }
[13:19:58.345]                     }
[13:19:58.345]                     sendCondition <<- function(cond) NULL
[13:19:58.345]                   }
[13:19:58.345]                 })
[13:19:58.345]                 withCallingHandlers({
[13:19:58.345]                   {
[13:19:58.345]                     message(sprintf("Calculating tile #%d of %d ...", 
[13:19:58.345]                       ii, n), appendLF = FALSE)
[13:19:58.345]                     fit <- mandelbrot(C)
[13:19:58.345]                     delay(fit)
[13:19:58.345]                     message(" done")
[13:19:58.345]                     fit
[13:19:58.345]                   }
[13:19:58.345]                 }, immediateCondition = function(cond) {
[13:19:58.345]                   sendCondition <- ...future.makeSendCondition()
[13:19:58.345]                   sendCondition(cond)
[13:19:58.345]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.345]                   {
[13:19:58.345]                     inherits <- base::inherits
[13:19:58.345]                     invokeRestart <- base::invokeRestart
[13:19:58.345]                     is.null <- base::is.null
[13:19:58.345]                     muffled <- FALSE
[13:19:58.345]                     if (inherits(cond, "message")) {
[13:19:58.345]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:58.345]                       if (muffled) 
[13:19:58.345]                         invokeRestart("muffleMessage")
[13:19:58.345]                     }
[13:19:58.345]                     else if (inherits(cond, "warning")) {
[13:19:58.345]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:58.345]                       if (muffled) 
[13:19:58.345]                         invokeRestart("muffleWarning")
[13:19:58.345]                     }
[13:19:58.345]                     else if (inherits(cond, "condition")) {
[13:19:58.345]                       if (!is.null(pattern)) {
[13:19:58.345]                         computeRestarts <- base::computeRestarts
[13:19:58.345]                         grepl <- base::grepl
[13:19:58.345]                         restarts <- computeRestarts(cond)
[13:19:58.345]                         for (restart in restarts) {
[13:19:58.345]                           name <- restart$name
[13:19:58.345]                           if (is.null(name)) 
[13:19:58.345]                             next
[13:19:58.345]                           if (!grepl(pattern, name)) 
[13:19:58.345]                             next
[13:19:58.345]                           invokeRestart(restart)
[13:19:58.345]                           muffled <- TRUE
[13:19:58.345]                           break
[13:19:58.345]                         }
[13:19:58.345]                       }
[13:19:58.345]                     }
[13:19:58.345]                     invisible(muffled)
[13:19:58.345]                   }
[13:19:58.345]                   muffleCondition(cond)
[13:19:58.345]                 })
[13:19:58.345]             }))
[13:19:58.345]             future::FutureResult(value = ...future.value$value, 
[13:19:58.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.345]                   ...future.rng), globalenv = if (FALSE) 
[13:19:58.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:58.345]                     ...future.globalenv.names))
[13:19:58.345]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:58.345]         }, condition = base::local({
[13:19:58.345]             c <- base::c
[13:19:58.345]             inherits <- base::inherits
[13:19:58.345]             invokeRestart <- base::invokeRestart
[13:19:58.345]             length <- base::length
[13:19:58.345]             list <- base::list
[13:19:58.345]             seq.int <- base::seq.int
[13:19:58.345]             signalCondition <- base::signalCondition
[13:19:58.345]             sys.calls <- base::sys.calls
[13:19:58.345]             `[[` <- base::`[[`
[13:19:58.345]             `+` <- base::`+`
[13:19:58.345]             `<<-` <- base::`<<-`
[13:19:58.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:58.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:58.345]                   3L)]
[13:19:58.345]             }
[13:19:58.345]             function(cond) {
[13:19:58.345]                 is_error <- inherits(cond, "error")
[13:19:58.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:58.345]                   NULL)
[13:19:58.345]                 if (is_error) {
[13:19:58.345]                   sessionInformation <- function() {
[13:19:58.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:58.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:58.345]                       search = base::search(), system = base::Sys.info())
[13:19:58.345]                   }
[13:19:58.345]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:58.345]                     cond$call), session = sessionInformation(), 
[13:19:58.345]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:58.345]                   signalCondition(cond)
[13:19:58.345]                 }
[13:19:58.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:58.345]                 "immediateCondition"))) {
[13:19:58.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:58.345]                   ...future.conditions[[length(...future.conditions) + 
[13:19:58.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:58.345]                   if (TRUE && !signal) {
[13:19:58.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.345]                     {
[13:19:58.345]                       inherits <- base::inherits
[13:19:58.345]                       invokeRestart <- base::invokeRestart
[13:19:58.345]                       is.null <- base::is.null
[13:19:58.345]                       muffled <- FALSE
[13:19:58.345]                       if (inherits(cond, "message")) {
[13:19:58.345]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.345]                         if (muffled) 
[13:19:58.345]                           invokeRestart("muffleMessage")
[13:19:58.345]                       }
[13:19:58.345]                       else if (inherits(cond, "warning")) {
[13:19:58.345]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.345]                         if (muffled) 
[13:19:58.345]                           invokeRestart("muffleWarning")
[13:19:58.345]                       }
[13:19:58.345]                       else if (inherits(cond, "condition")) {
[13:19:58.345]                         if (!is.null(pattern)) {
[13:19:58.345]                           computeRestarts <- base::computeRestarts
[13:19:58.345]                           grepl <- base::grepl
[13:19:58.345]                           restarts <- computeRestarts(cond)
[13:19:58.345]                           for (restart in restarts) {
[13:19:58.345]                             name <- restart$name
[13:19:58.345]                             if (is.null(name)) 
[13:19:58.345]                               next
[13:19:58.345]                             if (!grepl(pattern, name)) 
[13:19:58.345]                               next
[13:19:58.345]                             invokeRestart(restart)
[13:19:58.345]                             muffled <- TRUE
[13:19:58.345]                             break
[13:19:58.345]                           }
[13:19:58.345]                         }
[13:19:58.345]                       }
[13:19:58.345]                       invisible(muffled)
[13:19:58.345]                     }
[13:19:58.345]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.345]                   }
[13:19:58.345]                 }
[13:19:58.345]                 else {
[13:19:58.345]                   if (TRUE) {
[13:19:58.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:58.345]                     {
[13:19:58.345]                       inherits <- base::inherits
[13:19:58.345]                       invokeRestart <- base::invokeRestart
[13:19:58.345]                       is.null <- base::is.null
[13:19:58.345]                       muffled <- FALSE
[13:19:58.345]                       if (inherits(cond, "message")) {
[13:19:58.345]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:58.345]                         if (muffled) 
[13:19:58.345]                           invokeRestart("muffleMessage")
[13:19:58.345]                       }
[13:19:58.345]                       else if (inherits(cond, "warning")) {
[13:19:58.345]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:58.345]                         if (muffled) 
[13:19:58.345]                           invokeRestart("muffleWarning")
[13:19:58.345]                       }
[13:19:58.345]                       else if (inherits(cond, "condition")) {
[13:19:58.345]                         if (!is.null(pattern)) {
[13:19:58.345]                           computeRestarts <- base::computeRestarts
[13:19:58.345]                           grepl <- base::grepl
[13:19:58.345]                           restarts <- computeRestarts(cond)
[13:19:58.345]                           for (restart in restarts) {
[13:19:58.345]                             name <- restart$name
[13:19:58.345]                             if (is.null(name)) 
[13:19:58.345]                               next
[13:19:58.345]                             if (!grepl(pattern, name)) 
[13:19:58.345]                               next
[13:19:58.345]                             invokeRestart(restart)
[13:19:58.345]                             muffled <- TRUE
[13:19:58.345]                             break
[13:19:58.345]                           }
[13:19:58.345]                         }
[13:19:58.345]                       }
[13:19:58.345]                       invisible(muffled)
[13:19:58.345]                     }
[13:19:58.345]                     muffleCondition(cond, pattern = "^muffle")
[13:19:58.345]                   }
[13:19:58.345]                 }
[13:19:58.345]             }
[13:19:58.345]         }))
[13:19:58.345]     }, error = function(ex) {
[13:19:58.345]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:58.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:58.345]                 ...future.rng), started = ...future.startTime, 
[13:19:58.345]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:58.345]             version = "1.8"), class = "FutureResult")
[13:19:58.345]     }, finally = {
[13:19:58.345]         if (!identical(...future.workdir, getwd())) 
[13:19:58.345]             setwd(...future.workdir)
[13:19:58.345]         {
[13:19:58.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:58.345]                 ...future.oldOptions$nwarnings <- NULL
[13:19:58.345]             }
[13:19:58.345]             base::options(...future.oldOptions)
[13:19:58.345]             if (.Platform$OS.type == "windows") {
[13:19:58.345]                 old_names <- names(...future.oldEnvVars)
[13:19:58.345]                 envs <- base::Sys.getenv()
[13:19:58.345]                 names <- names(envs)
[13:19:58.345]                 common <- intersect(names, old_names)
[13:19:58.345]                 added <- setdiff(names, old_names)
[13:19:58.345]                 removed <- setdiff(old_names, names)
[13:19:58.345]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:58.345]                   envs[common]]
[13:19:58.345]                 NAMES <- toupper(changed)
[13:19:58.345]                 args <- list()
[13:19:58.345]                 for (kk in seq_along(NAMES)) {
[13:19:58.345]                   name <- changed[[kk]]
[13:19:58.345]                   NAME <- NAMES[[kk]]
[13:19:58.345]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.345]                     next
[13:19:58.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.345]                 }
[13:19:58.345]                 NAMES <- toupper(added)
[13:19:58.345]                 for (kk in seq_along(NAMES)) {
[13:19:58.345]                   name <- added[[kk]]
[13:19:58.345]                   NAME <- NAMES[[kk]]
[13:19:58.345]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.345]                     next
[13:19:58.345]                   args[[name]] <- ""
[13:19:58.345]                 }
[13:19:58.345]                 NAMES <- toupper(removed)
[13:19:58.345]                 for (kk in seq_along(NAMES)) {
[13:19:58.345]                   name <- removed[[kk]]
[13:19:58.345]                   NAME <- NAMES[[kk]]
[13:19:58.345]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:58.345]                     next
[13:19:58.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:58.345]                 }
[13:19:58.345]                 if (length(args) > 0) 
[13:19:58.345]                   base::do.call(base::Sys.setenv, args = args)
[13:19:58.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:58.345]             }
[13:19:58.345]             else {
[13:19:58.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:58.345]             }
[13:19:58.345]             {
[13:19:58.345]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:58.345]                   0L) {
[13:19:58.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:58.345]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:58.345]                   base::options(opts)
[13:19:58.345]                 }
[13:19:58.345]                 {
[13:19:58.345]                   {
[13:19:58.345]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:58.345]                     NULL
[13:19:58.345]                   }
[13:19:58.345]                   options(future.plan = NULL)
[13:19:58.345]                   if (is.na(NA_character_)) 
[13:19:58.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:58.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:58.345]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:58.345]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:58.345]                     envir = parent.frame()) 
[13:19:58.345]                   {
[13:19:58.345]                     if (is.function(workers)) 
[13:19:58.345]                       workers <- workers()
[13:19:58.345]                     workers <- structure(as.integer(workers), 
[13:19:58.345]                       class = class(workers))
[13:19:58.345]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:58.345]                       workers >= 1)
[13:19:58.345]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:58.345]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:58.345]                     }
[13:19:58.345]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:58.345]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:58.345]                       envir = envir)
[13:19:58.345]                     if (!future$lazy) 
[13:19:58.345]                       future <- run(future)
[13:19:58.345]                     invisible(future)
[13:19:58.345]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:58.345]                 }
[13:19:58.345]             }
[13:19:58.345]         }
[13:19:58.345]     })
[13:19:58.345]     if (TRUE) {
[13:19:58.345]         base::sink(type = "output", split = FALSE)
[13:19:58.345]         if (TRUE) {
[13:19:58.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:58.345]         }
[13:19:58.345]         else {
[13:19:58.345]             ...future.result["stdout"] <- base::list(NULL)
[13:19:58.345]         }
[13:19:58.345]         base::close(...future.stdout)
[13:19:58.345]         ...future.stdout <- NULL
[13:19:58.345]     }
[13:19:58.345]     ...future.result$conditions <- ...future.conditions
[13:19:58.345]     ...future.result$finished <- base::Sys.time()
[13:19:58.345]     ...future.result
[13:19:58.345] }
[13:19:58.347] Poll #1 (0): usedNodes() = 2, workers = 2
[13:19:58.358] receiveMessageFromWorker() for ClusterFuture ...
[13:19:58.358] - Validating connection of MultisessionFuture
[13:19:58.359] - received message: FutureResult
[13:19:58.359] - Received FutureResult
[13:19:58.359] - Erased future from FutureRegistry
[13:19:58.359] result() for ClusterFuture ...
[13:19:58.359] - result already collected: FutureResult
[13:19:58.360] result() for ClusterFuture ... done
[13:19:58.360] signalConditions() ...
[13:19:58.360]  - include = ‘immediateCondition’
[13:19:58.360]  - exclude = 
[13:19:58.360]  - resignal = FALSE
[13:19:58.360]  - Number of conditions: 2
[13:19:58.360] signalConditions() ... done
[13:19:58.360] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:58.361] result() for ClusterFuture ...
[13:19:58.361] - result already collected: FutureResult
[13:19:58.361] result() for ClusterFuture ... done
[13:19:58.361] result() for ClusterFuture ...
[13:19:58.361] - result already collected: FutureResult
[13:19:58.361] result() for ClusterFuture ... done
[13:19:58.361] signalConditions() ...
[13:19:58.362]  - include = ‘immediateCondition’
[13:19:58.362]  - exclude = 
[13:19:58.362]  - resignal = FALSE
[13:19:58.362]  - Number of conditions: 2
[13:19:58.362] signalConditions() ... done
[13:19:58.363] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[13:19:58.363] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:19:58.364] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:19:58.364] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[13:19:58.364] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[13:19:58.365] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[13:19:58.409] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[13:19:58.409] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[13:19:58.453] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[13:19:58.453] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[13:19:58.454] MultisessionFuture started
[13:19:58.454] - Launch lazy future ... done
[13:19:58.454] run() for ‘MultisessionFuture’ ... done
[13:19:58.454] - run() ... done
[13:19:58.454] - resolved() ...
[13:19:58.465] - resolved: FALSE
[13:19:58.465] - resolved() ... done
[13:19:58.465] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[13:19:58.466] result() for ClusterFuture ...
[13:19:58.466] - result already collected: FutureResult
[13:19:58.466] result() for ClusterFuture ... done
[13:19:58.466] result() for ClusterFuture ...
[13:19:58.466] - result already collected: FutureResult
[13:19:58.466] result() for ClusterFuture ... done
[13:19:58.466] signalConditions() ...
[13:19:58.466]  - include = ‘immediateCondition’
[13:19:58.466]  - exclude = 
[13:19:58.467]  - resignal = FALSE
[13:19:58.467]  - Number of conditions: 2
[13:19:58.467] signalConditions() ... done
[13:19:58.467] Future state: ‘finished’
[13:19:58.467] result() for ClusterFuture ...
[13:19:58.467] - result already collected: FutureResult
[13:19:58.467] result() for ClusterFuture ... done
[13:19:58.467] signalConditions() ...
[13:19:58.467]  - include = ‘condition’
[13:19:58.467]  - exclude = ‘immediateCondition’
[13:19:58.467]  - resignal = TRUE
[13:19:58.468]  - Number of conditions: 2
[13:19:58.468]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[13:19:58.468]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:58.468] signalConditions() ... done
Plotting tile #2 of 4 ...
[13:19:58.471] result() for ClusterFuture ...
[13:19:58.471] - result already collected: FutureResult
[13:19:58.471] result() for ClusterFuture ... done
[13:19:58.471] result() for ClusterFuture ...
[13:19:58.471] - result already collected: FutureResult
[13:19:58.471] result() for ClusterFuture ... done
[13:19:58.471] signalConditions() ...
[13:19:58.471]  - include = ‘immediateCondition’
[13:19:58.472]  - exclude = 
[13:19:58.472]  - resignal = FALSE
[13:19:58.472]  - Number of conditions: 2
[13:19:58.472] signalConditions() ... done
[13:19:58.472] Future state: ‘finished’
[13:19:58.472] result() for ClusterFuture ...
[13:19:58.472] - result already collected: FutureResult
[13:19:58.472] result() for ClusterFuture ... done
[13:19:58.472] signalConditions() ...
[13:19:58.472]  - include = ‘condition’
[13:19:58.473]  - exclude = ‘immediateCondition’
[13:19:58.473]  - resignal = TRUE
[13:19:58.473]  - Number of conditions: 2
[13:19:58.473]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[13:19:58.473]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:58.473] signalConditions() ... done
[13:19:58.474] receiveMessageFromWorker() for ClusterFuture ...
[13:19:58.474] - Validating connection of MultisessionFuture
[13:19:58.475] - received message: FutureResult
[13:19:58.475] - Received FutureResult
[13:19:58.475] - Erased future from FutureRegistry
[13:19:58.475] result() for ClusterFuture ...
[13:19:58.475] - result already collected: FutureResult
[13:19:58.475] result() for ClusterFuture ... done
[13:19:58.475] signalConditions() ...
[13:19:58.475]  - include = ‘immediateCondition’
[13:19:58.475]  - exclude = 
[13:19:58.476]  - resignal = FALSE
[13:19:58.476]  - Number of conditions: 2
[13:19:58.476] signalConditions() ... done
[13:19:58.476] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[13:19:58.476] result() for ClusterFuture ...
[13:19:58.476] - result already collected: FutureResult
[13:19:58.476] result() for ClusterFuture ... done
[13:19:58.476] result() for ClusterFuture ...
[13:19:58.476] - result already collected: FutureResult
[13:19:58.476] result() for ClusterFuture ... done
[13:19:58.476] signalConditions() ...
[13:19:58.477]  - include = ‘immediateCondition’
[13:19:58.477]  - exclude = 
[13:19:58.477]  - resignal = FALSE
[13:19:58.477]  - Number of conditions: 2
[13:19:58.477] signalConditions() ... done
[13:19:58.477] Future state: ‘finished’
[13:19:58.477] result() for ClusterFuture ...
[13:19:58.477] - result already collected: FutureResult
[13:19:58.477] result() for ClusterFuture ... done
[13:19:58.477] signalConditions() ...
[13:19:58.477]  - include = ‘condition’
[13:19:58.478]  - exclude = ‘immediateCondition’
[13:19:58.478]  - resignal = TRUE
[13:19:58.478]  - Number of conditions: 2
[13:19:58.478]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[13:19:58.478]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:58.478] signalConditions() ... done
[13:19:58.517] receiveMessageFromWorker() for ClusterFuture ...
[13:19:58.518] - Validating connection of MultisessionFuture
[13:19:58.518] - received message: FutureResult
[13:19:58.518] - Received FutureResult
[13:19:58.518] - Erased future from FutureRegistry
[13:19:58.519] result() for ClusterFuture ...
[13:19:58.519] - result already collected: FutureResult
[13:19:58.519] result() for ClusterFuture ... done
[13:19:58.519] signalConditions() ...
[13:19:58.519]  - include = ‘immediateCondition’
[13:19:58.519]  - exclude = 
[13:19:58.519]  - resignal = FALSE
[13:19:58.519]  - Number of conditions: 2
[13:19:58.519] signalConditions() ... done
[13:19:58.519] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[13:19:58.520] result() for ClusterFuture ...
[13:19:58.520] - result already collected: FutureResult
[13:19:58.520] result() for ClusterFuture ... done
[13:19:58.520] result() for ClusterFuture ...
[13:19:58.520] - result already collected: FutureResult
[13:19:58.520] result() for ClusterFuture ... done
[13:19:58.520] signalConditions() ...
[13:19:58.520]  - include = ‘immediateCondition’
[13:19:58.520]  - exclude = 
[13:19:58.520]  - resignal = FALSE
[13:19:58.520]  - Number of conditions: 2
[13:19:58.520] signalConditions() ... done
[13:19:58.521] Future state: ‘finished’
[13:19:58.521] result() for ClusterFuture ...
[13:19:58.521] - result already collected: FutureResult
[13:19:58.521] result() for ClusterFuture ... done
[13:19:58.521] signalConditions() ...
[13:19:58.521]  - include = ‘condition’
[13:19:58.521]  - exclude = ‘immediateCondition’
[13:19:58.521]  - resignal = TRUE
[13:19:58.521]  - Number of conditions: 2
[13:19:58.521]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[13:19:58.522]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[13:19:58.522] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[13:19:58.523] plan(): Setting new future strategy stack:
[13:19:58.524] List of future strategies:
[13:19:58.524] 1. sequential:
[13:19:58.524]    - args: function (..., envir = parent.frame())
[13:19:58.524]    - tweaked: FALSE
[13:19:58.524]    - call: future::plan("sequential")
[13:19:58.524] plan(): nbrOfWorkers() = 1
> 
