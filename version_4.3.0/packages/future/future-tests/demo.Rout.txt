
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:41:47.669] plan(): Setting new future strategy stack:
[17:41:47.670] List of future strategies:
[17:41:47.670] 1. sequential:
[17:41:47.670]    - args: function (..., envir = parent.frame())
[17:41:47.670]    - tweaked: FALSE
[17:41:47.670]    - call: future::plan("sequential")
[17:41:47.683] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[17:41:47.699] plan(): Setting new future strategy stack:
[17:41:47.699] List of future strategies:
[17:41:47.699] 1. sequential:
[17:41:47.699]    - args: function (..., envir = parent.frame())
[17:41:47.699]    - tweaked: FALSE
[17:41:47.699]    - call: plan(sequential)
[17:41:47.710] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[17:41:47.719] getGlobalsAndPackages() ...
[17:41:47.719] Searching for globals...
[17:41:47.726] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.726] Searching for globals ... DONE
[17:41:47.726] Resolving globals: FALSE
[17:41:47.728] The total size of the 2 globals is 224 bytes (224 bytes)
[17:41:47.728] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 224 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (168 bytes of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.728] - globals: [2] ‘x’, ‘i’
[17:41:47.728] 
[17:41:47.728] getGlobalsAndPackages() ... DONE
[17:41:47.729] getGlobalsAndPackages() ...
[17:41:47.729] Searching for globals...
[17:41:47.731] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.731] Searching for globals ... DONE
[17:41:47.731] Resolving globals: FALSE
[17:41:47.732] The total size of the 2 globals is 8.41 KiB (8608 bytes)
[17:41:47.732] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 8.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (8.35 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.732] - globals: [2] ‘x’, ‘i’
[17:41:47.732] 
[17:41:47.733] getGlobalsAndPackages() ... DONE
[17:41:47.733] getGlobalsAndPackages() ...
[17:41:47.733] Searching for globals...
[17:41:47.735] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.735] Searching for globals ... DONE
[17:41:47.735] Resolving globals: FALSE
[17:41:47.736] The total size of the 2 globals is 16.76 KiB (17160 bytes)
[17:41:47.736] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 16.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (16.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.736] - globals: [2] ‘x’, ‘i’
[17:41:47.737] 
[17:41:47.737] getGlobalsAndPackages() ... DONE
[17:41:47.737] getGlobalsAndPackages() ...
[17:41:47.737] Searching for globals...
[17:41:47.739] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.739] Searching for globals ... DONE
[17:41:47.739] Resolving globals: FALSE
[17:41:47.740] The total size of the 2 globals is 25.11 KiB (25712 bytes)
[17:41:47.741] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 25.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (25.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.741] - globals: [2] ‘x’, ‘i’
[17:41:47.741] 
[17:41:47.741] getGlobalsAndPackages() ... DONE
[17:41:47.741] getGlobalsAndPackages() ...
[17:41:47.742] Searching for globals...
[17:41:47.743] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.743] Searching for globals ... DONE
[17:41:47.743] Resolving globals: FALSE
[17:41:47.747] The total size of the 2 globals is 33.46 KiB (34264 bytes)
[17:41:47.747] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.747] - globals: [2] ‘x’, ‘i’
[17:41:47.748] 
[17:41:47.748] getGlobalsAndPackages() ... DONE
[17:41:47.748] getGlobalsAndPackages() ...
[17:41:47.748] Searching for globals...
[17:41:47.750] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.750] Searching for globals ... DONE
[17:41:47.750] Resolving globals: FALSE
[17:41:47.752] The total size of the 2 globals is 41.81 KiB (42816 bytes)
[17:41:47.752] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 41.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (41.76 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.752] - globals: [2] ‘x’, ‘i’
[17:41:47.752] 
[17:41:47.752] getGlobalsAndPackages() ... DONE
[17:41:47.753] getGlobalsAndPackages() ...
[17:41:47.753] Searching for globals...
[17:41:47.754] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.755] Searching for globals ... DONE
[17:41:47.755] Resolving globals: FALSE
[17:41:47.757] The total size of the 2 globals is 50.16 KiB (51368 bytes)
[17:41:47.757] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 50.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (50.11 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.757] - globals: [2] ‘x’, ‘i’
[17:41:47.757] 
[17:41:47.757] getGlobalsAndPackages() ... DONE
[17:41:47.758] getGlobalsAndPackages() ...
[17:41:47.758] Searching for globals...
[17:41:47.759] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.760] Searching for globals ... DONE
[17:41:47.760] Resolving globals: FALSE
[17:41:47.762] The total size of the 2 globals is 58.52 KiB (59920 bytes)
[17:41:47.762] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 58.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (58.46 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.762] - globals: [2] ‘x’, ‘i’
[17:41:47.763] 
[17:41:47.763] getGlobalsAndPackages() ... DONE
[17:41:47.763] getGlobalsAndPackages() ...
[17:41:47.763] Searching for globals...
[17:41:47.765] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.765] Searching for globals ... DONE
[17:41:47.765] Resolving globals: FALSE
[17:41:47.769] The total size of the 2 globals is 66.87 KiB (68472 bytes)
[17:41:47.769] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 66.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (66.81 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.770] - globals: [2] ‘x’, ‘i’
[17:41:47.770] 
[17:41:47.770] getGlobalsAndPackages() ... DONE
[17:41:47.770] getGlobalsAndPackages() ...
[17:41:47.770] Searching for globals...
[17:41:47.772] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.772] Searching for globals ... DONE
[17:41:47.772] Resolving globals: FALSE
[17:41:47.775] The total size of the 2 globals is 75.22 KiB (77024 bytes)
[17:41:47.776] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 75.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (75.16 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.776] - globals: [2] ‘x’, ‘i’
[17:41:47.776] 
[17:41:47.776] getGlobalsAndPackages() ... DONE
[17:41:47.777] getGlobalsAndPackages() ...
[17:41:47.777] Searching for globals...
[17:41:47.778] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.778] Searching for globals ... DONE
[17:41:47.778] Resolving globals: FALSE
[17:41:47.781] The total size of the 2 globals is 83.57 KiB (85576 bytes)
[17:41:47.782] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 83.57 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (83.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.782] - globals: [2] ‘x’, ‘i’
[17:41:47.782] 
[17:41:47.782] getGlobalsAndPackages() ... DONE
[17:41:47.783] getGlobalsAndPackages() ...
[17:41:47.783] Searching for globals...
[17:41:47.784] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.784] Searching for globals ... DONE
[17:41:47.784] Resolving globals: FALSE
[17:41:47.788] The total size of the 2 globals is 91.92 KiB (94128 bytes)
[17:41:47.788] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 91.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (91.87 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.788] - globals: [2] ‘x’, ‘i’
[17:41:47.790] 
[17:41:47.790] getGlobalsAndPackages() ... DONE
[17:41:47.791] getGlobalsAndPackages() ...
[17:41:47.791] Searching for globals...
[17:41:47.792] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.792] Searching for globals ... DONE
[17:41:47.792] Resolving globals: FALSE
[17:41:47.796] The total size of the 2 globals is 100.27 KiB (102680 bytes)
[17:41:47.796] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 100.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (100.22 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.797] - globals: [2] ‘x’, ‘i’
[17:41:47.797] 
[17:41:47.797] getGlobalsAndPackages() ... DONE
[17:41:47.797] getGlobalsAndPackages() ...
[17:41:47.797] Searching for globals...
[17:41:47.799] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.799] Searching for globals ... DONE
[17:41:47.799] Resolving globals: FALSE
[17:41:47.803] The total size of the 2 globals is 108.62 KiB (111232 bytes)
[17:41:47.803] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 108.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (108.57 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.804] - globals: [2] ‘x’, ‘i’
[17:41:47.804] 
[17:41:47.804] getGlobalsAndPackages() ... DONE
[17:41:47.804] getGlobalsAndPackages() ...
[17:41:47.804] Searching for globals...
[17:41:47.806] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.806] Searching for globals ... DONE
[17:41:47.806] Resolving globals: FALSE
[17:41:47.812] The total size of the 2 globals is 116.98 KiB (119784 bytes)
[17:41:47.813] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 116.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (116.92 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.813] - globals: [2] ‘x’, ‘i’
[17:41:47.813] 
[17:41:47.813] getGlobalsAndPackages() ... DONE
[17:41:47.813] getGlobalsAndPackages() ...
[17:41:47.813] Searching for globals...
[17:41:47.815] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.815] Searching for globals ... DONE
[17:41:47.815] Resolving globals: FALSE
[17:41:47.820] The total size of the 2 globals is 125.33 KiB (128336 bytes)
[17:41:47.820] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 125.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (125.27 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.820] - globals: [2] ‘x’, ‘i’
[17:41:47.820] 
[17:41:47.820] getGlobalsAndPackages() ... DONE
[17:41:47.821] getGlobalsAndPackages() ...
[17:41:47.821] Searching for globals...
[17:41:47.822] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.823] Searching for globals ... DONE
[17:41:47.823] Resolving globals: FALSE
[17:41:47.827] The total size of the 2 globals is 133.68 KiB (136888 bytes)
[17:41:47.828] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 133.68 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133.62 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.828] - globals: [2] ‘x’, ‘i’
[17:41:47.828] 
[17:41:47.828] getGlobalsAndPackages() ... DONE
[17:41:47.828] getGlobalsAndPackages() ...
[17:41:47.828] Searching for globals...
[17:41:47.831] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.831] Searching for globals ... DONE
[17:41:47.832] Resolving globals: FALSE
[17:41:47.836] The total size of the 2 globals is 142.03 KiB (145440 bytes)
[17:41:47.837] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 142.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (141.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.837] - globals: [2] ‘x’, ‘i’
[17:41:47.837] 
[17:41:47.837] getGlobalsAndPackages() ... DONE
[17:41:47.838] getGlobalsAndPackages() ...
[17:41:47.838] Searching for globals...
[17:41:47.839] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.839] Searching for globals ... DONE
[17:41:47.840] Resolving globals: FALSE
[17:41:47.845] The total size of the 2 globals is 150.38 KiB (153992 bytes)
[17:41:47.845] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 150.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (150.33 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.845] - globals: [2] ‘x’, ‘i’
[17:41:47.845] 
[17:41:47.846] getGlobalsAndPackages() ... DONE
[17:41:47.846] getGlobalsAndPackages() ...
[17:41:47.846] Searching for globals...
[17:41:47.848] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.848] Searching for globals ... DONE
[17:41:47.848] Resolving globals: FALSE
[17:41:47.855] The total size of the 2 globals is 158.73 KiB (162544 bytes)
[17:41:47.855] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 158.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (158.68 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.856] - globals: [2] ‘x’, ‘i’
[17:41:47.856] 
[17:41:47.856] getGlobalsAndPackages() ... DONE
[17:41:47.856] getGlobalsAndPackages() ...
[17:41:47.856] Searching for globals...
[17:41:47.858] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.858] Searching for globals ... DONE
[17:41:47.858] Resolving globals: FALSE
[17:41:47.864] The total size of the 2 globals is 167.09 KiB (171096 bytes)
[17:41:47.864] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 167.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (167.03 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.864] - globals: [2] ‘x’, ‘i’
[17:41:47.864] 
[17:41:47.864] getGlobalsAndPackages() ... DONE
[17:41:47.865] getGlobalsAndPackages() ...
[17:41:47.865] Searching for globals...
[17:41:47.866] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.867] Searching for globals ... DONE
[17:41:47.867] Resolving globals: FALSE
[17:41:47.874] The total size of the 2 globals is 175.44 KiB (179648 bytes)
[17:41:47.875] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 175.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (175.38 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.875] - globals: [2] ‘x’, ‘i’
[17:41:47.875] 
[17:41:47.875] getGlobalsAndPackages() ... DONE
[17:41:47.876] getGlobalsAndPackages() ...
[17:41:47.876] Searching for globals...
[17:41:47.878] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.878] Searching for globals ... DONE
[17:41:47.878] Resolving globals: FALSE
[17:41:47.884] The total size of the 2 globals is 183.79 KiB (188200 bytes)
[17:41:47.885] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 183.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (183.73 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.885] - globals: [2] ‘x’, ‘i’
[17:41:47.885] 
[17:41:47.885] getGlobalsAndPackages() ... DONE
[17:41:47.886] getGlobalsAndPackages() ...
[17:41:47.886] Searching for globals...
[17:41:47.887] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.887] Searching for globals ... DONE
[17:41:47.887] Resolving globals: FALSE
[17:41:47.896] The total size of the 2 globals is 192.14 KiB (196752 bytes)
[17:41:47.896] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 192.14 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (192.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.896] - globals: [2] ‘x’, ‘i’
[17:41:47.896] 
[17:41:47.896] getGlobalsAndPackages() ... DONE
[17:41:47.897] getGlobalsAndPackages() ...
[17:41:47.897] Searching for globals...
[17:41:47.898] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.899] Searching for globals ... DONE
[17:41:47.899] Resolving globals: FALSE
[17:41:47.905] The total size of the 2 globals is 200.49 KiB (205304 bytes)
[17:41:47.906] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 200.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (200.44 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.906] - globals: [2] ‘x’, ‘i’
[17:41:47.906] 
[17:41:47.906] getGlobalsAndPackages() ... DONE
[17:41:47.909] getGlobalsAndPackages() ...
[17:41:47.909] Searching for globals...
[17:41:47.910] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.911] Searching for globals ... DONE
[17:41:47.911] Resolving globals: FALSE
[17:41:47.918] The total size of the 2 globals is 208.84 KiB (213856 bytes)
[17:41:47.918] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 208.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (208.79 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.919] - globals: [2] ‘x’, ‘i’
[17:41:47.919] 
[17:41:47.919] getGlobalsAndPackages() ... DONE
[17:41:47.919] getGlobalsAndPackages() ...
[17:41:47.920] Searching for globals...
[17:41:47.921] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.921] Searching for globals ... DONE
[17:41:47.921] Resolving globals: FALSE
[17:41:47.930] The total size of the 2 globals is 217.20 KiB (222408 bytes)
[17:41:47.931] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 217.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (217.14 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.931] - globals: [2] ‘x’, ‘i’
[17:41:47.931] 
[17:41:47.931] getGlobalsAndPackages() ... DONE
[17:41:47.932] getGlobalsAndPackages() ...
[17:41:47.932] Searching for globals...
[17:41:47.933] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.933] Searching for globals ... DONE
[17:41:47.934] Resolving globals: FALSE
[17:41:47.941] The total size of the 2 globals is 225.55 KiB (230960 bytes)
[17:41:47.942] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 225.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (225.49 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.942] - globals: [2] ‘x’, ‘i’
[17:41:47.942] 
[17:41:47.942] getGlobalsAndPackages() ... DONE
[17:41:47.943] getGlobalsAndPackages() ...
[17:41:47.943] Searching for globals...
[17:41:47.945] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.945] Searching for globals ... DONE
[17:41:47.945] Resolving globals: FALSE
[17:41:47.955] The total size of the 2 globals is 233.90 KiB (239512 bytes)
[17:41:47.955] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 233.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (233.84 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.955] - globals: [2] ‘x’, ‘i’
[17:41:47.955] 
[17:41:47.955] getGlobalsAndPackages() ... DONE
[17:41:47.956] getGlobalsAndPackages() ...
[17:41:47.956] Searching for globals...
[17:41:47.958] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.958] Searching for globals ... DONE
[17:41:47.958] Resolving globals: FALSE
[17:41:47.968] The total size of the 2 globals is 242.25 KiB (248064 bytes)
[17:41:47.968] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.968] - globals: [2] ‘x’, ‘i’
[17:41:47.968] 
[17:41:47.969] getGlobalsAndPackages() ... DONE
[17:41:47.969] getGlobalsAndPackages() ...
[17:41:47.969] Searching for globals...
[17:41:47.971] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.971] Searching for globals ... DONE
[17:41:47.971] Resolving globals: FALSE
[17:41:47.979] The total size of the 2 globals is 250.60 KiB (256616 bytes)
[17:41:47.980] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 250.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (250.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.980] - globals: [2] ‘x’, ‘i’
[17:41:47.980] 
[17:41:47.980] getGlobalsAndPackages() ... DONE
[17:41:47.981] getGlobalsAndPackages() ...
[17:41:47.981] Searching for globals...
[17:41:47.984] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.984] Searching for globals ... DONE
[17:41:47.984] Resolving globals: FALSE
[17:41:47.993] The total size of the 2 globals is 258.95 KiB (265168 bytes)
[17:41:47.993] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 258.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (258.90 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:47.993] - globals: [2] ‘x’, ‘i’
[17:41:47.993] 
[17:41:47.993] getGlobalsAndPackages() ... DONE
[17:41:47.994] getGlobalsAndPackages() ...
[17:41:47.994] Searching for globals...
[17:41:47.995] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:47.996] Searching for globals ... DONE
[17:41:47.996] Resolving globals: FALSE
[17:41:48.007] The total size of the 2 globals is 267.30 KiB (273720 bytes)
[17:41:48.007] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 267.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (267.25 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.007] - globals: [2] ‘x’, ‘i’
[17:41:48.007] 
[17:41:48.007] getGlobalsAndPackages() ... DONE
[17:41:48.008] getGlobalsAndPackages() ...
[17:41:48.008] Searching for globals...
[17:41:48.010] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.010] Searching for globals ... DONE
[17:41:48.010] Resolving globals: FALSE
[17:41:48.021] The total size of the 2 globals is 275.66 KiB (282272 bytes)
[17:41:48.021] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 275.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (275.60 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.022] - globals: [2] ‘x’, ‘i’
[17:41:48.022] 
[17:41:48.022] getGlobalsAndPackages() ... DONE
[17:41:48.022] getGlobalsAndPackages() ...
[17:41:48.022] Searching for globals...
[17:41:48.024] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.024] Searching for globals ... DONE
[17:41:48.024] Resolving globals: FALSE
[17:41:48.034] The total size of the 2 globals is 284.01 KiB (290824 bytes)
[17:41:48.035] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 284.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (283.95 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.035] - globals: [2] ‘x’, ‘i’
[17:41:48.035] 
[17:41:48.035] getGlobalsAndPackages() ... DONE
[17:41:48.036] getGlobalsAndPackages() ...
[17:41:48.036] Searching for globals...
[17:41:48.040] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.040] Searching for globals ... DONE
[17:41:48.040] Resolving globals: FALSE
[17:41:48.050] The total size of the 2 globals is 292.36 KiB (299376 bytes)
[17:41:48.051] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 292.36 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (292.30 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.051] - globals: [2] ‘x’, ‘i’
[17:41:48.051] 
[17:41:48.051] getGlobalsAndPackages() ... DONE
[17:41:48.052] getGlobalsAndPackages() ...
[17:41:48.052] Searching for globals...
[17:41:48.053] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.054] Searching for globals ... DONE
[17:41:48.054] Resolving globals: FALSE
[17:41:48.066] The total size of the 2 globals is 300.71 KiB (307928 bytes)
[17:41:48.067] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 300.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (300.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.067] - globals: [2] ‘x’, ‘i’
[17:41:48.067] 
[17:41:48.067] getGlobalsAndPackages() ... DONE
[17:41:48.068] getGlobalsAndPackages() ...
[17:41:48.068] Searching for globals...
[17:41:48.070] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.070] Searching for globals ... DONE
[17:41:48.070] Resolving globals: FALSE
[17:41:48.112] The total size of the 2 globals is 309.06 KiB (316480 bytes)
[17:41:48.112] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 309.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (309.01 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.112] - globals: [2] ‘x’, ‘i’
[17:41:48.112] 
[17:41:48.113] getGlobalsAndPackages() ... DONE
[17:41:48.113] getGlobalsAndPackages() ...
[17:41:48.113] Searching for globals...
[17:41:48.115] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.115] Searching for globals ... DONE
[17:41:48.115] Resolving globals: FALSE
[17:41:48.128] The total size of the 2 globals is 317.41 KiB (325032 bytes)
[17:41:48.129] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 317.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (317.36 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.129] - globals: [2] ‘x’, ‘i’
[17:41:48.129] 
[17:41:48.129] getGlobalsAndPackages() ... DONE
[17:41:48.130] getGlobalsAndPackages() ...
[17:41:48.130] Searching for globals...
[17:41:48.132] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.132] Searching for globals ... DONE
[17:41:48.132] Resolving globals: FALSE
[17:41:48.146] The total size of the 2 globals is 325.77 KiB (333584 bytes)
[17:41:48.146] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 325.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (325.71 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.146] - globals: [2] ‘x’, ‘i’
[17:41:48.146] 
[17:41:48.146] getGlobalsAndPackages() ... DONE
[17:41:48.147] getGlobalsAndPackages() ...
[17:41:48.147] Searching for globals...
[17:41:48.149] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.149] Searching for globals ... DONE
[17:41:48.149] Resolving globals: FALSE
[17:41:48.161] The total size of the 2 globals is 334.12 KiB (342136 bytes)
[17:41:48.162] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 334.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (334.06 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.162] - globals: [2] ‘x’, ‘i’
[17:41:48.163] 
[17:41:48.163] getGlobalsAndPackages() ... DONE
[17:41:48.164] getGlobalsAndPackages() ...
[17:41:48.164] Searching for globals...
[17:41:48.166] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.166] Searching for globals ... DONE
[17:41:48.167] Resolving globals: FALSE
[17:41:48.179] The total size of the 2 globals is 342.47 KiB (350688 bytes)
[17:41:48.179] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 342.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (342.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.179] - globals: [2] ‘x’, ‘i’
[17:41:48.179] 
[17:41:48.180] getGlobalsAndPackages() ... DONE
[17:41:48.180] getGlobalsAndPackages() ...
[17:41:48.180] Searching for globals...
[17:41:48.184] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.184] Searching for globals ... DONE
[17:41:48.185] Resolving globals: FALSE
[17:41:48.197] The total size of the 2 globals is 350.82 KiB (359240 bytes)
[17:41:48.198] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 350.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (350.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.198] - globals: [2] ‘x’, ‘i’
[17:41:48.198] 
[17:41:48.198] getGlobalsAndPackages() ... DONE
[17:41:48.199] getGlobalsAndPackages() ...
[17:41:48.199] Searching for globals...
[17:41:48.201] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.201] Searching for globals ... DONE
[17:41:48.201] Resolving globals: FALSE
[17:41:48.217] The total size of the 2 globals is 359.17 KiB (367792 bytes)
[17:41:48.217] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 359.17 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (359.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.217] - globals: [2] ‘x’, ‘i’
[17:41:48.218] 
[17:41:48.218] getGlobalsAndPackages() ... DONE
[17:41:48.218] getGlobalsAndPackages() ...
[17:41:48.218] Searching for globals...
[17:41:48.220] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.220] Searching for globals ... DONE
[17:41:48.220] Resolving globals: FALSE
[17:41:48.235] The total size of the 2 globals is 367.52 KiB (376344 bytes)
[17:41:48.236] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 367.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (367.47 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.236] - globals: [2] ‘x’, ‘i’
[17:41:48.236] 
[17:41:48.236] getGlobalsAndPackages() ... DONE
[17:41:48.237] getGlobalsAndPackages() ...
[17:41:48.237] Searching for globals...
[17:41:48.239] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.239] Searching for globals ... DONE
[17:41:48.239] Resolving globals: FALSE
[17:41:48.254] The total size of the 2 globals is 375.88 KiB (384896 bytes)
[17:41:48.255] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 375.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (375.82 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.255] - globals: [2] ‘x’, ‘i’
[17:41:48.255] 
[17:41:48.255] getGlobalsAndPackages() ... DONE
[17:41:48.256] getGlobalsAndPackages() ...
[17:41:48.256] Searching for globals...
[17:41:48.257] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.257] Searching for globals ... DONE
[17:41:48.257] Resolving globals: FALSE
[17:41:48.273] The total size of the 2 globals is 384.23 KiB (393448 bytes)
[17:41:48.273] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 384.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (384.17 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.273] - globals: [2] ‘x’, ‘i’
[17:41:48.273] 
[17:41:48.273] getGlobalsAndPackages() ... DONE
[17:41:48.274] getGlobalsAndPackages() ...
[17:41:48.274] Searching for globals...
[17:41:48.276] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.276] Searching for globals ... DONE
[17:41:48.276] Resolving globals: FALSE
[17:41:48.292] The total size of the 2 globals is 392.58 KiB (402000 bytes)
[17:41:48.292] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 392.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (392.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.292] - globals: [2] ‘x’, ‘i’
[17:41:48.293] 
[17:41:48.293] getGlobalsAndPackages() ... DONE
[17:41:48.293] getGlobalsAndPackages() ...
[17:41:48.293] Searching for globals...
[17:41:48.295] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.295] Searching for globals ... DONE
[17:41:48.295] Resolving globals: FALSE
[17:41:48.311] The total size of the 2 globals is 400.93 KiB (410552 bytes)
[17:41:48.312] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 400.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (400.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.312] - globals: [2] ‘x’, ‘i’
[17:41:48.312] 
[17:41:48.312] getGlobalsAndPackages() ... DONE
[17:41:48.313] getGlobalsAndPackages() ...
[17:41:48.313] Searching for globals...
[17:41:48.315] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.316] Searching for globals ... DONE
[17:41:48.316] Resolving globals: FALSE
[17:41:48.331] The total size of the 2 globals is 409.28 KiB (419104 bytes)
[17:41:48.331] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 409.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (409.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.331] - globals: [2] ‘x’, ‘i’
[17:41:48.332] 
[17:41:48.332] getGlobalsAndPackages() ... DONE
[17:41:48.334] getGlobalsAndPackages() ...
[17:41:48.334] Searching for globals...
[17:41:48.336] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.336] Searching for globals ... DONE
[17:41:48.336] Resolving globals: FALSE
[17:41:48.353] The total size of the 2 globals is 417.63 KiB (427656 bytes)
[17:41:48.353] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 417.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (417.58 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.353] - globals: [2] ‘x’, ‘i’
[17:41:48.353] 
[17:41:48.353] getGlobalsAndPackages() ... DONE
[17:41:48.354] getGlobalsAndPackages() ...
[17:41:48.354] Searching for globals...
[17:41:48.356] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.356] Searching for globals ... DONE
[17:41:48.356] Resolving globals: FALSE
[17:41:48.373] The total size of the 2 globals is 425.98 KiB (436208 bytes)
[17:41:48.374] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 425.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (425.93 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.374] - globals: [2] ‘x’, ‘i’
[17:41:48.374] 
[17:41:48.374] getGlobalsAndPackages() ... DONE
[17:41:48.375] getGlobalsAndPackages() ...
[17:41:48.375] Searching for globals...
[17:41:48.376] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.376] Searching for globals ... DONE
[17:41:48.377] Resolving globals: FALSE
[17:41:48.393] The total size of the 2 globals is 434.34 KiB (444760 bytes)
[17:41:48.394] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 434.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (434.28 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.394] - globals: [2] ‘x’, ‘i’
[17:41:48.394] 
[17:41:48.394] getGlobalsAndPackages() ... DONE
[17:41:48.395] getGlobalsAndPackages() ...
[17:41:48.395] Searching for globals...
[17:41:48.396] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.396] Searching for globals ... DONE
[17:41:48.397] Resolving globals: FALSE
[17:41:48.414] The total size of the 2 globals is 442.69 KiB (453312 bytes)
[17:41:48.415] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 442.69 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (442.63 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.415] - globals: [2] ‘x’, ‘i’
[17:41:48.415] 
[17:41:48.415] getGlobalsAndPackages() ... DONE
[17:41:48.416] getGlobalsAndPackages() ...
[17:41:48.416] Searching for globals...
[17:41:48.417] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.418] Searching for globals ... DONE
[17:41:48.418] Resolving globals: FALSE
[17:41:48.434] The total size of the 2 globals is 451.04 KiB (461864 bytes)
[17:41:48.435] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 451.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (450.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.435] - globals: [2] ‘x’, ‘i’
[17:41:48.435] 
[17:41:48.435] getGlobalsAndPackages() ... DONE
[17:41:48.436] getGlobalsAndPackages() ...
[17:41:48.436] Searching for globals...
[17:41:48.438] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.438] Searching for globals ... DONE
[17:41:48.438] Resolving globals: FALSE
[17:41:48.456] The total size of the 2 globals is 459.39 KiB (470416 bytes)
[17:41:48.456] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 459.39 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (459.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.457] - globals: [2] ‘x’, ‘i’
[17:41:48.457] 
[17:41:48.457] getGlobalsAndPackages() ... DONE
[17:41:48.458] getGlobalsAndPackages() ...
[17:41:48.458] Searching for globals...
[17:41:48.459] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.460] Searching for globals ... DONE
[17:41:48.460] Resolving globals: FALSE
[17:41:48.478] The total size of the 2 globals is 467.74 KiB (478968 bytes)
[17:41:48.479] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 467.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (467.69 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.479] - globals: [2] ‘x’, ‘i’
[17:41:48.479] 
[17:41:48.479] getGlobalsAndPackages() ... DONE
[17:41:48.479] getGlobalsAndPackages() ...
[17:41:48.480] Searching for globals...
[17:41:48.481] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.481] Searching for globals ... DONE
[17:41:48.481] Resolving globals: FALSE
[17:41:48.501] The total size of the 2 globals is 476.09 KiB (487520 bytes)
[17:41:48.502] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 476.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (476.04 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.502] - globals: [2] ‘x’, ‘i’
[17:41:48.502] 
[17:41:48.502] getGlobalsAndPackages() ... DONE
[17:41:48.503] getGlobalsAndPackages() ...
[17:41:48.503] Searching for globals...
[17:41:48.504] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.505] Searching for globals ... DONE
[17:41:48.505] Resolving globals: FALSE
[17:41:48.524] The total size of the 2 globals is 484.45 KiB (496072 bytes)
[17:41:48.524] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 484.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (484.39 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.524] - globals: [2] ‘x’, ‘i’
[17:41:48.524] 
[17:41:48.524] getGlobalsAndPackages() ... DONE
[17:41:48.525] getGlobalsAndPackages() ...
[17:41:48.525] Searching for globals...
[17:41:48.528] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.528] Searching for globals ... DONE
[17:41:48.528] Resolving globals: FALSE
[17:41:48.547] The total size of the 2 globals is 492.80 KiB (504624 bytes)
[17:41:48.547] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 492.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (492.74 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.547] - globals: [2] ‘x’, ‘i’
[17:41:48.547] 
[17:41:48.548] getGlobalsAndPackages() ... DONE
[17:41:48.548] getGlobalsAndPackages() ...
[17:41:48.548] Searching for globals...
[17:41:48.550] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.550] Searching for globals ... DONE
[17:41:48.550] Resolving globals: FALSE
[17:41:48.569] The total size of the 2 globals is 501.15 KiB (513176 bytes)
[17:41:48.570] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 501.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (501.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.570] - globals: [2] ‘x’, ‘i’
[17:41:48.570] 
[17:41:48.570] getGlobalsAndPackages() ... DONE
[17:41:48.571] getGlobalsAndPackages() ...
[17:41:48.571] Searching for globals...
[17:41:48.572] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.573] Searching for globals ... DONE
[17:41:48.573] Resolving globals: FALSE
[17:41:48.592] The total size of the 2 globals is 509.50 KiB (521728 bytes)
[17:41:48.592] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.45 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.592] - globals: [2] ‘x’, ‘i’
[17:41:48.592] 
[17:41:48.593] getGlobalsAndPackages() ... DONE
[17:41:48.594] getGlobalsAndPackages() ...
[17:41:48.594] Searching for globals...
[17:41:48.596] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.596] Searching for globals ... DONE
[17:41:48.596] Resolving globals: FALSE
[17:41:48.617] The total size of the 2 globals is 517.85 KiB (530280 bytes)
[17:41:48.618] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 517.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (517.80 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.618] - globals: [2] ‘x’, ‘i’
[17:41:48.618] 
[17:41:48.618] getGlobalsAndPackages() ... DONE
[17:41:48.619] getGlobalsAndPackages() ...
[17:41:48.619] Searching for globals...
[17:41:48.620] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.621] Searching for globals ... DONE
[17:41:48.621] Resolving globals: FALSE
[17:41:48.640] The total size of the 2 globals is 526.20 KiB (538832 bytes)
[17:41:48.641] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 526.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (526.15 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.641] - globals: [2] ‘x’, ‘i’
[17:41:48.641] 
[17:41:48.641] getGlobalsAndPackages() ... DONE
[17:41:48.642] getGlobalsAndPackages() ...
[17:41:48.642] Searching for globals...
[17:41:48.644] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.644] Searching for globals ... DONE
[17:41:48.644] Resolving globals: FALSE
[17:41:48.667] The total size of the 2 globals is 534.55 KiB (547384 bytes)
[17:41:48.667] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 534.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (534.50 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.668] - globals: [2] ‘x’, ‘i’
[17:41:48.668] 
[17:41:48.668] getGlobalsAndPackages() ... DONE
[17:41:48.668] getGlobalsAndPackages() ...
[17:41:48.669] Searching for globals...
[17:41:48.670] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.670] Searching for globals ... DONE
[17:41:48.671] Resolving globals: FALSE
[17:41:48.692] The total size of the 2 globals is 542.91 KiB (555936 bytes)
[17:41:48.692] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 542.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (542.85 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.692] - globals: [2] ‘x’, ‘i’
[17:41:48.693] 
[17:41:48.693] getGlobalsAndPackages() ... DONE
[17:41:48.693] getGlobalsAndPackages() ...
[17:41:48.693] Searching for globals...
[17:41:48.695] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.695] Searching for globals ... DONE
[17:41:48.695] Resolving globals: FALSE
[17:41:48.718] The total size of the 2 globals is 551.26 KiB (564488 bytes)
[17:41:48.719] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 551.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (551.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.719] - globals: [2] ‘x’, ‘i’
[17:41:48.719] 
[17:41:48.719] getGlobalsAndPackages() ... DONE
[17:41:48.720] getGlobalsAndPackages() ...
[17:41:48.720] Searching for globals...
[17:41:48.722] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.722] Searching for globals ... DONE
[17:41:48.722] Resolving globals: FALSE
[17:41:48.744] The total size of the 2 globals is 559.61 KiB (573040 bytes)
[17:41:48.745] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 559.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (559.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.745] - globals: [2] ‘x’, ‘i’
[17:41:48.745] 
[17:41:48.745] getGlobalsAndPackages() ... DONE
[17:41:48.746] getGlobalsAndPackages() ...
[17:41:48.746] Searching for globals...
[17:41:48.747] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.747] Searching for globals ... DONE
[17:41:48.748] Resolving globals: FALSE
[17:41:48.772] The total size of the 2 globals is 567.96 KiB (581592 bytes)
[17:41:48.773] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 567.96 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (567.91 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.773] - globals: [2] ‘x’, ‘i’
[17:41:48.773] 
[17:41:48.773] getGlobalsAndPackages() ... DONE
[17:41:48.774] getGlobalsAndPackages() ...
[17:41:48.774] Searching for globals...
[17:41:48.776] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.776] Searching for globals ... DONE
[17:41:48.776] Resolving globals: FALSE
[17:41:48.798] The total size of the 2 globals is 576.31 KiB (590144 bytes)
[17:41:48.799] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 576.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (576.26 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.799] - globals: [2] ‘x’, ‘i’
[17:41:48.799] 
[17:41:48.799] getGlobalsAndPackages() ... DONE
[17:41:48.802] getGlobalsAndPackages() ...
[17:41:48.802] Searching for globals...
[17:41:48.804] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.805] Searching for globals ... DONE
[17:41:48.805] Resolving globals: FALSE
[17:41:48.828] The total size of the 2 globals is 584.66 KiB (598696 bytes)
[17:41:48.829] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 584.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (584.61 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.829] - globals: [2] ‘x’, ‘i’
[17:41:48.829] 
[17:41:48.829] getGlobalsAndPackages() ... DONE
[17:41:48.830] getGlobalsAndPackages() ...
[17:41:48.830] Searching for globals...
[17:41:48.832] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.832] Searching for globals ... DONE
[17:41:48.832] Resolving globals: FALSE
[17:41:48.859] The total size of the 2 globals is 593.02 KiB (607248 bytes)
[17:41:48.859] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 593.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (592.96 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.860] - globals: [2] ‘x’, ‘i’
[17:41:48.860] 
[17:41:48.860] getGlobalsAndPackages() ... DONE
[17:41:48.860] getGlobalsAndPackages() ...
[17:41:48.860] Searching for globals...
[17:41:48.862] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.862] Searching for globals ... DONE
[17:41:48.862] Resolving globals: FALSE
[17:41:48.886] The total size of the 2 globals is 601.37 KiB (615800 bytes)
[17:41:48.887] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 601.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (601.31 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.887] - globals: [2] ‘x’, ‘i’
[17:41:48.887] 
[17:41:48.887] getGlobalsAndPackages() ... DONE
[17:41:48.888] getGlobalsAndPackages() ...
[17:41:48.888] Searching for globals...
[17:41:48.891] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.892] Searching for globals ... DONE
[17:41:48.892] Resolving globals: FALSE
[17:41:48.915] The total size of the 2 globals is 609.72 KiB (624352 bytes)
[17:41:48.916] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 609.72 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (609.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.916] - globals: [2] ‘x’, ‘i’
[17:41:48.916] 
[17:41:48.916] getGlobalsAndPackages() ... DONE
[17:41:48.917] getGlobalsAndPackages() ...
[17:41:48.917] Searching for globals...
[17:41:48.919] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.919] Searching for globals ... DONE
[17:41:48.919] Resolving globals: FALSE
[17:41:48.946] The total size of the 2 globals is 618.07 KiB (632904 bytes)
[17:41:48.947] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 618.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (618.02 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.947] - globals: [2] ‘x’, ‘i’
[17:41:48.947] 
[17:41:48.947] getGlobalsAndPackages() ... DONE
[17:41:48.948] getGlobalsAndPackages() ...
[17:41:48.948] Searching for globals...
[17:41:48.949] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.950] Searching for globals ... DONE
[17:41:48.950] Resolving globals: FALSE
[17:41:48.976] The total size of the 2 globals is 626.42 KiB (641456 bytes)
[17:41:48.977] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 626.42 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (626.37 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:48.977] - globals: [2] ‘x’, ‘i’
[17:41:48.977] 
[17:41:48.977] getGlobalsAndPackages() ... DONE
[17:41:48.978] getGlobalsAndPackages() ...
[17:41:48.978] Searching for globals...
[17:41:48.980] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:48.980] Searching for globals ... DONE
[17:41:48.980] Resolving globals: FALSE
[17:41:49.005] The total size of the 2 globals is 634.77 KiB (650008 bytes)
[17:41:49.005] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 634.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (634.72 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.005] - globals: [2] ‘x’, ‘i’
[17:41:49.006] 
[17:41:49.006] getGlobalsAndPackages() ... DONE
[17:41:49.006] getGlobalsAndPackages() ...
[17:41:49.007] Searching for globals...
[17:41:49.008] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.008] Searching for globals ... DONE
[17:41:49.008] Resolving globals: FALSE
[17:41:49.036] The total size of the 2 globals is 643.12 KiB (658560 bytes)
[17:41:49.036] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 643.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (643.07 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.036] - globals: [2] ‘x’, ‘i’
[17:41:49.037] 
[17:41:49.037] getGlobalsAndPackages() ... DONE
[17:41:49.037] getGlobalsAndPackages() ...
[17:41:49.037] Searching for globals...
[17:41:49.039] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.039] Searching for globals ... DONE
[17:41:49.039] Resolving globals: FALSE
[17:41:49.066] The total size of the 2 globals is 651.48 KiB (667112 bytes)
[17:41:49.066] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 651.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (651.42 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.066] - globals: [2] ‘x’, ‘i’
[17:41:49.066] 
[17:41:49.067] getGlobalsAndPackages() ... DONE
[17:41:49.067] getGlobalsAndPackages() ...
[17:41:49.067] Searching for globals...
[17:41:49.069] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.069] Searching for globals ... DONE
[17:41:49.069] Resolving globals: FALSE
[17:41:49.098] The total size of the 2 globals is 659.83 KiB (675664 bytes)
[17:41:49.098] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 659.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (659.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.099] - globals: [2] ‘x’, ‘i’
[17:41:49.099] 
[17:41:49.099] getGlobalsAndPackages() ... DONE
[17:41:49.099] getGlobalsAndPackages() ...
[17:41:49.100] Searching for globals...
[17:41:49.101] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.101] Searching for globals ... DONE
[17:41:49.102] Resolving globals: FALSE
[17:41:49.130] The total size of the 2 globals is 668.18 KiB (684216 bytes)
[17:41:49.131] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 668.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (668.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.131] - globals: [2] ‘x’, ‘i’
[17:41:49.131] 
[17:41:49.131] getGlobalsAndPackages() ... DONE
[17:41:49.132] getGlobalsAndPackages() ...
[17:41:49.132] Searching for globals...
[17:41:49.134] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.134] Searching for globals ... DONE
[17:41:49.134] Resolving globals: FALSE
[17:41:49.163] The total size of the 2 globals is 676.53 KiB (692768 bytes)
[17:41:49.163] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 676.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (676.48 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.164] - globals: [2] ‘x’, ‘i’
[17:41:49.164] 
[17:41:49.164] getGlobalsAndPackages() ... DONE
[17:41:49.164] getGlobalsAndPackages() ...
[17:41:49.165] Searching for globals...
[17:41:49.166] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.166] Searching for globals ... DONE
[17:41:49.166] Resolving globals: FALSE
[17:41:49.196] The total size of the 2 globals is 684.88 KiB (701320 bytes)
[17:41:49.197] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 684.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (684.83 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.197] - globals: [2] ‘x’, ‘i’
[17:41:49.197] 
[17:41:49.197] getGlobalsAndPackages() ... DONE
[17:41:49.198] getGlobalsAndPackages() ...
[17:41:49.198] Searching for globals...
[17:41:49.200] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.200] Searching for globals ... DONE
[17:41:49.200] Resolving globals: FALSE
[17:41:49.231] The total size of the 2 globals is 693.23 KiB (709872 bytes)
[17:41:49.231] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 693.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (693.18 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.231] - globals: [2] ‘x’, ‘i’
[17:41:49.232] 
[17:41:49.232] getGlobalsAndPackages() ... DONE
[17:41:49.232] getGlobalsAndPackages() ...
[17:41:49.233] Searching for globals...
[17:41:49.234] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.235] Searching for globals ... DONE
[17:41:49.235] Resolving globals: FALSE
[17:41:49.263] The total size of the 2 globals is 701.59 KiB (718424 bytes)
[17:41:49.264] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 701.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (701.53 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.264] - globals: [2] ‘x’, ‘i’
[17:41:49.264] 
[17:41:49.264] getGlobalsAndPackages() ... DONE
[17:41:49.265] getGlobalsAndPackages() ...
[17:41:49.265] Searching for globals...
[17:41:49.267] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.267] Searching for globals ... DONE
[17:41:49.267] Resolving globals: FALSE
[17:41:49.295] The total size of the 2 globals is 709.94 KiB (726976 bytes)
[17:41:49.296] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 709.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (709.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.296] - globals: [2] ‘x’, ‘i’
[17:41:49.296] 
[17:41:49.296] getGlobalsAndPackages() ... DONE
[17:41:49.297] getGlobalsAndPackages() ...
[17:41:49.297] Searching for globals...
[17:41:49.299] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.299] Searching for globals ... DONE
[17:41:49.299] Resolving globals: FALSE
[17:41:49.329] The total size of the 2 globals is 718.29 KiB (735528 bytes)
[17:41:49.329] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.329] - globals: [2] ‘x’, ‘i’
[17:41:49.330] 
[17:41:49.330] getGlobalsAndPackages() ... DONE
[17:41:49.330] getGlobalsAndPackages() ...
[17:41:49.330] Searching for globals...
[17:41:49.332] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.332] Searching for globals ... DONE
[17:41:49.332] Resolving globals: FALSE
[17:41:49.364] The total size of the 2 globals is 726.64 KiB (744080 bytes)
[17:41:49.364] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 726.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (726.59 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.364] - globals: [2] ‘x’, ‘i’
[17:41:49.364] 
[17:41:49.364] getGlobalsAndPackages() ... DONE
[17:41:49.365] getGlobalsAndPackages() ...
[17:41:49.365] Searching for globals...
[17:41:49.367] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.367] Searching for globals ... DONE
[17:41:49.367] Resolving globals: FALSE
[17:41:49.398] The total size of the 2 globals is 734.99 KiB (752632 bytes)
[17:41:49.399] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 734.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (734.94 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.399] - globals: [2] ‘x’, ‘i’
[17:41:49.399] 
[17:41:49.399] getGlobalsAndPackages() ... DONE
[17:41:49.400] getGlobalsAndPackages() ...
[17:41:49.400] Searching for globals...
[17:41:49.402] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.402] Searching for globals ... DONE
[17:41:49.402] Resolving globals: FALSE
[17:41:49.432] The total size of the 2 globals is 743.34 KiB (761184 bytes)
[17:41:49.432] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 743.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (743.29 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.432] - globals: [2] ‘x’, ‘i’
[17:41:49.433] 
[17:41:49.433] getGlobalsAndPackages() ... DONE
[17:41:49.433] getGlobalsAndPackages() ...
[17:41:49.433] Searching for globals...
[17:41:49.435] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.435] Searching for globals ... DONE
[17:41:49.435] Resolving globals: FALSE
[17:41:49.464] The total size of the 2 globals is 751.70 KiB (769736 bytes)
[17:41:49.464] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 751.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (751.64 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.464] - globals: [2] ‘x’, ‘i’
[17:41:49.464] 
[17:41:49.464] getGlobalsAndPackages() ... DONE
[17:41:49.465] getGlobalsAndPackages() ...
[17:41:49.465] Searching for globals...
[17:41:49.467] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.467] Searching for globals ... DONE
[17:41:49.467] Resolving globals: FALSE
[17:41:49.494] The total size of the 2 globals is 760.05 KiB (778288 bytes)
[17:41:49.495] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 760.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (759.99 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.495] - globals: [2] ‘x’, ‘i’
[17:41:49.495] 
[17:41:49.495] getGlobalsAndPackages() ... DONE
[17:41:49.496] getGlobalsAndPackages() ...
[17:41:49.496] Searching for globals...
[17:41:49.497] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.497] Searching for globals ... DONE
[17:41:49.497] Resolving globals: FALSE
[17:41:49.529] The total size of the 2 globals is 768.40 KiB (786840 bytes)
[17:41:49.529] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 768.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (768.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.529] - globals: [2] ‘x’, ‘i’
[17:41:49.529] 
[17:41:49.530] getGlobalsAndPackages() ... DONE
[17:41:49.530] getGlobalsAndPackages() ...
[17:41:49.530] Searching for globals...
[17:41:49.532] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.532] Searching for globals ... DONE
[17:41:49.532] Resolving globals: FALSE
[17:41:49.565] The total size of the 2 globals is 776.75 KiB (795392 bytes)
[17:41:49.565] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 776.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (776.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.566] - globals: [2] ‘x’, ‘i’
[17:41:49.566] 
[17:41:49.566] getGlobalsAndPackages() ... DONE
[17:41:49.566] getGlobalsAndPackages() ...
[17:41:49.567] Searching for globals...
[17:41:49.568] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.568] Searching for globals ... DONE
[17:41:49.569] Resolving globals: FALSE
[17:41:49.601] The total size of the 2 globals is 785.10 KiB (803944 bytes)
[17:41:49.602] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 785.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (785.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.602] - globals: [2] ‘x’, ‘i’
[17:41:49.602] 
[17:41:49.602] getGlobalsAndPackages() ... DONE
[17:41:49.603] getGlobalsAndPackages() ...
[17:41:49.603] Searching for globals...
[17:41:49.605] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.605] Searching for globals ... DONE
[17:41:49.605] Resolving globals: FALSE
[17:41:49.638] The total size of the 2 globals is 793.45 KiB (812496 bytes)
[17:41:49.638] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 793.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (793.40 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.639] - globals: [2] ‘x’, ‘i’
[17:41:49.639] 
[17:41:49.639] getGlobalsAndPackages() ... DONE
[17:41:49.640] getGlobalsAndPackages() ...
[17:41:49.640] Searching for globals...
[17:41:49.643] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.643] Searching for globals ... DONE
[17:41:49.643] Resolving globals: FALSE
[17:41:49.675] The total size of the 2 globals is 801.80 KiB (821048 bytes)
[17:41:49.676] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 801.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (801.75 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.676] - globals: [2] ‘x’, ‘i’
[17:41:49.676] 
[17:41:49.676] getGlobalsAndPackages() ... DONE
[17:41:49.677] getGlobalsAndPackages() ...
[17:41:49.677] Searching for globals...
[17:41:49.678] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[17:41:49.678] Searching for globals ... DONE
[17:41:49.678] Resolving globals: FALSE
[17:41:49.712] The total size of the 2 globals is 810.16 KiB (829600 bytes)
[17:41:49.713] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 810.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (810.10 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[17:41:49.713] - globals: [2] ‘x’, ‘i’
[17:41:49.713] 
[17:41:49.713] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[17:41:49.714] run() for ‘Future’ ...
[17:41:49.714] - state: ‘created’
[17:41:49.715] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:49.715] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:49.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:49.715]   - Field: ‘label’
[17:41:49.715]   - Field: ‘local’
[17:41:49.716]   - Field: ‘owner’
[17:41:49.716]   - Field: ‘envir’
[17:41:49.716]   - Field: ‘packages’
[17:41:49.716]   - Field: ‘gc’
[17:41:49.716]   - Field: ‘conditions’
[17:41:49.716]   - Field: ‘expr’
[17:41:49.716]   - Field: ‘uuid’
[17:41:49.716]   - Field: ‘seed’
[17:41:49.716]   - Field: ‘version’
[17:41:49.716]   - Field: ‘result’
[17:41:49.717]   - Field: ‘asynchronous’
[17:41:49.717]   - Field: ‘calls’
[17:41:49.717]   - Field: ‘globals’
[17:41:49.717]   - Field: ‘stdout’
[17:41:49.717]   - Field: ‘earlySignal’
[17:41:49.717]   - Field: ‘lazy’
[17:41:49.717]   - Field: ‘state’
[17:41:49.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:49.718] - Launch lazy future ...
[17:41:49.718] Packages needed by the future expression (n = 0): <none>
[17:41:49.719] Packages needed by future strategies (n = 0): <none>
[17:41:49.719] {
[17:41:49.719]     {
[17:41:49.719]         {
[17:41:49.719]             ...future.startTime <- base::Sys.time()
[17:41:49.719]             {
[17:41:49.719]                 {
[17:41:49.719]                   {
[17:41:49.719]                     base::local({
[17:41:49.719]                       has_future <- base::requireNamespace("future", 
[17:41:49.719]                         quietly = TRUE)
[17:41:49.719]                       if (has_future) {
[17:41:49.719]                         ns <- base::getNamespace("future")
[17:41:49.719]                         version <- ns[[".package"]][["version"]]
[17:41:49.719]                         if (is.null(version)) 
[17:41:49.719]                           version <- utils::packageVersion("future")
[17:41:49.719]                       }
[17:41:49.719]                       else {
[17:41:49.719]                         version <- NULL
[17:41:49.719]                       }
[17:41:49.719]                       if (!has_future || version < "1.8.0") {
[17:41:49.719]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:49.719]                           "", base::R.version$version.string), 
[17:41:49.719]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:49.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:49.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:49.719]                             "release", "version")], collapse = " "), 
[17:41:49.719]                           hostname = base::Sys.info()[["nodename"]])
[17:41:49.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:49.719]                           info)
[17:41:49.719]                         info <- base::paste(info, collapse = "; ")
[17:41:49.719]                         if (!has_future) {
[17:41:49.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:49.719]                             info)
[17:41:49.719]                         }
[17:41:49.719]                         else {
[17:41:49.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:49.719]                             info, version)
[17:41:49.719]                         }
[17:41:49.719]                         base::stop(msg)
[17:41:49.719]                       }
[17:41:49.719]                     })
[17:41:49.719]                   }
[17:41:49.719]                   options(future.plan = NULL)
[17:41:49.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:49.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:49.719]                 }
[17:41:49.719]                 ...future.workdir <- getwd()
[17:41:49.719]             }
[17:41:49.719]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:49.719]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:49.719]         }
[17:41:49.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:49.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:49.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:49.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:49.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:49.719]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:49.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:49.719]             base::names(...future.oldOptions))
[17:41:49.719]     }
[17:41:49.719]     if (TRUE) {
[17:41:49.719]     }
[17:41:49.719]     else {
[17:41:49.719]         if (NA) {
[17:41:49.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:49.719]                 open = "w")
[17:41:49.719]         }
[17:41:49.719]         else {
[17:41:49.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:49.719]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:49.719]         }
[17:41:49.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:49.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:49.719]             base::sink(type = "output", split = FALSE)
[17:41:49.719]             base::close(...future.stdout)
[17:41:49.719]         }, add = TRUE)
[17:41:49.719]     }
[17:41:49.719]     ...future.frame <- base::sys.nframe()
[17:41:49.719]     ...future.conditions <- base::list()
[17:41:49.719]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:49.719]     if (FALSE) {
[17:41:49.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:49.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:49.719]     }
[17:41:49.719]     ...future.result <- base::tryCatch({
[17:41:49.719]         base::withCallingHandlers({
[17:41:49.719]             ...future.value <- base::withVisible(base::local({
[17:41:49.719]                 x[[i - 2]] + x[[i - 1]]
[17:41:49.719]             }))
[17:41:49.719]             future::FutureResult(value = ...future.value$value, 
[17:41:49.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:49.719]                   ...future.rng), globalenv = if (FALSE) 
[17:41:49.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:49.719]                     ...future.globalenv.names))
[17:41:49.719]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:49.719]         }, condition = base::local({
[17:41:49.719]             c <- base::c
[17:41:49.719]             inherits <- base::inherits
[17:41:49.719]             invokeRestart <- base::invokeRestart
[17:41:49.719]             length <- base::length
[17:41:49.719]             list <- base::list
[17:41:49.719]             seq.int <- base::seq.int
[17:41:49.719]             signalCondition <- base::signalCondition
[17:41:49.719]             sys.calls <- base::sys.calls
[17:41:49.719]             `[[` <- base::`[[`
[17:41:49.719]             `+` <- base::`+`
[17:41:49.719]             `<<-` <- base::`<<-`
[17:41:49.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:49.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:49.719]                   3L)]
[17:41:49.719]             }
[17:41:49.719]             function(cond) {
[17:41:49.719]                 is_error <- inherits(cond, "error")
[17:41:49.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:49.719]                   NULL)
[17:41:49.719]                 if (is_error) {
[17:41:49.719]                   sessionInformation <- function() {
[17:41:49.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:49.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:49.719]                       search = base::search(), system = base::Sys.info())
[17:41:49.719]                   }
[17:41:49.719]                   ...future.conditions[[length(...future.conditions) + 
[17:41:49.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:49.719]                     cond$call), session = sessionInformation(), 
[17:41:49.719]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:49.719]                   signalCondition(cond)
[17:41:49.719]                 }
[17:41:49.719]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[17:41:49.719]                 "immediateCondition"))) {
[17:41:49.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:49.719]                   ...future.conditions[[length(...future.conditions) + 
[17:41:49.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:49.719]                   if (TRUE && !signal) {
[17:41:49.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:49.719]                     {
[17:41:49.719]                       inherits <- base::inherits
[17:41:49.719]                       invokeRestart <- base::invokeRestart
[17:41:49.719]                       is.null <- base::is.null
[17:41:49.719]                       muffled <- FALSE
[17:41:49.719]                       if (inherits(cond, "message")) {
[17:41:49.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:49.719]                         if (muffled) 
[17:41:49.719]                           invokeRestart("muffleMessage")
[17:41:49.719]                       }
[17:41:49.719]                       else if (inherits(cond, "warning")) {
[17:41:49.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:49.719]                         if (muffled) 
[17:41:49.719]                           invokeRestart("muffleWarning")
[17:41:49.719]                       }
[17:41:49.719]                       else if (inherits(cond, "condition")) {
[17:41:49.719]                         if (!is.null(pattern)) {
[17:41:49.719]                           computeRestarts <- base::computeRestarts
[17:41:49.719]                           grepl <- base::grepl
[17:41:49.719]                           restarts <- computeRestarts(cond)
[17:41:49.719]                           for (restart in restarts) {
[17:41:49.719]                             name <- restart$name
[17:41:49.719]                             if (is.null(name)) 
[17:41:49.719]                               next
[17:41:49.719]                             if (!grepl(pattern, name)) 
[17:41:49.719]                               next
[17:41:49.719]                             invokeRestart(restart)
[17:41:49.719]                             muffled <- TRUE
[17:41:49.719]                             break
[17:41:49.719]                           }
[17:41:49.719]                         }
[17:41:49.719]                       }
[17:41:49.719]                       invisible(muffled)
[17:41:49.719]                     }
[17:41:49.719]                     muffleCondition(cond, pattern = "^muffle")
[17:41:49.719]                   }
[17:41:49.719]                 }
[17:41:49.719]                 else {
[17:41:49.719]                   if (TRUE) {
[17:41:49.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:49.719]                     {
[17:41:49.719]                       inherits <- base::inherits
[17:41:49.719]                       invokeRestart <- base::invokeRestart
[17:41:49.719]                       is.null <- base::is.null
[17:41:49.719]                       muffled <- FALSE
[17:41:49.719]                       if (inherits(cond, "message")) {
[17:41:49.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:49.719]                         if (muffled) 
[17:41:49.719]                           invokeRestart("muffleMessage")
[17:41:49.719]                       }
[17:41:49.719]                       else if (inherits(cond, "warning")) {
[17:41:49.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:49.719]                         if (muffled) 
[17:41:49.719]                           invokeRestart("muffleWarning")
[17:41:49.719]                       }
[17:41:49.719]                       else if (inherits(cond, "condition")) {
[17:41:49.719]                         if (!is.null(pattern)) {
[17:41:49.719]                           computeRestarts <- base::computeRestarts
[17:41:49.719]                           grepl <- base::grepl
[17:41:49.719]                           restarts <- computeRestarts(cond)
[17:41:49.719]                           for (restart in restarts) {
[17:41:49.719]                             name <- restart$name
[17:41:49.719]                             if (is.null(name)) 
[17:41:49.719]                               next
[17:41:49.719]                             if (!grepl(pattern, name)) 
[17:41:49.719]                               next
[17:41:49.719]                             invokeRestart(restart)
[17:41:49.719]                             muffled <- TRUE
[17:41:49.719]                             break
[17:41:49.719]                           }
[17:41:49.719]                         }
[17:41:49.719]                       }
[17:41:49.719]                       invisible(muffled)
[17:41:49.719]                     }
[17:41:49.719]                     muffleCondition(cond, pattern = "^muffle")
[17:41:49.719]                   }
[17:41:49.719]                 }
[17:41:49.719]             }
[17:41:49.719]         }))
[17:41:49.719]     }, error = function(ex) {
[17:41:49.719]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:49.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:49.719]                 ...future.rng), started = ...future.startTime, 
[17:41:49.719]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:49.719]             version = "1.8"), class = "FutureResult")
[17:41:49.719]     }, finally = {
[17:41:49.719]         if (!identical(...future.workdir, getwd())) 
[17:41:49.719]             setwd(...future.workdir)
[17:41:49.719]         {
[17:41:49.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:49.719]                 ...future.oldOptions$nwarnings <- NULL
[17:41:49.719]             }
[17:41:49.719]             base::options(...future.oldOptions)
[17:41:49.719]             if (.Platform$OS.type == "windows") {
[17:41:49.719]                 old_names <- names(...future.oldEnvVars)
[17:41:49.719]                 envs <- base::Sys.getenv()
[17:41:49.719]                 names <- names(envs)
[17:41:49.719]                 common <- intersect(names, old_names)
[17:41:49.719]                 added <- setdiff(names, old_names)
[17:41:49.719]                 removed <- setdiff(old_names, names)
[17:41:49.719]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:49.719]                   envs[common]]
[17:41:49.719]                 NAMES <- toupper(changed)
[17:41:49.719]                 args <- list()
[17:41:49.719]                 for (kk in seq_along(NAMES)) {
[17:41:49.719]                   name <- changed[[kk]]
[17:41:49.719]                   NAME <- NAMES[[kk]]
[17:41:49.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:49.719]                     next
[17:41:49.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:49.719]                 }
[17:41:49.719]                 NAMES <- toupper(added)
[17:41:49.719]                 for (kk in seq_along(NAMES)) {
[17:41:49.719]                   name <- added[[kk]]
[17:41:49.719]                   NAME <- NAMES[[kk]]
[17:41:49.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:49.719]                     next
[17:41:49.719]                   args[[name]] <- ""
[17:41:49.719]                 }
[17:41:49.719]                 NAMES <- toupper(removed)
[17:41:49.719]                 for (kk in seq_along(NAMES)) {
[17:41:49.719]                   name <- removed[[kk]]
[17:41:49.719]                   NAME <- NAMES[[kk]]
[17:41:49.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:49.719]                     next
[17:41:49.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:49.719]                 }
[17:41:49.719]                 if (length(args) > 0) 
[17:41:49.719]                   base::do.call(base::Sys.setenv, args = args)
[17:41:49.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:49.719]             }
[17:41:49.719]             else {
[17:41:49.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:49.719]             }
[17:41:49.719]             {
[17:41:49.719]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:49.719]                   0L) {
[17:41:49.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:49.719]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:49.719]                   base::options(opts)
[17:41:49.719]                 }
[17:41:49.719]                 {
[17:41:49.719]                   {
[17:41:49.719]                     NULL
[17:41:49.719]                     RNGkind("Mersenne-Twister")
[17:41:49.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:49.719]                       inherits = FALSE)
[17:41:49.719]                   }
[17:41:49.719]                   options(future.plan = NULL)
[17:41:49.719]                   if (is.na(NA_character_)) 
[17:41:49.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:49.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:49.719]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:49.719]                   {
[17:41:49.719]                     future <- SequentialFuture(..., envir = envir)
[17:41:49.719]                     if (!future$lazy) 
[17:41:49.719]                       future <- run(future)
[17:41:49.719]                     invisible(future)
[17:41:49.719]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:49.719]                 }
[17:41:49.719]             }
[17:41:49.719]         }
[17:41:49.719]     })
[17:41:49.719]     if (FALSE) {
[17:41:49.719]         base::sink(type = "output", split = FALSE)
[17:41:49.719]         if (NA) {
[17:41:49.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:49.719]         }
[17:41:49.719]         else {
[17:41:49.719]             ...future.result["stdout"] <- base::list(NULL)
[17:41:49.719]         }
[17:41:49.719]         base::close(...future.stdout)
[17:41:49.719]         ...future.stdout <- NULL
[17:41:49.719]     }
[17:41:49.719]     ...future.result$conditions <- ...future.conditions
[17:41:49.719]     ...future.result$finished <- base::Sys.time()
[17:41:49.719]     ...future.result
[17:41:49.719] }
[17:41:49.721] assign_globals() ...
[17:41:49.722] List of 2
[17:41:49.722]  $ x:Classes 'listenv', 'environment' <environment: 0x56348c08d628> 
[17:41:49.722]  $ i: int 7
[17:41:49.722]  - attr(*, "where")=List of 2
[17:41:49.722]   ..$ x:<environment: R_EmptyEnv> 
[17:41:49.722]   ..$ i:<environment: R_EmptyEnv> 
[17:41:49.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:49.722]  - attr(*, "resolved")= logi FALSE
[17:41:49.722]  - attr(*, "total_size")= num 34264
[17:41:49.722]  - attr(*, "already-done")= logi TRUE
[17:41:49.730] - copied ‘x’ to environment
[17:41:49.730] - copied ‘i’ to environment
[17:41:49.730] assign_globals() ... done
[17:41:49.730] plan(): Setting new future strategy stack:
[17:41:49.730] List of future strategies:
[17:41:49.730] 1. sequential:
[17:41:49.730]    - args: function (..., envir = parent.frame())
[17:41:49.730]    - tweaked: FALSE
[17:41:49.730]    - call: NULL
[17:41:49.731] plan(): nbrOfWorkers() = 1
[17:41:49.815] plan(): Setting new future strategy stack:
[17:41:49.815] List of future strategies:
[17:41:49.815] 1. sequential:
[17:41:49.815]    - args: function (..., envir = parent.frame())
[17:41:49.815]    - tweaked: FALSE
[17:41:49.815]    - call: plan(sequential)
[17:41:49.816] plan(): nbrOfWorkers() = 1
[17:41:49.816] SequentialFuture started (and completed)
[17:41:49.816] - Launch lazy future ... done
[17:41:49.816] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[17:41:49.817] run() for ‘Future’ ...
[17:41:49.817] - state: ‘created’
[17:41:49.817] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:49.817] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:49.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:49.817]   - Field: ‘label’
[17:41:49.818]   - Field: ‘local’
[17:41:49.818]   - Field: ‘owner’
[17:41:49.818]   - Field: ‘envir’
[17:41:49.818]   - Field: ‘packages’
[17:41:49.818]   - Field: ‘gc’
[17:41:49.818]   - Field: ‘conditions’
[17:41:49.818]   - Field: ‘expr’
[17:41:49.818]   - Field: ‘uuid’
[17:41:49.818]   - Field: ‘seed’
[17:41:49.818]   - Field: ‘version’
[17:41:49.819]   - Field: ‘result’
[17:41:49.819]   - Field: ‘asynchronous’
[17:41:49.819]   - Field: ‘calls’
[17:41:49.819]   - Field: ‘globals’
[17:41:49.819]   - Field: ‘stdout’
[17:41:49.819]   - Field: ‘earlySignal’
[17:41:49.819]   - Field: ‘lazy’
[17:41:49.819]   - Field: ‘state’
[17:41:49.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:49.819] - Launch lazy future ...
[17:41:49.820] Packages needed by the future expression (n = 0): <none>
[17:41:49.820] Packages needed by future strategies (n = 0): <none>
[17:41:49.820] {
[17:41:49.820]     {
[17:41:49.820]         {
[17:41:49.820]             ...future.startTime <- base::Sys.time()
[17:41:49.820]             {
[17:41:49.820]                 {
[17:41:49.820]                   {
[17:41:49.820]                     base::local({
[17:41:49.820]                       has_future <- base::requireNamespace("future", 
[17:41:49.820]                         quietly = TRUE)
[17:41:49.820]                       if (has_future) {
[17:41:49.820]                         ns <- base::getNamespace("future")
[17:41:49.820]                         version <- ns[[".package"]][["version"]]
[17:41:49.820]                         if (is.null(version)) 
[17:41:49.820]                           version <- utils::packageVersion("future")
[17:41:49.820]                       }
[17:41:49.820]                       else {
[17:41:49.820]                         version <- NULL
[17:41:49.820]                       }
[17:41:49.820]                       if (!has_future || version < "1.8.0") {
[17:41:49.820]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:49.820]                           "", base::R.version$version.string), 
[17:41:49.820]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:49.820]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:49.820]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:49.820]                             "release", "version")], collapse = " "), 
[17:41:49.820]                           hostname = base::Sys.info()[["nodename"]])
[17:41:49.820]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:49.820]                           info)
[17:41:49.820]                         info <- base::paste(info, collapse = "; ")
[17:41:49.820]                         if (!has_future) {
[17:41:49.820]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:49.820]                             info)
[17:41:49.820]                         }
[17:41:49.820]                         else {
[17:41:49.820]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:49.820]                             info, version)
[17:41:49.820]                         }
[17:41:49.820]                         base::stop(msg)
[17:41:49.820]                       }
[17:41:49.820]                     })
[17:41:49.820]                   }
[17:41:49.820]                   options(future.plan = NULL)
[17:41:49.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:49.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:49.820]                 }
[17:41:49.820]                 ...future.workdir <- getwd()
[17:41:49.820]             }
[17:41:49.820]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:49.820]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:49.820]         }
[17:41:49.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:49.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:49.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:49.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:49.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:49.820]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:49.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:49.820]             base::names(...future.oldOptions))
[17:41:49.820]     }
[17:41:49.820]     if (TRUE) {
[17:41:49.820]     }
[17:41:49.820]     else {
[17:41:49.820]         if (NA) {
[17:41:49.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:49.820]                 open = "w")
[17:41:49.820]         }
[17:41:49.820]         else {
[17:41:49.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:49.820]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:49.820]         }
[17:41:49.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:49.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:49.820]             base::sink(type = "output", split = FALSE)
[17:41:49.820]             base::close(...future.stdout)
[17:41:49.820]         }, add = TRUE)
[17:41:49.820]     }
[17:41:49.820]     ...future.frame <- base::sys.nframe()
[17:41:49.820]     ...future.conditions <- base::list()
[17:41:49.820]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:49.820]     if (FALSE) {
[17:41:49.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:49.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:49.820]     }
[17:41:49.820]     ...future.result <- base::tryCatch({
[17:41:49.820]         base::withCallingHandlers({
[17:41:49.820]             ...future.value <- base::withVisible(base::local({
[17:41:49.820]                 x[[i - 2]] + x[[i - 1]]
[17:41:49.820]             }))
[17:41:49.820]             future::FutureResult(value = ...future.value$value, 
[17:41:49.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:49.820]                   ...future.rng), globalenv = if (FALSE) 
[17:41:49.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:49.820]                     ...future.globalenv.names))
[17:41:49.820]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:49.820]         }, condition = base::local({
[17:41:49.820]             c <- base::c
[17:41:49.820]             inherits <- base::inherits
[17:41:49.820]             invokeRestart <- base::invokeRestart
[17:41:49.820]             length <- base::length
[17:41:49.820]             list <- base::list
[17:41:49.820]             seq.int <- base::seq.int
[17:41:49.820]             signalCondition <- base::signalCondition
[17:41:49.820]             sys.calls <- base::sys.calls
[17:41:49.820]             `[[` <- base::`[[`
[17:41:49.820]             `+` <- base::`+`
[17:41:49.820]             `<<-` <- base::`<<-`
[17:41:49.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:49.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:49.820]                   3L)]
[17:41:49.820]             }
[17:41:49.820]             function(cond) {
[17:41:49.820]                 is_error <- inherits(cond, "error")
[17:41:49.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:49.820]                   NULL)
[17:41:49.820]                 if (is_error) {
[17:41:49.820]                   sessionInformation <- function() {
[17:41:49.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:49.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:49.820]                       search = base::search(), system = base::Sys.info())
[17:41:49.820]                   }
[17:41:49.820]                   ...future.conditions[[length(...future.conditions) + 
[17:41:49.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:49.820]                     cond$call), session = sessionInformation(), 
[17:41:49.820]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:49.820]                   signalCondition(cond)
[17:41:49.820]                 }
[17:41:49.820]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[17:41:49.820]                 "immediateCondition"))) {
[17:41:49.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:49.820]                   ...future.conditions[[length(...future.conditions) + 
[17:41:49.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:49.820]                   if (TRUE && !signal) {
[17:41:49.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:49.820]                     {
[17:41:49.820]                       inherits <- base::inherits
[17:41:49.820]                       invokeRestart <- base::invokeRestart
[17:41:49.820]                       is.null <- base::is.null
[17:41:49.820]                       muffled <- FALSE
[17:41:49.820]                       if (inherits(cond, "message")) {
[17:41:49.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:49.820]                         if (muffled) 
[17:41:49.820]                           invokeRestart("muffleMessage")
[17:41:49.820]                       }
[17:41:49.820]                       else if (inherits(cond, "warning")) {
[17:41:49.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:49.820]                         if (muffled) 
[17:41:49.820]                           invokeRestart("muffleWarning")
[17:41:49.820]                       }
[17:41:49.820]                       else if (inherits(cond, "condition")) {
[17:41:49.820]                         if (!is.null(pattern)) {
[17:41:49.820]                           computeRestarts <- base::computeRestarts
[17:41:49.820]                           grepl <- base::grepl
[17:41:49.820]                           restarts <- computeRestarts(cond)
[17:41:49.820]                           for (restart in restarts) {
[17:41:49.820]                             name <- restart$name
[17:41:49.820]                             if (is.null(name)) 
[17:41:49.820]                               next
[17:41:49.820]                             if (!grepl(pattern, name)) 
[17:41:49.820]                               next
[17:41:49.820]                             invokeRestart(restart)
[17:41:49.820]                             muffled <- TRUE
[17:41:49.820]                             break
[17:41:49.820]                           }
[17:41:49.820]                         }
[17:41:49.820]                       }
[17:41:49.820]                       invisible(muffled)
[17:41:49.820]                     }
[17:41:49.820]                     muffleCondition(cond, pattern = "^muffle")
[17:41:49.820]                   }
[17:41:49.820]                 }
[17:41:49.820]                 else {
[17:41:49.820]                   if (TRUE) {
[17:41:49.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:49.820]                     {
[17:41:49.820]                       inherits <- base::inherits
[17:41:49.820]                       invokeRestart <- base::invokeRestart
[17:41:49.820]                       is.null <- base::is.null
[17:41:49.820]                       muffled <- FALSE
[17:41:49.820]                       if (inherits(cond, "message")) {
[17:41:49.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:49.820]                         if (muffled) 
[17:41:49.820]                           invokeRestart("muffleMessage")
[17:41:49.820]                       }
[17:41:49.820]                       else if (inherits(cond, "warning")) {
[17:41:49.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:49.820]                         if (muffled) 
[17:41:49.820]                           invokeRestart("muffleWarning")
[17:41:49.820]                       }
[17:41:49.820]                       else if (inherits(cond, "condition")) {
[17:41:49.820]                         if (!is.null(pattern)) {
[17:41:49.820]                           computeRestarts <- base::computeRestarts
[17:41:49.820]                           grepl <- base::grepl
[17:41:49.820]                           restarts <- computeRestarts(cond)
[17:41:49.820]                           for (restart in restarts) {
[17:41:49.820]                             name <- restart$name
[17:41:49.820]                             if (is.null(name)) 
[17:41:49.820]                               next
[17:41:49.820]                             if (!grepl(pattern, name)) 
[17:41:49.820]                               next
[17:41:49.820]                             invokeRestart(restart)
[17:41:49.820]                             muffled <- TRUE
[17:41:49.820]                             break
[17:41:49.820]                           }
[17:41:49.820]                         }
[17:41:49.820]                       }
[17:41:49.820]                       invisible(muffled)
[17:41:49.820]                     }
[17:41:49.820]                     muffleCondition(cond, pattern = "^muffle")
[17:41:49.820]                   }
[17:41:49.820]                 }
[17:41:49.820]             }
[17:41:49.820]         }))
[17:41:49.820]     }, error = function(ex) {
[17:41:49.820]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:49.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:49.820]                 ...future.rng), started = ...future.startTime, 
[17:41:49.820]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:49.820]             version = "1.8"), class = "FutureResult")
[17:41:49.820]     }, finally = {
[17:41:49.820]         if (!identical(...future.workdir, getwd())) 
[17:41:49.820]             setwd(...future.workdir)
[17:41:49.820]         {
[17:41:49.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:49.820]                 ...future.oldOptions$nwarnings <- NULL
[17:41:49.820]             }
[17:41:49.820]             base::options(...future.oldOptions)
[17:41:49.820]             if (.Platform$OS.type == "windows") {
[17:41:49.820]                 old_names <- names(...future.oldEnvVars)
[17:41:49.820]                 envs <- base::Sys.getenv()
[17:41:49.820]                 names <- names(envs)
[17:41:49.820]                 common <- intersect(names, old_names)
[17:41:49.820]                 added <- setdiff(names, old_names)
[17:41:49.820]                 removed <- setdiff(old_names, names)
[17:41:49.820]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:49.820]                   envs[common]]
[17:41:49.820]                 NAMES <- toupper(changed)
[17:41:49.820]                 args <- list()
[17:41:49.820]                 for (kk in seq_along(NAMES)) {
[17:41:49.820]                   name <- changed[[kk]]
[17:41:49.820]                   NAME <- NAMES[[kk]]
[17:41:49.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:49.820]                     next
[17:41:49.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:49.820]                 }
[17:41:49.820]                 NAMES <- toupper(added)
[17:41:49.820]                 for (kk in seq_along(NAMES)) {
[17:41:49.820]                   name <- added[[kk]]
[17:41:49.820]                   NAME <- NAMES[[kk]]
[17:41:49.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:49.820]                     next
[17:41:49.820]                   args[[name]] <- ""
[17:41:49.820]                 }
[17:41:49.820]                 NAMES <- toupper(removed)
[17:41:49.820]                 for (kk in seq_along(NAMES)) {
[17:41:49.820]                   name <- removed[[kk]]
[17:41:49.820]                   NAME <- NAMES[[kk]]
[17:41:49.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:49.820]                     next
[17:41:49.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:49.820]                 }
[17:41:49.820]                 if (length(args) > 0) 
[17:41:49.820]                   base::do.call(base::Sys.setenv, args = args)
[17:41:49.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:49.820]             }
[17:41:49.820]             else {
[17:41:49.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:49.820]             }
[17:41:49.820]             {
[17:41:49.820]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:49.820]                   0L) {
[17:41:49.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:49.820]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:49.820]                   base::options(opts)
[17:41:49.820]                 }
[17:41:49.820]                 {
[17:41:49.820]                   {
[17:41:49.820]                     NULL
[17:41:49.820]                     RNGkind("Mersenne-Twister")
[17:41:49.820]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:49.820]                       inherits = FALSE)
[17:41:49.820]                   }
[17:41:49.820]                   options(future.plan = NULL)
[17:41:49.820]                   if (is.na(NA_character_)) 
[17:41:49.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:49.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:49.820]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:49.820]                   {
[17:41:49.820]                     future <- SequentialFuture(..., envir = envir)
[17:41:49.820]                     if (!future$lazy) 
[17:41:49.820]                       future <- run(future)
[17:41:49.820]                     invisible(future)
[17:41:49.820]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:49.820]                 }
[17:41:49.820]             }
[17:41:49.820]         }
[17:41:49.820]     })
[17:41:49.820]     if (FALSE) {
[17:41:49.820]         base::sink(type = "output", split = FALSE)
[17:41:49.820]         if (NA) {
[17:41:49.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:49.820]         }
[17:41:49.820]         else {
[17:41:49.820]             ...future.result["stdout"] <- base::list(NULL)
[17:41:49.820]         }
[17:41:49.820]         base::close(...future.stdout)
[17:41:49.820]         ...future.stdout <- NULL
[17:41:49.820]     }
[17:41:49.820]     ...future.result$conditions <- ...future.conditions
[17:41:49.820]     ...future.result$finished <- base::Sys.time()
[17:41:49.820]     ...future.result
[17:41:49.820] }
[17:41:49.822] assign_globals() ...
[17:41:49.822] List of 2
[17:41:49.822]  $ x:Classes 'listenv', 'environment' <environment: 0x56348c08d628> 
[17:41:49.822]  $ i: int 50
[17:41:49.822]  - attr(*, "where")=List of 2
[17:41:49.822]   ..$ x:<environment: R_EmptyEnv> 
[17:41:49.822]   ..$ i:<environment: R_EmptyEnv> 
[17:41:49.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:49.822]  - attr(*, "resolved")= logi FALSE
[17:41:49.822]  - attr(*, "total_size")= num 402000
[17:41:49.822]  - attr(*, "already-done")= logi TRUE
[17:41:49.827] - copied ‘x’ to environment
[17:41:49.828] - copied ‘i’ to environment
[17:41:49.828] assign_globals() ... done
[17:41:49.828] plan(): Setting new future strategy stack:
[17:41:49.828] List of future strategies:
[17:41:49.828] 1. sequential:
[17:41:49.828]    - args: function (..., envir = parent.frame())
[17:41:49.828]    - tweaked: FALSE
[17:41:49.828]    - call: NULL
[17:41:49.829] plan(): nbrOfWorkers() = 1
[17:41:50.734] plan(): Setting new future strategy stack:
[17:41:50.734] List of future strategies:
[17:41:50.734] 1. sequential:
[17:41:50.734]    - args: function (..., envir = parent.frame())
[17:41:50.734]    - tweaked: FALSE
[17:41:50.734]    - call: plan(sequential)
[17:41:50.734] plan(): nbrOfWorkers() = 1
[17:41:50.734] SequentialFuture started (and completed)
[17:41:50.734] - Launch lazy future ... done
[17:41:50.734] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[17:41:50.735] plan(): Setting new future strategy stack:
[17:41:50.735] List of future strategies:
[17:41:50.735] 1. sequential:
[17:41:50.735]    - args: function (..., envir = parent.frame())
[17:41:50.735]    - tweaked: FALSE
[17:41:50.735]    - call: future::plan("sequential")
[17:41:50.735] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[17:41:50.742] plan(): Setting new future strategy stack:
[17:41:50.742] List of future strategies:
[17:41:50.742] 1. sequential:
[17:41:50.742]    - args: function (..., envir = parent.frame())
[17:41:50.742]    - tweaked: FALSE
[17:41:50.742]    - call: plan(strategy)
[17:41:50.742] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[17:41:50.776] getGlobalsAndPackages() ...
[17:41:50.776] Searching for globals...
[17:41:50.780] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.780] Searching for globals ... DONE
[17:41:50.780] Resolving globals: FALSE
[17:41:50.781] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.781] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.781] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.781] - packages: [1] ‘future’
[17:41:50.781] getGlobalsAndPackages() ... DONE
 2[17:41:50.785] getGlobalsAndPackages() ...
[17:41:50.785] Searching for globals...
[17:41:50.789] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.789] Searching for globals ... DONE
[17:41:50.789] Resolving globals: FALSE
[17:41:50.789] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.790] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.790] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.790] - packages: [1] ‘future’
[17:41:50.790] getGlobalsAndPackages() ... DONE
 3[17:41:50.790] getGlobalsAndPackages() ...
[17:41:50.791] Searching for globals...
[17:41:50.794] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.794] Searching for globals ... DONE
[17:41:50.794] Resolving globals: FALSE
[17:41:50.795] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.795] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.795] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.795] - packages: [1] ‘future’
[17:41:50.795] getGlobalsAndPackages() ... DONE
 4[17:41:50.796] getGlobalsAndPackages() ...
[17:41:50.796] Searching for globals...
[17:41:50.799] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.799] Searching for globals ... DONE
[17:41:50.799] Resolving globals: FALSE
[17:41:50.800] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.800] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.800] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.800] - packages: [1] ‘future’
[17:41:50.800] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[17:41:50.809] resolved() for ‘Future’ ...
[17:41:50.810] - state: ‘created’
[17:41:50.810] - run: TRUE
[17:41:50.810] - run() ...
[17:41:50.810] run() for ‘Future’ ...
[17:41:50.810] - state: ‘created’
[17:41:50.810] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:50.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:50.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:50.811]   - Field: ‘label’
[17:41:50.811]   - Field: ‘local’
[17:41:50.811]   - Field: ‘owner’
[17:41:50.811]   - Field: ‘envir’
[17:41:50.811]   - Field: ‘packages’
[17:41:50.811]   - Field: ‘gc’
[17:41:50.811]   - Field: ‘conditions’
[17:41:50.811]   - Field: ‘expr’
[17:41:50.811]   - Field: ‘uuid’
[17:41:50.811]   - Field: ‘seed’
[17:41:50.812]   - Field: ‘version’
[17:41:50.812]   - Field: ‘result’
[17:41:50.812]   - Field: ‘asynchronous’
[17:41:50.812]   - Field: ‘calls’
[17:41:50.812]   - Field: ‘globals’
[17:41:50.812]   - Field: ‘stdout’
[17:41:50.812]   - Field: ‘earlySignal’
[17:41:50.812]   - Field: ‘lazy’
[17:41:50.812]   - Field: ‘state’
[17:41:50.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:50.813] - Launch lazy future ...
[17:41:50.813] Packages needed by the future expression (n = 1): ‘future’
[17:41:50.813] Packages needed by future strategies (n = 0): <none>
[17:41:50.813] {
[17:41:50.813]     {
[17:41:50.813]         {
[17:41:50.813]             ...future.startTime <- base::Sys.time()
[17:41:50.813]             {
[17:41:50.813]                 {
[17:41:50.813]                   {
[17:41:50.813]                     {
[17:41:50.813]                       base::local({
[17:41:50.813]                         has_future <- base::requireNamespace("future", 
[17:41:50.813]                           quietly = TRUE)
[17:41:50.813]                         if (has_future) {
[17:41:50.813]                           ns <- base::getNamespace("future")
[17:41:50.813]                           version <- ns[[".package"]][["version"]]
[17:41:50.813]                           if (is.null(version)) 
[17:41:50.813]                             version <- utils::packageVersion("future")
[17:41:50.813]                         }
[17:41:50.813]                         else {
[17:41:50.813]                           version <- NULL
[17:41:50.813]                         }
[17:41:50.813]                         if (!has_future || version < "1.8.0") {
[17:41:50.813]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:50.813]                             "", base::R.version$version.string), 
[17:41:50.813]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:50.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:50.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:50.813]                               "release", "version")], collapse = " "), 
[17:41:50.813]                             hostname = base::Sys.info()[["nodename"]])
[17:41:50.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:50.813]                             info)
[17:41:50.813]                           info <- base::paste(info, collapse = "; ")
[17:41:50.813]                           if (!has_future) {
[17:41:50.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:50.813]                               info)
[17:41:50.813]                           }
[17:41:50.813]                           else {
[17:41:50.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:50.813]                               info, version)
[17:41:50.813]                           }
[17:41:50.813]                           base::stop(msg)
[17:41:50.813]                         }
[17:41:50.813]                       })
[17:41:50.813]                     }
[17:41:50.813]                     base::local({
[17:41:50.813]                       for (pkg in "future") {
[17:41:50.813]                         base::loadNamespace(pkg)
[17:41:50.813]                         base::library(pkg, character.only = TRUE)
[17:41:50.813]                       }
[17:41:50.813]                     })
[17:41:50.813]                   }
[17:41:50.813]                   options(future.plan = NULL)
[17:41:50.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:50.813]                 }
[17:41:50.813]                 ...future.workdir <- getwd()
[17:41:50.813]             }
[17:41:50.813]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:50.813]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:50.813]         }
[17:41:50.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:50.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:50.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:50.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:50.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:50.813]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:50.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:50.813]             base::names(...future.oldOptions))
[17:41:50.813]     }
[17:41:50.813]     if (FALSE) {
[17:41:50.813]     }
[17:41:50.813]     else {
[17:41:50.813]         if (TRUE) {
[17:41:50.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:50.813]                 open = "w")
[17:41:50.813]         }
[17:41:50.813]         else {
[17:41:50.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:50.813]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:50.813]         }
[17:41:50.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:50.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:50.813]             base::sink(type = "output", split = FALSE)
[17:41:50.813]             base::close(...future.stdout)
[17:41:50.813]         }, add = TRUE)
[17:41:50.813]     }
[17:41:50.813]     ...future.frame <- base::sys.nframe()
[17:41:50.813]     ...future.conditions <- base::list()
[17:41:50.813]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:50.813]     if (FALSE) {
[17:41:50.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:50.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:50.813]     }
[17:41:50.813]     ...future.result <- base::tryCatch({
[17:41:50.813]         base::withCallingHandlers({
[17:41:50.813]             ...future.value <- base::withVisible(base::local({
[17:41:50.813]                 message(sprintf("Calculating tile #%d of %d ...", 
[17:41:50.813]                   ii, n), appendLF = FALSE)
[17:41:50.813]                 fit <- mandelbrot(C)
[17:41:50.813]                 delay(fit)
[17:41:50.813]                 message(" done")
[17:41:50.813]                 fit
[17:41:50.813]             }))
[17:41:50.813]             future::FutureResult(value = ...future.value$value, 
[17:41:50.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.813]                   ...future.rng), globalenv = if (FALSE) 
[17:41:50.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:50.813]                     ...future.globalenv.names))
[17:41:50.813]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:50.813]         }, condition = base::local({
[17:41:50.813]             c <- base::c
[17:41:50.813]             inherits <- base::inherits
[17:41:50.813]             invokeRestart <- base::invokeRestart
[17:41:50.813]             length <- base::length
[17:41:50.813]             list <- base::list
[17:41:50.813]             seq.int <- base::seq.int
[17:41:50.813]             signalCondition <- base::signalCondition
[17:41:50.813]             sys.calls <- base::sys.calls
[17:41:50.813]             `[[` <- base::`[[`
[17:41:50.813]             `+` <- base::`+`
[17:41:50.813]             `<<-` <- base::`<<-`
[17:41:50.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:50.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:50.813]                   3L)]
[17:41:50.813]             }
[17:41:50.813]             function(cond) {
[17:41:50.813]                 is_error <- inherits(cond, "error")
[17:41:50.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:50.813]                   NULL)
[17:41:50.813]                 if (is_error) {
[17:41:50.813]                   sessionInformation <- function() {
[17:41:50.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:50.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:50.813]                       search = base::search(), system = base::Sys.info())
[17:41:50.813]                   }
[17:41:50.813]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:50.813]                     cond$call), session = sessionInformation(), 
[17:41:50.813]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:50.813]                   signalCondition(cond)
[17:41:50.813]                 }
[17:41:50.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:50.813]                 "immediateCondition"))) {
[17:41:50.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:50.813]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:50.813]                   if (TRUE && !signal) {
[17:41:50.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.813]                     {
[17:41:50.813]                       inherits <- base::inherits
[17:41:50.813]                       invokeRestart <- base::invokeRestart
[17:41:50.813]                       is.null <- base::is.null
[17:41:50.813]                       muffled <- FALSE
[17:41:50.813]                       if (inherits(cond, "message")) {
[17:41:50.813]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.813]                         if (muffled) 
[17:41:50.813]                           invokeRestart("muffleMessage")
[17:41:50.813]                       }
[17:41:50.813]                       else if (inherits(cond, "warning")) {
[17:41:50.813]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.813]                         if (muffled) 
[17:41:50.813]                           invokeRestart("muffleWarning")
[17:41:50.813]                       }
[17:41:50.813]                       else if (inherits(cond, "condition")) {
[17:41:50.813]                         if (!is.null(pattern)) {
[17:41:50.813]                           computeRestarts <- base::computeRestarts
[17:41:50.813]                           grepl <- base::grepl
[17:41:50.813]                           restarts <- computeRestarts(cond)
[17:41:50.813]                           for (restart in restarts) {
[17:41:50.813]                             name <- restart$name
[17:41:50.813]                             if (is.null(name)) 
[17:41:50.813]                               next
[17:41:50.813]                             if (!grepl(pattern, name)) 
[17:41:50.813]                               next
[17:41:50.813]                             invokeRestart(restart)
[17:41:50.813]                             muffled <- TRUE
[17:41:50.813]                             break
[17:41:50.813]                           }
[17:41:50.813]                         }
[17:41:50.813]                       }
[17:41:50.813]                       invisible(muffled)
[17:41:50.813]                     }
[17:41:50.813]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.813]                   }
[17:41:50.813]                 }
[17:41:50.813]                 else {
[17:41:50.813]                   if (TRUE) {
[17:41:50.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.813]                     {
[17:41:50.813]                       inherits <- base::inherits
[17:41:50.813]                       invokeRestart <- base::invokeRestart
[17:41:50.813]                       is.null <- base::is.null
[17:41:50.813]                       muffled <- FALSE
[17:41:50.813]                       if (inherits(cond, "message")) {
[17:41:50.813]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.813]                         if (muffled) 
[17:41:50.813]                           invokeRestart("muffleMessage")
[17:41:50.813]                       }
[17:41:50.813]                       else if (inherits(cond, "warning")) {
[17:41:50.813]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.813]                         if (muffled) 
[17:41:50.813]                           invokeRestart("muffleWarning")
[17:41:50.813]                       }
[17:41:50.813]                       else if (inherits(cond, "condition")) {
[17:41:50.813]                         if (!is.null(pattern)) {
[17:41:50.813]                           computeRestarts <- base::computeRestarts
[17:41:50.813]                           grepl <- base::grepl
[17:41:50.813]                           restarts <- computeRestarts(cond)
[17:41:50.813]                           for (restart in restarts) {
[17:41:50.813]                             name <- restart$name
[17:41:50.813]                             if (is.null(name)) 
[17:41:50.813]                               next
[17:41:50.813]                             if (!grepl(pattern, name)) 
[17:41:50.813]                               next
[17:41:50.813]                             invokeRestart(restart)
[17:41:50.813]                             muffled <- TRUE
[17:41:50.813]                             break
[17:41:50.813]                           }
[17:41:50.813]                         }
[17:41:50.813]                       }
[17:41:50.813]                       invisible(muffled)
[17:41:50.813]                     }
[17:41:50.813]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.813]                   }
[17:41:50.813]                 }
[17:41:50.813]             }
[17:41:50.813]         }))
[17:41:50.813]     }, error = function(ex) {
[17:41:50.813]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:50.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.813]                 ...future.rng), started = ...future.startTime, 
[17:41:50.813]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:50.813]             version = "1.8"), class = "FutureResult")
[17:41:50.813]     }, finally = {
[17:41:50.813]         if (!identical(...future.workdir, getwd())) 
[17:41:50.813]             setwd(...future.workdir)
[17:41:50.813]         {
[17:41:50.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:50.813]                 ...future.oldOptions$nwarnings <- NULL
[17:41:50.813]             }
[17:41:50.813]             base::options(...future.oldOptions)
[17:41:50.813]             if (.Platform$OS.type == "windows") {
[17:41:50.813]                 old_names <- names(...future.oldEnvVars)
[17:41:50.813]                 envs <- base::Sys.getenv()
[17:41:50.813]                 names <- names(envs)
[17:41:50.813]                 common <- intersect(names, old_names)
[17:41:50.813]                 added <- setdiff(names, old_names)
[17:41:50.813]                 removed <- setdiff(old_names, names)
[17:41:50.813]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:50.813]                   envs[common]]
[17:41:50.813]                 NAMES <- toupper(changed)
[17:41:50.813]                 args <- list()
[17:41:50.813]                 for (kk in seq_along(NAMES)) {
[17:41:50.813]                   name <- changed[[kk]]
[17:41:50.813]                   NAME <- NAMES[[kk]]
[17:41:50.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.813]                     next
[17:41:50.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.813]                 }
[17:41:50.813]                 NAMES <- toupper(added)
[17:41:50.813]                 for (kk in seq_along(NAMES)) {
[17:41:50.813]                   name <- added[[kk]]
[17:41:50.813]                   NAME <- NAMES[[kk]]
[17:41:50.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.813]                     next
[17:41:50.813]                   args[[name]] <- ""
[17:41:50.813]                 }
[17:41:50.813]                 NAMES <- toupper(removed)
[17:41:50.813]                 for (kk in seq_along(NAMES)) {
[17:41:50.813]                   name <- removed[[kk]]
[17:41:50.813]                   NAME <- NAMES[[kk]]
[17:41:50.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.813]                     next
[17:41:50.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.813]                 }
[17:41:50.813]                 if (length(args) > 0) 
[17:41:50.813]                   base::do.call(base::Sys.setenv, args = args)
[17:41:50.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:50.813]             }
[17:41:50.813]             else {
[17:41:50.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:50.813]             }
[17:41:50.813]             {
[17:41:50.813]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:50.813]                   0L) {
[17:41:50.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:50.813]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:50.813]                   base::options(opts)
[17:41:50.813]                 }
[17:41:50.813]                 {
[17:41:50.813]                   {
[17:41:50.813]                     NULL
[17:41:50.813]                     RNGkind("Mersenne-Twister")
[17:41:50.813]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:50.813]                       inherits = FALSE)
[17:41:50.813]                   }
[17:41:50.813]                   options(future.plan = NULL)
[17:41:50.813]                   if (is.na(NA_character_)) 
[17:41:50.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:50.813]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:50.813]                   {
[17:41:50.813]                     future <- SequentialFuture(..., envir = envir)
[17:41:50.813]                     if (!future$lazy) 
[17:41:50.813]                       future <- run(future)
[17:41:50.813]                     invisible(future)
[17:41:50.813]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:50.813]                 }
[17:41:50.813]             }
[17:41:50.813]         }
[17:41:50.813]     })
[17:41:50.813]     if (TRUE) {
[17:41:50.813]         base::sink(type = "output", split = FALSE)
[17:41:50.813]         if (TRUE) {
[17:41:50.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:50.813]         }
[17:41:50.813]         else {
[17:41:50.813]             ...future.result["stdout"] <- base::list(NULL)
[17:41:50.813]         }
[17:41:50.813]         base::close(...future.stdout)
[17:41:50.813]         ...future.stdout <- NULL
[17:41:50.813]     }
[17:41:50.813]     ...future.result$conditions <- ...future.conditions
[17:41:50.813]     ...future.result$finished <- base::Sys.time()
[17:41:50.813]     ...future.result
[17:41:50.813] }
[17:41:50.815] assign_globals() ...
[17:41:50.815] List of 4
[17:41:50.815]  $ ii   : int 1
[17:41:50.815]  $ n    : int 4
[17:41:50.815]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[17:41:50.815]   ..- attr(*, "region")=List of 2
[17:41:50.815]   .. ..$ xrange: num [1:2] -2.25 -0.781
[17:41:50.815]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[17:41:50.815]   ..- attr(*, "tile")= int [1:2] 1 1
[17:41:50.815]  $ delay:function (counts)  
[17:41:50.815]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:50.815]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d887048> 
[17:41:50.815]  - attr(*, "where")=List of 4
[17:41:50.815]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:50.815]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:50.815]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:50.815]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:50.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:50.815]  - attr(*, "resolved")= logi FALSE
[17:41:50.815]  - attr(*, "total_size")= num 14584
[17:41:50.815]  - attr(*, "already-done")= logi TRUE
[17:41:50.821] - copied ‘ii’ to environment
[17:41:50.821] - copied ‘n’ to environment
[17:41:50.822] - copied ‘C’ to environment
[17:41:50.822] - reassign environment for ‘delay’
[17:41:50.822] - copied ‘delay’ to environment
[17:41:50.822] assign_globals() ... done
[17:41:50.822] plan(): Setting new future strategy stack:
[17:41:50.822] List of future strategies:
[17:41:50.822] 1. sequential:
[17:41:50.822]    - args: function (..., envir = parent.frame())
[17:41:50.822]    - tweaked: FALSE
[17:41:50.822]    - call: NULL
[17:41:50.823] plan(): nbrOfWorkers() = 1
[17:41:50.839] plan(): Setting new future strategy stack:
[17:41:50.839] List of future strategies:
[17:41:50.839] 1. sequential:
[17:41:50.839]    - args: function (..., envir = parent.frame())
[17:41:50.839]    - tweaked: FALSE
[17:41:50.839]    - call: plan(strategy)
[17:41:50.840] plan(): nbrOfWorkers() = 1
[17:41:50.840] SequentialFuture started (and completed)
[17:41:50.840] signalConditions() ...
[17:41:50.840]  - include = ‘immediateCondition’
[17:41:50.840]  - exclude = 
[17:41:50.840]  - resignal = FALSE
[17:41:50.840]  - Number of conditions: 2
[17:41:50.841] signalConditions() ... done
[17:41:50.841] - Launch lazy future ... done
[17:41:50.841] run() for ‘SequentialFuture’ ... done
[17:41:50.841] - run() ... done
[17:41:50.841] - resolved() ...
[17:41:50.841] resolved() for ‘SequentialFuture’ ...
[17:41:50.841] - state: ‘finished’
[17:41:50.841] - run: TRUE
[17:41:50.841] - result: ‘FutureResult’
[17:41:50.841] resolved() for ‘SequentialFuture’ ... done
[17:41:50.841] - resolved: TRUE
[17:41:50.842] - resolved() ... done
[17:41:50.842] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[17:41:50.842] signalConditions() ...
[17:41:50.842]  - include = ‘immediateCondition’
[17:41:50.842]  - exclude = 
[17:41:50.842]  - resignal = FALSE
[17:41:50.842]  - Number of conditions: 2
[17:41:50.842] signalConditions() ... done
[17:41:50.842] Future state: ‘finished’
[17:41:50.842] signalConditions() ...
[17:41:50.843]  - include = ‘condition’
[17:41:50.843]  - exclude = ‘immediateCondition’
[17:41:50.843]  - resignal = TRUE
[17:41:50.843]  - Number of conditions: 2
[17:41:50.843]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[17:41:50.843]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:50.844] signalConditions() ... done
[17:41:50.845] resolved() for ‘Future’ ...
[17:41:50.845] - state: ‘created’
[17:41:50.845] - run: TRUE
[17:41:50.846] - run() ...
[17:41:50.846] run() for ‘Future’ ...
[17:41:50.846] - state: ‘created’
[17:41:50.846] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:50.846] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:50.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:50.846]   - Field: ‘label’
[17:41:50.847]   - Field: ‘local’
[17:41:50.847]   - Field: ‘owner’
[17:41:50.847]   - Field: ‘envir’
[17:41:50.847]   - Field: ‘packages’
[17:41:50.847]   - Field: ‘gc’
[17:41:50.847]   - Field: ‘conditions’
[17:41:50.847]   - Field: ‘expr’
[17:41:50.847]   - Field: ‘uuid’
[17:41:50.847]   - Field: ‘seed’
[17:41:50.847]   - Field: ‘version’
[17:41:50.847]   - Field: ‘result’
[17:41:50.848]   - Field: ‘asynchronous’
[17:41:50.848]   - Field: ‘calls’
[17:41:50.848]   - Field: ‘globals’
[17:41:50.848]   - Field: ‘stdout’
[17:41:50.848]   - Field: ‘earlySignal’
[17:41:50.848]   - Field: ‘lazy’
[17:41:50.848]   - Field: ‘state’
[17:41:50.848] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:50.848] - Launch lazy future ...
[17:41:50.849] Packages needed by the future expression (n = 1): ‘future’
[17:41:50.849] Packages needed by future strategies (n = 0): <none>
[17:41:50.849] {
[17:41:50.849]     {
[17:41:50.849]         {
[17:41:50.849]             ...future.startTime <- base::Sys.time()
[17:41:50.849]             {
[17:41:50.849]                 {
[17:41:50.849]                   {
[17:41:50.849]                     {
[17:41:50.849]                       base::local({
[17:41:50.849]                         has_future <- base::requireNamespace("future", 
[17:41:50.849]                           quietly = TRUE)
[17:41:50.849]                         if (has_future) {
[17:41:50.849]                           ns <- base::getNamespace("future")
[17:41:50.849]                           version <- ns[[".package"]][["version"]]
[17:41:50.849]                           if (is.null(version)) 
[17:41:50.849]                             version <- utils::packageVersion("future")
[17:41:50.849]                         }
[17:41:50.849]                         else {
[17:41:50.849]                           version <- NULL
[17:41:50.849]                         }
[17:41:50.849]                         if (!has_future || version < "1.8.0") {
[17:41:50.849]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:50.849]                             "", base::R.version$version.string), 
[17:41:50.849]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:50.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:50.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:50.849]                               "release", "version")], collapse = " "), 
[17:41:50.849]                             hostname = base::Sys.info()[["nodename"]])
[17:41:50.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:50.849]                             info)
[17:41:50.849]                           info <- base::paste(info, collapse = "; ")
[17:41:50.849]                           if (!has_future) {
[17:41:50.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:50.849]                               info)
[17:41:50.849]                           }
[17:41:50.849]                           else {
[17:41:50.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:50.849]                               info, version)
[17:41:50.849]                           }
[17:41:50.849]                           base::stop(msg)
[17:41:50.849]                         }
[17:41:50.849]                       })
[17:41:50.849]                     }
[17:41:50.849]                     base::local({
[17:41:50.849]                       for (pkg in "future") {
[17:41:50.849]                         base::loadNamespace(pkg)
[17:41:50.849]                         base::library(pkg, character.only = TRUE)
[17:41:50.849]                       }
[17:41:50.849]                     })
[17:41:50.849]                   }
[17:41:50.849]                   options(future.plan = NULL)
[17:41:50.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:50.849]                 }
[17:41:50.849]                 ...future.workdir <- getwd()
[17:41:50.849]             }
[17:41:50.849]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:50.849]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:50.849]         }
[17:41:50.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:50.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:50.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:50.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:50.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:50.849]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:50.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:50.849]             base::names(...future.oldOptions))
[17:41:50.849]     }
[17:41:50.849]     if (FALSE) {
[17:41:50.849]     }
[17:41:50.849]     else {
[17:41:50.849]         if (TRUE) {
[17:41:50.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:50.849]                 open = "w")
[17:41:50.849]         }
[17:41:50.849]         else {
[17:41:50.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:50.849]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:50.849]         }
[17:41:50.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:50.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:50.849]             base::sink(type = "output", split = FALSE)
[17:41:50.849]             base::close(...future.stdout)
[17:41:50.849]         }, add = TRUE)
[17:41:50.849]     }
[17:41:50.849]     ...future.frame <- base::sys.nframe()
[17:41:50.849]     ...future.conditions <- base::list()
[17:41:50.849]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:50.849]     if (FALSE) {
[17:41:50.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:50.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:50.849]     }
[17:41:50.849]     ...future.result <- base::tryCatch({
[17:41:50.849]         base::withCallingHandlers({
[17:41:50.849]             ...future.value <- base::withVisible(base::local({
[17:41:50.849]                 message(sprintf("Calculating tile #%d of %d ...", 
[17:41:50.849]                   ii, n), appendLF = FALSE)
[17:41:50.849]                 fit <- mandelbrot(C)
[17:41:50.849]                 delay(fit)
[17:41:50.849]                 message(" done")
[17:41:50.849]                 fit
[17:41:50.849]             }))
[17:41:50.849]             future::FutureResult(value = ...future.value$value, 
[17:41:50.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.849]                   ...future.rng), globalenv = if (FALSE) 
[17:41:50.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:50.849]                     ...future.globalenv.names))
[17:41:50.849]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:50.849]         }, condition = base::local({
[17:41:50.849]             c <- base::c
[17:41:50.849]             inherits <- base::inherits
[17:41:50.849]             invokeRestart <- base::invokeRestart
[17:41:50.849]             length <- base::length
[17:41:50.849]             list <- base::list
[17:41:50.849]             seq.int <- base::seq.int
[17:41:50.849]             signalCondition <- base::signalCondition
[17:41:50.849]             sys.calls <- base::sys.calls
[17:41:50.849]             `[[` <- base::`[[`
[17:41:50.849]             `+` <- base::`+`
[17:41:50.849]             `<<-` <- base::`<<-`
[17:41:50.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:50.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:50.849]                   3L)]
[17:41:50.849]             }
[17:41:50.849]             function(cond) {
[17:41:50.849]                 is_error <- inherits(cond, "error")
[17:41:50.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:50.849]                   NULL)
[17:41:50.849]                 if (is_error) {
[17:41:50.849]                   sessionInformation <- function() {
[17:41:50.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:50.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:50.849]                       search = base::search(), system = base::Sys.info())
[17:41:50.849]                   }
[17:41:50.849]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:50.849]                     cond$call), session = sessionInformation(), 
[17:41:50.849]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:50.849]                   signalCondition(cond)
[17:41:50.849]                 }
[17:41:50.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:50.849]                 "immediateCondition"))) {
[17:41:50.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:50.849]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:50.849]                   if (TRUE && !signal) {
[17:41:50.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.849]                     {
[17:41:50.849]                       inherits <- base::inherits
[17:41:50.849]                       invokeRestart <- base::invokeRestart
[17:41:50.849]                       is.null <- base::is.null
[17:41:50.849]                       muffled <- FALSE
[17:41:50.849]                       if (inherits(cond, "message")) {
[17:41:50.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.849]                         if (muffled) 
[17:41:50.849]                           invokeRestart("muffleMessage")
[17:41:50.849]                       }
[17:41:50.849]                       else if (inherits(cond, "warning")) {
[17:41:50.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.849]                         if (muffled) 
[17:41:50.849]                           invokeRestart("muffleWarning")
[17:41:50.849]                       }
[17:41:50.849]                       else if (inherits(cond, "condition")) {
[17:41:50.849]                         if (!is.null(pattern)) {
[17:41:50.849]                           computeRestarts <- base::computeRestarts
[17:41:50.849]                           grepl <- base::grepl
[17:41:50.849]                           restarts <- computeRestarts(cond)
[17:41:50.849]                           for (restart in restarts) {
[17:41:50.849]                             name <- restart$name
[17:41:50.849]                             if (is.null(name)) 
[17:41:50.849]                               next
[17:41:50.849]                             if (!grepl(pattern, name)) 
[17:41:50.849]                               next
[17:41:50.849]                             invokeRestart(restart)
[17:41:50.849]                             muffled <- TRUE
[17:41:50.849]                             break
[17:41:50.849]                           }
[17:41:50.849]                         }
[17:41:50.849]                       }
[17:41:50.849]                       invisible(muffled)
[17:41:50.849]                     }
[17:41:50.849]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.849]                   }
[17:41:50.849]                 }
[17:41:50.849]                 else {
[17:41:50.849]                   if (TRUE) {
[17:41:50.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.849]                     {
[17:41:50.849]                       inherits <- base::inherits
[17:41:50.849]                       invokeRestart <- base::invokeRestart
[17:41:50.849]                       is.null <- base::is.null
[17:41:50.849]                       muffled <- FALSE
[17:41:50.849]                       if (inherits(cond, "message")) {
[17:41:50.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.849]                         if (muffled) 
[17:41:50.849]                           invokeRestart("muffleMessage")
[17:41:50.849]                       }
[17:41:50.849]                       else if (inherits(cond, "warning")) {
[17:41:50.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.849]                         if (muffled) 
[17:41:50.849]                           invokeRestart("muffleWarning")
[17:41:50.849]                       }
[17:41:50.849]                       else if (inherits(cond, "condition")) {
[17:41:50.849]                         if (!is.null(pattern)) {
[17:41:50.849]                           computeRestarts <- base::computeRestarts
[17:41:50.849]                           grepl <- base::grepl
[17:41:50.849]                           restarts <- computeRestarts(cond)
[17:41:50.849]                           for (restart in restarts) {
[17:41:50.849]                             name <- restart$name
[17:41:50.849]                             if (is.null(name)) 
[17:41:50.849]                               next
[17:41:50.849]                             if (!grepl(pattern, name)) 
[17:41:50.849]                               next
[17:41:50.849]                             invokeRestart(restart)
[17:41:50.849]                             muffled <- TRUE
[17:41:50.849]                             break
[17:41:50.849]                           }
[17:41:50.849]                         }
[17:41:50.849]                       }
[17:41:50.849]                       invisible(muffled)
[17:41:50.849]                     }
[17:41:50.849]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.849]                   }
[17:41:50.849]                 }
[17:41:50.849]             }
[17:41:50.849]         }))
[17:41:50.849]     }, error = function(ex) {
[17:41:50.849]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:50.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.849]                 ...future.rng), started = ...future.startTime, 
[17:41:50.849]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:50.849]             version = "1.8"), class = "FutureResult")
[17:41:50.849]     }, finally = {
[17:41:50.849]         if (!identical(...future.workdir, getwd())) 
[17:41:50.849]             setwd(...future.workdir)
[17:41:50.849]         {
[17:41:50.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:50.849]                 ...future.oldOptions$nwarnings <- NULL
[17:41:50.849]             }
[17:41:50.849]             base::options(...future.oldOptions)
[17:41:50.849]             if (.Platform$OS.type == "windows") {
[17:41:50.849]                 old_names <- names(...future.oldEnvVars)
[17:41:50.849]                 envs <- base::Sys.getenv()
[17:41:50.849]                 names <- names(envs)
[17:41:50.849]                 common <- intersect(names, old_names)
[17:41:50.849]                 added <- setdiff(names, old_names)
[17:41:50.849]                 removed <- setdiff(old_names, names)
[17:41:50.849]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:50.849]                   envs[common]]
[17:41:50.849]                 NAMES <- toupper(changed)
[17:41:50.849]                 args <- list()
[17:41:50.849]                 for (kk in seq_along(NAMES)) {
[17:41:50.849]                   name <- changed[[kk]]
[17:41:50.849]                   NAME <- NAMES[[kk]]
[17:41:50.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.849]                     next
[17:41:50.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.849]                 }
[17:41:50.849]                 NAMES <- toupper(added)
[17:41:50.849]                 for (kk in seq_along(NAMES)) {
[17:41:50.849]                   name <- added[[kk]]
[17:41:50.849]                   NAME <- NAMES[[kk]]
[17:41:50.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.849]                     next
[17:41:50.849]                   args[[name]] <- ""
[17:41:50.849]                 }
[17:41:50.849]                 NAMES <- toupper(removed)
[17:41:50.849]                 for (kk in seq_along(NAMES)) {
[17:41:50.849]                   name <- removed[[kk]]
[17:41:50.849]                   NAME <- NAMES[[kk]]
[17:41:50.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.849]                     next
[17:41:50.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.849]                 }
[17:41:50.849]                 if (length(args) > 0) 
[17:41:50.849]                   base::do.call(base::Sys.setenv, args = args)
[17:41:50.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:50.849]             }
[17:41:50.849]             else {
[17:41:50.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:50.849]             }
[17:41:50.849]             {
[17:41:50.849]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:50.849]                   0L) {
[17:41:50.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:50.849]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:50.849]                   base::options(opts)
[17:41:50.849]                 }
[17:41:50.849]                 {
[17:41:50.849]                   {
[17:41:50.849]                     NULL
[17:41:50.849]                     RNGkind("Mersenne-Twister")
[17:41:50.849]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:50.849]                       inherits = FALSE)
[17:41:50.849]                   }
[17:41:50.849]                   options(future.plan = NULL)
[17:41:50.849]                   if (is.na(NA_character_)) 
[17:41:50.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:50.849]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:50.849]                   {
[17:41:50.849]                     future <- SequentialFuture(..., envir = envir)
[17:41:50.849]                     if (!future$lazy) 
[17:41:50.849]                       future <- run(future)
[17:41:50.849]                     invisible(future)
[17:41:50.849]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:50.849]                 }
[17:41:50.849]             }
[17:41:50.849]         }
[17:41:50.849]     })
[17:41:50.849]     if (TRUE) {
[17:41:50.849]         base::sink(type = "output", split = FALSE)
[17:41:50.849]         if (TRUE) {
[17:41:50.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:50.849]         }
[17:41:50.849]         else {
[17:41:50.849]             ...future.result["stdout"] <- base::list(NULL)
[17:41:50.849]         }
[17:41:50.849]         base::close(...future.stdout)
[17:41:50.849]         ...future.stdout <- NULL
[17:41:50.849]     }
[17:41:50.849]     ...future.result$conditions <- ...future.conditions
[17:41:50.849]     ...future.result$finished <- base::Sys.time()
[17:41:50.849]     ...future.result
[17:41:50.849] }
[17:41:50.851] assign_globals() ...
[17:41:50.851] List of 4
[17:41:50.851]  $ ii   : int 2
[17:41:50.851]  $ n    : int 4
[17:41:50.851]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[17:41:50.851]   ..- attr(*, "region")=List of 2
[17:41:50.851]   .. ..$ xrange: num [1:2] -0.719 0.75
[17:41:50.851]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[17:41:50.851]   ..- attr(*, "tile")= int [1:2] 1 2
[17:41:50.851]  $ delay:function (counts)  
[17:41:50.851]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:50.851]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d887048> 
[17:41:50.851]  - attr(*, "where")=List of 4
[17:41:50.851]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:50.851]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:50.851]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:50.851]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:50.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:50.851]  - attr(*, "resolved")= logi FALSE
[17:41:50.851]  - attr(*, "total_size")= num 14584
[17:41:50.851]  - attr(*, "already-done")= logi TRUE
[17:41:50.857] - copied ‘ii’ to environment
[17:41:50.857] - copied ‘n’ to environment
[17:41:50.857] - copied ‘C’ to environment
[17:41:50.858] - reassign environment for ‘delay’
[17:41:50.858] - copied ‘delay’ to environment
[17:41:50.858] assign_globals() ... done
[17:41:50.858] plan(): Setting new future strategy stack:
[17:41:50.858] List of future strategies:
[17:41:50.858] 1. sequential:
[17:41:50.858]    - args: function (..., envir = parent.frame())
[17:41:50.858]    - tweaked: FALSE
[17:41:50.858]    - call: NULL
[17:41:50.859] plan(): nbrOfWorkers() = 1
[17:41:50.874] plan(): Setting new future strategy stack:
[17:41:50.874] List of future strategies:
[17:41:50.874] 1. sequential:
[17:41:50.874]    - args: function (..., envir = parent.frame())
[17:41:50.874]    - tweaked: FALSE
[17:41:50.874]    - call: plan(strategy)
[17:41:50.875] plan(): nbrOfWorkers() = 1
[17:41:50.875] SequentialFuture started (and completed)
[17:41:50.875] signalConditions() ...
[17:41:50.875]  - include = ‘immediateCondition’
[17:41:50.876]  - exclude = 
[17:41:50.876]  - resignal = FALSE
[17:41:50.876]  - Number of conditions: 2
[17:41:50.876] signalConditions() ... done
[17:41:50.876] - Launch lazy future ... done
[17:41:50.876] run() for ‘SequentialFuture’ ... done
[17:41:50.877] - run() ... done
[17:41:50.877] - resolved() ...
[17:41:50.877] resolved() for ‘SequentialFuture’ ...
[17:41:50.877] - state: ‘finished’
[17:41:50.877] - run: TRUE
[17:41:50.877] - result: ‘FutureResult’
[17:41:50.877] resolved() for ‘SequentialFuture’ ... done
[17:41:50.877] - resolved: TRUE
[17:41:50.877] - resolved() ... done
[17:41:50.877] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[17:41:50.878] signalConditions() ...
[17:41:50.878]  - include = ‘immediateCondition’
[17:41:50.878]  - exclude = 
[17:41:50.878]  - resignal = FALSE
[17:41:50.878]  - Number of conditions: 2
[17:41:50.878] signalConditions() ... done
[17:41:50.878] Future state: ‘finished’
[17:41:50.878] signalConditions() ...
[17:41:50.878]  - include = ‘condition’
[17:41:50.879]  - exclude = ‘immediateCondition’
[17:41:50.879]  - resignal = TRUE
[17:41:50.879]  - Number of conditions: 2
[17:41:50.879]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[17:41:50.879]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:50.879] signalConditions() ... done
[17:41:50.880] resolved() for ‘Future’ ...
[17:41:50.880] - state: ‘created’
[17:41:50.880] - run: TRUE
[17:41:50.880] - run() ...
[17:41:50.880] run() for ‘Future’ ...
[17:41:50.880] - state: ‘created’
[17:41:50.881] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:50.881] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:50.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:50.881]   - Field: ‘label’
[17:41:50.881]   - Field: ‘local’
[17:41:50.881]   - Field: ‘owner’
[17:41:50.881]   - Field: ‘envir’
[17:41:50.882]   - Field: ‘packages’
[17:41:50.882]   - Field: ‘gc’
[17:41:50.882]   - Field: ‘conditions’
[17:41:50.882]   - Field: ‘expr’
[17:41:50.882]   - Field: ‘uuid’
[17:41:50.882]   - Field: ‘seed’
[17:41:50.882]   - Field: ‘version’
[17:41:50.882]   - Field: ‘result’
[17:41:50.882]   - Field: ‘asynchronous’
[17:41:50.882]   - Field: ‘calls’
[17:41:50.882]   - Field: ‘globals’
[17:41:50.883]   - Field: ‘stdout’
[17:41:50.883]   - Field: ‘earlySignal’
[17:41:50.883]   - Field: ‘lazy’
[17:41:50.883]   - Field: ‘state’
[17:41:50.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:50.883] - Launch lazy future ...
[17:41:50.883] Packages needed by the future expression (n = 1): ‘future’
[17:41:50.883] Packages needed by future strategies (n = 0): <none>
[17:41:50.884] {
[17:41:50.884]     {
[17:41:50.884]         {
[17:41:50.884]             ...future.startTime <- base::Sys.time()
[17:41:50.884]             {
[17:41:50.884]                 {
[17:41:50.884]                   {
[17:41:50.884]                     {
[17:41:50.884]                       base::local({
[17:41:50.884]                         has_future <- base::requireNamespace("future", 
[17:41:50.884]                           quietly = TRUE)
[17:41:50.884]                         if (has_future) {
[17:41:50.884]                           ns <- base::getNamespace("future")
[17:41:50.884]                           version <- ns[[".package"]][["version"]]
[17:41:50.884]                           if (is.null(version)) 
[17:41:50.884]                             version <- utils::packageVersion("future")
[17:41:50.884]                         }
[17:41:50.884]                         else {
[17:41:50.884]                           version <- NULL
[17:41:50.884]                         }
[17:41:50.884]                         if (!has_future || version < "1.8.0") {
[17:41:50.884]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:50.884]                             "", base::R.version$version.string), 
[17:41:50.884]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:50.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:50.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:50.884]                               "release", "version")], collapse = " "), 
[17:41:50.884]                             hostname = base::Sys.info()[["nodename"]])
[17:41:50.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:50.884]                             info)
[17:41:50.884]                           info <- base::paste(info, collapse = "; ")
[17:41:50.884]                           if (!has_future) {
[17:41:50.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:50.884]                               info)
[17:41:50.884]                           }
[17:41:50.884]                           else {
[17:41:50.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:50.884]                               info, version)
[17:41:50.884]                           }
[17:41:50.884]                           base::stop(msg)
[17:41:50.884]                         }
[17:41:50.884]                       })
[17:41:50.884]                     }
[17:41:50.884]                     base::local({
[17:41:50.884]                       for (pkg in "future") {
[17:41:50.884]                         base::loadNamespace(pkg)
[17:41:50.884]                         base::library(pkg, character.only = TRUE)
[17:41:50.884]                       }
[17:41:50.884]                     })
[17:41:50.884]                   }
[17:41:50.884]                   options(future.plan = NULL)
[17:41:50.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:50.884]                 }
[17:41:50.884]                 ...future.workdir <- getwd()
[17:41:50.884]             }
[17:41:50.884]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:50.884]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:50.884]         }
[17:41:50.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:50.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:50.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:50.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:50.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:50.884]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:50.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:50.884]             base::names(...future.oldOptions))
[17:41:50.884]     }
[17:41:50.884]     if (FALSE) {
[17:41:50.884]     }
[17:41:50.884]     else {
[17:41:50.884]         if (TRUE) {
[17:41:50.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:50.884]                 open = "w")
[17:41:50.884]         }
[17:41:50.884]         else {
[17:41:50.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:50.884]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:50.884]         }
[17:41:50.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:50.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:50.884]             base::sink(type = "output", split = FALSE)
[17:41:50.884]             base::close(...future.stdout)
[17:41:50.884]         }, add = TRUE)
[17:41:50.884]     }
[17:41:50.884]     ...future.frame <- base::sys.nframe()
[17:41:50.884]     ...future.conditions <- base::list()
[17:41:50.884]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:50.884]     if (FALSE) {
[17:41:50.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:50.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:50.884]     }
[17:41:50.884]     ...future.result <- base::tryCatch({
[17:41:50.884]         base::withCallingHandlers({
[17:41:50.884]             ...future.value <- base::withVisible(base::local({
[17:41:50.884]                 message(sprintf("Calculating tile #%d of %d ...", 
[17:41:50.884]                   ii, n), appendLF = FALSE)
[17:41:50.884]                 fit <- mandelbrot(C)
[17:41:50.884]                 delay(fit)
[17:41:50.884]                 message(" done")
[17:41:50.884]                 fit
[17:41:50.884]             }))
[17:41:50.884]             future::FutureResult(value = ...future.value$value, 
[17:41:50.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.884]                   ...future.rng), globalenv = if (FALSE) 
[17:41:50.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:50.884]                     ...future.globalenv.names))
[17:41:50.884]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:50.884]         }, condition = base::local({
[17:41:50.884]             c <- base::c
[17:41:50.884]             inherits <- base::inherits
[17:41:50.884]             invokeRestart <- base::invokeRestart
[17:41:50.884]             length <- base::length
[17:41:50.884]             list <- base::list
[17:41:50.884]             seq.int <- base::seq.int
[17:41:50.884]             signalCondition <- base::signalCondition
[17:41:50.884]             sys.calls <- base::sys.calls
[17:41:50.884]             `[[` <- base::`[[`
[17:41:50.884]             `+` <- base::`+`
[17:41:50.884]             `<<-` <- base::`<<-`
[17:41:50.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:50.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:50.884]                   3L)]
[17:41:50.884]             }
[17:41:50.884]             function(cond) {
[17:41:50.884]                 is_error <- inherits(cond, "error")
[17:41:50.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:50.884]                   NULL)
[17:41:50.884]                 if (is_error) {
[17:41:50.884]                   sessionInformation <- function() {
[17:41:50.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:50.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:50.884]                       search = base::search(), system = base::Sys.info())
[17:41:50.884]                   }
[17:41:50.884]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:50.884]                     cond$call), session = sessionInformation(), 
[17:41:50.884]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:50.884]                   signalCondition(cond)
[17:41:50.884]                 }
[17:41:50.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:50.884]                 "immediateCondition"))) {
[17:41:50.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:50.884]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:50.884]                   if (TRUE && !signal) {
[17:41:50.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.884]                     {
[17:41:50.884]                       inherits <- base::inherits
[17:41:50.884]                       invokeRestart <- base::invokeRestart
[17:41:50.884]                       is.null <- base::is.null
[17:41:50.884]                       muffled <- FALSE
[17:41:50.884]                       if (inherits(cond, "message")) {
[17:41:50.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.884]                         if (muffled) 
[17:41:50.884]                           invokeRestart("muffleMessage")
[17:41:50.884]                       }
[17:41:50.884]                       else if (inherits(cond, "warning")) {
[17:41:50.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.884]                         if (muffled) 
[17:41:50.884]                           invokeRestart("muffleWarning")
[17:41:50.884]                       }
[17:41:50.884]                       else if (inherits(cond, "condition")) {
[17:41:50.884]                         if (!is.null(pattern)) {
[17:41:50.884]                           computeRestarts <- base::computeRestarts
[17:41:50.884]                           grepl <- base::grepl
[17:41:50.884]                           restarts <- computeRestarts(cond)
[17:41:50.884]                           for (restart in restarts) {
[17:41:50.884]                             name <- restart$name
[17:41:50.884]                             if (is.null(name)) 
[17:41:50.884]                               next
[17:41:50.884]                             if (!grepl(pattern, name)) 
[17:41:50.884]                               next
[17:41:50.884]                             invokeRestart(restart)
[17:41:50.884]                             muffled <- TRUE
[17:41:50.884]                             break
[17:41:50.884]                           }
[17:41:50.884]                         }
[17:41:50.884]                       }
[17:41:50.884]                       invisible(muffled)
[17:41:50.884]                     }
[17:41:50.884]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.884]                   }
[17:41:50.884]                 }
[17:41:50.884]                 else {
[17:41:50.884]                   if (TRUE) {
[17:41:50.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.884]                     {
[17:41:50.884]                       inherits <- base::inherits
[17:41:50.884]                       invokeRestart <- base::invokeRestart
[17:41:50.884]                       is.null <- base::is.null
[17:41:50.884]                       muffled <- FALSE
[17:41:50.884]                       if (inherits(cond, "message")) {
[17:41:50.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.884]                         if (muffled) 
[17:41:50.884]                           invokeRestart("muffleMessage")
[17:41:50.884]                       }
[17:41:50.884]                       else if (inherits(cond, "warning")) {
[17:41:50.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.884]                         if (muffled) 
[17:41:50.884]                           invokeRestart("muffleWarning")
[17:41:50.884]                       }
[17:41:50.884]                       else if (inherits(cond, "condition")) {
[17:41:50.884]                         if (!is.null(pattern)) {
[17:41:50.884]                           computeRestarts <- base::computeRestarts
[17:41:50.884]                           grepl <- base::grepl
[17:41:50.884]                           restarts <- computeRestarts(cond)
[17:41:50.884]                           for (restart in restarts) {
[17:41:50.884]                             name <- restart$name
[17:41:50.884]                             if (is.null(name)) 
[17:41:50.884]                               next
[17:41:50.884]                             if (!grepl(pattern, name)) 
[17:41:50.884]                               next
[17:41:50.884]                             invokeRestart(restart)
[17:41:50.884]                             muffled <- TRUE
[17:41:50.884]                             break
[17:41:50.884]                           }
[17:41:50.884]                         }
[17:41:50.884]                       }
[17:41:50.884]                       invisible(muffled)
[17:41:50.884]                     }
[17:41:50.884]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.884]                   }
[17:41:50.884]                 }
[17:41:50.884]             }
[17:41:50.884]         }))
[17:41:50.884]     }, error = function(ex) {
[17:41:50.884]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:50.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.884]                 ...future.rng), started = ...future.startTime, 
[17:41:50.884]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:50.884]             version = "1.8"), class = "FutureResult")
[17:41:50.884]     }, finally = {
[17:41:50.884]         if (!identical(...future.workdir, getwd())) 
[17:41:50.884]             setwd(...future.workdir)
[17:41:50.884]         {
[17:41:50.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:50.884]                 ...future.oldOptions$nwarnings <- NULL
[17:41:50.884]             }
[17:41:50.884]             base::options(...future.oldOptions)
[17:41:50.884]             if (.Platform$OS.type == "windows") {
[17:41:50.884]                 old_names <- names(...future.oldEnvVars)
[17:41:50.884]                 envs <- base::Sys.getenv()
[17:41:50.884]                 names <- names(envs)
[17:41:50.884]                 common <- intersect(names, old_names)
[17:41:50.884]                 added <- setdiff(names, old_names)
[17:41:50.884]                 removed <- setdiff(old_names, names)
[17:41:50.884]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:50.884]                   envs[common]]
[17:41:50.884]                 NAMES <- toupper(changed)
[17:41:50.884]                 args <- list()
[17:41:50.884]                 for (kk in seq_along(NAMES)) {
[17:41:50.884]                   name <- changed[[kk]]
[17:41:50.884]                   NAME <- NAMES[[kk]]
[17:41:50.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.884]                     next
[17:41:50.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.884]                 }
[17:41:50.884]                 NAMES <- toupper(added)
[17:41:50.884]                 for (kk in seq_along(NAMES)) {
[17:41:50.884]                   name <- added[[kk]]
[17:41:50.884]                   NAME <- NAMES[[kk]]
[17:41:50.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.884]                     next
[17:41:50.884]                   args[[name]] <- ""
[17:41:50.884]                 }
[17:41:50.884]                 NAMES <- toupper(removed)
[17:41:50.884]                 for (kk in seq_along(NAMES)) {
[17:41:50.884]                   name <- removed[[kk]]
[17:41:50.884]                   NAME <- NAMES[[kk]]
[17:41:50.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.884]                     next
[17:41:50.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.884]                 }
[17:41:50.884]                 if (length(args) > 0) 
[17:41:50.884]                   base::do.call(base::Sys.setenv, args = args)
[17:41:50.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:50.884]             }
[17:41:50.884]             else {
[17:41:50.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:50.884]             }
[17:41:50.884]             {
[17:41:50.884]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:50.884]                   0L) {
[17:41:50.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:50.884]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:50.884]                   base::options(opts)
[17:41:50.884]                 }
[17:41:50.884]                 {
[17:41:50.884]                   {
[17:41:50.884]                     NULL
[17:41:50.884]                     RNGkind("Mersenne-Twister")
[17:41:50.884]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:50.884]                       inherits = FALSE)
[17:41:50.884]                   }
[17:41:50.884]                   options(future.plan = NULL)
[17:41:50.884]                   if (is.na(NA_character_)) 
[17:41:50.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:50.884]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:50.884]                   {
[17:41:50.884]                     future <- SequentialFuture(..., envir = envir)
[17:41:50.884]                     if (!future$lazy) 
[17:41:50.884]                       future <- run(future)
[17:41:50.884]                     invisible(future)
[17:41:50.884]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:50.884]                 }
[17:41:50.884]             }
[17:41:50.884]         }
[17:41:50.884]     })
[17:41:50.884]     if (TRUE) {
[17:41:50.884]         base::sink(type = "output", split = FALSE)
[17:41:50.884]         if (TRUE) {
[17:41:50.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:50.884]         }
[17:41:50.884]         else {
[17:41:50.884]             ...future.result["stdout"] <- base::list(NULL)
[17:41:50.884]         }
[17:41:50.884]         base::close(...future.stdout)
[17:41:50.884]         ...future.stdout <- NULL
[17:41:50.884]     }
[17:41:50.884]     ...future.result$conditions <- ...future.conditions
[17:41:50.884]     ...future.result$finished <- base::Sys.time()
[17:41:50.884]     ...future.result
[17:41:50.884] }
[17:41:50.886] assign_globals() ...
[17:41:50.886] List of 4
[17:41:50.886]  $ ii   : int 3
[17:41:50.886]  $ n    : int 4
[17:41:50.886]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[17:41:50.886]   ..- attr(*, "region")=List of 2
[17:41:50.886]   .. ..$ xrange: num [1:2] -2.25 -0.781
[17:41:50.886]   .. ..$ yrange: num [1:2] 0.0306 1.5
[17:41:50.886]   ..- attr(*, "tile")= int [1:2] 2 1
[17:41:50.886]  $ delay:function (counts)  
[17:41:50.886]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:50.886]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d887048> 
[17:41:50.886]  - attr(*, "where")=List of 4
[17:41:50.886]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:50.886]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:50.886]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:50.886]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:50.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:50.886]  - attr(*, "resolved")= logi FALSE
[17:41:50.886]  - attr(*, "total_size")= num 14584
[17:41:50.886]  - attr(*, "already-done")= logi TRUE
[17:41:50.892] - copied ‘ii’ to environment
[17:41:50.892] - copied ‘n’ to environment
[17:41:50.892] - copied ‘C’ to environment
[17:41:50.892] - reassign environment for ‘delay’
[17:41:50.893] - copied ‘delay’ to environment
[17:41:50.893] assign_globals() ... done
[17:41:50.893] plan(): Setting new future strategy stack:
[17:41:50.893] List of future strategies:
[17:41:50.893] 1. sequential:
[17:41:50.893]    - args: function (..., envir = parent.frame())
[17:41:50.893]    - tweaked: FALSE
[17:41:50.893]    - call: NULL
[17:41:50.894] plan(): nbrOfWorkers() = 1
[17:41:50.911] plan(): Setting new future strategy stack:
[17:41:50.911] List of future strategies:
[17:41:50.911] 1. sequential:
[17:41:50.911]    - args: function (..., envir = parent.frame())
[17:41:50.911]    - tweaked: FALSE
[17:41:50.911]    - call: plan(strategy)
[17:41:50.912] plan(): nbrOfWorkers() = 1
[17:41:50.912] SequentialFuture started (and completed)
[17:41:50.912] signalConditions() ...
[17:41:50.912]  - include = ‘immediateCondition’
[17:41:50.912]  - exclude = 
[17:41:50.912]  - resignal = FALSE
[17:41:50.912]  - Number of conditions: 2
[17:41:50.912] signalConditions() ... done
[17:41:50.912] - Launch lazy future ... done
[17:41:50.912] run() for ‘SequentialFuture’ ... done
[17:41:50.913] - run() ... done
[17:41:50.913] - resolved() ...
[17:41:50.913] resolved() for ‘SequentialFuture’ ...
[17:41:50.913] - state: ‘finished’
[17:41:50.913] - run: TRUE
[17:41:50.913] - result: ‘FutureResult’
[17:41:50.913] resolved() for ‘SequentialFuture’ ... done
[17:41:50.913] - resolved: TRUE
[17:41:50.913] - resolved() ... done
[17:41:50.913] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[17:41:50.914] signalConditions() ...
[17:41:50.914]  - include = ‘immediateCondition’
[17:41:50.914]  - exclude = 
[17:41:50.914]  - resignal = FALSE
[17:41:50.914]  - Number of conditions: 2
[17:41:50.914] signalConditions() ... done
[17:41:50.914] Future state: ‘finished’
[17:41:50.914] signalConditions() ...
[17:41:50.914]  - include = ‘condition’
[17:41:50.914]  - exclude = ‘immediateCondition’
[17:41:50.915]  - resignal = TRUE
[17:41:50.915]  - Number of conditions: 2
[17:41:50.915]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[17:41:50.915]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:50.915] signalConditions() ... done
[17:41:50.916] resolved() for ‘Future’ ...
[17:41:50.916] - state: ‘created’
[17:41:50.916] - run: TRUE
[17:41:50.916] - run() ...
[17:41:50.916] run() for ‘Future’ ...
[17:41:50.916] - state: ‘created’
[17:41:50.916] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:50.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:50.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:50.917]   - Field: ‘label’
[17:41:50.917]   - Field: ‘local’
[17:41:50.917]   - Field: ‘owner’
[17:41:50.917]   - Field: ‘envir’
[17:41:50.917]   - Field: ‘packages’
[17:41:50.917]   - Field: ‘gc’
[17:41:50.917]   - Field: ‘conditions’
[17:41:50.917]   - Field: ‘expr’
[17:41:50.918]   - Field: ‘uuid’
[17:41:50.918]   - Field: ‘seed’
[17:41:50.918]   - Field: ‘version’
[17:41:50.918]   - Field: ‘result’
[17:41:50.918]   - Field: ‘asynchronous’
[17:41:50.918]   - Field: ‘calls’
[17:41:50.918]   - Field: ‘globals’
[17:41:50.918]   - Field: ‘stdout’
[17:41:50.918]   - Field: ‘earlySignal’
[17:41:50.918]   - Field: ‘lazy’
[17:41:50.919]   - Field: ‘state’
[17:41:50.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:50.919] - Launch lazy future ...
[17:41:50.919] Packages needed by the future expression (n = 1): ‘future’
[17:41:50.919] Packages needed by future strategies (n = 0): <none>
[17:41:50.920] {
[17:41:50.920]     {
[17:41:50.920]         {
[17:41:50.920]             ...future.startTime <- base::Sys.time()
[17:41:50.920]             {
[17:41:50.920]                 {
[17:41:50.920]                   {
[17:41:50.920]                     {
[17:41:50.920]                       base::local({
[17:41:50.920]                         has_future <- base::requireNamespace("future", 
[17:41:50.920]                           quietly = TRUE)
[17:41:50.920]                         if (has_future) {
[17:41:50.920]                           ns <- base::getNamespace("future")
[17:41:50.920]                           version <- ns[[".package"]][["version"]]
[17:41:50.920]                           if (is.null(version)) 
[17:41:50.920]                             version <- utils::packageVersion("future")
[17:41:50.920]                         }
[17:41:50.920]                         else {
[17:41:50.920]                           version <- NULL
[17:41:50.920]                         }
[17:41:50.920]                         if (!has_future || version < "1.8.0") {
[17:41:50.920]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:50.920]                             "", base::R.version$version.string), 
[17:41:50.920]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:50.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:50.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:50.920]                               "release", "version")], collapse = " "), 
[17:41:50.920]                             hostname = base::Sys.info()[["nodename"]])
[17:41:50.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:50.920]                             info)
[17:41:50.920]                           info <- base::paste(info, collapse = "; ")
[17:41:50.920]                           if (!has_future) {
[17:41:50.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:50.920]                               info)
[17:41:50.920]                           }
[17:41:50.920]                           else {
[17:41:50.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:50.920]                               info, version)
[17:41:50.920]                           }
[17:41:50.920]                           base::stop(msg)
[17:41:50.920]                         }
[17:41:50.920]                       })
[17:41:50.920]                     }
[17:41:50.920]                     base::local({
[17:41:50.920]                       for (pkg in "future") {
[17:41:50.920]                         base::loadNamespace(pkg)
[17:41:50.920]                         base::library(pkg, character.only = TRUE)
[17:41:50.920]                       }
[17:41:50.920]                     })
[17:41:50.920]                   }
[17:41:50.920]                   options(future.plan = NULL)
[17:41:50.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:50.920]                 }
[17:41:50.920]                 ...future.workdir <- getwd()
[17:41:50.920]             }
[17:41:50.920]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:50.920]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:50.920]         }
[17:41:50.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:50.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:50.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:50.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:50.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:50.920]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:50.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:50.920]             base::names(...future.oldOptions))
[17:41:50.920]     }
[17:41:50.920]     if (FALSE) {
[17:41:50.920]     }
[17:41:50.920]     else {
[17:41:50.920]         if (TRUE) {
[17:41:50.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:50.920]                 open = "w")
[17:41:50.920]         }
[17:41:50.920]         else {
[17:41:50.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:50.920]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:50.920]         }
[17:41:50.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:50.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:50.920]             base::sink(type = "output", split = FALSE)
[17:41:50.920]             base::close(...future.stdout)
[17:41:50.920]         }, add = TRUE)
[17:41:50.920]     }
[17:41:50.920]     ...future.frame <- base::sys.nframe()
[17:41:50.920]     ...future.conditions <- base::list()
[17:41:50.920]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:50.920]     if (FALSE) {
[17:41:50.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:50.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:50.920]     }
[17:41:50.920]     ...future.result <- base::tryCatch({
[17:41:50.920]         base::withCallingHandlers({
[17:41:50.920]             ...future.value <- base::withVisible(base::local({
[17:41:50.920]                 message(sprintf("Calculating tile #%d of %d ...", 
[17:41:50.920]                   ii, n), appendLF = FALSE)
[17:41:50.920]                 fit <- mandelbrot(C)
[17:41:50.920]                 delay(fit)
[17:41:50.920]                 message(" done")
[17:41:50.920]                 fit
[17:41:50.920]             }))
[17:41:50.920]             future::FutureResult(value = ...future.value$value, 
[17:41:50.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.920]                   ...future.rng), globalenv = if (FALSE) 
[17:41:50.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:50.920]                     ...future.globalenv.names))
[17:41:50.920]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:50.920]         }, condition = base::local({
[17:41:50.920]             c <- base::c
[17:41:50.920]             inherits <- base::inherits
[17:41:50.920]             invokeRestart <- base::invokeRestart
[17:41:50.920]             length <- base::length
[17:41:50.920]             list <- base::list
[17:41:50.920]             seq.int <- base::seq.int
[17:41:50.920]             signalCondition <- base::signalCondition
[17:41:50.920]             sys.calls <- base::sys.calls
[17:41:50.920]             `[[` <- base::`[[`
[17:41:50.920]             `+` <- base::`+`
[17:41:50.920]             `<<-` <- base::`<<-`
[17:41:50.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:50.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:50.920]                   3L)]
[17:41:50.920]             }
[17:41:50.920]             function(cond) {
[17:41:50.920]                 is_error <- inherits(cond, "error")
[17:41:50.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:50.920]                   NULL)
[17:41:50.920]                 if (is_error) {
[17:41:50.920]                   sessionInformation <- function() {
[17:41:50.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:50.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:50.920]                       search = base::search(), system = base::Sys.info())
[17:41:50.920]                   }
[17:41:50.920]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:50.920]                     cond$call), session = sessionInformation(), 
[17:41:50.920]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:50.920]                   signalCondition(cond)
[17:41:50.920]                 }
[17:41:50.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:50.920]                 "immediateCondition"))) {
[17:41:50.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:50.920]                   ...future.conditions[[length(...future.conditions) + 
[17:41:50.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:50.920]                   if (TRUE && !signal) {
[17:41:50.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.920]                     {
[17:41:50.920]                       inherits <- base::inherits
[17:41:50.920]                       invokeRestart <- base::invokeRestart
[17:41:50.920]                       is.null <- base::is.null
[17:41:50.920]                       muffled <- FALSE
[17:41:50.920]                       if (inherits(cond, "message")) {
[17:41:50.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.920]                         if (muffled) 
[17:41:50.920]                           invokeRestart("muffleMessage")
[17:41:50.920]                       }
[17:41:50.920]                       else if (inherits(cond, "warning")) {
[17:41:50.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.920]                         if (muffled) 
[17:41:50.920]                           invokeRestart("muffleWarning")
[17:41:50.920]                       }
[17:41:50.920]                       else if (inherits(cond, "condition")) {
[17:41:50.920]                         if (!is.null(pattern)) {
[17:41:50.920]                           computeRestarts <- base::computeRestarts
[17:41:50.920]                           grepl <- base::grepl
[17:41:50.920]                           restarts <- computeRestarts(cond)
[17:41:50.920]                           for (restart in restarts) {
[17:41:50.920]                             name <- restart$name
[17:41:50.920]                             if (is.null(name)) 
[17:41:50.920]                               next
[17:41:50.920]                             if (!grepl(pattern, name)) 
[17:41:50.920]                               next
[17:41:50.920]                             invokeRestart(restart)
[17:41:50.920]                             muffled <- TRUE
[17:41:50.920]                             break
[17:41:50.920]                           }
[17:41:50.920]                         }
[17:41:50.920]                       }
[17:41:50.920]                       invisible(muffled)
[17:41:50.920]                     }
[17:41:50.920]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.920]                   }
[17:41:50.920]                 }
[17:41:50.920]                 else {
[17:41:50.920]                   if (TRUE) {
[17:41:50.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:50.920]                     {
[17:41:50.920]                       inherits <- base::inherits
[17:41:50.920]                       invokeRestart <- base::invokeRestart
[17:41:50.920]                       is.null <- base::is.null
[17:41:50.920]                       muffled <- FALSE
[17:41:50.920]                       if (inherits(cond, "message")) {
[17:41:50.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:50.920]                         if (muffled) 
[17:41:50.920]                           invokeRestart("muffleMessage")
[17:41:50.920]                       }
[17:41:50.920]                       else if (inherits(cond, "warning")) {
[17:41:50.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:50.920]                         if (muffled) 
[17:41:50.920]                           invokeRestart("muffleWarning")
[17:41:50.920]                       }
[17:41:50.920]                       else if (inherits(cond, "condition")) {
[17:41:50.920]                         if (!is.null(pattern)) {
[17:41:50.920]                           computeRestarts <- base::computeRestarts
[17:41:50.920]                           grepl <- base::grepl
[17:41:50.920]                           restarts <- computeRestarts(cond)
[17:41:50.920]                           for (restart in restarts) {
[17:41:50.920]                             name <- restart$name
[17:41:50.920]                             if (is.null(name)) 
[17:41:50.920]                               next
[17:41:50.920]                             if (!grepl(pattern, name)) 
[17:41:50.920]                               next
[17:41:50.920]                             invokeRestart(restart)
[17:41:50.920]                             muffled <- TRUE
[17:41:50.920]                             break
[17:41:50.920]                           }
[17:41:50.920]                         }
[17:41:50.920]                       }
[17:41:50.920]                       invisible(muffled)
[17:41:50.920]                     }
[17:41:50.920]                     muffleCondition(cond, pattern = "^muffle")
[17:41:50.920]                   }
[17:41:50.920]                 }
[17:41:50.920]             }
[17:41:50.920]         }))
[17:41:50.920]     }, error = function(ex) {
[17:41:50.920]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:50.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:50.920]                 ...future.rng), started = ...future.startTime, 
[17:41:50.920]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:50.920]             version = "1.8"), class = "FutureResult")
[17:41:50.920]     }, finally = {
[17:41:50.920]         if (!identical(...future.workdir, getwd())) 
[17:41:50.920]             setwd(...future.workdir)
[17:41:50.920]         {
[17:41:50.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:50.920]                 ...future.oldOptions$nwarnings <- NULL
[17:41:50.920]             }
[17:41:50.920]             base::options(...future.oldOptions)
[17:41:50.920]             if (.Platform$OS.type == "windows") {
[17:41:50.920]                 old_names <- names(...future.oldEnvVars)
[17:41:50.920]                 envs <- base::Sys.getenv()
[17:41:50.920]                 names <- names(envs)
[17:41:50.920]                 common <- intersect(names, old_names)
[17:41:50.920]                 added <- setdiff(names, old_names)
[17:41:50.920]                 removed <- setdiff(old_names, names)
[17:41:50.920]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:50.920]                   envs[common]]
[17:41:50.920]                 NAMES <- toupper(changed)
[17:41:50.920]                 args <- list()
[17:41:50.920]                 for (kk in seq_along(NAMES)) {
[17:41:50.920]                   name <- changed[[kk]]
[17:41:50.920]                   NAME <- NAMES[[kk]]
[17:41:50.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.920]                     next
[17:41:50.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.920]                 }
[17:41:50.920]                 NAMES <- toupper(added)
[17:41:50.920]                 for (kk in seq_along(NAMES)) {
[17:41:50.920]                   name <- added[[kk]]
[17:41:50.920]                   NAME <- NAMES[[kk]]
[17:41:50.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.920]                     next
[17:41:50.920]                   args[[name]] <- ""
[17:41:50.920]                 }
[17:41:50.920]                 NAMES <- toupper(removed)
[17:41:50.920]                 for (kk in seq_along(NAMES)) {
[17:41:50.920]                   name <- removed[[kk]]
[17:41:50.920]                   NAME <- NAMES[[kk]]
[17:41:50.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:50.920]                     next
[17:41:50.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:50.920]                 }
[17:41:50.920]                 if (length(args) > 0) 
[17:41:50.920]                   base::do.call(base::Sys.setenv, args = args)
[17:41:50.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:50.920]             }
[17:41:50.920]             else {
[17:41:50.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:50.920]             }
[17:41:50.920]             {
[17:41:50.920]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:50.920]                   0L) {
[17:41:50.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:50.920]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:50.920]                   base::options(opts)
[17:41:50.920]                 }
[17:41:50.920]                 {
[17:41:50.920]                   {
[17:41:50.920]                     NULL
[17:41:50.920]                     RNGkind("Mersenne-Twister")
[17:41:50.920]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:50.920]                       inherits = FALSE)
[17:41:50.920]                   }
[17:41:50.920]                   options(future.plan = NULL)
[17:41:50.920]                   if (is.na(NA_character_)) 
[17:41:50.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:50.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:50.920]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:50.920]                   {
[17:41:50.920]                     future <- SequentialFuture(..., envir = envir)
[17:41:50.920]                     if (!future$lazy) 
[17:41:50.920]                       future <- run(future)
[17:41:50.920]                     invisible(future)
[17:41:50.920]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:50.920]                 }
[17:41:50.920]             }
[17:41:50.920]         }
[17:41:50.920]     })
[17:41:50.920]     if (TRUE) {
[17:41:50.920]         base::sink(type = "output", split = FALSE)
[17:41:50.920]         if (TRUE) {
[17:41:50.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:50.920]         }
[17:41:50.920]         else {
[17:41:50.920]             ...future.result["stdout"] <- base::list(NULL)
[17:41:50.920]         }
[17:41:50.920]         base::close(...future.stdout)
[17:41:50.920]         ...future.stdout <- NULL
[17:41:50.920]     }
[17:41:50.920]     ...future.result$conditions <- ...future.conditions
[17:41:50.920]     ...future.result$finished <- base::Sys.time()
[17:41:50.920]     ...future.result
[17:41:50.920] }
[17:41:50.921] assign_globals() ...
[17:41:50.921] List of 4
[17:41:50.921]  $ ii   : int 4
[17:41:50.921]  $ n    : int 4
[17:41:50.921]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[17:41:50.921]   ..- attr(*, "region")=List of 2
[17:41:50.921]   .. ..$ xrange: num [1:2] -0.719 0.75
[17:41:50.921]   .. ..$ yrange: num [1:2] 0.0306 1.5
[17:41:50.921]   ..- attr(*, "tile")= int [1:2] 2 2
[17:41:50.921]  $ delay:function (counts)  
[17:41:50.921]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:50.921]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d887048> 
[17:41:50.921]  - attr(*, "where")=List of 4
[17:41:50.921]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:50.921]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:50.921]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:50.921]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:50.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:50.921]  - attr(*, "resolved")= logi FALSE
[17:41:50.921]  - attr(*, "total_size")= num 14584
[17:41:50.921]  - attr(*, "already-done")= logi TRUE
[17:41:50.928] - copied ‘ii’ to environment
[17:41:50.928] - copied ‘n’ to environment
[17:41:50.928] - copied ‘C’ to environment
[17:41:50.928] - reassign environment for ‘delay’
[17:41:50.928] - copied ‘delay’ to environment
[17:41:50.928] assign_globals() ... done
[17:41:50.928] plan(): Setting new future strategy stack:
[17:41:50.929] List of future strategies:
[17:41:50.929] 1. sequential:
[17:41:50.929]    - args: function (..., envir = parent.frame())
[17:41:50.929]    - tweaked: FALSE
[17:41:50.929]    - call: NULL
[17:41:50.929] plan(): nbrOfWorkers() = 1
[17:41:50.944] plan(): Setting new future strategy stack:
[17:41:50.944] List of future strategies:
[17:41:50.944] 1. sequential:
[17:41:50.944]    - args: function (..., envir = parent.frame())
[17:41:50.944]    - tweaked: FALSE
[17:41:50.944]    - call: plan(strategy)
[17:41:50.945] plan(): nbrOfWorkers() = 1
[17:41:50.945] SequentialFuture started (and completed)
[17:41:50.945] signalConditions() ...
[17:41:50.945]  - include = ‘immediateCondition’
[17:41:50.945]  - exclude = 
[17:41:50.945]  - resignal = FALSE
[17:41:50.946]  - Number of conditions: 2
[17:41:50.946] signalConditions() ... done
[17:41:50.946] - Launch lazy future ... done
[17:41:50.946] run() for ‘SequentialFuture’ ... done
[17:41:50.946] - run() ... done
[17:41:50.946] - resolved() ...
[17:41:50.946] resolved() for ‘SequentialFuture’ ...
[17:41:50.946] - state: ‘finished’
[17:41:50.946] - run: TRUE
[17:41:50.946] - result: ‘FutureResult’
[17:41:50.946] resolved() for ‘SequentialFuture’ ... done
[17:41:50.947] - resolved: TRUE
[17:41:50.947] - resolved() ... done
[17:41:50.947] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[17:41:50.947] signalConditions() ...
[17:41:50.947]  - include = ‘immediateCondition’
[17:41:50.947]  - exclude = 
[17:41:50.947]  - resignal = FALSE
[17:41:50.947]  - Number of conditions: 2
[17:41:50.947] signalConditions() ... done
[17:41:50.948] Future state: ‘finished’
[17:41:50.948] signalConditions() ...
[17:41:50.948]  - include = ‘condition’
[17:41:50.948]  - exclude = ‘immediateCondition’
[17:41:50.948]  - resignal = TRUE
[17:41:50.948]  - Number of conditions: 2
[17:41:50.948]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[17:41:50.948]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:50.948] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[17:41:50.955] plan(): Setting new future strategy stack:
[17:41:50.955] List of future strategies:
[17:41:50.955] 1. multicore:
[17:41:50.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:50.955]    - tweaked: FALSE
[17:41:50.955]    - call: plan(strategy)
[17:41:50.959] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[17:41:50.965] getGlobalsAndPackages() ...
[17:41:50.966] Searching for globals...
[17:41:50.969] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.969] Searching for globals ... DONE
[17:41:50.970] Resolving globals: FALSE
[17:41:50.970] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.971] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.971] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.971] - packages: [1] ‘future’
[17:41:50.971] getGlobalsAndPackages() ... DONE
 2[17:41:50.975] getGlobalsAndPackages() ...
[17:41:50.975] Searching for globals...
[17:41:50.979] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.979] Searching for globals ... DONE
[17:41:50.979] Resolving globals: FALSE
[17:41:50.979] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.980] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.980] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.980] - packages: [1] ‘future’
[17:41:50.980] getGlobalsAndPackages() ... DONE
 3[17:41:50.980] getGlobalsAndPackages() ...
[17:41:50.981] Searching for globals...
[17:41:50.984] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.984] Searching for globals ... DONE
[17:41:50.984] Resolving globals: FALSE
[17:41:50.985] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.985] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.985] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.985] - packages: [1] ‘future’
[17:41:50.985] getGlobalsAndPackages() ... DONE
 4[17:41:50.986] getGlobalsAndPackages() ...
[17:41:50.986] Searching for globals...
[17:41:50.989] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:50.989] Searching for globals ... DONE
[17:41:50.989] Resolving globals: FALSE
[17:41:50.990] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:50.990] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:50.990] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:50.990] - packages: [1] ‘future’
[17:41:50.991] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[17:41:50.999] resolved() for ‘Future’ ...
[17:41:50.999] - state: ‘created’
[17:41:50.999] - run: TRUE
[17:41:50.999] - run() ...
[17:41:51.000] run() for ‘Future’ ...
[17:41:51.000] - state: ‘created’
[17:41:51.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:51.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:51.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:51.004]   - Field: ‘label’
[17:41:51.004]   - Field: ‘local’
[17:41:51.004]   - Field: ‘owner’
[17:41:51.005]   - Field: ‘envir’
[17:41:51.005]   - Field: ‘workers’
[17:41:51.005]   - Field: ‘packages’
[17:41:51.005]   - Field: ‘gc’
[17:41:51.005]   - Field: ‘job’
[17:41:51.005]   - Field: ‘conditions’
[17:41:51.005]   - Field: ‘expr’
[17:41:51.005]   - Field: ‘uuid’
[17:41:51.005]   - Field: ‘seed’
[17:41:51.005]   - Field: ‘version’
[17:41:51.005]   - Field: ‘result’
[17:41:51.006]   - Field: ‘asynchronous’
[17:41:51.006]   - Field: ‘calls’
[17:41:51.006]   - Field: ‘globals’
[17:41:51.006]   - Field: ‘stdout’
[17:41:51.006]   - Field: ‘earlySignal’
[17:41:51.006]   - Field: ‘lazy’
[17:41:51.006]   - Field: ‘state’
[17:41:51.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:51.006] - Launch lazy future ...
[17:41:51.007] Packages needed by the future expression (n = 1): ‘future’
[17:41:51.008] Packages needed by future strategies (n = 0): <none>
[17:41:51.008] {
[17:41:51.008]     {
[17:41:51.008]         {
[17:41:51.008]             ...future.startTime <- base::Sys.time()
[17:41:51.008]             {
[17:41:51.008]                 {
[17:41:51.008]                   {
[17:41:51.008]                     {
[17:41:51.008]                       {
[17:41:51.008]                         base::local({
[17:41:51.008]                           has_future <- base::requireNamespace("future", 
[17:41:51.008]                             quietly = TRUE)
[17:41:51.008]                           if (has_future) {
[17:41:51.008]                             ns <- base::getNamespace("future")
[17:41:51.008]                             version <- ns[[".package"]][["version"]]
[17:41:51.008]                             if (is.null(version)) 
[17:41:51.008]                               version <- utils::packageVersion("future")
[17:41:51.008]                           }
[17:41:51.008]                           else {
[17:41:51.008]                             version <- NULL
[17:41:51.008]                           }
[17:41:51.008]                           if (!has_future || version < "1.8.0") {
[17:41:51.008]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:51.008]                               "", base::R.version$version.string), 
[17:41:51.008]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:51.008]                                 base::R.version$platform, 8 * 
[17:41:51.008]                                   base::.Machine$sizeof.pointer), 
[17:41:51.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:51.008]                                 "release", "version")], collapse = " "), 
[17:41:51.008]                               hostname = base::Sys.info()[["nodename"]])
[17:41:51.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:51.008]                               info)
[17:41:51.008]                             info <- base::paste(info, collapse = "; ")
[17:41:51.008]                             if (!has_future) {
[17:41:51.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:51.008]                                 info)
[17:41:51.008]                             }
[17:41:51.008]                             else {
[17:41:51.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:51.008]                                 info, version)
[17:41:51.008]                             }
[17:41:51.008]                             base::stop(msg)
[17:41:51.008]                           }
[17:41:51.008]                         })
[17:41:51.008]                       }
[17:41:51.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:51.008]                       base::options(mc.cores = 1L)
[17:41:51.008]                     }
[17:41:51.008]                     base::local({
[17:41:51.008]                       for (pkg in "future") {
[17:41:51.008]                         base::loadNamespace(pkg)
[17:41:51.008]                         base::library(pkg, character.only = TRUE)
[17:41:51.008]                       }
[17:41:51.008]                     })
[17:41:51.008]                   }
[17:41:51.008]                   options(future.plan = NULL)
[17:41:51.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:51.008]                 }
[17:41:51.008]                 ...future.workdir <- getwd()
[17:41:51.008]             }
[17:41:51.008]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:51.008]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:51.008]         }
[17:41:51.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:51.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:51.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:51.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:51.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:51.008]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:51.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:51.008]             base::names(...future.oldOptions))
[17:41:51.008]     }
[17:41:51.008]     if (FALSE) {
[17:41:51.008]     }
[17:41:51.008]     else {
[17:41:51.008]         if (TRUE) {
[17:41:51.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:51.008]                 open = "w")
[17:41:51.008]         }
[17:41:51.008]         else {
[17:41:51.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:51.008]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:51.008]         }
[17:41:51.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:51.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:51.008]             base::sink(type = "output", split = FALSE)
[17:41:51.008]             base::close(...future.stdout)
[17:41:51.008]         }, add = TRUE)
[17:41:51.008]     }
[17:41:51.008]     ...future.frame <- base::sys.nframe()
[17:41:51.008]     ...future.conditions <- base::list()
[17:41:51.008]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:51.008]     if (FALSE) {
[17:41:51.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:51.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:51.008]     }
[17:41:51.008]     ...future.result <- base::tryCatch({
[17:41:51.008]         base::withCallingHandlers({
[17:41:51.008]             ...future.value <- base::withVisible(base::local({
[17:41:51.008]                 withCallingHandlers({
[17:41:51.008]                   {
[17:41:51.008]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:51.008]                       ii, n), appendLF = FALSE)
[17:41:51.008]                     fit <- mandelbrot(C)
[17:41:51.008]                     delay(fit)
[17:41:51.008]                     message(" done")
[17:41:51.008]                     fit
[17:41:51.008]                   }
[17:41:51.008]                 }, immediateCondition = function(cond) {
[17:41:51.008]                   save_rds <- function (object, pathname, ...) 
[17:41:51.008]                   {
[17:41:51.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:51.008]                     if (file_test("-f", pathname_tmp)) {
[17:41:51.008]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:51.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.008]                         fi_tmp[["mtime"]])
[17:41:51.008]                     }
[17:41:51.008]                     tryCatch({
[17:41:51.008]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:51.008]                     }, error = function(ex) {
[17:41:51.008]                       msg <- conditionMessage(ex)
[17:41:51.008]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:51.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.008]                         fi_tmp[["mtime"]], msg)
[17:41:51.008]                       ex$message <- msg
[17:41:51.008]                       stop(ex)
[17:41:51.008]                     })
[17:41:51.008]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:51.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:51.008]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:51.008]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.008]                       fi <- file.info(pathname)
[17:41:51.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:51.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:51.008]                         fi[["size"]], fi[["mtime"]])
[17:41:51.008]                       stop(msg)
[17:41:51.008]                     }
[17:41:51.008]                     invisible(pathname)
[17:41:51.008]                   }
[17:41:51.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:51.008]                     rootPath = tempdir()) 
[17:41:51.008]                   {
[17:41:51.008]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:51.008]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:51.008]                       tmpdir = path, fileext = ".rds")
[17:41:51.008]                     save_rds(obj, file)
[17:41:51.008]                   }
[17:41:51.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpkaR8AW/.future/immediateConditions")
[17:41:51.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.008]                   {
[17:41:51.008]                     inherits <- base::inherits
[17:41:51.008]                     invokeRestart <- base::invokeRestart
[17:41:51.008]                     is.null <- base::is.null
[17:41:51.008]                     muffled <- FALSE
[17:41:51.008]                     if (inherits(cond, "message")) {
[17:41:51.008]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:51.008]                       if (muffled) 
[17:41:51.008]                         invokeRestart("muffleMessage")
[17:41:51.008]                     }
[17:41:51.008]                     else if (inherits(cond, "warning")) {
[17:41:51.008]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:51.008]                       if (muffled) 
[17:41:51.008]                         invokeRestart("muffleWarning")
[17:41:51.008]                     }
[17:41:51.008]                     else if (inherits(cond, "condition")) {
[17:41:51.008]                       if (!is.null(pattern)) {
[17:41:51.008]                         computeRestarts <- base::computeRestarts
[17:41:51.008]                         grepl <- base::grepl
[17:41:51.008]                         restarts <- computeRestarts(cond)
[17:41:51.008]                         for (restart in restarts) {
[17:41:51.008]                           name <- restart$name
[17:41:51.008]                           if (is.null(name)) 
[17:41:51.008]                             next
[17:41:51.008]                           if (!grepl(pattern, name)) 
[17:41:51.008]                             next
[17:41:51.008]                           invokeRestart(restart)
[17:41:51.008]                           muffled <- TRUE
[17:41:51.008]                           break
[17:41:51.008]                         }
[17:41:51.008]                       }
[17:41:51.008]                     }
[17:41:51.008]                     invisible(muffled)
[17:41:51.008]                   }
[17:41:51.008]                   muffleCondition(cond)
[17:41:51.008]                 })
[17:41:51.008]             }))
[17:41:51.008]             future::FutureResult(value = ...future.value$value, 
[17:41:51.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.008]                   ...future.rng), globalenv = if (FALSE) 
[17:41:51.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:51.008]                     ...future.globalenv.names))
[17:41:51.008]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:51.008]         }, condition = base::local({
[17:41:51.008]             c <- base::c
[17:41:51.008]             inherits <- base::inherits
[17:41:51.008]             invokeRestart <- base::invokeRestart
[17:41:51.008]             length <- base::length
[17:41:51.008]             list <- base::list
[17:41:51.008]             seq.int <- base::seq.int
[17:41:51.008]             signalCondition <- base::signalCondition
[17:41:51.008]             sys.calls <- base::sys.calls
[17:41:51.008]             `[[` <- base::`[[`
[17:41:51.008]             `+` <- base::`+`
[17:41:51.008]             `<<-` <- base::`<<-`
[17:41:51.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:51.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:51.008]                   3L)]
[17:41:51.008]             }
[17:41:51.008]             function(cond) {
[17:41:51.008]                 is_error <- inherits(cond, "error")
[17:41:51.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:51.008]                   NULL)
[17:41:51.008]                 if (is_error) {
[17:41:51.008]                   sessionInformation <- function() {
[17:41:51.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:51.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:51.008]                       search = base::search(), system = base::Sys.info())
[17:41:51.008]                   }
[17:41:51.008]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:51.008]                     cond$call), session = sessionInformation(), 
[17:41:51.008]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:51.008]                   signalCondition(cond)
[17:41:51.008]                 }
[17:41:51.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:51.008]                 "immediateCondition"))) {
[17:41:51.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:51.008]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:51.008]                   if (TRUE && !signal) {
[17:41:51.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.008]                     {
[17:41:51.008]                       inherits <- base::inherits
[17:41:51.008]                       invokeRestart <- base::invokeRestart
[17:41:51.008]                       is.null <- base::is.null
[17:41:51.008]                       muffled <- FALSE
[17:41:51.008]                       if (inherits(cond, "message")) {
[17:41:51.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.008]                         if (muffled) 
[17:41:51.008]                           invokeRestart("muffleMessage")
[17:41:51.008]                       }
[17:41:51.008]                       else if (inherits(cond, "warning")) {
[17:41:51.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.008]                         if (muffled) 
[17:41:51.008]                           invokeRestart("muffleWarning")
[17:41:51.008]                       }
[17:41:51.008]                       else if (inherits(cond, "condition")) {
[17:41:51.008]                         if (!is.null(pattern)) {
[17:41:51.008]                           computeRestarts <- base::computeRestarts
[17:41:51.008]                           grepl <- base::grepl
[17:41:51.008]                           restarts <- computeRestarts(cond)
[17:41:51.008]                           for (restart in restarts) {
[17:41:51.008]                             name <- restart$name
[17:41:51.008]                             if (is.null(name)) 
[17:41:51.008]                               next
[17:41:51.008]                             if (!grepl(pattern, name)) 
[17:41:51.008]                               next
[17:41:51.008]                             invokeRestart(restart)
[17:41:51.008]                             muffled <- TRUE
[17:41:51.008]                             break
[17:41:51.008]                           }
[17:41:51.008]                         }
[17:41:51.008]                       }
[17:41:51.008]                       invisible(muffled)
[17:41:51.008]                     }
[17:41:51.008]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.008]                   }
[17:41:51.008]                 }
[17:41:51.008]                 else {
[17:41:51.008]                   if (TRUE) {
[17:41:51.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.008]                     {
[17:41:51.008]                       inherits <- base::inherits
[17:41:51.008]                       invokeRestart <- base::invokeRestart
[17:41:51.008]                       is.null <- base::is.null
[17:41:51.008]                       muffled <- FALSE
[17:41:51.008]                       if (inherits(cond, "message")) {
[17:41:51.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.008]                         if (muffled) 
[17:41:51.008]                           invokeRestart("muffleMessage")
[17:41:51.008]                       }
[17:41:51.008]                       else if (inherits(cond, "warning")) {
[17:41:51.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.008]                         if (muffled) 
[17:41:51.008]                           invokeRestart("muffleWarning")
[17:41:51.008]                       }
[17:41:51.008]                       else if (inherits(cond, "condition")) {
[17:41:51.008]                         if (!is.null(pattern)) {
[17:41:51.008]                           computeRestarts <- base::computeRestarts
[17:41:51.008]                           grepl <- base::grepl
[17:41:51.008]                           restarts <- computeRestarts(cond)
[17:41:51.008]                           for (restart in restarts) {
[17:41:51.008]                             name <- restart$name
[17:41:51.008]                             if (is.null(name)) 
[17:41:51.008]                               next
[17:41:51.008]                             if (!grepl(pattern, name)) 
[17:41:51.008]                               next
[17:41:51.008]                             invokeRestart(restart)
[17:41:51.008]                             muffled <- TRUE
[17:41:51.008]                             break
[17:41:51.008]                           }
[17:41:51.008]                         }
[17:41:51.008]                       }
[17:41:51.008]                       invisible(muffled)
[17:41:51.008]                     }
[17:41:51.008]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.008]                   }
[17:41:51.008]                 }
[17:41:51.008]             }
[17:41:51.008]         }))
[17:41:51.008]     }, error = function(ex) {
[17:41:51.008]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:51.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.008]                 ...future.rng), started = ...future.startTime, 
[17:41:51.008]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:51.008]             version = "1.8"), class = "FutureResult")
[17:41:51.008]     }, finally = {
[17:41:51.008]         if (!identical(...future.workdir, getwd())) 
[17:41:51.008]             setwd(...future.workdir)
[17:41:51.008]         {
[17:41:51.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:51.008]                 ...future.oldOptions$nwarnings <- NULL
[17:41:51.008]             }
[17:41:51.008]             base::options(...future.oldOptions)
[17:41:51.008]             if (.Platform$OS.type == "windows") {
[17:41:51.008]                 old_names <- names(...future.oldEnvVars)
[17:41:51.008]                 envs <- base::Sys.getenv()
[17:41:51.008]                 names <- names(envs)
[17:41:51.008]                 common <- intersect(names, old_names)
[17:41:51.008]                 added <- setdiff(names, old_names)
[17:41:51.008]                 removed <- setdiff(old_names, names)
[17:41:51.008]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:51.008]                   envs[common]]
[17:41:51.008]                 NAMES <- toupper(changed)
[17:41:51.008]                 args <- list()
[17:41:51.008]                 for (kk in seq_along(NAMES)) {
[17:41:51.008]                   name <- changed[[kk]]
[17:41:51.008]                   NAME <- NAMES[[kk]]
[17:41:51.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.008]                     next
[17:41:51.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.008]                 }
[17:41:51.008]                 NAMES <- toupper(added)
[17:41:51.008]                 for (kk in seq_along(NAMES)) {
[17:41:51.008]                   name <- added[[kk]]
[17:41:51.008]                   NAME <- NAMES[[kk]]
[17:41:51.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.008]                     next
[17:41:51.008]                   args[[name]] <- ""
[17:41:51.008]                 }
[17:41:51.008]                 NAMES <- toupper(removed)
[17:41:51.008]                 for (kk in seq_along(NAMES)) {
[17:41:51.008]                   name <- removed[[kk]]
[17:41:51.008]                   NAME <- NAMES[[kk]]
[17:41:51.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.008]                     next
[17:41:51.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.008]                 }
[17:41:51.008]                 if (length(args) > 0) 
[17:41:51.008]                   base::do.call(base::Sys.setenv, args = args)
[17:41:51.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:51.008]             }
[17:41:51.008]             else {
[17:41:51.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:51.008]             }
[17:41:51.008]             {
[17:41:51.008]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:51.008]                   0L) {
[17:41:51.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:51.008]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:51.008]                   base::options(opts)
[17:41:51.008]                 }
[17:41:51.008]                 {
[17:41:51.008]                   {
[17:41:51.008]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:51.008]                     NULL
[17:41:51.008]                   }
[17:41:51.008]                   options(future.plan = NULL)
[17:41:51.008]                   if (is.na(NA_character_)) 
[17:41:51.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:51.008]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:51.008]                     envir = parent.frame()) 
[17:41:51.008]                   {
[17:41:51.008]                     default_workers <- missing(workers)
[17:41:51.008]                     if (is.function(workers)) 
[17:41:51.008]                       workers <- workers()
[17:41:51.008]                     workers <- structure(as.integer(workers), 
[17:41:51.008]                       class = class(workers))
[17:41:51.008]                     stop_if_not(is.finite(workers), workers >= 
[17:41:51.008]                       1L)
[17:41:51.008]                     if ((workers == 1L && !inherits(workers, 
[17:41:51.008]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:51.008]                       if (default_workers) 
[17:41:51.008]                         supportsMulticore(warn = TRUE)
[17:41:51.008]                       return(sequential(..., envir = envir))
[17:41:51.008]                     }
[17:41:51.008]                     oopts <- options(mc.cores = workers)
[17:41:51.008]                     on.exit(options(oopts))
[17:41:51.008]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:51.008]                       envir = envir)
[17:41:51.008]                     if (!future$lazy) 
[17:41:51.008]                       future <- run(future)
[17:41:51.008]                     invisible(future)
[17:41:51.008]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:51.008]                 }
[17:41:51.008]             }
[17:41:51.008]         }
[17:41:51.008]     })
[17:41:51.008]     if (TRUE) {
[17:41:51.008]         base::sink(type = "output", split = FALSE)
[17:41:51.008]         if (TRUE) {
[17:41:51.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:51.008]         }
[17:41:51.008]         else {
[17:41:51.008]             ...future.result["stdout"] <- base::list(NULL)
[17:41:51.008]         }
[17:41:51.008]         base::close(...future.stdout)
[17:41:51.008]         ...future.stdout <- NULL
[17:41:51.008]     }
[17:41:51.008]     ...future.result$conditions <- ...future.conditions
[17:41:51.008]     ...future.result$finished <- base::Sys.time()
[17:41:51.008]     ...future.result
[17:41:51.008] }
[17:41:51.011] assign_globals() ...
[17:41:51.011] List of 4
[17:41:51.011]  $ ii   : int 1
[17:41:51.011]  $ n    : int 4
[17:41:51.011]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[17:41:51.011]   ..- attr(*, "region")=List of 2
[17:41:51.011]   .. ..$ xrange: num [1:2] -2.25 -0.781
[17:41:51.011]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[17:41:51.011]   ..- attr(*, "tile")= int [1:2] 1 1
[17:41:51.011]  $ delay:function (counts)  
[17:41:51.011]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:51.011]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d9fb9f8> 
[17:41:51.011]  - attr(*, "where")=List of 4
[17:41:51.011]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:51.011]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:51.011]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:51.011]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:51.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:51.011]  - attr(*, "resolved")= logi FALSE
[17:41:51.011]  - attr(*, "total_size")= num 14584
[17:41:51.011]  - attr(*, "already-done")= logi TRUE
[17:41:51.017] - copied ‘ii’ to environment
[17:41:51.017] - copied ‘n’ to environment
[17:41:51.017] - copied ‘C’ to environment
[17:41:51.017] - reassign environment for ‘delay’
[17:41:51.017] - copied ‘delay’ to environment
[17:41:51.017] assign_globals() ... done
[17:41:51.017] requestCore(): workers = 2
[17:41:51.021] MulticoreFuture started
[17:41:51.021] - Launch lazy future ... done
[17:41:51.021] run() for ‘MulticoreFuture’ ... done
[17:41:51.022] - run() ... done
[17:41:51.022] - resolved() ...
[17:41:51.022] plan(): Setting new future strategy stack:
[17:41:51.022] List of future strategies:
[17:41:51.022] 1. sequential:
[17:41:51.022]    - args: function (..., envir = parent.frame())
[17:41:51.022]    - tweaked: FALSE
[17:41:51.022]    - call: NULL
[17:41:51.023] plan(): nbrOfWorkers() = 1
[17:41:51.026] plan(): Setting new future strategy stack:
[17:41:51.026] List of future strategies:
[17:41:51.026] 1. multicore:
[17:41:51.026]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:51.026]    - tweaked: FALSE
[17:41:51.026]    - call: plan(strategy)
[17:41:51.031] plan(): nbrOfWorkers() = 2
[17:41:51.033] - resolved: TRUE
[17:41:51.033] - resolved() ... done
[17:41:51.033] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[17:41:51.039] signalConditions() ...
[17:41:51.039]  - include = ‘immediateCondition’
[17:41:51.039]  - exclude = 
[17:41:51.039]  - resignal = FALSE
[17:41:51.039]  - Number of conditions: 2
[17:41:51.039] signalConditions() ... done
[17:41:51.039] signalConditions() ...
[17:41:51.040]  - include = ‘immediateCondition’
[17:41:51.040]  - exclude = 
[17:41:51.040]  - resignal = FALSE
[17:41:51.040]  - Number of conditions: 2
[17:41:51.040] signalConditions() ... done
[17:41:51.040] Future state: ‘finished’
[17:41:51.040] signalConditions() ...
[17:41:51.040]  - include = ‘condition’
[17:41:51.041]  - exclude = ‘immediateCondition’
[17:41:51.041]  - resignal = TRUE
[17:41:51.041]  - Number of conditions: 2
[17:41:51.041]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[17:41:51.041]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:51.041] signalConditions() ... done
[17:41:51.042] resolved() for ‘Future’ ...
[17:41:51.042] - state: ‘created’
[17:41:51.042] - run: TRUE
[17:41:51.042] - run() ...
[17:41:51.042] run() for ‘Future’ ...
[17:41:51.043] - state: ‘created’
[17:41:51.043] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:51.050] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:51.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:51.051]   - Field: ‘label’
[17:41:51.051]   - Field: ‘local’
[17:41:51.051]   - Field: ‘owner’
[17:41:51.051]   - Field: ‘envir’
[17:41:51.051]   - Field: ‘workers’
[17:41:51.052]   - Field: ‘packages’
[17:41:51.052]   - Field: ‘gc’
[17:41:51.052]   - Field: ‘job’
[17:41:51.052]   - Field: ‘conditions’
[17:41:51.052]   - Field: ‘expr’
[17:41:51.052]   - Field: ‘uuid’
[17:41:51.052]   - Field: ‘seed’
[17:41:51.052]   - Field: ‘version’
[17:41:51.052]   - Field: ‘result’
[17:41:51.053]   - Field: ‘asynchronous’
[17:41:51.053]   - Field: ‘calls’
[17:41:51.053]   - Field: ‘globals’
[17:41:51.053]   - Field: ‘stdout’
[17:41:51.053]   - Field: ‘earlySignal’
[17:41:51.053]   - Field: ‘lazy’
[17:41:51.053]   - Field: ‘state’
[17:41:51.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:51.054] - Launch lazy future ...
[17:41:51.054] Packages needed by the future expression (n = 1): ‘future’
[17:41:51.054] Packages needed by future strategies (n = 0): <none>
[17:41:51.055] {
[17:41:51.055]     {
[17:41:51.055]         {
[17:41:51.055]             ...future.startTime <- base::Sys.time()
[17:41:51.055]             {
[17:41:51.055]                 {
[17:41:51.055]                   {
[17:41:51.055]                     {
[17:41:51.055]                       {
[17:41:51.055]                         base::local({
[17:41:51.055]                           has_future <- base::requireNamespace("future", 
[17:41:51.055]                             quietly = TRUE)
[17:41:51.055]                           if (has_future) {
[17:41:51.055]                             ns <- base::getNamespace("future")
[17:41:51.055]                             version <- ns[[".package"]][["version"]]
[17:41:51.055]                             if (is.null(version)) 
[17:41:51.055]                               version <- utils::packageVersion("future")
[17:41:51.055]                           }
[17:41:51.055]                           else {
[17:41:51.055]                             version <- NULL
[17:41:51.055]                           }
[17:41:51.055]                           if (!has_future || version < "1.8.0") {
[17:41:51.055]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:51.055]                               "", base::R.version$version.string), 
[17:41:51.055]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:51.055]                                 base::R.version$platform, 8 * 
[17:41:51.055]                                   base::.Machine$sizeof.pointer), 
[17:41:51.055]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:51.055]                                 "release", "version")], collapse = " "), 
[17:41:51.055]                               hostname = base::Sys.info()[["nodename"]])
[17:41:51.055]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:51.055]                               info)
[17:41:51.055]                             info <- base::paste(info, collapse = "; ")
[17:41:51.055]                             if (!has_future) {
[17:41:51.055]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:51.055]                                 info)
[17:41:51.055]                             }
[17:41:51.055]                             else {
[17:41:51.055]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:51.055]                                 info, version)
[17:41:51.055]                             }
[17:41:51.055]                             base::stop(msg)
[17:41:51.055]                           }
[17:41:51.055]                         })
[17:41:51.055]                       }
[17:41:51.055]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:51.055]                       base::options(mc.cores = 1L)
[17:41:51.055]                     }
[17:41:51.055]                     base::local({
[17:41:51.055]                       for (pkg in "future") {
[17:41:51.055]                         base::loadNamespace(pkg)
[17:41:51.055]                         base::library(pkg, character.only = TRUE)
[17:41:51.055]                       }
[17:41:51.055]                     })
[17:41:51.055]                   }
[17:41:51.055]                   options(future.plan = NULL)
[17:41:51.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:51.055]                 }
[17:41:51.055]                 ...future.workdir <- getwd()
[17:41:51.055]             }
[17:41:51.055]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:51.055]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:51.055]         }
[17:41:51.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:51.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:51.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:51.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:51.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:51.055]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:51.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:51.055]             base::names(...future.oldOptions))
[17:41:51.055]     }
[17:41:51.055]     if (FALSE) {
[17:41:51.055]     }
[17:41:51.055]     else {
[17:41:51.055]         if (TRUE) {
[17:41:51.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:51.055]                 open = "w")
[17:41:51.055]         }
[17:41:51.055]         else {
[17:41:51.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:51.055]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:51.055]         }
[17:41:51.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:51.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:51.055]             base::sink(type = "output", split = FALSE)
[17:41:51.055]             base::close(...future.stdout)
[17:41:51.055]         }, add = TRUE)
[17:41:51.055]     }
[17:41:51.055]     ...future.frame <- base::sys.nframe()
[17:41:51.055]     ...future.conditions <- base::list()
[17:41:51.055]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:51.055]     if (FALSE) {
[17:41:51.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:51.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:51.055]     }
[17:41:51.055]     ...future.result <- base::tryCatch({
[17:41:51.055]         base::withCallingHandlers({
[17:41:51.055]             ...future.value <- base::withVisible(base::local({
[17:41:51.055]                 withCallingHandlers({
[17:41:51.055]                   {
[17:41:51.055]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:51.055]                       ii, n), appendLF = FALSE)
[17:41:51.055]                     fit <- mandelbrot(C)
[17:41:51.055]                     delay(fit)
[17:41:51.055]                     message(" done")
[17:41:51.055]                     fit
[17:41:51.055]                   }
[17:41:51.055]                 }, immediateCondition = function(cond) {
[17:41:51.055]                   save_rds <- function (object, pathname, ...) 
[17:41:51.055]                   {
[17:41:51.055]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:51.055]                     if (file_test("-f", pathname_tmp)) {
[17:41:51.055]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.055]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:51.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.055]                         fi_tmp[["mtime"]])
[17:41:51.055]                     }
[17:41:51.055]                     tryCatch({
[17:41:51.055]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:51.055]                     }, error = function(ex) {
[17:41:51.055]                       msg <- conditionMessage(ex)
[17:41:51.055]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.055]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:51.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.055]                         fi_tmp[["mtime"]], msg)
[17:41:51.055]                       ex$message <- msg
[17:41:51.055]                       stop(ex)
[17:41:51.055]                     })
[17:41:51.055]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:51.055]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:51.055]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:51.055]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.055]                       fi <- file.info(pathname)
[17:41:51.055]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:51.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.055]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:51.055]                         fi[["size"]], fi[["mtime"]])
[17:41:51.055]                       stop(msg)
[17:41:51.055]                     }
[17:41:51.055]                     invisible(pathname)
[17:41:51.055]                   }
[17:41:51.055]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:51.055]                     rootPath = tempdir()) 
[17:41:51.055]                   {
[17:41:51.055]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:51.055]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:51.055]                       tmpdir = path, fileext = ".rds")
[17:41:51.055]                     save_rds(obj, file)
[17:41:51.055]                   }
[17:41:51.055]                   saveImmediateCondition(cond, path = "/tmp/RtmpkaR8AW/.future/immediateConditions")
[17:41:51.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.055]                   {
[17:41:51.055]                     inherits <- base::inherits
[17:41:51.055]                     invokeRestart <- base::invokeRestart
[17:41:51.055]                     is.null <- base::is.null
[17:41:51.055]                     muffled <- FALSE
[17:41:51.055]                     if (inherits(cond, "message")) {
[17:41:51.055]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:51.055]                       if (muffled) 
[17:41:51.055]                         invokeRestart("muffleMessage")
[17:41:51.055]                     }
[17:41:51.055]                     else if (inherits(cond, "warning")) {
[17:41:51.055]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:51.055]                       if (muffled) 
[17:41:51.055]                         invokeRestart("muffleWarning")
[17:41:51.055]                     }
[17:41:51.055]                     else if (inherits(cond, "condition")) {
[17:41:51.055]                       if (!is.null(pattern)) {
[17:41:51.055]                         computeRestarts <- base::computeRestarts
[17:41:51.055]                         grepl <- base::grepl
[17:41:51.055]                         restarts <- computeRestarts(cond)
[17:41:51.055]                         for (restart in restarts) {
[17:41:51.055]                           name <- restart$name
[17:41:51.055]                           if (is.null(name)) 
[17:41:51.055]                             next
[17:41:51.055]                           if (!grepl(pattern, name)) 
[17:41:51.055]                             next
[17:41:51.055]                           invokeRestart(restart)
[17:41:51.055]                           muffled <- TRUE
[17:41:51.055]                           break
[17:41:51.055]                         }
[17:41:51.055]                       }
[17:41:51.055]                     }
[17:41:51.055]                     invisible(muffled)
[17:41:51.055]                   }
[17:41:51.055]                   muffleCondition(cond)
[17:41:51.055]                 })
[17:41:51.055]             }))
[17:41:51.055]             future::FutureResult(value = ...future.value$value, 
[17:41:51.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.055]                   ...future.rng), globalenv = if (FALSE) 
[17:41:51.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:51.055]                     ...future.globalenv.names))
[17:41:51.055]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:51.055]         }, condition = base::local({
[17:41:51.055]             c <- base::c
[17:41:51.055]             inherits <- base::inherits
[17:41:51.055]             invokeRestart <- base::invokeRestart
[17:41:51.055]             length <- base::length
[17:41:51.055]             list <- base::list
[17:41:51.055]             seq.int <- base::seq.int
[17:41:51.055]             signalCondition <- base::signalCondition
[17:41:51.055]             sys.calls <- base::sys.calls
[17:41:51.055]             `[[` <- base::`[[`
[17:41:51.055]             `+` <- base::`+`
[17:41:51.055]             `<<-` <- base::`<<-`
[17:41:51.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:51.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:51.055]                   3L)]
[17:41:51.055]             }
[17:41:51.055]             function(cond) {
[17:41:51.055]                 is_error <- inherits(cond, "error")
[17:41:51.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:51.055]                   NULL)
[17:41:51.055]                 if (is_error) {
[17:41:51.055]                   sessionInformation <- function() {
[17:41:51.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:51.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:51.055]                       search = base::search(), system = base::Sys.info())
[17:41:51.055]                   }
[17:41:51.055]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:51.055]                     cond$call), session = sessionInformation(), 
[17:41:51.055]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:51.055]                   signalCondition(cond)
[17:41:51.055]                 }
[17:41:51.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:51.055]                 "immediateCondition"))) {
[17:41:51.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:51.055]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:51.055]                   if (TRUE && !signal) {
[17:41:51.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.055]                     {
[17:41:51.055]                       inherits <- base::inherits
[17:41:51.055]                       invokeRestart <- base::invokeRestart
[17:41:51.055]                       is.null <- base::is.null
[17:41:51.055]                       muffled <- FALSE
[17:41:51.055]                       if (inherits(cond, "message")) {
[17:41:51.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.055]                         if (muffled) 
[17:41:51.055]                           invokeRestart("muffleMessage")
[17:41:51.055]                       }
[17:41:51.055]                       else if (inherits(cond, "warning")) {
[17:41:51.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.055]                         if (muffled) 
[17:41:51.055]                           invokeRestart("muffleWarning")
[17:41:51.055]                       }
[17:41:51.055]                       else if (inherits(cond, "condition")) {
[17:41:51.055]                         if (!is.null(pattern)) {
[17:41:51.055]                           computeRestarts <- base::computeRestarts
[17:41:51.055]                           grepl <- base::grepl
[17:41:51.055]                           restarts <- computeRestarts(cond)
[17:41:51.055]                           for (restart in restarts) {
[17:41:51.055]                             name <- restart$name
[17:41:51.055]                             if (is.null(name)) 
[17:41:51.055]                               next
[17:41:51.055]                             if (!grepl(pattern, name)) 
[17:41:51.055]                               next
[17:41:51.055]                             invokeRestart(restart)
[17:41:51.055]                             muffled <- TRUE
[17:41:51.055]                             break
[17:41:51.055]                           }
[17:41:51.055]                         }
[17:41:51.055]                       }
[17:41:51.055]                       invisible(muffled)
[17:41:51.055]                     }
[17:41:51.055]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.055]                   }
[17:41:51.055]                 }
[17:41:51.055]                 else {
[17:41:51.055]                   if (TRUE) {
[17:41:51.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.055]                     {
[17:41:51.055]                       inherits <- base::inherits
[17:41:51.055]                       invokeRestart <- base::invokeRestart
[17:41:51.055]                       is.null <- base::is.null
[17:41:51.055]                       muffled <- FALSE
[17:41:51.055]                       if (inherits(cond, "message")) {
[17:41:51.055]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.055]                         if (muffled) 
[17:41:51.055]                           invokeRestart("muffleMessage")
[17:41:51.055]                       }
[17:41:51.055]                       else if (inherits(cond, "warning")) {
[17:41:51.055]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.055]                         if (muffled) 
[17:41:51.055]                           invokeRestart("muffleWarning")
[17:41:51.055]                       }
[17:41:51.055]                       else if (inherits(cond, "condition")) {
[17:41:51.055]                         if (!is.null(pattern)) {
[17:41:51.055]                           computeRestarts <- base::computeRestarts
[17:41:51.055]                           grepl <- base::grepl
[17:41:51.055]                           restarts <- computeRestarts(cond)
[17:41:51.055]                           for (restart in restarts) {
[17:41:51.055]                             name <- restart$name
[17:41:51.055]                             if (is.null(name)) 
[17:41:51.055]                               next
[17:41:51.055]                             if (!grepl(pattern, name)) 
[17:41:51.055]                               next
[17:41:51.055]                             invokeRestart(restart)
[17:41:51.055]                             muffled <- TRUE
[17:41:51.055]                             break
[17:41:51.055]                           }
[17:41:51.055]                         }
[17:41:51.055]                       }
[17:41:51.055]                       invisible(muffled)
[17:41:51.055]                     }
[17:41:51.055]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.055]                   }
[17:41:51.055]                 }
[17:41:51.055]             }
[17:41:51.055]         }))
[17:41:51.055]     }, error = function(ex) {
[17:41:51.055]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:51.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.055]                 ...future.rng), started = ...future.startTime, 
[17:41:51.055]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:51.055]             version = "1.8"), class = "FutureResult")
[17:41:51.055]     }, finally = {
[17:41:51.055]         if (!identical(...future.workdir, getwd())) 
[17:41:51.055]             setwd(...future.workdir)
[17:41:51.055]         {
[17:41:51.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:51.055]                 ...future.oldOptions$nwarnings <- NULL
[17:41:51.055]             }
[17:41:51.055]             base::options(...future.oldOptions)
[17:41:51.055]             if (.Platform$OS.type == "windows") {
[17:41:51.055]                 old_names <- names(...future.oldEnvVars)
[17:41:51.055]                 envs <- base::Sys.getenv()
[17:41:51.055]                 names <- names(envs)
[17:41:51.055]                 common <- intersect(names, old_names)
[17:41:51.055]                 added <- setdiff(names, old_names)
[17:41:51.055]                 removed <- setdiff(old_names, names)
[17:41:51.055]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:51.055]                   envs[common]]
[17:41:51.055]                 NAMES <- toupper(changed)
[17:41:51.055]                 args <- list()
[17:41:51.055]                 for (kk in seq_along(NAMES)) {
[17:41:51.055]                   name <- changed[[kk]]
[17:41:51.055]                   NAME <- NAMES[[kk]]
[17:41:51.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.055]                     next
[17:41:51.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.055]                 }
[17:41:51.055]                 NAMES <- toupper(added)
[17:41:51.055]                 for (kk in seq_along(NAMES)) {
[17:41:51.055]                   name <- added[[kk]]
[17:41:51.055]                   NAME <- NAMES[[kk]]
[17:41:51.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.055]                     next
[17:41:51.055]                   args[[name]] <- ""
[17:41:51.055]                 }
[17:41:51.055]                 NAMES <- toupper(removed)
[17:41:51.055]                 for (kk in seq_along(NAMES)) {
[17:41:51.055]                   name <- removed[[kk]]
[17:41:51.055]                   NAME <- NAMES[[kk]]
[17:41:51.055]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.055]                     next
[17:41:51.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.055]                 }
[17:41:51.055]                 if (length(args) > 0) 
[17:41:51.055]                   base::do.call(base::Sys.setenv, args = args)
[17:41:51.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:51.055]             }
[17:41:51.055]             else {
[17:41:51.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:51.055]             }
[17:41:51.055]             {
[17:41:51.055]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:51.055]                   0L) {
[17:41:51.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:51.055]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:51.055]                   base::options(opts)
[17:41:51.055]                 }
[17:41:51.055]                 {
[17:41:51.055]                   {
[17:41:51.055]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:51.055]                     NULL
[17:41:51.055]                   }
[17:41:51.055]                   options(future.plan = NULL)
[17:41:51.055]                   if (is.na(NA_character_)) 
[17:41:51.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:51.055]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:51.055]                     envir = parent.frame()) 
[17:41:51.055]                   {
[17:41:51.055]                     default_workers <- missing(workers)
[17:41:51.055]                     if (is.function(workers)) 
[17:41:51.055]                       workers <- workers()
[17:41:51.055]                     workers <- structure(as.integer(workers), 
[17:41:51.055]                       class = class(workers))
[17:41:51.055]                     stop_if_not(is.finite(workers), workers >= 
[17:41:51.055]                       1L)
[17:41:51.055]                     if ((workers == 1L && !inherits(workers, 
[17:41:51.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:51.055]                       if (default_workers) 
[17:41:51.055]                         supportsMulticore(warn = TRUE)
[17:41:51.055]                       return(sequential(..., envir = envir))
[17:41:51.055]                     }
[17:41:51.055]                     oopts <- options(mc.cores = workers)
[17:41:51.055]                     on.exit(options(oopts))
[17:41:51.055]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:51.055]                       envir = envir)
[17:41:51.055]                     if (!future$lazy) 
[17:41:51.055]                       future <- run(future)
[17:41:51.055]                     invisible(future)
[17:41:51.055]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:51.055]                 }
[17:41:51.055]             }
[17:41:51.055]         }
[17:41:51.055]     })
[17:41:51.055]     if (TRUE) {
[17:41:51.055]         base::sink(type = "output", split = FALSE)
[17:41:51.055]         if (TRUE) {
[17:41:51.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:51.055]         }
[17:41:51.055]         else {
[17:41:51.055]             ...future.result["stdout"] <- base::list(NULL)
[17:41:51.055]         }
[17:41:51.055]         base::close(...future.stdout)
[17:41:51.055]         ...future.stdout <- NULL
[17:41:51.055]     }
[17:41:51.055]     ...future.result$conditions <- ...future.conditions
[17:41:51.055]     ...future.result$finished <- base::Sys.time()
[17:41:51.055]     ...future.result
[17:41:51.055] }
[17:41:51.057] assign_globals() ...
[17:41:51.057] List of 4
[17:41:51.057]  $ ii   : int 2
[17:41:51.057]  $ n    : int 4
[17:41:51.057]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[17:41:51.057]   ..- attr(*, "region")=List of 2
[17:41:51.057]   .. ..$ xrange: num [1:2] -0.719 0.75
[17:41:51.057]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[17:41:51.057]   ..- attr(*, "tile")= int [1:2] 1 2
[17:41:51.057]  $ delay:function (counts)  
[17:41:51.057]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:51.057]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d9fb9f8> 
[17:41:51.057]  - attr(*, "where")=List of 4
[17:41:51.057]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:51.057]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:51.057]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:51.057]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:51.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:51.057]  - attr(*, "resolved")= logi FALSE
[17:41:51.057]  - attr(*, "total_size")= num 14584
[17:41:51.057]  - attr(*, "already-done")= logi TRUE
[17:41:51.065] - copied ‘ii’ to environment
[17:41:51.065] - copied ‘n’ to environment
[17:41:51.065] - copied ‘C’ to environment
[17:41:51.065] - reassign environment for ‘delay’
[17:41:51.066] - copied ‘delay’ to environment
[17:41:51.066] assign_globals() ... done
[17:41:51.066] requestCore(): workers = 2
[17:41:51.068] MulticoreFuture started
[17:41:51.069] - Launch lazy future ... done
[17:41:51.069] run() for ‘MulticoreFuture’ ... done
[17:41:51.069] - run() ... done
[17:41:51.069] - resolved() ...
[17:41:51.070] plan(): Setting new future strategy stack:
[17:41:51.070] List of future strategies:
[17:41:51.070] 1. sequential:
[17:41:51.070]    - args: function (..., envir = parent.frame())
[17:41:51.070]    - tweaked: FALSE
[17:41:51.070]    - call: NULL
[17:41:51.071] plan(): nbrOfWorkers() = 1
[17:41:51.076] plan(): Setting new future strategy stack:
[17:41:51.076] List of future strategies:
[17:41:51.076] 1. multicore:
[17:41:51.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:51.076]    - tweaked: FALSE
[17:41:51.076]    - call: plan(strategy)
[17:41:51.080] - resolved: FALSE
[17:41:51.080] - resolved() ... done
[17:41:51.080] resolved() for ‘MulticoreFuture’ ... done
[17:41:51.080] resolved() for ‘Future’ ...
[17:41:51.081] - state: ‘created’
[17:41:51.081] - run: TRUE
[17:41:51.081] - run() ...
[17:41:51.081] run() for ‘Future’ ...
[17:41:51.081] - state: ‘created’
[17:41:51.081] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:51.082] plan(): nbrOfWorkers() = 2
[17:41:51.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:51.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:51.086]   - Field: ‘label’
[17:41:51.086]   - Field: ‘local’
[17:41:51.086]   - Field: ‘owner’
[17:41:51.087]   - Field: ‘envir’
[17:41:51.087]   - Field: ‘workers’
[17:41:51.087]   - Field: ‘packages’
[17:41:51.087]   - Field: ‘gc’
[17:41:51.087]   - Field: ‘job’
[17:41:51.087]   - Field: ‘conditions’
[17:41:51.088]   - Field: ‘expr’
[17:41:51.088]   - Field: ‘uuid’
[17:41:51.088]   - Field: ‘seed’
[17:41:51.088]   - Field: ‘version’
[17:41:51.088]   - Field: ‘result’
[17:41:51.088]   - Field: ‘asynchronous’
[17:41:51.089]   - Field: ‘calls’
[17:41:51.089]   - Field: ‘globals’
[17:41:51.089]   - Field: ‘stdout’
[17:41:51.089]   - Field: ‘earlySignal’
[17:41:51.089]   - Field: ‘lazy’
[17:41:51.089]   - Field: ‘state’
[17:41:51.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:51.090] - Launch lazy future ...
[17:41:51.090] Packages needed by the future expression (n = 1): ‘future’
[17:41:51.090] Packages needed by future strategies (n = 0): <none>
[17:41:51.091] {
[17:41:51.091]     {
[17:41:51.091]         {
[17:41:51.091]             ...future.startTime <- base::Sys.time()
[17:41:51.091]             {
[17:41:51.091]                 {
[17:41:51.091]                   {
[17:41:51.091]                     {
[17:41:51.091]                       {
[17:41:51.091]                         base::local({
[17:41:51.091]                           has_future <- base::requireNamespace("future", 
[17:41:51.091]                             quietly = TRUE)
[17:41:51.091]                           if (has_future) {
[17:41:51.091]                             ns <- base::getNamespace("future")
[17:41:51.091]                             version <- ns[[".package"]][["version"]]
[17:41:51.091]                             if (is.null(version)) 
[17:41:51.091]                               version <- utils::packageVersion("future")
[17:41:51.091]                           }
[17:41:51.091]                           else {
[17:41:51.091]                             version <- NULL
[17:41:51.091]                           }
[17:41:51.091]                           if (!has_future || version < "1.8.0") {
[17:41:51.091]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:51.091]                               "", base::R.version$version.string), 
[17:41:51.091]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:51.091]                                 base::R.version$platform, 8 * 
[17:41:51.091]                                   base::.Machine$sizeof.pointer), 
[17:41:51.091]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:51.091]                                 "release", "version")], collapse = " "), 
[17:41:51.091]                               hostname = base::Sys.info()[["nodename"]])
[17:41:51.091]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:51.091]                               info)
[17:41:51.091]                             info <- base::paste(info, collapse = "; ")
[17:41:51.091]                             if (!has_future) {
[17:41:51.091]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:51.091]                                 info)
[17:41:51.091]                             }
[17:41:51.091]                             else {
[17:41:51.091]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:51.091]                                 info, version)
[17:41:51.091]                             }
[17:41:51.091]                             base::stop(msg)
[17:41:51.091]                           }
[17:41:51.091]                         })
[17:41:51.091]                       }
[17:41:51.091]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:51.091]                       base::options(mc.cores = 1L)
[17:41:51.091]                     }
[17:41:51.091]                     base::local({
[17:41:51.091]                       for (pkg in "future") {
[17:41:51.091]                         base::loadNamespace(pkg)
[17:41:51.091]                         base::library(pkg, character.only = TRUE)
[17:41:51.091]                       }
[17:41:51.091]                     })
[17:41:51.091]                   }
[17:41:51.091]                   options(future.plan = NULL)
[17:41:51.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:51.091]                 }
[17:41:51.091]                 ...future.workdir <- getwd()
[17:41:51.091]             }
[17:41:51.091]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:51.091]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:51.091]         }
[17:41:51.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:51.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:51.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:51.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:51.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:51.091]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:51.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:51.091]             base::names(...future.oldOptions))
[17:41:51.091]     }
[17:41:51.091]     if (FALSE) {
[17:41:51.091]     }
[17:41:51.091]     else {
[17:41:51.091]         if (TRUE) {
[17:41:51.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:51.091]                 open = "w")
[17:41:51.091]         }
[17:41:51.091]         else {
[17:41:51.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:51.091]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:51.091]         }
[17:41:51.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:51.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:51.091]             base::sink(type = "output", split = FALSE)
[17:41:51.091]             base::close(...future.stdout)
[17:41:51.091]         }, add = TRUE)
[17:41:51.091]     }
[17:41:51.091]     ...future.frame <- base::sys.nframe()
[17:41:51.091]     ...future.conditions <- base::list()
[17:41:51.091]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:51.091]     if (FALSE) {
[17:41:51.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:51.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:51.091]     }
[17:41:51.091]     ...future.result <- base::tryCatch({
[17:41:51.091]         base::withCallingHandlers({
[17:41:51.091]             ...future.value <- base::withVisible(base::local({
[17:41:51.091]                 withCallingHandlers({
[17:41:51.091]                   {
[17:41:51.091]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:51.091]                       ii, n), appendLF = FALSE)
[17:41:51.091]                     fit <- mandelbrot(C)
[17:41:51.091]                     delay(fit)
[17:41:51.091]                     message(" done")
[17:41:51.091]                     fit
[17:41:51.091]                   }
[17:41:51.091]                 }, immediateCondition = function(cond) {
[17:41:51.091]                   save_rds <- function (object, pathname, ...) 
[17:41:51.091]                   {
[17:41:51.091]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:51.091]                     if (file_test("-f", pathname_tmp)) {
[17:41:51.091]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.091]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:51.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.091]                         fi_tmp[["mtime"]])
[17:41:51.091]                     }
[17:41:51.091]                     tryCatch({
[17:41:51.091]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:51.091]                     }, error = function(ex) {
[17:41:51.091]                       msg <- conditionMessage(ex)
[17:41:51.091]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.091]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:51.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.091]                         fi_tmp[["mtime"]], msg)
[17:41:51.091]                       ex$message <- msg
[17:41:51.091]                       stop(ex)
[17:41:51.091]                     })
[17:41:51.091]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:51.091]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:51.091]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:51.091]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.091]                       fi <- file.info(pathname)
[17:41:51.091]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:51.091]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.091]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:51.091]                         fi[["size"]], fi[["mtime"]])
[17:41:51.091]                       stop(msg)
[17:41:51.091]                     }
[17:41:51.091]                     invisible(pathname)
[17:41:51.091]                   }
[17:41:51.091]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:51.091]                     rootPath = tempdir()) 
[17:41:51.091]                   {
[17:41:51.091]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:51.091]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:51.091]                       tmpdir = path, fileext = ".rds")
[17:41:51.091]                     save_rds(obj, file)
[17:41:51.091]                   }
[17:41:51.091]                   saveImmediateCondition(cond, path = "/tmp/RtmpkaR8AW/.future/immediateConditions")
[17:41:51.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.091]                   {
[17:41:51.091]                     inherits <- base::inherits
[17:41:51.091]                     invokeRestart <- base::invokeRestart
[17:41:51.091]                     is.null <- base::is.null
[17:41:51.091]                     muffled <- FALSE
[17:41:51.091]                     if (inherits(cond, "message")) {
[17:41:51.091]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:51.091]                       if (muffled) 
[17:41:51.091]                         invokeRestart("muffleMessage")
[17:41:51.091]                     }
[17:41:51.091]                     else if (inherits(cond, "warning")) {
[17:41:51.091]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:51.091]                       if (muffled) 
[17:41:51.091]                         invokeRestart("muffleWarning")
[17:41:51.091]                     }
[17:41:51.091]                     else if (inherits(cond, "condition")) {
[17:41:51.091]                       if (!is.null(pattern)) {
[17:41:51.091]                         computeRestarts <- base::computeRestarts
[17:41:51.091]                         grepl <- base::grepl
[17:41:51.091]                         restarts <- computeRestarts(cond)
[17:41:51.091]                         for (restart in restarts) {
[17:41:51.091]                           name <- restart$name
[17:41:51.091]                           if (is.null(name)) 
[17:41:51.091]                             next
[17:41:51.091]                           if (!grepl(pattern, name)) 
[17:41:51.091]                             next
[17:41:51.091]                           invokeRestart(restart)
[17:41:51.091]                           muffled <- TRUE
[17:41:51.091]                           break
[17:41:51.091]                         }
[17:41:51.091]                       }
[17:41:51.091]                     }
[17:41:51.091]                     invisible(muffled)
[17:41:51.091]                   }
[17:41:51.091]                   muffleCondition(cond)
[17:41:51.091]                 })
[17:41:51.091]             }))
[17:41:51.091]             future::FutureResult(value = ...future.value$value, 
[17:41:51.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.091]                   ...future.rng), globalenv = if (FALSE) 
[17:41:51.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:51.091]                     ...future.globalenv.names))
[17:41:51.091]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:51.091]         }, condition = base::local({
[17:41:51.091]             c <- base::c
[17:41:51.091]             inherits <- base::inherits
[17:41:51.091]             invokeRestart <- base::invokeRestart
[17:41:51.091]             length <- base::length
[17:41:51.091]             list <- base::list
[17:41:51.091]             seq.int <- base::seq.int
[17:41:51.091]             signalCondition <- base::signalCondition
[17:41:51.091]             sys.calls <- base::sys.calls
[17:41:51.091]             `[[` <- base::`[[`
[17:41:51.091]             `+` <- base::`+`
[17:41:51.091]             `<<-` <- base::`<<-`
[17:41:51.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:51.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:51.091]                   3L)]
[17:41:51.091]             }
[17:41:51.091]             function(cond) {
[17:41:51.091]                 is_error <- inherits(cond, "error")
[17:41:51.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:51.091]                   NULL)
[17:41:51.091]                 if (is_error) {
[17:41:51.091]                   sessionInformation <- function() {
[17:41:51.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:51.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:51.091]                       search = base::search(), system = base::Sys.info())
[17:41:51.091]                   }
[17:41:51.091]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:51.091]                     cond$call), session = sessionInformation(), 
[17:41:51.091]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:51.091]                   signalCondition(cond)
[17:41:51.091]                 }
[17:41:51.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:51.091]                 "immediateCondition"))) {
[17:41:51.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:51.091]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:51.091]                   if (TRUE && !signal) {
[17:41:51.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.091]                     {
[17:41:51.091]                       inherits <- base::inherits
[17:41:51.091]                       invokeRestart <- base::invokeRestart
[17:41:51.091]                       is.null <- base::is.null
[17:41:51.091]                       muffled <- FALSE
[17:41:51.091]                       if (inherits(cond, "message")) {
[17:41:51.091]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.091]                         if (muffled) 
[17:41:51.091]                           invokeRestart("muffleMessage")
[17:41:51.091]                       }
[17:41:51.091]                       else if (inherits(cond, "warning")) {
[17:41:51.091]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.091]                         if (muffled) 
[17:41:51.091]                           invokeRestart("muffleWarning")
[17:41:51.091]                       }
[17:41:51.091]                       else if (inherits(cond, "condition")) {
[17:41:51.091]                         if (!is.null(pattern)) {
[17:41:51.091]                           computeRestarts <- base::computeRestarts
[17:41:51.091]                           grepl <- base::grepl
[17:41:51.091]                           restarts <- computeRestarts(cond)
[17:41:51.091]                           for (restart in restarts) {
[17:41:51.091]                             name <- restart$name
[17:41:51.091]                             if (is.null(name)) 
[17:41:51.091]                               next
[17:41:51.091]                             if (!grepl(pattern, name)) 
[17:41:51.091]                               next
[17:41:51.091]                             invokeRestart(restart)
[17:41:51.091]                             muffled <- TRUE
[17:41:51.091]                             break
[17:41:51.091]                           }
[17:41:51.091]                         }
[17:41:51.091]                       }
[17:41:51.091]                       invisible(muffled)
[17:41:51.091]                     }
[17:41:51.091]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.091]                   }
[17:41:51.091]                 }
[17:41:51.091]                 else {
[17:41:51.091]                   if (TRUE) {
[17:41:51.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.091]                     {
[17:41:51.091]                       inherits <- base::inherits
[17:41:51.091]                       invokeRestart <- base::invokeRestart
[17:41:51.091]                       is.null <- base::is.null
[17:41:51.091]                       muffled <- FALSE
[17:41:51.091]                       if (inherits(cond, "message")) {
[17:41:51.091]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.091]                         if (muffled) 
[17:41:51.091]                           invokeRestart("muffleMessage")
[17:41:51.091]                       }
[17:41:51.091]                       else if (inherits(cond, "warning")) {
[17:41:51.091]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.091]                         if (muffled) 
[17:41:51.091]                           invokeRestart("muffleWarning")
[17:41:51.091]                       }
[17:41:51.091]                       else if (inherits(cond, "condition")) {
[17:41:51.091]                         if (!is.null(pattern)) {
[17:41:51.091]                           computeRestarts <- base::computeRestarts
[17:41:51.091]                           grepl <- base::grepl
[17:41:51.091]                           restarts <- computeRestarts(cond)
[17:41:51.091]                           for (restart in restarts) {
[17:41:51.091]                             name <- restart$name
[17:41:51.091]                             if (is.null(name)) 
[17:41:51.091]                               next
[17:41:51.091]                             if (!grepl(pattern, name)) 
[17:41:51.091]                               next
[17:41:51.091]                             invokeRestart(restart)
[17:41:51.091]                             muffled <- TRUE
[17:41:51.091]                             break
[17:41:51.091]                           }
[17:41:51.091]                         }
[17:41:51.091]                       }
[17:41:51.091]                       invisible(muffled)
[17:41:51.091]                     }
[17:41:51.091]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.091]                   }
[17:41:51.091]                 }
[17:41:51.091]             }
[17:41:51.091]         }))
[17:41:51.091]     }, error = function(ex) {
[17:41:51.091]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:51.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.091]                 ...future.rng), started = ...future.startTime, 
[17:41:51.091]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:51.091]             version = "1.8"), class = "FutureResult")
[17:41:51.091]     }, finally = {
[17:41:51.091]         if (!identical(...future.workdir, getwd())) 
[17:41:51.091]             setwd(...future.workdir)
[17:41:51.091]         {
[17:41:51.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:51.091]                 ...future.oldOptions$nwarnings <- NULL
[17:41:51.091]             }
[17:41:51.091]             base::options(...future.oldOptions)
[17:41:51.091]             if (.Platform$OS.type == "windows") {
[17:41:51.091]                 old_names <- names(...future.oldEnvVars)
[17:41:51.091]                 envs <- base::Sys.getenv()
[17:41:51.091]                 names <- names(envs)
[17:41:51.091]                 common <- intersect(names, old_names)
[17:41:51.091]                 added <- setdiff(names, old_names)
[17:41:51.091]                 removed <- setdiff(old_names, names)
[17:41:51.091]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:51.091]                   envs[common]]
[17:41:51.091]                 NAMES <- toupper(changed)
[17:41:51.091]                 args <- list()
[17:41:51.091]                 for (kk in seq_along(NAMES)) {
[17:41:51.091]                   name <- changed[[kk]]
[17:41:51.091]                   NAME <- NAMES[[kk]]
[17:41:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.091]                     next
[17:41:51.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.091]                 }
[17:41:51.091]                 NAMES <- toupper(added)
[17:41:51.091]                 for (kk in seq_along(NAMES)) {
[17:41:51.091]                   name <- added[[kk]]
[17:41:51.091]                   NAME <- NAMES[[kk]]
[17:41:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.091]                     next
[17:41:51.091]                   args[[name]] <- ""
[17:41:51.091]                 }
[17:41:51.091]                 NAMES <- toupper(removed)
[17:41:51.091]                 for (kk in seq_along(NAMES)) {
[17:41:51.091]                   name <- removed[[kk]]
[17:41:51.091]                   NAME <- NAMES[[kk]]
[17:41:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.091]                     next
[17:41:51.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.091]                 }
[17:41:51.091]                 if (length(args) > 0) 
[17:41:51.091]                   base::do.call(base::Sys.setenv, args = args)
[17:41:51.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:51.091]             }
[17:41:51.091]             else {
[17:41:51.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:51.091]             }
[17:41:51.091]             {
[17:41:51.091]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:51.091]                   0L) {
[17:41:51.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:51.091]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:51.091]                   base::options(opts)
[17:41:51.091]                 }
[17:41:51.091]                 {
[17:41:51.091]                   {
[17:41:51.091]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:51.091]                     NULL
[17:41:51.091]                   }
[17:41:51.091]                   options(future.plan = NULL)
[17:41:51.091]                   if (is.na(NA_character_)) 
[17:41:51.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:51.091]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:51.091]                     envir = parent.frame()) 
[17:41:51.091]                   {
[17:41:51.091]                     default_workers <- missing(workers)
[17:41:51.091]                     if (is.function(workers)) 
[17:41:51.091]                       workers <- workers()
[17:41:51.091]                     workers <- structure(as.integer(workers), 
[17:41:51.091]                       class = class(workers))
[17:41:51.091]                     stop_if_not(is.finite(workers), workers >= 
[17:41:51.091]                       1L)
[17:41:51.091]                     if ((workers == 1L && !inherits(workers, 
[17:41:51.091]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:51.091]                       if (default_workers) 
[17:41:51.091]                         supportsMulticore(warn = TRUE)
[17:41:51.091]                       return(sequential(..., envir = envir))
[17:41:51.091]                     }
[17:41:51.091]                     oopts <- options(mc.cores = workers)
[17:41:51.091]                     on.exit(options(oopts))
[17:41:51.091]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:51.091]                       envir = envir)
[17:41:51.091]                     if (!future$lazy) 
[17:41:51.091]                       future <- run(future)
[17:41:51.091]                     invisible(future)
[17:41:51.091]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:51.091]                 }
[17:41:51.091]             }
[17:41:51.091]         }
[17:41:51.091]     })
[17:41:51.091]     if (TRUE) {
[17:41:51.091]         base::sink(type = "output", split = FALSE)
[17:41:51.091]         if (TRUE) {
[17:41:51.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:51.091]         }
[17:41:51.091]         else {
[17:41:51.091]             ...future.result["stdout"] <- base::list(NULL)
[17:41:51.091]         }
[17:41:51.091]         base::close(...future.stdout)
[17:41:51.091]         ...future.stdout <- NULL
[17:41:51.091]     }
[17:41:51.091]     ...future.result$conditions <- ...future.conditions
[17:41:51.091]     ...future.result$finished <- base::Sys.time()
[17:41:51.091]     ...future.result
[17:41:51.091] }
[17:41:51.095] assign_globals() ...
[17:41:51.095] List of 4
[17:41:51.095]  $ ii   : int 3
[17:41:51.095]  $ n    : int 4
[17:41:51.095]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[17:41:51.095]   ..- attr(*, "region")=List of 2
[17:41:51.095]   .. ..$ xrange: num [1:2] -2.25 -0.781
[17:41:51.095]   .. ..$ yrange: num [1:2] 0.0306 1.5
[17:41:51.095]   ..- attr(*, "tile")= int [1:2] 2 1
[17:41:51.095]  $ delay:function (counts)  
[17:41:51.095]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:51.095]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d9fb9f8> 
[17:41:51.095]  - attr(*, "where")=List of 4
[17:41:51.095]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:51.095]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:51.095]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:51.095]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:51.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:51.095]  - attr(*, "resolved")= logi FALSE
[17:41:51.095]  - attr(*, "total_size")= num 14584
[17:41:51.095]  - attr(*, "already-done")= logi TRUE
[17:41:51.105] - copied ‘ii’ to environment
[17:41:51.105] - copied ‘n’ to environment
[17:41:51.105] - copied ‘C’ to environment
[17:41:51.106] - reassign environment for ‘delay’
[17:41:51.106] - copied ‘delay’ to environment
[17:41:51.106] assign_globals() ... done
[17:41:51.106] requestCore(): workers = 2
[17:41:51.109] MulticoreFuture started
[17:41:51.109] - Launch lazy future ... done
[17:41:51.109] run() for ‘MulticoreFuture’ ... done
[17:41:51.109] - run() ... done
[17:41:51.110] - resolved() ...
[17:41:51.110] plan(): Setting new future strategy stack:
[17:41:51.110] List of future strategies:
[17:41:51.110] 1. sequential:
[17:41:51.110]    - args: function (..., envir = parent.frame())
[17:41:51.110]    - tweaked: FALSE
[17:41:51.110]    - call: NULL
[17:41:51.112] plan(): nbrOfWorkers() = 1
[17:41:51.116] plan(): Setting new future strategy stack:
[17:41:51.116] List of future strategies:
[17:41:51.116] 1. multicore:
[17:41:51.116]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:51.116]    - tweaked: FALSE
[17:41:51.116]    - call: plan(strategy)
[17:41:51.120] - resolved: FALSE
[17:41:51.121] - resolved() ... done
[17:41:51.121] resolved() for ‘MulticoreFuture’ ... done
[17:41:51.121] resolved() for ‘Future’ ...
[17:41:51.121] - state: ‘created’
[17:41:51.121] - run: TRUE
[17:41:51.122] plan(): nbrOfWorkers() = 2
[17:41:51.122] - run() ...
[17:41:51.122] run() for ‘Future’ ...
[17:41:51.122] - state: ‘created’
[17:41:51.122] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:51.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:51.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:51.127]   - Field: ‘label’
[17:41:51.128]   - Field: ‘local’
[17:41:51.128]   - Field: ‘owner’
[17:41:51.128]   - Field: ‘envir’
[17:41:51.128]   - Field: ‘workers’
[17:41:51.128]   - Field: ‘packages’
[17:41:51.128]   - Field: ‘gc’
[17:41:51.128]   - Field: ‘job’
[17:41:51.128]   - Field: ‘conditions’
[17:41:51.129]   - Field: ‘expr’
[17:41:51.129]   - Field: ‘uuid’
[17:41:51.129]   - Field: ‘seed’
[17:41:51.129]   - Field: ‘version’
[17:41:51.129]   - Field: ‘result’
[17:41:51.129]   - Field: ‘asynchronous’
[17:41:51.129]   - Field: ‘calls’
[17:41:51.130]   - Field: ‘globals’
[17:41:51.130]   - Field: ‘stdout’
[17:41:51.130]   - Field: ‘earlySignal’
[17:41:51.130]   - Field: ‘lazy’
[17:41:51.130]   - Field: ‘state’
[17:41:51.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:51.130] - Launch lazy future ...
[17:41:51.131] Packages needed by the future expression (n = 1): ‘future’
[17:41:51.131] Packages needed by future strategies (n = 0): <none>
[17:41:51.132] {
[17:41:51.132]     {
[17:41:51.132]         {
[17:41:51.132]             ...future.startTime <- base::Sys.time()
[17:41:51.132]             {
[17:41:51.132]                 {
[17:41:51.132]                   {
[17:41:51.132]                     {
[17:41:51.132]                       {
[17:41:51.132]                         base::local({
[17:41:51.132]                           has_future <- base::requireNamespace("future", 
[17:41:51.132]                             quietly = TRUE)
[17:41:51.132]                           if (has_future) {
[17:41:51.132]                             ns <- base::getNamespace("future")
[17:41:51.132]                             version <- ns[[".package"]][["version"]]
[17:41:51.132]                             if (is.null(version)) 
[17:41:51.132]                               version <- utils::packageVersion("future")
[17:41:51.132]                           }
[17:41:51.132]                           else {
[17:41:51.132]                             version <- NULL
[17:41:51.132]                           }
[17:41:51.132]                           if (!has_future || version < "1.8.0") {
[17:41:51.132]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:51.132]                               "", base::R.version$version.string), 
[17:41:51.132]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:51.132]                                 base::R.version$platform, 8 * 
[17:41:51.132]                                   base::.Machine$sizeof.pointer), 
[17:41:51.132]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:51.132]                                 "release", "version")], collapse = " "), 
[17:41:51.132]                               hostname = base::Sys.info()[["nodename"]])
[17:41:51.132]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:51.132]                               info)
[17:41:51.132]                             info <- base::paste(info, collapse = "; ")
[17:41:51.132]                             if (!has_future) {
[17:41:51.132]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:51.132]                                 info)
[17:41:51.132]                             }
[17:41:51.132]                             else {
[17:41:51.132]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:51.132]                                 info, version)
[17:41:51.132]                             }
[17:41:51.132]                             base::stop(msg)
[17:41:51.132]                           }
[17:41:51.132]                         })
[17:41:51.132]                       }
[17:41:51.132]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:51.132]                       base::options(mc.cores = 1L)
[17:41:51.132]                     }
[17:41:51.132]                     base::local({
[17:41:51.132]                       for (pkg in "future") {
[17:41:51.132]                         base::loadNamespace(pkg)
[17:41:51.132]                         base::library(pkg, character.only = TRUE)
[17:41:51.132]                       }
[17:41:51.132]                     })
[17:41:51.132]                   }
[17:41:51.132]                   options(future.plan = NULL)
[17:41:51.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:51.132]                 }
[17:41:51.132]                 ...future.workdir <- getwd()
[17:41:51.132]             }
[17:41:51.132]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:51.132]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:51.132]         }
[17:41:51.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:51.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:51.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:51.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:51.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:51.132]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:51.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:51.132]             base::names(...future.oldOptions))
[17:41:51.132]     }
[17:41:51.132]     if (FALSE) {
[17:41:51.132]     }
[17:41:51.132]     else {
[17:41:51.132]         if (TRUE) {
[17:41:51.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:51.132]                 open = "w")
[17:41:51.132]         }
[17:41:51.132]         else {
[17:41:51.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:51.132]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:51.132]         }
[17:41:51.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:51.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:51.132]             base::sink(type = "output", split = FALSE)
[17:41:51.132]             base::close(...future.stdout)
[17:41:51.132]         }, add = TRUE)
[17:41:51.132]     }
[17:41:51.132]     ...future.frame <- base::sys.nframe()
[17:41:51.132]     ...future.conditions <- base::list()
[17:41:51.132]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:51.132]     if (FALSE) {
[17:41:51.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:51.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:51.132]     }
[17:41:51.132]     ...future.result <- base::tryCatch({
[17:41:51.132]         base::withCallingHandlers({
[17:41:51.132]             ...future.value <- base::withVisible(base::local({
[17:41:51.132]                 withCallingHandlers({
[17:41:51.132]                   {
[17:41:51.132]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:51.132]                       ii, n), appendLF = FALSE)
[17:41:51.132]                     fit <- mandelbrot(C)
[17:41:51.132]                     delay(fit)
[17:41:51.132]                     message(" done")
[17:41:51.132]                     fit
[17:41:51.132]                   }
[17:41:51.132]                 }, immediateCondition = function(cond) {
[17:41:51.132]                   save_rds <- function (object, pathname, ...) 
[17:41:51.132]                   {
[17:41:51.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:51.132]                     if (file_test("-f", pathname_tmp)) {
[17:41:51.132]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:51.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.132]                         fi_tmp[["mtime"]])
[17:41:51.132]                     }
[17:41:51.132]                     tryCatch({
[17:41:51.132]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:51.132]                     }, error = function(ex) {
[17:41:51.132]                       msg <- conditionMessage(ex)
[17:41:51.132]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:51.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.132]                         fi_tmp[["mtime"]], msg)
[17:41:51.132]                       ex$message <- msg
[17:41:51.132]                       stop(ex)
[17:41:51.132]                     })
[17:41:51.132]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:51.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:51.132]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:51.132]                       fi_tmp <- file.info(pathname_tmp)
[17:41:51.132]                       fi <- file.info(pathname)
[17:41:51.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:51.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:51.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:51.132]                         fi[["size"]], fi[["mtime"]])
[17:41:51.132]                       stop(msg)
[17:41:51.132]                     }
[17:41:51.132]                     invisible(pathname)
[17:41:51.132]                   }
[17:41:51.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:51.132]                     rootPath = tempdir()) 
[17:41:51.132]                   {
[17:41:51.132]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:51.132]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:51.132]                       tmpdir = path, fileext = ".rds")
[17:41:51.132]                     save_rds(obj, file)
[17:41:51.132]                   }
[17:41:51.132]                   saveImmediateCondition(cond, path = "/tmp/RtmpkaR8AW/.future/immediateConditions")
[17:41:51.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.132]                   {
[17:41:51.132]                     inherits <- base::inherits
[17:41:51.132]                     invokeRestart <- base::invokeRestart
[17:41:51.132]                     is.null <- base::is.null
[17:41:51.132]                     muffled <- FALSE
[17:41:51.132]                     if (inherits(cond, "message")) {
[17:41:51.132]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:51.132]                       if (muffled) 
[17:41:51.132]                         invokeRestart("muffleMessage")
[17:41:51.132]                     }
[17:41:51.132]                     else if (inherits(cond, "warning")) {
[17:41:51.132]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:51.132]                       if (muffled) 
[17:41:51.132]                         invokeRestart("muffleWarning")
[17:41:51.132]                     }
[17:41:51.132]                     else if (inherits(cond, "condition")) {
[17:41:51.132]                       if (!is.null(pattern)) {
[17:41:51.132]                         computeRestarts <- base::computeRestarts
[17:41:51.132]                         grepl <- base::grepl
[17:41:51.132]                         restarts <- computeRestarts(cond)
[17:41:51.132]                         for (restart in restarts) {
[17:41:51.132]                           name <- restart$name
[17:41:51.132]                           if (is.null(name)) 
[17:41:51.132]                             next
[17:41:51.132]                           if (!grepl(pattern, name)) 
[17:41:51.132]                             next
[17:41:51.132]                           invokeRestart(restart)
[17:41:51.132]                           muffled <- TRUE
[17:41:51.132]                           break
[17:41:51.132]                         }
[17:41:51.132]                       }
[17:41:51.132]                     }
[17:41:51.132]                     invisible(muffled)
[17:41:51.132]                   }
[17:41:51.132]                   muffleCondition(cond)
[17:41:51.132]                 })
[17:41:51.132]             }))
[17:41:51.132]             future::FutureResult(value = ...future.value$value, 
[17:41:51.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.132]                   ...future.rng), globalenv = if (FALSE) 
[17:41:51.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:51.132]                     ...future.globalenv.names))
[17:41:51.132]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:51.132]         }, condition = base::local({
[17:41:51.132]             c <- base::c
[17:41:51.132]             inherits <- base::inherits
[17:41:51.132]             invokeRestart <- base::invokeRestart
[17:41:51.132]             length <- base::length
[17:41:51.132]             list <- base::list
[17:41:51.132]             seq.int <- base::seq.int
[17:41:51.132]             signalCondition <- base::signalCondition
[17:41:51.132]             sys.calls <- base::sys.calls
[17:41:51.132]             `[[` <- base::`[[`
[17:41:51.132]             `+` <- base::`+`
[17:41:51.132]             `<<-` <- base::`<<-`
[17:41:51.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:51.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:51.132]                   3L)]
[17:41:51.132]             }
[17:41:51.132]             function(cond) {
[17:41:51.132]                 is_error <- inherits(cond, "error")
[17:41:51.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:51.132]                   NULL)
[17:41:51.132]                 if (is_error) {
[17:41:51.132]                   sessionInformation <- function() {
[17:41:51.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:51.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:51.132]                       search = base::search(), system = base::Sys.info())
[17:41:51.132]                   }
[17:41:51.132]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:51.132]                     cond$call), session = sessionInformation(), 
[17:41:51.132]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:51.132]                   signalCondition(cond)
[17:41:51.132]                 }
[17:41:51.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:51.132]                 "immediateCondition"))) {
[17:41:51.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:51.132]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:51.132]                   if (TRUE && !signal) {
[17:41:51.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.132]                     {
[17:41:51.132]                       inherits <- base::inherits
[17:41:51.132]                       invokeRestart <- base::invokeRestart
[17:41:51.132]                       is.null <- base::is.null
[17:41:51.132]                       muffled <- FALSE
[17:41:51.132]                       if (inherits(cond, "message")) {
[17:41:51.132]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.132]                         if (muffled) 
[17:41:51.132]                           invokeRestart("muffleMessage")
[17:41:51.132]                       }
[17:41:51.132]                       else if (inherits(cond, "warning")) {
[17:41:51.132]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.132]                         if (muffled) 
[17:41:51.132]                           invokeRestart("muffleWarning")
[17:41:51.132]                       }
[17:41:51.132]                       else if (inherits(cond, "condition")) {
[17:41:51.132]                         if (!is.null(pattern)) {
[17:41:51.132]                           computeRestarts <- base::computeRestarts
[17:41:51.132]                           grepl <- base::grepl
[17:41:51.132]                           restarts <- computeRestarts(cond)
[17:41:51.132]                           for (restart in restarts) {
[17:41:51.132]                             name <- restart$name
[17:41:51.132]                             if (is.null(name)) 
[17:41:51.132]                               next
[17:41:51.132]                             if (!grepl(pattern, name)) 
[17:41:51.132]                               next
[17:41:51.132]                             invokeRestart(restart)
[17:41:51.132]                             muffled <- TRUE
[17:41:51.132]                             break
[17:41:51.132]                           }
[17:41:51.132]                         }
[17:41:51.132]                       }
[17:41:51.132]                       invisible(muffled)
[17:41:51.132]                     }
[17:41:51.132]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.132]                   }
[17:41:51.132]                 }
[17:41:51.132]                 else {
[17:41:51.132]                   if (TRUE) {
[17:41:51.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.132]                     {
[17:41:51.132]                       inherits <- base::inherits
[17:41:51.132]                       invokeRestart <- base::invokeRestart
[17:41:51.132]                       is.null <- base::is.null
[17:41:51.132]                       muffled <- FALSE
[17:41:51.132]                       if (inherits(cond, "message")) {
[17:41:51.132]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.132]                         if (muffled) 
[17:41:51.132]                           invokeRestart("muffleMessage")
[17:41:51.132]                       }
[17:41:51.132]                       else if (inherits(cond, "warning")) {
[17:41:51.132]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.132]                         if (muffled) 
[17:41:51.132]                           invokeRestart("muffleWarning")
[17:41:51.132]                       }
[17:41:51.132]                       else if (inherits(cond, "condition")) {
[17:41:51.132]                         if (!is.null(pattern)) {
[17:41:51.132]                           computeRestarts <- base::computeRestarts
[17:41:51.132]                           grepl <- base::grepl
[17:41:51.132]                           restarts <- computeRestarts(cond)
[17:41:51.132]                           for (restart in restarts) {
[17:41:51.132]                             name <- restart$name
[17:41:51.132]                             if (is.null(name)) 
[17:41:51.132]                               next
[17:41:51.132]                             if (!grepl(pattern, name)) 
[17:41:51.132]                               next
[17:41:51.132]                             invokeRestart(restart)
[17:41:51.132]                             muffled <- TRUE
[17:41:51.132]                             break
[17:41:51.132]                           }
[17:41:51.132]                         }
[17:41:51.132]                       }
[17:41:51.132]                       invisible(muffled)
[17:41:51.132]                     }
[17:41:51.132]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.132]                   }
[17:41:51.132]                 }
[17:41:51.132]             }
[17:41:51.132]         }))
[17:41:51.132]     }, error = function(ex) {
[17:41:51.132]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:51.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.132]                 ...future.rng), started = ...future.startTime, 
[17:41:51.132]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:51.132]             version = "1.8"), class = "FutureResult")
[17:41:51.132]     }, finally = {
[17:41:51.132]         if (!identical(...future.workdir, getwd())) 
[17:41:51.132]             setwd(...future.workdir)
[17:41:51.132]         {
[17:41:51.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:51.132]                 ...future.oldOptions$nwarnings <- NULL
[17:41:51.132]             }
[17:41:51.132]             base::options(...future.oldOptions)
[17:41:51.132]             if (.Platform$OS.type == "windows") {
[17:41:51.132]                 old_names <- names(...future.oldEnvVars)
[17:41:51.132]                 envs <- base::Sys.getenv()
[17:41:51.132]                 names <- names(envs)
[17:41:51.132]                 common <- intersect(names, old_names)
[17:41:51.132]                 added <- setdiff(names, old_names)
[17:41:51.132]                 removed <- setdiff(old_names, names)
[17:41:51.132]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:51.132]                   envs[common]]
[17:41:51.132]                 NAMES <- toupper(changed)
[17:41:51.132]                 args <- list()
[17:41:51.132]                 for (kk in seq_along(NAMES)) {
[17:41:51.132]                   name <- changed[[kk]]
[17:41:51.132]                   NAME <- NAMES[[kk]]
[17:41:51.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.132]                     next
[17:41:51.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.132]                 }
[17:41:51.132]                 NAMES <- toupper(added)
[17:41:51.132]                 for (kk in seq_along(NAMES)) {
[17:41:51.132]                   name <- added[[kk]]
[17:41:51.132]                   NAME <- NAMES[[kk]]
[17:41:51.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.132]                     next
[17:41:51.132]                   args[[name]] <- ""
[17:41:51.132]                 }
[17:41:51.132]                 NAMES <- toupper(removed)
[17:41:51.132]                 for (kk in seq_along(NAMES)) {
[17:41:51.132]                   name <- removed[[kk]]
[17:41:51.132]                   NAME <- NAMES[[kk]]
[17:41:51.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.132]                     next
[17:41:51.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.132]                 }
[17:41:51.132]                 if (length(args) > 0) 
[17:41:51.132]                   base::do.call(base::Sys.setenv, args = args)
[17:41:51.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:51.132]             }
[17:41:51.132]             else {
[17:41:51.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:51.132]             }
[17:41:51.132]             {
[17:41:51.132]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:51.132]                   0L) {
[17:41:51.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:51.132]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:51.132]                   base::options(opts)
[17:41:51.132]                 }
[17:41:51.132]                 {
[17:41:51.132]                   {
[17:41:51.132]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:51.132]                     NULL
[17:41:51.132]                   }
[17:41:51.132]                   options(future.plan = NULL)
[17:41:51.132]                   if (is.na(NA_character_)) 
[17:41:51.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:51.132]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:51.132]                     envir = parent.frame()) 
[17:41:51.132]                   {
[17:41:51.132]                     default_workers <- missing(workers)
[17:41:51.132]                     if (is.function(workers)) 
[17:41:51.132]                       workers <- workers()
[17:41:51.132]                     workers <- structure(as.integer(workers), 
[17:41:51.132]                       class = class(workers))
[17:41:51.132]                     stop_if_not(is.finite(workers), workers >= 
[17:41:51.132]                       1L)
[17:41:51.132]                     if ((workers == 1L && !inherits(workers, 
[17:41:51.132]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:51.132]                       if (default_workers) 
[17:41:51.132]                         supportsMulticore(warn = TRUE)
[17:41:51.132]                       return(sequential(..., envir = envir))
[17:41:51.132]                     }
[17:41:51.132]                     oopts <- options(mc.cores = workers)
[17:41:51.132]                     on.exit(options(oopts))
[17:41:51.132]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:51.132]                       envir = envir)
[17:41:51.132]                     if (!future$lazy) 
[17:41:51.132]                       future <- run(future)
[17:41:51.132]                     invisible(future)
[17:41:51.132]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:51.132]                 }
[17:41:51.132]             }
[17:41:51.132]         }
[17:41:51.132]     })
[17:41:51.132]     if (TRUE) {
[17:41:51.132]         base::sink(type = "output", split = FALSE)
[17:41:51.132]         if (TRUE) {
[17:41:51.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:51.132]         }
[17:41:51.132]         else {
[17:41:51.132]             ...future.result["stdout"] <- base::list(NULL)
[17:41:51.132]         }
[17:41:51.132]         base::close(...future.stdout)
[17:41:51.132]         ...future.stdout <- NULL
[17:41:51.132]     }
[17:41:51.132]     ...future.result$conditions <- ...future.conditions
[17:41:51.132]     ...future.result$finished <- base::Sys.time()
[17:41:51.132]     ...future.result
[17:41:51.132] }
[17:41:51.135] assign_globals() ...
[17:41:51.136] List of 4
[17:41:51.136]  $ ii   : int 4
[17:41:51.136]  $ n    : int 4
[17:41:51.136]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[17:41:51.136]   ..- attr(*, "region")=List of 2
[17:41:51.136]   .. ..$ xrange: num [1:2] -0.719 0.75
[17:41:51.136]   .. ..$ yrange: num [1:2] 0.0306 1.5
[17:41:51.136]   ..- attr(*, "tile")= int [1:2] 2 2
[17:41:51.136]  $ delay:function (counts)  
[17:41:51.136]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[17:41:51.136]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56348d9fb9f8> 
[17:41:51.136]  - attr(*, "where")=List of 4
[17:41:51.136]   ..$ ii   :<environment: R_EmptyEnv> 
[17:41:51.136]   ..$ n    :<environment: R_EmptyEnv> 
[17:41:51.136]   ..$ C    :<environment: R_EmptyEnv> 
[17:41:51.136]   ..$ delay:<environment: R_EmptyEnv> 
[17:41:51.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:51.136]  - attr(*, "resolved")= logi FALSE
[17:41:51.136]  - attr(*, "total_size")= num 14584
[17:41:51.136]  - attr(*, "already-done")= logi TRUE
[17:41:51.145] - copied ‘ii’ to environment
[17:41:51.145] - copied ‘n’ to environment
[17:41:51.145] - copied ‘C’ to environment
[17:41:51.145] - reassign environment for ‘delay’
[17:41:51.146] - copied ‘delay’ to environment
[17:41:51.146] assign_globals() ... done
[17:41:51.146] requestCore(): workers = 2
[17:41:51.146] Poll #1 (0): usedCores() = 2, workers = 2
[17:41:51.158] signalConditions() ...
[17:41:51.158]  - include = ‘immediateCondition’
[17:41:51.158]  - exclude = 
[17:41:51.158]  - resignal = FALSE
[17:41:51.159]  - Number of conditions: 2
[17:41:51.159] signalConditions() ... done
[17:41:51.159] signalConditions() ...
[17:41:51.159]  - include = ‘immediateCondition’
[17:41:51.159]  - exclude = 
[17:41:51.159]  - resignal = FALSE
[17:41:51.159]  - Number of conditions: 2
[17:41:51.160] signalConditions() ... done
[17:41:51.162] MulticoreFuture started
[17:41:51.163] - Launch lazy future ... done
[17:41:51.163] run() for ‘MulticoreFuture’ ... done
[17:41:51.163] - run() ... done
[17:41:51.163] - resolved() ...
[17:41:51.164] plan(): Setting new future strategy stack:
[17:41:51.164] List of future strategies:
[17:41:51.164] 1. sequential:
[17:41:51.164]    - args: function (..., envir = parent.frame())
[17:41:51.164]    - tweaked: FALSE
[17:41:51.164]    - call: NULL
[17:41:51.165] plan(): nbrOfWorkers() = 1
[17:41:51.169] plan(): Setting new future strategy stack:
[17:41:51.170] List of future strategies:
[17:41:51.170] 1. multicore:
[17:41:51.170]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:51.170]    - tweaked: FALSE
[17:41:51.170]    - call: plan(strategy)
[17:41:51.174] - resolved: FALSE
[17:41:51.174] - resolved() ... done
[17:41:51.174] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[17:41:51.175] plan(): nbrOfWorkers() = 2
[17:41:51.175] signalConditions() ...
[17:41:51.175]  - include = ‘immediateCondition’
[17:41:51.175]  - exclude = 
[17:41:51.175]  - resignal = FALSE
[17:41:51.176]  - Number of conditions: 2
[17:41:51.176] signalConditions() ... done
[17:41:51.176] Future state: ‘finished’
[17:41:51.176] signalConditions() ...
[17:41:51.176]  - include = ‘condition’
[17:41:51.177]  - exclude = ‘immediateCondition’
[17:41:51.177]  - resignal = TRUE
[17:41:51.177]  - Number of conditions: 2
[17:41:51.177]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[17:41:51.177]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:51.177] signalConditions() ... done
Plotting tile #3 of 4 ...
[17:41:51.180] signalConditions() ...
[17:41:51.180]  - include = ‘immediateCondition’
[17:41:51.180]  - exclude = 
[17:41:51.180]  - resignal = FALSE
[17:41:51.181]  - Number of conditions: 2
[17:41:51.181] signalConditions() ... done
[17:41:51.181] signalConditions() ...
[17:41:51.181]  - include = ‘immediateCondition’
[17:41:51.181]  - exclude = 
[17:41:51.182]  - resignal = FALSE
[17:41:51.182]  - Number of conditions: 2
[17:41:51.182] signalConditions() ... done
[17:41:51.182] Future state: ‘finished’
[17:41:51.182] signalConditions() ...
[17:41:51.182]  - include = ‘condition’
[17:41:51.183]  - exclude = ‘immediateCondition’
[17:41:51.183]  - resignal = TRUE
[17:41:51.183]  - Number of conditions: 2
[17:41:51.183]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[17:41:51.183]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:51.184] signalConditions() ... done
Plotting tile #4 of 4 ...
[17:41:51.185] signalConditions() ...
[17:41:51.186]  - include = ‘immediateCondition’
[17:41:51.186]  - exclude = 
[17:41:51.186]  - resignal = FALSE
[17:41:51.186]  - Number of conditions: 2
[17:41:51.186] signalConditions() ... done
[17:41:51.186] signalConditions() ...
[17:41:51.186]  - include = ‘immediateCondition’
[17:41:51.187]  - exclude = 
[17:41:51.187]  - resignal = FALSE
[17:41:51.187]  - Number of conditions: 2
[17:41:51.187] signalConditions() ... done
[17:41:51.187] Future state: ‘finished’
[17:41:51.187] signalConditions() ...
[17:41:51.187]  - include = ‘condition’
[17:41:51.188]  - exclude = ‘immediateCondition’
[17:41:51.188]  - resignal = TRUE
[17:41:51.188]  - Number of conditions: 2
[17:41:51.188]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[17:41:51.188]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:51.188] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[17:41:51.190] plan(): Setting new future strategy stack:
[17:41:51.190] List of future strategies:
[17:41:51.190] 1. multisession:
[17:41:51.190]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:51.190]    - tweaked: FALSE
[17:41:51.190]    - call: plan(strategy)
[17:41:51.191] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:41:51.191] multisession:
[17:41:51.191] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:51.191] - tweaked: FALSE
[17:41:51.191] - call: plan(strategy)
[17:41:51.198] getGlobalsAndPackages() ...
[17:41:51.198] Not searching for globals
[17:41:51.198] - globals: [0] <none>
[17:41:51.198] getGlobalsAndPackages() ... DONE
[17:41:51.199] [local output] makeClusterPSOCK() ...
[17:41:51.252] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:41:51.258] [local output] Base port: 11877
[17:41:51.258] [local output] Getting setup options for 2 cluster nodes ...
[17:41:51.258] [local output]  - Node 1 of 2 ...
[17:41:51.259] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:51.259] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpkaR8AW/worker.rank=1.parallelly.parent=42484.a5f41452f94c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpkaR8AW/worker.rank=1.parallelly.parent=42484.a5f41452f94c.pid")'’
[17:41:51.451] - Possible to infer worker's PID: TRUE
[17:41:51.451] [local output] Rscript port: 11877

[17:41:51.452] [local output]  - Node 2 of 2 ...
[17:41:51.452] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:51.453] [local output] Rscript port: 11877

[17:41:51.453] [local output] Getting setup options for 2 cluster nodes ... done
[17:41:51.453] [local output]  - Parallel setup requested for some PSOCK nodes
[17:41:51.454] [local output] Setting up PSOCK nodes in parallel
[17:41:51.454] List of 36
[17:41:51.454]  $ worker          : chr "localhost"
[17:41:51.454]   ..- attr(*, "localhost")= logi TRUE
[17:41:51.454]  $ master          : chr "localhost"
[17:41:51.454]  $ port            : int 11877
[17:41:51.454]  $ connectTimeout  : num 120
[17:41:51.454]  $ timeout         : num 2592000
[17:41:51.454]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:41:51.454]  $ homogeneous     : logi TRUE
[17:41:51.454]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:41:51.454]  $ rscript_envs    : NULL
[17:41:51.454]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:51.454]  $ rscript_startup : NULL
[17:41:51.454]  $ rscript_sh      : chr "sh"
[17:41:51.454]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:51.454]  $ methods         : logi TRUE
[17:41:51.454]  $ socketOptions   : chr "no-delay"
[17:41:51.454]  $ useXDR          : logi FALSE
[17:41:51.454]  $ outfile         : chr "/dev/null"
[17:41:51.454]  $ renice          : int NA
[17:41:51.454]  $ rshcmd          : NULL
[17:41:51.454]  $ user            : chr(0) 
[17:41:51.454]  $ revtunnel       : logi FALSE
[17:41:51.454]  $ rshlogfile      : NULL
[17:41:51.454]  $ rshopts         : chr(0) 
[17:41:51.454]  $ rank            : int 1
[17:41:51.454]  $ manual          : logi FALSE
[17:41:51.454]  $ dryrun          : logi FALSE
[17:41:51.454]  $ quiet           : logi FALSE
[17:41:51.454]  $ setup_strategy  : chr "parallel"
[17:41:51.454]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:51.454]  $ pidfile         : chr "/tmp/RtmpkaR8AW/worker.rank=1.parallelly.parent=42484.a5f41452f94c.pid"
[17:41:51.454]  $ rshcmd_label    : NULL
[17:41:51.454]  $ rsh_call        : NULL
[17:41:51.454]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:51.454]  $ localMachine    : logi TRUE
[17:41:51.454]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:41:51.454]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:41:51.454]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:41:51.454]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:41:51.454]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:41:51.454]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:41:51.454]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:41:51.454]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:41:51.454]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:41:51.454]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:41:51.454]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:41:51.454]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:41:51.454]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:41:51.454]  $ arguments       :List of 28
[17:41:51.454]   ..$ worker          : chr "localhost"
[17:41:51.454]   ..$ master          : NULL
[17:41:51.454]   ..$ port            : int 11877
[17:41:51.454]   ..$ connectTimeout  : num 120
[17:41:51.454]   ..$ timeout         : num 2592000
[17:41:51.454]   ..$ rscript         : NULL
[17:41:51.454]   ..$ homogeneous     : NULL
[17:41:51.454]   ..$ rscript_args    : NULL
[17:41:51.454]   ..$ rscript_envs    : NULL
[17:41:51.454]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:51.454]   ..$ rscript_startup : NULL
[17:41:51.454]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:41:51.454]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:51.454]   ..$ methods         : logi TRUE
[17:41:51.454]   ..$ socketOptions   : chr "no-delay"
[17:41:51.454]   ..$ useXDR          : logi FALSE
[17:41:51.454]   ..$ outfile         : chr "/dev/null"
[17:41:51.454]   ..$ renice          : int NA
[17:41:51.454]   ..$ rshcmd          : NULL
[17:41:51.454]   ..$ user            : NULL
[17:41:51.454]   ..$ revtunnel       : logi NA
[17:41:51.454]   ..$ rshlogfile      : NULL
[17:41:51.454]   ..$ rshopts         : NULL
[17:41:51.454]   ..$ rank            : int 1
[17:41:51.454]   ..$ manual          : logi FALSE
[17:41:51.454]   ..$ dryrun          : logi FALSE
[17:41:51.454]   ..$ quiet           : logi FALSE
[17:41:51.454]   ..$ setup_strategy  : chr "parallel"
[17:41:51.454]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:41:51.470] [local output] System call to launch all workers:
[17:41:51.470] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpkaR8AW/worker.rank=1.parallelly.parent=42484.a5f41452f94c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11877 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:41:51.471] [local output] Starting PSOCK main server
[17:41:51.472] [local output] Workers launched
[17:41:51.472] [local output] Waiting for workers to connect back
[17:41:51.472]  - [local output] 0 workers out of 2 ready
[17:41:51.721]  - [local output] 0 workers out of 2 ready
[17:41:51.721]  - [local output] 1 workers out of 2 ready
[17:41:51.724]  - [local output] 1 workers out of 2 ready
[17:41:51.724]  - [local output] 2 workers out of 2 ready
[17:41:51.724] [local output] Launching of workers completed
[17:41:51.724] [local output] Collecting session information from workers
[17:41:51.725] [local output]  - Worker #1 of 2
[17:41:51.726] [local output]  - Worker #2 of 2
[17:41:51.726] [local output] makeClusterPSOCK() ... done
[17:41:51.738] Packages needed by the future expression (n = 0): <none>
[17:41:51.738] Packages needed by future strategies (n = 0): <none>
[17:41:51.738] {
[17:41:51.738]     {
[17:41:51.738]         {
[17:41:51.738]             ...future.startTime <- base::Sys.time()
[17:41:51.738]             {
[17:41:51.738]                 {
[17:41:51.738]                   {
[17:41:51.738]                     {
[17:41:51.738]                       base::local({
[17:41:51.738]                         has_future <- base::requireNamespace("future", 
[17:41:51.738]                           quietly = TRUE)
[17:41:51.738]                         if (has_future) {
[17:41:51.738]                           ns <- base::getNamespace("future")
[17:41:51.738]                           version <- ns[[".package"]][["version"]]
[17:41:51.738]                           if (is.null(version)) 
[17:41:51.738]                             version <- utils::packageVersion("future")
[17:41:51.738]                         }
[17:41:51.738]                         else {
[17:41:51.738]                           version <- NULL
[17:41:51.738]                         }
[17:41:51.738]                         if (!has_future || version < "1.8.0") {
[17:41:51.738]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:51.738]                             "", base::R.version$version.string), 
[17:41:51.738]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:51.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:51.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:51.738]                               "release", "version")], collapse = " "), 
[17:41:51.738]                             hostname = base::Sys.info()[["nodename"]])
[17:41:51.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:51.738]                             info)
[17:41:51.738]                           info <- base::paste(info, collapse = "; ")
[17:41:51.738]                           if (!has_future) {
[17:41:51.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:51.738]                               info)
[17:41:51.738]                           }
[17:41:51.738]                           else {
[17:41:51.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:51.738]                               info, version)
[17:41:51.738]                           }
[17:41:51.738]                           base::stop(msg)
[17:41:51.738]                         }
[17:41:51.738]                       })
[17:41:51.738]                     }
[17:41:51.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:51.738]                     base::options(mc.cores = 1L)
[17:41:51.738]                   }
[17:41:51.738]                   options(future.plan = NULL)
[17:41:51.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:51.738]                 }
[17:41:51.738]                 ...future.workdir <- getwd()
[17:41:51.738]             }
[17:41:51.738]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:51.738]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:51.738]         }
[17:41:51.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:51.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:51.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:51.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:51.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:51.738]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:51.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:51.738]             base::names(...future.oldOptions))
[17:41:51.738]     }
[17:41:51.738]     if (FALSE) {
[17:41:51.738]     }
[17:41:51.738]     else {
[17:41:51.738]         if (TRUE) {
[17:41:51.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:51.738]                 open = "w")
[17:41:51.738]         }
[17:41:51.738]         else {
[17:41:51.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:51.738]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:51.738]         }
[17:41:51.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:51.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:51.738]             base::sink(type = "output", split = FALSE)
[17:41:51.738]             base::close(...future.stdout)
[17:41:51.738]         }, add = TRUE)
[17:41:51.738]     }
[17:41:51.738]     ...future.frame <- base::sys.nframe()
[17:41:51.738]     ...future.conditions <- base::list()
[17:41:51.738]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:51.738]     if (FALSE) {
[17:41:51.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:51.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:51.738]     }
[17:41:51.738]     ...future.result <- base::tryCatch({
[17:41:51.738]         base::withCallingHandlers({
[17:41:51.738]             ...future.value <- base::withVisible(base::local({
[17:41:51.738]                 ...future.makeSendCondition <- local({
[17:41:51.738]                   sendCondition <- NULL
[17:41:51.738]                   function(frame = 1L) {
[17:41:51.738]                     if (is.function(sendCondition)) 
[17:41:51.738]                       return(sendCondition)
[17:41:51.738]                     ns <- getNamespace("parallel")
[17:41:51.738]                     if (exists("sendData", mode = "function", 
[17:41:51.738]                       envir = ns)) {
[17:41:51.738]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:51.738]                         envir = ns)
[17:41:51.738]                       envir <- sys.frame(frame)
[17:41:51.738]                       master <- NULL
[17:41:51.738]                       while (!identical(envir, .GlobalEnv) && 
[17:41:51.738]                         !identical(envir, emptyenv())) {
[17:41:51.738]                         if (exists("master", mode = "list", envir = envir, 
[17:41:51.738]                           inherits = FALSE)) {
[17:41:51.738]                           master <- get("master", mode = "list", 
[17:41:51.738]                             envir = envir, inherits = FALSE)
[17:41:51.738]                           if (inherits(master, c("SOCKnode", 
[17:41:51.738]                             "SOCK0node"))) {
[17:41:51.738]                             sendCondition <<- function(cond) {
[17:41:51.738]                               data <- list(type = "VALUE", value = cond, 
[17:41:51.738]                                 success = TRUE)
[17:41:51.738]                               parallel_sendData(master, data)
[17:41:51.738]                             }
[17:41:51.738]                             return(sendCondition)
[17:41:51.738]                           }
[17:41:51.738]                         }
[17:41:51.738]                         frame <- frame + 1L
[17:41:51.738]                         envir <- sys.frame(frame)
[17:41:51.738]                       }
[17:41:51.738]                     }
[17:41:51.738]                     sendCondition <<- function(cond) NULL
[17:41:51.738]                   }
[17:41:51.738]                 })
[17:41:51.738]                 withCallingHandlers({
[17:41:51.738]                   NA
[17:41:51.738]                 }, immediateCondition = function(cond) {
[17:41:51.738]                   sendCondition <- ...future.makeSendCondition()
[17:41:51.738]                   sendCondition(cond)
[17:41:51.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.738]                   {
[17:41:51.738]                     inherits <- base::inherits
[17:41:51.738]                     invokeRestart <- base::invokeRestart
[17:41:51.738]                     is.null <- base::is.null
[17:41:51.738]                     muffled <- FALSE
[17:41:51.738]                     if (inherits(cond, "message")) {
[17:41:51.738]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:51.738]                       if (muffled) 
[17:41:51.738]                         invokeRestart("muffleMessage")
[17:41:51.738]                     }
[17:41:51.738]                     else if (inherits(cond, "warning")) {
[17:41:51.738]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:51.738]                       if (muffled) 
[17:41:51.738]                         invokeRestart("muffleWarning")
[17:41:51.738]                     }
[17:41:51.738]                     else if (inherits(cond, "condition")) {
[17:41:51.738]                       if (!is.null(pattern)) {
[17:41:51.738]                         computeRestarts <- base::computeRestarts
[17:41:51.738]                         grepl <- base::grepl
[17:41:51.738]                         restarts <- computeRestarts(cond)
[17:41:51.738]                         for (restart in restarts) {
[17:41:51.738]                           name <- restart$name
[17:41:51.738]                           if (is.null(name)) 
[17:41:51.738]                             next
[17:41:51.738]                           if (!grepl(pattern, name)) 
[17:41:51.738]                             next
[17:41:51.738]                           invokeRestart(restart)
[17:41:51.738]                           muffled <- TRUE
[17:41:51.738]                           break
[17:41:51.738]                         }
[17:41:51.738]                       }
[17:41:51.738]                     }
[17:41:51.738]                     invisible(muffled)
[17:41:51.738]                   }
[17:41:51.738]                   muffleCondition(cond)
[17:41:51.738]                 })
[17:41:51.738]             }))
[17:41:51.738]             future::FutureResult(value = ...future.value$value, 
[17:41:51.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.738]                   ...future.rng), globalenv = if (FALSE) 
[17:41:51.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:51.738]                     ...future.globalenv.names))
[17:41:51.738]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:51.738]         }, condition = base::local({
[17:41:51.738]             c <- base::c
[17:41:51.738]             inherits <- base::inherits
[17:41:51.738]             invokeRestart <- base::invokeRestart
[17:41:51.738]             length <- base::length
[17:41:51.738]             list <- base::list
[17:41:51.738]             seq.int <- base::seq.int
[17:41:51.738]             signalCondition <- base::signalCondition
[17:41:51.738]             sys.calls <- base::sys.calls
[17:41:51.738]             `[[` <- base::`[[`
[17:41:51.738]             `+` <- base::`+`
[17:41:51.738]             `<<-` <- base::`<<-`
[17:41:51.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:51.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:51.738]                   3L)]
[17:41:51.738]             }
[17:41:51.738]             function(cond) {
[17:41:51.738]                 is_error <- inherits(cond, "error")
[17:41:51.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:51.738]                   NULL)
[17:41:51.738]                 if (is_error) {
[17:41:51.738]                   sessionInformation <- function() {
[17:41:51.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:51.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:51.738]                       search = base::search(), system = base::Sys.info())
[17:41:51.738]                   }
[17:41:51.738]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:51.738]                     cond$call), session = sessionInformation(), 
[17:41:51.738]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:51.738]                   signalCondition(cond)
[17:41:51.738]                 }
[17:41:51.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:51.738]                 "immediateCondition"))) {
[17:41:51.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:51.738]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:51.738]                   if (TRUE && !signal) {
[17:41:51.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.738]                     {
[17:41:51.738]                       inherits <- base::inherits
[17:41:51.738]                       invokeRestart <- base::invokeRestart
[17:41:51.738]                       is.null <- base::is.null
[17:41:51.738]                       muffled <- FALSE
[17:41:51.738]                       if (inherits(cond, "message")) {
[17:41:51.738]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.738]                         if (muffled) 
[17:41:51.738]                           invokeRestart("muffleMessage")
[17:41:51.738]                       }
[17:41:51.738]                       else if (inherits(cond, "warning")) {
[17:41:51.738]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.738]                         if (muffled) 
[17:41:51.738]                           invokeRestart("muffleWarning")
[17:41:51.738]                       }
[17:41:51.738]                       else if (inherits(cond, "condition")) {
[17:41:51.738]                         if (!is.null(pattern)) {
[17:41:51.738]                           computeRestarts <- base::computeRestarts
[17:41:51.738]                           grepl <- base::grepl
[17:41:51.738]                           restarts <- computeRestarts(cond)
[17:41:51.738]                           for (restart in restarts) {
[17:41:51.738]                             name <- restart$name
[17:41:51.738]                             if (is.null(name)) 
[17:41:51.738]                               next
[17:41:51.738]                             if (!grepl(pattern, name)) 
[17:41:51.738]                               next
[17:41:51.738]                             invokeRestart(restart)
[17:41:51.738]                             muffled <- TRUE
[17:41:51.738]                             break
[17:41:51.738]                           }
[17:41:51.738]                         }
[17:41:51.738]                       }
[17:41:51.738]                       invisible(muffled)
[17:41:51.738]                     }
[17:41:51.738]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.738]                   }
[17:41:51.738]                 }
[17:41:51.738]                 else {
[17:41:51.738]                   if (TRUE) {
[17:41:51.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.738]                     {
[17:41:51.738]                       inherits <- base::inherits
[17:41:51.738]                       invokeRestart <- base::invokeRestart
[17:41:51.738]                       is.null <- base::is.null
[17:41:51.738]                       muffled <- FALSE
[17:41:51.738]                       if (inherits(cond, "message")) {
[17:41:51.738]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.738]                         if (muffled) 
[17:41:51.738]                           invokeRestart("muffleMessage")
[17:41:51.738]                       }
[17:41:51.738]                       else if (inherits(cond, "warning")) {
[17:41:51.738]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.738]                         if (muffled) 
[17:41:51.738]                           invokeRestart("muffleWarning")
[17:41:51.738]                       }
[17:41:51.738]                       else if (inherits(cond, "condition")) {
[17:41:51.738]                         if (!is.null(pattern)) {
[17:41:51.738]                           computeRestarts <- base::computeRestarts
[17:41:51.738]                           grepl <- base::grepl
[17:41:51.738]                           restarts <- computeRestarts(cond)
[17:41:51.738]                           for (restart in restarts) {
[17:41:51.738]                             name <- restart$name
[17:41:51.738]                             if (is.null(name)) 
[17:41:51.738]                               next
[17:41:51.738]                             if (!grepl(pattern, name)) 
[17:41:51.738]                               next
[17:41:51.738]                             invokeRestart(restart)
[17:41:51.738]                             muffled <- TRUE
[17:41:51.738]                             break
[17:41:51.738]                           }
[17:41:51.738]                         }
[17:41:51.738]                       }
[17:41:51.738]                       invisible(muffled)
[17:41:51.738]                     }
[17:41:51.738]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.738]                   }
[17:41:51.738]                 }
[17:41:51.738]             }
[17:41:51.738]         }))
[17:41:51.738]     }, error = function(ex) {
[17:41:51.738]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:51.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.738]                 ...future.rng), started = ...future.startTime, 
[17:41:51.738]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:51.738]             version = "1.8"), class = "FutureResult")
[17:41:51.738]     }, finally = {
[17:41:51.738]         if (!identical(...future.workdir, getwd())) 
[17:41:51.738]             setwd(...future.workdir)
[17:41:51.738]         {
[17:41:51.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:51.738]                 ...future.oldOptions$nwarnings <- NULL
[17:41:51.738]             }
[17:41:51.738]             base::options(...future.oldOptions)
[17:41:51.738]             if (.Platform$OS.type == "windows") {
[17:41:51.738]                 old_names <- names(...future.oldEnvVars)
[17:41:51.738]                 envs <- base::Sys.getenv()
[17:41:51.738]                 names <- names(envs)
[17:41:51.738]                 common <- intersect(names, old_names)
[17:41:51.738]                 added <- setdiff(names, old_names)
[17:41:51.738]                 removed <- setdiff(old_names, names)
[17:41:51.738]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:51.738]                   envs[common]]
[17:41:51.738]                 NAMES <- toupper(changed)
[17:41:51.738]                 args <- list()
[17:41:51.738]                 for (kk in seq_along(NAMES)) {
[17:41:51.738]                   name <- changed[[kk]]
[17:41:51.738]                   NAME <- NAMES[[kk]]
[17:41:51.738]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.738]                     next
[17:41:51.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.738]                 }
[17:41:51.738]                 NAMES <- toupper(added)
[17:41:51.738]                 for (kk in seq_along(NAMES)) {
[17:41:51.738]                   name <- added[[kk]]
[17:41:51.738]                   NAME <- NAMES[[kk]]
[17:41:51.738]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.738]                     next
[17:41:51.738]                   args[[name]] <- ""
[17:41:51.738]                 }
[17:41:51.738]                 NAMES <- toupper(removed)
[17:41:51.738]                 for (kk in seq_along(NAMES)) {
[17:41:51.738]                   name <- removed[[kk]]
[17:41:51.738]                   NAME <- NAMES[[kk]]
[17:41:51.738]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.738]                     next
[17:41:51.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.738]                 }
[17:41:51.738]                 if (length(args) > 0) 
[17:41:51.738]                   base::do.call(base::Sys.setenv, args = args)
[17:41:51.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:51.738]             }
[17:41:51.738]             else {
[17:41:51.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:51.738]             }
[17:41:51.738]             {
[17:41:51.738]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:51.738]                   0L) {
[17:41:51.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:51.738]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:51.738]                   base::options(opts)
[17:41:51.738]                 }
[17:41:51.738]                 {
[17:41:51.738]                   {
[17:41:51.738]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:51.738]                     NULL
[17:41:51.738]                   }
[17:41:51.738]                   options(future.plan = NULL)
[17:41:51.738]                   if (is.na(NA_character_)) 
[17:41:51.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:51.738]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:51.738]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:51.738]                     envir = parent.frame()) 
[17:41:51.738]                   {
[17:41:51.738]                     if (is.function(workers)) 
[17:41:51.738]                       workers <- workers()
[17:41:51.738]                     workers <- structure(as.integer(workers), 
[17:41:51.738]                       class = class(workers))
[17:41:51.738]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:51.738]                       workers >= 1)
[17:41:51.738]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:51.738]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:51.738]                     }
[17:41:51.738]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:51.738]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:51.738]                       envir = envir)
[17:41:51.738]                     if (!future$lazy) 
[17:41:51.738]                       future <- run(future)
[17:41:51.738]                     invisible(future)
[17:41:51.738]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:51.738]                 }
[17:41:51.738]             }
[17:41:51.738]         }
[17:41:51.738]     })
[17:41:51.738]     if (TRUE) {
[17:41:51.738]         base::sink(type = "output", split = FALSE)
[17:41:51.738]         if (TRUE) {
[17:41:51.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:51.738]         }
[17:41:51.738]         else {
[17:41:51.738]             ...future.result["stdout"] <- base::list(NULL)
[17:41:51.738]         }
[17:41:51.738]         base::close(...future.stdout)
[17:41:51.738]         ...future.stdout <- NULL
[17:41:51.738]     }
[17:41:51.738]     ...future.result$conditions <- ...future.conditions
[17:41:51.738]     ...future.result$finished <- base::Sys.time()
[17:41:51.738]     ...future.result
[17:41:51.738] }
[17:41:51.812] MultisessionFuture started
[17:41:51.812] result() for ClusterFuture ...
[17:41:51.813] receiveMessageFromWorker() for ClusterFuture ...
[17:41:51.813] - Validating connection of MultisessionFuture
[17:41:51.846] - received message: FutureResult
[17:41:51.846] - Received FutureResult
[17:41:51.846] - Erased future from FutureRegistry
[17:41:51.846] result() for ClusterFuture ...
[17:41:51.846] - result already collected: FutureResult
[17:41:51.846] result() for ClusterFuture ... done
[17:41:51.846] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:51.847] result() for ClusterFuture ... done
[17:41:51.847] result() for ClusterFuture ...
[17:41:51.847] - result already collected: FutureResult
[17:41:51.847] result() for ClusterFuture ... done
[17:41:51.847] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:41:51.850] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[17:41:51.854] getGlobalsAndPackages() ...
[17:41:51.854] Searching for globals...
[17:41:51.858] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:51.858] Searching for globals ... DONE
[17:41:51.858] Resolving globals: FALSE
[17:41:51.859] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:51.859] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:51.859] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:51.859] - packages: [1] ‘future’
[17:41:51.860] getGlobalsAndPackages() ... DONE
 2[17:41:51.863] getGlobalsAndPackages() ...
[17:41:51.863] Searching for globals...
[17:41:51.867] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:51.867] Searching for globals ... DONE
[17:41:51.867] Resolving globals: FALSE
[17:41:51.867] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:51.868] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:51.868] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:51.868] - packages: [1] ‘future’
[17:41:51.868] getGlobalsAndPackages() ... DONE
 3[17:41:51.869] getGlobalsAndPackages() ...
[17:41:51.869] Searching for globals...
[17:41:51.872] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:51.872] Searching for globals ... DONE
[17:41:51.872] Resolving globals: FALSE
[17:41:51.873] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:51.873] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:51.873] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:51.873] - packages: [1] ‘future’
[17:41:51.874] getGlobalsAndPackages() ... DONE
 4[17:41:51.874] getGlobalsAndPackages() ...
[17:41:51.874] Searching for globals...
[17:41:51.877] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[17:41:51.877] Searching for globals ... DONE
[17:41:51.877] Resolving globals: FALSE
[17:41:51.878] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[17:41:51.878] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:41:51.878] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[17:41:51.879] - packages: [1] ‘future’
[17:41:51.879] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[17:41:51.890] resolved() for ‘Future’ ...
[17:41:51.890] - state: ‘created’
[17:41:51.890] - run: TRUE
[17:41:51.890] - run() ...
[17:41:51.890] run() for ‘Future’ ...
[17:41:51.890] - state: ‘created’
[17:41:51.890] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:51.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:51.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:51.905]   - Field: ‘node’
[17:41:51.905]   - Field: ‘label’
[17:41:51.905]   - Field: ‘local’
[17:41:51.905]   - Field: ‘owner’
[17:41:51.906]   - Field: ‘envir’
[17:41:51.906]   - Field: ‘workers’
[17:41:51.906]   - Field: ‘packages’
[17:41:51.906]   - Field: ‘gc’
[17:41:51.906]   - Field: ‘conditions’
[17:41:51.906]   - Field: ‘persistent’
[17:41:51.906]   - Field: ‘expr’
[17:41:51.906]   - Field: ‘uuid’
[17:41:51.906]   - Field: ‘seed’
[17:41:51.906]   - Field: ‘version’
[17:41:51.906]   - Field: ‘result’
[17:41:51.907]   - Field: ‘asynchronous’
[17:41:51.907]   - Field: ‘calls’
[17:41:51.907]   - Field: ‘globals’
[17:41:51.907]   - Field: ‘stdout’
[17:41:51.907]   - Field: ‘earlySignal’
[17:41:51.907]   - Field: ‘lazy’
[17:41:51.907]   - Field: ‘state’
[17:41:51.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:51.907] - Launch lazy future ...
[17:41:51.908] Packages needed by the future expression (n = 1): ‘future’
[17:41:51.908] Packages needed by future strategies (n = 0): <none>
[17:41:51.908] {
[17:41:51.908]     {
[17:41:51.908]         {
[17:41:51.908]             ...future.startTime <- base::Sys.time()
[17:41:51.908]             {
[17:41:51.908]                 {
[17:41:51.908]                   {
[17:41:51.908]                     {
[17:41:51.908]                       {
[17:41:51.908]                         base::local({
[17:41:51.908]                           has_future <- base::requireNamespace("future", 
[17:41:51.908]                             quietly = TRUE)
[17:41:51.908]                           if (has_future) {
[17:41:51.908]                             ns <- base::getNamespace("future")
[17:41:51.908]                             version <- ns[[".package"]][["version"]]
[17:41:51.908]                             if (is.null(version)) 
[17:41:51.908]                               version <- utils::packageVersion("future")
[17:41:51.908]                           }
[17:41:51.908]                           else {
[17:41:51.908]                             version <- NULL
[17:41:51.908]                           }
[17:41:51.908]                           if (!has_future || version < "1.8.0") {
[17:41:51.908]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:51.908]                               "", base::R.version$version.string), 
[17:41:51.908]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:51.908]                                 base::R.version$platform, 8 * 
[17:41:51.908]                                   base::.Machine$sizeof.pointer), 
[17:41:51.908]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:51.908]                                 "release", "version")], collapse = " "), 
[17:41:51.908]                               hostname = base::Sys.info()[["nodename"]])
[17:41:51.908]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:51.908]                               info)
[17:41:51.908]                             info <- base::paste(info, collapse = "; ")
[17:41:51.908]                             if (!has_future) {
[17:41:51.908]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:51.908]                                 info)
[17:41:51.908]                             }
[17:41:51.908]                             else {
[17:41:51.908]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:51.908]                                 info, version)
[17:41:51.908]                             }
[17:41:51.908]                             base::stop(msg)
[17:41:51.908]                           }
[17:41:51.908]                         })
[17:41:51.908]                       }
[17:41:51.908]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:51.908]                       base::options(mc.cores = 1L)
[17:41:51.908]                     }
[17:41:51.908]                     base::local({
[17:41:51.908]                       for (pkg in "future") {
[17:41:51.908]                         base::loadNamespace(pkg)
[17:41:51.908]                         base::library(pkg, character.only = TRUE)
[17:41:51.908]                       }
[17:41:51.908]                     })
[17:41:51.908]                   }
[17:41:51.908]                   options(future.plan = NULL)
[17:41:51.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:51.908]                 }
[17:41:51.908]                 ...future.workdir <- getwd()
[17:41:51.908]             }
[17:41:51.908]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:51.908]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:51.908]         }
[17:41:51.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:51.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:51.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:51.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:51.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:51.908]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:51.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:51.908]             base::names(...future.oldOptions))
[17:41:51.908]     }
[17:41:51.908]     if (FALSE) {
[17:41:51.908]     }
[17:41:51.908]     else {
[17:41:51.908]         if (TRUE) {
[17:41:51.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:51.908]                 open = "w")
[17:41:51.908]         }
[17:41:51.908]         else {
[17:41:51.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:51.908]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:51.908]         }
[17:41:51.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:51.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:51.908]             base::sink(type = "output", split = FALSE)
[17:41:51.908]             base::close(...future.stdout)
[17:41:51.908]         }, add = TRUE)
[17:41:51.908]     }
[17:41:51.908]     ...future.frame <- base::sys.nframe()
[17:41:51.908]     ...future.conditions <- base::list()
[17:41:51.908]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:51.908]     if (FALSE) {
[17:41:51.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:51.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:51.908]     }
[17:41:51.908]     ...future.result <- base::tryCatch({
[17:41:51.908]         base::withCallingHandlers({
[17:41:51.908]             ...future.value <- base::withVisible(base::local({
[17:41:51.908]                 ...future.makeSendCondition <- local({
[17:41:51.908]                   sendCondition <- NULL
[17:41:51.908]                   function(frame = 1L) {
[17:41:51.908]                     if (is.function(sendCondition)) 
[17:41:51.908]                       return(sendCondition)
[17:41:51.908]                     ns <- getNamespace("parallel")
[17:41:51.908]                     if (exists("sendData", mode = "function", 
[17:41:51.908]                       envir = ns)) {
[17:41:51.908]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:51.908]                         envir = ns)
[17:41:51.908]                       envir <- sys.frame(frame)
[17:41:51.908]                       master <- NULL
[17:41:51.908]                       while (!identical(envir, .GlobalEnv) && 
[17:41:51.908]                         !identical(envir, emptyenv())) {
[17:41:51.908]                         if (exists("master", mode = "list", envir = envir, 
[17:41:51.908]                           inherits = FALSE)) {
[17:41:51.908]                           master <- get("master", mode = "list", 
[17:41:51.908]                             envir = envir, inherits = FALSE)
[17:41:51.908]                           if (inherits(master, c("SOCKnode", 
[17:41:51.908]                             "SOCK0node"))) {
[17:41:51.908]                             sendCondition <<- function(cond) {
[17:41:51.908]                               data <- list(type = "VALUE", value = cond, 
[17:41:51.908]                                 success = TRUE)
[17:41:51.908]                               parallel_sendData(master, data)
[17:41:51.908]                             }
[17:41:51.908]                             return(sendCondition)
[17:41:51.908]                           }
[17:41:51.908]                         }
[17:41:51.908]                         frame <- frame + 1L
[17:41:51.908]                         envir <- sys.frame(frame)
[17:41:51.908]                       }
[17:41:51.908]                     }
[17:41:51.908]                     sendCondition <<- function(cond) NULL
[17:41:51.908]                   }
[17:41:51.908]                 })
[17:41:51.908]                 withCallingHandlers({
[17:41:51.908]                   {
[17:41:51.908]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:51.908]                       ii, n), appendLF = FALSE)
[17:41:51.908]                     fit <- mandelbrot(C)
[17:41:51.908]                     delay(fit)
[17:41:51.908]                     message(" done")
[17:41:51.908]                     fit
[17:41:51.908]                   }
[17:41:51.908]                 }, immediateCondition = function(cond) {
[17:41:51.908]                   sendCondition <- ...future.makeSendCondition()
[17:41:51.908]                   sendCondition(cond)
[17:41:51.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.908]                   {
[17:41:51.908]                     inherits <- base::inherits
[17:41:51.908]                     invokeRestart <- base::invokeRestart
[17:41:51.908]                     is.null <- base::is.null
[17:41:51.908]                     muffled <- FALSE
[17:41:51.908]                     if (inherits(cond, "message")) {
[17:41:51.908]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:51.908]                       if (muffled) 
[17:41:51.908]                         invokeRestart("muffleMessage")
[17:41:51.908]                     }
[17:41:51.908]                     else if (inherits(cond, "warning")) {
[17:41:51.908]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:51.908]                       if (muffled) 
[17:41:51.908]                         invokeRestart("muffleWarning")
[17:41:51.908]                     }
[17:41:51.908]                     else if (inherits(cond, "condition")) {
[17:41:51.908]                       if (!is.null(pattern)) {
[17:41:51.908]                         computeRestarts <- base::computeRestarts
[17:41:51.908]                         grepl <- base::grepl
[17:41:51.908]                         restarts <- computeRestarts(cond)
[17:41:51.908]                         for (restart in restarts) {
[17:41:51.908]                           name <- restart$name
[17:41:51.908]                           if (is.null(name)) 
[17:41:51.908]                             next
[17:41:51.908]                           if (!grepl(pattern, name)) 
[17:41:51.908]                             next
[17:41:51.908]                           invokeRestart(restart)
[17:41:51.908]                           muffled <- TRUE
[17:41:51.908]                           break
[17:41:51.908]                         }
[17:41:51.908]                       }
[17:41:51.908]                     }
[17:41:51.908]                     invisible(muffled)
[17:41:51.908]                   }
[17:41:51.908]                   muffleCondition(cond)
[17:41:51.908]                 })
[17:41:51.908]             }))
[17:41:51.908]             future::FutureResult(value = ...future.value$value, 
[17:41:51.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.908]                   ...future.rng), globalenv = if (FALSE) 
[17:41:51.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:51.908]                     ...future.globalenv.names))
[17:41:51.908]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:51.908]         }, condition = base::local({
[17:41:51.908]             c <- base::c
[17:41:51.908]             inherits <- base::inherits
[17:41:51.908]             invokeRestart <- base::invokeRestart
[17:41:51.908]             length <- base::length
[17:41:51.908]             list <- base::list
[17:41:51.908]             seq.int <- base::seq.int
[17:41:51.908]             signalCondition <- base::signalCondition
[17:41:51.908]             sys.calls <- base::sys.calls
[17:41:51.908]             `[[` <- base::`[[`
[17:41:51.908]             `+` <- base::`+`
[17:41:51.908]             `<<-` <- base::`<<-`
[17:41:51.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:51.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:51.908]                   3L)]
[17:41:51.908]             }
[17:41:51.908]             function(cond) {
[17:41:51.908]                 is_error <- inherits(cond, "error")
[17:41:51.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:51.908]                   NULL)
[17:41:51.908]                 if (is_error) {
[17:41:51.908]                   sessionInformation <- function() {
[17:41:51.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:51.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:51.908]                       search = base::search(), system = base::Sys.info())
[17:41:51.908]                   }
[17:41:51.908]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:51.908]                     cond$call), session = sessionInformation(), 
[17:41:51.908]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:51.908]                   signalCondition(cond)
[17:41:51.908]                 }
[17:41:51.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:51.908]                 "immediateCondition"))) {
[17:41:51.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:51.908]                   ...future.conditions[[length(...future.conditions) + 
[17:41:51.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:51.908]                   if (TRUE && !signal) {
[17:41:51.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.908]                     {
[17:41:51.908]                       inherits <- base::inherits
[17:41:51.908]                       invokeRestart <- base::invokeRestart
[17:41:51.908]                       is.null <- base::is.null
[17:41:51.908]                       muffled <- FALSE
[17:41:51.908]                       if (inherits(cond, "message")) {
[17:41:51.908]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.908]                         if (muffled) 
[17:41:51.908]                           invokeRestart("muffleMessage")
[17:41:51.908]                       }
[17:41:51.908]                       else if (inherits(cond, "warning")) {
[17:41:51.908]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.908]                         if (muffled) 
[17:41:51.908]                           invokeRestart("muffleWarning")
[17:41:51.908]                       }
[17:41:51.908]                       else if (inherits(cond, "condition")) {
[17:41:51.908]                         if (!is.null(pattern)) {
[17:41:51.908]                           computeRestarts <- base::computeRestarts
[17:41:51.908]                           grepl <- base::grepl
[17:41:51.908]                           restarts <- computeRestarts(cond)
[17:41:51.908]                           for (restart in restarts) {
[17:41:51.908]                             name <- restart$name
[17:41:51.908]                             if (is.null(name)) 
[17:41:51.908]                               next
[17:41:51.908]                             if (!grepl(pattern, name)) 
[17:41:51.908]                               next
[17:41:51.908]                             invokeRestart(restart)
[17:41:51.908]                             muffled <- TRUE
[17:41:51.908]                             break
[17:41:51.908]                           }
[17:41:51.908]                         }
[17:41:51.908]                       }
[17:41:51.908]                       invisible(muffled)
[17:41:51.908]                     }
[17:41:51.908]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.908]                   }
[17:41:51.908]                 }
[17:41:51.908]                 else {
[17:41:51.908]                   if (TRUE) {
[17:41:51.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:51.908]                     {
[17:41:51.908]                       inherits <- base::inherits
[17:41:51.908]                       invokeRestart <- base::invokeRestart
[17:41:51.908]                       is.null <- base::is.null
[17:41:51.908]                       muffled <- FALSE
[17:41:51.908]                       if (inherits(cond, "message")) {
[17:41:51.908]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:51.908]                         if (muffled) 
[17:41:51.908]                           invokeRestart("muffleMessage")
[17:41:51.908]                       }
[17:41:51.908]                       else if (inherits(cond, "warning")) {
[17:41:51.908]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:51.908]                         if (muffled) 
[17:41:51.908]                           invokeRestart("muffleWarning")
[17:41:51.908]                       }
[17:41:51.908]                       else if (inherits(cond, "condition")) {
[17:41:51.908]                         if (!is.null(pattern)) {
[17:41:51.908]                           computeRestarts <- base::computeRestarts
[17:41:51.908]                           grepl <- base::grepl
[17:41:51.908]                           restarts <- computeRestarts(cond)
[17:41:51.908]                           for (restart in restarts) {
[17:41:51.908]                             name <- restart$name
[17:41:51.908]                             if (is.null(name)) 
[17:41:51.908]                               next
[17:41:51.908]                             if (!grepl(pattern, name)) 
[17:41:51.908]                               next
[17:41:51.908]                             invokeRestart(restart)
[17:41:51.908]                             muffled <- TRUE
[17:41:51.908]                             break
[17:41:51.908]                           }
[17:41:51.908]                         }
[17:41:51.908]                       }
[17:41:51.908]                       invisible(muffled)
[17:41:51.908]                     }
[17:41:51.908]                     muffleCondition(cond, pattern = "^muffle")
[17:41:51.908]                   }
[17:41:51.908]                 }
[17:41:51.908]             }
[17:41:51.908]         }))
[17:41:51.908]     }, error = function(ex) {
[17:41:51.908]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:51.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:51.908]                 ...future.rng), started = ...future.startTime, 
[17:41:51.908]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:51.908]             version = "1.8"), class = "FutureResult")
[17:41:51.908]     }, finally = {
[17:41:51.908]         if (!identical(...future.workdir, getwd())) 
[17:41:51.908]             setwd(...future.workdir)
[17:41:51.908]         {
[17:41:51.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:51.908]                 ...future.oldOptions$nwarnings <- NULL
[17:41:51.908]             }
[17:41:51.908]             base::options(...future.oldOptions)
[17:41:51.908]             if (.Platform$OS.type == "windows") {
[17:41:51.908]                 old_names <- names(...future.oldEnvVars)
[17:41:51.908]                 envs <- base::Sys.getenv()
[17:41:51.908]                 names <- names(envs)
[17:41:51.908]                 common <- intersect(names, old_names)
[17:41:51.908]                 added <- setdiff(names, old_names)
[17:41:51.908]                 removed <- setdiff(old_names, names)
[17:41:51.908]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:51.908]                   envs[common]]
[17:41:51.908]                 NAMES <- toupper(changed)
[17:41:51.908]                 args <- list()
[17:41:51.908]                 for (kk in seq_along(NAMES)) {
[17:41:51.908]                   name <- changed[[kk]]
[17:41:51.908]                   NAME <- NAMES[[kk]]
[17:41:51.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.908]                     next
[17:41:51.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.908]                 }
[17:41:51.908]                 NAMES <- toupper(added)
[17:41:51.908]                 for (kk in seq_along(NAMES)) {
[17:41:51.908]                   name <- added[[kk]]
[17:41:51.908]                   NAME <- NAMES[[kk]]
[17:41:51.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.908]                     next
[17:41:51.908]                   args[[name]] <- ""
[17:41:51.908]                 }
[17:41:51.908]                 NAMES <- toupper(removed)
[17:41:51.908]                 for (kk in seq_along(NAMES)) {
[17:41:51.908]                   name <- removed[[kk]]
[17:41:51.908]                   NAME <- NAMES[[kk]]
[17:41:51.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:51.908]                     next
[17:41:51.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:51.908]                 }
[17:41:51.908]                 if (length(args) > 0) 
[17:41:51.908]                   base::do.call(base::Sys.setenv, args = args)
[17:41:51.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:51.908]             }
[17:41:51.908]             else {
[17:41:51.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:51.908]             }
[17:41:51.908]             {
[17:41:51.908]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:51.908]                   0L) {
[17:41:51.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:51.908]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:51.908]                   base::options(opts)
[17:41:51.908]                 }
[17:41:51.908]                 {
[17:41:51.908]                   {
[17:41:51.908]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:51.908]                     NULL
[17:41:51.908]                   }
[17:41:51.908]                   options(future.plan = NULL)
[17:41:51.908]                   if (is.na(NA_character_)) 
[17:41:51.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:51.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:51.908]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:51.908]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:51.908]                     envir = parent.frame()) 
[17:41:51.908]                   {
[17:41:51.908]                     if (is.function(workers)) 
[17:41:51.908]                       workers <- workers()
[17:41:51.908]                     workers <- structure(as.integer(workers), 
[17:41:51.908]                       class = class(workers))
[17:41:51.908]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:51.908]                       workers >= 1)
[17:41:51.908]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:51.908]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:51.908]                     }
[17:41:51.908]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:51.908]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:51.908]                       envir = envir)
[17:41:51.908]                     if (!future$lazy) 
[17:41:51.908]                       future <- run(future)
[17:41:51.908]                     invisible(future)
[17:41:51.908]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:51.908]                 }
[17:41:51.908]             }
[17:41:51.908]         }
[17:41:51.908]     })
[17:41:51.908]     if (TRUE) {
[17:41:51.908]         base::sink(type = "output", split = FALSE)
[17:41:51.908]         if (TRUE) {
[17:41:51.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:51.908]         }
[17:41:51.908]         else {
[17:41:51.908]             ...future.result["stdout"] <- base::list(NULL)
[17:41:51.908]         }
[17:41:51.908]         base::close(...future.stdout)
[17:41:51.908]         ...future.stdout <- NULL
[17:41:51.908]     }
[17:41:51.908]     ...future.result$conditions <- ...future.conditions
[17:41:51.908]     ...future.result$finished <- base::Sys.time()
[17:41:51.908]     ...future.result
[17:41:51.908] }
[17:41:51.911] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[17:41:51.911] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:41:51.912] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:51.912] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[17:41:51.912] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[17:41:51.912] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[17:41:51.955] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[17:41:51.956] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[17:41:51.999] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[17:41:51.999] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[17:41:52.000] MultisessionFuture started
[17:41:52.000] - Launch lazy future ... done
[17:41:52.001] run() for ‘MultisessionFuture’ ... done
[17:41:52.001] - run() ... done
[17:41:52.001] - resolved() ...
[17:41:52.012] - resolved: FALSE
[17:41:52.012] - resolved() ... done
[17:41:52.012] resolved() for ‘MultisessionFuture’ ... done
[17:41:52.012] resolved() for ‘Future’ ...
[17:41:52.012] - state: ‘created’
[17:41:52.012] - run: TRUE
[17:41:52.012] - run() ...
[17:41:52.012] run() for ‘Future’ ...
[17:41:52.013] - state: ‘created’
[17:41:52.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:52.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:52.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:52.027]   - Field: ‘node’
[17:41:52.028]   - Field: ‘label’
[17:41:52.028]   - Field: ‘local’
[17:41:52.028]   - Field: ‘owner’
[17:41:52.028]   - Field: ‘envir’
[17:41:52.028]   - Field: ‘workers’
[17:41:52.028]   - Field: ‘packages’
[17:41:52.028]   - Field: ‘gc’
[17:41:52.028]   - Field: ‘conditions’
[17:41:52.028]   - Field: ‘persistent’
[17:41:52.028]   - Field: ‘expr’
[17:41:52.028]   - Field: ‘uuid’
[17:41:52.029]   - Field: ‘seed’
[17:41:52.029]   - Field: ‘version’
[17:41:52.029]   - Field: ‘result’
[17:41:52.029]   - Field: ‘asynchronous’
[17:41:52.029]   - Field: ‘calls’
[17:41:52.029]   - Field: ‘globals’
[17:41:52.029]   - Field: ‘stdout’
[17:41:52.029]   - Field: ‘earlySignal’
[17:41:52.029]   - Field: ‘lazy’
[17:41:52.029]   - Field: ‘state’
[17:41:52.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:52.030] - Launch lazy future ...
[17:41:52.030] Packages needed by the future expression (n = 1): ‘future’
[17:41:52.030] Packages needed by future strategies (n = 0): <none>
[17:41:52.030] {
[17:41:52.030]     {
[17:41:52.030]         {
[17:41:52.030]             ...future.startTime <- base::Sys.time()
[17:41:52.030]             {
[17:41:52.030]                 {
[17:41:52.030]                   {
[17:41:52.030]                     {
[17:41:52.030]                       {
[17:41:52.030]                         base::local({
[17:41:52.030]                           has_future <- base::requireNamespace("future", 
[17:41:52.030]                             quietly = TRUE)
[17:41:52.030]                           if (has_future) {
[17:41:52.030]                             ns <- base::getNamespace("future")
[17:41:52.030]                             version <- ns[[".package"]][["version"]]
[17:41:52.030]                             if (is.null(version)) 
[17:41:52.030]                               version <- utils::packageVersion("future")
[17:41:52.030]                           }
[17:41:52.030]                           else {
[17:41:52.030]                             version <- NULL
[17:41:52.030]                           }
[17:41:52.030]                           if (!has_future || version < "1.8.0") {
[17:41:52.030]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:52.030]                               "", base::R.version$version.string), 
[17:41:52.030]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:52.030]                                 base::R.version$platform, 8 * 
[17:41:52.030]                                   base::.Machine$sizeof.pointer), 
[17:41:52.030]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:52.030]                                 "release", "version")], collapse = " "), 
[17:41:52.030]                               hostname = base::Sys.info()[["nodename"]])
[17:41:52.030]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:52.030]                               info)
[17:41:52.030]                             info <- base::paste(info, collapse = "; ")
[17:41:52.030]                             if (!has_future) {
[17:41:52.030]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:52.030]                                 info)
[17:41:52.030]                             }
[17:41:52.030]                             else {
[17:41:52.030]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:52.030]                                 info, version)
[17:41:52.030]                             }
[17:41:52.030]                             base::stop(msg)
[17:41:52.030]                           }
[17:41:52.030]                         })
[17:41:52.030]                       }
[17:41:52.030]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:52.030]                       base::options(mc.cores = 1L)
[17:41:52.030]                     }
[17:41:52.030]                     base::local({
[17:41:52.030]                       for (pkg in "future") {
[17:41:52.030]                         base::loadNamespace(pkg)
[17:41:52.030]                         base::library(pkg, character.only = TRUE)
[17:41:52.030]                       }
[17:41:52.030]                     })
[17:41:52.030]                   }
[17:41:52.030]                   options(future.plan = NULL)
[17:41:52.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:52.030]                 }
[17:41:52.030]                 ...future.workdir <- getwd()
[17:41:52.030]             }
[17:41:52.030]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:52.030]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:52.030]         }
[17:41:52.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:52.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:52.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:52.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:52.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:52.030]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:52.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:52.030]             base::names(...future.oldOptions))
[17:41:52.030]     }
[17:41:52.030]     if (FALSE) {
[17:41:52.030]     }
[17:41:52.030]     else {
[17:41:52.030]         if (TRUE) {
[17:41:52.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:52.030]                 open = "w")
[17:41:52.030]         }
[17:41:52.030]         else {
[17:41:52.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:52.030]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:52.030]         }
[17:41:52.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:52.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:52.030]             base::sink(type = "output", split = FALSE)
[17:41:52.030]             base::close(...future.stdout)
[17:41:52.030]         }, add = TRUE)
[17:41:52.030]     }
[17:41:52.030]     ...future.frame <- base::sys.nframe()
[17:41:52.030]     ...future.conditions <- base::list()
[17:41:52.030]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:52.030]     if (FALSE) {
[17:41:52.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:52.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:52.030]     }
[17:41:52.030]     ...future.result <- base::tryCatch({
[17:41:52.030]         base::withCallingHandlers({
[17:41:52.030]             ...future.value <- base::withVisible(base::local({
[17:41:52.030]                 ...future.makeSendCondition <- local({
[17:41:52.030]                   sendCondition <- NULL
[17:41:52.030]                   function(frame = 1L) {
[17:41:52.030]                     if (is.function(sendCondition)) 
[17:41:52.030]                       return(sendCondition)
[17:41:52.030]                     ns <- getNamespace("parallel")
[17:41:52.030]                     if (exists("sendData", mode = "function", 
[17:41:52.030]                       envir = ns)) {
[17:41:52.030]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:52.030]                         envir = ns)
[17:41:52.030]                       envir <- sys.frame(frame)
[17:41:52.030]                       master <- NULL
[17:41:52.030]                       while (!identical(envir, .GlobalEnv) && 
[17:41:52.030]                         !identical(envir, emptyenv())) {
[17:41:52.030]                         if (exists("master", mode = "list", envir = envir, 
[17:41:52.030]                           inherits = FALSE)) {
[17:41:52.030]                           master <- get("master", mode = "list", 
[17:41:52.030]                             envir = envir, inherits = FALSE)
[17:41:52.030]                           if (inherits(master, c("SOCKnode", 
[17:41:52.030]                             "SOCK0node"))) {
[17:41:52.030]                             sendCondition <<- function(cond) {
[17:41:52.030]                               data <- list(type = "VALUE", value = cond, 
[17:41:52.030]                                 success = TRUE)
[17:41:52.030]                               parallel_sendData(master, data)
[17:41:52.030]                             }
[17:41:52.030]                             return(sendCondition)
[17:41:52.030]                           }
[17:41:52.030]                         }
[17:41:52.030]                         frame <- frame + 1L
[17:41:52.030]                         envir <- sys.frame(frame)
[17:41:52.030]                       }
[17:41:52.030]                     }
[17:41:52.030]                     sendCondition <<- function(cond) NULL
[17:41:52.030]                   }
[17:41:52.030]                 })
[17:41:52.030]                 withCallingHandlers({
[17:41:52.030]                   {
[17:41:52.030]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:52.030]                       ii, n), appendLF = FALSE)
[17:41:52.030]                     fit <- mandelbrot(C)
[17:41:52.030]                     delay(fit)
[17:41:52.030]                     message(" done")
[17:41:52.030]                     fit
[17:41:52.030]                   }
[17:41:52.030]                 }, immediateCondition = function(cond) {
[17:41:52.030]                   sendCondition <- ...future.makeSendCondition()
[17:41:52.030]                   sendCondition(cond)
[17:41:52.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.030]                   {
[17:41:52.030]                     inherits <- base::inherits
[17:41:52.030]                     invokeRestart <- base::invokeRestart
[17:41:52.030]                     is.null <- base::is.null
[17:41:52.030]                     muffled <- FALSE
[17:41:52.030]                     if (inherits(cond, "message")) {
[17:41:52.030]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:52.030]                       if (muffled) 
[17:41:52.030]                         invokeRestart("muffleMessage")
[17:41:52.030]                     }
[17:41:52.030]                     else if (inherits(cond, "warning")) {
[17:41:52.030]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:52.030]                       if (muffled) 
[17:41:52.030]                         invokeRestart("muffleWarning")
[17:41:52.030]                     }
[17:41:52.030]                     else if (inherits(cond, "condition")) {
[17:41:52.030]                       if (!is.null(pattern)) {
[17:41:52.030]                         computeRestarts <- base::computeRestarts
[17:41:52.030]                         grepl <- base::grepl
[17:41:52.030]                         restarts <- computeRestarts(cond)
[17:41:52.030]                         for (restart in restarts) {
[17:41:52.030]                           name <- restart$name
[17:41:52.030]                           if (is.null(name)) 
[17:41:52.030]                             next
[17:41:52.030]                           if (!grepl(pattern, name)) 
[17:41:52.030]                             next
[17:41:52.030]                           invokeRestart(restart)
[17:41:52.030]                           muffled <- TRUE
[17:41:52.030]                           break
[17:41:52.030]                         }
[17:41:52.030]                       }
[17:41:52.030]                     }
[17:41:52.030]                     invisible(muffled)
[17:41:52.030]                   }
[17:41:52.030]                   muffleCondition(cond)
[17:41:52.030]                 })
[17:41:52.030]             }))
[17:41:52.030]             future::FutureResult(value = ...future.value$value, 
[17:41:52.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.030]                   ...future.rng), globalenv = if (FALSE) 
[17:41:52.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:52.030]                     ...future.globalenv.names))
[17:41:52.030]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:52.030]         }, condition = base::local({
[17:41:52.030]             c <- base::c
[17:41:52.030]             inherits <- base::inherits
[17:41:52.030]             invokeRestart <- base::invokeRestart
[17:41:52.030]             length <- base::length
[17:41:52.030]             list <- base::list
[17:41:52.030]             seq.int <- base::seq.int
[17:41:52.030]             signalCondition <- base::signalCondition
[17:41:52.030]             sys.calls <- base::sys.calls
[17:41:52.030]             `[[` <- base::`[[`
[17:41:52.030]             `+` <- base::`+`
[17:41:52.030]             `<<-` <- base::`<<-`
[17:41:52.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:52.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:52.030]                   3L)]
[17:41:52.030]             }
[17:41:52.030]             function(cond) {
[17:41:52.030]                 is_error <- inherits(cond, "error")
[17:41:52.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:52.030]                   NULL)
[17:41:52.030]                 if (is_error) {
[17:41:52.030]                   sessionInformation <- function() {
[17:41:52.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:52.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:52.030]                       search = base::search(), system = base::Sys.info())
[17:41:52.030]                   }
[17:41:52.030]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:52.030]                     cond$call), session = sessionInformation(), 
[17:41:52.030]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:52.030]                   signalCondition(cond)
[17:41:52.030]                 }
[17:41:52.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:52.030]                 "immediateCondition"))) {
[17:41:52.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:52.030]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:52.030]                   if (TRUE && !signal) {
[17:41:52.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.030]                     {
[17:41:52.030]                       inherits <- base::inherits
[17:41:52.030]                       invokeRestart <- base::invokeRestart
[17:41:52.030]                       is.null <- base::is.null
[17:41:52.030]                       muffled <- FALSE
[17:41:52.030]                       if (inherits(cond, "message")) {
[17:41:52.030]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.030]                         if (muffled) 
[17:41:52.030]                           invokeRestart("muffleMessage")
[17:41:52.030]                       }
[17:41:52.030]                       else if (inherits(cond, "warning")) {
[17:41:52.030]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.030]                         if (muffled) 
[17:41:52.030]                           invokeRestart("muffleWarning")
[17:41:52.030]                       }
[17:41:52.030]                       else if (inherits(cond, "condition")) {
[17:41:52.030]                         if (!is.null(pattern)) {
[17:41:52.030]                           computeRestarts <- base::computeRestarts
[17:41:52.030]                           grepl <- base::grepl
[17:41:52.030]                           restarts <- computeRestarts(cond)
[17:41:52.030]                           for (restart in restarts) {
[17:41:52.030]                             name <- restart$name
[17:41:52.030]                             if (is.null(name)) 
[17:41:52.030]                               next
[17:41:52.030]                             if (!grepl(pattern, name)) 
[17:41:52.030]                               next
[17:41:52.030]                             invokeRestart(restart)
[17:41:52.030]                             muffled <- TRUE
[17:41:52.030]                             break
[17:41:52.030]                           }
[17:41:52.030]                         }
[17:41:52.030]                       }
[17:41:52.030]                       invisible(muffled)
[17:41:52.030]                     }
[17:41:52.030]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.030]                   }
[17:41:52.030]                 }
[17:41:52.030]                 else {
[17:41:52.030]                   if (TRUE) {
[17:41:52.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.030]                     {
[17:41:52.030]                       inherits <- base::inherits
[17:41:52.030]                       invokeRestart <- base::invokeRestart
[17:41:52.030]                       is.null <- base::is.null
[17:41:52.030]                       muffled <- FALSE
[17:41:52.030]                       if (inherits(cond, "message")) {
[17:41:52.030]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.030]                         if (muffled) 
[17:41:52.030]                           invokeRestart("muffleMessage")
[17:41:52.030]                       }
[17:41:52.030]                       else if (inherits(cond, "warning")) {
[17:41:52.030]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.030]                         if (muffled) 
[17:41:52.030]                           invokeRestart("muffleWarning")
[17:41:52.030]                       }
[17:41:52.030]                       else if (inherits(cond, "condition")) {
[17:41:52.030]                         if (!is.null(pattern)) {
[17:41:52.030]                           computeRestarts <- base::computeRestarts
[17:41:52.030]                           grepl <- base::grepl
[17:41:52.030]                           restarts <- computeRestarts(cond)
[17:41:52.030]                           for (restart in restarts) {
[17:41:52.030]                             name <- restart$name
[17:41:52.030]                             if (is.null(name)) 
[17:41:52.030]                               next
[17:41:52.030]                             if (!grepl(pattern, name)) 
[17:41:52.030]                               next
[17:41:52.030]                             invokeRestart(restart)
[17:41:52.030]                             muffled <- TRUE
[17:41:52.030]                             break
[17:41:52.030]                           }
[17:41:52.030]                         }
[17:41:52.030]                       }
[17:41:52.030]                       invisible(muffled)
[17:41:52.030]                     }
[17:41:52.030]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.030]                   }
[17:41:52.030]                 }
[17:41:52.030]             }
[17:41:52.030]         }))
[17:41:52.030]     }, error = function(ex) {
[17:41:52.030]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:52.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.030]                 ...future.rng), started = ...future.startTime, 
[17:41:52.030]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:52.030]             version = "1.8"), class = "FutureResult")
[17:41:52.030]     }, finally = {
[17:41:52.030]         if (!identical(...future.workdir, getwd())) 
[17:41:52.030]             setwd(...future.workdir)
[17:41:52.030]         {
[17:41:52.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:52.030]                 ...future.oldOptions$nwarnings <- NULL
[17:41:52.030]             }
[17:41:52.030]             base::options(...future.oldOptions)
[17:41:52.030]             if (.Platform$OS.type == "windows") {
[17:41:52.030]                 old_names <- names(...future.oldEnvVars)
[17:41:52.030]                 envs <- base::Sys.getenv()
[17:41:52.030]                 names <- names(envs)
[17:41:52.030]                 common <- intersect(names, old_names)
[17:41:52.030]                 added <- setdiff(names, old_names)
[17:41:52.030]                 removed <- setdiff(old_names, names)
[17:41:52.030]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:52.030]                   envs[common]]
[17:41:52.030]                 NAMES <- toupper(changed)
[17:41:52.030]                 args <- list()
[17:41:52.030]                 for (kk in seq_along(NAMES)) {
[17:41:52.030]                   name <- changed[[kk]]
[17:41:52.030]                   NAME <- NAMES[[kk]]
[17:41:52.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.030]                     next
[17:41:52.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.030]                 }
[17:41:52.030]                 NAMES <- toupper(added)
[17:41:52.030]                 for (kk in seq_along(NAMES)) {
[17:41:52.030]                   name <- added[[kk]]
[17:41:52.030]                   NAME <- NAMES[[kk]]
[17:41:52.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.030]                     next
[17:41:52.030]                   args[[name]] <- ""
[17:41:52.030]                 }
[17:41:52.030]                 NAMES <- toupper(removed)
[17:41:52.030]                 for (kk in seq_along(NAMES)) {
[17:41:52.030]                   name <- removed[[kk]]
[17:41:52.030]                   NAME <- NAMES[[kk]]
[17:41:52.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.030]                     next
[17:41:52.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.030]                 }
[17:41:52.030]                 if (length(args) > 0) 
[17:41:52.030]                   base::do.call(base::Sys.setenv, args = args)
[17:41:52.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:52.030]             }
[17:41:52.030]             else {
[17:41:52.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:52.030]             }
[17:41:52.030]             {
[17:41:52.030]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:52.030]                   0L) {
[17:41:52.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:52.030]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:52.030]                   base::options(opts)
[17:41:52.030]                 }
[17:41:52.030]                 {
[17:41:52.030]                   {
[17:41:52.030]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:52.030]                     NULL
[17:41:52.030]                   }
[17:41:52.030]                   options(future.plan = NULL)
[17:41:52.030]                   if (is.na(NA_character_)) 
[17:41:52.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:52.030]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:52.030]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:52.030]                     envir = parent.frame()) 
[17:41:52.030]                   {
[17:41:52.030]                     if (is.function(workers)) 
[17:41:52.030]                       workers <- workers()
[17:41:52.030]                     workers <- structure(as.integer(workers), 
[17:41:52.030]                       class = class(workers))
[17:41:52.030]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:52.030]                       workers >= 1)
[17:41:52.030]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:52.030]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:52.030]                     }
[17:41:52.030]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:52.030]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:52.030]                       envir = envir)
[17:41:52.030]                     if (!future$lazy) 
[17:41:52.030]                       future <- run(future)
[17:41:52.030]                     invisible(future)
[17:41:52.030]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:52.030]                 }
[17:41:52.030]             }
[17:41:52.030]         }
[17:41:52.030]     })
[17:41:52.030]     if (TRUE) {
[17:41:52.030]         base::sink(type = "output", split = FALSE)
[17:41:52.030]         if (TRUE) {
[17:41:52.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:52.030]         }
[17:41:52.030]         else {
[17:41:52.030]             ...future.result["stdout"] <- base::list(NULL)
[17:41:52.030]         }
[17:41:52.030]         base::close(...future.stdout)
[17:41:52.030]         ...future.stdout <- NULL
[17:41:52.030]     }
[17:41:52.030]     ...future.result$conditions <- ...future.conditions
[17:41:52.030]     ...future.result$finished <- base::Sys.time()
[17:41:52.030]     ...future.result
[17:41:52.030] }
[17:41:52.104] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[17:41:52.104] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:41:52.104] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:41:52.105] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[17:41:52.105] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[17:41:52.105] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[17:41:52.147] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[17:41:52.147] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[17:41:52.191] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[17:41:52.191] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[17:41:52.193] MultisessionFuture started
[17:41:52.193] - Launch lazy future ... done
[17:41:52.193] run() for ‘MultisessionFuture’ ... done
[17:41:52.193] - run() ... done
[17:41:52.193] - resolved() ...
[17:41:52.204] - resolved: FALSE
[17:41:52.204] - resolved() ... done
[17:41:52.204] resolved() for ‘MultisessionFuture’ ... done
[17:41:52.204] resolved() for ‘Future’ ...
[17:41:52.204] - state: ‘created’
[17:41:52.204] - run: TRUE
[17:41:52.205] - run() ...
[17:41:52.205] run() for ‘Future’ ...
[17:41:52.205] - state: ‘created’
[17:41:52.205] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:52.220] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:52.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:52.220]   - Field: ‘node’
[17:41:52.220]   - Field: ‘label’
[17:41:52.221]   - Field: ‘local’
[17:41:52.221]   - Field: ‘owner’
[17:41:52.221]   - Field: ‘envir’
[17:41:52.221]   - Field: ‘workers’
[17:41:52.221]   - Field: ‘packages’
[17:41:52.221]   - Field: ‘gc’
[17:41:52.221]   - Field: ‘conditions’
[17:41:52.221]   - Field: ‘persistent’
[17:41:52.221]   - Field: ‘expr’
[17:41:52.221]   - Field: ‘uuid’
[17:41:52.221]   - Field: ‘seed’
[17:41:52.222]   - Field: ‘version’
[17:41:52.222]   - Field: ‘result’
[17:41:52.222]   - Field: ‘asynchronous’
[17:41:52.222]   - Field: ‘calls’
[17:41:52.222]   - Field: ‘globals’
[17:41:52.222]   - Field: ‘stdout’
[17:41:52.222]   - Field: ‘earlySignal’
[17:41:52.222]   - Field: ‘lazy’
[17:41:52.222]   - Field: ‘state’
[17:41:52.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:52.222] - Launch lazy future ...
[17:41:52.223] Packages needed by the future expression (n = 1): ‘future’
[17:41:52.223] Packages needed by future strategies (n = 0): <none>
[17:41:52.223] {
[17:41:52.223]     {
[17:41:52.223]         {
[17:41:52.223]             ...future.startTime <- base::Sys.time()
[17:41:52.223]             {
[17:41:52.223]                 {
[17:41:52.223]                   {
[17:41:52.223]                     {
[17:41:52.223]                       {
[17:41:52.223]                         base::local({
[17:41:52.223]                           has_future <- base::requireNamespace("future", 
[17:41:52.223]                             quietly = TRUE)
[17:41:52.223]                           if (has_future) {
[17:41:52.223]                             ns <- base::getNamespace("future")
[17:41:52.223]                             version <- ns[[".package"]][["version"]]
[17:41:52.223]                             if (is.null(version)) 
[17:41:52.223]                               version <- utils::packageVersion("future")
[17:41:52.223]                           }
[17:41:52.223]                           else {
[17:41:52.223]                             version <- NULL
[17:41:52.223]                           }
[17:41:52.223]                           if (!has_future || version < "1.8.0") {
[17:41:52.223]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:52.223]                               "", base::R.version$version.string), 
[17:41:52.223]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:52.223]                                 base::R.version$platform, 8 * 
[17:41:52.223]                                   base::.Machine$sizeof.pointer), 
[17:41:52.223]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:52.223]                                 "release", "version")], collapse = " "), 
[17:41:52.223]                               hostname = base::Sys.info()[["nodename"]])
[17:41:52.223]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:52.223]                               info)
[17:41:52.223]                             info <- base::paste(info, collapse = "; ")
[17:41:52.223]                             if (!has_future) {
[17:41:52.223]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:52.223]                                 info)
[17:41:52.223]                             }
[17:41:52.223]                             else {
[17:41:52.223]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:52.223]                                 info, version)
[17:41:52.223]                             }
[17:41:52.223]                             base::stop(msg)
[17:41:52.223]                           }
[17:41:52.223]                         })
[17:41:52.223]                       }
[17:41:52.223]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:52.223]                       base::options(mc.cores = 1L)
[17:41:52.223]                     }
[17:41:52.223]                     base::local({
[17:41:52.223]                       for (pkg in "future") {
[17:41:52.223]                         base::loadNamespace(pkg)
[17:41:52.223]                         base::library(pkg, character.only = TRUE)
[17:41:52.223]                       }
[17:41:52.223]                     })
[17:41:52.223]                   }
[17:41:52.223]                   options(future.plan = NULL)
[17:41:52.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:52.223]                 }
[17:41:52.223]                 ...future.workdir <- getwd()
[17:41:52.223]             }
[17:41:52.223]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:52.223]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:52.223]         }
[17:41:52.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:52.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:52.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:52.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:52.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:52.223]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:52.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:52.223]             base::names(...future.oldOptions))
[17:41:52.223]     }
[17:41:52.223]     if (FALSE) {
[17:41:52.223]     }
[17:41:52.223]     else {
[17:41:52.223]         if (TRUE) {
[17:41:52.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:52.223]                 open = "w")
[17:41:52.223]         }
[17:41:52.223]         else {
[17:41:52.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:52.223]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:52.223]         }
[17:41:52.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:52.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:52.223]             base::sink(type = "output", split = FALSE)
[17:41:52.223]             base::close(...future.stdout)
[17:41:52.223]         }, add = TRUE)
[17:41:52.223]     }
[17:41:52.223]     ...future.frame <- base::sys.nframe()
[17:41:52.223]     ...future.conditions <- base::list()
[17:41:52.223]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:52.223]     if (FALSE) {
[17:41:52.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:52.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:52.223]     }
[17:41:52.223]     ...future.result <- base::tryCatch({
[17:41:52.223]         base::withCallingHandlers({
[17:41:52.223]             ...future.value <- base::withVisible(base::local({
[17:41:52.223]                 ...future.makeSendCondition <- local({
[17:41:52.223]                   sendCondition <- NULL
[17:41:52.223]                   function(frame = 1L) {
[17:41:52.223]                     if (is.function(sendCondition)) 
[17:41:52.223]                       return(sendCondition)
[17:41:52.223]                     ns <- getNamespace("parallel")
[17:41:52.223]                     if (exists("sendData", mode = "function", 
[17:41:52.223]                       envir = ns)) {
[17:41:52.223]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:52.223]                         envir = ns)
[17:41:52.223]                       envir <- sys.frame(frame)
[17:41:52.223]                       master <- NULL
[17:41:52.223]                       while (!identical(envir, .GlobalEnv) && 
[17:41:52.223]                         !identical(envir, emptyenv())) {
[17:41:52.223]                         if (exists("master", mode = "list", envir = envir, 
[17:41:52.223]                           inherits = FALSE)) {
[17:41:52.223]                           master <- get("master", mode = "list", 
[17:41:52.223]                             envir = envir, inherits = FALSE)
[17:41:52.223]                           if (inherits(master, c("SOCKnode", 
[17:41:52.223]                             "SOCK0node"))) {
[17:41:52.223]                             sendCondition <<- function(cond) {
[17:41:52.223]                               data <- list(type = "VALUE", value = cond, 
[17:41:52.223]                                 success = TRUE)
[17:41:52.223]                               parallel_sendData(master, data)
[17:41:52.223]                             }
[17:41:52.223]                             return(sendCondition)
[17:41:52.223]                           }
[17:41:52.223]                         }
[17:41:52.223]                         frame <- frame + 1L
[17:41:52.223]                         envir <- sys.frame(frame)
[17:41:52.223]                       }
[17:41:52.223]                     }
[17:41:52.223]                     sendCondition <<- function(cond) NULL
[17:41:52.223]                   }
[17:41:52.223]                 })
[17:41:52.223]                 withCallingHandlers({
[17:41:52.223]                   {
[17:41:52.223]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:52.223]                       ii, n), appendLF = FALSE)
[17:41:52.223]                     fit <- mandelbrot(C)
[17:41:52.223]                     delay(fit)
[17:41:52.223]                     message(" done")
[17:41:52.223]                     fit
[17:41:52.223]                   }
[17:41:52.223]                 }, immediateCondition = function(cond) {
[17:41:52.223]                   sendCondition <- ...future.makeSendCondition()
[17:41:52.223]                   sendCondition(cond)
[17:41:52.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.223]                   {
[17:41:52.223]                     inherits <- base::inherits
[17:41:52.223]                     invokeRestart <- base::invokeRestart
[17:41:52.223]                     is.null <- base::is.null
[17:41:52.223]                     muffled <- FALSE
[17:41:52.223]                     if (inherits(cond, "message")) {
[17:41:52.223]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:52.223]                       if (muffled) 
[17:41:52.223]                         invokeRestart("muffleMessage")
[17:41:52.223]                     }
[17:41:52.223]                     else if (inherits(cond, "warning")) {
[17:41:52.223]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:52.223]                       if (muffled) 
[17:41:52.223]                         invokeRestart("muffleWarning")
[17:41:52.223]                     }
[17:41:52.223]                     else if (inherits(cond, "condition")) {
[17:41:52.223]                       if (!is.null(pattern)) {
[17:41:52.223]                         computeRestarts <- base::computeRestarts
[17:41:52.223]                         grepl <- base::grepl
[17:41:52.223]                         restarts <- computeRestarts(cond)
[17:41:52.223]                         for (restart in restarts) {
[17:41:52.223]                           name <- restart$name
[17:41:52.223]                           if (is.null(name)) 
[17:41:52.223]                             next
[17:41:52.223]                           if (!grepl(pattern, name)) 
[17:41:52.223]                             next
[17:41:52.223]                           invokeRestart(restart)
[17:41:52.223]                           muffled <- TRUE
[17:41:52.223]                           break
[17:41:52.223]                         }
[17:41:52.223]                       }
[17:41:52.223]                     }
[17:41:52.223]                     invisible(muffled)
[17:41:52.223]                   }
[17:41:52.223]                   muffleCondition(cond)
[17:41:52.223]                 })
[17:41:52.223]             }))
[17:41:52.223]             future::FutureResult(value = ...future.value$value, 
[17:41:52.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.223]                   ...future.rng), globalenv = if (FALSE) 
[17:41:52.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:52.223]                     ...future.globalenv.names))
[17:41:52.223]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:52.223]         }, condition = base::local({
[17:41:52.223]             c <- base::c
[17:41:52.223]             inherits <- base::inherits
[17:41:52.223]             invokeRestart <- base::invokeRestart
[17:41:52.223]             length <- base::length
[17:41:52.223]             list <- base::list
[17:41:52.223]             seq.int <- base::seq.int
[17:41:52.223]             signalCondition <- base::signalCondition
[17:41:52.223]             sys.calls <- base::sys.calls
[17:41:52.223]             `[[` <- base::`[[`
[17:41:52.223]             `+` <- base::`+`
[17:41:52.223]             `<<-` <- base::`<<-`
[17:41:52.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:52.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:52.223]                   3L)]
[17:41:52.223]             }
[17:41:52.223]             function(cond) {
[17:41:52.223]                 is_error <- inherits(cond, "error")
[17:41:52.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:52.223]                   NULL)
[17:41:52.223]                 if (is_error) {
[17:41:52.223]                   sessionInformation <- function() {
[17:41:52.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:52.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:52.223]                       search = base::search(), system = base::Sys.info())
[17:41:52.223]                   }
[17:41:52.223]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:52.223]                     cond$call), session = sessionInformation(), 
[17:41:52.223]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:52.223]                   signalCondition(cond)
[17:41:52.223]                 }
[17:41:52.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:52.223]                 "immediateCondition"))) {
[17:41:52.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:52.223]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:52.223]                   if (TRUE && !signal) {
[17:41:52.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.223]                     {
[17:41:52.223]                       inherits <- base::inherits
[17:41:52.223]                       invokeRestart <- base::invokeRestart
[17:41:52.223]                       is.null <- base::is.null
[17:41:52.223]                       muffled <- FALSE
[17:41:52.223]                       if (inherits(cond, "message")) {
[17:41:52.223]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.223]                         if (muffled) 
[17:41:52.223]                           invokeRestart("muffleMessage")
[17:41:52.223]                       }
[17:41:52.223]                       else if (inherits(cond, "warning")) {
[17:41:52.223]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.223]                         if (muffled) 
[17:41:52.223]                           invokeRestart("muffleWarning")
[17:41:52.223]                       }
[17:41:52.223]                       else if (inherits(cond, "condition")) {
[17:41:52.223]                         if (!is.null(pattern)) {
[17:41:52.223]                           computeRestarts <- base::computeRestarts
[17:41:52.223]                           grepl <- base::grepl
[17:41:52.223]                           restarts <- computeRestarts(cond)
[17:41:52.223]                           for (restart in restarts) {
[17:41:52.223]                             name <- restart$name
[17:41:52.223]                             if (is.null(name)) 
[17:41:52.223]                               next
[17:41:52.223]                             if (!grepl(pattern, name)) 
[17:41:52.223]                               next
[17:41:52.223]                             invokeRestart(restart)
[17:41:52.223]                             muffled <- TRUE
[17:41:52.223]                             break
[17:41:52.223]                           }
[17:41:52.223]                         }
[17:41:52.223]                       }
[17:41:52.223]                       invisible(muffled)
[17:41:52.223]                     }
[17:41:52.223]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.223]                   }
[17:41:52.223]                 }
[17:41:52.223]                 else {
[17:41:52.223]                   if (TRUE) {
[17:41:52.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.223]                     {
[17:41:52.223]                       inherits <- base::inherits
[17:41:52.223]                       invokeRestart <- base::invokeRestart
[17:41:52.223]                       is.null <- base::is.null
[17:41:52.223]                       muffled <- FALSE
[17:41:52.223]                       if (inherits(cond, "message")) {
[17:41:52.223]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.223]                         if (muffled) 
[17:41:52.223]                           invokeRestart("muffleMessage")
[17:41:52.223]                       }
[17:41:52.223]                       else if (inherits(cond, "warning")) {
[17:41:52.223]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.223]                         if (muffled) 
[17:41:52.223]                           invokeRestart("muffleWarning")
[17:41:52.223]                       }
[17:41:52.223]                       else if (inherits(cond, "condition")) {
[17:41:52.223]                         if (!is.null(pattern)) {
[17:41:52.223]                           computeRestarts <- base::computeRestarts
[17:41:52.223]                           grepl <- base::grepl
[17:41:52.223]                           restarts <- computeRestarts(cond)
[17:41:52.223]                           for (restart in restarts) {
[17:41:52.223]                             name <- restart$name
[17:41:52.223]                             if (is.null(name)) 
[17:41:52.223]                               next
[17:41:52.223]                             if (!grepl(pattern, name)) 
[17:41:52.223]                               next
[17:41:52.223]                             invokeRestart(restart)
[17:41:52.223]                             muffled <- TRUE
[17:41:52.223]                             break
[17:41:52.223]                           }
[17:41:52.223]                         }
[17:41:52.223]                       }
[17:41:52.223]                       invisible(muffled)
[17:41:52.223]                     }
[17:41:52.223]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.223]                   }
[17:41:52.223]                 }
[17:41:52.223]             }
[17:41:52.223]         }))
[17:41:52.223]     }, error = function(ex) {
[17:41:52.223]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:52.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.223]                 ...future.rng), started = ...future.startTime, 
[17:41:52.223]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:52.223]             version = "1.8"), class = "FutureResult")
[17:41:52.223]     }, finally = {
[17:41:52.223]         if (!identical(...future.workdir, getwd())) 
[17:41:52.223]             setwd(...future.workdir)
[17:41:52.223]         {
[17:41:52.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:52.223]                 ...future.oldOptions$nwarnings <- NULL
[17:41:52.223]             }
[17:41:52.223]             base::options(...future.oldOptions)
[17:41:52.223]             if (.Platform$OS.type == "windows") {
[17:41:52.223]                 old_names <- names(...future.oldEnvVars)
[17:41:52.223]                 envs <- base::Sys.getenv()
[17:41:52.223]                 names <- names(envs)
[17:41:52.223]                 common <- intersect(names, old_names)
[17:41:52.223]                 added <- setdiff(names, old_names)
[17:41:52.223]                 removed <- setdiff(old_names, names)
[17:41:52.223]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:52.223]                   envs[common]]
[17:41:52.223]                 NAMES <- toupper(changed)
[17:41:52.223]                 args <- list()
[17:41:52.223]                 for (kk in seq_along(NAMES)) {
[17:41:52.223]                   name <- changed[[kk]]
[17:41:52.223]                   NAME <- NAMES[[kk]]
[17:41:52.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.223]                     next
[17:41:52.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.223]                 }
[17:41:52.223]                 NAMES <- toupper(added)
[17:41:52.223]                 for (kk in seq_along(NAMES)) {
[17:41:52.223]                   name <- added[[kk]]
[17:41:52.223]                   NAME <- NAMES[[kk]]
[17:41:52.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.223]                     next
[17:41:52.223]                   args[[name]] <- ""
[17:41:52.223]                 }
[17:41:52.223]                 NAMES <- toupper(removed)
[17:41:52.223]                 for (kk in seq_along(NAMES)) {
[17:41:52.223]                   name <- removed[[kk]]
[17:41:52.223]                   NAME <- NAMES[[kk]]
[17:41:52.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.223]                     next
[17:41:52.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.223]                 }
[17:41:52.223]                 if (length(args) > 0) 
[17:41:52.223]                   base::do.call(base::Sys.setenv, args = args)
[17:41:52.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:52.223]             }
[17:41:52.223]             else {
[17:41:52.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:52.223]             }
[17:41:52.223]             {
[17:41:52.223]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:52.223]                   0L) {
[17:41:52.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:52.223]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:52.223]                   base::options(opts)
[17:41:52.223]                 }
[17:41:52.223]                 {
[17:41:52.223]                   {
[17:41:52.223]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:52.223]                     NULL
[17:41:52.223]                   }
[17:41:52.223]                   options(future.plan = NULL)
[17:41:52.223]                   if (is.na(NA_character_)) 
[17:41:52.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:52.223]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:52.223]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:52.223]                     envir = parent.frame()) 
[17:41:52.223]                   {
[17:41:52.223]                     if (is.function(workers)) 
[17:41:52.223]                       workers <- workers()
[17:41:52.223]                     workers <- structure(as.integer(workers), 
[17:41:52.223]                       class = class(workers))
[17:41:52.223]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:52.223]                       workers >= 1)
[17:41:52.223]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:52.223]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:52.223]                     }
[17:41:52.223]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:52.223]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:52.223]                       envir = envir)
[17:41:52.223]                     if (!future$lazy) 
[17:41:52.223]                       future <- run(future)
[17:41:52.223]                     invisible(future)
[17:41:52.223]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:52.223]                 }
[17:41:52.223]             }
[17:41:52.223]         }
[17:41:52.223]     })
[17:41:52.223]     if (TRUE) {
[17:41:52.223]         base::sink(type = "output", split = FALSE)
[17:41:52.223]         if (TRUE) {
[17:41:52.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:52.223]         }
[17:41:52.223]         else {
[17:41:52.223]             ...future.result["stdout"] <- base::list(NULL)
[17:41:52.223]         }
[17:41:52.223]         base::close(...future.stdout)
[17:41:52.223]         ...future.stdout <- NULL
[17:41:52.223]     }
[17:41:52.223]     ...future.result$conditions <- ...future.conditions
[17:41:52.223]     ...future.result$finished <- base::Sys.time()
[17:41:52.223]     ...future.result
[17:41:52.223] }
[17:41:52.226] Poll #1 (0): usedNodes() = 2, workers = 2
[17:41:52.251] receiveMessageFromWorker() for ClusterFuture ...
[17:41:52.251] - Validating connection of MultisessionFuture
[17:41:52.252] - received message: FutureResult
[17:41:52.252] - Received FutureResult
[17:41:52.252] - Erased future from FutureRegistry
[17:41:52.252] result() for ClusterFuture ...
[17:41:52.252] - result already collected: FutureResult
[17:41:52.252] result() for ClusterFuture ... done
[17:41:52.253] signalConditions() ...
[17:41:52.253]  - include = ‘immediateCondition’
[17:41:52.253]  - exclude = 
[17:41:52.253]  - resignal = FALSE
[17:41:52.253]  - Number of conditions: 2
[17:41:52.253] signalConditions() ... done
[17:41:52.253] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:52.254] result() for ClusterFuture ...
[17:41:52.254] - result already collected: FutureResult
[17:41:52.254] result() for ClusterFuture ... done
[17:41:52.254] result() for ClusterFuture ...
[17:41:52.254] - result already collected: FutureResult
[17:41:52.254] result() for ClusterFuture ... done
[17:41:52.255] signalConditions() ...
[17:41:52.255]  - include = ‘immediateCondition’
[17:41:52.255]  - exclude = 
[17:41:52.255]  - resignal = FALSE
[17:41:52.255]  - Number of conditions: 2
[17:41:52.255] signalConditions() ... done
[17:41:52.256] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[17:41:52.256] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:41:52.257] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:52.257] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[17:41:52.257] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[17:41:52.257] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[17:41:52.303] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[17:41:52.303] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[17:41:52.347] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[17:41:52.348] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[17:41:52.349] MultisessionFuture started
[17:41:52.349] - Launch lazy future ... done
[17:41:52.349] run() for ‘MultisessionFuture’ ... done
[17:41:52.349] - run() ... done
[17:41:52.349] - resolved() ...
[17:41:52.360] - resolved: FALSE
[17:41:52.360] - resolved() ... done
[17:41:52.360] resolved() for ‘MultisessionFuture’ ... done
[17:41:52.360] resolved() for ‘Future’ ...
[17:41:52.360] - state: ‘created’
[17:41:52.361] - run: TRUE
[17:41:52.361] - run() ...
[17:41:52.361] run() for ‘Future’ ...
[17:41:52.361] - state: ‘created’
[17:41:52.361] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:52.376] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:52.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:52.376]   - Field: ‘node’
[17:41:52.377]   - Field: ‘label’
[17:41:52.377]   - Field: ‘local’
[17:41:52.377]   - Field: ‘owner’
[17:41:52.377]   - Field: ‘envir’
[17:41:52.377]   - Field: ‘workers’
[17:41:52.377]   - Field: ‘packages’
[17:41:52.377]   - Field: ‘gc’
[17:41:52.377]   - Field: ‘conditions’
[17:41:52.377]   - Field: ‘persistent’
[17:41:52.377]   - Field: ‘expr’
[17:41:52.378]   - Field: ‘uuid’
[17:41:52.378]   - Field: ‘seed’
[17:41:52.378]   - Field: ‘version’
[17:41:52.378]   - Field: ‘result’
[17:41:52.378]   - Field: ‘asynchronous’
[17:41:52.378]   - Field: ‘calls’
[17:41:52.378]   - Field: ‘globals’
[17:41:52.378]   - Field: ‘stdout’
[17:41:52.378]   - Field: ‘earlySignal’
[17:41:52.378]   - Field: ‘lazy’
[17:41:52.378]   - Field: ‘state’
[17:41:52.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:52.379] - Launch lazy future ...
[17:41:52.379] Packages needed by the future expression (n = 1): ‘future’
[17:41:52.379] Packages needed by future strategies (n = 0): <none>
[17:41:52.380] {
[17:41:52.380]     {
[17:41:52.380]         {
[17:41:52.380]             ...future.startTime <- base::Sys.time()
[17:41:52.380]             {
[17:41:52.380]                 {
[17:41:52.380]                   {
[17:41:52.380]                     {
[17:41:52.380]                       {
[17:41:52.380]                         base::local({
[17:41:52.380]                           has_future <- base::requireNamespace("future", 
[17:41:52.380]                             quietly = TRUE)
[17:41:52.380]                           if (has_future) {
[17:41:52.380]                             ns <- base::getNamespace("future")
[17:41:52.380]                             version <- ns[[".package"]][["version"]]
[17:41:52.380]                             if (is.null(version)) 
[17:41:52.380]                               version <- utils::packageVersion("future")
[17:41:52.380]                           }
[17:41:52.380]                           else {
[17:41:52.380]                             version <- NULL
[17:41:52.380]                           }
[17:41:52.380]                           if (!has_future || version < "1.8.0") {
[17:41:52.380]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:52.380]                               "", base::R.version$version.string), 
[17:41:52.380]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:52.380]                                 base::R.version$platform, 8 * 
[17:41:52.380]                                   base::.Machine$sizeof.pointer), 
[17:41:52.380]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:52.380]                                 "release", "version")], collapse = " "), 
[17:41:52.380]                               hostname = base::Sys.info()[["nodename"]])
[17:41:52.380]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:52.380]                               info)
[17:41:52.380]                             info <- base::paste(info, collapse = "; ")
[17:41:52.380]                             if (!has_future) {
[17:41:52.380]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:52.380]                                 info)
[17:41:52.380]                             }
[17:41:52.380]                             else {
[17:41:52.380]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:52.380]                                 info, version)
[17:41:52.380]                             }
[17:41:52.380]                             base::stop(msg)
[17:41:52.380]                           }
[17:41:52.380]                         })
[17:41:52.380]                       }
[17:41:52.380]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:52.380]                       base::options(mc.cores = 1L)
[17:41:52.380]                     }
[17:41:52.380]                     base::local({
[17:41:52.380]                       for (pkg in "future") {
[17:41:52.380]                         base::loadNamespace(pkg)
[17:41:52.380]                         base::library(pkg, character.only = TRUE)
[17:41:52.380]                       }
[17:41:52.380]                     })
[17:41:52.380]                   }
[17:41:52.380]                   options(future.plan = NULL)
[17:41:52.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:52.380]                 }
[17:41:52.380]                 ...future.workdir <- getwd()
[17:41:52.380]             }
[17:41:52.380]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:52.380]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:52.380]         }
[17:41:52.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:52.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:52.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:52.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:52.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:52.380]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:52.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:52.380]             base::names(...future.oldOptions))
[17:41:52.380]     }
[17:41:52.380]     if (FALSE) {
[17:41:52.380]     }
[17:41:52.380]     else {
[17:41:52.380]         if (TRUE) {
[17:41:52.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:52.380]                 open = "w")
[17:41:52.380]         }
[17:41:52.380]         else {
[17:41:52.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:52.380]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:52.380]         }
[17:41:52.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:52.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:52.380]             base::sink(type = "output", split = FALSE)
[17:41:52.380]             base::close(...future.stdout)
[17:41:52.380]         }, add = TRUE)
[17:41:52.380]     }
[17:41:52.380]     ...future.frame <- base::sys.nframe()
[17:41:52.380]     ...future.conditions <- base::list()
[17:41:52.380]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:52.380]     if (FALSE) {
[17:41:52.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:52.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:52.380]     }
[17:41:52.380]     ...future.result <- base::tryCatch({
[17:41:52.380]         base::withCallingHandlers({
[17:41:52.380]             ...future.value <- base::withVisible(base::local({
[17:41:52.380]                 ...future.makeSendCondition <- local({
[17:41:52.380]                   sendCondition <- NULL
[17:41:52.380]                   function(frame = 1L) {
[17:41:52.380]                     if (is.function(sendCondition)) 
[17:41:52.380]                       return(sendCondition)
[17:41:52.380]                     ns <- getNamespace("parallel")
[17:41:52.380]                     if (exists("sendData", mode = "function", 
[17:41:52.380]                       envir = ns)) {
[17:41:52.380]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:52.380]                         envir = ns)
[17:41:52.380]                       envir <- sys.frame(frame)
[17:41:52.380]                       master <- NULL
[17:41:52.380]                       while (!identical(envir, .GlobalEnv) && 
[17:41:52.380]                         !identical(envir, emptyenv())) {
[17:41:52.380]                         if (exists("master", mode = "list", envir = envir, 
[17:41:52.380]                           inherits = FALSE)) {
[17:41:52.380]                           master <- get("master", mode = "list", 
[17:41:52.380]                             envir = envir, inherits = FALSE)
[17:41:52.380]                           if (inherits(master, c("SOCKnode", 
[17:41:52.380]                             "SOCK0node"))) {
[17:41:52.380]                             sendCondition <<- function(cond) {
[17:41:52.380]                               data <- list(type = "VALUE", value = cond, 
[17:41:52.380]                                 success = TRUE)
[17:41:52.380]                               parallel_sendData(master, data)
[17:41:52.380]                             }
[17:41:52.380]                             return(sendCondition)
[17:41:52.380]                           }
[17:41:52.380]                         }
[17:41:52.380]                         frame <- frame + 1L
[17:41:52.380]                         envir <- sys.frame(frame)
[17:41:52.380]                       }
[17:41:52.380]                     }
[17:41:52.380]                     sendCondition <<- function(cond) NULL
[17:41:52.380]                   }
[17:41:52.380]                 })
[17:41:52.380]                 withCallingHandlers({
[17:41:52.380]                   {
[17:41:52.380]                     message(sprintf("Calculating tile #%d of %d ...", 
[17:41:52.380]                       ii, n), appendLF = FALSE)
[17:41:52.380]                     fit <- mandelbrot(C)
[17:41:52.380]                     delay(fit)
[17:41:52.380]                     message(" done")
[17:41:52.380]                     fit
[17:41:52.380]                   }
[17:41:52.380]                 }, immediateCondition = function(cond) {
[17:41:52.380]                   sendCondition <- ...future.makeSendCondition()
[17:41:52.380]                   sendCondition(cond)
[17:41:52.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.380]                   {
[17:41:52.380]                     inherits <- base::inherits
[17:41:52.380]                     invokeRestart <- base::invokeRestart
[17:41:52.380]                     is.null <- base::is.null
[17:41:52.380]                     muffled <- FALSE
[17:41:52.380]                     if (inherits(cond, "message")) {
[17:41:52.380]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:52.380]                       if (muffled) 
[17:41:52.380]                         invokeRestart("muffleMessage")
[17:41:52.380]                     }
[17:41:52.380]                     else if (inherits(cond, "warning")) {
[17:41:52.380]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:52.380]                       if (muffled) 
[17:41:52.380]                         invokeRestart("muffleWarning")
[17:41:52.380]                     }
[17:41:52.380]                     else if (inherits(cond, "condition")) {
[17:41:52.380]                       if (!is.null(pattern)) {
[17:41:52.380]                         computeRestarts <- base::computeRestarts
[17:41:52.380]                         grepl <- base::grepl
[17:41:52.380]                         restarts <- computeRestarts(cond)
[17:41:52.380]                         for (restart in restarts) {
[17:41:52.380]                           name <- restart$name
[17:41:52.380]                           if (is.null(name)) 
[17:41:52.380]                             next
[17:41:52.380]                           if (!grepl(pattern, name)) 
[17:41:52.380]                             next
[17:41:52.380]                           invokeRestart(restart)
[17:41:52.380]                           muffled <- TRUE
[17:41:52.380]                           break
[17:41:52.380]                         }
[17:41:52.380]                       }
[17:41:52.380]                     }
[17:41:52.380]                     invisible(muffled)
[17:41:52.380]                   }
[17:41:52.380]                   muffleCondition(cond)
[17:41:52.380]                 })
[17:41:52.380]             }))
[17:41:52.380]             future::FutureResult(value = ...future.value$value, 
[17:41:52.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.380]                   ...future.rng), globalenv = if (FALSE) 
[17:41:52.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:52.380]                     ...future.globalenv.names))
[17:41:52.380]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:52.380]         }, condition = base::local({
[17:41:52.380]             c <- base::c
[17:41:52.380]             inherits <- base::inherits
[17:41:52.380]             invokeRestart <- base::invokeRestart
[17:41:52.380]             length <- base::length
[17:41:52.380]             list <- base::list
[17:41:52.380]             seq.int <- base::seq.int
[17:41:52.380]             signalCondition <- base::signalCondition
[17:41:52.380]             sys.calls <- base::sys.calls
[17:41:52.380]             `[[` <- base::`[[`
[17:41:52.380]             `+` <- base::`+`
[17:41:52.380]             `<<-` <- base::`<<-`
[17:41:52.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:52.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:52.380]                   3L)]
[17:41:52.380]             }
[17:41:52.380]             function(cond) {
[17:41:52.380]                 is_error <- inherits(cond, "error")
[17:41:52.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:52.380]                   NULL)
[17:41:52.380]                 if (is_error) {
[17:41:52.380]                   sessionInformation <- function() {
[17:41:52.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:52.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:52.380]                       search = base::search(), system = base::Sys.info())
[17:41:52.380]                   }
[17:41:52.380]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:52.380]                     cond$call), session = sessionInformation(), 
[17:41:52.380]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:52.380]                   signalCondition(cond)
[17:41:52.380]                 }
[17:41:52.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:52.380]                 "immediateCondition"))) {
[17:41:52.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:52.380]                   ...future.conditions[[length(...future.conditions) + 
[17:41:52.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:52.380]                   if (TRUE && !signal) {
[17:41:52.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.380]                     {
[17:41:52.380]                       inherits <- base::inherits
[17:41:52.380]                       invokeRestart <- base::invokeRestart
[17:41:52.380]                       is.null <- base::is.null
[17:41:52.380]                       muffled <- FALSE
[17:41:52.380]                       if (inherits(cond, "message")) {
[17:41:52.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.380]                         if (muffled) 
[17:41:52.380]                           invokeRestart("muffleMessage")
[17:41:52.380]                       }
[17:41:52.380]                       else if (inherits(cond, "warning")) {
[17:41:52.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.380]                         if (muffled) 
[17:41:52.380]                           invokeRestart("muffleWarning")
[17:41:52.380]                       }
[17:41:52.380]                       else if (inherits(cond, "condition")) {
[17:41:52.380]                         if (!is.null(pattern)) {
[17:41:52.380]                           computeRestarts <- base::computeRestarts
[17:41:52.380]                           grepl <- base::grepl
[17:41:52.380]                           restarts <- computeRestarts(cond)
[17:41:52.380]                           for (restart in restarts) {
[17:41:52.380]                             name <- restart$name
[17:41:52.380]                             if (is.null(name)) 
[17:41:52.380]                               next
[17:41:52.380]                             if (!grepl(pattern, name)) 
[17:41:52.380]                               next
[17:41:52.380]                             invokeRestart(restart)
[17:41:52.380]                             muffled <- TRUE
[17:41:52.380]                             break
[17:41:52.380]                           }
[17:41:52.380]                         }
[17:41:52.380]                       }
[17:41:52.380]                       invisible(muffled)
[17:41:52.380]                     }
[17:41:52.380]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.380]                   }
[17:41:52.380]                 }
[17:41:52.380]                 else {
[17:41:52.380]                   if (TRUE) {
[17:41:52.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:52.380]                     {
[17:41:52.380]                       inherits <- base::inherits
[17:41:52.380]                       invokeRestart <- base::invokeRestart
[17:41:52.380]                       is.null <- base::is.null
[17:41:52.380]                       muffled <- FALSE
[17:41:52.380]                       if (inherits(cond, "message")) {
[17:41:52.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:52.380]                         if (muffled) 
[17:41:52.380]                           invokeRestart("muffleMessage")
[17:41:52.380]                       }
[17:41:52.380]                       else if (inherits(cond, "warning")) {
[17:41:52.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:52.380]                         if (muffled) 
[17:41:52.380]                           invokeRestart("muffleWarning")
[17:41:52.380]                       }
[17:41:52.380]                       else if (inherits(cond, "condition")) {
[17:41:52.380]                         if (!is.null(pattern)) {
[17:41:52.380]                           computeRestarts <- base::computeRestarts
[17:41:52.380]                           grepl <- base::grepl
[17:41:52.380]                           restarts <- computeRestarts(cond)
[17:41:52.380]                           for (restart in restarts) {
[17:41:52.380]                             name <- restart$name
[17:41:52.380]                             if (is.null(name)) 
[17:41:52.380]                               next
[17:41:52.380]                             if (!grepl(pattern, name)) 
[17:41:52.380]                               next
[17:41:52.380]                             invokeRestart(restart)
[17:41:52.380]                             muffled <- TRUE
[17:41:52.380]                             break
[17:41:52.380]                           }
[17:41:52.380]                         }
[17:41:52.380]                       }
[17:41:52.380]                       invisible(muffled)
[17:41:52.380]                     }
[17:41:52.380]                     muffleCondition(cond, pattern = "^muffle")
[17:41:52.380]                   }
[17:41:52.380]                 }
[17:41:52.380]             }
[17:41:52.380]         }))
[17:41:52.380]     }, error = function(ex) {
[17:41:52.380]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:52.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:52.380]                 ...future.rng), started = ...future.startTime, 
[17:41:52.380]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:52.380]             version = "1.8"), class = "FutureResult")
[17:41:52.380]     }, finally = {
[17:41:52.380]         if (!identical(...future.workdir, getwd())) 
[17:41:52.380]             setwd(...future.workdir)
[17:41:52.380]         {
[17:41:52.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:52.380]                 ...future.oldOptions$nwarnings <- NULL
[17:41:52.380]             }
[17:41:52.380]             base::options(...future.oldOptions)
[17:41:52.380]             if (.Platform$OS.type == "windows") {
[17:41:52.380]                 old_names <- names(...future.oldEnvVars)
[17:41:52.380]                 envs <- base::Sys.getenv()
[17:41:52.380]                 names <- names(envs)
[17:41:52.380]                 common <- intersect(names, old_names)
[17:41:52.380]                 added <- setdiff(names, old_names)
[17:41:52.380]                 removed <- setdiff(old_names, names)
[17:41:52.380]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:52.380]                   envs[common]]
[17:41:52.380]                 NAMES <- toupper(changed)
[17:41:52.380]                 args <- list()
[17:41:52.380]                 for (kk in seq_along(NAMES)) {
[17:41:52.380]                   name <- changed[[kk]]
[17:41:52.380]                   NAME <- NAMES[[kk]]
[17:41:52.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.380]                     next
[17:41:52.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.380]                 }
[17:41:52.380]                 NAMES <- toupper(added)
[17:41:52.380]                 for (kk in seq_along(NAMES)) {
[17:41:52.380]                   name <- added[[kk]]
[17:41:52.380]                   NAME <- NAMES[[kk]]
[17:41:52.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.380]                     next
[17:41:52.380]                   args[[name]] <- ""
[17:41:52.380]                 }
[17:41:52.380]                 NAMES <- toupper(removed)
[17:41:52.380]                 for (kk in seq_along(NAMES)) {
[17:41:52.380]                   name <- removed[[kk]]
[17:41:52.380]                   NAME <- NAMES[[kk]]
[17:41:52.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:52.380]                     next
[17:41:52.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:52.380]                 }
[17:41:52.380]                 if (length(args) > 0) 
[17:41:52.380]                   base::do.call(base::Sys.setenv, args = args)
[17:41:52.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:52.380]             }
[17:41:52.380]             else {
[17:41:52.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:52.380]             }
[17:41:52.380]             {
[17:41:52.380]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:52.380]                   0L) {
[17:41:52.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:52.380]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:52.380]                   base::options(opts)
[17:41:52.380]                 }
[17:41:52.380]                 {
[17:41:52.380]                   {
[17:41:52.380]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:52.380]                     NULL
[17:41:52.380]                   }
[17:41:52.380]                   options(future.plan = NULL)
[17:41:52.380]                   if (is.na(NA_character_)) 
[17:41:52.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:52.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:52.380]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:52.380]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:52.380]                     envir = parent.frame()) 
[17:41:52.380]                   {
[17:41:52.380]                     if (is.function(workers)) 
[17:41:52.380]                       workers <- workers()
[17:41:52.380]                     workers <- structure(as.integer(workers), 
[17:41:52.380]                       class = class(workers))
[17:41:52.380]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:52.380]                       workers >= 1)
[17:41:52.380]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:52.380]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:52.380]                     }
[17:41:52.380]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:52.380]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:52.380]                       envir = envir)
[17:41:52.380]                     if (!future$lazy) 
[17:41:52.380]                       future <- run(future)
[17:41:52.380]                     invisible(future)
[17:41:52.380]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:52.380]                 }
[17:41:52.380]             }
[17:41:52.380]         }
[17:41:52.380]     })
[17:41:52.380]     if (TRUE) {
[17:41:52.380]         base::sink(type = "output", split = FALSE)
[17:41:52.380]         if (TRUE) {
[17:41:52.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:52.380]         }
[17:41:52.380]         else {
[17:41:52.380]             ...future.result["stdout"] <- base::list(NULL)
[17:41:52.380]         }
[17:41:52.380]         base::close(...future.stdout)
[17:41:52.380]         ...future.stdout <- NULL
[17:41:52.380]     }
[17:41:52.380]     ...future.result$conditions <- ...future.conditions
[17:41:52.380]     ...future.result$finished <- base::Sys.time()
[17:41:52.380]     ...future.result
[17:41:52.380] }
[17:41:52.382] Poll #1 (0): usedNodes() = 2, workers = 2
[17:41:52.393] receiveMessageFromWorker() for ClusterFuture ...
[17:41:52.393] - Validating connection of MultisessionFuture
[17:41:52.394] - received message: FutureResult
[17:41:52.394] - Received FutureResult
[17:41:52.394] - Erased future from FutureRegistry
[17:41:52.394] result() for ClusterFuture ...
[17:41:52.394] - result already collected: FutureResult
[17:41:52.394] result() for ClusterFuture ... done
[17:41:52.395] signalConditions() ...
[17:41:52.395]  - include = ‘immediateCondition’
[17:41:52.395]  - exclude = 
[17:41:52.395]  - resignal = FALSE
[17:41:52.395]  - Number of conditions: 2
[17:41:52.395] signalConditions() ... done
[17:41:52.395] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:52.396] result() for ClusterFuture ...
[17:41:52.396] - result already collected: FutureResult
[17:41:52.396] result() for ClusterFuture ... done
[17:41:52.396] result() for ClusterFuture ...
[17:41:52.396] - result already collected: FutureResult
[17:41:52.396] result() for ClusterFuture ... done
[17:41:52.397] signalConditions() ...
[17:41:52.397]  - include = ‘immediateCondition’
[17:41:52.397]  - exclude = 
[17:41:52.397]  - resignal = FALSE
[17:41:52.397]  - Number of conditions: 2
[17:41:52.397] signalConditions() ... done
[17:41:52.398] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[17:41:52.398] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:41:52.399] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:41:52.399] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[17:41:52.400] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[17:41:52.400] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[17:41:52.443] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[17:41:52.443] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[17:41:52.487] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[17:41:52.488] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[17:41:52.488] MultisessionFuture started
[17:41:52.489] - Launch lazy future ... done
[17:41:52.489] run() for ‘MultisessionFuture’ ... done
[17:41:52.489] - run() ... done
[17:41:52.489] - resolved() ...
[17:41:52.499] - resolved: FALSE
[17:41:52.500] - resolved() ... done
[17:41:52.500] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[17:41:52.500] result() for ClusterFuture ...
[17:41:52.500] - result already collected: FutureResult
[17:41:52.500] result() for ClusterFuture ... done
[17:41:52.500] result() for ClusterFuture ...
[17:41:52.500] - result already collected: FutureResult
[17:41:52.500] result() for ClusterFuture ... done
[17:41:52.501] signalConditions() ...
[17:41:52.501]  - include = ‘immediateCondition’
[17:41:52.501]  - exclude = 
[17:41:52.501]  - resignal = FALSE
[17:41:52.501]  - Number of conditions: 2
[17:41:52.501] signalConditions() ... done
[17:41:52.501] Future state: ‘finished’
[17:41:52.501] result() for ClusterFuture ...
[17:41:52.501] - result already collected: FutureResult
[17:41:52.501] result() for ClusterFuture ... done
[17:41:52.501] signalConditions() ...
[17:41:52.502]  - include = ‘condition’
[17:41:52.502]  - exclude = ‘immediateCondition’
[17:41:52.502]  - resignal = TRUE
[17:41:52.502]  - Number of conditions: 2
[17:41:52.502]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[17:41:52.502]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:52.502] signalConditions() ... done
Plotting tile #2 of 4 ...
[17:41:52.505] result() for ClusterFuture ...
[17:41:52.505] - result already collected: FutureResult
[17:41:52.505] result() for ClusterFuture ... done
[17:41:52.505] result() for ClusterFuture ...
[17:41:52.506] - result already collected: FutureResult
[17:41:52.506] result() for ClusterFuture ... done
[17:41:52.506] signalConditions() ...
[17:41:52.506]  - include = ‘immediateCondition’
[17:41:52.506]  - exclude = 
[17:41:52.506]  - resignal = FALSE
[17:41:52.506]  - Number of conditions: 2
[17:41:52.506] signalConditions() ... done
[17:41:52.506] Future state: ‘finished’
[17:41:52.506] result() for ClusterFuture ...
[17:41:52.506] - result already collected: FutureResult
[17:41:52.507] result() for ClusterFuture ... done
[17:41:52.507] signalConditions() ...
[17:41:52.507]  - include = ‘condition’
[17:41:52.507]  - exclude = ‘immediateCondition’
[17:41:52.507]  - resignal = TRUE
[17:41:52.507]  - Number of conditions: 2
[17:41:52.507]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[17:41:52.507]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:52.507] signalConditions() ... done
[17:41:52.508] receiveMessageFromWorker() for ClusterFuture ...
[17:41:52.508] - Validating connection of MultisessionFuture
[17:41:52.509] - received message: FutureResult
[17:41:52.509] - Received FutureResult
[17:41:52.509] - Erased future from FutureRegistry
[17:41:52.509] result() for ClusterFuture ...
[17:41:52.509] - result already collected: FutureResult
[17:41:52.509] result() for ClusterFuture ... done
[17:41:52.509] signalConditions() ...
[17:41:52.509]  - include = ‘immediateCondition’
[17:41:52.510]  - exclude = 
[17:41:52.510]  - resignal = FALSE
[17:41:52.510]  - Number of conditions: 2
[17:41:52.510] signalConditions() ... done
[17:41:52.510] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[17:41:52.510] result() for ClusterFuture ...
[17:41:52.510] - result already collected: FutureResult
[17:41:52.510] result() for ClusterFuture ... done
[17:41:52.510] result() for ClusterFuture ...
[17:41:52.510] - result already collected: FutureResult
[17:41:52.510] result() for ClusterFuture ... done
[17:41:52.511] signalConditions() ...
[17:41:52.511]  - include = ‘immediateCondition’
[17:41:52.511]  - exclude = 
[17:41:52.511]  - resignal = FALSE
[17:41:52.511]  - Number of conditions: 2
[17:41:52.511] signalConditions() ... done
[17:41:52.511] Future state: ‘finished’
[17:41:52.511] result() for ClusterFuture ...
[17:41:52.511] - result already collected: FutureResult
[17:41:52.511] result() for ClusterFuture ... done
[17:41:52.511] signalConditions() ...
[17:41:52.512]  - include = ‘condition’
[17:41:52.512]  - exclude = ‘immediateCondition’
[17:41:52.512]  - resignal = TRUE
[17:41:52.512]  - Number of conditions: 2
[17:41:52.512]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[17:41:52.512]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:52.512] signalConditions() ... done
[17:41:52.552] receiveMessageFromWorker() for ClusterFuture ...
[17:41:52.553] - Validating connection of MultisessionFuture
[17:41:52.553] - received message: FutureResult
[17:41:52.553] - Received FutureResult
[17:41:52.554] - Erased future from FutureRegistry
[17:41:52.554] result() for ClusterFuture ...
[17:41:52.554] - result already collected: FutureResult
[17:41:52.554] result() for ClusterFuture ... done
[17:41:52.554] signalConditions() ...
[17:41:52.554]  - include = ‘immediateCondition’
[17:41:52.554]  - exclude = 
[17:41:52.554]  - resignal = FALSE
[17:41:52.554]  - Number of conditions: 2
[17:41:52.554] signalConditions() ... done
[17:41:52.554] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[17:41:52.555] result() for ClusterFuture ...
[17:41:52.555] - result already collected: FutureResult
[17:41:52.555] result() for ClusterFuture ... done
[17:41:52.555] result() for ClusterFuture ...
[17:41:52.555] - result already collected: FutureResult
[17:41:52.555] result() for ClusterFuture ... done
[17:41:52.555] signalConditions() ...
[17:41:52.555]  - include = ‘immediateCondition’
[17:41:52.555]  - exclude = 
[17:41:52.555]  - resignal = FALSE
[17:41:52.556]  - Number of conditions: 2
[17:41:52.556] signalConditions() ... done
[17:41:52.556] Future state: ‘finished’
[17:41:52.556] result() for ClusterFuture ...
[17:41:52.556] - result already collected: FutureResult
[17:41:52.556] result() for ClusterFuture ... done
[17:41:52.556] signalConditions() ...
[17:41:52.556]  - include = ‘condition’
[17:41:52.556]  - exclude = ‘immediateCondition’
[17:41:52.556]  - resignal = TRUE
[17:41:52.556]  - Number of conditions: 2
[17:41:52.557]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[17:41:52.557]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[17:41:52.557] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[17:41:52.559] plan(): Setting new future strategy stack:
[17:41:52.559] List of future strategies:
[17:41:52.559] 1. sequential:
[17:41:52.559]    - args: function (..., envir = parent.frame())
[17:41:52.559]    - tweaked: FALSE
[17:41:52.559]    - call: future::plan("sequential")
[17:41:52.560] plan(): nbrOfWorkers() = 1
> 
