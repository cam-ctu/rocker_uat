
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:12:19.162] plan(): Setting new future strategy stack:
[16:12:19.162] List of future strategies:
[16:12:19.162] 1. sequential:
[16:12:19.162]    - args: function (..., envir = parent.frame())
[16:12:19.162]    - tweaked: FALSE
[16:12:19.162]    - call: future::plan("sequential")
[16:12:19.176] plan(): nbrOfWorkers() = 1
> 
> message("*** futureAssign() ...")
*** futureAssign() ...
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ...")
*** futureAssign() - sequential w/ lazy evaluation ...
> 
> delayedAssign("a", {
+   cat("Delayed assignment evaluated\n")
+   1
+ })
> 
> futureAssign("b", {
+   cat("Future assignment evaluated\n")
+   2
+ }, lazy = TRUE)
[16:12:19.186] getGlobalsAndPackages() ...
[16:12:19.187] Searching for globals...
[16:12:19.193] - globals found: [2] ‘{’, ‘cat’
[16:12:19.193] Searching for globals ... DONE
[16:12:19.193] Resolving globals: FALSE
[16:12:19.194] 
[16:12:19.194] 
[16:12:19.194] getGlobalsAndPackages() ... DONE
> 
> ## Because "lazy future" is used, the expression/value
> ## for 'b' will not be resolved at the point.  For other
> ## types of futures, it may already have been resolved
> cat(sprintf("b = %s\n", b))
[16:12:19.195] run() for ‘Future’ ...
[16:12:19.195] - state: ‘created’
[16:12:19.195] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.196] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.196]   - Field: ‘label’
[16:12:19.196]   - Field: ‘local’
[16:12:19.196]   - Field: ‘owner’
[16:12:19.196]   - Field: ‘envir’
[16:12:19.196]   - Field: ‘packages’
[16:12:19.196]   - Field: ‘gc’
[16:12:19.196]   - Field: ‘conditions’
[16:12:19.197]   - Field: ‘expr’
[16:12:19.197]   - Field: ‘uuid’
[16:12:19.197]   - Field: ‘seed’
[16:12:19.197]   - Field: ‘version’
[16:12:19.197]   - Field: ‘result’
[16:12:19.197]   - Field: ‘asynchronous’
[16:12:19.197]   - Field: ‘calls’
[16:12:19.197]   - Field: ‘globals’
[16:12:19.197]   - Field: ‘stdout’
[16:12:19.197]   - Field: ‘earlySignal’
[16:12:19.197]   - Field: ‘lazy’
[16:12:19.197]   - Field: ‘state’
[16:12:19.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.198] - Launch lazy future ...
[16:12:19.198] Packages needed by the future expression (n = 0): <none>
[16:12:19.199] Packages needed by future strategies (n = 0): <none>
[16:12:19.199] {
[16:12:19.199]     {
[16:12:19.199]         {
[16:12:19.199]             ...future.startTime <- base::Sys.time()
[16:12:19.199]             {
[16:12:19.199]                 {
[16:12:19.199]                   {
[16:12:19.199]                     base::local({
[16:12:19.199]                       has_future <- base::requireNamespace("future", 
[16:12:19.199]                         quietly = TRUE)
[16:12:19.199]                       if (has_future) {
[16:12:19.199]                         ns <- base::getNamespace("future")
[16:12:19.199]                         version <- ns[[".package"]][["version"]]
[16:12:19.199]                         if (is.null(version)) 
[16:12:19.199]                           version <- utils::packageVersion("future")
[16:12:19.199]                       }
[16:12:19.199]                       else {
[16:12:19.199]                         version <- NULL
[16:12:19.199]                       }
[16:12:19.199]                       if (!has_future || version < "1.8.0") {
[16:12:19.199]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.199]                           "", base::R.version$version.string), 
[16:12:19.199]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.199]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.199]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.199]                             "release", "version")], collapse = " "), 
[16:12:19.199]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.199]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.199]                           info)
[16:12:19.199]                         info <- base::paste(info, collapse = "; ")
[16:12:19.199]                         if (!has_future) {
[16:12:19.199]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.199]                             info)
[16:12:19.199]                         }
[16:12:19.199]                         else {
[16:12:19.199]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.199]                             info, version)
[16:12:19.199]                         }
[16:12:19.199]                         base::stop(msg)
[16:12:19.199]                       }
[16:12:19.199]                     })
[16:12:19.199]                   }
[16:12:19.199]                   options(future.plan = NULL)
[16:12:19.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.199]                 }
[16:12:19.199]                 ...future.workdir <- getwd()
[16:12:19.199]             }
[16:12:19.199]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.199]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.199]         }
[16:12:19.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.199]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.199]             base::names(...future.oldOptions))
[16:12:19.199]     }
[16:12:19.199]     if (FALSE) {
[16:12:19.199]     }
[16:12:19.199]     else {
[16:12:19.199]         if (TRUE) {
[16:12:19.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.199]                 open = "w")
[16:12:19.199]         }
[16:12:19.199]         else {
[16:12:19.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.199]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.199]         }
[16:12:19.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.199]             base::sink(type = "output", split = FALSE)
[16:12:19.199]             base::close(...future.stdout)
[16:12:19.199]         }, add = TRUE)
[16:12:19.199]     }
[16:12:19.199]     ...future.frame <- base::sys.nframe()
[16:12:19.199]     ...future.conditions <- base::list()
[16:12:19.199]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.199]     if (FALSE) {
[16:12:19.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.199]     }
[16:12:19.199]     ...future.result <- base::tryCatch({
[16:12:19.199]         base::withCallingHandlers({
[16:12:19.199]             ...future.value <- base::withVisible(base::local({
[16:12:19.199]                 cat("Future assignment evaluated\n")
[16:12:19.199]                 2
[16:12:19.199]             }))
[16:12:19.199]             future::FutureResult(value = ...future.value$value, 
[16:12:19.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.199]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.199]                     ...future.globalenv.names))
[16:12:19.199]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.199]         }, condition = base::local({
[16:12:19.199]             c <- base::c
[16:12:19.199]             inherits <- base::inherits
[16:12:19.199]             invokeRestart <- base::invokeRestart
[16:12:19.199]             length <- base::length
[16:12:19.199]             list <- base::list
[16:12:19.199]             seq.int <- base::seq.int
[16:12:19.199]             signalCondition <- base::signalCondition
[16:12:19.199]             sys.calls <- base::sys.calls
[16:12:19.199]             `[[` <- base::`[[`
[16:12:19.199]             `+` <- base::`+`
[16:12:19.199]             `<<-` <- base::`<<-`
[16:12:19.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.199]                   3L)]
[16:12:19.199]             }
[16:12:19.199]             function(cond) {
[16:12:19.199]                 is_error <- inherits(cond, "error")
[16:12:19.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.199]                   NULL)
[16:12:19.199]                 if (is_error) {
[16:12:19.199]                   sessionInformation <- function() {
[16:12:19.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.199]                       search = base::search(), system = base::Sys.info())
[16:12:19.199]                   }
[16:12:19.199]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.199]                     cond$call), session = sessionInformation(), 
[16:12:19.199]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.199]                   signalCondition(cond)
[16:12:19.199]                 }
[16:12:19.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.199]                 "immediateCondition"))) {
[16:12:19.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.199]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.199]                   if (TRUE && !signal) {
[16:12:19.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.199]                     {
[16:12:19.199]                       inherits <- base::inherits
[16:12:19.199]                       invokeRestart <- base::invokeRestart
[16:12:19.199]                       is.null <- base::is.null
[16:12:19.199]                       muffled <- FALSE
[16:12:19.199]                       if (inherits(cond, "message")) {
[16:12:19.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.199]                         if (muffled) 
[16:12:19.199]                           invokeRestart("muffleMessage")
[16:12:19.199]                       }
[16:12:19.199]                       else if (inherits(cond, "warning")) {
[16:12:19.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.199]                         if (muffled) 
[16:12:19.199]                           invokeRestart("muffleWarning")
[16:12:19.199]                       }
[16:12:19.199]                       else if (inherits(cond, "condition")) {
[16:12:19.199]                         if (!is.null(pattern)) {
[16:12:19.199]                           computeRestarts <- base::computeRestarts
[16:12:19.199]                           grepl <- base::grepl
[16:12:19.199]                           restarts <- computeRestarts(cond)
[16:12:19.199]                           for (restart in restarts) {
[16:12:19.199]                             name <- restart$name
[16:12:19.199]                             if (is.null(name)) 
[16:12:19.199]                               next
[16:12:19.199]                             if (!grepl(pattern, name)) 
[16:12:19.199]                               next
[16:12:19.199]                             invokeRestart(restart)
[16:12:19.199]                             muffled <- TRUE
[16:12:19.199]                             break
[16:12:19.199]                           }
[16:12:19.199]                         }
[16:12:19.199]                       }
[16:12:19.199]                       invisible(muffled)
[16:12:19.199]                     }
[16:12:19.199]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.199]                   }
[16:12:19.199]                 }
[16:12:19.199]                 else {
[16:12:19.199]                   if (TRUE) {
[16:12:19.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.199]                     {
[16:12:19.199]                       inherits <- base::inherits
[16:12:19.199]                       invokeRestart <- base::invokeRestart
[16:12:19.199]                       is.null <- base::is.null
[16:12:19.199]                       muffled <- FALSE
[16:12:19.199]                       if (inherits(cond, "message")) {
[16:12:19.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.199]                         if (muffled) 
[16:12:19.199]                           invokeRestart("muffleMessage")
[16:12:19.199]                       }
[16:12:19.199]                       else if (inherits(cond, "warning")) {
[16:12:19.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.199]                         if (muffled) 
[16:12:19.199]                           invokeRestart("muffleWarning")
[16:12:19.199]                       }
[16:12:19.199]                       else if (inherits(cond, "condition")) {
[16:12:19.199]                         if (!is.null(pattern)) {
[16:12:19.199]                           computeRestarts <- base::computeRestarts
[16:12:19.199]                           grepl <- base::grepl
[16:12:19.199]                           restarts <- computeRestarts(cond)
[16:12:19.199]                           for (restart in restarts) {
[16:12:19.199]                             name <- restart$name
[16:12:19.199]                             if (is.null(name)) 
[16:12:19.199]                               next
[16:12:19.199]                             if (!grepl(pattern, name)) 
[16:12:19.199]                               next
[16:12:19.199]                             invokeRestart(restart)
[16:12:19.199]                             muffled <- TRUE
[16:12:19.199]                             break
[16:12:19.199]                           }
[16:12:19.199]                         }
[16:12:19.199]                       }
[16:12:19.199]                       invisible(muffled)
[16:12:19.199]                     }
[16:12:19.199]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.199]                   }
[16:12:19.199]                 }
[16:12:19.199]             }
[16:12:19.199]         }))
[16:12:19.199]     }, error = function(ex) {
[16:12:19.199]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.199]                 ...future.rng), started = ...future.startTime, 
[16:12:19.199]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.199]             version = "1.8"), class = "FutureResult")
[16:12:19.199]     }, finally = {
[16:12:19.199]         if (!identical(...future.workdir, getwd())) 
[16:12:19.199]             setwd(...future.workdir)
[16:12:19.199]         {
[16:12:19.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.199]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.199]             }
[16:12:19.199]             base::options(...future.oldOptions)
[16:12:19.199]             if (.Platform$OS.type == "windows") {
[16:12:19.199]                 old_names <- names(...future.oldEnvVars)
[16:12:19.199]                 envs <- base::Sys.getenv()
[16:12:19.199]                 names <- names(envs)
[16:12:19.199]                 common <- intersect(names, old_names)
[16:12:19.199]                 added <- setdiff(names, old_names)
[16:12:19.199]                 removed <- setdiff(old_names, names)
[16:12:19.199]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.199]                   envs[common]]
[16:12:19.199]                 NAMES <- toupper(changed)
[16:12:19.199]                 args <- list()
[16:12:19.199]                 for (kk in seq_along(NAMES)) {
[16:12:19.199]                   name <- changed[[kk]]
[16:12:19.199]                   NAME <- NAMES[[kk]]
[16:12:19.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.199]                     next
[16:12:19.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.199]                 }
[16:12:19.199]                 NAMES <- toupper(added)
[16:12:19.199]                 for (kk in seq_along(NAMES)) {
[16:12:19.199]                   name <- added[[kk]]
[16:12:19.199]                   NAME <- NAMES[[kk]]
[16:12:19.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.199]                     next
[16:12:19.199]                   args[[name]] <- ""
[16:12:19.199]                 }
[16:12:19.199]                 NAMES <- toupper(removed)
[16:12:19.199]                 for (kk in seq_along(NAMES)) {
[16:12:19.199]                   name <- removed[[kk]]
[16:12:19.199]                   NAME <- NAMES[[kk]]
[16:12:19.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.199]                     next
[16:12:19.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.199]                 }
[16:12:19.199]                 if (length(args) > 0) 
[16:12:19.199]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.199]             }
[16:12:19.199]             else {
[16:12:19.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.199]             }
[16:12:19.199]             {
[16:12:19.199]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.199]                   0L) {
[16:12:19.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.199]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.199]                   base::options(opts)
[16:12:19.199]                 }
[16:12:19.199]                 {
[16:12:19.199]                   {
[16:12:19.199]                     NULL
[16:12:19.199]                     RNGkind("Mersenne-Twister")
[16:12:19.199]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.199]                       inherits = FALSE)
[16:12:19.199]                   }
[16:12:19.199]                   options(future.plan = NULL)
[16:12:19.199]                   if (is.na(NA_character_)) 
[16:12:19.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.199]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.199]                   {
[16:12:19.199]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.199]                     if (!future$lazy) 
[16:12:19.199]                       future <- run(future)
[16:12:19.199]                     invisible(future)
[16:12:19.199]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.199]                 }
[16:12:19.199]             }
[16:12:19.199]         }
[16:12:19.199]     })
[16:12:19.199]     if (TRUE) {
[16:12:19.199]         base::sink(type = "output", split = FALSE)
[16:12:19.199]         if (TRUE) {
[16:12:19.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.199]         }
[16:12:19.199]         else {
[16:12:19.199]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.199]         }
[16:12:19.199]         base::close(...future.stdout)
[16:12:19.199]         ...future.stdout <- NULL
[16:12:19.199]     }
[16:12:19.199]     ...future.result$conditions <- ...future.conditions
[16:12:19.199]     ...future.result$finished <- base::Sys.time()
[16:12:19.199]     ...future.result
[16:12:19.199] }
[16:12:19.201] plan(): Setting new future strategy stack:
[16:12:19.202] List of future strategies:
[16:12:19.202] 1. sequential:
[16:12:19.202]    - args: function (..., envir = parent.frame())
[16:12:19.202]    - tweaked: FALSE
[16:12:19.202]    - call: NULL
[16:12:19.202] plan(): nbrOfWorkers() = 1
[16:12:19.203] plan(): Setting new future strategy stack:
[16:12:19.203] List of future strategies:
[16:12:19.203] 1. sequential:
[16:12:19.203]    - args: function (..., envir = parent.frame())
[16:12:19.203]    - tweaked: FALSE
[16:12:19.203]    - call: future::plan("sequential")
[16:12:19.203] plan(): nbrOfWorkers() = 1
[16:12:19.204] SequentialFuture started (and completed)
[16:12:19.204] - Launch lazy future ... done
[16:12:19.204] run() for ‘SequentialFuture’ ... done
Future assignment evaluated
b = 2
> 
> ## The expression/value of 'a' is resolved at this point,
> ## because a delayed assignment (promise) was used.
> cat(sprintf("a = %s\n", a))
Delayed assignment evaluated
a = 1
> 
> stopifnot(identical(a, 1))
> stopifnot(identical(b, 2))
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ... DONE")
*** futureAssign() - sequential w/ lazy evaluation ... DONE
> 
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ...")
*** futureAssign() - lazy = TRUE / FALSE ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** futureAssign() with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     ## Potential task name clashes
+     u <- new.env()
+     v <- new.env()
+     futureAssign("a", { 2 }, assign.env = u)
+     futureAssign("a", { 4 }, assign.env = v)
+     
+     cat(sprintf("u$a = %s\n", u$a))
+     cat(sprintf("v$a = %s\n", v$a))
+     
+     stopifnot(identical(u$a, 2))
+     stopifnot(identical(v$a, 4))
+     
+     
+     ## Global variables
+     a <- 1
+     futureAssign("b", { 2 * a })
+     a <- 2
+     stopifnot(b == 2)
+ 
+     ## Explicit lazy evaluation
+     for (lazy in c(FALSE, TRUE)) {
+       a <- 1
+       f <- futureAssign("b", { 2 * a }, lazy = lazy)
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+       
+       ## Set 'lazy' via disposable option
+       options(future.disposable = list(lazy = lazy))
+       a <- 1
+       f <- futureAssign("b", { 2 * a })
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+     }
+ 
+     message(sprintf("*** futureAssign() with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** futureAssign() with ‘sequential’ futures ...
[16:12:19.230] plan(): Setting new future strategy stack:
[16:12:19.230] List of future strategies:
[16:12:19.230] 1. sequential:
[16:12:19.230]    - args: function (..., envir = parent.frame())
[16:12:19.230]    - tweaked: FALSE
[16:12:19.230]    - call: plan(strategy)
[16:12:19.242] plan(): nbrOfWorkers() = 1
[16:12:19.242] getGlobalsAndPackages() ...
[16:12:19.242] Searching for globals...
[16:12:19.243] - globals found: [1] ‘{’
[16:12:19.243] Searching for globals ... DONE
[16:12:19.243] Resolving globals: FALSE
[16:12:19.243] 
[16:12:19.244] 
[16:12:19.244] getGlobalsAndPackages() ... DONE
[16:12:19.244] run() for ‘Future’ ...
[16:12:19.244] - state: ‘created’
[16:12:19.244] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.245]   - Field: ‘label’
[16:12:19.245]   - Field: ‘local’
[16:12:19.245]   - Field: ‘owner’
[16:12:19.245]   - Field: ‘envir’
[16:12:19.245]   - Field: ‘packages’
[16:12:19.245]   - Field: ‘gc’
[16:12:19.245]   - Field: ‘conditions’
[16:12:19.245]   - Field: ‘expr’
[16:12:19.245]   - Field: ‘uuid’
[16:12:19.246]   - Field: ‘seed’
[16:12:19.246]   - Field: ‘version’
[16:12:19.246]   - Field: ‘result’
[16:12:19.246]   - Field: ‘asynchronous’
[16:12:19.246]   - Field: ‘calls’
[16:12:19.246]   - Field: ‘globals’
[16:12:19.246]   - Field: ‘stdout’
[16:12:19.246]   - Field: ‘earlySignal’
[16:12:19.246]   - Field: ‘lazy’
[16:12:19.246]   - Field: ‘state’
[16:12:19.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.247] - Launch lazy future ...
[16:12:19.247] Packages needed by the future expression (n = 0): <none>
[16:12:19.247] Packages needed by future strategies (n = 0): <none>
[16:12:19.247] {
[16:12:19.247]     {
[16:12:19.247]         {
[16:12:19.247]             ...future.startTime <- base::Sys.time()
[16:12:19.247]             {
[16:12:19.247]                 {
[16:12:19.247]                   {
[16:12:19.247]                     base::local({
[16:12:19.247]                       has_future <- base::requireNamespace("future", 
[16:12:19.247]                         quietly = TRUE)
[16:12:19.247]                       if (has_future) {
[16:12:19.247]                         ns <- base::getNamespace("future")
[16:12:19.247]                         version <- ns[[".package"]][["version"]]
[16:12:19.247]                         if (is.null(version)) 
[16:12:19.247]                           version <- utils::packageVersion("future")
[16:12:19.247]                       }
[16:12:19.247]                       else {
[16:12:19.247]                         version <- NULL
[16:12:19.247]                       }
[16:12:19.247]                       if (!has_future || version < "1.8.0") {
[16:12:19.247]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.247]                           "", base::R.version$version.string), 
[16:12:19.247]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.247]                             "release", "version")], collapse = " "), 
[16:12:19.247]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.247]                           info)
[16:12:19.247]                         info <- base::paste(info, collapse = "; ")
[16:12:19.247]                         if (!has_future) {
[16:12:19.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.247]                             info)
[16:12:19.247]                         }
[16:12:19.247]                         else {
[16:12:19.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.247]                             info, version)
[16:12:19.247]                         }
[16:12:19.247]                         base::stop(msg)
[16:12:19.247]                       }
[16:12:19.247]                     })
[16:12:19.247]                   }
[16:12:19.247]                   options(future.plan = NULL)
[16:12:19.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.247]                 }
[16:12:19.247]                 ...future.workdir <- getwd()
[16:12:19.247]             }
[16:12:19.247]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.247]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.247]         }
[16:12:19.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.247]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.247]             base::names(...future.oldOptions))
[16:12:19.247]     }
[16:12:19.247]     if (FALSE) {
[16:12:19.247]     }
[16:12:19.247]     else {
[16:12:19.247]         if (TRUE) {
[16:12:19.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.247]                 open = "w")
[16:12:19.247]         }
[16:12:19.247]         else {
[16:12:19.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.247]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.247]         }
[16:12:19.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.247]             base::sink(type = "output", split = FALSE)
[16:12:19.247]             base::close(...future.stdout)
[16:12:19.247]         }, add = TRUE)
[16:12:19.247]     }
[16:12:19.247]     ...future.frame <- base::sys.nframe()
[16:12:19.247]     ...future.conditions <- base::list()
[16:12:19.247]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.247]     if (FALSE) {
[16:12:19.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.247]     }
[16:12:19.247]     ...future.result <- base::tryCatch({
[16:12:19.247]         base::withCallingHandlers({
[16:12:19.247]             ...future.value <- base::withVisible(base::local({
[16:12:19.247]                 2
[16:12:19.247]             }))
[16:12:19.247]             future::FutureResult(value = ...future.value$value, 
[16:12:19.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.247]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.247]                     ...future.globalenv.names))
[16:12:19.247]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.247]         }, condition = base::local({
[16:12:19.247]             c <- base::c
[16:12:19.247]             inherits <- base::inherits
[16:12:19.247]             invokeRestart <- base::invokeRestart
[16:12:19.247]             length <- base::length
[16:12:19.247]             list <- base::list
[16:12:19.247]             seq.int <- base::seq.int
[16:12:19.247]             signalCondition <- base::signalCondition
[16:12:19.247]             sys.calls <- base::sys.calls
[16:12:19.247]             `[[` <- base::`[[`
[16:12:19.247]             `+` <- base::`+`
[16:12:19.247]             `<<-` <- base::`<<-`
[16:12:19.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.247]                   3L)]
[16:12:19.247]             }
[16:12:19.247]             function(cond) {
[16:12:19.247]                 is_error <- inherits(cond, "error")
[16:12:19.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.247]                   NULL)
[16:12:19.247]                 if (is_error) {
[16:12:19.247]                   sessionInformation <- function() {
[16:12:19.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.247]                       search = base::search(), system = base::Sys.info())
[16:12:19.247]                   }
[16:12:19.247]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.247]                     cond$call), session = sessionInformation(), 
[16:12:19.247]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.247]                   signalCondition(cond)
[16:12:19.247]                 }
[16:12:19.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.247]                 "immediateCondition"))) {
[16:12:19.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.247]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.247]                   if (TRUE && !signal) {
[16:12:19.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.247]                     {
[16:12:19.247]                       inherits <- base::inherits
[16:12:19.247]                       invokeRestart <- base::invokeRestart
[16:12:19.247]                       is.null <- base::is.null
[16:12:19.247]                       muffled <- FALSE
[16:12:19.247]                       if (inherits(cond, "message")) {
[16:12:19.247]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.247]                         if (muffled) 
[16:12:19.247]                           invokeRestart("muffleMessage")
[16:12:19.247]                       }
[16:12:19.247]                       else if (inherits(cond, "warning")) {
[16:12:19.247]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.247]                         if (muffled) 
[16:12:19.247]                           invokeRestart("muffleWarning")
[16:12:19.247]                       }
[16:12:19.247]                       else if (inherits(cond, "condition")) {
[16:12:19.247]                         if (!is.null(pattern)) {
[16:12:19.247]                           computeRestarts <- base::computeRestarts
[16:12:19.247]                           grepl <- base::grepl
[16:12:19.247]                           restarts <- computeRestarts(cond)
[16:12:19.247]                           for (restart in restarts) {
[16:12:19.247]                             name <- restart$name
[16:12:19.247]                             if (is.null(name)) 
[16:12:19.247]                               next
[16:12:19.247]                             if (!grepl(pattern, name)) 
[16:12:19.247]                               next
[16:12:19.247]                             invokeRestart(restart)
[16:12:19.247]                             muffled <- TRUE
[16:12:19.247]                             break
[16:12:19.247]                           }
[16:12:19.247]                         }
[16:12:19.247]                       }
[16:12:19.247]                       invisible(muffled)
[16:12:19.247]                     }
[16:12:19.247]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.247]                   }
[16:12:19.247]                 }
[16:12:19.247]                 else {
[16:12:19.247]                   if (TRUE) {
[16:12:19.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.247]                     {
[16:12:19.247]                       inherits <- base::inherits
[16:12:19.247]                       invokeRestart <- base::invokeRestart
[16:12:19.247]                       is.null <- base::is.null
[16:12:19.247]                       muffled <- FALSE
[16:12:19.247]                       if (inherits(cond, "message")) {
[16:12:19.247]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.247]                         if (muffled) 
[16:12:19.247]                           invokeRestart("muffleMessage")
[16:12:19.247]                       }
[16:12:19.247]                       else if (inherits(cond, "warning")) {
[16:12:19.247]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.247]                         if (muffled) 
[16:12:19.247]                           invokeRestart("muffleWarning")
[16:12:19.247]                       }
[16:12:19.247]                       else if (inherits(cond, "condition")) {
[16:12:19.247]                         if (!is.null(pattern)) {
[16:12:19.247]                           computeRestarts <- base::computeRestarts
[16:12:19.247]                           grepl <- base::grepl
[16:12:19.247]                           restarts <- computeRestarts(cond)
[16:12:19.247]                           for (restart in restarts) {
[16:12:19.247]                             name <- restart$name
[16:12:19.247]                             if (is.null(name)) 
[16:12:19.247]                               next
[16:12:19.247]                             if (!grepl(pattern, name)) 
[16:12:19.247]                               next
[16:12:19.247]                             invokeRestart(restart)
[16:12:19.247]                             muffled <- TRUE
[16:12:19.247]                             break
[16:12:19.247]                           }
[16:12:19.247]                         }
[16:12:19.247]                       }
[16:12:19.247]                       invisible(muffled)
[16:12:19.247]                     }
[16:12:19.247]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.247]                   }
[16:12:19.247]                 }
[16:12:19.247]             }
[16:12:19.247]         }))
[16:12:19.247]     }, error = function(ex) {
[16:12:19.247]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.247]                 ...future.rng), started = ...future.startTime, 
[16:12:19.247]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.247]             version = "1.8"), class = "FutureResult")
[16:12:19.247]     }, finally = {
[16:12:19.247]         if (!identical(...future.workdir, getwd())) 
[16:12:19.247]             setwd(...future.workdir)
[16:12:19.247]         {
[16:12:19.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.247]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.247]             }
[16:12:19.247]             base::options(...future.oldOptions)
[16:12:19.247]             if (.Platform$OS.type == "windows") {
[16:12:19.247]                 old_names <- names(...future.oldEnvVars)
[16:12:19.247]                 envs <- base::Sys.getenv()
[16:12:19.247]                 names <- names(envs)
[16:12:19.247]                 common <- intersect(names, old_names)
[16:12:19.247]                 added <- setdiff(names, old_names)
[16:12:19.247]                 removed <- setdiff(old_names, names)
[16:12:19.247]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.247]                   envs[common]]
[16:12:19.247]                 NAMES <- toupper(changed)
[16:12:19.247]                 args <- list()
[16:12:19.247]                 for (kk in seq_along(NAMES)) {
[16:12:19.247]                   name <- changed[[kk]]
[16:12:19.247]                   NAME <- NAMES[[kk]]
[16:12:19.247]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.247]                     next
[16:12:19.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.247]                 }
[16:12:19.247]                 NAMES <- toupper(added)
[16:12:19.247]                 for (kk in seq_along(NAMES)) {
[16:12:19.247]                   name <- added[[kk]]
[16:12:19.247]                   NAME <- NAMES[[kk]]
[16:12:19.247]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.247]                     next
[16:12:19.247]                   args[[name]] <- ""
[16:12:19.247]                 }
[16:12:19.247]                 NAMES <- toupper(removed)
[16:12:19.247]                 for (kk in seq_along(NAMES)) {
[16:12:19.247]                   name <- removed[[kk]]
[16:12:19.247]                   NAME <- NAMES[[kk]]
[16:12:19.247]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.247]                     next
[16:12:19.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.247]                 }
[16:12:19.247]                 if (length(args) > 0) 
[16:12:19.247]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.247]             }
[16:12:19.247]             else {
[16:12:19.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.247]             }
[16:12:19.247]             {
[16:12:19.247]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.247]                   0L) {
[16:12:19.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.247]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.247]                   base::options(opts)
[16:12:19.247]                 }
[16:12:19.247]                 {
[16:12:19.247]                   {
[16:12:19.247]                     NULL
[16:12:19.247]                     RNGkind("Mersenne-Twister")
[16:12:19.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.247]                       inherits = FALSE)
[16:12:19.247]                   }
[16:12:19.247]                   options(future.plan = NULL)
[16:12:19.247]                   if (is.na(NA_character_)) 
[16:12:19.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.247]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.247]                   {
[16:12:19.247]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.247]                     if (!future$lazy) 
[16:12:19.247]                       future <- run(future)
[16:12:19.247]                     invisible(future)
[16:12:19.247]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.247]                 }
[16:12:19.247]             }
[16:12:19.247]         }
[16:12:19.247]     })
[16:12:19.247]     if (TRUE) {
[16:12:19.247]         base::sink(type = "output", split = FALSE)
[16:12:19.247]         if (TRUE) {
[16:12:19.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.247]         }
[16:12:19.247]         else {
[16:12:19.247]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.247]         }
[16:12:19.247]         base::close(...future.stdout)
[16:12:19.247]         ...future.stdout <- NULL
[16:12:19.247]     }
[16:12:19.247]     ...future.result$conditions <- ...future.conditions
[16:12:19.247]     ...future.result$finished <- base::Sys.time()
[16:12:19.247]     ...future.result
[16:12:19.247] }
[16:12:19.249] plan(): Setting new future strategy stack:
[16:12:19.249] List of future strategies:
[16:12:19.249] 1. sequential:
[16:12:19.249]    - args: function (..., envir = parent.frame())
[16:12:19.249]    - tweaked: FALSE
[16:12:19.249]    - call: NULL
[16:12:19.250] plan(): nbrOfWorkers() = 1
[16:12:19.250] plan(): Setting new future strategy stack:
[16:12:19.251] List of future strategies:
[16:12:19.251] 1. sequential:
[16:12:19.251]    - args: function (..., envir = parent.frame())
[16:12:19.251]    - tweaked: FALSE
[16:12:19.251]    - call: plan(strategy)
[16:12:19.251] plan(): nbrOfWorkers() = 1
[16:12:19.251] SequentialFuture started (and completed)
[16:12:19.251] - Launch lazy future ... done
[16:12:19.251] run() for ‘SequentialFuture’ ... done
[16:12:19.251] getGlobalsAndPackages() ...
[16:12:19.252] Searching for globals...
[16:12:19.252] - globals found: [1] ‘{’
[16:12:19.252] Searching for globals ... DONE
[16:12:19.252] Resolving globals: FALSE
[16:12:19.253] 
[16:12:19.253] 
[16:12:19.253] getGlobalsAndPackages() ... DONE
[16:12:19.253] run() for ‘Future’ ...
[16:12:19.253] - state: ‘created’
[16:12:19.253] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.254] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.254] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.254]   - Field: ‘label’
[16:12:19.254]   - Field: ‘local’
[16:12:19.254]   - Field: ‘owner’
[16:12:19.254]   - Field: ‘envir’
[16:12:19.254]   - Field: ‘packages’
[16:12:19.254]   - Field: ‘gc’
[16:12:19.254]   - Field: ‘conditions’
[16:12:19.254]   - Field: ‘expr’
[16:12:19.255]   - Field: ‘uuid’
[16:12:19.255]   - Field: ‘seed’
[16:12:19.255]   - Field: ‘version’
[16:12:19.255]   - Field: ‘result’
[16:12:19.255]   - Field: ‘asynchronous’
[16:12:19.255]   - Field: ‘calls’
[16:12:19.255]   - Field: ‘globals’
[16:12:19.255]   - Field: ‘stdout’
[16:12:19.255]   - Field: ‘earlySignal’
[16:12:19.255]   - Field: ‘lazy’
[16:12:19.255]   - Field: ‘state’
[16:12:19.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.256] - Launch lazy future ...
[16:12:19.256] Packages needed by the future expression (n = 0): <none>
[16:12:19.256] Packages needed by future strategies (n = 0): <none>
[16:12:19.256] {
[16:12:19.256]     {
[16:12:19.256]         {
[16:12:19.256]             ...future.startTime <- base::Sys.time()
[16:12:19.256]             {
[16:12:19.256]                 {
[16:12:19.256]                   {
[16:12:19.256]                     base::local({
[16:12:19.256]                       has_future <- base::requireNamespace("future", 
[16:12:19.256]                         quietly = TRUE)
[16:12:19.256]                       if (has_future) {
[16:12:19.256]                         ns <- base::getNamespace("future")
[16:12:19.256]                         version <- ns[[".package"]][["version"]]
[16:12:19.256]                         if (is.null(version)) 
[16:12:19.256]                           version <- utils::packageVersion("future")
[16:12:19.256]                       }
[16:12:19.256]                       else {
[16:12:19.256]                         version <- NULL
[16:12:19.256]                       }
[16:12:19.256]                       if (!has_future || version < "1.8.0") {
[16:12:19.256]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.256]                           "", base::R.version$version.string), 
[16:12:19.256]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.256]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.256]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.256]                             "release", "version")], collapse = " "), 
[16:12:19.256]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.256]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.256]                           info)
[16:12:19.256]                         info <- base::paste(info, collapse = "; ")
[16:12:19.256]                         if (!has_future) {
[16:12:19.256]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.256]                             info)
[16:12:19.256]                         }
[16:12:19.256]                         else {
[16:12:19.256]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.256]                             info, version)
[16:12:19.256]                         }
[16:12:19.256]                         base::stop(msg)
[16:12:19.256]                       }
[16:12:19.256]                     })
[16:12:19.256]                   }
[16:12:19.256]                   options(future.plan = NULL)
[16:12:19.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.256]                 }
[16:12:19.256]                 ...future.workdir <- getwd()
[16:12:19.256]             }
[16:12:19.256]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.256]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.256]         }
[16:12:19.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.256]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.256]             base::names(...future.oldOptions))
[16:12:19.256]     }
[16:12:19.256]     if (FALSE) {
[16:12:19.256]     }
[16:12:19.256]     else {
[16:12:19.256]         if (TRUE) {
[16:12:19.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.256]                 open = "w")
[16:12:19.256]         }
[16:12:19.256]         else {
[16:12:19.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.256]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.256]         }
[16:12:19.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.256]             base::sink(type = "output", split = FALSE)
[16:12:19.256]             base::close(...future.stdout)
[16:12:19.256]         }, add = TRUE)
[16:12:19.256]     }
[16:12:19.256]     ...future.frame <- base::sys.nframe()
[16:12:19.256]     ...future.conditions <- base::list()
[16:12:19.256]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.256]     if (FALSE) {
[16:12:19.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.256]     }
[16:12:19.256]     ...future.result <- base::tryCatch({
[16:12:19.256]         base::withCallingHandlers({
[16:12:19.256]             ...future.value <- base::withVisible(base::local({
[16:12:19.256]                 4
[16:12:19.256]             }))
[16:12:19.256]             future::FutureResult(value = ...future.value$value, 
[16:12:19.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.256]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.256]                     ...future.globalenv.names))
[16:12:19.256]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.256]         }, condition = base::local({
[16:12:19.256]             c <- base::c
[16:12:19.256]             inherits <- base::inherits
[16:12:19.256]             invokeRestart <- base::invokeRestart
[16:12:19.256]             length <- base::length
[16:12:19.256]             list <- base::list
[16:12:19.256]             seq.int <- base::seq.int
[16:12:19.256]             signalCondition <- base::signalCondition
[16:12:19.256]             sys.calls <- base::sys.calls
[16:12:19.256]             `[[` <- base::`[[`
[16:12:19.256]             `+` <- base::`+`
[16:12:19.256]             `<<-` <- base::`<<-`
[16:12:19.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.256]                   3L)]
[16:12:19.256]             }
[16:12:19.256]             function(cond) {
[16:12:19.256]                 is_error <- inherits(cond, "error")
[16:12:19.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.256]                   NULL)
[16:12:19.256]                 if (is_error) {
[16:12:19.256]                   sessionInformation <- function() {
[16:12:19.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.256]                       search = base::search(), system = base::Sys.info())
[16:12:19.256]                   }
[16:12:19.256]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.256]                     cond$call), session = sessionInformation(), 
[16:12:19.256]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.256]                   signalCondition(cond)
[16:12:19.256]                 }
[16:12:19.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.256]                 "immediateCondition"))) {
[16:12:19.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.256]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.256]                   if (TRUE && !signal) {
[16:12:19.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.256]                     {
[16:12:19.256]                       inherits <- base::inherits
[16:12:19.256]                       invokeRestart <- base::invokeRestart
[16:12:19.256]                       is.null <- base::is.null
[16:12:19.256]                       muffled <- FALSE
[16:12:19.256]                       if (inherits(cond, "message")) {
[16:12:19.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.256]                         if (muffled) 
[16:12:19.256]                           invokeRestart("muffleMessage")
[16:12:19.256]                       }
[16:12:19.256]                       else if (inherits(cond, "warning")) {
[16:12:19.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.256]                         if (muffled) 
[16:12:19.256]                           invokeRestart("muffleWarning")
[16:12:19.256]                       }
[16:12:19.256]                       else if (inherits(cond, "condition")) {
[16:12:19.256]                         if (!is.null(pattern)) {
[16:12:19.256]                           computeRestarts <- base::computeRestarts
[16:12:19.256]                           grepl <- base::grepl
[16:12:19.256]                           restarts <- computeRestarts(cond)
[16:12:19.256]                           for (restart in restarts) {
[16:12:19.256]                             name <- restart$name
[16:12:19.256]                             if (is.null(name)) 
[16:12:19.256]                               next
[16:12:19.256]                             if (!grepl(pattern, name)) 
[16:12:19.256]                               next
[16:12:19.256]                             invokeRestart(restart)
[16:12:19.256]                             muffled <- TRUE
[16:12:19.256]                             break
[16:12:19.256]                           }
[16:12:19.256]                         }
[16:12:19.256]                       }
[16:12:19.256]                       invisible(muffled)
[16:12:19.256]                     }
[16:12:19.256]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.256]                   }
[16:12:19.256]                 }
[16:12:19.256]                 else {
[16:12:19.256]                   if (TRUE) {
[16:12:19.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.256]                     {
[16:12:19.256]                       inherits <- base::inherits
[16:12:19.256]                       invokeRestart <- base::invokeRestart
[16:12:19.256]                       is.null <- base::is.null
[16:12:19.256]                       muffled <- FALSE
[16:12:19.256]                       if (inherits(cond, "message")) {
[16:12:19.256]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.256]                         if (muffled) 
[16:12:19.256]                           invokeRestart("muffleMessage")
[16:12:19.256]                       }
[16:12:19.256]                       else if (inherits(cond, "warning")) {
[16:12:19.256]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.256]                         if (muffled) 
[16:12:19.256]                           invokeRestart("muffleWarning")
[16:12:19.256]                       }
[16:12:19.256]                       else if (inherits(cond, "condition")) {
[16:12:19.256]                         if (!is.null(pattern)) {
[16:12:19.256]                           computeRestarts <- base::computeRestarts
[16:12:19.256]                           grepl <- base::grepl
[16:12:19.256]                           restarts <- computeRestarts(cond)
[16:12:19.256]                           for (restart in restarts) {
[16:12:19.256]                             name <- restart$name
[16:12:19.256]                             if (is.null(name)) 
[16:12:19.256]                               next
[16:12:19.256]                             if (!grepl(pattern, name)) 
[16:12:19.256]                               next
[16:12:19.256]                             invokeRestart(restart)
[16:12:19.256]                             muffled <- TRUE
[16:12:19.256]                             break
[16:12:19.256]                           }
[16:12:19.256]                         }
[16:12:19.256]                       }
[16:12:19.256]                       invisible(muffled)
[16:12:19.256]                     }
[16:12:19.256]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.256]                   }
[16:12:19.256]                 }
[16:12:19.256]             }
[16:12:19.256]         }))
[16:12:19.256]     }, error = function(ex) {
[16:12:19.256]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.256]                 ...future.rng), started = ...future.startTime, 
[16:12:19.256]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.256]             version = "1.8"), class = "FutureResult")
[16:12:19.256]     }, finally = {
[16:12:19.256]         if (!identical(...future.workdir, getwd())) 
[16:12:19.256]             setwd(...future.workdir)
[16:12:19.256]         {
[16:12:19.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.256]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.256]             }
[16:12:19.256]             base::options(...future.oldOptions)
[16:12:19.256]             if (.Platform$OS.type == "windows") {
[16:12:19.256]                 old_names <- names(...future.oldEnvVars)
[16:12:19.256]                 envs <- base::Sys.getenv()
[16:12:19.256]                 names <- names(envs)
[16:12:19.256]                 common <- intersect(names, old_names)
[16:12:19.256]                 added <- setdiff(names, old_names)
[16:12:19.256]                 removed <- setdiff(old_names, names)
[16:12:19.256]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.256]                   envs[common]]
[16:12:19.256]                 NAMES <- toupper(changed)
[16:12:19.256]                 args <- list()
[16:12:19.256]                 for (kk in seq_along(NAMES)) {
[16:12:19.256]                   name <- changed[[kk]]
[16:12:19.256]                   NAME <- NAMES[[kk]]
[16:12:19.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.256]                     next
[16:12:19.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.256]                 }
[16:12:19.256]                 NAMES <- toupper(added)
[16:12:19.256]                 for (kk in seq_along(NAMES)) {
[16:12:19.256]                   name <- added[[kk]]
[16:12:19.256]                   NAME <- NAMES[[kk]]
[16:12:19.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.256]                     next
[16:12:19.256]                   args[[name]] <- ""
[16:12:19.256]                 }
[16:12:19.256]                 NAMES <- toupper(removed)
[16:12:19.256]                 for (kk in seq_along(NAMES)) {
[16:12:19.256]                   name <- removed[[kk]]
[16:12:19.256]                   NAME <- NAMES[[kk]]
[16:12:19.256]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.256]                     next
[16:12:19.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.256]                 }
[16:12:19.256]                 if (length(args) > 0) 
[16:12:19.256]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.256]             }
[16:12:19.256]             else {
[16:12:19.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.256]             }
[16:12:19.256]             {
[16:12:19.256]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.256]                   0L) {
[16:12:19.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.256]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.256]                   base::options(opts)
[16:12:19.256]                 }
[16:12:19.256]                 {
[16:12:19.256]                   {
[16:12:19.256]                     NULL
[16:12:19.256]                     RNGkind("Mersenne-Twister")
[16:12:19.256]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.256]                       inherits = FALSE)
[16:12:19.256]                   }
[16:12:19.256]                   options(future.plan = NULL)
[16:12:19.256]                   if (is.na(NA_character_)) 
[16:12:19.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.256]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.256]                   {
[16:12:19.256]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.256]                     if (!future$lazy) 
[16:12:19.256]                       future <- run(future)
[16:12:19.256]                     invisible(future)
[16:12:19.256]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.256]                 }
[16:12:19.256]             }
[16:12:19.256]         }
[16:12:19.256]     })
[16:12:19.256]     if (TRUE) {
[16:12:19.256]         base::sink(type = "output", split = FALSE)
[16:12:19.256]         if (TRUE) {
[16:12:19.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.256]         }
[16:12:19.256]         else {
[16:12:19.256]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.256]         }
[16:12:19.256]         base::close(...future.stdout)
[16:12:19.256]         ...future.stdout <- NULL
[16:12:19.256]     }
[16:12:19.256]     ...future.result$conditions <- ...future.conditions
[16:12:19.256]     ...future.result$finished <- base::Sys.time()
[16:12:19.256]     ...future.result
[16:12:19.256] }
[16:12:19.258] plan(): Setting new future strategy stack:
[16:12:19.258] List of future strategies:
[16:12:19.258] 1. sequential:
[16:12:19.258]    - args: function (..., envir = parent.frame())
[16:12:19.258]    - tweaked: FALSE
[16:12:19.258]    - call: NULL
[16:12:19.259] plan(): nbrOfWorkers() = 1
[16:12:19.259] plan(): Setting new future strategy stack:
[16:12:19.259] List of future strategies:
[16:12:19.259] 1. sequential:
[16:12:19.259]    - args: function (..., envir = parent.frame())
[16:12:19.259]    - tweaked: FALSE
[16:12:19.259]    - call: plan(strategy)
[16:12:19.260] plan(): nbrOfWorkers() = 1
[16:12:19.260] SequentialFuture started (and completed)
[16:12:19.260] - Launch lazy future ... done
[16:12:19.260] run() for ‘SequentialFuture’ ... done
u$a = 2
v$a = 4
[16:12:19.261] getGlobalsAndPackages() ...
[16:12:19.262] Searching for globals...
[16:12:19.263] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.263] Searching for globals ... DONE
[16:12:19.264] Resolving globals: FALSE
[16:12:19.264] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.265] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.265] - globals: [1] ‘a’
[16:12:19.265] 
[16:12:19.265] getGlobalsAndPackages() ... DONE
[16:12:19.265] run() for ‘Future’ ...
[16:12:19.266] - state: ‘created’
[16:12:19.266] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.266] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.266]   - Field: ‘label’
[16:12:19.266]   - Field: ‘local’
[16:12:19.266]   - Field: ‘owner’
[16:12:19.266]   - Field: ‘envir’
[16:12:19.266]   - Field: ‘packages’
[16:12:19.267]   - Field: ‘gc’
[16:12:19.267]   - Field: ‘conditions’
[16:12:19.267]   - Field: ‘expr’
[16:12:19.267]   - Field: ‘uuid’
[16:12:19.267]   - Field: ‘seed’
[16:12:19.267]   - Field: ‘version’
[16:12:19.267]   - Field: ‘result’
[16:12:19.267]   - Field: ‘asynchronous’
[16:12:19.267]   - Field: ‘calls’
[16:12:19.267]   - Field: ‘globals’
[16:12:19.268]   - Field: ‘stdout’
[16:12:19.268]   - Field: ‘earlySignal’
[16:12:19.268]   - Field: ‘lazy’
[16:12:19.268]   - Field: ‘state’
[16:12:19.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.268] - Launch lazy future ...
[16:12:19.268] Packages needed by the future expression (n = 0): <none>
[16:12:19.268] Packages needed by future strategies (n = 0): <none>
[16:12:19.269] {
[16:12:19.269]     {
[16:12:19.269]         {
[16:12:19.269]             ...future.startTime <- base::Sys.time()
[16:12:19.269]             {
[16:12:19.269]                 {
[16:12:19.269]                   {
[16:12:19.269]                     base::local({
[16:12:19.269]                       has_future <- base::requireNamespace("future", 
[16:12:19.269]                         quietly = TRUE)
[16:12:19.269]                       if (has_future) {
[16:12:19.269]                         ns <- base::getNamespace("future")
[16:12:19.269]                         version <- ns[[".package"]][["version"]]
[16:12:19.269]                         if (is.null(version)) 
[16:12:19.269]                           version <- utils::packageVersion("future")
[16:12:19.269]                       }
[16:12:19.269]                       else {
[16:12:19.269]                         version <- NULL
[16:12:19.269]                       }
[16:12:19.269]                       if (!has_future || version < "1.8.0") {
[16:12:19.269]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.269]                           "", base::R.version$version.string), 
[16:12:19.269]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.269]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.269]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.269]                             "release", "version")], collapse = " "), 
[16:12:19.269]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.269]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.269]                           info)
[16:12:19.269]                         info <- base::paste(info, collapse = "; ")
[16:12:19.269]                         if (!has_future) {
[16:12:19.269]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.269]                             info)
[16:12:19.269]                         }
[16:12:19.269]                         else {
[16:12:19.269]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.269]                             info, version)
[16:12:19.269]                         }
[16:12:19.269]                         base::stop(msg)
[16:12:19.269]                       }
[16:12:19.269]                     })
[16:12:19.269]                   }
[16:12:19.269]                   options(future.plan = NULL)
[16:12:19.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.269]                 }
[16:12:19.269]                 ...future.workdir <- getwd()
[16:12:19.269]             }
[16:12:19.269]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.269]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.269]         }
[16:12:19.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.269]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.269]             base::names(...future.oldOptions))
[16:12:19.269]     }
[16:12:19.269]     if (FALSE) {
[16:12:19.269]     }
[16:12:19.269]     else {
[16:12:19.269]         if (TRUE) {
[16:12:19.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.269]                 open = "w")
[16:12:19.269]         }
[16:12:19.269]         else {
[16:12:19.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.269]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.269]         }
[16:12:19.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.269]             base::sink(type = "output", split = FALSE)
[16:12:19.269]             base::close(...future.stdout)
[16:12:19.269]         }, add = TRUE)
[16:12:19.269]     }
[16:12:19.269]     ...future.frame <- base::sys.nframe()
[16:12:19.269]     ...future.conditions <- base::list()
[16:12:19.269]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.269]     if (FALSE) {
[16:12:19.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.269]     }
[16:12:19.269]     ...future.result <- base::tryCatch({
[16:12:19.269]         base::withCallingHandlers({
[16:12:19.269]             ...future.value <- base::withVisible(base::local({
[16:12:19.269]                 2 * a
[16:12:19.269]             }))
[16:12:19.269]             future::FutureResult(value = ...future.value$value, 
[16:12:19.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.269]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.269]                     ...future.globalenv.names))
[16:12:19.269]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.269]         }, condition = base::local({
[16:12:19.269]             c <- base::c
[16:12:19.269]             inherits <- base::inherits
[16:12:19.269]             invokeRestart <- base::invokeRestart
[16:12:19.269]             length <- base::length
[16:12:19.269]             list <- base::list
[16:12:19.269]             seq.int <- base::seq.int
[16:12:19.269]             signalCondition <- base::signalCondition
[16:12:19.269]             sys.calls <- base::sys.calls
[16:12:19.269]             `[[` <- base::`[[`
[16:12:19.269]             `+` <- base::`+`
[16:12:19.269]             `<<-` <- base::`<<-`
[16:12:19.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.269]                   3L)]
[16:12:19.269]             }
[16:12:19.269]             function(cond) {
[16:12:19.269]                 is_error <- inherits(cond, "error")
[16:12:19.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.269]                   NULL)
[16:12:19.269]                 if (is_error) {
[16:12:19.269]                   sessionInformation <- function() {
[16:12:19.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.269]                       search = base::search(), system = base::Sys.info())
[16:12:19.269]                   }
[16:12:19.269]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.269]                     cond$call), session = sessionInformation(), 
[16:12:19.269]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.269]                   signalCondition(cond)
[16:12:19.269]                 }
[16:12:19.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.269]                 "immediateCondition"))) {
[16:12:19.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.269]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.269]                   if (TRUE && !signal) {
[16:12:19.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.269]                     {
[16:12:19.269]                       inherits <- base::inherits
[16:12:19.269]                       invokeRestart <- base::invokeRestart
[16:12:19.269]                       is.null <- base::is.null
[16:12:19.269]                       muffled <- FALSE
[16:12:19.269]                       if (inherits(cond, "message")) {
[16:12:19.269]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.269]                         if (muffled) 
[16:12:19.269]                           invokeRestart("muffleMessage")
[16:12:19.269]                       }
[16:12:19.269]                       else if (inherits(cond, "warning")) {
[16:12:19.269]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.269]                         if (muffled) 
[16:12:19.269]                           invokeRestart("muffleWarning")
[16:12:19.269]                       }
[16:12:19.269]                       else if (inherits(cond, "condition")) {
[16:12:19.269]                         if (!is.null(pattern)) {
[16:12:19.269]                           computeRestarts <- base::computeRestarts
[16:12:19.269]                           grepl <- base::grepl
[16:12:19.269]                           restarts <- computeRestarts(cond)
[16:12:19.269]                           for (restart in restarts) {
[16:12:19.269]                             name <- restart$name
[16:12:19.269]                             if (is.null(name)) 
[16:12:19.269]                               next
[16:12:19.269]                             if (!grepl(pattern, name)) 
[16:12:19.269]                               next
[16:12:19.269]                             invokeRestart(restart)
[16:12:19.269]                             muffled <- TRUE
[16:12:19.269]                             break
[16:12:19.269]                           }
[16:12:19.269]                         }
[16:12:19.269]                       }
[16:12:19.269]                       invisible(muffled)
[16:12:19.269]                     }
[16:12:19.269]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.269]                   }
[16:12:19.269]                 }
[16:12:19.269]                 else {
[16:12:19.269]                   if (TRUE) {
[16:12:19.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.269]                     {
[16:12:19.269]                       inherits <- base::inherits
[16:12:19.269]                       invokeRestart <- base::invokeRestart
[16:12:19.269]                       is.null <- base::is.null
[16:12:19.269]                       muffled <- FALSE
[16:12:19.269]                       if (inherits(cond, "message")) {
[16:12:19.269]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.269]                         if (muffled) 
[16:12:19.269]                           invokeRestart("muffleMessage")
[16:12:19.269]                       }
[16:12:19.269]                       else if (inherits(cond, "warning")) {
[16:12:19.269]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.269]                         if (muffled) 
[16:12:19.269]                           invokeRestart("muffleWarning")
[16:12:19.269]                       }
[16:12:19.269]                       else if (inherits(cond, "condition")) {
[16:12:19.269]                         if (!is.null(pattern)) {
[16:12:19.269]                           computeRestarts <- base::computeRestarts
[16:12:19.269]                           grepl <- base::grepl
[16:12:19.269]                           restarts <- computeRestarts(cond)
[16:12:19.269]                           for (restart in restarts) {
[16:12:19.269]                             name <- restart$name
[16:12:19.269]                             if (is.null(name)) 
[16:12:19.269]                               next
[16:12:19.269]                             if (!grepl(pattern, name)) 
[16:12:19.269]                               next
[16:12:19.269]                             invokeRestart(restart)
[16:12:19.269]                             muffled <- TRUE
[16:12:19.269]                             break
[16:12:19.269]                           }
[16:12:19.269]                         }
[16:12:19.269]                       }
[16:12:19.269]                       invisible(muffled)
[16:12:19.269]                     }
[16:12:19.269]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.269]                   }
[16:12:19.269]                 }
[16:12:19.269]             }
[16:12:19.269]         }))
[16:12:19.269]     }, error = function(ex) {
[16:12:19.269]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.269]                 ...future.rng), started = ...future.startTime, 
[16:12:19.269]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.269]             version = "1.8"), class = "FutureResult")
[16:12:19.269]     }, finally = {
[16:12:19.269]         if (!identical(...future.workdir, getwd())) 
[16:12:19.269]             setwd(...future.workdir)
[16:12:19.269]         {
[16:12:19.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.269]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.269]             }
[16:12:19.269]             base::options(...future.oldOptions)
[16:12:19.269]             if (.Platform$OS.type == "windows") {
[16:12:19.269]                 old_names <- names(...future.oldEnvVars)
[16:12:19.269]                 envs <- base::Sys.getenv()
[16:12:19.269]                 names <- names(envs)
[16:12:19.269]                 common <- intersect(names, old_names)
[16:12:19.269]                 added <- setdiff(names, old_names)
[16:12:19.269]                 removed <- setdiff(old_names, names)
[16:12:19.269]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.269]                   envs[common]]
[16:12:19.269]                 NAMES <- toupper(changed)
[16:12:19.269]                 args <- list()
[16:12:19.269]                 for (kk in seq_along(NAMES)) {
[16:12:19.269]                   name <- changed[[kk]]
[16:12:19.269]                   NAME <- NAMES[[kk]]
[16:12:19.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.269]                     next
[16:12:19.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.269]                 }
[16:12:19.269]                 NAMES <- toupper(added)
[16:12:19.269]                 for (kk in seq_along(NAMES)) {
[16:12:19.269]                   name <- added[[kk]]
[16:12:19.269]                   NAME <- NAMES[[kk]]
[16:12:19.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.269]                     next
[16:12:19.269]                   args[[name]] <- ""
[16:12:19.269]                 }
[16:12:19.269]                 NAMES <- toupper(removed)
[16:12:19.269]                 for (kk in seq_along(NAMES)) {
[16:12:19.269]                   name <- removed[[kk]]
[16:12:19.269]                   NAME <- NAMES[[kk]]
[16:12:19.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.269]                     next
[16:12:19.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.269]                 }
[16:12:19.269]                 if (length(args) > 0) 
[16:12:19.269]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.269]             }
[16:12:19.269]             else {
[16:12:19.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.269]             }
[16:12:19.269]             {
[16:12:19.269]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.269]                   0L) {
[16:12:19.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.269]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.269]                   base::options(opts)
[16:12:19.269]                 }
[16:12:19.269]                 {
[16:12:19.269]                   {
[16:12:19.269]                     NULL
[16:12:19.269]                     RNGkind("Mersenne-Twister")
[16:12:19.269]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.269]                       inherits = FALSE)
[16:12:19.269]                   }
[16:12:19.269]                   options(future.plan = NULL)
[16:12:19.269]                   if (is.na(NA_character_)) 
[16:12:19.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.269]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.269]                   {
[16:12:19.269]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.269]                     if (!future$lazy) 
[16:12:19.269]                       future <- run(future)
[16:12:19.269]                     invisible(future)
[16:12:19.269]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.269]                 }
[16:12:19.269]             }
[16:12:19.269]         }
[16:12:19.269]     })
[16:12:19.269]     if (TRUE) {
[16:12:19.269]         base::sink(type = "output", split = FALSE)
[16:12:19.269]         if (TRUE) {
[16:12:19.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.269]         }
[16:12:19.269]         else {
[16:12:19.269]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.269]         }
[16:12:19.269]         base::close(...future.stdout)
[16:12:19.269]         ...future.stdout <- NULL
[16:12:19.269]     }
[16:12:19.269]     ...future.result$conditions <- ...future.conditions
[16:12:19.269]     ...future.result$finished <- base::Sys.time()
[16:12:19.269]     ...future.result
[16:12:19.269] }
[16:12:19.270] assign_globals() ...
[16:12:19.271] List of 1
[16:12:19.271]  $ a: num 1
[16:12:19.271]  - attr(*, "where")=List of 1
[16:12:19.271]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.271]  - attr(*, "resolved")= logi FALSE
[16:12:19.271]  - attr(*, "total_size")= num 56
[16:12:19.271]  - attr(*, "already-done")= logi TRUE
[16:12:19.276] - copied ‘a’ to environment
[16:12:19.276] assign_globals() ... done
[16:12:19.276] plan(): Setting new future strategy stack:
[16:12:19.276] List of future strategies:
[16:12:19.276] 1. sequential:
[16:12:19.276]    - args: function (..., envir = parent.frame())
[16:12:19.276]    - tweaked: FALSE
[16:12:19.276]    - call: NULL
[16:12:19.277] plan(): nbrOfWorkers() = 1
[16:12:19.277] plan(): Setting new future strategy stack:
[16:12:19.277] List of future strategies:
[16:12:19.277] 1. sequential:
[16:12:19.277]    - args: function (..., envir = parent.frame())
[16:12:19.277]    - tweaked: FALSE
[16:12:19.277]    - call: plan(strategy)
[16:12:19.278] plan(): nbrOfWorkers() = 1
[16:12:19.278] SequentialFuture started (and completed)
[16:12:19.278] - Launch lazy future ... done
[16:12:19.278] run() for ‘SequentialFuture’ ... done
[16:12:19.278] getGlobalsAndPackages() ...
[16:12:19.278] Searching for globals...
[16:12:19.279] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.279] Searching for globals ... DONE
[16:12:19.279] Resolving globals: FALSE
[16:12:19.280] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.280] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.280] - globals: [1] ‘a’
[16:12:19.280] 
[16:12:19.281] getGlobalsAndPackages() ... DONE
[16:12:19.281] run() for ‘Future’ ...
[16:12:19.281] - state: ‘created’
[16:12:19.281] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.281]   - Field: ‘label’
[16:12:19.282]   - Field: ‘local’
[16:12:19.282]   - Field: ‘owner’
[16:12:19.282]   - Field: ‘envir’
[16:12:19.282]   - Field: ‘packages’
[16:12:19.282]   - Field: ‘gc’
[16:12:19.282]   - Field: ‘conditions’
[16:12:19.282]   - Field: ‘expr’
[16:12:19.282]   - Field: ‘uuid’
[16:12:19.282]   - Field: ‘seed’
[16:12:19.282]   - Field: ‘version’
[16:12:19.282]   - Field: ‘result’
[16:12:19.283]   - Field: ‘asynchronous’
[16:12:19.283]   - Field: ‘calls’
[16:12:19.283]   - Field: ‘globals’
[16:12:19.283]   - Field: ‘stdout’
[16:12:19.283]   - Field: ‘earlySignal’
[16:12:19.283]   - Field: ‘lazy’
[16:12:19.283]   - Field: ‘state’
[16:12:19.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.283] - Launch lazy future ...
[16:12:19.283] Packages needed by the future expression (n = 0): <none>
[16:12:19.284] Packages needed by future strategies (n = 0): <none>
[16:12:19.284] {
[16:12:19.284]     {
[16:12:19.284]         {
[16:12:19.284]             ...future.startTime <- base::Sys.time()
[16:12:19.284]             {
[16:12:19.284]                 {
[16:12:19.284]                   {
[16:12:19.284]                     base::local({
[16:12:19.284]                       has_future <- base::requireNamespace("future", 
[16:12:19.284]                         quietly = TRUE)
[16:12:19.284]                       if (has_future) {
[16:12:19.284]                         ns <- base::getNamespace("future")
[16:12:19.284]                         version <- ns[[".package"]][["version"]]
[16:12:19.284]                         if (is.null(version)) 
[16:12:19.284]                           version <- utils::packageVersion("future")
[16:12:19.284]                       }
[16:12:19.284]                       else {
[16:12:19.284]                         version <- NULL
[16:12:19.284]                       }
[16:12:19.284]                       if (!has_future || version < "1.8.0") {
[16:12:19.284]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.284]                           "", base::R.version$version.string), 
[16:12:19.284]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.284]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.284]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.284]                             "release", "version")], collapse = " "), 
[16:12:19.284]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.284]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.284]                           info)
[16:12:19.284]                         info <- base::paste(info, collapse = "; ")
[16:12:19.284]                         if (!has_future) {
[16:12:19.284]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.284]                             info)
[16:12:19.284]                         }
[16:12:19.284]                         else {
[16:12:19.284]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.284]                             info, version)
[16:12:19.284]                         }
[16:12:19.284]                         base::stop(msg)
[16:12:19.284]                       }
[16:12:19.284]                     })
[16:12:19.284]                   }
[16:12:19.284]                   options(future.plan = NULL)
[16:12:19.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.284]                 }
[16:12:19.284]                 ...future.workdir <- getwd()
[16:12:19.284]             }
[16:12:19.284]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.284]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.284]         }
[16:12:19.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.284]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.284]             base::names(...future.oldOptions))
[16:12:19.284]     }
[16:12:19.284]     if (FALSE) {
[16:12:19.284]     }
[16:12:19.284]     else {
[16:12:19.284]         if (TRUE) {
[16:12:19.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.284]                 open = "w")
[16:12:19.284]         }
[16:12:19.284]         else {
[16:12:19.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.284]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.284]         }
[16:12:19.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.284]             base::sink(type = "output", split = FALSE)
[16:12:19.284]             base::close(...future.stdout)
[16:12:19.284]         }, add = TRUE)
[16:12:19.284]     }
[16:12:19.284]     ...future.frame <- base::sys.nframe()
[16:12:19.284]     ...future.conditions <- base::list()
[16:12:19.284]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.284]     if (FALSE) {
[16:12:19.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.284]     }
[16:12:19.284]     ...future.result <- base::tryCatch({
[16:12:19.284]         base::withCallingHandlers({
[16:12:19.284]             ...future.value <- base::withVisible(base::local({
[16:12:19.284]                 2 * a
[16:12:19.284]             }))
[16:12:19.284]             future::FutureResult(value = ...future.value$value, 
[16:12:19.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.284]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.284]                     ...future.globalenv.names))
[16:12:19.284]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.284]         }, condition = base::local({
[16:12:19.284]             c <- base::c
[16:12:19.284]             inherits <- base::inherits
[16:12:19.284]             invokeRestart <- base::invokeRestart
[16:12:19.284]             length <- base::length
[16:12:19.284]             list <- base::list
[16:12:19.284]             seq.int <- base::seq.int
[16:12:19.284]             signalCondition <- base::signalCondition
[16:12:19.284]             sys.calls <- base::sys.calls
[16:12:19.284]             `[[` <- base::`[[`
[16:12:19.284]             `+` <- base::`+`
[16:12:19.284]             `<<-` <- base::`<<-`
[16:12:19.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.284]                   3L)]
[16:12:19.284]             }
[16:12:19.284]             function(cond) {
[16:12:19.284]                 is_error <- inherits(cond, "error")
[16:12:19.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.284]                   NULL)
[16:12:19.284]                 if (is_error) {
[16:12:19.284]                   sessionInformation <- function() {
[16:12:19.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.284]                       search = base::search(), system = base::Sys.info())
[16:12:19.284]                   }
[16:12:19.284]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.284]                     cond$call), session = sessionInformation(), 
[16:12:19.284]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.284]                   signalCondition(cond)
[16:12:19.284]                 }
[16:12:19.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.284]                 "immediateCondition"))) {
[16:12:19.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.284]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.284]                   if (TRUE && !signal) {
[16:12:19.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.284]                     {
[16:12:19.284]                       inherits <- base::inherits
[16:12:19.284]                       invokeRestart <- base::invokeRestart
[16:12:19.284]                       is.null <- base::is.null
[16:12:19.284]                       muffled <- FALSE
[16:12:19.284]                       if (inherits(cond, "message")) {
[16:12:19.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.284]                         if (muffled) 
[16:12:19.284]                           invokeRestart("muffleMessage")
[16:12:19.284]                       }
[16:12:19.284]                       else if (inherits(cond, "warning")) {
[16:12:19.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.284]                         if (muffled) 
[16:12:19.284]                           invokeRestart("muffleWarning")
[16:12:19.284]                       }
[16:12:19.284]                       else if (inherits(cond, "condition")) {
[16:12:19.284]                         if (!is.null(pattern)) {
[16:12:19.284]                           computeRestarts <- base::computeRestarts
[16:12:19.284]                           grepl <- base::grepl
[16:12:19.284]                           restarts <- computeRestarts(cond)
[16:12:19.284]                           for (restart in restarts) {
[16:12:19.284]                             name <- restart$name
[16:12:19.284]                             if (is.null(name)) 
[16:12:19.284]                               next
[16:12:19.284]                             if (!grepl(pattern, name)) 
[16:12:19.284]                               next
[16:12:19.284]                             invokeRestart(restart)
[16:12:19.284]                             muffled <- TRUE
[16:12:19.284]                             break
[16:12:19.284]                           }
[16:12:19.284]                         }
[16:12:19.284]                       }
[16:12:19.284]                       invisible(muffled)
[16:12:19.284]                     }
[16:12:19.284]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.284]                   }
[16:12:19.284]                 }
[16:12:19.284]                 else {
[16:12:19.284]                   if (TRUE) {
[16:12:19.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.284]                     {
[16:12:19.284]                       inherits <- base::inherits
[16:12:19.284]                       invokeRestart <- base::invokeRestart
[16:12:19.284]                       is.null <- base::is.null
[16:12:19.284]                       muffled <- FALSE
[16:12:19.284]                       if (inherits(cond, "message")) {
[16:12:19.284]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.284]                         if (muffled) 
[16:12:19.284]                           invokeRestart("muffleMessage")
[16:12:19.284]                       }
[16:12:19.284]                       else if (inherits(cond, "warning")) {
[16:12:19.284]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.284]                         if (muffled) 
[16:12:19.284]                           invokeRestart("muffleWarning")
[16:12:19.284]                       }
[16:12:19.284]                       else if (inherits(cond, "condition")) {
[16:12:19.284]                         if (!is.null(pattern)) {
[16:12:19.284]                           computeRestarts <- base::computeRestarts
[16:12:19.284]                           grepl <- base::grepl
[16:12:19.284]                           restarts <- computeRestarts(cond)
[16:12:19.284]                           for (restart in restarts) {
[16:12:19.284]                             name <- restart$name
[16:12:19.284]                             if (is.null(name)) 
[16:12:19.284]                               next
[16:12:19.284]                             if (!grepl(pattern, name)) 
[16:12:19.284]                               next
[16:12:19.284]                             invokeRestart(restart)
[16:12:19.284]                             muffled <- TRUE
[16:12:19.284]                             break
[16:12:19.284]                           }
[16:12:19.284]                         }
[16:12:19.284]                       }
[16:12:19.284]                       invisible(muffled)
[16:12:19.284]                     }
[16:12:19.284]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.284]                   }
[16:12:19.284]                 }
[16:12:19.284]             }
[16:12:19.284]         }))
[16:12:19.284]     }, error = function(ex) {
[16:12:19.284]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.284]                 ...future.rng), started = ...future.startTime, 
[16:12:19.284]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.284]             version = "1.8"), class = "FutureResult")
[16:12:19.284]     }, finally = {
[16:12:19.284]         if (!identical(...future.workdir, getwd())) 
[16:12:19.284]             setwd(...future.workdir)
[16:12:19.284]         {
[16:12:19.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.284]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.284]             }
[16:12:19.284]             base::options(...future.oldOptions)
[16:12:19.284]             if (.Platform$OS.type == "windows") {
[16:12:19.284]                 old_names <- names(...future.oldEnvVars)
[16:12:19.284]                 envs <- base::Sys.getenv()
[16:12:19.284]                 names <- names(envs)
[16:12:19.284]                 common <- intersect(names, old_names)
[16:12:19.284]                 added <- setdiff(names, old_names)
[16:12:19.284]                 removed <- setdiff(old_names, names)
[16:12:19.284]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.284]                   envs[common]]
[16:12:19.284]                 NAMES <- toupper(changed)
[16:12:19.284]                 args <- list()
[16:12:19.284]                 for (kk in seq_along(NAMES)) {
[16:12:19.284]                   name <- changed[[kk]]
[16:12:19.284]                   NAME <- NAMES[[kk]]
[16:12:19.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.284]                     next
[16:12:19.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.284]                 }
[16:12:19.284]                 NAMES <- toupper(added)
[16:12:19.284]                 for (kk in seq_along(NAMES)) {
[16:12:19.284]                   name <- added[[kk]]
[16:12:19.284]                   NAME <- NAMES[[kk]]
[16:12:19.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.284]                     next
[16:12:19.284]                   args[[name]] <- ""
[16:12:19.284]                 }
[16:12:19.284]                 NAMES <- toupper(removed)
[16:12:19.284]                 for (kk in seq_along(NAMES)) {
[16:12:19.284]                   name <- removed[[kk]]
[16:12:19.284]                   NAME <- NAMES[[kk]]
[16:12:19.284]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.284]                     next
[16:12:19.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.284]                 }
[16:12:19.284]                 if (length(args) > 0) 
[16:12:19.284]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.284]             }
[16:12:19.284]             else {
[16:12:19.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.284]             }
[16:12:19.284]             {
[16:12:19.284]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.284]                   0L) {
[16:12:19.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.284]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.284]                   base::options(opts)
[16:12:19.284]                 }
[16:12:19.284]                 {
[16:12:19.284]                   {
[16:12:19.284]                     NULL
[16:12:19.284]                     RNGkind("Mersenne-Twister")
[16:12:19.284]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.284]                       inherits = FALSE)
[16:12:19.284]                   }
[16:12:19.284]                   options(future.plan = NULL)
[16:12:19.284]                   if (is.na(NA_character_)) 
[16:12:19.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.284]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.284]                   {
[16:12:19.284]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.284]                     if (!future$lazy) 
[16:12:19.284]                       future <- run(future)
[16:12:19.284]                     invisible(future)
[16:12:19.284]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.284]                 }
[16:12:19.284]             }
[16:12:19.284]         }
[16:12:19.284]     })
[16:12:19.284]     if (TRUE) {
[16:12:19.284]         base::sink(type = "output", split = FALSE)
[16:12:19.284]         if (TRUE) {
[16:12:19.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.284]         }
[16:12:19.284]         else {
[16:12:19.284]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.284]         }
[16:12:19.284]         base::close(...future.stdout)
[16:12:19.284]         ...future.stdout <- NULL
[16:12:19.284]     }
[16:12:19.284]     ...future.result$conditions <- ...future.conditions
[16:12:19.284]     ...future.result$finished <- base::Sys.time()
[16:12:19.284]     ...future.result
[16:12:19.284] }
[16:12:19.286] assign_globals() ...
[16:12:19.286] List of 1
[16:12:19.286]  $ a: num 1
[16:12:19.286]  - attr(*, "where")=List of 1
[16:12:19.286]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.286]  - attr(*, "resolved")= logi FALSE
[16:12:19.286]  - attr(*, "total_size")= num 56
[16:12:19.286]  - attr(*, "already-done")= logi TRUE
[16:12:19.288] - copied ‘a’ to environment
[16:12:19.288] assign_globals() ... done
[16:12:19.288] plan(): Setting new future strategy stack:
[16:12:19.289] List of future strategies:
[16:12:19.289] 1. sequential:
[16:12:19.289]    - args: function (..., envir = parent.frame())
[16:12:19.289]    - tweaked: FALSE
[16:12:19.289]    - call: NULL
[16:12:19.289] plan(): nbrOfWorkers() = 1
[16:12:19.290] plan(): Setting new future strategy stack:
[16:12:19.290] List of future strategies:
[16:12:19.290] 1. sequential:
[16:12:19.290]    - args: function (..., envir = parent.frame())
[16:12:19.290]    - tweaked: FALSE
[16:12:19.290]    - call: plan(strategy)
[16:12:19.290] plan(): nbrOfWorkers() = 1
[16:12:19.290] SequentialFuture started (and completed)
[16:12:19.290] - Launch lazy future ... done
[16:12:19.290] run() for ‘SequentialFuture’ ... done
[16:12:19.291] getGlobalsAndPackages() ...
[16:12:19.291] Searching for globals...
[16:12:19.292] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.292] Searching for globals ... DONE
[16:12:19.292] Resolving globals: FALSE
[16:12:19.292] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.293] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.293] - globals: [1] ‘a’
[16:12:19.293] 
[16:12:19.293] getGlobalsAndPackages() ... DONE
[16:12:19.293] run() for ‘Future’ ...
[16:12:19.293] - state: ‘created’
[16:12:19.293] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.294] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.294]   - Field: ‘label’
[16:12:19.294]   - Field: ‘local’
[16:12:19.294]   - Field: ‘owner’
[16:12:19.294]   - Field: ‘envir’
[16:12:19.294]   - Field: ‘packages’
[16:12:19.294]   - Field: ‘gc’
[16:12:19.296]   - Field: ‘conditions’
[16:12:19.296]   - Field: ‘expr’
[16:12:19.297]   - Field: ‘uuid’
[16:12:19.297]   - Field: ‘seed’
[16:12:19.297]   - Field: ‘version’
[16:12:19.297]   - Field: ‘result’
[16:12:19.297]   - Field: ‘asynchronous’
[16:12:19.297]   - Field: ‘calls’
[16:12:19.297]   - Field: ‘globals’
[16:12:19.297]   - Field: ‘stdout’
[16:12:19.297]   - Field: ‘earlySignal’
[16:12:19.297]   - Field: ‘lazy’
[16:12:19.297]   - Field: ‘state’
[16:12:19.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.298] - Launch lazy future ...
[16:12:19.298] Packages needed by the future expression (n = 0): <none>
[16:12:19.298] Packages needed by future strategies (n = 0): <none>
[16:12:19.298] {
[16:12:19.298]     {
[16:12:19.298]         {
[16:12:19.298]             ...future.startTime <- base::Sys.time()
[16:12:19.298]             {
[16:12:19.298]                 {
[16:12:19.298]                   {
[16:12:19.298]                     base::local({
[16:12:19.298]                       has_future <- base::requireNamespace("future", 
[16:12:19.298]                         quietly = TRUE)
[16:12:19.298]                       if (has_future) {
[16:12:19.298]                         ns <- base::getNamespace("future")
[16:12:19.298]                         version <- ns[[".package"]][["version"]]
[16:12:19.298]                         if (is.null(version)) 
[16:12:19.298]                           version <- utils::packageVersion("future")
[16:12:19.298]                       }
[16:12:19.298]                       else {
[16:12:19.298]                         version <- NULL
[16:12:19.298]                       }
[16:12:19.298]                       if (!has_future || version < "1.8.0") {
[16:12:19.298]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.298]                           "", base::R.version$version.string), 
[16:12:19.298]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.298]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.298]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.298]                             "release", "version")], collapse = " "), 
[16:12:19.298]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.298]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.298]                           info)
[16:12:19.298]                         info <- base::paste(info, collapse = "; ")
[16:12:19.298]                         if (!has_future) {
[16:12:19.298]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.298]                             info)
[16:12:19.298]                         }
[16:12:19.298]                         else {
[16:12:19.298]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.298]                             info, version)
[16:12:19.298]                         }
[16:12:19.298]                         base::stop(msg)
[16:12:19.298]                       }
[16:12:19.298]                     })
[16:12:19.298]                   }
[16:12:19.298]                   options(future.plan = NULL)
[16:12:19.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.298]                 }
[16:12:19.298]                 ...future.workdir <- getwd()
[16:12:19.298]             }
[16:12:19.298]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.298]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.298]         }
[16:12:19.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.298]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.298]             base::names(...future.oldOptions))
[16:12:19.298]     }
[16:12:19.298]     if (FALSE) {
[16:12:19.298]     }
[16:12:19.298]     else {
[16:12:19.298]         if (TRUE) {
[16:12:19.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.298]                 open = "w")
[16:12:19.298]         }
[16:12:19.298]         else {
[16:12:19.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.298]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.298]         }
[16:12:19.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.298]             base::sink(type = "output", split = FALSE)
[16:12:19.298]             base::close(...future.stdout)
[16:12:19.298]         }, add = TRUE)
[16:12:19.298]     }
[16:12:19.298]     ...future.frame <- base::sys.nframe()
[16:12:19.298]     ...future.conditions <- base::list()
[16:12:19.298]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.298]     if (FALSE) {
[16:12:19.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.298]     }
[16:12:19.298]     ...future.result <- base::tryCatch({
[16:12:19.298]         base::withCallingHandlers({
[16:12:19.298]             ...future.value <- base::withVisible(base::local({
[16:12:19.298]                 2 * a
[16:12:19.298]             }))
[16:12:19.298]             future::FutureResult(value = ...future.value$value, 
[16:12:19.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.298]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.298]                     ...future.globalenv.names))
[16:12:19.298]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.298]         }, condition = base::local({
[16:12:19.298]             c <- base::c
[16:12:19.298]             inherits <- base::inherits
[16:12:19.298]             invokeRestart <- base::invokeRestart
[16:12:19.298]             length <- base::length
[16:12:19.298]             list <- base::list
[16:12:19.298]             seq.int <- base::seq.int
[16:12:19.298]             signalCondition <- base::signalCondition
[16:12:19.298]             sys.calls <- base::sys.calls
[16:12:19.298]             `[[` <- base::`[[`
[16:12:19.298]             `+` <- base::`+`
[16:12:19.298]             `<<-` <- base::`<<-`
[16:12:19.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.298]                   3L)]
[16:12:19.298]             }
[16:12:19.298]             function(cond) {
[16:12:19.298]                 is_error <- inherits(cond, "error")
[16:12:19.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.298]                   NULL)
[16:12:19.298]                 if (is_error) {
[16:12:19.298]                   sessionInformation <- function() {
[16:12:19.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.298]                       search = base::search(), system = base::Sys.info())
[16:12:19.298]                   }
[16:12:19.298]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.298]                     cond$call), session = sessionInformation(), 
[16:12:19.298]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.298]                   signalCondition(cond)
[16:12:19.298]                 }
[16:12:19.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.298]                 "immediateCondition"))) {
[16:12:19.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.298]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.298]                   if (TRUE && !signal) {
[16:12:19.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.298]                     {
[16:12:19.298]                       inherits <- base::inherits
[16:12:19.298]                       invokeRestart <- base::invokeRestart
[16:12:19.298]                       is.null <- base::is.null
[16:12:19.298]                       muffled <- FALSE
[16:12:19.298]                       if (inherits(cond, "message")) {
[16:12:19.298]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.298]                         if (muffled) 
[16:12:19.298]                           invokeRestart("muffleMessage")
[16:12:19.298]                       }
[16:12:19.298]                       else if (inherits(cond, "warning")) {
[16:12:19.298]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.298]                         if (muffled) 
[16:12:19.298]                           invokeRestart("muffleWarning")
[16:12:19.298]                       }
[16:12:19.298]                       else if (inherits(cond, "condition")) {
[16:12:19.298]                         if (!is.null(pattern)) {
[16:12:19.298]                           computeRestarts <- base::computeRestarts
[16:12:19.298]                           grepl <- base::grepl
[16:12:19.298]                           restarts <- computeRestarts(cond)
[16:12:19.298]                           for (restart in restarts) {
[16:12:19.298]                             name <- restart$name
[16:12:19.298]                             if (is.null(name)) 
[16:12:19.298]                               next
[16:12:19.298]                             if (!grepl(pattern, name)) 
[16:12:19.298]                               next
[16:12:19.298]                             invokeRestart(restart)
[16:12:19.298]                             muffled <- TRUE
[16:12:19.298]                             break
[16:12:19.298]                           }
[16:12:19.298]                         }
[16:12:19.298]                       }
[16:12:19.298]                       invisible(muffled)
[16:12:19.298]                     }
[16:12:19.298]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.298]                   }
[16:12:19.298]                 }
[16:12:19.298]                 else {
[16:12:19.298]                   if (TRUE) {
[16:12:19.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.298]                     {
[16:12:19.298]                       inherits <- base::inherits
[16:12:19.298]                       invokeRestart <- base::invokeRestart
[16:12:19.298]                       is.null <- base::is.null
[16:12:19.298]                       muffled <- FALSE
[16:12:19.298]                       if (inherits(cond, "message")) {
[16:12:19.298]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.298]                         if (muffled) 
[16:12:19.298]                           invokeRestart("muffleMessage")
[16:12:19.298]                       }
[16:12:19.298]                       else if (inherits(cond, "warning")) {
[16:12:19.298]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.298]                         if (muffled) 
[16:12:19.298]                           invokeRestart("muffleWarning")
[16:12:19.298]                       }
[16:12:19.298]                       else if (inherits(cond, "condition")) {
[16:12:19.298]                         if (!is.null(pattern)) {
[16:12:19.298]                           computeRestarts <- base::computeRestarts
[16:12:19.298]                           grepl <- base::grepl
[16:12:19.298]                           restarts <- computeRestarts(cond)
[16:12:19.298]                           for (restart in restarts) {
[16:12:19.298]                             name <- restart$name
[16:12:19.298]                             if (is.null(name)) 
[16:12:19.298]                               next
[16:12:19.298]                             if (!grepl(pattern, name)) 
[16:12:19.298]                               next
[16:12:19.298]                             invokeRestart(restart)
[16:12:19.298]                             muffled <- TRUE
[16:12:19.298]                             break
[16:12:19.298]                           }
[16:12:19.298]                         }
[16:12:19.298]                       }
[16:12:19.298]                       invisible(muffled)
[16:12:19.298]                     }
[16:12:19.298]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.298]                   }
[16:12:19.298]                 }
[16:12:19.298]             }
[16:12:19.298]         }))
[16:12:19.298]     }, error = function(ex) {
[16:12:19.298]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.298]                 ...future.rng), started = ...future.startTime, 
[16:12:19.298]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.298]             version = "1.8"), class = "FutureResult")
[16:12:19.298]     }, finally = {
[16:12:19.298]         if (!identical(...future.workdir, getwd())) 
[16:12:19.298]             setwd(...future.workdir)
[16:12:19.298]         {
[16:12:19.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.298]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.298]             }
[16:12:19.298]             base::options(...future.oldOptions)
[16:12:19.298]             if (.Platform$OS.type == "windows") {
[16:12:19.298]                 old_names <- names(...future.oldEnvVars)
[16:12:19.298]                 envs <- base::Sys.getenv()
[16:12:19.298]                 names <- names(envs)
[16:12:19.298]                 common <- intersect(names, old_names)
[16:12:19.298]                 added <- setdiff(names, old_names)
[16:12:19.298]                 removed <- setdiff(old_names, names)
[16:12:19.298]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.298]                   envs[common]]
[16:12:19.298]                 NAMES <- toupper(changed)
[16:12:19.298]                 args <- list()
[16:12:19.298]                 for (kk in seq_along(NAMES)) {
[16:12:19.298]                   name <- changed[[kk]]
[16:12:19.298]                   NAME <- NAMES[[kk]]
[16:12:19.298]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.298]                     next
[16:12:19.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.298]                 }
[16:12:19.298]                 NAMES <- toupper(added)
[16:12:19.298]                 for (kk in seq_along(NAMES)) {
[16:12:19.298]                   name <- added[[kk]]
[16:12:19.298]                   NAME <- NAMES[[kk]]
[16:12:19.298]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.298]                     next
[16:12:19.298]                   args[[name]] <- ""
[16:12:19.298]                 }
[16:12:19.298]                 NAMES <- toupper(removed)
[16:12:19.298]                 for (kk in seq_along(NAMES)) {
[16:12:19.298]                   name <- removed[[kk]]
[16:12:19.298]                   NAME <- NAMES[[kk]]
[16:12:19.298]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.298]                     next
[16:12:19.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.298]                 }
[16:12:19.298]                 if (length(args) > 0) 
[16:12:19.298]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.298]             }
[16:12:19.298]             else {
[16:12:19.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.298]             }
[16:12:19.298]             {
[16:12:19.298]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.298]                   0L) {
[16:12:19.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.298]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.298]                   base::options(opts)
[16:12:19.298]                 }
[16:12:19.298]                 {
[16:12:19.298]                   {
[16:12:19.298]                     NULL
[16:12:19.298]                     RNGkind("Mersenne-Twister")
[16:12:19.298]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.298]                       inherits = FALSE)
[16:12:19.298]                   }
[16:12:19.298]                   options(future.plan = NULL)
[16:12:19.298]                   if (is.na(NA_character_)) 
[16:12:19.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.298]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.298]                   {
[16:12:19.298]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.298]                     if (!future$lazy) 
[16:12:19.298]                       future <- run(future)
[16:12:19.298]                     invisible(future)
[16:12:19.298]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.298]                 }
[16:12:19.298]             }
[16:12:19.298]         }
[16:12:19.298]     })
[16:12:19.298]     if (TRUE) {
[16:12:19.298]         base::sink(type = "output", split = FALSE)
[16:12:19.298]         if (TRUE) {
[16:12:19.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.298]         }
[16:12:19.298]         else {
[16:12:19.298]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.298]         }
[16:12:19.298]         base::close(...future.stdout)
[16:12:19.298]         ...future.stdout <- NULL
[16:12:19.298]     }
[16:12:19.298]     ...future.result$conditions <- ...future.conditions
[16:12:19.298]     ...future.result$finished <- base::Sys.time()
[16:12:19.298]     ...future.result
[16:12:19.298] }
[16:12:19.300] assign_globals() ...
[16:12:19.300] List of 1
[16:12:19.300]  $ a: num 1
[16:12:19.300]  - attr(*, "where")=List of 1
[16:12:19.300]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.300]  - attr(*, "resolved")= logi FALSE
[16:12:19.300]  - attr(*, "total_size")= num 56
[16:12:19.300]  - attr(*, "already-done")= logi TRUE
[16:12:19.303] - copied ‘a’ to environment
[16:12:19.303] assign_globals() ... done
[16:12:19.303] plan(): Setting new future strategy stack:
[16:12:19.303] List of future strategies:
[16:12:19.303] 1. sequential:
[16:12:19.303]    - args: function (..., envir = parent.frame())
[16:12:19.303]    - tweaked: FALSE
[16:12:19.303]    - call: NULL
[16:12:19.303] plan(): nbrOfWorkers() = 1
[16:12:19.304] plan(): Setting new future strategy stack:
[16:12:19.304] List of future strategies:
[16:12:19.304] 1. sequential:
[16:12:19.304]    - args: function (..., envir = parent.frame())
[16:12:19.304]    - tweaked: FALSE
[16:12:19.304]    - call: plan(strategy)
[16:12:19.304] plan(): nbrOfWorkers() = 1
[16:12:19.305] SequentialFuture started (and completed)
[16:12:19.305] - Launch lazy future ... done
[16:12:19.305] run() for ‘SequentialFuture’ ... done
[16:12:19.305] getGlobalsAndPackages() ...
[16:12:19.305] Searching for globals...
[16:12:19.306] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.306] Searching for globals ... DONE
[16:12:19.306] Resolving globals: FALSE
[16:12:19.307] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.307] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.307] - globals: [1] ‘a’
[16:12:19.307] 
[16:12:19.307] getGlobalsAndPackages() ... DONE
[16:12:19.307] run() for ‘Future’ ...
[16:12:19.308] - state: ‘created’
[16:12:19.308] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.308] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.308]   - Field: ‘label’
[16:12:19.308]   - Field: ‘local’
[16:12:19.308]   - Field: ‘owner’
[16:12:19.308]   - Field: ‘envir’
[16:12:19.309]   - Field: ‘packages’
[16:12:19.309]   - Field: ‘gc’
[16:12:19.309]   - Field: ‘conditions’
[16:12:19.309]   - Field: ‘expr’
[16:12:19.309]   - Field: ‘uuid’
[16:12:19.309]   - Field: ‘seed’
[16:12:19.309]   - Field: ‘version’
[16:12:19.309]   - Field: ‘result’
[16:12:19.309]   - Field: ‘asynchronous’
[16:12:19.309]   - Field: ‘calls’
[16:12:19.310]   - Field: ‘globals’
[16:12:19.310]   - Field: ‘stdout’
[16:12:19.310]   - Field: ‘earlySignal’
[16:12:19.310]   - Field: ‘lazy’
[16:12:19.310]   - Field: ‘state’
[16:12:19.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.310] - Launch lazy future ...
[16:12:19.310] Packages needed by the future expression (n = 0): <none>
[16:12:19.310] Packages needed by future strategies (n = 0): <none>
[16:12:19.311] {
[16:12:19.311]     {
[16:12:19.311]         {
[16:12:19.311]             ...future.startTime <- base::Sys.time()
[16:12:19.311]             {
[16:12:19.311]                 {
[16:12:19.311]                   {
[16:12:19.311]                     base::local({
[16:12:19.311]                       has_future <- base::requireNamespace("future", 
[16:12:19.311]                         quietly = TRUE)
[16:12:19.311]                       if (has_future) {
[16:12:19.311]                         ns <- base::getNamespace("future")
[16:12:19.311]                         version <- ns[[".package"]][["version"]]
[16:12:19.311]                         if (is.null(version)) 
[16:12:19.311]                           version <- utils::packageVersion("future")
[16:12:19.311]                       }
[16:12:19.311]                       else {
[16:12:19.311]                         version <- NULL
[16:12:19.311]                       }
[16:12:19.311]                       if (!has_future || version < "1.8.0") {
[16:12:19.311]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.311]                           "", base::R.version$version.string), 
[16:12:19.311]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.311]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.311]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.311]                             "release", "version")], collapse = " "), 
[16:12:19.311]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.311]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.311]                           info)
[16:12:19.311]                         info <- base::paste(info, collapse = "; ")
[16:12:19.311]                         if (!has_future) {
[16:12:19.311]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.311]                             info)
[16:12:19.311]                         }
[16:12:19.311]                         else {
[16:12:19.311]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.311]                             info, version)
[16:12:19.311]                         }
[16:12:19.311]                         base::stop(msg)
[16:12:19.311]                       }
[16:12:19.311]                     })
[16:12:19.311]                   }
[16:12:19.311]                   options(future.plan = NULL)
[16:12:19.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.311]                 }
[16:12:19.311]                 ...future.workdir <- getwd()
[16:12:19.311]             }
[16:12:19.311]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.311]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.311]         }
[16:12:19.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.311]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.311]             base::names(...future.oldOptions))
[16:12:19.311]     }
[16:12:19.311]     if (FALSE) {
[16:12:19.311]     }
[16:12:19.311]     else {
[16:12:19.311]         if (TRUE) {
[16:12:19.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.311]                 open = "w")
[16:12:19.311]         }
[16:12:19.311]         else {
[16:12:19.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.311]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.311]         }
[16:12:19.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.311]             base::sink(type = "output", split = FALSE)
[16:12:19.311]             base::close(...future.stdout)
[16:12:19.311]         }, add = TRUE)
[16:12:19.311]     }
[16:12:19.311]     ...future.frame <- base::sys.nframe()
[16:12:19.311]     ...future.conditions <- base::list()
[16:12:19.311]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.311]     if (FALSE) {
[16:12:19.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.311]     }
[16:12:19.311]     ...future.result <- base::tryCatch({
[16:12:19.311]         base::withCallingHandlers({
[16:12:19.311]             ...future.value <- base::withVisible(base::local({
[16:12:19.311]                 2 * a
[16:12:19.311]             }))
[16:12:19.311]             future::FutureResult(value = ...future.value$value, 
[16:12:19.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.311]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.311]                     ...future.globalenv.names))
[16:12:19.311]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.311]         }, condition = base::local({
[16:12:19.311]             c <- base::c
[16:12:19.311]             inherits <- base::inherits
[16:12:19.311]             invokeRestart <- base::invokeRestart
[16:12:19.311]             length <- base::length
[16:12:19.311]             list <- base::list
[16:12:19.311]             seq.int <- base::seq.int
[16:12:19.311]             signalCondition <- base::signalCondition
[16:12:19.311]             sys.calls <- base::sys.calls
[16:12:19.311]             `[[` <- base::`[[`
[16:12:19.311]             `+` <- base::`+`
[16:12:19.311]             `<<-` <- base::`<<-`
[16:12:19.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.311]                   3L)]
[16:12:19.311]             }
[16:12:19.311]             function(cond) {
[16:12:19.311]                 is_error <- inherits(cond, "error")
[16:12:19.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.311]                   NULL)
[16:12:19.311]                 if (is_error) {
[16:12:19.311]                   sessionInformation <- function() {
[16:12:19.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.311]                       search = base::search(), system = base::Sys.info())
[16:12:19.311]                   }
[16:12:19.311]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.311]                     cond$call), session = sessionInformation(), 
[16:12:19.311]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.311]                   signalCondition(cond)
[16:12:19.311]                 }
[16:12:19.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.311]                 "immediateCondition"))) {
[16:12:19.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.311]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.311]                   if (TRUE && !signal) {
[16:12:19.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.311]                     {
[16:12:19.311]                       inherits <- base::inherits
[16:12:19.311]                       invokeRestart <- base::invokeRestart
[16:12:19.311]                       is.null <- base::is.null
[16:12:19.311]                       muffled <- FALSE
[16:12:19.311]                       if (inherits(cond, "message")) {
[16:12:19.311]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.311]                         if (muffled) 
[16:12:19.311]                           invokeRestart("muffleMessage")
[16:12:19.311]                       }
[16:12:19.311]                       else if (inherits(cond, "warning")) {
[16:12:19.311]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.311]                         if (muffled) 
[16:12:19.311]                           invokeRestart("muffleWarning")
[16:12:19.311]                       }
[16:12:19.311]                       else if (inherits(cond, "condition")) {
[16:12:19.311]                         if (!is.null(pattern)) {
[16:12:19.311]                           computeRestarts <- base::computeRestarts
[16:12:19.311]                           grepl <- base::grepl
[16:12:19.311]                           restarts <- computeRestarts(cond)
[16:12:19.311]                           for (restart in restarts) {
[16:12:19.311]                             name <- restart$name
[16:12:19.311]                             if (is.null(name)) 
[16:12:19.311]                               next
[16:12:19.311]                             if (!grepl(pattern, name)) 
[16:12:19.311]                               next
[16:12:19.311]                             invokeRestart(restart)
[16:12:19.311]                             muffled <- TRUE
[16:12:19.311]                             break
[16:12:19.311]                           }
[16:12:19.311]                         }
[16:12:19.311]                       }
[16:12:19.311]                       invisible(muffled)
[16:12:19.311]                     }
[16:12:19.311]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.311]                   }
[16:12:19.311]                 }
[16:12:19.311]                 else {
[16:12:19.311]                   if (TRUE) {
[16:12:19.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.311]                     {
[16:12:19.311]                       inherits <- base::inherits
[16:12:19.311]                       invokeRestart <- base::invokeRestart
[16:12:19.311]                       is.null <- base::is.null
[16:12:19.311]                       muffled <- FALSE
[16:12:19.311]                       if (inherits(cond, "message")) {
[16:12:19.311]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.311]                         if (muffled) 
[16:12:19.311]                           invokeRestart("muffleMessage")
[16:12:19.311]                       }
[16:12:19.311]                       else if (inherits(cond, "warning")) {
[16:12:19.311]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.311]                         if (muffled) 
[16:12:19.311]                           invokeRestart("muffleWarning")
[16:12:19.311]                       }
[16:12:19.311]                       else if (inherits(cond, "condition")) {
[16:12:19.311]                         if (!is.null(pattern)) {
[16:12:19.311]                           computeRestarts <- base::computeRestarts
[16:12:19.311]                           grepl <- base::grepl
[16:12:19.311]                           restarts <- computeRestarts(cond)
[16:12:19.311]                           for (restart in restarts) {
[16:12:19.311]                             name <- restart$name
[16:12:19.311]                             if (is.null(name)) 
[16:12:19.311]                               next
[16:12:19.311]                             if (!grepl(pattern, name)) 
[16:12:19.311]                               next
[16:12:19.311]                             invokeRestart(restart)
[16:12:19.311]                             muffled <- TRUE
[16:12:19.311]                             break
[16:12:19.311]                           }
[16:12:19.311]                         }
[16:12:19.311]                       }
[16:12:19.311]                       invisible(muffled)
[16:12:19.311]                     }
[16:12:19.311]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.311]                   }
[16:12:19.311]                 }
[16:12:19.311]             }
[16:12:19.311]         }))
[16:12:19.311]     }, error = function(ex) {
[16:12:19.311]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.311]                 ...future.rng), started = ...future.startTime, 
[16:12:19.311]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.311]             version = "1.8"), class = "FutureResult")
[16:12:19.311]     }, finally = {
[16:12:19.311]         if (!identical(...future.workdir, getwd())) 
[16:12:19.311]             setwd(...future.workdir)
[16:12:19.311]         {
[16:12:19.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.311]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.311]             }
[16:12:19.311]             base::options(...future.oldOptions)
[16:12:19.311]             if (.Platform$OS.type == "windows") {
[16:12:19.311]                 old_names <- names(...future.oldEnvVars)
[16:12:19.311]                 envs <- base::Sys.getenv()
[16:12:19.311]                 names <- names(envs)
[16:12:19.311]                 common <- intersect(names, old_names)
[16:12:19.311]                 added <- setdiff(names, old_names)
[16:12:19.311]                 removed <- setdiff(old_names, names)
[16:12:19.311]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.311]                   envs[common]]
[16:12:19.311]                 NAMES <- toupper(changed)
[16:12:19.311]                 args <- list()
[16:12:19.311]                 for (kk in seq_along(NAMES)) {
[16:12:19.311]                   name <- changed[[kk]]
[16:12:19.311]                   NAME <- NAMES[[kk]]
[16:12:19.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.311]                     next
[16:12:19.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.311]                 }
[16:12:19.311]                 NAMES <- toupper(added)
[16:12:19.311]                 for (kk in seq_along(NAMES)) {
[16:12:19.311]                   name <- added[[kk]]
[16:12:19.311]                   NAME <- NAMES[[kk]]
[16:12:19.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.311]                     next
[16:12:19.311]                   args[[name]] <- ""
[16:12:19.311]                 }
[16:12:19.311]                 NAMES <- toupper(removed)
[16:12:19.311]                 for (kk in seq_along(NAMES)) {
[16:12:19.311]                   name <- removed[[kk]]
[16:12:19.311]                   NAME <- NAMES[[kk]]
[16:12:19.311]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.311]                     next
[16:12:19.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.311]                 }
[16:12:19.311]                 if (length(args) > 0) 
[16:12:19.311]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.311]             }
[16:12:19.311]             else {
[16:12:19.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.311]             }
[16:12:19.311]             {
[16:12:19.311]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.311]                   0L) {
[16:12:19.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.311]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.311]                   base::options(opts)
[16:12:19.311]                 }
[16:12:19.311]                 {
[16:12:19.311]                   {
[16:12:19.311]                     NULL
[16:12:19.311]                     RNGkind("Mersenne-Twister")
[16:12:19.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.311]                       inherits = FALSE)
[16:12:19.311]                   }
[16:12:19.311]                   options(future.plan = NULL)
[16:12:19.311]                   if (is.na(NA_character_)) 
[16:12:19.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.311]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.311]                   {
[16:12:19.311]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.311]                     if (!future$lazy) 
[16:12:19.311]                       future <- run(future)
[16:12:19.311]                     invisible(future)
[16:12:19.311]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.311]                 }
[16:12:19.311]             }
[16:12:19.311]         }
[16:12:19.311]     })
[16:12:19.311]     if (TRUE) {
[16:12:19.311]         base::sink(type = "output", split = FALSE)
[16:12:19.311]         if (TRUE) {
[16:12:19.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.311]         }
[16:12:19.311]         else {
[16:12:19.311]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.311]         }
[16:12:19.311]         base::close(...future.stdout)
[16:12:19.311]         ...future.stdout <- NULL
[16:12:19.311]     }
[16:12:19.311]     ...future.result$conditions <- ...future.conditions
[16:12:19.311]     ...future.result$finished <- base::Sys.time()
[16:12:19.311]     ...future.result
[16:12:19.311] }
[16:12:19.312] assign_globals() ...
[16:12:19.313] List of 1
[16:12:19.313]  $ a: num 1
[16:12:19.313]  - attr(*, "where")=List of 1
[16:12:19.313]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.313]  - attr(*, "resolved")= logi FALSE
[16:12:19.313]  - attr(*, "total_size")= num 56
[16:12:19.313]  - attr(*, "already-done")= logi TRUE
[16:12:19.315] - copied ‘a’ to environment
[16:12:19.315] assign_globals() ... done
[16:12:19.315] plan(): Setting new future strategy stack:
[16:12:19.315] List of future strategies:
[16:12:19.315] 1. sequential:
[16:12:19.315]    - args: function (..., envir = parent.frame())
[16:12:19.315]    - tweaked: FALSE
[16:12:19.315]    - call: NULL
[16:12:19.316] plan(): nbrOfWorkers() = 1
[16:12:19.316] plan(): Setting new future strategy stack:
[16:12:19.317] List of future strategies:
[16:12:19.317] 1. sequential:
[16:12:19.317]    - args: function (..., envir = parent.frame())
[16:12:19.317]    - tweaked: FALSE
[16:12:19.317]    - call: plan(strategy)
[16:12:19.317] plan(): nbrOfWorkers() = 1
[16:12:19.317] SequentialFuture started (and completed)
[16:12:19.317] - Launch lazy future ... done
[16:12:19.317] run() for ‘SequentialFuture’ ... done
[16:12:19.318] getGlobalsAndPackages() ...
[16:12:19.318] Searching for globals...
[16:12:19.318] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.319] Searching for globals ... DONE
[16:12:19.319] Resolving globals: FALSE
[16:12:19.319] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.319] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.319] - globals: [1] ‘a’
[16:12:19.320] 
[16:12:19.320] getGlobalsAndPackages() ... DONE
[16:12:19.320] run() for ‘Future’ ...
[16:12:19.320] - state: ‘created’
[16:12:19.320] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:19.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:19.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:19.321]   - Field: ‘label’
[16:12:19.321]   - Field: ‘local’
[16:12:19.321]   - Field: ‘owner’
[16:12:19.321]   - Field: ‘envir’
[16:12:19.321]   - Field: ‘packages’
[16:12:19.321]   - Field: ‘gc’
[16:12:19.321]   - Field: ‘conditions’
[16:12:19.321]   - Field: ‘expr’
[16:12:19.321]   - Field: ‘uuid’
[16:12:19.321]   - Field: ‘seed’
[16:12:19.322]   - Field: ‘version’
[16:12:19.322]   - Field: ‘result’
[16:12:19.322]   - Field: ‘asynchronous’
[16:12:19.322]   - Field: ‘calls’
[16:12:19.322]   - Field: ‘globals’
[16:12:19.322]   - Field: ‘stdout’
[16:12:19.322]   - Field: ‘earlySignal’
[16:12:19.322]   - Field: ‘lazy’
[16:12:19.322]   - Field: ‘state’
[16:12:19.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:19.322] - Launch lazy future ...
[16:12:19.323] Packages needed by the future expression (n = 0): <none>
[16:12:19.323] Packages needed by future strategies (n = 0): <none>
[16:12:19.323] {
[16:12:19.323]     {
[16:12:19.323]         {
[16:12:19.323]             ...future.startTime <- base::Sys.time()
[16:12:19.323]             {
[16:12:19.323]                 {
[16:12:19.323]                   {
[16:12:19.323]                     base::local({
[16:12:19.323]                       has_future <- base::requireNamespace("future", 
[16:12:19.323]                         quietly = TRUE)
[16:12:19.323]                       if (has_future) {
[16:12:19.323]                         ns <- base::getNamespace("future")
[16:12:19.323]                         version <- ns[[".package"]][["version"]]
[16:12:19.323]                         if (is.null(version)) 
[16:12:19.323]                           version <- utils::packageVersion("future")
[16:12:19.323]                       }
[16:12:19.323]                       else {
[16:12:19.323]                         version <- NULL
[16:12:19.323]                       }
[16:12:19.323]                       if (!has_future || version < "1.8.0") {
[16:12:19.323]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.323]                           "", base::R.version$version.string), 
[16:12:19.323]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:19.323]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.323]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.323]                             "release", "version")], collapse = " "), 
[16:12:19.323]                           hostname = base::Sys.info()[["nodename"]])
[16:12:19.323]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.323]                           info)
[16:12:19.323]                         info <- base::paste(info, collapse = "; ")
[16:12:19.323]                         if (!has_future) {
[16:12:19.323]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.323]                             info)
[16:12:19.323]                         }
[16:12:19.323]                         else {
[16:12:19.323]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.323]                             info, version)
[16:12:19.323]                         }
[16:12:19.323]                         base::stop(msg)
[16:12:19.323]                       }
[16:12:19.323]                     })
[16:12:19.323]                   }
[16:12:19.323]                   options(future.plan = NULL)
[16:12:19.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.323]                 }
[16:12:19.323]                 ...future.workdir <- getwd()
[16:12:19.323]             }
[16:12:19.323]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.323]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.323]         }
[16:12:19.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.323]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.323]             base::names(...future.oldOptions))
[16:12:19.323]     }
[16:12:19.323]     if (FALSE) {
[16:12:19.323]     }
[16:12:19.323]     else {
[16:12:19.323]         if (TRUE) {
[16:12:19.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.323]                 open = "w")
[16:12:19.323]         }
[16:12:19.323]         else {
[16:12:19.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.323]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.323]         }
[16:12:19.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.323]             base::sink(type = "output", split = FALSE)
[16:12:19.323]             base::close(...future.stdout)
[16:12:19.323]         }, add = TRUE)
[16:12:19.323]     }
[16:12:19.323]     ...future.frame <- base::sys.nframe()
[16:12:19.323]     ...future.conditions <- base::list()
[16:12:19.323]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.323]     if (FALSE) {
[16:12:19.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.323]     }
[16:12:19.323]     ...future.result <- base::tryCatch({
[16:12:19.323]         base::withCallingHandlers({
[16:12:19.323]             ...future.value <- base::withVisible(base::local({
[16:12:19.323]                 2 * a
[16:12:19.323]             }))
[16:12:19.323]             future::FutureResult(value = ...future.value$value, 
[16:12:19.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.323]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.323]                     ...future.globalenv.names))
[16:12:19.323]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.323]         }, condition = base::local({
[16:12:19.323]             c <- base::c
[16:12:19.323]             inherits <- base::inherits
[16:12:19.323]             invokeRestart <- base::invokeRestart
[16:12:19.323]             length <- base::length
[16:12:19.323]             list <- base::list
[16:12:19.323]             seq.int <- base::seq.int
[16:12:19.323]             signalCondition <- base::signalCondition
[16:12:19.323]             sys.calls <- base::sys.calls
[16:12:19.323]             `[[` <- base::`[[`
[16:12:19.323]             `+` <- base::`+`
[16:12:19.323]             `<<-` <- base::`<<-`
[16:12:19.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.323]                   3L)]
[16:12:19.323]             }
[16:12:19.323]             function(cond) {
[16:12:19.323]                 is_error <- inherits(cond, "error")
[16:12:19.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.323]                   NULL)
[16:12:19.323]                 if (is_error) {
[16:12:19.323]                   sessionInformation <- function() {
[16:12:19.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.323]                       search = base::search(), system = base::Sys.info())
[16:12:19.323]                   }
[16:12:19.323]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.323]                     cond$call), session = sessionInformation(), 
[16:12:19.323]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.323]                   signalCondition(cond)
[16:12:19.323]                 }
[16:12:19.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.323]                 "immediateCondition"))) {
[16:12:19.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.323]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.323]                   if (TRUE && !signal) {
[16:12:19.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.323]                     {
[16:12:19.323]                       inherits <- base::inherits
[16:12:19.323]                       invokeRestart <- base::invokeRestart
[16:12:19.323]                       is.null <- base::is.null
[16:12:19.323]                       muffled <- FALSE
[16:12:19.323]                       if (inherits(cond, "message")) {
[16:12:19.323]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.323]                         if (muffled) 
[16:12:19.323]                           invokeRestart("muffleMessage")
[16:12:19.323]                       }
[16:12:19.323]                       else if (inherits(cond, "warning")) {
[16:12:19.323]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.323]                         if (muffled) 
[16:12:19.323]                           invokeRestart("muffleWarning")
[16:12:19.323]                       }
[16:12:19.323]                       else if (inherits(cond, "condition")) {
[16:12:19.323]                         if (!is.null(pattern)) {
[16:12:19.323]                           computeRestarts <- base::computeRestarts
[16:12:19.323]                           grepl <- base::grepl
[16:12:19.323]                           restarts <- computeRestarts(cond)
[16:12:19.323]                           for (restart in restarts) {
[16:12:19.323]                             name <- restart$name
[16:12:19.323]                             if (is.null(name)) 
[16:12:19.323]                               next
[16:12:19.323]                             if (!grepl(pattern, name)) 
[16:12:19.323]                               next
[16:12:19.323]                             invokeRestart(restart)
[16:12:19.323]                             muffled <- TRUE
[16:12:19.323]                             break
[16:12:19.323]                           }
[16:12:19.323]                         }
[16:12:19.323]                       }
[16:12:19.323]                       invisible(muffled)
[16:12:19.323]                     }
[16:12:19.323]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.323]                   }
[16:12:19.323]                 }
[16:12:19.323]                 else {
[16:12:19.323]                   if (TRUE) {
[16:12:19.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.323]                     {
[16:12:19.323]                       inherits <- base::inherits
[16:12:19.323]                       invokeRestart <- base::invokeRestart
[16:12:19.323]                       is.null <- base::is.null
[16:12:19.323]                       muffled <- FALSE
[16:12:19.323]                       if (inherits(cond, "message")) {
[16:12:19.323]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.323]                         if (muffled) 
[16:12:19.323]                           invokeRestart("muffleMessage")
[16:12:19.323]                       }
[16:12:19.323]                       else if (inherits(cond, "warning")) {
[16:12:19.323]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.323]                         if (muffled) 
[16:12:19.323]                           invokeRestart("muffleWarning")
[16:12:19.323]                       }
[16:12:19.323]                       else if (inherits(cond, "condition")) {
[16:12:19.323]                         if (!is.null(pattern)) {
[16:12:19.323]                           computeRestarts <- base::computeRestarts
[16:12:19.323]                           grepl <- base::grepl
[16:12:19.323]                           restarts <- computeRestarts(cond)
[16:12:19.323]                           for (restart in restarts) {
[16:12:19.323]                             name <- restart$name
[16:12:19.323]                             if (is.null(name)) 
[16:12:19.323]                               next
[16:12:19.323]                             if (!grepl(pattern, name)) 
[16:12:19.323]                               next
[16:12:19.323]                             invokeRestart(restart)
[16:12:19.323]                             muffled <- TRUE
[16:12:19.323]                             break
[16:12:19.323]                           }
[16:12:19.323]                         }
[16:12:19.323]                       }
[16:12:19.323]                       invisible(muffled)
[16:12:19.323]                     }
[16:12:19.323]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.323]                   }
[16:12:19.323]                 }
[16:12:19.323]             }
[16:12:19.323]         }))
[16:12:19.323]     }, error = function(ex) {
[16:12:19.323]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.323]                 ...future.rng), started = ...future.startTime, 
[16:12:19.323]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.323]             version = "1.8"), class = "FutureResult")
[16:12:19.323]     }, finally = {
[16:12:19.323]         if (!identical(...future.workdir, getwd())) 
[16:12:19.323]             setwd(...future.workdir)
[16:12:19.323]         {
[16:12:19.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.323]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.323]             }
[16:12:19.323]             base::options(...future.oldOptions)
[16:12:19.323]             if (.Platform$OS.type == "windows") {
[16:12:19.323]                 old_names <- names(...future.oldEnvVars)
[16:12:19.323]                 envs <- base::Sys.getenv()
[16:12:19.323]                 names <- names(envs)
[16:12:19.323]                 common <- intersect(names, old_names)
[16:12:19.323]                 added <- setdiff(names, old_names)
[16:12:19.323]                 removed <- setdiff(old_names, names)
[16:12:19.323]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.323]                   envs[common]]
[16:12:19.323]                 NAMES <- toupper(changed)
[16:12:19.323]                 args <- list()
[16:12:19.323]                 for (kk in seq_along(NAMES)) {
[16:12:19.323]                   name <- changed[[kk]]
[16:12:19.323]                   NAME <- NAMES[[kk]]
[16:12:19.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.323]                     next
[16:12:19.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.323]                 }
[16:12:19.323]                 NAMES <- toupper(added)
[16:12:19.323]                 for (kk in seq_along(NAMES)) {
[16:12:19.323]                   name <- added[[kk]]
[16:12:19.323]                   NAME <- NAMES[[kk]]
[16:12:19.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.323]                     next
[16:12:19.323]                   args[[name]] <- ""
[16:12:19.323]                 }
[16:12:19.323]                 NAMES <- toupper(removed)
[16:12:19.323]                 for (kk in seq_along(NAMES)) {
[16:12:19.323]                   name <- removed[[kk]]
[16:12:19.323]                   NAME <- NAMES[[kk]]
[16:12:19.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.323]                     next
[16:12:19.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.323]                 }
[16:12:19.323]                 if (length(args) > 0) 
[16:12:19.323]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.323]             }
[16:12:19.323]             else {
[16:12:19.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.323]             }
[16:12:19.323]             {
[16:12:19.323]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.323]                   0L) {
[16:12:19.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.323]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.323]                   base::options(opts)
[16:12:19.323]                 }
[16:12:19.323]                 {
[16:12:19.323]                   {
[16:12:19.323]                     NULL
[16:12:19.323]                     RNGkind("Mersenne-Twister")
[16:12:19.323]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:19.323]                       inherits = FALSE)
[16:12:19.323]                   }
[16:12:19.323]                   options(future.plan = NULL)
[16:12:19.323]                   if (is.na(NA_character_)) 
[16:12:19.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.323]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:19.323]                   {
[16:12:19.323]                     future <- SequentialFuture(..., envir = envir)
[16:12:19.323]                     if (!future$lazy) 
[16:12:19.323]                       future <- run(future)
[16:12:19.323]                     invisible(future)
[16:12:19.323]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.323]                 }
[16:12:19.323]             }
[16:12:19.323]         }
[16:12:19.323]     })
[16:12:19.323]     if (TRUE) {
[16:12:19.323]         base::sink(type = "output", split = FALSE)
[16:12:19.323]         if (TRUE) {
[16:12:19.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.323]         }
[16:12:19.323]         else {
[16:12:19.323]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.323]         }
[16:12:19.323]         base::close(...future.stdout)
[16:12:19.323]         ...future.stdout <- NULL
[16:12:19.323]     }
[16:12:19.323]     ...future.result$conditions <- ...future.conditions
[16:12:19.323]     ...future.result$finished <- base::Sys.time()
[16:12:19.323]     ...future.result
[16:12:19.323] }
[16:12:19.325] assign_globals() ...
[16:12:19.325] List of 1
[16:12:19.325]  $ a: num 1
[16:12:19.325]  - attr(*, "where")=List of 1
[16:12:19.325]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.325]  - attr(*, "resolved")= logi FALSE
[16:12:19.325]  - attr(*, "total_size")= num 56
[16:12:19.325]  - attr(*, "already-done")= logi TRUE
[16:12:19.329] - copied ‘a’ to environment
[16:12:19.329] assign_globals() ... done
[16:12:19.330] plan(): Setting new future strategy stack:
[16:12:19.330] List of future strategies:
[16:12:19.330] 1. sequential:
[16:12:19.330]    - args: function (..., envir = parent.frame())
[16:12:19.330]    - tweaked: FALSE
[16:12:19.330]    - call: NULL
[16:12:19.330] plan(): nbrOfWorkers() = 1
[16:12:19.331] plan(): Setting new future strategy stack:
[16:12:19.331] List of future strategies:
[16:12:19.331] 1. sequential:
[16:12:19.331]    - args: function (..., envir = parent.frame())
[16:12:19.331]    - tweaked: FALSE
[16:12:19.331]    - call: plan(strategy)
[16:12:19.331] plan(): nbrOfWorkers() = 1
[16:12:19.331] SequentialFuture started (and completed)
[16:12:19.332] - Launch lazy future ... done
[16:12:19.332] run() for ‘SequentialFuture’ ... done
*** futureAssign() with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** futureAssign() with ‘multicore’ futures ...
[16:12:19.338] plan(): Setting new future strategy stack:
[16:12:19.338] List of future strategies:
[16:12:19.338] 1. multicore:
[16:12:19.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.338]    - tweaked: FALSE
[16:12:19.338]    - call: plan(strategy)
[16:12:19.342] plan(): nbrOfWorkers() = 2
[16:12:19.342] getGlobalsAndPackages() ...
[16:12:19.342] Searching for globals...
[16:12:19.343] - globals found: [1] ‘{’
[16:12:19.343] Searching for globals ... DONE
[16:12:19.343] Resolving globals: FALSE
[16:12:19.343] 
[16:12:19.344] 
[16:12:19.344] getGlobalsAndPackages() ... DONE
[16:12:19.344] run() for ‘Future’ ...
[16:12:19.344] - state: ‘created’
[16:12:19.344] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.348] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.348]   - Field: ‘label’
[16:12:19.348]   - Field: ‘local’
[16:12:19.348]   - Field: ‘owner’
[16:12:19.348]   - Field: ‘envir’
[16:12:19.348]   - Field: ‘workers’
[16:12:19.349]   - Field: ‘packages’
[16:12:19.349]   - Field: ‘gc’
[16:12:19.349]   - Field: ‘job’
[16:12:19.349]   - Field: ‘conditions’
[16:12:19.349]   - Field: ‘expr’
[16:12:19.349]   - Field: ‘uuid’
[16:12:19.349]   - Field: ‘seed’
[16:12:19.349]   - Field: ‘version’
[16:12:19.349]   - Field: ‘result’
[16:12:19.349]   - Field: ‘asynchronous’
[16:12:19.349]   - Field: ‘calls’
[16:12:19.350]   - Field: ‘globals’
[16:12:19.350]   - Field: ‘stdout’
[16:12:19.350]   - Field: ‘earlySignal’
[16:12:19.350]   - Field: ‘lazy’
[16:12:19.350]   - Field: ‘state’
[16:12:19.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.350] - Launch lazy future ...
[16:12:19.351] Packages needed by the future expression (n = 0): <none>
[16:12:19.351] Packages needed by future strategies (n = 0): <none>
[16:12:19.352] {
[16:12:19.352]     {
[16:12:19.352]         {
[16:12:19.352]             ...future.startTime <- base::Sys.time()
[16:12:19.352]             {
[16:12:19.352]                 {
[16:12:19.352]                   {
[16:12:19.352]                     {
[16:12:19.352]                       base::local({
[16:12:19.352]                         has_future <- base::requireNamespace("future", 
[16:12:19.352]                           quietly = TRUE)
[16:12:19.352]                         if (has_future) {
[16:12:19.352]                           ns <- base::getNamespace("future")
[16:12:19.352]                           version <- ns[[".package"]][["version"]]
[16:12:19.352]                           if (is.null(version)) 
[16:12:19.352]                             version <- utils::packageVersion("future")
[16:12:19.352]                         }
[16:12:19.352]                         else {
[16:12:19.352]                           version <- NULL
[16:12:19.352]                         }
[16:12:19.352]                         if (!has_future || version < "1.8.0") {
[16:12:19.352]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.352]                             "", base::R.version$version.string), 
[16:12:19.352]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.352]                               "release", "version")], collapse = " "), 
[16:12:19.352]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.352]                             info)
[16:12:19.352]                           info <- base::paste(info, collapse = "; ")
[16:12:19.352]                           if (!has_future) {
[16:12:19.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.352]                               info)
[16:12:19.352]                           }
[16:12:19.352]                           else {
[16:12:19.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.352]                               info, version)
[16:12:19.352]                           }
[16:12:19.352]                           base::stop(msg)
[16:12:19.352]                         }
[16:12:19.352]                       })
[16:12:19.352]                     }
[16:12:19.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.352]                     base::options(mc.cores = 1L)
[16:12:19.352]                   }
[16:12:19.352]                   options(future.plan = NULL)
[16:12:19.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.352]                 }
[16:12:19.352]                 ...future.workdir <- getwd()
[16:12:19.352]             }
[16:12:19.352]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.352]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.352]         }
[16:12:19.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.352]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.352]             base::names(...future.oldOptions))
[16:12:19.352]     }
[16:12:19.352]     if (FALSE) {
[16:12:19.352]     }
[16:12:19.352]     else {
[16:12:19.352]         if (TRUE) {
[16:12:19.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.352]                 open = "w")
[16:12:19.352]         }
[16:12:19.352]         else {
[16:12:19.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.352]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.352]         }
[16:12:19.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.352]             base::sink(type = "output", split = FALSE)
[16:12:19.352]             base::close(...future.stdout)
[16:12:19.352]         }, add = TRUE)
[16:12:19.352]     }
[16:12:19.352]     ...future.frame <- base::sys.nframe()
[16:12:19.352]     ...future.conditions <- base::list()
[16:12:19.352]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.352]     if (FALSE) {
[16:12:19.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.352]     }
[16:12:19.352]     ...future.result <- base::tryCatch({
[16:12:19.352]         base::withCallingHandlers({
[16:12:19.352]             ...future.value <- base::withVisible(base::local({
[16:12:19.352]                 withCallingHandlers({
[16:12:19.352]                   {
[16:12:19.352]                     2
[16:12:19.352]                   }
[16:12:19.352]                 }, immediateCondition = function(cond) {
[16:12:19.352]                   save_rds <- function (object, pathname, ...) 
[16:12:19.352]                   {
[16:12:19.352]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.352]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.352]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.352]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.352]                         fi_tmp[["mtime"]])
[16:12:19.352]                     }
[16:12:19.352]                     tryCatch({
[16:12:19.352]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.352]                     }, error = function(ex) {
[16:12:19.352]                       msg <- conditionMessage(ex)
[16:12:19.352]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.352]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.352]                         fi_tmp[["mtime"]], msg)
[16:12:19.352]                       ex$message <- msg
[16:12:19.352]                       stop(ex)
[16:12:19.352]                     })
[16:12:19.352]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.352]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.352]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.352]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.352]                       fi <- file.info(pathname)
[16:12:19.352]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.352]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.352]                         fi[["size"]], fi[["mtime"]])
[16:12:19.352]                       stop(msg)
[16:12:19.352]                     }
[16:12:19.352]                     invisible(pathname)
[16:12:19.352]                   }
[16:12:19.352]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.352]                     rootPath = tempdir()) 
[16:12:19.352]                   {
[16:12:19.352]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.352]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.352]                       tmpdir = path, fileext = ".rds")
[16:12:19.352]                     save_rds(obj, file)
[16:12:19.352]                   }
[16:12:19.352]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.352]                   {
[16:12:19.352]                     inherits <- base::inherits
[16:12:19.352]                     invokeRestart <- base::invokeRestart
[16:12:19.352]                     is.null <- base::is.null
[16:12:19.352]                     muffled <- FALSE
[16:12:19.352]                     if (inherits(cond, "message")) {
[16:12:19.352]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.352]                       if (muffled) 
[16:12:19.352]                         invokeRestart("muffleMessage")
[16:12:19.352]                     }
[16:12:19.352]                     else if (inherits(cond, "warning")) {
[16:12:19.352]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.352]                       if (muffled) 
[16:12:19.352]                         invokeRestart("muffleWarning")
[16:12:19.352]                     }
[16:12:19.352]                     else if (inherits(cond, "condition")) {
[16:12:19.352]                       if (!is.null(pattern)) {
[16:12:19.352]                         computeRestarts <- base::computeRestarts
[16:12:19.352]                         grepl <- base::grepl
[16:12:19.352]                         restarts <- computeRestarts(cond)
[16:12:19.352]                         for (restart in restarts) {
[16:12:19.352]                           name <- restart$name
[16:12:19.352]                           if (is.null(name)) 
[16:12:19.352]                             next
[16:12:19.352]                           if (!grepl(pattern, name)) 
[16:12:19.352]                             next
[16:12:19.352]                           invokeRestart(restart)
[16:12:19.352]                           muffled <- TRUE
[16:12:19.352]                           break
[16:12:19.352]                         }
[16:12:19.352]                       }
[16:12:19.352]                     }
[16:12:19.352]                     invisible(muffled)
[16:12:19.352]                   }
[16:12:19.352]                   muffleCondition(cond)
[16:12:19.352]                 })
[16:12:19.352]             }))
[16:12:19.352]             future::FutureResult(value = ...future.value$value, 
[16:12:19.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.352]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.352]                     ...future.globalenv.names))
[16:12:19.352]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.352]         }, condition = base::local({
[16:12:19.352]             c <- base::c
[16:12:19.352]             inherits <- base::inherits
[16:12:19.352]             invokeRestart <- base::invokeRestart
[16:12:19.352]             length <- base::length
[16:12:19.352]             list <- base::list
[16:12:19.352]             seq.int <- base::seq.int
[16:12:19.352]             signalCondition <- base::signalCondition
[16:12:19.352]             sys.calls <- base::sys.calls
[16:12:19.352]             `[[` <- base::`[[`
[16:12:19.352]             `+` <- base::`+`
[16:12:19.352]             `<<-` <- base::`<<-`
[16:12:19.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.352]                   3L)]
[16:12:19.352]             }
[16:12:19.352]             function(cond) {
[16:12:19.352]                 is_error <- inherits(cond, "error")
[16:12:19.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.352]                   NULL)
[16:12:19.352]                 if (is_error) {
[16:12:19.352]                   sessionInformation <- function() {
[16:12:19.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.352]                       search = base::search(), system = base::Sys.info())
[16:12:19.352]                   }
[16:12:19.352]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.352]                     cond$call), session = sessionInformation(), 
[16:12:19.352]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.352]                   signalCondition(cond)
[16:12:19.352]                 }
[16:12:19.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.352]                 "immediateCondition"))) {
[16:12:19.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.352]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.352]                   if (TRUE && !signal) {
[16:12:19.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.352]                     {
[16:12:19.352]                       inherits <- base::inherits
[16:12:19.352]                       invokeRestart <- base::invokeRestart
[16:12:19.352]                       is.null <- base::is.null
[16:12:19.352]                       muffled <- FALSE
[16:12:19.352]                       if (inherits(cond, "message")) {
[16:12:19.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.352]                         if (muffled) 
[16:12:19.352]                           invokeRestart("muffleMessage")
[16:12:19.352]                       }
[16:12:19.352]                       else if (inherits(cond, "warning")) {
[16:12:19.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.352]                         if (muffled) 
[16:12:19.352]                           invokeRestart("muffleWarning")
[16:12:19.352]                       }
[16:12:19.352]                       else if (inherits(cond, "condition")) {
[16:12:19.352]                         if (!is.null(pattern)) {
[16:12:19.352]                           computeRestarts <- base::computeRestarts
[16:12:19.352]                           grepl <- base::grepl
[16:12:19.352]                           restarts <- computeRestarts(cond)
[16:12:19.352]                           for (restart in restarts) {
[16:12:19.352]                             name <- restart$name
[16:12:19.352]                             if (is.null(name)) 
[16:12:19.352]                               next
[16:12:19.352]                             if (!grepl(pattern, name)) 
[16:12:19.352]                               next
[16:12:19.352]                             invokeRestart(restart)
[16:12:19.352]                             muffled <- TRUE
[16:12:19.352]                             break
[16:12:19.352]                           }
[16:12:19.352]                         }
[16:12:19.352]                       }
[16:12:19.352]                       invisible(muffled)
[16:12:19.352]                     }
[16:12:19.352]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.352]                   }
[16:12:19.352]                 }
[16:12:19.352]                 else {
[16:12:19.352]                   if (TRUE) {
[16:12:19.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.352]                     {
[16:12:19.352]                       inherits <- base::inherits
[16:12:19.352]                       invokeRestart <- base::invokeRestart
[16:12:19.352]                       is.null <- base::is.null
[16:12:19.352]                       muffled <- FALSE
[16:12:19.352]                       if (inherits(cond, "message")) {
[16:12:19.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.352]                         if (muffled) 
[16:12:19.352]                           invokeRestart("muffleMessage")
[16:12:19.352]                       }
[16:12:19.352]                       else if (inherits(cond, "warning")) {
[16:12:19.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.352]                         if (muffled) 
[16:12:19.352]                           invokeRestart("muffleWarning")
[16:12:19.352]                       }
[16:12:19.352]                       else if (inherits(cond, "condition")) {
[16:12:19.352]                         if (!is.null(pattern)) {
[16:12:19.352]                           computeRestarts <- base::computeRestarts
[16:12:19.352]                           grepl <- base::grepl
[16:12:19.352]                           restarts <- computeRestarts(cond)
[16:12:19.352]                           for (restart in restarts) {
[16:12:19.352]                             name <- restart$name
[16:12:19.352]                             if (is.null(name)) 
[16:12:19.352]                               next
[16:12:19.352]                             if (!grepl(pattern, name)) 
[16:12:19.352]                               next
[16:12:19.352]                             invokeRestart(restart)
[16:12:19.352]                             muffled <- TRUE
[16:12:19.352]                             break
[16:12:19.352]                           }
[16:12:19.352]                         }
[16:12:19.352]                       }
[16:12:19.352]                       invisible(muffled)
[16:12:19.352]                     }
[16:12:19.352]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.352]                   }
[16:12:19.352]                 }
[16:12:19.352]             }
[16:12:19.352]         }))
[16:12:19.352]     }, error = function(ex) {
[16:12:19.352]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.352]                 ...future.rng), started = ...future.startTime, 
[16:12:19.352]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.352]             version = "1.8"), class = "FutureResult")
[16:12:19.352]     }, finally = {
[16:12:19.352]         if (!identical(...future.workdir, getwd())) 
[16:12:19.352]             setwd(...future.workdir)
[16:12:19.352]         {
[16:12:19.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.352]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.352]             }
[16:12:19.352]             base::options(...future.oldOptions)
[16:12:19.352]             if (.Platform$OS.type == "windows") {
[16:12:19.352]                 old_names <- names(...future.oldEnvVars)
[16:12:19.352]                 envs <- base::Sys.getenv()
[16:12:19.352]                 names <- names(envs)
[16:12:19.352]                 common <- intersect(names, old_names)
[16:12:19.352]                 added <- setdiff(names, old_names)
[16:12:19.352]                 removed <- setdiff(old_names, names)
[16:12:19.352]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.352]                   envs[common]]
[16:12:19.352]                 NAMES <- toupper(changed)
[16:12:19.352]                 args <- list()
[16:12:19.352]                 for (kk in seq_along(NAMES)) {
[16:12:19.352]                   name <- changed[[kk]]
[16:12:19.352]                   NAME <- NAMES[[kk]]
[16:12:19.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.352]                     next
[16:12:19.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.352]                 }
[16:12:19.352]                 NAMES <- toupper(added)
[16:12:19.352]                 for (kk in seq_along(NAMES)) {
[16:12:19.352]                   name <- added[[kk]]
[16:12:19.352]                   NAME <- NAMES[[kk]]
[16:12:19.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.352]                     next
[16:12:19.352]                   args[[name]] <- ""
[16:12:19.352]                 }
[16:12:19.352]                 NAMES <- toupper(removed)
[16:12:19.352]                 for (kk in seq_along(NAMES)) {
[16:12:19.352]                   name <- removed[[kk]]
[16:12:19.352]                   NAME <- NAMES[[kk]]
[16:12:19.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.352]                     next
[16:12:19.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.352]                 }
[16:12:19.352]                 if (length(args) > 0) 
[16:12:19.352]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.352]             }
[16:12:19.352]             else {
[16:12:19.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.352]             }
[16:12:19.352]             {
[16:12:19.352]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.352]                   0L) {
[16:12:19.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.352]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.352]                   base::options(opts)
[16:12:19.352]                 }
[16:12:19.352]                 {
[16:12:19.352]                   {
[16:12:19.352]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.352]                     NULL
[16:12:19.352]                   }
[16:12:19.352]                   options(future.plan = NULL)
[16:12:19.352]                   if (is.na(NA_character_)) 
[16:12:19.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.352]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.352]                     envir = parent.frame()) 
[16:12:19.352]                   {
[16:12:19.352]                     default_workers <- missing(workers)
[16:12:19.352]                     if (is.function(workers)) 
[16:12:19.352]                       workers <- workers()
[16:12:19.352]                     workers <- structure(as.integer(workers), 
[16:12:19.352]                       class = class(workers))
[16:12:19.352]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.352]                       1L)
[16:12:19.352]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.352]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.352]                       if (default_workers) 
[16:12:19.352]                         supportsMulticore(warn = TRUE)
[16:12:19.352]                       return(sequential(..., envir = envir))
[16:12:19.352]                     }
[16:12:19.352]                     oopts <- options(mc.cores = workers)
[16:12:19.352]                     on.exit(options(oopts))
[16:12:19.352]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.352]                       envir = envir)
[16:12:19.352]                     if (!future$lazy) 
[16:12:19.352]                       future <- run(future)
[16:12:19.352]                     invisible(future)
[16:12:19.352]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.352]                 }
[16:12:19.352]             }
[16:12:19.352]         }
[16:12:19.352]     })
[16:12:19.352]     if (TRUE) {
[16:12:19.352]         base::sink(type = "output", split = FALSE)
[16:12:19.352]         if (TRUE) {
[16:12:19.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.352]         }
[16:12:19.352]         else {
[16:12:19.352]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.352]         }
[16:12:19.352]         base::close(...future.stdout)
[16:12:19.352]         ...future.stdout <- NULL
[16:12:19.352]     }
[16:12:19.352]     ...future.result$conditions <- ...future.conditions
[16:12:19.352]     ...future.result$finished <- base::Sys.time()
[16:12:19.352]     ...future.result
[16:12:19.352] }
[16:12:19.354] requestCore(): workers = 2
[16:12:19.357] MulticoreFuture started
[16:12:19.357] - Launch lazy future ... done
[16:12:19.358] plan(): Setting new future strategy stack:
[16:12:19.358] run() for ‘MulticoreFuture’ ... done
[16:12:19.358] getGlobalsAndPackages() ...
[16:12:19.358] List of future strategies:
[16:12:19.358] 1. sequential:
[16:12:19.358]    - args: function (..., envir = parent.frame())
[16:12:19.358]    - tweaked: FALSE
[16:12:19.358]    - call: NULL
[16:12:19.359] Searching for globals...
[16:12:19.359] plan(): nbrOfWorkers() = 1
[16:12:19.360] - globals found: [1] ‘{’
[16:12:19.361] Searching for globals ... DONE
[16:12:19.361] plan(): Setting new future strategy stack:
[16:12:19.361] Resolving globals: FALSE
[16:12:19.361] List of future strategies:
[16:12:19.361] 1. multicore:
[16:12:19.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.361]    - tweaked: FALSE
[16:12:19.361]    - call: plan(strategy)
[16:12:19.361] 
[16:12:19.362] 
[16:12:19.362] getGlobalsAndPackages() ... DONE
[16:12:19.362] run() for ‘Future’ ...
[16:12:19.363] - state: ‘created’
[16:12:19.363] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.366] plan(): nbrOfWorkers() = 2
[16:12:19.367] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.368]   - Field: ‘label’
[16:12:19.368]   - Field: ‘local’
[16:12:19.368]   - Field: ‘owner’
[16:12:19.368]   - Field: ‘envir’
[16:12:19.368]   - Field: ‘workers’
[16:12:19.369]   - Field: ‘packages’
[16:12:19.369]   - Field: ‘gc’
[16:12:19.369]   - Field: ‘job’
[16:12:19.369]   - Field: ‘conditions’
[16:12:19.369]   - Field: ‘expr’
[16:12:19.369]   - Field: ‘uuid’
[16:12:19.369]   - Field: ‘seed’
[16:12:19.369]   - Field: ‘version’
[16:12:19.374]   - Field: ‘result’
[16:12:19.374]   - Field: ‘asynchronous’
[16:12:19.374]   - Field: ‘calls’
[16:12:19.374]   - Field: ‘globals’
[16:12:19.374]   - Field: ‘stdout’
[16:12:19.375]   - Field: ‘earlySignal’
[16:12:19.375]   - Field: ‘lazy’
[16:12:19.375]   - Field: ‘state’
[16:12:19.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.375] - Launch lazy future ...
[16:12:19.376] Packages needed by the future expression (n = 0): <none>
[16:12:19.376] Packages needed by future strategies (n = 0): <none>
[16:12:19.377] {
[16:12:19.377]     {
[16:12:19.377]         {
[16:12:19.377]             ...future.startTime <- base::Sys.time()
[16:12:19.377]             {
[16:12:19.377]                 {
[16:12:19.377]                   {
[16:12:19.377]                     {
[16:12:19.377]                       base::local({
[16:12:19.377]                         has_future <- base::requireNamespace("future", 
[16:12:19.377]                           quietly = TRUE)
[16:12:19.377]                         if (has_future) {
[16:12:19.377]                           ns <- base::getNamespace("future")
[16:12:19.377]                           version <- ns[[".package"]][["version"]]
[16:12:19.377]                           if (is.null(version)) 
[16:12:19.377]                             version <- utils::packageVersion("future")
[16:12:19.377]                         }
[16:12:19.377]                         else {
[16:12:19.377]                           version <- NULL
[16:12:19.377]                         }
[16:12:19.377]                         if (!has_future || version < "1.8.0") {
[16:12:19.377]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.377]                             "", base::R.version$version.string), 
[16:12:19.377]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.377]                               "release", "version")], collapse = " "), 
[16:12:19.377]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.377]                             info)
[16:12:19.377]                           info <- base::paste(info, collapse = "; ")
[16:12:19.377]                           if (!has_future) {
[16:12:19.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.377]                               info)
[16:12:19.377]                           }
[16:12:19.377]                           else {
[16:12:19.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.377]                               info, version)
[16:12:19.377]                           }
[16:12:19.377]                           base::stop(msg)
[16:12:19.377]                         }
[16:12:19.377]                       })
[16:12:19.377]                     }
[16:12:19.377]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.377]                     base::options(mc.cores = 1L)
[16:12:19.377]                   }
[16:12:19.377]                   options(future.plan = NULL)
[16:12:19.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.377]                 }
[16:12:19.377]                 ...future.workdir <- getwd()
[16:12:19.377]             }
[16:12:19.377]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.377]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.377]         }
[16:12:19.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.377]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.377]             base::names(...future.oldOptions))
[16:12:19.377]     }
[16:12:19.377]     if (FALSE) {
[16:12:19.377]     }
[16:12:19.377]     else {
[16:12:19.377]         if (TRUE) {
[16:12:19.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.377]                 open = "w")
[16:12:19.377]         }
[16:12:19.377]         else {
[16:12:19.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.377]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.377]         }
[16:12:19.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.377]             base::sink(type = "output", split = FALSE)
[16:12:19.377]             base::close(...future.stdout)
[16:12:19.377]         }, add = TRUE)
[16:12:19.377]     }
[16:12:19.377]     ...future.frame <- base::sys.nframe()
[16:12:19.377]     ...future.conditions <- base::list()
[16:12:19.377]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.377]     if (FALSE) {
[16:12:19.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.377]     }
[16:12:19.377]     ...future.result <- base::tryCatch({
[16:12:19.377]         base::withCallingHandlers({
[16:12:19.377]             ...future.value <- base::withVisible(base::local({
[16:12:19.377]                 withCallingHandlers({
[16:12:19.377]                   {
[16:12:19.377]                     4
[16:12:19.377]                   }
[16:12:19.377]                 }, immediateCondition = function(cond) {
[16:12:19.377]                   save_rds <- function (object, pathname, ...) 
[16:12:19.377]                   {
[16:12:19.377]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.377]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.377]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.377]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.377]                         fi_tmp[["mtime"]])
[16:12:19.377]                     }
[16:12:19.377]                     tryCatch({
[16:12:19.377]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.377]                     }, error = function(ex) {
[16:12:19.377]                       msg <- conditionMessage(ex)
[16:12:19.377]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.377]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.377]                         fi_tmp[["mtime"]], msg)
[16:12:19.377]                       ex$message <- msg
[16:12:19.377]                       stop(ex)
[16:12:19.377]                     })
[16:12:19.377]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.377]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.377]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.377]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.377]                       fi <- file.info(pathname)
[16:12:19.377]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.377]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.377]                         fi[["size"]], fi[["mtime"]])
[16:12:19.377]                       stop(msg)
[16:12:19.377]                     }
[16:12:19.377]                     invisible(pathname)
[16:12:19.377]                   }
[16:12:19.377]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.377]                     rootPath = tempdir()) 
[16:12:19.377]                   {
[16:12:19.377]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.377]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.377]                       tmpdir = path, fileext = ".rds")
[16:12:19.377]                     save_rds(obj, file)
[16:12:19.377]                   }
[16:12:19.377]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.377]                   {
[16:12:19.377]                     inherits <- base::inherits
[16:12:19.377]                     invokeRestart <- base::invokeRestart
[16:12:19.377]                     is.null <- base::is.null
[16:12:19.377]                     muffled <- FALSE
[16:12:19.377]                     if (inherits(cond, "message")) {
[16:12:19.377]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.377]                       if (muffled) 
[16:12:19.377]                         invokeRestart("muffleMessage")
[16:12:19.377]                     }
[16:12:19.377]                     else if (inherits(cond, "warning")) {
[16:12:19.377]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.377]                       if (muffled) 
[16:12:19.377]                         invokeRestart("muffleWarning")
[16:12:19.377]                     }
[16:12:19.377]                     else if (inherits(cond, "condition")) {
[16:12:19.377]                       if (!is.null(pattern)) {
[16:12:19.377]                         computeRestarts <- base::computeRestarts
[16:12:19.377]                         grepl <- base::grepl
[16:12:19.377]                         restarts <- computeRestarts(cond)
[16:12:19.377]                         for (restart in restarts) {
[16:12:19.377]                           name <- restart$name
[16:12:19.377]                           if (is.null(name)) 
[16:12:19.377]                             next
[16:12:19.377]                           if (!grepl(pattern, name)) 
[16:12:19.377]                             next
[16:12:19.377]                           invokeRestart(restart)
[16:12:19.377]                           muffled <- TRUE
[16:12:19.377]                           break
[16:12:19.377]                         }
[16:12:19.377]                       }
[16:12:19.377]                     }
[16:12:19.377]                     invisible(muffled)
[16:12:19.377]                   }
[16:12:19.377]                   muffleCondition(cond)
[16:12:19.377]                 })
[16:12:19.377]             }))
[16:12:19.377]             future::FutureResult(value = ...future.value$value, 
[16:12:19.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.377]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.377]                     ...future.globalenv.names))
[16:12:19.377]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.377]         }, condition = base::local({
[16:12:19.377]             c <- base::c
[16:12:19.377]             inherits <- base::inherits
[16:12:19.377]             invokeRestart <- base::invokeRestart
[16:12:19.377]             length <- base::length
[16:12:19.377]             list <- base::list
[16:12:19.377]             seq.int <- base::seq.int
[16:12:19.377]             signalCondition <- base::signalCondition
[16:12:19.377]             sys.calls <- base::sys.calls
[16:12:19.377]             `[[` <- base::`[[`
[16:12:19.377]             `+` <- base::`+`
[16:12:19.377]             `<<-` <- base::`<<-`
[16:12:19.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.377]                   3L)]
[16:12:19.377]             }
[16:12:19.377]             function(cond) {
[16:12:19.377]                 is_error <- inherits(cond, "error")
[16:12:19.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.377]                   NULL)
[16:12:19.377]                 if (is_error) {
[16:12:19.377]                   sessionInformation <- function() {
[16:12:19.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.377]                       search = base::search(), system = base::Sys.info())
[16:12:19.377]                   }
[16:12:19.377]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.377]                     cond$call), session = sessionInformation(), 
[16:12:19.377]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.377]                   signalCondition(cond)
[16:12:19.377]                 }
[16:12:19.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.377]                 "immediateCondition"))) {
[16:12:19.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.377]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.377]                   if (TRUE && !signal) {
[16:12:19.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.377]                     {
[16:12:19.377]                       inherits <- base::inherits
[16:12:19.377]                       invokeRestart <- base::invokeRestart
[16:12:19.377]                       is.null <- base::is.null
[16:12:19.377]                       muffled <- FALSE
[16:12:19.377]                       if (inherits(cond, "message")) {
[16:12:19.377]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.377]                         if (muffled) 
[16:12:19.377]                           invokeRestart("muffleMessage")
[16:12:19.377]                       }
[16:12:19.377]                       else if (inherits(cond, "warning")) {
[16:12:19.377]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.377]                         if (muffled) 
[16:12:19.377]                           invokeRestart("muffleWarning")
[16:12:19.377]                       }
[16:12:19.377]                       else if (inherits(cond, "condition")) {
[16:12:19.377]                         if (!is.null(pattern)) {
[16:12:19.377]                           computeRestarts <- base::computeRestarts
[16:12:19.377]                           grepl <- base::grepl
[16:12:19.377]                           restarts <- computeRestarts(cond)
[16:12:19.377]                           for (restart in restarts) {
[16:12:19.377]                             name <- restart$name
[16:12:19.377]                             if (is.null(name)) 
[16:12:19.377]                               next
[16:12:19.377]                             if (!grepl(pattern, name)) 
[16:12:19.377]                               next
[16:12:19.377]                             invokeRestart(restart)
[16:12:19.377]                             muffled <- TRUE
[16:12:19.377]                             break
[16:12:19.377]                           }
[16:12:19.377]                         }
[16:12:19.377]                       }
[16:12:19.377]                       invisible(muffled)
[16:12:19.377]                     }
[16:12:19.377]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.377]                   }
[16:12:19.377]                 }
[16:12:19.377]                 else {
[16:12:19.377]                   if (TRUE) {
[16:12:19.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.377]                     {
[16:12:19.377]                       inherits <- base::inherits
[16:12:19.377]                       invokeRestart <- base::invokeRestart
[16:12:19.377]                       is.null <- base::is.null
[16:12:19.377]                       muffled <- FALSE
[16:12:19.377]                       if (inherits(cond, "message")) {
[16:12:19.377]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.377]                         if (muffled) 
[16:12:19.377]                           invokeRestart("muffleMessage")
[16:12:19.377]                       }
[16:12:19.377]                       else if (inherits(cond, "warning")) {
[16:12:19.377]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.377]                         if (muffled) 
[16:12:19.377]                           invokeRestart("muffleWarning")
[16:12:19.377]                       }
[16:12:19.377]                       else if (inherits(cond, "condition")) {
[16:12:19.377]                         if (!is.null(pattern)) {
[16:12:19.377]                           computeRestarts <- base::computeRestarts
[16:12:19.377]                           grepl <- base::grepl
[16:12:19.377]                           restarts <- computeRestarts(cond)
[16:12:19.377]                           for (restart in restarts) {
[16:12:19.377]                             name <- restart$name
[16:12:19.377]                             if (is.null(name)) 
[16:12:19.377]                               next
[16:12:19.377]                             if (!grepl(pattern, name)) 
[16:12:19.377]                               next
[16:12:19.377]                             invokeRestart(restart)
[16:12:19.377]                             muffled <- TRUE
[16:12:19.377]                             break
[16:12:19.377]                           }
[16:12:19.377]                         }
[16:12:19.377]                       }
[16:12:19.377]                       invisible(muffled)
[16:12:19.377]                     }
[16:12:19.377]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.377]                   }
[16:12:19.377]                 }
[16:12:19.377]             }
[16:12:19.377]         }))
[16:12:19.377]     }, error = function(ex) {
[16:12:19.377]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.377]                 ...future.rng), started = ...future.startTime, 
[16:12:19.377]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.377]             version = "1.8"), class = "FutureResult")
[16:12:19.377]     }, finally = {
[16:12:19.377]         if (!identical(...future.workdir, getwd())) 
[16:12:19.377]             setwd(...future.workdir)
[16:12:19.377]         {
[16:12:19.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.377]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.377]             }
[16:12:19.377]             base::options(...future.oldOptions)
[16:12:19.377]             if (.Platform$OS.type == "windows") {
[16:12:19.377]                 old_names <- names(...future.oldEnvVars)
[16:12:19.377]                 envs <- base::Sys.getenv()
[16:12:19.377]                 names <- names(envs)
[16:12:19.377]                 common <- intersect(names, old_names)
[16:12:19.377]                 added <- setdiff(names, old_names)
[16:12:19.377]                 removed <- setdiff(old_names, names)
[16:12:19.377]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.377]                   envs[common]]
[16:12:19.377]                 NAMES <- toupper(changed)
[16:12:19.377]                 args <- list()
[16:12:19.377]                 for (kk in seq_along(NAMES)) {
[16:12:19.377]                   name <- changed[[kk]]
[16:12:19.377]                   NAME <- NAMES[[kk]]
[16:12:19.377]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.377]                     next
[16:12:19.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.377]                 }
[16:12:19.377]                 NAMES <- toupper(added)
[16:12:19.377]                 for (kk in seq_along(NAMES)) {
[16:12:19.377]                   name <- added[[kk]]
[16:12:19.377]                   NAME <- NAMES[[kk]]
[16:12:19.377]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.377]                     next
[16:12:19.377]                   args[[name]] <- ""
[16:12:19.377]                 }
[16:12:19.377]                 NAMES <- toupper(removed)
[16:12:19.377]                 for (kk in seq_along(NAMES)) {
[16:12:19.377]                   name <- removed[[kk]]
[16:12:19.377]                   NAME <- NAMES[[kk]]
[16:12:19.377]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.377]                     next
[16:12:19.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.377]                 }
[16:12:19.377]                 if (length(args) > 0) 
[16:12:19.377]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.377]             }
[16:12:19.377]             else {
[16:12:19.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.377]             }
[16:12:19.377]             {
[16:12:19.377]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.377]                   0L) {
[16:12:19.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.377]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.377]                   base::options(opts)
[16:12:19.377]                 }
[16:12:19.377]                 {
[16:12:19.377]                   {
[16:12:19.377]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.377]                     NULL
[16:12:19.377]                   }
[16:12:19.377]                   options(future.plan = NULL)
[16:12:19.377]                   if (is.na(NA_character_)) 
[16:12:19.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.377]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.377]                     envir = parent.frame()) 
[16:12:19.377]                   {
[16:12:19.377]                     default_workers <- missing(workers)
[16:12:19.377]                     if (is.function(workers)) 
[16:12:19.377]                       workers <- workers()
[16:12:19.377]                     workers <- structure(as.integer(workers), 
[16:12:19.377]                       class = class(workers))
[16:12:19.377]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.377]                       1L)
[16:12:19.377]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.377]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.377]                       if (default_workers) 
[16:12:19.377]                         supportsMulticore(warn = TRUE)
[16:12:19.377]                       return(sequential(..., envir = envir))
[16:12:19.377]                     }
[16:12:19.377]                     oopts <- options(mc.cores = workers)
[16:12:19.377]                     on.exit(options(oopts))
[16:12:19.377]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.377]                       envir = envir)
[16:12:19.377]                     if (!future$lazy) 
[16:12:19.377]                       future <- run(future)
[16:12:19.377]                     invisible(future)
[16:12:19.377]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.377]                 }
[16:12:19.377]             }
[16:12:19.377]         }
[16:12:19.377]     })
[16:12:19.377]     if (TRUE) {
[16:12:19.377]         base::sink(type = "output", split = FALSE)
[16:12:19.377]         if (TRUE) {
[16:12:19.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.377]         }
[16:12:19.377]         else {
[16:12:19.377]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.377]         }
[16:12:19.377]         base::close(...future.stdout)
[16:12:19.377]         ...future.stdout <- NULL
[16:12:19.377]     }
[16:12:19.377]     ...future.result$conditions <- ...future.conditions
[16:12:19.377]     ...future.result$finished <- base::Sys.time()
[16:12:19.377]     ...future.result
[16:12:19.377] }
[16:12:19.380] requestCore(): workers = 2
[16:12:19.387] MulticoreFuture started
[16:12:19.387] - Launch lazy future ... done
[16:12:19.387] run() for ‘MulticoreFuture’ ... done
[16:12:19.388] plan(): Setting new future strategy stack:
[16:12:19.388] List of future strategies:
[16:12:19.388] 1. sequential:
[16:12:19.388]    - args: function (..., envir = parent.frame())
[16:12:19.388]    - tweaked: FALSE
[16:12:19.388]    - call: NULL
[16:12:19.389] plan(): nbrOfWorkers() = 1
u$a = 2
[16:12:19.391] plan(): Setting new future strategy stack:
[16:12:19.391] List of future strategies:
[16:12:19.391] 1. multicore:
[16:12:19.391]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.391]    - tweaked: FALSE
[16:12:19.391]    - call: plan(strategy)
[16:12:19.397] plan(): nbrOfWorkers() = 2
v$a = 4
[16:12:19.398] getGlobalsAndPackages() ...
[16:12:19.399] Searching for globals...
[16:12:19.400] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.400] Searching for globals ... DONE
[16:12:19.401] Resolving globals: FALSE
[16:12:19.401] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.402] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.402] - globals: [1] ‘a’
[16:12:19.402] 
[16:12:19.402] getGlobalsAndPackages() ... DONE
[16:12:19.402] run() for ‘Future’ ...
[16:12:19.402] - state: ‘created’
[16:12:19.403] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.407] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.407]   - Field: ‘label’
[16:12:19.407]   - Field: ‘local’
[16:12:19.407]   - Field: ‘owner’
[16:12:19.407]   - Field: ‘envir’
[16:12:19.408]   - Field: ‘workers’
[16:12:19.408]   - Field: ‘packages’
[16:12:19.408]   - Field: ‘gc’
[16:12:19.408]   - Field: ‘job’
[16:12:19.408]   - Field: ‘conditions’
[16:12:19.408]   - Field: ‘expr’
[16:12:19.408]   - Field: ‘uuid’
[16:12:19.408]   - Field: ‘seed’
[16:12:19.409]   - Field: ‘version’
[16:12:19.409]   - Field: ‘result’
[16:12:19.409]   - Field: ‘asynchronous’
[16:12:19.409]   - Field: ‘calls’
[16:12:19.409]   - Field: ‘globals’
[16:12:19.409]   - Field: ‘stdout’
[16:12:19.409]   - Field: ‘earlySignal’
[16:12:19.409]   - Field: ‘lazy’
[16:12:19.409]   - Field: ‘state’
[16:12:19.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.410] - Launch lazy future ...
[16:12:19.410] Packages needed by the future expression (n = 0): <none>
[16:12:19.410] Packages needed by future strategies (n = 0): <none>
[16:12:19.411] {
[16:12:19.411]     {
[16:12:19.411]         {
[16:12:19.411]             ...future.startTime <- base::Sys.time()
[16:12:19.411]             {
[16:12:19.411]                 {
[16:12:19.411]                   {
[16:12:19.411]                     {
[16:12:19.411]                       base::local({
[16:12:19.411]                         has_future <- base::requireNamespace("future", 
[16:12:19.411]                           quietly = TRUE)
[16:12:19.411]                         if (has_future) {
[16:12:19.411]                           ns <- base::getNamespace("future")
[16:12:19.411]                           version <- ns[[".package"]][["version"]]
[16:12:19.411]                           if (is.null(version)) 
[16:12:19.411]                             version <- utils::packageVersion("future")
[16:12:19.411]                         }
[16:12:19.411]                         else {
[16:12:19.411]                           version <- NULL
[16:12:19.411]                         }
[16:12:19.411]                         if (!has_future || version < "1.8.0") {
[16:12:19.411]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.411]                             "", base::R.version$version.string), 
[16:12:19.411]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.411]                               "release", "version")], collapse = " "), 
[16:12:19.411]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.411]                             info)
[16:12:19.411]                           info <- base::paste(info, collapse = "; ")
[16:12:19.411]                           if (!has_future) {
[16:12:19.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.411]                               info)
[16:12:19.411]                           }
[16:12:19.411]                           else {
[16:12:19.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.411]                               info, version)
[16:12:19.411]                           }
[16:12:19.411]                           base::stop(msg)
[16:12:19.411]                         }
[16:12:19.411]                       })
[16:12:19.411]                     }
[16:12:19.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.411]                     base::options(mc.cores = 1L)
[16:12:19.411]                   }
[16:12:19.411]                   options(future.plan = NULL)
[16:12:19.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.411]                 }
[16:12:19.411]                 ...future.workdir <- getwd()
[16:12:19.411]             }
[16:12:19.411]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.411]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.411]         }
[16:12:19.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.411]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.411]             base::names(...future.oldOptions))
[16:12:19.411]     }
[16:12:19.411]     if (FALSE) {
[16:12:19.411]     }
[16:12:19.411]     else {
[16:12:19.411]         if (TRUE) {
[16:12:19.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.411]                 open = "w")
[16:12:19.411]         }
[16:12:19.411]         else {
[16:12:19.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.411]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.411]         }
[16:12:19.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.411]             base::sink(type = "output", split = FALSE)
[16:12:19.411]             base::close(...future.stdout)
[16:12:19.411]         }, add = TRUE)
[16:12:19.411]     }
[16:12:19.411]     ...future.frame <- base::sys.nframe()
[16:12:19.411]     ...future.conditions <- base::list()
[16:12:19.411]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.411]     if (FALSE) {
[16:12:19.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.411]     }
[16:12:19.411]     ...future.result <- base::tryCatch({
[16:12:19.411]         base::withCallingHandlers({
[16:12:19.411]             ...future.value <- base::withVisible(base::local({
[16:12:19.411]                 withCallingHandlers({
[16:12:19.411]                   {
[16:12:19.411]                     2 * a
[16:12:19.411]                   }
[16:12:19.411]                 }, immediateCondition = function(cond) {
[16:12:19.411]                   save_rds <- function (object, pathname, ...) 
[16:12:19.411]                   {
[16:12:19.411]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.411]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.411]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.411]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.411]                         fi_tmp[["mtime"]])
[16:12:19.411]                     }
[16:12:19.411]                     tryCatch({
[16:12:19.411]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.411]                     }, error = function(ex) {
[16:12:19.411]                       msg <- conditionMessage(ex)
[16:12:19.411]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.411]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.411]                         fi_tmp[["mtime"]], msg)
[16:12:19.411]                       ex$message <- msg
[16:12:19.411]                       stop(ex)
[16:12:19.411]                     })
[16:12:19.411]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.411]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.411]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.411]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.411]                       fi <- file.info(pathname)
[16:12:19.411]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.411]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.411]                         fi[["size"]], fi[["mtime"]])
[16:12:19.411]                       stop(msg)
[16:12:19.411]                     }
[16:12:19.411]                     invisible(pathname)
[16:12:19.411]                   }
[16:12:19.411]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.411]                     rootPath = tempdir()) 
[16:12:19.411]                   {
[16:12:19.411]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.411]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.411]                       tmpdir = path, fileext = ".rds")
[16:12:19.411]                     save_rds(obj, file)
[16:12:19.411]                   }
[16:12:19.411]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.411]                   {
[16:12:19.411]                     inherits <- base::inherits
[16:12:19.411]                     invokeRestart <- base::invokeRestart
[16:12:19.411]                     is.null <- base::is.null
[16:12:19.411]                     muffled <- FALSE
[16:12:19.411]                     if (inherits(cond, "message")) {
[16:12:19.411]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.411]                       if (muffled) 
[16:12:19.411]                         invokeRestart("muffleMessage")
[16:12:19.411]                     }
[16:12:19.411]                     else if (inherits(cond, "warning")) {
[16:12:19.411]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.411]                       if (muffled) 
[16:12:19.411]                         invokeRestart("muffleWarning")
[16:12:19.411]                     }
[16:12:19.411]                     else if (inherits(cond, "condition")) {
[16:12:19.411]                       if (!is.null(pattern)) {
[16:12:19.411]                         computeRestarts <- base::computeRestarts
[16:12:19.411]                         grepl <- base::grepl
[16:12:19.411]                         restarts <- computeRestarts(cond)
[16:12:19.411]                         for (restart in restarts) {
[16:12:19.411]                           name <- restart$name
[16:12:19.411]                           if (is.null(name)) 
[16:12:19.411]                             next
[16:12:19.411]                           if (!grepl(pattern, name)) 
[16:12:19.411]                             next
[16:12:19.411]                           invokeRestart(restart)
[16:12:19.411]                           muffled <- TRUE
[16:12:19.411]                           break
[16:12:19.411]                         }
[16:12:19.411]                       }
[16:12:19.411]                     }
[16:12:19.411]                     invisible(muffled)
[16:12:19.411]                   }
[16:12:19.411]                   muffleCondition(cond)
[16:12:19.411]                 })
[16:12:19.411]             }))
[16:12:19.411]             future::FutureResult(value = ...future.value$value, 
[16:12:19.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.411]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.411]                     ...future.globalenv.names))
[16:12:19.411]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.411]         }, condition = base::local({
[16:12:19.411]             c <- base::c
[16:12:19.411]             inherits <- base::inherits
[16:12:19.411]             invokeRestart <- base::invokeRestart
[16:12:19.411]             length <- base::length
[16:12:19.411]             list <- base::list
[16:12:19.411]             seq.int <- base::seq.int
[16:12:19.411]             signalCondition <- base::signalCondition
[16:12:19.411]             sys.calls <- base::sys.calls
[16:12:19.411]             `[[` <- base::`[[`
[16:12:19.411]             `+` <- base::`+`
[16:12:19.411]             `<<-` <- base::`<<-`
[16:12:19.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.411]                   3L)]
[16:12:19.411]             }
[16:12:19.411]             function(cond) {
[16:12:19.411]                 is_error <- inherits(cond, "error")
[16:12:19.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.411]                   NULL)
[16:12:19.411]                 if (is_error) {
[16:12:19.411]                   sessionInformation <- function() {
[16:12:19.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.411]                       search = base::search(), system = base::Sys.info())
[16:12:19.411]                   }
[16:12:19.411]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.411]                     cond$call), session = sessionInformation(), 
[16:12:19.411]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.411]                   signalCondition(cond)
[16:12:19.411]                 }
[16:12:19.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.411]                 "immediateCondition"))) {
[16:12:19.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.411]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.411]                   if (TRUE && !signal) {
[16:12:19.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.411]                     {
[16:12:19.411]                       inherits <- base::inherits
[16:12:19.411]                       invokeRestart <- base::invokeRestart
[16:12:19.411]                       is.null <- base::is.null
[16:12:19.411]                       muffled <- FALSE
[16:12:19.411]                       if (inherits(cond, "message")) {
[16:12:19.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.411]                         if (muffled) 
[16:12:19.411]                           invokeRestart("muffleMessage")
[16:12:19.411]                       }
[16:12:19.411]                       else if (inherits(cond, "warning")) {
[16:12:19.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.411]                         if (muffled) 
[16:12:19.411]                           invokeRestart("muffleWarning")
[16:12:19.411]                       }
[16:12:19.411]                       else if (inherits(cond, "condition")) {
[16:12:19.411]                         if (!is.null(pattern)) {
[16:12:19.411]                           computeRestarts <- base::computeRestarts
[16:12:19.411]                           grepl <- base::grepl
[16:12:19.411]                           restarts <- computeRestarts(cond)
[16:12:19.411]                           for (restart in restarts) {
[16:12:19.411]                             name <- restart$name
[16:12:19.411]                             if (is.null(name)) 
[16:12:19.411]                               next
[16:12:19.411]                             if (!grepl(pattern, name)) 
[16:12:19.411]                               next
[16:12:19.411]                             invokeRestart(restart)
[16:12:19.411]                             muffled <- TRUE
[16:12:19.411]                             break
[16:12:19.411]                           }
[16:12:19.411]                         }
[16:12:19.411]                       }
[16:12:19.411]                       invisible(muffled)
[16:12:19.411]                     }
[16:12:19.411]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.411]                   }
[16:12:19.411]                 }
[16:12:19.411]                 else {
[16:12:19.411]                   if (TRUE) {
[16:12:19.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.411]                     {
[16:12:19.411]                       inherits <- base::inherits
[16:12:19.411]                       invokeRestart <- base::invokeRestart
[16:12:19.411]                       is.null <- base::is.null
[16:12:19.411]                       muffled <- FALSE
[16:12:19.411]                       if (inherits(cond, "message")) {
[16:12:19.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.411]                         if (muffled) 
[16:12:19.411]                           invokeRestart("muffleMessage")
[16:12:19.411]                       }
[16:12:19.411]                       else if (inherits(cond, "warning")) {
[16:12:19.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.411]                         if (muffled) 
[16:12:19.411]                           invokeRestart("muffleWarning")
[16:12:19.411]                       }
[16:12:19.411]                       else if (inherits(cond, "condition")) {
[16:12:19.411]                         if (!is.null(pattern)) {
[16:12:19.411]                           computeRestarts <- base::computeRestarts
[16:12:19.411]                           grepl <- base::grepl
[16:12:19.411]                           restarts <- computeRestarts(cond)
[16:12:19.411]                           for (restart in restarts) {
[16:12:19.411]                             name <- restart$name
[16:12:19.411]                             if (is.null(name)) 
[16:12:19.411]                               next
[16:12:19.411]                             if (!grepl(pattern, name)) 
[16:12:19.411]                               next
[16:12:19.411]                             invokeRestart(restart)
[16:12:19.411]                             muffled <- TRUE
[16:12:19.411]                             break
[16:12:19.411]                           }
[16:12:19.411]                         }
[16:12:19.411]                       }
[16:12:19.411]                       invisible(muffled)
[16:12:19.411]                     }
[16:12:19.411]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.411]                   }
[16:12:19.411]                 }
[16:12:19.411]             }
[16:12:19.411]         }))
[16:12:19.411]     }, error = function(ex) {
[16:12:19.411]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.411]                 ...future.rng), started = ...future.startTime, 
[16:12:19.411]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.411]             version = "1.8"), class = "FutureResult")
[16:12:19.411]     }, finally = {
[16:12:19.411]         if (!identical(...future.workdir, getwd())) 
[16:12:19.411]             setwd(...future.workdir)
[16:12:19.411]         {
[16:12:19.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.411]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.411]             }
[16:12:19.411]             base::options(...future.oldOptions)
[16:12:19.411]             if (.Platform$OS.type == "windows") {
[16:12:19.411]                 old_names <- names(...future.oldEnvVars)
[16:12:19.411]                 envs <- base::Sys.getenv()
[16:12:19.411]                 names <- names(envs)
[16:12:19.411]                 common <- intersect(names, old_names)
[16:12:19.411]                 added <- setdiff(names, old_names)
[16:12:19.411]                 removed <- setdiff(old_names, names)
[16:12:19.411]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.411]                   envs[common]]
[16:12:19.411]                 NAMES <- toupper(changed)
[16:12:19.411]                 args <- list()
[16:12:19.411]                 for (kk in seq_along(NAMES)) {
[16:12:19.411]                   name <- changed[[kk]]
[16:12:19.411]                   NAME <- NAMES[[kk]]
[16:12:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.411]                     next
[16:12:19.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.411]                 }
[16:12:19.411]                 NAMES <- toupper(added)
[16:12:19.411]                 for (kk in seq_along(NAMES)) {
[16:12:19.411]                   name <- added[[kk]]
[16:12:19.411]                   NAME <- NAMES[[kk]]
[16:12:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.411]                     next
[16:12:19.411]                   args[[name]] <- ""
[16:12:19.411]                 }
[16:12:19.411]                 NAMES <- toupper(removed)
[16:12:19.411]                 for (kk in seq_along(NAMES)) {
[16:12:19.411]                   name <- removed[[kk]]
[16:12:19.411]                   NAME <- NAMES[[kk]]
[16:12:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.411]                     next
[16:12:19.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.411]                 }
[16:12:19.411]                 if (length(args) > 0) 
[16:12:19.411]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.411]             }
[16:12:19.411]             else {
[16:12:19.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.411]             }
[16:12:19.411]             {
[16:12:19.411]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.411]                   0L) {
[16:12:19.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.411]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.411]                   base::options(opts)
[16:12:19.411]                 }
[16:12:19.411]                 {
[16:12:19.411]                   {
[16:12:19.411]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.411]                     NULL
[16:12:19.411]                   }
[16:12:19.411]                   options(future.plan = NULL)
[16:12:19.411]                   if (is.na(NA_character_)) 
[16:12:19.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.411]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.411]                     envir = parent.frame()) 
[16:12:19.411]                   {
[16:12:19.411]                     default_workers <- missing(workers)
[16:12:19.411]                     if (is.function(workers)) 
[16:12:19.411]                       workers <- workers()
[16:12:19.411]                     workers <- structure(as.integer(workers), 
[16:12:19.411]                       class = class(workers))
[16:12:19.411]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.411]                       1L)
[16:12:19.411]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.411]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.411]                       if (default_workers) 
[16:12:19.411]                         supportsMulticore(warn = TRUE)
[16:12:19.411]                       return(sequential(..., envir = envir))
[16:12:19.411]                     }
[16:12:19.411]                     oopts <- options(mc.cores = workers)
[16:12:19.411]                     on.exit(options(oopts))
[16:12:19.411]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.411]                       envir = envir)
[16:12:19.411]                     if (!future$lazy) 
[16:12:19.411]                       future <- run(future)
[16:12:19.411]                     invisible(future)
[16:12:19.411]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.411]                 }
[16:12:19.411]             }
[16:12:19.411]         }
[16:12:19.411]     })
[16:12:19.411]     if (TRUE) {
[16:12:19.411]         base::sink(type = "output", split = FALSE)
[16:12:19.411]         if (TRUE) {
[16:12:19.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.411]         }
[16:12:19.411]         else {
[16:12:19.411]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.411]         }
[16:12:19.411]         base::close(...future.stdout)
[16:12:19.411]         ...future.stdout <- NULL
[16:12:19.411]     }
[16:12:19.411]     ...future.result$conditions <- ...future.conditions
[16:12:19.411]     ...future.result$finished <- base::Sys.time()
[16:12:19.411]     ...future.result
[16:12:19.411] }
[16:12:19.413] assign_globals() ...
[16:12:19.414] List of 1
[16:12:19.414]  $ a: num 1
[16:12:19.414]  - attr(*, "where")=List of 1
[16:12:19.414]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.414]  - attr(*, "resolved")= logi FALSE
[16:12:19.414]  - attr(*, "total_size")= num 56
[16:12:19.414]  - attr(*, "already-done")= logi TRUE
[16:12:19.417] - copied ‘a’ to environment
[16:12:19.417] assign_globals() ... done
[16:12:19.417] requestCore(): workers = 2
[16:12:19.419] MulticoreFuture started
[16:12:19.419] - Launch lazy future ... done
[16:12:19.419] run() for ‘MulticoreFuture’ ... done
[16:12:19.420] plan(): Setting new future strategy stack:
[16:12:19.420] List of future strategies:
[16:12:19.420] 1. sequential:
[16:12:19.420]    - args: function (..., envir = parent.frame())
[16:12:19.420]    - tweaked: FALSE
[16:12:19.420]    - call: NULL
[16:12:19.421] plan(): nbrOfWorkers() = 1
[16:12:19.423] plan(): Setting new future strategy stack:
[16:12:19.423] List of future strategies:
[16:12:19.423] 1. multicore:
[16:12:19.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.423]    - tweaked: FALSE
[16:12:19.423]    - call: plan(strategy)
[16:12:19.429] plan(): nbrOfWorkers() = 2
[16:12:19.430] getGlobalsAndPackages() ...
[16:12:19.430] Searching for globals...
[16:12:19.431] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.431] Searching for globals ... DONE
[16:12:19.432] Resolving globals: FALSE
[16:12:19.432] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.433] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.433] - globals: [1] ‘a’
[16:12:19.433] 
[16:12:19.433] getGlobalsAndPackages() ... DONE
[16:12:19.433] run() for ‘Future’ ...
[16:12:19.434] - state: ‘created’
[16:12:19.434] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.438]   - Field: ‘label’
[16:12:19.438]   - Field: ‘local’
[16:12:19.439]   - Field: ‘owner’
[16:12:19.439]   - Field: ‘envir’
[16:12:19.439]   - Field: ‘workers’
[16:12:19.439]   - Field: ‘packages’
[16:12:19.439]   - Field: ‘gc’
[16:12:19.439]   - Field: ‘job’
[16:12:19.439]   - Field: ‘conditions’
[16:12:19.439]   - Field: ‘expr’
[16:12:19.439]   - Field: ‘uuid’
[16:12:19.440]   - Field: ‘seed’
[16:12:19.440]   - Field: ‘version’
[16:12:19.440]   - Field: ‘result’
[16:12:19.440]   - Field: ‘asynchronous’
[16:12:19.440]   - Field: ‘calls’
[16:12:19.440]   - Field: ‘globals’
[16:12:19.440]   - Field: ‘stdout’
[16:12:19.441]   - Field: ‘earlySignal’
[16:12:19.441]   - Field: ‘lazy’
[16:12:19.441]   - Field: ‘state’
[16:12:19.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.441] - Launch lazy future ...
[16:12:19.441] Packages needed by the future expression (n = 0): <none>
[16:12:19.441] Packages needed by future strategies (n = 0): <none>
[16:12:19.445] {
[16:12:19.445]     {
[16:12:19.445]         {
[16:12:19.445]             ...future.startTime <- base::Sys.time()
[16:12:19.445]             {
[16:12:19.445]                 {
[16:12:19.445]                   {
[16:12:19.445]                     {
[16:12:19.445]                       base::local({
[16:12:19.445]                         has_future <- base::requireNamespace("future", 
[16:12:19.445]                           quietly = TRUE)
[16:12:19.445]                         if (has_future) {
[16:12:19.445]                           ns <- base::getNamespace("future")
[16:12:19.445]                           version <- ns[[".package"]][["version"]]
[16:12:19.445]                           if (is.null(version)) 
[16:12:19.445]                             version <- utils::packageVersion("future")
[16:12:19.445]                         }
[16:12:19.445]                         else {
[16:12:19.445]                           version <- NULL
[16:12:19.445]                         }
[16:12:19.445]                         if (!has_future || version < "1.8.0") {
[16:12:19.445]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.445]                             "", base::R.version$version.string), 
[16:12:19.445]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.445]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.445]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.445]                               "release", "version")], collapse = " "), 
[16:12:19.445]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.445]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.445]                             info)
[16:12:19.445]                           info <- base::paste(info, collapse = "; ")
[16:12:19.445]                           if (!has_future) {
[16:12:19.445]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.445]                               info)
[16:12:19.445]                           }
[16:12:19.445]                           else {
[16:12:19.445]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.445]                               info, version)
[16:12:19.445]                           }
[16:12:19.445]                           base::stop(msg)
[16:12:19.445]                         }
[16:12:19.445]                       })
[16:12:19.445]                     }
[16:12:19.445]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.445]                     base::options(mc.cores = 1L)
[16:12:19.445]                   }
[16:12:19.445]                   options(future.plan = NULL)
[16:12:19.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.445]                 }
[16:12:19.445]                 ...future.workdir <- getwd()
[16:12:19.445]             }
[16:12:19.445]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.445]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.445]         }
[16:12:19.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.445]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.445]             base::names(...future.oldOptions))
[16:12:19.445]     }
[16:12:19.445]     if (FALSE) {
[16:12:19.445]     }
[16:12:19.445]     else {
[16:12:19.445]         if (TRUE) {
[16:12:19.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.445]                 open = "w")
[16:12:19.445]         }
[16:12:19.445]         else {
[16:12:19.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.445]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.445]         }
[16:12:19.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.445]             base::sink(type = "output", split = FALSE)
[16:12:19.445]             base::close(...future.stdout)
[16:12:19.445]         }, add = TRUE)
[16:12:19.445]     }
[16:12:19.445]     ...future.frame <- base::sys.nframe()
[16:12:19.445]     ...future.conditions <- base::list()
[16:12:19.445]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.445]     if (FALSE) {
[16:12:19.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.445]     }
[16:12:19.445]     ...future.result <- base::tryCatch({
[16:12:19.445]         base::withCallingHandlers({
[16:12:19.445]             ...future.value <- base::withVisible(base::local({
[16:12:19.445]                 withCallingHandlers({
[16:12:19.445]                   {
[16:12:19.445]                     2 * a
[16:12:19.445]                   }
[16:12:19.445]                 }, immediateCondition = function(cond) {
[16:12:19.445]                   save_rds <- function (object, pathname, ...) 
[16:12:19.445]                   {
[16:12:19.445]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.445]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.445]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.445]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.445]                         fi_tmp[["mtime"]])
[16:12:19.445]                     }
[16:12:19.445]                     tryCatch({
[16:12:19.445]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.445]                     }, error = function(ex) {
[16:12:19.445]                       msg <- conditionMessage(ex)
[16:12:19.445]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.445]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.445]                         fi_tmp[["mtime"]], msg)
[16:12:19.445]                       ex$message <- msg
[16:12:19.445]                       stop(ex)
[16:12:19.445]                     })
[16:12:19.445]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.445]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.445]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.445]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.445]                       fi <- file.info(pathname)
[16:12:19.445]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.445]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.445]                         fi[["size"]], fi[["mtime"]])
[16:12:19.445]                       stop(msg)
[16:12:19.445]                     }
[16:12:19.445]                     invisible(pathname)
[16:12:19.445]                   }
[16:12:19.445]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.445]                     rootPath = tempdir()) 
[16:12:19.445]                   {
[16:12:19.445]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.445]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.445]                       tmpdir = path, fileext = ".rds")
[16:12:19.445]                     save_rds(obj, file)
[16:12:19.445]                   }
[16:12:19.445]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.445]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.445]                   {
[16:12:19.445]                     inherits <- base::inherits
[16:12:19.445]                     invokeRestart <- base::invokeRestart
[16:12:19.445]                     is.null <- base::is.null
[16:12:19.445]                     muffled <- FALSE
[16:12:19.445]                     if (inherits(cond, "message")) {
[16:12:19.445]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.445]                       if (muffled) 
[16:12:19.445]                         invokeRestart("muffleMessage")
[16:12:19.445]                     }
[16:12:19.445]                     else if (inherits(cond, "warning")) {
[16:12:19.445]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.445]                       if (muffled) 
[16:12:19.445]                         invokeRestart("muffleWarning")
[16:12:19.445]                     }
[16:12:19.445]                     else if (inherits(cond, "condition")) {
[16:12:19.445]                       if (!is.null(pattern)) {
[16:12:19.445]                         computeRestarts <- base::computeRestarts
[16:12:19.445]                         grepl <- base::grepl
[16:12:19.445]                         restarts <- computeRestarts(cond)
[16:12:19.445]                         for (restart in restarts) {
[16:12:19.445]                           name <- restart$name
[16:12:19.445]                           if (is.null(name)) 
[16:12:19.445]                             next
[16:12:19.445]                           if (!grepl(pattern, name)) 
[16:12:19.445]                             next
[16:12:19.445]                           invokeRestart(restart)
[16:12:19.445]                           muffled <- TRUE
[16:12:19.445]                           break
[16:12:19.445]                         }
[16:12:19.445]                       }
[16:12:19.445]                     }
[16:12:19.445]                     invisible(muffled)
[16:12:19.445]                   }
[16:12:19.445]                   muffleCondition(cond)
[16:12:19.445]                 })
[16:12:19.445]             }))
[16:12:19.445]             future::FutureResult(value = ...future.value$value, 
[16:12:19.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.445]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.445]                     ...future.globalenv.names))
[16:12:19.445]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.445]         }, condition = base::local({
[16:12:19.445]             c <- base::c
[16:12:19.445]             inherits <- base::inherits
[16:12:19.445]             invokeRestart <- base::invokeRestart
[16:12:19.445]             length <- base::length
[16:12:19.445]             list <- base::list
[16:12:19.445]             seq.int <- base::seq.int
[16:12:19.445]             signalCondition <- base::signalCondition
[16:12:19.445]             sys.calls <- base::sys.calls
[16:12:19.445]             `[[` <- base::`[[`
[16:12:19.445]             `+` <- base::`+`
[16:12:19.445]             `<<-` <- base::`<<-`
[16:12:19.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.445]                   3L)]
[16:12:19.445]             }
[16:12:19.445]             function(cond) {
[16:12:19.445]                 is_error <- inherits(cond, "error")
[16:12:19.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.445]                   NULL)
[16:12:19.445]                 if (is_error) {
[16:12:19.445]                   sessionInformation <- function() {
[16:12:19.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.445]                       search = base::search(), system = base::Sys.info())
[16:12:19.445]                   }
[16:12:19.445]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.445]                     cond$call), session = sessionInformation(), 
[16:12:19.445]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.445]                   signalCondition(cond)
[16:12:19.445]                 }
[16:12:19.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.445]                 "immediateCondition"))) {
[16:12:19.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.445]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.445]                   if (TRUE && !signal) {
[16:12:19.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.445]                     {
[16:12:19.445]                       inherits <- base::inherits
[16:12:19.445]                       invokeRestart <- base::invokeRestart
[16:12:19.445]                       is.null <- base::is.null
[16:12:19.445]                       muffled <- FALSE
[16:12:19.445]                       if (inherits(cond, "message")) {
[16:12:19.445]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.445]                         if (muffled) 
[16:12:19.445]                           invokeRestart("muffleMessage")
[16:12:19.445]                       }
[16:12:19.445]                       else if (inherits(cond, "warning")) {
[16:12:19.445]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.445]                         if (muffled) 
[16:12:19.445]                           invokeRestart("muffleWarning")
[16:12:19.445]                       }
[16:12:19.445]                       else if (inherits(cond, "condition")) {
[16:12:19.445]                         if (!is.null(pattern)) {
[16:12:19.445]                           computeRestarts <- base::computeRestarts
[16:12:19.445]                           grepl <- base::grepl
[16:12:19.445]                           restarts <- computeRestarts(cond)
[16:12:19.445]                           for (restart in restarts) {
[16:12:19.445]                             name <- restart$name
[16:12:19.445]                             if (is.null(name)) 
[16:12:19.445]                               next
[16:12:19.445]                             if (!grepl(pattern, name)) 
[16:12:19.445]                               next
[16:12:19.445]                             invokeRestart(restart)
[16:12:19.445]                             muffled <- TRUE
[16:12:19.445]                             break
[16:12:19.445]                           }
[16:12:19.445]                         }
[16:12:19.445]                       }
[16:12:19.445]                       invisible(muffled)
[16:12:19.445]                     }
[16:12:19.445]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.445]                   }
[16:12:19.445]                 }
[16:12:19.445]                 else {
[16:12:19.445]                   if (TRUE) {
[16:12:19.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.445]                     {
[16:12:19.445]                       inherits <- base::inherits
[16:12:19.445]                       invokeRestart <- base::invokeRestart
[16:12:19.445]                       is.null <- base::is.null
[16:12:19.445]                       muffled <- FALSE
[16:12:19.445]                       if (inherits(cond, "message")) {
[16:12:19.445]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.445]                         if (muffled) 
[16:12:19.445]                           invokeRestart("muffleMessage")
[16:12:19.445]                       }
[16:12:19.445]                       else if (inherits(cond, "warning")) {
[16:12:19.445]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.445]                         if (muffled) 
[16:12:19.445]                           invokeRestart("muffleWarning")
[16:12:19.445]                       }
[16:12:19.445]                       else if (inherits(cond, "condition")) {
[16:12:19.445]                         if (!is.null(pattern)) {
[16:12:19.445]                           computeRestarts <- base::computeRestarts
[16:12:19.445]                           grepl <- base::grepl
[16:12:19.445]                           restarts <- computeRestarts(cond)
[16:12:19.445]                           for (restart in restarts) {
[16:12:19.445]                             name <- restart$name
[16:12:19.445]                             if (is.null(name)) 
[16:12:19.445]                               next
[16:12:19.445]                             if (!grepl(pattern, name)) 
[16:12:19.445]                               next
[16:12:19.445]                             invokeRestart(restart)
[16:12:19.445]                             muffled <- TRUE
[16:12:19.445]                             break
[16:12:19.445]                           }
[16:12:19.445]                         }
[16:12:19.445]                       }
[16:12:19.445]                       invisible(muffled)
[16:12:19.445]                     }
[16:12:19.445]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.445]                   }
[16:12:19.445]                 }
[16:12:19.445]             }
[16:12:19.445]         }))
[16:12:19.445]     }, error = function(ex) {
[16:12:19.445]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.445]                 ...future.rng), started = ...future.startTime, 
[16:12:19.445]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.445]             version = "1.8"), class = "FutureResult")
[16:12:19.445]     }, finally = {
[16:12:19.445]         if (!identical(...future.workdir, getwd())) 
[16:12:19.445]             setwd(...future.workdir)
[16:12:19.445]         {
[16:12:19.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.445]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.445]             }
[16:12:19.445]             base::options(...future.oldOptions)
[16:12:19.445]             if (.Platform$OS.type == "windows") {
[16:12:19.445]                 old_names <- names(...future.oldEnvVars)
[16:12:19.445]                 envs <- base::Sys.getenv()
[16:12:19.445]                 names <- names(envs)
[16:12:19.445]                 common <- intersect(names, old_names)
[16:12:19.445]                 added <- setdiff(names, old_names)
[16:12:19.445]                 removed <- setdiff(old_names, names)
[16:12:19.445]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.445]                   envs[common]]
[16:12:19.445]                 NAMES <- toupper(changed)
[16:12:19.445]                 args <- list()
[16:12:19.445]                 for (kk in seq_along(NAMES)) {
[16:12:19.445]                   name <- changed[[kk]]
[16:12:19.445]                   NAME <- NAMES[[kk]]
[16:12:19.445]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.445]                     next
[16:12:19.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.445]                 }
[16:12:19.445]                 NAMES <- toupper(added)
[16:12:19.445]                 for (kk in seq_along(NAMES)) {
[16:12:19.445]                   name <- added[[kk]]
[16:12:19.445]                   NAME <- NAMES[[kk]]
[16:12:19.445]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.445]                     next
[16:12:19.445]                   args[[name]] <- ""
[16:12:19.445]                 }
[16:12:19.445]                 NAMES <- toupper(removed)
[16:12:19.445]                 for (kk in seq_along(NAMES)) {
[16:12:19.445]                   name <- removed[[kk]]
[16:12:19.445]                   NAME <- NAMES[[kk]]
[16:12:19.445]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.445]                     next
[16:12:19.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.445]                 }
[16:12:19.445]                 if (length(args) > 0) 
[16:12:19.445]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.445]             }
[16:12:19.445]             else {
[16:12:19.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.445]             }
[16:12:19.445]             {
[16:12:19.445]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.445]                   0L) {
[16:12:19.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.445]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.445]                   base::options(opts)
[16:12:19.445]                 }
[16:12:19.445]                 {
[16:12:19.445]                   {
[16:12:19.445]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.445]                     NULL
[16:12:19.445]                   }
[16:12:19.445]                   options(future.plan = NULL)
[16:12:19.445]                   if (is.na(NA_character_)) 
[16:12:19.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.445]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.445]                     envir = parent.frame()) 
[16:12:19.445]                   {
[16:12:19.445]                     default_workers <- missing(workers)
[16:12:19.445]                     if (is.function(workers)) 
[16:12:19.445]                       workers <- workers()
[16:12:19.445]                     workers <- structure(as.integer(workers), 
[16:12:19.445]                       class = class(workers))
[16:12:19.445]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.445]                       1L)
[16:12:19.445]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.445]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.445]                       if (default_workers) 
[16:12:19.445]                         supportsMulticore(warn = TRUE)
[16:12:19.445]                       return(sequential(..., envir = envir))
[16:12:19.445]                     }
[16:12:19.445]                     oopts <- options(mc.cores = workers)
[16:12:19.445]                     on.exit(options(oopts))
[16:12:19.445]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.445]                       envir = envir)
[16:12:19.445]                     if (!future$lazy) 
[16:12:19.445]                       future <- run(future)
[16:12:19.445]                     invisible(future)
[16:12:19.445]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.445]                 }
[16:12:19.445]             }
[16:12:19.445]         }
[16:12:19.445]     })
[16:12:19.445]     if (TRUE) {
[16:12:19.445]         base::sink(type = "output", split = FALSE)
[16:12:19.445]         if (TRUE) {
[16:12:19.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.445]         }
[16:12:19.445]         else {
[16:12:19.445]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.445]         }
[16:12:19.445]         base::close(...future.stdout)
[16:12:19.445]         ...future.stdout <- NULL
[16:12:19.445]     }
[16:12:19.445]     ...future.result$conditions <- ...future.conditions
[16:12:19.445]     ...future.result$finished <- base::Sys.time()
[16:12:19.445]     ...future.result
[16:12:19.445] }
[16:12:19.447] assign_globals() ...
[16:12:19.447] List of 1
[16:12:19.447]  $ a: num 1
[16:12:19.447]  - attr(*, "where")=List of 1
[16:12:19.447]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.447]  - attr(*, "resolved")= logi FALSE
[16:12:19.447]  - attr(*, "total_size")= num 56
[16:12:19.447]  - attr(*, "already-done")= logi TRUE
[16:12:19.451] - copied ‘a’ to environment
[16:12:19.451] assign_globals() ... done
[16:12:19.451] requestCore(): workers = 2
[16:12:19.453] MulticoreFuture started
[16:12:19.454] - Launch lazy future ... done
[16:12:19.454] run() for ‘MulticoreFuture’ ... done
[16:12:19.454] plan(): Setting new future strategy stack:
[16:12:19.455] List of future strategies:
[16:12:19.455] 1. sequential:
[16:12:19.455]    - args: function (..., envir = parent.frame())
[16:12:19.455]    - tweaked: FALSE
[16:12:19.455]    - call: NULL
[16:12:19.456] plan(): nbrOfWorkers() = 1
[16:12:19.458] plan(): Setting new future strategy stack:
[16:12:19.458] List of future strategies:
[16:12:19.458] 1. multicore:
[16:12:19.458]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.458]    - tweaked: FALSE
[16:12:19.458]    - call: plan(strategy)
[16:12:19.463] plan(): nbrOfWorkers() = 2
[16:12:19.464] getGlobalsAndPackages() ...
[16:12:19.465] Searching for globals...
[16:12:19.467] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.467] Searching for globals ... DONE
[16:12:19.467] Resolving globals: FALSE
[16:12:19.468] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.468] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.468] - globals: [1] ‘a’
[16:12:19.468] 
[16:12:19.469] getGlobalsAndPackages() ... DONE
[16:12:19.469] run() for ‘Future’ ...
[16:12:19.469] - state: ‘created’
[16:12:19.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.473] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.474]   - Field: ‘label’
[16:12:19.474]   - Field: ‘local’
[16:12:19.474]   - Field: ‘owner’
[16:12:19.474]   - Field: ‘envir’
[16:12:19.474]   - Field: ‘workers’
[16:12:19.474]   - Field: ‘packages’
[16:12:19.475]   - Field: ‘gc’
[16:12:19.475]   - Field: ‘job’
[16:12:19.475]   - Field: ‘conditions’
[16:12:19.475]   - Field: ‘expr’
[16:12:19.475]   - Field: ‘uuid’
[16:12:19.475]   - Field: ‘seed’
[16:12:19.475]   - Field: ‘version’
[16:12:19.475]   - Field: ‘result’
[16:12:19.475]   - Field: ‘asynchronous’
[16:12:19.476]   - Field: ‘calls’
[16:12:19.476]   - Field: ‘globals’
[16:12:19.476]   - Field: ‘stdout’
[16:12:19.476]   - Field: ‘earlySignal’
[16:12:19.476]   - Field: ‘lazy’
[16:12:19.476]   - Field: ‘state’
[16:12:19.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.476] - Launch lazy future ...
[16:12:19.477] Packages needed by the future expression (n = 0): <none>
[16:12:19.477] Packages needed by future strategies (n = 0): <none>
[16:12:19.477] {
[16:12:19.477]     {
[16:12:19.477]         {
[16:12:19.477]             ...future.startTime <- base::Sys.time()
[16:12:19.477]             {
[16:12:19.477]                 {
[16:12:19.477]                   {
[16:12:19.477]                     {
[16:12:19.477]                       base::local({
[16:12:19.477]                         has_future <- base::requireNamespace("future", 
[16:12:19.477]                           quietly = TRUE)
[16:12:19.477]                         if (has_future) {
[16:12:19.477]                           ns <- base::getNamespace("future")
[16:12:19.477]                           version <- ns[[".package"]][["version"]]
[16:12:19.477]                           if (is.null(version)) 
[16:12:19.477]                             version <- utils::packageVersion("future")
[16:12:19.477]                         }
[16:12:19.477]                         else {
[16:12:19.477]                           version <- NULL
[16:12:19.477]                         }
[16:12:19.477]                         if (!has_future || version < "1.8.0") {
[16:12:19.477]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.477]                             "", base::R.version$version.string), 
[16:12:19.477]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.477]                               "release", "version")], collapse = " "), 
[16:12:19.477]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.477]                             info)
[16:12:19.477]                           info <- base::paste(info, collapse = "; ")
[16:12:19.477]                           if (!has_future) {
[16:12:19.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.477]                               info)
[16:12:19.477]                           }
[16:12:19.477]                           else {
[16:12:19.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.477]                               info, version)
[16:12:19.477]                           }
[16:12:19.477]                           base::stop(msg)
[16:12:19.477]                         }
[16:12:19.477]                       })
[16:12:19.477]                     }
[16:12:19.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.477]                     base::options(mc.cores = 1L)
[16:12:19.477]                   }
[16:12:19.477]                   options(future.plan = NULL)
[16:12:19.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.477]                 }
[16:12:19.477]                 ...future.workdir <- getwd()
[16:12:19.477]             }
[16:12:19.477]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.477]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.477]         }
[16:12:19.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.477]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.477]             base::names(...future.oldOptions))
[16:12:19.477]     }
[16:12:19.477]     if (FALSE) {
[16:12:19.477]     }
[16:12:19.477]     else {
[16:12:19.477]         if (TRUE) {
[16:12:19.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.477]                 open = "w")
[16:12:19.477]         }
[16:12:19.477]         else {
[16:12:19.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.477]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.477]         }
[16:12:19.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.477]             base::sink(type = "output", split = FALSE)
[16:12:19.477]             base::close(...future.stdout)
[16:12:19.477]         }, add = TRUE)
[16:12:19.477]     }
[16:12:19.477]     ...future.frame <- base::sys.nframe()
[16:12:19.477]     ...future.conditions <- base::list()
[16:12:19.477]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.477]     if (FALSE) {
[16:12:19.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.477]     }
[16:12:19.477]     ...future.result <- base::tryCatch({
[16:12:19.477]         base::withCallingHandlers({
[16:12:19.477]             ...future.value <- base::withVisible(base::local({
[16:12:19.477]                 withCallingHandlers({
[16:12:19.477]                   {
[16:12:19.477]                     2 * a
[16:12:19.477]                   }
[16:12:19.477]                 }, immediateCondition = function(cond) {
[16:12:19.477]                   save_rds <- function (object, pathname, ...) 
[16:12:19.477]                   {
[16:12:19.477]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.477]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.477]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.477]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.477]                         fi_tmp[["mtime"]])
[16:12:19.477]                     }
[16:12:19.477]                     tryCatch({
[16:12:19.477]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.477]                     }, error = function(ex) {
[16:12:19.477]                       msg <- conditionMessage(ex)
[16:12:19.477]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.477]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.477]                         fi_tmp[["mtime"]], msg)
[16:12:19.477]                       ex$message <- msg
[16:12:19.477]                       stop(ex)
[16:12:19.477]                     })
[16:12:19.477]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.477]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.477]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.477]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.477]                       fi <- file.info(pathname)
[16:12:19.477]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.477]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.477]                         fi[["size"]], fi[["mtime"]])
[16:12:19.477]                       stop(msg)
[16:12:19.477]                     }
[16:12:19.477]                     invisible(pathname)
[16:12:19.477]                   }
[16:12:19.477]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.477]                     rootPath = tempdir()) 
[16:12:19.477]                   {
[16:12:19.477]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.477]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.477]                       tmpdir = path, fileext = ".rds")
[16:12:19.477]                     save_rds(obj, file)
[16:12:19.477]                   }
[16:12:19.477]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.477]                   {
[16:12:19.477]                     inherits <- base::inherits
[16:12:19.477]                     invokeRestart <- base::invokeRestart
[16:12:19.477]                     is.null <- base::is.null
[16:12:19.477]                     muffled <- FALSE
[16:12:19.477]                     if (inherits(cond, "message")) {
[16:12:19.477]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.477]                       if (muffled) 
[16:12:19.477]                         invokeRestart("muffleMessage")
[16:12:19.477]                     }
[16:12:19.477]                     else if (inherits(cond, "warning")) {
[16:12:19.477]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.477]                       if (muffled) 
[16:12:19.477]                         invokeRestart("muffleWarning")
[16:12:19.477]                     }
[16:12:19.477]                     else if (inherits(cond, "condition")) {
[16:12:19.477]                       if (!is.null(pattern)) {
[16:12:19.477]                         computeRestarts <- base::computeRestarts
[16:12:19.477]                         grepl <- base::grepl
[16:12:19.477]                         restarts <- computeRestarts(cond)
[16:12:19.477]                         for (restart in restarts) {
[16:12:19.477]                           name <- restart$name
[16:12:19.477]                           if (is.null(name)) 
[16:12:19.477]                             next
[16:12:19.477]                           if (!grepl(pattern, name)) 
[16:12:19.477]                             next
[16:12:19.477]                           invokeRestart(restart)
[16:12:19.477]                           muffled <- TRUE
[16:12:19.477]                           break
[16:12:19.477]                         }
[16:12:19.477]                       }
[16:12:19.477]                     }
[16:12:19.477]                     invisible(muffled)
[16:12:19.477]                   }
[16:12:19.477]                   muffleCondition(cond)
[16:12:19.477]                 })
[16:12:19.477]             }))
[16:12:19.477]             future::FutureResult(value = ...future.value$value, 
[16:12:19.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.477]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.477]                     ...future.globalenv.names))
[16:12:19.477]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.477]         }, condition = base::local({
[16:12:19.477]             c <- base::c
[16:12:19.477]             inherits <- base::inherits
[16:12:19.477]             invokeRestart <- base::invokeRestart
[16:12:19.477]             length <- base::length
[16:12:19.477]             list <- base::list
[16:12:19.477]             seq.int <- base::seq.int
[16:12:19.477]             signalCondition <- base::signalCondition
[16:12:19.477]             sys.calls <- base::sys.calls
[16:12:19.477]             `[[` <- base::`[[`
[16:12:19.477]             `+` <- base::`+`
[16:12:19.477]             `<<-` <- base::`<<-`
[16:12:19.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.477]                   3L)]
[16:12:19.477]             }
[16:12:19.477]             function(cond) {
[16:12:19.477]                 is_error <- inherits(cond, "error")
[16:12:19.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.477]                   NULL)
[16:12:19.477]                 if (is_error) {
[16:12:19.477]                   sessionInformation <- function() {
[16:12:19.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.477]                       search = base::search(), system = base::Sys.info())
[16:12:19.477]                   }
[16:12:19.477]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.477]                     cond$call), session = sessionInformation(), 
[16:12:19.477]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.477]                   signalCondition(cond)
[16:12:19.477]                 }
[16:12:19.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.477]                 "immediateCondition"))) {
[16:12:19.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.477]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.477]                   if (TRUE && !signal) {
[16:12:19.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.477]                     {
[16:12:19.477]                       inherits <- base::inherits
[16:12:19.477]                       invokeRestart <- base::invokeRestart
[16:12:19.477]                       is.null <- base::is.null
[16:12:19.477]                       muffled <- FALSE
[16:12:19.477]                       if (inherits(cond, "message")) {
[16:12:19.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.477]                         if (muffled) 
[16:12:19.477]                           invokeRestart("muffleMessage")
[16:12:19.477]                       }
[16:12:19.477]                       else if (inherits(cond, "warning")) {
[16:12:19.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.477]                         if (muffled) 
[16:12:19.477]                           invokeRestart("muffleWarning")
[16:12:19.477]                       }
[16:12:19.477]                       else if (inherits(cond, "condition")) {
[16:12:19.477]                         if (!is.null(pattern)) {
[16:12:19.477]                           computeRestarts <- base::computeRestarts
[16:12:19.477]                           grepl <- base::grepl
[16:12:19.477]                           restarts <- computeRestarts(cond)
[16:12:19.477]                           for (restart in restarts) {
[16:12:19.477]                             name <- restart$name
[16:12:19.477]                             if (is.null(name)) 
[16:12:19.477]                               next
[16:12:19.477]                             if (!grepl(pattern, name)) 
[16:12:19.477]                               next
[16:12:19.477]                             invokeRestart(restart)
[16:12:19.477]                             muffled <- TRUE
[16:12:19.477]                             break
[16:12:19.477]                           }
[16:12:19.477]                         }
[16:12:19.477]                       }
[16:12:19.477]                       invisible(muffled)
[16:12:19.477]                     }
[16:12:19.477]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.477]                   }
[16:12:19.477]                 }
[16:12:19.477]                 else {
[16:12:19.477]                   if (TRUE) {
[16:12:19.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.477]                     {
[16:12:19.477]                       inherits <- base::inherits
[16:12:19.477]                       invokeRestart <- base::invokeRestart
[16:12:19.477]                       is.null <- base::is.null
[16:12:19.477]                       muffled <- FALSE
[16:12:19.477]                       if (inherits(cond, "message")) {
[16:12:19.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.477]                         if (muffled) 
[16:12:19.477]                           invokeRestart("muffleMessage")
[16:12:19.477]                       }
[16:12:19.477]                       else if (inherits(cond, "warning")) {
[16:12:19.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.477]                         if (muffled) 
[16:12:19.477]                           invokeRestart("muffleWarning")
[16:12:19.477]                       }
[16:12:19.477]                       else if (inherits(cond, "condition")) {
[16:12:19.477]                         if (!is.null(pattern)) {
[16:12:19.477]                           computeRestarts <- base::computeRestarts
[16:12:19.477]                           grepl <- base::grepl
[16:12:19.477]                           restarts <- computeRestarts(cond)
[16:12:19.477]                           for (restart in restarts) {
[16:12:19.477]                             name <- restart$name
[16:12:19.477]                             if (is.null(name)) 
[16:12:19.477]                               next
[16:12:19.477]                             if (!grepl(pattern, name)) 
[16:12:19.477]                               next
[16:12:19.477]                             invokeRestart(restart)
[16:12:19.477]                             muffled <- TRUE
[16:12:19.477]                             break
[16:12:19.477]                           }
[16:12:19.477]                         }
[16:12:19.477]                       }
[16:12:19.477]                       invisible(muffled)
[16:12:19.477]                     }
[16:12:19.477]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.477]                   }
[16:12:19.477]                 }
[16:12:19.477]             }
[16:12:19.477]         }))
[16:12:19.477]     }, error = function(ex) {
[16:12:19.477]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.477]                 ...future.rng), started = ...future.startTime, 
[16:12:19.477]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.477]             version = "1.8"), class = "FutureResult")
[16:12:19.477]     }, finally = {
[16:12:19.477]         if (!identical(...future.workdir, getwd())) 
[16:12:19.477]             setwd(...future.workdir)
[16:12:19.477]         {
[16:12:19.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.477]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.477]             }
[16:12:19.477]             base::options(...future.oldOptions)
[16:12:19.477]             if (.Platform$OS.type == "windows") {
[16:12:19.477]                 old_names <- names(...future.oldEnvVars)
[16:12:19.477]                 envs <- base::Sys.getenv()
[16:12:19.477]                 names <- names(envs)
[16:12:19.477]                 common <- intersect(names, old_names)
[16:12:19.477]                 added <- setdiff(names, old_names)
[16:12:19.477]                 removed <- setdiff(old_names, names)
[16:12:19.477]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.477]                   envs[common]]
[16:12:19.477]                 NAMES <- toupper(changed)
[16:12:19.477]                 args <- list()
[16:12:19.477]                 for (kk in seq_along(NAMES)) {
[16:12:19.477]                   name <- changed[[kk]]
[16:12:19.477]                   NAME <- NAMES[[kk]]
[16:12:19.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.477]                     next
[16:12:19.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.477]                 }
[16:12:19.477]                 NAMES <- toupper(added)
[16:12:19.477]                 for (kk in seq_along(NAMES)) {
[16:12:19.477]                   name <- added[[kk]]
[16:12:19.477]                   NAME <- NAMES[[kk]]
[16:12:19.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.477]                     next
[16:12:19.477]                   args[[name]] <- ""
[16:12:19.477]                 }
[16:12:19.477]                 NAMES <- toupper(removed)
[16:12:19.477]                 for (kk in seq_along(NAMES)) {
[16:12:19.477]                   name <- removed[[kk]]
[16:12:19.477]                   NAME <- NAMES[[kk]]
[16:12:19.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.477]                     next
[16:12:19.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.477]                 }
[16:12:19.477]                 if (length(args) > 0) 
[16:12:19.477]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.477]             }
[16:12:19.477]             else {
[16:12:19.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.477]             }
[16:12:19.477]             {
[16:12:19.477]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.477]                   0L) {
[16:12:19.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.477]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.477]                   base::options(opts)
[16:12:19.477]                 }
[16:12:19.477]                 {
[16:12:19.477]                   {
[16:12:19.477]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.477]                     NULL
[16:12:19.477]                   }
[16:12:19.477]                   options(future.plan = NULL)
[16:12:19.477]                   if (is.na(NA_character_)) 
[16:12:19.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.477]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.477]                     envir = parent.frame()) 
[16:12:19.477]                   {
[16:12:19.477]                     default_workers <- missing(workers)
[16:12:19.477]                     if (is.function(workers)) 
[16:12:19.477]                       workers <- workers()
[16:12:19.477]                     workers <- structure(as.integer(workers), 
[16:12:19.477]                       class = class(workers))
[16:12:19.477]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.477]                       1L)
[16:12:19.477]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.477]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.477]                       if (default_workers) 
[16:12:19.477]                         supportsMulticore(warn = TRUE)
[16:12:19.477]                       return(sequential(..., envir = envir))
[16:12:19.477]                     }
[16:12:19.477]                     oopts <- options(mc.cores = workers)
[16:12:19.477]                     on.exit(options(oopts))
[16:12:19.477]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.477]                       envir = envir)
[16:12:19.477]                     if (!future$lazy) 
[16:12:19.477]                       future <- run(future)
[16:12:19.477]                     invisible(future)
[16:12:19.477]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.477]                 }
[16:12:19.477]             }
[16:12:19.477]         }
[16:12:19.477]     })
[16:12:19.477]     if (TRUE) {
[16:12:19.477]         base::sink(type = "output", split = FALSE)
[16:12:19.477]         if (TRUE) {
[16:12:19.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.477]         }
[16:12:19.477]         else {
[16:12:19.477]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.477]         }
[16:12:19.477]         base::close(...future.stdout)
[16:12:19.477]         ...future.stdout <- NULL
[16:12:19.477]     }
[16:12:19.477]     ...future.result$conditions <- ...future.conditions
[16:12:19.477]     ...future.result$finished <- base::Sys.time()
[16:12:19.477]     ...future.result
[16:12:19.477] }
[16:12:19.480] assign_globals() ...
[16:12:19.480] List of 1
[16:12:19.480]  $ a: num 1
[16:12:19.480]  - attr(*, "where")=List of 1
[16:12:19.480]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.480]  - attr(*, "resolved")= logi FALSE
[16:12:19.480]  - attr(*, "total_size")= num 56
[16:12:19.480]  - attr(*, "already-done")= logi TRUE
[16:12:19.484] - copied ‘a’ to environment
[16:12:19.484] assign_globals() ... done
[16:12:19.484] requestCore(): workers = 2
[16:12:19.486] MulticoreFuture started
[16:12:19.486] - Launch lazy future ... done
[16:12:19.486] run() for ‘MulticoreFuture’ ... done
[16:12:19.487] plan(): Setting new future strategy stack:
[16:12:19.487] List of future strategies:
[16:12:19.487] 1. sequential:
[16:12:19.487]    - args: function (..., envir = parent.frame())
[16:12:19.487]    - tweaked: FALSE
[16:12:19.487]    - call: NULL
[16:12:19.488] plan(): nbrOfWorkers() = 1
[16:12:19.490] plan(): Setting new future strategy stack:
[16:12:19.490] List of future strategies:
[16:12:19.490] 1. multicore:
[16:12:19.490]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.490]    - tweaked: FALSE
[16:12:19.490]    - call: plan(strategy)
[16:12:19.495] plan(): nbrOfWorkers() = 2
[16:12:19.496] getGlobalsAndPackages() ...
[16:12:19.496] Searching for globals...
[16:12:19.498] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.498] Searching for globals ... DONE
[16:12:19.498] Resolving globals: FALSE
[16:12:19.499] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.499] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.500] - globals: [1] ‘a’
[16:12:19.500] 
[16:12:19.500] getGlobalsAndPackages() ... DONE
[16:12:19.500] run() for ‘Future’ ...
[16:12:19.500] - state: ‘created’
[16:12:19.501] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.505] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.505] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.506]   - Field: ‘label’
[16:12:19.506]   - Field: ‘local’
[16:12:19.506]   - Field: ‘owner’
[16:12:19.506]   - Field: ‘envir’
[16:12:19.506]   - Field: ‘workers’
[16:12:19.507]   - Field: ‘packages’
[16:12:19.507]   - Field: ‘gc’
[16:12:19.507]   - Field: ‘job’
[16:12:19.507]   - Field: ‘conditions’
[16:12:19.507]   - Field: ‘expr’
[16:12:19.507]   - Field: ‘uuid’
[16:12:19.507]   - Field: ‘seed’
[16:12:19.508]   - Field: ‘version’
[16:12:19.508]   - Field: ‘result’
[16:12:19.508]   - Field: ‘asynchronous’
[16:12:19.508]   - Field: ‘calls’
[16:12:19.508]   - Field: ‘globals’
[16:12:19.508]   - Field: ‘stdout’
[16:12:19.508]   - Field: ‘earlySignal’
[16:12:19.508]   - Field: ‘lazy’
[16:12:19.508]   - Field: ‘state’
[16:12:19.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.509] - Launch lazy future ...
[16:12:19.509] Packages needed by the future expression (n = 0): <none>
[16:12:19.509] Packages needed by future strategies (n = 0): <none>
[16:12:19.510] {
[16:12:19.510]     {
[16:12:19.510]         {
[16:12:19.510]             ...future.startTime <- base::Sys.time()
[16:12:19.510]             {
[16:12:19.510]                 {
[16:12:19.510]                   {
[16:12:19.510]                     {
[16:12:19.510]                       base::local({
[16:12:19.510]                         has_future <- base::requireNamespace("future", 
[16:12:19.510]                           quietly = TRUE)
[16:12:19.510]                         if (has_future) {
[16:12:19.510]                           ns <- base::getNamespace("future")
[16:12:19.510]                           version <- ns[[".package"]][["version"]]
[16:12:19.510]                           if (is.null(version)) 
[16:12:19.510]                             version <- utils::packageVersion("future")
[16:12:19.510]                         }
[16:12:19.510]                         else {
[16:12:19.510]                           version <- NULL
[16:12:19.510]                         }
[16:12:19.510]                         if (!has_future || version < "1.8.0") {
[16:12:19.510]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.510]                             "", base::R.version$version.string), 
[16:12:19.510]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.510]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.510]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.510]                               "release", "version")], collapse = " "), 
[16:12:19.510]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.510]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.510]                             info)
[16:12:19.510]                           info <- base::paste(info, collapse = "; ")
[16:12:19.510]                           if (!has_future) {
[16:12:19.510]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.510]                               info)
[16:12:19.510]                           }
[16:12:19.510]                           else {
[16:12:19.510]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.510]                               info, version)
[16:12:19.510]                           }
[16:12:19.510]                           base::stop(msg)
[16:12:19.510]                         }
[16:12:19.510]                       })
[16:12:19.510]                     }
[16:12:19.510]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.510]                     base::options(mc.cores = 1L)
[16:12:19.510]                   }
[16:12:19.510]                   options(future.plan = NULL)
[16:12:19.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.510]                 }
[16:12:19.510]                 ...future.workdir <- getwd()
[16:12:19.510]             }
[16:12:19.510]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.510]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.510]         }
[16:12:19.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.510]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.510]             base::names(...future.oldOptions))
[16:12:19.510]     }
[16:12:19.510]     if (FALSE) {
[16:12:19.510]     }
[16:12:19.510]     else {
[16:12:19.510]         if (TRUE) {
[16:12:19.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.510]                 open = "w")
[16:12:19.510]         }
[16:12:19.510]         else {
[16:12:19.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.510]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.510]         }
[16:12:19.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.510]             base::sink(type = "output", split = FALSE)
[16:12:19.510]             base::close(...future.stdout)
[16:12:19.510]         }, add = TRUE)
[16:12:19.510]     }
[16:12:19.510]     ...future.frame <- base::sys.nframe()
[16:12:19.510]     ...future.conditions <- base::list()
[16:12:19.510]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.510]     if (FALSE) {
[16:12:19.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.510]     }
[16:12:19.510]     ...future.result <- base::tryCatch({
[16:12:19.510]         base::withCallingHandlers({
[16:12:19.510]             ...future.value <- base::withVisible(base::local({
[16:12:19.510]                 withCallingHandlers({
[16:12:19.510]                   {
[16:12:19.510]                     2 * a
[16:12:19.510]                   }
[16:12:19.510]                 }, immediateCondition = function(cond) {
[16:12:19.510]                   save_rds <- function (object, pathname, ...) 
[16:12:19.510]                   {
[16:12:19.510]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.510]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.510]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.510]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.510]                         fi_tmp[["mtime"]])
[16:12:19.510]                     }
[16:12:19.510]                     tryCatch({
[16:12:19.510]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.510]                     }, error = function(ex) {
[16:12:19.510]                       msg <- conditionMessage(ex)
[16:12:19.510]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.510]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.510]                         fi_tmp[["mtime"]], msg)
[16:12:19.510]                       ex$message <- msg
[16:12:19.510]                       stop(ex)
[16:12:19.510]                     })
[16:12:19.510]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.510]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.510]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.510]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.510]                       fi <- file.info(pathname)
[16:12:19.510]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.510]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.510]                         fi[["size"]], fi[["mtime"]])
[16:12:19.510]                       stop(msg)
[16:12:19.510]                     }
[16:12:19.510]                     invisible(pathname)
[16:12:19.510]                   }
[16:12:19.510]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.510]                     rootPath = tempdir()) 
[16:12:19.510]                   {
[16:12:19.510]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.510]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.510]                       tmpdir = path, fileext = ".rds")
[16:12:19.510]                     save_rds(obj, file)
[16:12:19.510]                   }
[16:12:19.510]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.510]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.510]                   {
[16:12:19.510]                     inherits <- base::inherits
[16:12:19.510]                     invokeRestart <- base::invokeRestart
[16:12:19.510]                     is.null <- base::is.null
[16:12:19.510]                     muffled <- FALSE
[16:12:19.510]                     if (inherits(cond, "message")) {
[16:12:19.510]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.510]                       if (muffled) 
[16:12:19.510]                         invokeRestart("muffleMessage")
[16:12:19.510]                     }
[16:12:19.510]                     else if (inherits(cond, "warning")) {
[16:12:19.510]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.510]                       if (muffled) 
[16:12:19.510]                         invokeRestart("muffleWarning")
[16:12:19.510]                     }
[16:12:19.510]                     else if (inherits(cond, "condition")) {
[16:12:19.510]                       if (!is.null(pattern)) {
[16:12:19.510]                         computeRestarts <- base::computeRestarts
[16:12:19.510]                         grepl <- base::grepl
[16:12:19.510]                         restarts <- computeRestarts(cond)
[16:12:19.510]                         for (restart in restarts) {
[16:12:19.510]                           name <- restart$name
[16:12:19.510]                           if (is.null(name)) 
[16:12:19.510]                             next
[16:12:19.510]                           if (!grepl(pattern, name)) 
[16:12:19.510]                             next
[16:12:19.510]                           invokeRestart(restart)
[16:12:19.510]                           muffled <- TRUE
[16:12:19.510]                           break
[16:12:19.510]                         }
[16:12:19.510]                       }
[16:12:19.510]                     }
[16:12:19.510]                     invisible(muffled)
[16:12:19.510]                   }
[16:12:19.510]                   muffleCondition(cond)
[16:12:19.510]                 })
[16:12:19.510]             }))
[16:12:19.510]             future::FutureResult(value = ...future.value$value, 
[16:12:19.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.510]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.510]                     ...future.globalenv.names))
[16:12:19.510]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.510]         }, condition = base::local({
[16:12:19.510]             c <- base::c
[16:12:19.510]             inherits <- base::inherits
[16:12:19.510]             invokeRestart <- base::invokeRestart
[16:12:19.510]             length <- base::length
[16:12:19.510]             list <- base::list
[16:12:19.510]             seq.int <- base::seq.int
[16:12:19.510]             signalCondition <- base::signalCondition
[16:12:19.510]             sys.calls <- base::sys.calls
[16:12:19.510]             `[[` <- base::`[[`
[16:12:19.510]             `+` <- base::`+`
[16:12:19.510]             `<<-` <- base::`<<-`
[16:12:19.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.510]                   3L)]
[16:12:19.510]             }
[16:12:19.510]             function(cond) {
[16:12:19.510]                 is_error <- inherits(cond, "error")
[16:12:19.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.510]                   NULL)
[16:12:19.510]                 if (is_error) {
[16:12:19.510]                   sessionInformation <- function() {
[16:12:19.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.510]                       search = base::search(), system = base::Sys.info())
[16:12:19.510]                   }
[16:12:19.510]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.510]                     cond$call), session = sessionInformation(), 
[16:12:19.510]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.510]                   signalCondition(cond)
[16:12:19.510]                 }
[16:12:19.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.510]                 "immediateCondition"))) {
[16:12:19.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.510]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.510]                   if (TRUE && !signal) {
[16:12:19.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.510]                     {
[16:12:19.510]                       inherits <- base::inherits
[16:12:19.510]                       invokeRestart <- base::invokeRestart
[16:12:19.510]                       is.null <- base::is.null
[16:12:19.510]                       muffled <- FALSE
[16:12:19.510]                       if (inherits(cond, "message")) {
[16:12:19.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.510]                         if (muffled) 
[16:12:19.510]                           invokeRestart("muffleMessage")
[16:12:19.510]                       }
[16:12:19.510]                       else if (inherits(cond, "warning")) {
[16:12:19.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.510]                         if (muffled) 
[16:12:19.510]                           invokeRestart("muffleWarning")
[16:12:19.510]                       }
[16:12:19.510]                       else if (inherits(cond, "condition")) {
[16:12:19.510]                         if (!is.null(pattern)) {
[16:12:19.510]                           computeRestarts <- base::computeRestarts
[16:12:19.510]                           grepl <- base::grepl
[16:12:19.510]                           restarts <- computeRestarts(cond)
[16:12:19.510]                           for (restart in restarts) {
[16:12:19.510]                             name <- restart$name
[16:12:19.510]                             if (is.null(name)) 
[16:12:19.510]                               next
[16:12:19.510]                             if (!grepl(pattern, name)) 
[16:12:19.510]                               next
[16:12:19.510]                             invokeRestart(restart)
[16:12:19.510]                             muffled <- TRUE
[16:12:19.510]                             break
[16:12:19.510]                           }
[16:12:19.510]                         }
[16:12:19.510]                       }
[16:12:19.510]                       invisible(muffled)
[16:12:19.510]                     }
[16:12:19.510]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.510]                   }
[16:12:19.510]                 }
[16:12:19.510]                 else {
[16:12:19.510]                   if (TRUE) {
[16:12:19.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.510]                     {
[16:12:19.510]                       inherits <- base::inherits
[16:12:19.510]                       invokeRestart <- base::invokeRestart
[16:12:19.510]                       is.null <- base::is.null
[16:12:19.510]                       muffled <- FALSE
[16:12:19.510]                       if (inherits(cond, "message")) {
[16:12:19.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.510]                         if (muffled) 
[16:12:19.510]                           invokeRestart("muffleMessage")
[16:12:19.510]                       }
[16:12:19.510]                       else if (inherits(cond, "warning")) {
[16:12:19.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.510]                         if (muffled) 
[16:12:19.510]                           invokeRestart("muffleWarning")
[16:12:19.510]                       }
[16:12:19.510]                       else if (inherits(cond, "condition")) {
[16:12:19.510]                         if (!is.null(pattern)) {
[16:12:19.510]                           computeRestarts <- base::computeRestarts
[16:12:19.510]                           grepl <- base::grepl
[16:12:19.510]                           restarts <- computeRestarts(cond)
[16:12:19.510]                           for (restart in restarts) {
[16:12:19.510]                             name <- restart$name
[16:12:19.510]                             if (is.null(name)) 
[16:12:19.510]                               next
[16:12:19.510]                             if (!grepl(pattern, name)) 
[16:12:19.510]                               next
[16:12:19.510]                             invokeRestart(restart)
[16:12:19.510]                             muffled <- TRUE
[16:12:19.510]                             break
[16:12:19.510]                           }
[16:12:19.510]                         }
[16:12:19.510]                       }
[16:12:19.510]                       invisible(muffled)
[16:12:19.510]                     }
[16:12:19.510]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.510]                   }
[16:12:19.510]                 }
[16:12:19.510]             }
[16:12:19.510]         }))
[16:12:19.510]     }, error = function(ex) {
[16:12:19.510]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.510]                 ...future.rng), started = ...future.startTime, 
[16:12:19.510]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.510]             version = "1.8"), class = "FutureResult")
[16:12:19.510]     }, finally = {
[16:12:19.510]         if (!identical(...future.workdir, getwd())) 
[16:12:19.510]             setwd(...future.workdir)
[16:12:19.510]         {
[16:12:19.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.510]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.510]             }
[16:12:19.510]             base::options(...future.oldOptions)
[16:12:19.510]             if (.Platform$OS.type == "windows") {
[16:12:19.510]                 old_names <- names(...future.oldEnvVars)
[16:12:19.510]                 envs <- base::Sys.getenv()
[16:12:19.510]                 names <- names(envs)
[16:12:19.510]                 common <- intersect(names, old_names)
[16:12:19.510]                 added <- setdiff(names, old_names)
[16:12:19.510]                 removed <- setdiff(old_names, names)
[16:12:19.510]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.510]                   envs[common]]
[16:12:19.510]                 NAMES <- toupper(changed)
[16:12:19.510]                 args <- list()
[16:12:19.510]                 for (kk in seq_along(NAMES)) {
[16:12:19.510]                   name <- changed[[kk]]
[16:12:19.510]                   NAME <- NAMES[[kk]]
[16:12:19.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.510]                     next
[16:12:19.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.510]                 }
[16:12:19.510]                 NAMES <- toupper(added)
[16:12:19.510]                 for (kk in seq_along(NAMES)) {
[16:12:19.510]                   name <- added[[kk]]
[16:12:19.510]                   NAME <- NAMES[[kk]]
[16:12:19.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.510]                     next
[16:12:19.510]                   args[[name]] <- ""
[16:12:19.510]                 }
[16:12:19.510]                 NAMES <- toupper(removed)
[16:12:19.510]                 for (kk in seq_along(NAMES)) {
[16:12:19.510]                   name <- removed[[kk]]
[16:12:19.510]                   NAME <- NAMES[[kk]]
[16:12:19.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.510]                     next
[16:12:19.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.510]                 }
[16:12:19.510]                 if (length(args) > 0) 
[16:12:19.510]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.510]             }
[16:12:19.510]             else {
[16:12:19.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.510]             }
[16:12:19.510]             {
[16:12:19.510]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.510]                   0L) {
[16:12:19.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.510]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.510]                   base::options(opts)
[16:12:19.510]                 }
[16:12:19.510]                 {
[16:12:19.510]                   {
[16:12:19.510]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.510]                     NULL
[16:12:19.510]                   }
[16:12:19.510]                   options(future.plan = NULL)
[16:12:19.510]                   if (is.na(NA_character_)) 
[16:12:19.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.510]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.510]                     envir = parent.frame()) 
[16:12:19.510]                   {
[16:12:19.510]                     default_workers <- missing(workers)
[16:12:19.510]                     if (is.function(workers)) 
[16:12:19.510]                       workers <- workers()
[16:12:19.510]                     workers <- structure(as.integer(workers), 
[16:12:19.510]                       class = class(workers))
[16:12:19.510]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.510]                       1L)
[16:12:19.510]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.510]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.510]                       if (default_workers) 
[16:12:19.510]                         supportsMulticore(warn = TRUE)
[16:12:19.510]                       return(sequential(..., envir = envir))
[16:12:19.510]                     }
[16:12:19.510]                     oopts <- options(mc.cores = workers)
[16:12:19.510]                     on.exit(options(oopts))
[16:12:19.510]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.510]                       envir = envir)
[16:12:19.510]                     if (!future$lazy) 
[16:12:19.510]                       future <- run(future)
[16:12:19.510]                     invisible(future)
[16:12:19.510]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.510]                 }
[16:12:19.510]             }
[16:12:19.510]         }
[16:12:19.510]     })
[16:12:19.510]     if (TRUE) {
[16:12:19.510]         base::sink(type = "output", split = FALSE)
[16:12:19.510]         if (TRUE) {
[16:12:19.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.510]         }
[16:12:19.510]         else {
[16:12:19.510]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.510]         }
[16:12:19.510]         base::close(...future.stdout)
[16:12:19.510]         ...future.stdout <- NULL
[16:12:19.510]     }
[16:12:19.510]     ...future.result$conditions <- ...future.conditions
[16:12:19.510]     ...future.result$finished <- base::Sys.time()
[16:12:19.510]     ...future.result
[16:12:19.510] }
[16:12:19.512] assign_globals() ...
[16:12:19.513] List of 1
[16:12:19.513]  $ a: num 1
[16:12:19.513]  - attr(*, "where")=List of 1
[16:12:19.513]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.513]  - attr(*, "resolved")= logi FALSE
[16:12:19.513]  - attr(*, "total_size")= num 56
[16:12:19.513]  - attr(*, "already-done")= logi TRUE
[16:12:19.518] - copied ‘a’ to environment
[16:12:19.519] assign_globals() ... done
[16:12:19.519] requestCore(): workers = 2
[16:12:19.521] MulticoreFuture started
[16:12:19.521] - Launch lazy future ... done
[16:12:19.522] run() for ‘MulticoreFuture’ ... done
[16:12:19.522] plan(): Setting new future strategy stack:
[16:12:19.522] List of future strategies:
[16:12:19.522] 1. sequential:
[16:12:19.522]    - args: function (..., envir = parent.frame())
[16:12:19.522]    - tweaked: FALSE
[16:12:19.522]    - call: NULL
[16:12:19.523] plan(): nbrOfWorkers() = 1
[16:12:19.525] plan(): Setting new future strategy stack:
[16:12:19.525] List of future strategies:
[16:12:19.525] 1. multicore:
[16:12:19.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.525]    - tweaked: FALSE
[16:12:19.525]    - call: plan(strategy)
[16:12:19.531] plan(): nbrOfWorkers() = 2
[16:12:19.532] getGlobalsAndPackages() ...
[16:12:19.533] Searching for globals...
[16:12:19.534] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:19.534] Searching for globals ... DONE
[16:12:19.535] Resolving globals: FALSE
[16:12:19.535] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:19.536] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:19.536] - globals: [1] ‘a’
[16:12:19.536] 
[16:12:19.536] getGlobalsAndPackages() ... DONE
[16:12:19.536] run() for ‘Future’ ...
[16:12:19.537] - state: ‘created’
[16:12:19.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:19.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:19.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:19.541]   - Field: ‘label’
[16:12:19.541]   - Field: ‘local’
[16:12:19.542]   - Field: ‘owner’
[16:12:19.542]   - Field: ‘envir’
[16:12:19.542]   - Field: ‘workers’
[16:12:19.542]   - Field: ‘packages’
[16:12:19.542]   - Field: ‘gc’
[16:12:19.542]   - Field: ‘job’
[16:12:19.542]   - Field: ‘conditions’
[16:12:19.543]   - Field: ‘expr’
[16:12:19.543]   - Field: ‘uuid’
[16:12:19.543]   - Field: ‘seed’
[16:12:19.543]   - Field: ‘version’
[16:12:19.543]   - Field: ‘result’
[16:12:19.543]   - Field: ‘asynchronous’
[16:12:19.543]   - Field: ‘calls’
[16:12:19.543]   - Field: ‘globals’
[16:12:19.543]   - Field: ‘stdout’
[16:12:19.544]   - Field: ‘earlySignal’
[16:12:19.544]   - Field: ‘lazy’
[16:12:19.544]   - Field: ‘state’
[16:12:19.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:19.544] - Launch lazy future ...
[16:12:19.544] Packages needed by the future expression (n = 0): <none>
[16:12:19.545] Packages needed by future strategies (n = 0): <none>
[16:12:19.545] {
[16:12:19.545]     {
[16:12:19.545]         {
[16:12:19.545]             ...future.startTime <- base::Sys.time()
[16:12:19.545]             {
[16:12:19.545]                 {
[16:12:19.545]                   {
[16:12:19.545]                     {
[16:12:19.545]                       base::local({
[16:12:19.545]                         has_future <- base::requireNamespace("future", 
[16:12:19.545]                           quietly = TRUE)
[16:12:19.545]                         if (has_future) {
[16:12:19.545]                           ns <- base::getNamespace("future")
[16:12:19.545]                           version <- ns[[".package"]][["version"]]
[16:12:19.545]                           if (is.null(version)) 
[16:12:19.545]                             version <- utils::packageVersion("future")
[16:12:19.545]                         }
[16:12:19.545]                         else {
[16:12:19.545]                           version <- NULL
[16:12:19.545]                         }
[16:12:19.545]                         if (!has_future || version < "1.8.0") {
[16:12:19.545]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:19.545]                             "", base::R.version$version.string), 
[16:12:19.545]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:19.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:19.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:19.545]                               "release", "version")], collapse = " "), 
[16:12:19.545]                             hostname = base::Sys.info()[["nodename"]])
[16:12:19.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:19.545]                             info)
[16:12:19.545]                           info <- base::paste(info, collapse = "; ")
[16:12:19.545]                           if (!has_future) {
[16:12:19.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:19.545]                               info)
[16:12:19.545]                           }
[16:12:19.545]                           else {
[16:12:19.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:19.545]                               info, version)
[16:12:19.545]                           }
[16:12:19.545]                           base::stop(msg)
[16:12:19.545]                         }
[16:12:19.545]                       })
[16:12:19.545]                     }
[16:12:19.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:19.545]                     base::options(mc.cores = 1L)
[16:12:19.545]                   }
[16:12:19.545]                   options(future.plan = NULL)
[16:12:19.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:19.545]                 }
[16:12:19.545]                 ...future.workdir <- getwd()
[16:12:19.545]             }
[16:12:19.545]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:19.545]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:19.545]         }
[16:12:19.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:19.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:19.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:19.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:19.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:19.545]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:19.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:19.545]             base::names(...future.oldOptions))
[16:12:19.545]     }
[16:12:19.545]     if (FALSE) {
[16:12:19.545]     }
[16:12:19.545]     else {
[16:12:19.545]         if (TRUE) {
[16:12:19.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:19.545]                 open = "w")
[16:12:19.545]         }
[16:12:19.545]         else {
[16:12:19.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:19.545]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:19.545]         }
[16:12:19.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:19.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:19.545]             base::sink(type = "output", split = FALSE)
[16:12:19.545]             base::close(...future.stdout)
[16:12:19.545]         }, add = TRUE)
[16:12:19.545]     }
[16:12:19.545]     ...future.frame <- base::sys.nframe()
[16:12:19.545]     ...future.conditions <- base::list()
[16:12:19.545]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:19.545]     if (FALSE) {
[16:12:19.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:19.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:19.545]     }
[16:12:19.545]     ...future.result <- base::tryCatch({
[16:12:19.545]         base::withCallingHandlers({
[16:12:19.545]             ...future.value <- base::withVisible(base::local({
[16:12:19.545]                 withCallingHandlers({
[16:12:19.545]                   {
[16:12:19.545]                     2 * a
[16:12:19.545]                   }
[16:12:19.545]                 }, immediateCondition = function(cond) {
[16:12:19.545]                   save_rds <- function (object, pathname, ...) 
[16:12:19.545]                   {
[16:12:19.545]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:19.545]                     if (file_test("-f", pathname_tmp)) {
[16:12:19.545]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.545]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:19.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.545]                         fi_tmp[["mtime"]])
[16:12:19.545]                     }
[16:12:19.545]                     tryCatch({
[16:12:19.545]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:19.545]                     }, error = function(ex) {
[16:12:19.545]                       msg <- conditionMessage(ex)
[16:12:19.545]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.545]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:19.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.545]                         fi_tmp[["mtime"]], msg)
[16:12:19.545]                       ex$message <- msg
[16:12:19.545]                       stop(ex)
[16:12:19.545]                     })
[16:12:19.545]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:19.545]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:19.545]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:19.545]                       fi_tmp <- file.info(pathname_tmp)
[16:12:19.545]                       fi <- file.info(pathname)
[16:12:19.545]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:19.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:19.545]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:19.545]                         fi[["size"]], fi[["mtime"]])
[16:12:19.545]                       stop(msg)
[16:12:19.545]                     }
[16:12:19.545]                     invisible(pathname)
[16:12:19.545]                   }
[16:12:19.545]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:19.545]                     rootPath = tempdir()) 
[16:12:19.545]                   {
[16:12:19.545]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:19.545]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:19.545]                       tmpdir = path, fileext = ".rds")
[16:12:19.545]                     save_rds(obj, file)
[16:12:19.545]                   }
[16:12:19.545]                   saveImmediateCondition(cond, path = "/tmp/RtmpCPK8cm/.future/immediateConditions")
[16:12:19.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.545]                   {
[16:12:19.545]                     inherits <- base::inherits
[16:12:19.545]                     invokeRestart <- base::invokeRestart
[16:12:19.545]                     is.null <- base::is.null
[16:12:19.545]                     muffled <- FALSE
[16:12:19.545]                     if (inherits(cond, "message")) {
[16:12:19.545]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:19.545]                       if (muffled) 
[16:12:19.545]                         invokeRestart("muffleMessage")
[16:12:19.545]                     }
[16:12:19.545]                     else if (inherits(cond, "warning")) {
[16:12:19.545]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:19.545]                       if (muffled) 
[16:12:19.545]                         invokeRestart("muffleWarning")
[16:12:19.545]                     }
[16:12:19.545]                     else if (inherits(cond, "condition")) {
[16:12:19.545]                       if (!is.null(pattern)) {
[16:12:19.545]                         computeRestarts <- base::computeRestarts
[16:12:19.545]                         grepl <- base::grepl
[16:12:19.545]                         restarts <- computeRestarts(cond)
[16:12:19.545]                         for (restart in restarts) {
[16:12:19.545]                           name <- restart$name
[16:12:19.545]                           if (is.null(name)) 
[16:12:19.545]                             next
[16:12:19.545]                           if (!grepl(pattern, name)) 
[16:12:19.545]                             next
[16:12:19.545]                           invokeRestart(restart)
[16:12:19.545]                           muffled <- TRUE
[16:12:19.545]                           break
[16:12:19.545]                         }
[16:12:19.545]                       }
[16:12:19.545]                     }
[16:12:19.545]                     invisible(muffled)
[16:12:19.545]                   }
[16:12:19.545]                   muffleCondition(cond)
[16:12:19.545]                 })
[16:12:19.545]             }))
[16:12:19.545]             future::FutureResult(value = ...future.value$value, 
[16:12:19.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.545]                   ...future.rng), globalenv = if (FALSE) 
[16:12:19.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:19.545]                     ...future.globalenv.names))
[16:12:19.545]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:19.545]         }, condition = base::local({
[16:12:19.545]             c <- base::c
[16:12:19.545]             inherits <- base::inherits
[16:12:19.545]             invokeRestart <- base::invokeRestart
[16:12:19.545]             length <- base::length
[16:12:19.545]             list <- base::list
[16:12:19.545]             seq.int <- base::seq.int
[16:12:19.545]             signalCondition <- base::signalCondition
[16:12:19.545]             sys.calls <- base::sys.calls
[16:12:19.545]             `[[` <- base::`[[`
[16:12:19.545]             `+` <- base::`+`
[16:12:19.545]             `<<-` <- base::`<<-`
[16:12:19.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:19.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:19.545]                   3L)]
[16:12:19.545]             }
[16:12:19.545]             function(cond) {
[16:12:19.545]                 is_error <- inherits(cond, "error")
[16:12:19.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:19.545]                   NULL)
[16:12:19.545]                 if (is_error) {
[16:12:19.545]                   sessionInformation <- function() {
[16:12:19.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:19.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:19.545]                       search = base::search(), system = base::Sys.info())
[16:12:19.545]                   }
[16:12:19.545]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:19.545]                     cond$call), session = sessionInformation(), 
[16:12:19.545]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:19.545]                   signalCondition(cond)
[16:12:19.545]                 }
[16:12:19.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:19.545]                 "immediateCondition"))) {
[16:12:19.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:19.545]                   ...future.conditions[[length(...future.conditions) + 
[16:12:19.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:19.545]                   if (TRUE && !signal) {
[16:12:19.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.545]                     {
[16:12:19.545]                       inherits <- base::inherits
[16:12:19.545]                       invokeRestart <- base::invokeRestart
[16:12:19.545]                       is.null <- base::is.null
[16:12:19.545]                       muffled <- FALSE
[16:12:19.545]                       if (inherits(cond, "message")) {
[16:12:19.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.545]                         if (muffled) 
[16:12:19.545]                           invokeRestart("muffleMessage")
[16:12:19.545]                       }
[16:12:19.545]                       else if (inherits(cond, "warning")) {
[16:12:19.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.545]                         if (muffled) 
[16:12:19.545]                           invokeRestart("muffleWarning")
[16:12:19.545]                       }
[16:12:19.545]                       else if (inherits(cond, "condition")) {
[16:12:19.545]                         if (!is.null(pattern)) {
[16:12:19.545]                           computeRestarts <- base::computeRestarts
[16:12:19.545]                           grepl <- base::grepl
[16:12:19.545]                           restarts <- computeRestarts(cond)
[16:12:19.545]                           for (restart in restarts) {
[16:12:19.545]                             name <- restart$name
[16:12:19.545]                             if (is.null(name)) 
[16:12:19.545]                               next
[16:12:19.545]                             if (!grepl(pattern, name)) 
[16:12:19.545]                               next
[16:12:19.545]                             invokeRestart(restart)
[16:12:19.545]                             muffled <- TRUE
[16:12:19.545]                             break
[16:12:19.545]                           }
[16:12:19.545]                         }
[16:12:19.545]                       }
[16:12:19.545]                       invisible(muffled)
[16:12:19.545]                     }
[16:12:19.545]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.545]                   }
[16:12:19.545]                 }
[16:12:19.545]                 else {
[16:12:19.545]                   if (TRUE) {
[16:12:19.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:19.545]                     {
[16:12:19.545]                       inherits <- base::inherits
[16:12:19.545]                       invokeRestart <- base::invokeRestart
[16:12:19.545]                       is.null <- base::is.null
[16:12:19.545]                       muffled <- FALSE
[16:12:19.545]                       if (inherits(cond, "message")) {
[16:12:19.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:19.545]                         if (muffled) 
[16:12:19.545]                           invokeRestart("muffleMessage")
[16:12:19.545]                       }
[16:12:19.545]                       else if (inherits(cond, "warning")) {
[16:12:19.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:19.545]                         if (muffled) 
[16:12:19.545]                           invokeRestart("muffleWarning")
[16:12:19.545]                       }
[16:12:19.545]                       else if (inherits(cond, "condition")) {
[16:12:19.545]                         if (!is.null(pattern)) {
[16:12:19.545]                           computeRestarts <- base::computeRestarts
[16:12:19.545]                           grepl <- base::grepl
[16:12:19.545]                           restarts <- computeRestarts(cond)
[16:12:19.545]                           for (restart in restarts) {
[16:12:19.545]                             name <- restart$name
[16:12:19.545]                             if (is.null(name)) 
[16:12:19.545]                               next
[16:12:19.545]                             if (!grepl(pattern, name)) 
[16:12:19.545]                               next
[16:12:19.545]                             invokeRestart(restart)
[16:12:19.545]                             muffled <- TRUE
[16:12:19.545]                             break
[16:12:19.545]                           }
[16:12:19.545]                         }
[16:12:19.545]                       }
[16:12:19.545]                       invisible(muffled)
[16:12:19.545]                     }
[16:12:19.545]                     muffleCondition(cond, pattern = "^muffle")
[16:12:19.545]                   }
[16:12:19.545]                 }
[16:12:19.545]             }
[16:12:19.545]         }))
[16:12:19.545]     }, error = function(ex) {
[16:12:19.545]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:19.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:19.545]                 ...future.rng), started = ...future.startTime, 
[16:12:19.545]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:19.545]             version = "1.8"), class = "FutureResult")
[16:12:19.545]     }, finally = {
[16:12:19.545]         if (!identical(...future.workdir, getwd())) 
[16:12:19.545]             setwd(...future.workdir)
[16:12:19.545]         {
[16:12:19.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:19.545]                 ...future.oldOptions$nwarnings <- NULL
[16:12:19.545]             }
[16:12:19.545]             base::options(...future.oldOptions)
[16:12:19.545]             if (.Platform$OS.type == "windows") {
[16:12:19.545]                 old_names <- names(...future.oldEnvVars)
[16:12:19.545]                 envs <- base::Sys.getenv()
[16:12:19.545]                 names <- names(envs)
[16:12:19.545]                 common <- intersect(names, old_names)
[16:12:19.545]                 added <- setdiff(names, old_names)
[16:12:19.545]                 removed <- setdiff(old_names, names)
[16:12:19.545]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:19.545]                   envs[common]]
[16:12:19.545]                 NAMES <- toupper(changed)
[16:12:19.545]                 args <- list()
[16:12:19.545]                 for (kk in seq_along(NAMES)) {
[16:12:19.545]                   name <- changed[[kk]]
[16:12:19.545]                   NAME <- NAMES[[kk]]
[16:12:19.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.545]                     next
[16:12:19.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.545]                 }
[16:12:19.545]                 NAMES <- toupper(added)
[16:12:19.545]                 for (kk in seq_along(NAMES)) {
[16:12:19.545]                   name <- added[[kk]]
[16:12:19.545]                   NAME <- NAMES[[kk]]
[16:12:19.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.545]                     next
[16:12:19.545]                   args[[name]] <- ""
[16:12:19.545]                 }
[16:12:19.545]                 NAMES <- toupper(removed)
[16:12:19.545]                 for (kk in seq_along(NAMES)) {
[16:12:19.545]                   name <- removed[[kk]]
[16:12:19.545]                   NAME <- NAMES[[kk]]
[16:12:19.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:19.545]                     next
[16:12:19.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:19.545]                 }
[16:12:19.545]                 if (length(args) > 0) 
[16:12:19.545]                   base::do.call(base::Sys.setenv, args = args)
[16:12:19.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:19.545]             }
[16:12:19.545]             else {
[16:12:19.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:19.545]             }
[16:12:19.545]             {
[16:12:19.545]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:19.545]                   0L) {
[16:12:19.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:19.545]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:19.545]                   base::options(opts)
[16:12:19.545]                 }
[16:12:19.545]                 {
[16:12:19.545]                   {
[16:12:19.545]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:19.545]                     NULL
[16:12:19.545]                   }
[16:12:19.545]                   options(future.plan = NULL)
[16:12:19.545]                   if (is.na(NA_character_)) 
[16:12:19.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:19.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:19.545]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:19.545]                     envir = parent.frame()) 
[16:12:19.545]                   {
[16:12:19.545]                     default_workers <- missing(workers)
[16:12:19.545]                     if (is.function(workers)) 
[16:12:19.545]                       workers <- workers()
[16:12:19.545]                     workers <- structure(as.integer(workers), 
[16:12:19.545]                       class = class(workers))
[16:12:19.545]                     stop_if_not(is.finite(workers), workers >= 
[16:12:19.545]                       1L)
[16:12:19.545]                     if ((workers == 1L && !inherits(workers, 
[16:12:19.545]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:19.545]                       if (default_workers) 
[16:12:19.545]                         supportsMulticore(warn = TRUE)
[16:12:19.545]                       return(sequential(..., envir = envir))
[16:12:19.545]                     }
[16:12:19.545]                     oopts <- options(mc.cores = workers)
[16:12:19.545]                     on.exit(options(oopts))
[16:12:19.545]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:19.545]                       envir = envir)
[16:12:19.545]                     if (!future$lazy) 
[16:12:19.545]                       future <- run(future)
[16:12:19.545]                     invisible(future)
[16:12:19.545]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:19.545]                 }
[16:12:19.545]             }
[16:12:19.545]         }
[16:12:19.545]     })
[16:12:19.545]     if (TRUE) {
[16:12:19.545]         base::sink(type = "output", split = FALSE)
[16:12:19.545]         if (TRUE) {
[16:12:19.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:19.545]         }
[16:12:19.545]         else {
[16:12:19.545]             ...future.result["stdout"] <- base::list(NULL)
[16:12:19.545]         }
[16:12:19.545]         base::close(...future.stdout)
[16:12:19.545]         ...future.stdout <- NULL
[16:12:19.545]     }
[16:12:19.545]     ...future.result$conditions <- ...future.conditions
[16:12:19.545]     ...future.result$finished <- base::Sys.time()
[16:12:19.545]     ...future.result
[16:12:19.545] }
[16:12:19.548] assign_globals() ...
[16:12:19.548] List of 1
[16:12:19.548]  $ a: num 1
[16:12:19.548]  - attr(*, "where")=List of 1
[16:12:19.548]   ..$ a:<environment: R_EmptyEnv> 
[16:12:19.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:12:19.548]  - attr(*, "resolved")= logi FALSE
[16:12:19.548]  - attr(*, "total_size")= num 56
[16:12:19.548]  - attr(*, "already-done")= logi TRUE
[16:12:19.551] - copied ‘a’ to environment
[16:12:19.552] assign_globals() ... done
[16:12:19.552] requestCore(): workers = 2
[16:12:19.554] MulticoreFuture started
[16:12:19.554] - Launch lazy future ... done
[16:12:19.554] run() for ‘MulticoreFuture’ ... done
[16:12:19.555] plan(): Setting new future strategy stack:
[16:12:19.555] List of future strategies:
[16:12:19.555] 1. sequential:
[16:12:19.555]    - args: function (..., envir = parent.frame())
[16:12:19.555]    - tweaked: FALSE
[16:12:19.555]    - call: NULL
[16:12:19.556] plan(): nbrOfWorkers() = 1
[16:12:19.558] plan(): Setting new future strategy stack:
[16:12:19.558] List of future strategies:
[16:12:19.558] 1. multicore:
[16:12:19.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:19.558]    - tweaked: FALSE
[16:12:19.558]    - call: plan(strategy)
[16:12:19.564] plan(): nbrOfWorkers() = 2
*** futureAssign() with ‘multicore’ futures ... DONE
*** futureAssign() with ‘multisession’ futures ...
[16:12:19.566] plan(): Setting new future strategy stack:
[16:12:19.566] List of future strategies:
[16:12:19.566] 1. multisession:
[16:12:19.566]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:19.566]    - tweaked: FALSE
[16:12:19.566]    - call: plan(strategy)
[16:12:19.567] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:19.567] multisession:
[16:12:19.567] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:19.567] - tweaked: FALSE
[16:12:19.567] - call: plan(strategy)
[16:12:19.574] getGlobalsAndPackages() ...
[16:12:19.574] Not searching for globals
[16:12:19.575] - globals: [0] <none>
[16:12:19.575] getGlobalsAndPackages() ... DONE
[16:12:19.575] [local output] makeClusterPSOCK() ...
[16:12:19.618] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:19.623] [local output] Base port: 11155
[16:12:19.623] [local output] Getting setup options for 2 cluster nodes ...
[16:12:19.624] [local output]  - Node 1 of 2 ...
[16:12:19.624] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:19.625] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpCPK8cm/worker.rank=1.parallelly.parent=82556.1427c7bbc8372.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpCPK8cm/worker.rank=1.parallelly.parent=82556.1427c7bbc8372.pid")'’
[16:12:19.814] - Possible to infer worker's PID: TRUE
[16:12:19.814] [local output] Rscript port: 11155

[16:12:19.815] [local output]  - Node 2 of 2 ...
[16:12:19.815] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:19.816] [local output] Rscript port: 11155

[16:12:19.816] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:19.816] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:19.817] [local output] Setting up PSOCK nodes in parallel
[16:12:19.817] List of 36
[16:12:19.817]  $ worker          : chr "localhost"
[16:12:19.817]   ..- attr(*, "localhost")= logi TRUE
[16:12:19.817]  $ master          : chr "localhost"
[16:12:19.817]  $ port            : int 11155
[16:12:19.817]  $ connectTimeout  : num 120
[16:12:19.817]  $ timeout         : num 2592000
[16:12:19.817]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:19.817]  $ homogeneous     : logi TRUE
[16:12:19.817]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:19.817]  $ rscript_envs    : NULL
[16:12:19.817]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:19.817]  $ rscript_startup : NULL
[16:12:19.817]  $ rscript_sh      : chr "sh"
[16:12:19.817]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:19.817]  $ methods         : logi TRUE
[16:12:19.817]  $ socketOptions   : chr "no-delay"
[16:12:19.817]  $ useXDR          : logi FALSE
[16:12:19.817]  $ outfile         : chr "/dev/null"
[16:12:19.817]  $ renice          : int NA
[16:12:19.817]  $ rshcmd          : NULL
[16:12:19.817]  $ user            : chr(0) 
[16:12:19.817]  $ revtunnel       : logi FALSE
[16:12:19.817]  $ rshlogfile      : NULL
[16:12:19.817]  $ rshopts         : chr(0) 
[16:12:19.817]  $ rank            : int 1
[16:12:19.817]  $ manual          : logi FALSE
[16:12:19.817]  $ dryrun          : logi FALSE
[16:12:19.817]  $ quiet           : logi FALSE
[16:12:19.817]  $ setup_strategy  : chr "parallel"
[16:12:19.817]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:19.817]  $ pidfile         : chr "/tmp/RtmpCPK8cm/worker.rank=1.parallelly.parent=82556.1427c7bbc8372.pid"
[16:12:19.817]  $ rshcmd_label    : NULL
[16:12:19.817]  $ rsh_call        : NULL
[16:12:19.817]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:19.817]  $ localMachine    : logi TRUE
[16:12:19.817]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:19.817]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:19.817]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:19.817]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:19.817]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:19.817]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:19.817]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:19.817]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:19.817]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:19.817]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:19.817]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:19.817]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:19.817]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:19.817]  $ arguments       :List of 28
[16:12:19.817]   ..$ worker          : chr "localhost"
[16:12:19.817]   ..$ master          : NULL
[16:12:19.817]   ..$ port            : int 11155
[16:12:19.817]   ..$ connectTimeout  : num 120
[16:12:19.817]   ..$ timeout         : num 2592000
[16:12:19.817]   ..$ rscript         : NULL
[16:12:19.817]   ..$ homogeneous     : NULL
[16:12:19.817]   ..$ rscript_args    : NULL
[16:12:19.817]   ..$ rscript_envs    : NULL
[16:12:19.817]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:19.817]   ..$ rscript_startup : NULL
[16:12:19.817]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:19.817]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:19.817]   ..$ methods         : logi TRUE
[16:12:19.817]   ..$ socketOptions   : chr "no-delay"
[16:12:19.817]   ..$ useXDR          : logi FALSE
[16:12:19.817]   ..$ outfile         : chr "/dev/null"
[16:12:19.817]   ..$ renice          : int NA
[16:12:19.817]   ..$ rshcmd          : NULL
[16:12:19.817]   ..$ user            : NULL
[16:12:19.817]   ..$ revtunnel       : logi NA
[16:12:19.817]   ..$ rshlogfile      : NULL
[16:12:19.817]   ..$ rshopts         : NULL
[16:12:19.817]   ..$ rank            : int 1
[16:12:19.817]   ..$ manual          : logi FALSE
[16:12:19.817]   ..$ dryrun          : logi FALSE
[16:12:19.817]   ..$ quiet           : logi FALSE
[16:12:19.817]   ..$ setup_strategy  : chr "parallel"
[16:12:19.817]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:19.834] [local output] System call to launch all workers:
[16:12:19.834] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpCPK8cm/worker.rank=1.parallelly.parent=82556.1427c7bbc8372.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11155 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:19.834] [local output] Starting PSOCK main server
[16:12:19.836] [local output] Workers launched
[16:12:19.836] [local output] Waiting for workers to connect back
[16:12:19.836]  - [local output] 0 workers out of 2 ready
[16:12:20.083]  - [local output] 0 workers out of 2 ready
[16:12:20.083]  - [local output] 1 workers out of 2 ready
[16:12:20.083]  - [local output] 2 workers out of 2 ready
[16:12:20.084] [local output] Launching of workers completed
[16:12:20.084] [local output] Collecting session information from workers
[16:12:20.084] [local output]  - Worker #1 of 2
[16:12:20.085] [local output]  - Worker #2 of 2
[16:12:20.085] [local output] makeClusterPSOCK() ... done
[16:12:20.098] Packages needed by the future expression (n = 0): <none>
[16:12:20.098] Packages needed by future strategies (n = 0): <none>
[16:12:20.099] {
[16:12:20.099]     {
[16:12:20.099]         {
[16:12:20.099]             ...future.startTime <- base::Sys.time()
[16:12:20.099]             {
[16:12:20.099]                 {
[16:12:20.099]                   {
[16:12:20.099]                     {
[16:12:20.099]                       base::local({
[16:12:20.099]                         has_future <- base::requireNamespace("future", 
[16:12:20.099]                           quietly = TRUE)
[16:12:20.099]                         if (has_future) {
[16:12:20.099]                           ns <- base::getNamespace("future")
[16:12:20.099]                           version <- ns[[".package"]][["version"]]
[16:12:20.099]                           if (is.null(version)) 
[16:12:20.099]                             version <- utils::packageVersion("future")
[16:12:20.099]                         }
[16:12:20.099]                         else {
[16:12:20.099]                           version <- NULL
[16:12:20.099]                         }
[16:12:20.099]                         if (!has_future || version < "1.8.0") {
[16:12:20.099]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.099]                             "", base::R.version$version.string), 
[16:12:20.099]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.099]                               "release", "version")], collapse = " "), 
[16:12:20.099]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.099]                             info)
[16:12:20.099]                           info <- base::paste(info, collapse = "; ")
[16:12:20.099]                           if (!has_future) {
[16:12:20.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.099]                               info)
[16:12:20.099]                           }
[16:12:20.099]                           else {
[16:12:20.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.099]                               info, version)
[16:12:20.099]                           }
[16:12:20.099]                           base::stop(msg)
[16:12:20.099]                         }
[16:12:20.099]                       })
[16:12:20.099]                     }
[16:12:20.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.099]                     base::options(mc.cores = 1L)
[16:12:20.099]                   }
[16:12:20.099]                   options(future.plan = NULL)
[16:12:20.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.099]                 }
[16:12:20.099]                 ...future.workdir <- getwd()
[16:12:20.099]             }
[16:12:20.099]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.099]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.099]         }
[16:12:20.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.099]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.099]             base::names(...future.oldOptions))
[16:12:20.099]     }
[16:12:20.099]     if (FALSE) {
[16:12:20.099]     }
[16:12:20.099]     else {
[16:12:20.099]         if (TRUE) {
[16:12:20.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.099]                 open = "w")
[16:12:20.099]         }
[16:12:20.099]         else {
[16:12:20.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.099]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.099]         }
[16:12:20.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.099]             base::sink(type = "output", split = FALSE)
[16:12:20.099]             base::close(...future.stdout)
[16:12:20.099]         }, add = TRUE)
[16:12:20.099]     }
[16:12:20.099]     ...future.frame <- base::sys.nframe()
[16:12:20.099]     ...future.conditions <- base::list()
[16:12:20.099]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.099]     if (FALSE) {
[16:12:20.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.099]     }
[16:12:20.099]     ...future.result <- base::tryCatch({
[16:12:20.099]         base::withCallingHandlers({
[16:12:20.099]             ...future.value <- base::withVisible(base::local({
[16:12:20.099]                 ...future.makeSendCondition <- local({
[16:12:20.099]                   sendCondition <- NULL
[16:12:20.099]                   function(frame = 1L) {
[16:12:20.099]                     if (is.function(sendCondition)) 
[16:12:20.099]                       return(sendCondition)
[16:12:20.099]                     ns <- getNamespace("parallel")
[16:12:20.099]                     if (exists("sendData", mode = "function", 
[16:12:20.099]                       envir = ns)) {
[16:12:20.099]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.099]                         envir = ns)
[16:12:20.099]                       envir <- sys.frame(frame)
[16:12:20.099]                       master <- NULL
[16:12:20.099]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.099]                         !identical(envir, emptyenv())) {
[16:12:20.099]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.099]                           inherits = FALSE)) {
[16:12:20.099]                           master <- get("master", mode = "list", 
[16:12:20.099]                             envir = envir, inherits = FALSE)
[16:12:20.099]                           if (inherits(master, c("SOCKnode", 
[16:12:20.099]                             "SOCK0node"))) {
[16:12:20.099]                             sendCondition <<- function(cond) {
[16:12:20.099]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.099]                                 success = TRUE)
[16:12:20.099]                               parallel_sendData(master, data)
[16:12:20.099]                             }
[16:12:20.099]                             return(sendCondition)
[16:12:20.099]                           }
[16:12:20.099]                         }
[16:12:20.099]                         frame <- frame + 1L
[16:12:20.099]                         envir <- sys.frame(frame)
[16:12:20.099]                       }
[16:12:20.099]                     }
[16:12:20.099]                     sendCondition <<- function(cond) NULL
[16:12:20.099]                   }
[16:12:20.099]                 })
[16:12:20.099]                 withCallingHandlers({
[16:12:20.099]                   NA
[16:12:20.099]                 }, immediateCondition = function(cond) {
[16:12:20.099]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.099]                   sendCondition(cond)
[16:12:20.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.099]                   {
[16:12:20.099]                     inherits <- base::inherits
[16:12:20.099]                     invokeRestart <- base::invokeRestart
[16:12:20.099]                     is.null <- base::is.null
[16:12:20.099]                     muffled <- FALSE
[16:12:20.099]                     if (inherits(cond, "message")) {
[16:12:20.099]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.099]                       if (muffled) 
[16:12:20.099]                         invokeRestart("muffleMessage")
[16:12:20.099]                     }
[16:12:20.099]                     else if (inherits(cond, "warning")) {
[16:12:20.099]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.099]                       if (muffled) 
[16:12:20.099]                         invokeRestart("muffleWarning")
[16:12:20.099]                     }
[16:12:20.099]                     else if (inherits(cond, "condition")) {
[16:12:20.099]                       if (!is.null(pattern)) {
[16:12:20.099]                         computeRestarts <- base::computeRestarts
[16:12:20.099]                         grepl <- base::grepl
[16:12:20.099]                         restarts <- computeRestarts(cond)
[16:12:20.099]                         for (restart in restarts) {
[16:12:20.099]                           name <- restart$name
[16:12:20.099]                           if (is.null(name)) 
[16:12:20.099]                             next
[16:12:20.099]                           if (!grepl(pattern, name)) 
[16:12:20.099]                             next
[16:12:20.099]                           invokeRestart(restart)
[16:12:20.099]                           muffled <- TRUE
[16:12:20.099]                           break
[16:12:20.099]                         }
[16:12:20.099]                       }
[16:12:20.099]                     }
[16:12:20.099]                     invisible(muffled)
[16:12:20.099]                   }
[16:12:20.099]                   muffleCondition(cond)
[16:12:20.099]                 })
[16:12:20.099]             }))
[16:12:20.099]             future::FutureResult(value = ...future.value$value, 
[16:12:20.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.099]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.099]                     ...future.globalenv.names))
[16:12:20.099]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.099]         }, condition = base::local({
[16:12:20.099]             c <- base::c
[16:12:20.099]             inherits <- base::inherits
[16:12:20.099]             invokeRestart <- base::invokeRestart
[16:12:20.099]             length <- base::length
[16:12:20.099]             list <- base::list
[16:12:20.099]             seq.int <- base::seq.int
[16:12:20.099]             signalCondition <- base::signalCondition
[16:12:20.099]             sys.calls <- base::sys.calls
[16:12:20.099]             `[[` <- base::`[[`
[16:12:20.099]             `+` <- base::`+`
[16:12:20.099]             `<<-` <- base::`<<-`
[16:12:20.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.099]                   3L)]
[16:12:20.099]             }
[16:12:20.099]             function(cond) {
[16:12:20.099]                 is_error <- inherits(cond, "error")
[16:12:20.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.099]                   NULL)
[16:12:20.099]                 if (is_error) {
[16:12:20.099]                   sessionInformation <- function() {
[16:12:20.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.099]                       search = base::search(), system = base::Sys.info())
[16:12:20.099]                   }
[16:12:20.099]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.099]                     cond$call), session = sessionInformation(), 
[16:12:20.099]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.099]                   signalCondition(cond)
[16:12:20.099]                 }
[16:12:20.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.099]                 "immediateCondition"))) {
[16:12:20.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.099]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.099]                   if (TRUE && !signal) {
[16:12:20.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.099]                     {
[16:12:20.099]                       inherits <- base::inherits
[16:12:20.099]                       invokeRestart <- base::invokeRestart
[16:12:20.099]                       is.null <- base::is.null
[16:12:20.099]                       muffled <- FALSE
[16:12:20.099]                       if (inherits(cond, "message")) {
[16:12:20.099]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.099]                         if (muffled) 
[16:12:20.099]                           invokeRestart("muffleMessage")
[16:12:20.099]                       }
[16:12:20.099]                       else if (inherits(cond, "warning")) {
[16:12:20.099]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.099]                         if (muffled) 
[16:12:20.099]                           invokeRestart("muffleWarning")
[16:12:20.099]                       }
[16:12:20.099]                       else if (inherits(cond, "condition")) {
[16:12:20.099]                         if (!is.null(pattern)) {
[16:12:20.099]                           computeRestarts <- base::computeRestarts
[16:12:20.099]                           grepl <- base::grepl
[16:12:20.099]                           restarts <- computeRestarts(cond)
[16:12:20.099]                           for (restart in restarts) {
[16:12:20.099]                             name <- restart$name
[16:12:20.099]                             if (is.null(name)) 
[16:12:20.099]                               next
[16:12:20.099]                             if (!grepl(pattern, name)) 
[16:12:20.099]                               next
[16:12:20.099]                             invokeRestart(restart)
[16:12:20.099]                             muffled <- TRUE
[16:12:20.099]                             break
[16:12:20.099]                           }
[16:12:20.099]                         }
[16:12:20.099]                       }
[16:12:20.099]                       invisible(muffled)
[16:12:20.099]                     }
[16:12:20.099]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.099]                   }
[16:12:20.099]                 }
[16:12:20.099]                 else {
[16:12:20.099]                   if (TRUE) {
[16:12:20.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.099]                     {
[16:12:20.099]                       inherits <- base::inherits
[16:12:20.099]                       invokeRestart <- base::invokeRestart
[16:12:20.099]                       is.null <- base::is.null
[16:12:20.099]                       muffled <- FALSE
[16:12:20.099]                       if (inherits(cond, "message")) {
[16:12:20.099]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.099]                         if (muffled) 
[16:12:20.099]                           invokeRestart("muffleMessage")
[16:12:20.099]                       }
[16:12:20.099]                       else if (inherits(cond, "warning")) {
[16:12:20.099]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.099]                         if (muffled) 
[16:12:20.099]                           invokeRestart("muffleWarning")
[16:12:20.099]                       }
[16:12:20.099]                       else if (inherits(cond, "condition")) {
[16:12:20.099]                         if (!is.null(pattern)) {
[16:12:20.099]                           computeRestarts <- base::computeRestarts
[16:12:20.099]                           grepl <- base::grepl
[16:12:20.099]                           restarts <- computeRestarts(cond)
[16:12:20.099]                           for (restart in restarts) {
[16:12:20.099]                             name <- restart$name
[16:12:20.099]                             if (is.null(name)) 
[16:12:20.099]                               next
[16:12:20.099]                             if (!grepl(pattern, name)) 
[16:12:20.099]                               next
[16:12:20.099]                             invokeRestart(restart)
[16:12:20.099]                             muffled <- TRUE
[16:12:20.099]                             break
[16:12:20.099]                           }
[16:12:20.099]                         }
[16:12:20.099]                       }
[16:12:20.099]                       invisible(muffled)
[16:12:20.099]                     }
[16:12:20.099]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.099]                   }
[16:12:20.099]                 }
[16:12:20.099]             }
[16:12:20.099]         }))
[16:12:20.099]     }, error = function(ex) {
[16:12:20.099]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.099]                 ...future.rng), started = ...future.startTime, 
[16:12:20.099]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.099]             version = "1.8"), class = "FutureResult")
[16:12:20.099]     }, finally = {
[16:12:20.099]         if (!identical(...future.workdir, getwd())) 
[16:12:20.099]             setwd(...future.workdir)
[16:12:20.099]         {
[16:12:20.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.099]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.099]             }
[16:12:20.099]             base::options(...future.oldOptions)
[16:12:20.099]             if (.Platform$OS.type == "windows") {
[16:12:20.099]                 old_names <- names(...future.oldEnvVars)
[16:12:20.099]                 envs <- base::Sys.getenv()
[16:12:20.099]                 names <- names(envs)
[16:12:20.099]                 common <- intersect(names, old_names)
[16:12:20.099]                 added <- setdiff(names, old_names)
[16:12:20.099]                 removed <- setdiff(old_names, names)
[16:12:20.099]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.099]                   envs[common]]
[16:12:20.099]                 NAMES <- toupper(changed)
[16:12:20.099]                 args <- list()
[16:12:20.099]                 for (kk in seq_along(NAMES)) {
[16:12:20.099]                   name <- changed[[kk]]
[16:12:20.099]                   NAME <- NAMES[[kk]]
[16:12:20.099]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.099]                     next
[16:12:20.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.099]                 }
[16:12:20.099]                 NAMES <- toupper(added)
[16:12:20.099]                 for (kk in seq_along(NAMES)) {
[16:12:20.099]                   name <- added[[kk]]
[16:12:20.099]                   NAME <- NAMES[[kk]]
[16:12:20.099]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.099]                     next
[16:12:20.099]                   args[[name]] <- ""
[16:12:20.099]                 }
[16:12:20.099]                 NAMES <- toupper(removed)
[16:12:20.099]                 for (kk in seq_along(NAMES)) {
[16:12:20.099]                   name <- removed[[kk]]
[16:12:20.099]                   NAME <- NAMES[[kk]]
[16:12:20.099]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.099]                     next
[16:12:20.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.099]                 }
[16:12:20.099]                 if (length(args) > 0) 
[16:12:20.099]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.099]             }
[16:12:20.099]             else {
[16:12:20.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.099]             }
[16:12:20.099]             {
[16:12:20.099]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.099]                   0L) {
[16:12:20.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.099]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.099]                   base::options(opts)
[16:12:20.099]                 }
[16:12:20.099]                 {
[16:12:20.099]                   {
[16:12:20.099]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.099]                     NULL
[16:12:20.099]                   }
[16:12:20.099]                   options(future.plan = NULL)
[16:12:20.099]                   if (is.na(NA_character_)) 
[16:12:20.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.099]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.099]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.099]                     envir = parent.frame()) 
[16:12:20.099]                   {
[16:12:20.099]                     if (is.function(workers)) 
[16:12:20.099]                       workers <- workers()
[16:12:20.099]                     workers <- structure(as.integer(workers), 
[16:12:20.099]                       class = class(workers))
[16:12:20.099]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.099]                       workers >= 1)
[16:12:20.099]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.099]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.099]                     }
[16:12:20.099]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.099]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.099]                       envir = envir)
[16:12:20.099]                     if (!future$lazy) 
[16:12:20.099]                       future <- run(future)
[16:12:20.099]                     invisible(future)
[16:12:20.099]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.099]                 }
[16:12:20.099]             }
[16:12:20.099]         }
[16:12:20.099]     })
[16:12:20.099]     if (TRUE) {
[16:12:20.099]         base::sink(type = "output", split = FALSE)
[16:12:20.099]         if (TRUE) {
[16:12:20.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.099]         }
[16:12:20.099]         else {
[16:12:20.099]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.099]         }
[16:12:20.099]         base::close(...future.stdout)
[16:12:20.099]         ...future.stdout <- NULL
[16:12:20.099]     }
[16:12:20.099]     ...future.result$conditions <- ...future.conditions
[16:12:20.099]     ...future.result$finished <- base::Sys.time()
[16:12:20.099]     ...future.result
[16:12:20.099] }
[16:12:20.171] MultisessionFuture started
[16:12:20.171] result() for ClusterFuture ...
[16:12:20.171] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.172] - Validating connection of MultisessionFuture
[16:12:20.203] - received message: FutureResult
[16:12:20.203] - Received FutureResult
[16:12:20.203] - Erased future from FutureRegistry
[16:12:20.204] result() for ClusterFuture ...
[16:12:20.204] - result already collected: FutureResult
[16:12:20.204] result() for ClusterFuture ... done
[16:12:20.204] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.204] result() for ClusterFuture ... done
[16:12:20.204] result() for ClusterFuture ...
[16:12:20.204] - result already collected: FutureResult
[16:12:20.204] result() for ClusterFuture ... done
[16:12:20.205] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:20.208] plan(): nbrOfWorkers() = 2
[16:12:20.209] getGlobalsAndPackages() ...
[16:12:20.209] Searching for globals...
[16:12:20.210] - globals found: [1] ‘{’
[16:12:20.210] Searching for globals ... DONE
[16:12:20.210] Resolving globals: FALSE
[16:12:20.210] 
[16:12:20.210] 
[16:12:20.210] getGlobalsAndPackages() ... DONE
[16:12:20.211] run() for ‘Future’ ...
[16:12:20.211] - state: ‘created’
[16:12:20.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.226]   - Field: ‘node’
[16:12:20.226]   - Field: ‘label’
[16:12:20.226]   - Field: ‘local’
[16:12:20.226]   - Field: ‘owner’
[16:12:20.227]   - Field: ‘envir’
[16:12:20.227]   - Field: ‘workers’
[16:12:20.227]   - Field: ‘packages’
[16:12:20.227]   - Field: ‘gc’
[16:12:20.227]   - Field: ‘conditions’
[16:12:20.227]   - Field: ‘persistent’
[16:12:20.227]   - Field: ‘expr’
[16:12:20.227]   - Field: ‘uuid’
[16:12:20.227]   - Field: ‘seed’
[16:12:20.228]   - Field: ‘version’
[16:12:20.228]   - Field: ‘result’
[16:12:20.228]   - Field: ‘asynchronous’
[16:12:20.228]   - Field: ‘calls’
[16:12:20.228]   - Field: ‘globals’
[16:12:20.228]   - Field: ‘stdout’
[16:12:20.228]   - Field: ‘earlySignal’
[16:12:20.228]   - Field: ‘lazy’
[16:12:20.229]   - Field: ‘state’
[16:12:20.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.229] - Launch lazy future ...
[16:12:20.229] Packages needed by the future expression (n = 0): <none>
[16:12:20.229] Packages needed by future strategies (n = 0): <none>
[16:12:20.230] {
[16:12:20.230]     {
[16:12:20.230]         {
[16:12:20.230]             ...future.startTime <- base::Sys.time()
[16:12:20.230]             {
[16:12:20.230]                 {
[16:12:20.230]                   {
[16:12:20.230]                     {
[16:12:20.230]                       base::local({
[16:12:20.230]                         has_future <- base::requireNamespace("future", 
[16:12:20.230]                           quietly = TRUE)
[16:12:20.230]                         if (has_future) {
[16:12:20.230]                           ns <- base::getNamespace("future")
[16:12:20.230]                           version <- ns[[".package"]][["version"]]
[16:12:20.230]                           if (is.null(version)) 
[16:12:20.230]                             version <- utils::packageVersion("future")
[16:12:20.230]                         }
[16:12:20.230]                         else {
[16:12:20.230]                           version <- NULL
[16:12:20.230]                         }
[16:12:20.230]                         if (!has_future || version < "1.8.0") {
[16:12:20.230]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.230]                             "", base::R.version$version.string), 
[16:12:20.230]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.230]                               "release", "version")], collapse = " "), 
[16:12:20.230]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.230]                             info)
[16:12:20.230]                           info <- base::paste(info, collapse = "; ")
[16:12:20.230]                           if (!has_future) {
[16:12:20.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.230]                               info)
[16:12:20.230]                           }
[16:12:20.230]                           else {
[16:12:20.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.230]                               info, version)
[16:12:20.230]                           }
[16:12:20.230]                           base::stop(msg)
[16:12:20.230]                         }
[16:12:20.230]                       })
[16:12:20.230]                     }
[16:12:20.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.230]                     base::options(mc.cores = 1L)
[16:12:20.230]                   }
[16:12:20.230]                   options(future.plan = NULL)
[16:12:20.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.230]                 }
[16:12:20.230]                 ...future.workdir <- getwd()
[16:12:20.230]             }
[16:12:20.230]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.230]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.230]         }
[16:12:20.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.230]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.230]             base::names(...future.oldOptions))
[16:12:20.230]     }
[16:12:20.230]     if (FALSE) {
[16:12:20.230]     }
[16:12:20.230]     else {
[16:12:20.230]         if (TRUE) {
[16:12:20.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.230]                 open = "w")
[16:12:20.230]         }
[16:12:20.230]         else {
[16:12:20.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.230]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.230]         }
[16:12:20.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.230]             base::sink(type = "output", split = FALSE)
[16:12:20.230]             base::close(...future.stdout)
[16:12:20.230]         }, add = TRUE)
[16:12:20.230]     }
[16:12:20.230]     ...future.frame <- base::sys.nframe()
[16:12:20.230]     ...future.conditions <- base::list()
[16:12:20.230]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.230]     if (FALSE) {
[16:12:20.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.230]     }
[16:12:20.230]     ...future.result <- base::tryCatch({
[16:12:20.230]         base::withCallingHandlers({
[16:12:20.230]             ...future.value <- base::withVisible(base::local({
[16:12:20.230]                 ...future.makeSendCondition <- local({
[16:12:20.230]                   sendCondition <- NULL
[16:12:20.230]                   function(frame = 1L) {
[16:12:20.230]                     if (is.function(sendCondition)) 
[16:12:20.230]                       return(sendCondition)
[16:12:20.230]                     ns <- getNamespace("parallel")
[16:12:20.230]                     if (exists("sendData", mode = "function", 
[16:12:20.230]                       envir = ns)) {
[16:12:20.230]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.230]                         envir = ns)
[16:12:20.230]                       envir <- sys.frame(frame)
[16:12:20.230]                       master <- NULL
[16:12:20.230]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.230]                         !identical(envir, emptyenv())) {
[16:12:20.230]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.230]                           inherits = FALSE)) {
[16:12:20.230]                           master <- get("master", mode = "list", 
[16:12:20.230]                             envir = envir, inherits = FALSE)
[16:12:20.230]                           if (inherits(master, c("SOCKnode", 
[16:12:20.230]                             "SOCK0node"))) {
[16:12:20.230]                             sendCondition <<- function(cond) {
[16:12:20.230]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.230]                                 success = TRUE)
[16:12:20.230]                               parallel_sendData(master, data)
[16:12:20.230]                             }
[16:12:20.230]                             return(sendCondition)
[16:12:20.230]                           }
[16:12:20.230]                         }
[16:12:20.230]                         frame <- frame + 1L
[16:12:20.230]                         envir <- sys.frame(frame)
[16:12:20.230]                       }
[16:12:20.230]                     }
[16:12:20.230]                     sendCondition <<- function(cond) NULL
[16:12:20.230]                   }
[16:12:20.230]                 })
[16:12:20.230]                 withCallingHandlers({
[16:12:20.230]                   {
[16:12:20.230]                     2
[16:12:20.230]                   }
[16:12:20.230]                 }, immediateCondition = function(cond) {
[16:12:20.230]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.230]                   sendCondition(cond)
[16:12:20.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.230]                   {
[16:12:20.230]                     inherits <- base::inherits
[16:12:20.230]                     invokeRestart <- base::invokeRestart
[16:12:20.230]                     is.null <- base::is.null
[16:12:20.230]                     muffled <- FALSE
[16:12:20.230]                     if (inherits(cond, "message")) {
[16:12:20.230]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.230]                       if (muffled) 
[16:12:20.230]                         invokeRestart("muffleMessage")
[16:12:20.230]                     }
[16:12:20.230]                     else if (inherits(cond, "warning")) {
[16:12:20.230]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.230]                       if (muffled) 
[16:12:20.230]                         invokeRestart("muffleWarning")
[16:12:20.230]                     }
[16:12:20.230]                     else if (inherits(cond, "condition")) {
[16:12:20.230]                       if (!is.null(pattern)) {
[16:12:20.230]                         computeRestarts <- base::computeRestarts
[16:12:20.230]                         grepl <- base::grepl
[16:12:20.230]                         restarts <- computeRestarts(cond)
[16:12:20.230]                         for (restart in restarts) {
[16:12:20.230]                           name <- restart$name
[16:12:20.230]                           if (is.null(name)) 
[16:12:20.230]                             next
[16:12:20.230]                           if (!grepl(pattern, name)) 
[16:12:20.230]                             next
[16:12:20.230]                           invokeRestart(restart)
[16:12:20.230]                           muffled <- TRUE
[16:12:20.230]                           break
[16:12:20.230]                         }
[16:12:20.230]                       }
[16:12:20.230]                     }
[16:12:20.230]                     invisible(muffled)
[16:12:20.230]                   }
[16:12:20.230]                   muffleCondition(cond)
[16:12:20.230]                 })
[16:12:20.230]             }))
[16:12:20.230]             future::FutureResult(value = ...future.value$value, 
[16:12:20.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.230]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.230]                     ...future.globalenv.names))
[16:12:20.230]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.230]         }, condition = base::local({
[16:12:20.230]             c <- base::c
[16:12:20.230]             inherits <- base::inherits
[16:12:20.230]             invokeRestart <- base::invokeRestart
[16:12:20.230]             length <- base::length
[16:12:20.230]             list <- base::list
[16:12:20.230]             seq.int <- base::seq.int
[16:12:20.230]             signalCondition <- base::signalCondition
[16:12:20.230]             sys.calls <- base::sys.calls
[16:12:20.230]             `[[` <- base::`[[`
[16:12:20.230]             `+` <- base::`+`
[16:12:20.230]             `<<-` <- base::`<<-`
[16:12:20.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.230]                   3L)]
[16:12:20.230]             }
[16:12:20.230]             function(cond) {
[16:12:20.230]                 is_error <- inherits(cond, "error")
[16:12:20.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.230]                   NULL)
[16:12:20.230]                 if (is_error) {
[16:12:20.230]                   sessionInformation <- function() {
[16:12:20.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.230]                       search = base::search(), system = base::Sys.info())
[16:12:20.230]                   }
[16:12:20.230]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.230]                     cond$call), session = sessionInformation(), 
[16:12:20.230]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.230]                   signalCondition(cond)
[16:12:20.230]                 }
[16:12:20.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.230]                 "immediateCondition"))) {
[16:12:20.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.230]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.230]                   if (TRUE && !signal) {
[16:12:20.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.230]                     {
[16:12:20.230]                       inherits <- base::inherits
[16:12:20.230]                       invokeRestart <- base::invokeRestart
[16:12:20.230]                       is.null <- base::is.null
[16:12:20.230]                       muffled <- FALSE
[16:12:20.230]                       if (inherits(cond, "message")) {
[16:12:20.230]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.230]                         if (muffled) 
[16:12:20.230]                           invokeRestart("muffleMessage")
[16:12:20.230]                       }
[16:12:20.230]                       else if (inherits(cond, "warning")) {
[16:12:20.230]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.230]                         if (muffled) 
[16:12:20.230]                           invokeRestart("muffleWarning")
[16:12:20.230]                       }
[16:12:20.230]                       else if (inherits(cond, "condition")) {
[16:12:20.230]                         if (!is.null(pattern)) {
[16:12:20.230]                           computeRestarts <- base::computeRestarts
[16:12:20.230]                           grepl <- base::grepl
[16:12:20.230]                           restarts <- computeRestarts(cond)
[16:12:20.230]                           for (restart in restarts) {
[16:12:20.230]                             name <- restart$name
[16:12:20.230]                             if (is.null(name)) 
[16:12:20.230]                               next
[16:12:20.230]                             if (!grepl(pattern, name)) 
[16:12:20.230]                               next
[16:12:20.230]                             invokeRestart(restart)
[16:12:20.230]                             muffled <- TRUE
[16:12:20.230]                             break
[16:12:20.230]                           }
[16:12:20.230]                         }
[16:12:20.230]                       }
[16:12:20.230]                       invisible(muffled)
[16:12:20.230]                     }
[16:12:20.230]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.230]                   }
[16:12:20.230]                 }
[16:12:20.230]                 else {
[16:12:20.230]                   if (TRUE) {
[16:12:20.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.230]                     {
[16:12:20.230]                       inherits <- base::inherits
[16:12:20.230]                       invokeRestart <- base::invokeRestart
[16:12:20.230]                       is.null <- base::is.null
[16:12:20.230]                       muffled <- FALSE
[16:12:20.230]                       if (inherits(cond, "message")) {
[16:12:20.230]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.230]                         if (muffled) 
[16:12:20.230]                           invokeRestart("muffleMessage")
[16:12:20.230]                       }
[16:12:20.230]                       else if (inherits(cond, "warning")) {
[16:12:20.230]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.230]                         if (muffled) 
[16:12:20.230]                           invokeRestart("muffleWarning")
[16:12:20.230]                       }
[16:12:20.230]                       else if (inherits(cond, "condition")) {
[16:12:20.230]                         if (!is.null(pattern)) {
[16:12:20.230]                           computeRestarts <- base::computeRestarts
[16:12:20.230]                           grepl <- base::grepl
[16:12:20.230]                           restarts <- computeRestarts(cond)
[16:12:20.230]                           for (restart in restarts) {
[16:12:20.230]                             name <- restart$name
[16:12:20.230]                             if (is.null(name)) 
[16:12:20.230]                               next
[16:12:20.230]                             if (!grepl(pattern, name)) 
[16:12:20.230]                               next
[16:12:20.230]                             invokeRestart(restart)
[16:12:20.230]                             muffled <- TRUE
[16:12:20.230]                             break
[16:12:20.230]                           }
[16:12:20.230]                         }
[16:12:20.230]                       }
[16:12:20.230]                       invisible(muffled)
[16:12:20.230]                     }
[16:12:20.230]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.230]                   }
[16:12:20.230]                 }
[16:12:20.230]             }
[16:12:20.230]         }))
[16:12:20.230]     }, error = function(ex) {
[16:12:20.230]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.230]                 ...future.rng), started = ...future.startTime, 
[16:12:20.230]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.230]             version = "1.8"), class = "FutureResult")
[16:12:20.230]     }, finally = {
[16:12:20.230]         if (!identical(...future.workdir, getwd())) 
[16:12:20.230]             setwd(...future.workdir)
[16:12:20.230]         {
[16:12:20.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.230]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.230]             }
[16:12:20.230]             base::options(...future.oldOptions)
[16:12:20.230]             if (.Platform$OS.type == "windows") {
[16:12:20.230]                 old_names <- names(...future.oldEnvVars)
[16:12:20.230]                 envs <- base::Sys.getenv()
[16:12:20.230]                 names <- names(envs)
[16:12:20.230]                 common <- intersect(names, old_names)
[16:12:20.230]                 added <- setdiff(names, old_names)
[16:12:20.230]                 removed <- setdiff(old_names, names)
[16:12:20.230]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.230]                   envs[common]]
[16:12:20.230]                 NAMES <- toupper(changed)
[16:12:20.230]                 args <- list()
[16:12:20.230]                 for (kk in seq_along(NAMES)) {
[16:12:20.230]                   name <- changed[[kk]]
[16:12:20.230]                   NAME <- NAMES[[kk]]
[16:12:20.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.230]                     next
[16:12:20.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.230]                 }
[16:12:20.230]                 NAMES <- toupper(added)
[16:12:20.230]                 for (kk in seq_along(NAMES)) {
[16:12:20.230]                   name <- added[[kk]]
[16:12:20.230]                   NAME <- NAMES[[kk]]
[16:12:20.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.230]                     next
[16:12:20.230]                   args[[name]] <- ""
[16:12:20.230]                 }
[16:12:20.230]                 NAMES <- toupper(removed)
[16:12:20.230]                 for (kk in seq_along(NAMES)) {
[16:12:20.230]                   name <- removed[[kk]]
[16:12:20.230]                   NAME <- NAMES[[kk]]
[16:12:20.230]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.230]                     next
[16:12:20.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.230]                 }
[16:12:20.230]                 if (length(args) > 0) 
[16:12:20.230]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.230]             }
[16:12:20.230]             else {
[16:12:20.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.230]             }
[16:12:20.230]             {
[16:12:20.230]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.230]                   0L) {
[16:12:20.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.230]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.230]                   base::options(opts)
[16:12:20.230]                 }
[16:12:20.230]                 {
[16:12:20.230]                   {
[16:12:20.230]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.230]                     NULL
[16:12:20.230]                   }
[16:12:20.230]                   options(future.plan = NULL)
[16:12:20.230]                   if (is.na(NA_character_)) 
[16:12:20.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.230]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.230]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.230]                     envir = parent.frame()) 
[16:12:20.230]                   {
[16:12:20.230]                     if (is.function(workers)) 
[16:12:20.230]                       workers <- workers()
[16:12:20.230]                     workers <- structure(as.integer(workers), 
[16:12:20.230]                       class = class(workers))
[16:12:20.230]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.230]                       workers >= 1)
[16:12:20.230]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.230]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.230]                     }
[16:12:20.230]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.230]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.230]                       envir = envir)
[16:12:20.230]                     if (!future$lazy) 
[16:12:20.230]                       future <- run(future)
[16:12:20.230]                     invisible(future)
[16:12:20.230]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.230]                 }
[16:12:20.230]             }
[16:12:20.230]         }
[16:12:20.230]     })
[16:12:20.230]     if (TRUE) {
[16:12:20.230]         base::sink(type = "output", split = FALSE)
[16:12:20.230]         if (TRUE) {
[16:12:20.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.230]         }
[16:12:20.230]         else {
[16:12:20.230]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.230]         }
[16:12:20.230]         base::close(...future.stdout)
[16:12:20.230]         ...future.stdout <- NULL
[16:12:20.230]     }
[16:12:20.230]     ...future.result$conditions <- ...future.conditions
[16:12:20.230]     ...future.result$finished <- base::Sys.time()
[16:12:20.230]     ...future.result
[16:12:20.230] }
[16:12:20.233] MultisessionFuture started
[16:12:20.234] - Launch lazy future ... done
[16:12:20.234] run() for ‘MultisessionFuture’ ... done
[16:12:20.234] getGlobalsAndPackages() ...
[16:12:20.234] Searching for globals...
[16:12:20.235] - globals found: [1] ‘{’
[16:12:20.235] Searching for globals ... DONE
[16:12:20.235] Resolving globals: FALSE
[16:12:20.236] 
[16:12:20.236] 
[16:12:20.236] getGlobalsAndPackages() ... DONE
[16:12:20.236] run() for ‘Future’ ...
[16:12:20.236] - state: ‘created’
[16:12:20.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.251] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.252]   - Field: ‘node’
[16:12:20.252]   - Field: ‘label’
[16:12:20.252]   - Field: ‘local’
[16:12:20.252]   - Field: ‘owner’
[16:12:20.252]   - Field: ‘envir’
[16:12:20.252]   - Field: ‘workers’
[16:12:20.252]   - Field: ‘packages’
[16:12:20.252]   - Field: ‘gc’
[16:12:20.252]   - Field: ‘conditions’
[16:12:20.253]   - Field: ‘persistent’
[16:12:20.253]   - Field: ‘expr’
[16:12:20.253]   - Field: ‘uuid’
[16:12:20.253]   - Field: ‘seed’
[16:12:20.253]   - Field: ‘version’
[16:12:20.253]   - Field: ‘result’
[16:12:20.253]   - Field: ‘asynchronous’
[16:12:20.253]   - Field: ‘calls’
[16:12:20.253]   - Field: ‘globals’
[16:12:20.254]   - Field: ‘stdout’
[16:12:20.254]   - Field: ‘earlySignal’
[16:12:20.254]   - Field: ‘lazy’
[16:12:20.254]   - Field: ‘state’
[16:12:20.254] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.254] - Launch lazy future ...
[16:12:20.254] Packages needed by the future expression (n = 0): <none>
[16:12:20.255] Packages needed by future strategies (n = 0): <none>
[16:12:20.255] {
[16:12:20.255]     {
[16:12:20.255]         {
[16:12:20.255]             ...future.startTime <- base::Sys.time()
[16:12:20.255]             {
[16:12:20.255]                 {
[16:12:20.255]                   {
[16:12:20.255]                     {
[16:12:20.255]                       base::local({
[16:12:20.255]                         has_future <- base::requireNamespace("future", 
[16:12:20.255]                           quietly = TRUE)
[16:12:20.255]                         if (has_future) {
[16:12:20.255]                           ns <- base::getNamespace("future")
[16:12:20.255]                           version <- ns[[".package"]][["version"]]
[16:12:20.255]                           if (is.null(version)) 
[16:12:20.255]                             version <- utils::packageVersion("future")
[16:12:20.255]                         }
[16:12:20.255]                         else {
[16:12:20.255]                           version <- NULL
[16:12:20.255]                         }
[16:12:20.255]                         if (!has_future || version < "1.8.0") {
[16:12:20.255]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.255]                             "", base::R.version$version.string), 
[16:12:20.255]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.255]                               "release", "version")], collapse = " "), 
[16:12:20.255]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.255]                             info)
[16:12:20.255]                           info <- base::paste(info, collapse = "; ")
[16:12:20.255]                           if (!has_future) {
[16:12:20.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.255]                               info)
[16:12:20.255]                           }
[16:12:20.255]                           else {
[16:12:20.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.255]                               info, version)
[16:12:20.255]                           }
[16:12:20.255]                           base::stop(msg)
[16:12:20.255]                         }
[16:12:20.255]                       })
[16:12:20.255]                     }
[16:12:20.255]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.255]                     base::options(mc.cores = 1L)
[16:12:20.255]                   }
[16:12:20.255]                   options(future.plan = NULL)
[16:12:20.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.255]                 }
[16:12:20.255]                 ...future.workdir <- getwd()
[16:12:20.255]             }
[16:12:20.255]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.255]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.255]         }
[16:12:20.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.255]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.255]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.255]             base::names(...future.oldOptions))
[16:12:20.255]     }
[16:12:20.255]     if (FALSE) {
[16:12:20.255]     }
[16:12:20.255]     else {
[16:12:20.255]         if (TRUE) {
[16:12:20.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.255]                 open = "w")
[16:12:20.255]         }
[16:12:20.255]         else {
[16:12:20.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.255]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.255]         }
[16:12:20.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.255]             base::sink(type = "output", split = FALSE)
[16:12:20.255]             base::close(...future.stdout)
[16:12:20.255]         }, add = TRUE)
[16:12:20.255]     }
[16:12:20.255]     ...future.frame <- base::sys.nframe()
[16:12:20.255]     ...future.conditions <- base::list()
[16:12:20.255]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.255]     if (FALSE) {
[16:12:20.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.255]     }
[16:12:20.255]     ...future.result <- base::tryCatch({
[16:12:20.255]         base::withCallingHandlers({
[16:12:20.255]             ...future.value <- base::withVisible(base::local({
[16:12:20.255]                 ...future.makeSendCondition <- local({
[16:12:20.255]                   sendCondition <- NULL
[16:12:20.255]                   function(frame = 1L) {
[16:12:20.255]                     if (is.function(sendCondition)) 
[16:12:20.255]                       return(sendCondition)
[16:12:20.255]                     ns <- getNamespace("parallel")
[16:12:20.255]                     if (exists("sendData", mode = "function", 
[16:12:20.255]                       envir = ns)) {
[16:12:20.255]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.255]                         envir = ns)
[16:12:20.255]                       envir <- sys.frame(frame)
[16:12:20.255]                       master <- NULL
[16:12:20.255]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.255]                         !identical(envir, emptyenv())) {
[16:12:20.255]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.255]                           inherits = FALSE)) {
[16:12:20.255]                           master <- get("master", mode = "list", 
[16:12:20.255]                             envir = envir, inherits = FALSE)
[16:12:20.255]                           if (inherits(master, c("SOCKnode", 
[16:12:20.255]                             "SOCK0node"))) {
[16:12:20.255]                             sendCondition <<- function(cond) {
[16:12:20.255]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.255]                                 success = TRUE)
[16:12:20.255]                               parallel_sendData(master, data)
[16:12:20.255]                             }
[16:12:20.255]                             return(sendCondition)
[16:12:20.255]                           }
[16:12:20.255]                         }
[16:12:20.255]                         frame <- frame + 1L
[16:12:20.255]                         envir <- sys.frame(frame)
[16:12:20.255]                       }
[16:12:20.255]                     }
[16:12:20.255]                     sendCondition <<- function(cond) NULL
[16:12:20.255]                   }
[16:12:20.255]                 })
[16:12:20.255]                 withCallingHandlers({
[16:12:20.255]                   {
[16:12:20.255]                     4
[16:12:20.255]                   }
[16:12:20.255]                 }, immediateCondition = function(cond) {
[16:12:20.255]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.255]                   sendCondition(cond)
[16:12:20.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.255]                   {
[16:12:20.255]                     inherits <- base::inherits
[16:12:20.255]                     invokeRestart <- base::invokeRestart
[16:12:20.255]                     is.null <- base::is.null
[16:12:20.255]                     muffled <- FALSE
[16:12:20.255]                     if (inherits(cond, "message")) {
[16:12:20.255]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.255]                       if (muffled) 
[16:12:20.255]                         invokeRestart("muffleMessage")
[16:12:20.255]                     }
[16:12:20.255]                     else if (inherits(cond, "warning")) {
[16:12:20.255]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.255]                       if (muffled) 
[16:12:20.255]                         invokeRestart("muffleWarning")
[16:12:20.255]                     }
[16:12:20.255]                     else if (inherits(cond, "condition")) {
[16:12:20.255]                       if (!is.null(pattern)) {
[16:12:20.255]                         computeRestarts <- base::computeRestarts
[16:12:20.255]                         grepl <- base::grepl
[16:12:20.255]                         restarts <- computeRestarts(cond)
[16:12:20.255]                         for (restart in restarts) {
[16:12:20.255]                           name <- restart$name
[16:12:20.255]                           if (is.null(name)) 
[16:12:20.255]                             next
[16:12:20.255]                           if (!grepl(pattern, name)) 
[16:12:20.255]                             next
[16:12:20.255]                           invokeRestart(restart)
[16:12:20.255]                           muffled <- TRUE
[16:12:20.255]                           break
[16:12:20.255]                         }
[16:12:20.255]                       }
[16:12:20.255]                     }
[16:12:20.255]                     invisible(muffled)
[16:12:20.255]                   }
[16:12:20.255]                   muffleCondition(cond)
[16:12:20.255]                 })
[16:12:20.255]             }))
[16:12:20.255]             future::FutureResult(value = ...future.value$value, 
[16:12:20.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.255]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.255]                     ...future.globalenv.names))
[16:12:20.255]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.255]         }, condition = base::local({
[16:12:20.255]             c <- base::c
[16:12:20.255]             inherits <- base::inherits
[16:12:20.255]             invokeRestart <- base::invokeRestart
[16:12:20.255]             length <- base::length
[16:12:20.255]             list <- base::list
[16:12:20.255]             seq.int <- base::seq.int
[16:12:20.255]             signalCondition <- base::signalCondition
[16:12:20.255]             sys.calls <- base::sys.calls
[16:12:20.255]             `[[` <- base::`[[`
[16:12:20.255]             `+` <- base::`+`
[16:12:20.255]             `<<-` <- base::`<<-`
[16:12:20.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.255]                   3L)]
[16:12:20.255]             }
[16:12:20.255]             function(cond) {
[16:12:20.255]                 is_error <- inherits(cond, "error")
[16:12:20.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.255]                   NULL)
[16:12:20.255]                 if (is_error) {
[16:12:20.255]                   sessionInformation <- function() {
[16:12:20.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.255]                       search = base::search(), system = base::Sys.info())
[16:12:20.255]                   }
[16:12:20.255]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.255]                     cond$call), session = sessionInformation(), 
[16:12:20.255]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.255]                   signalCondition(cond)
[16:12:20.255]                 }
[16:12:20.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.255]                 "immediateCondition"))) {
[16:12:20.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.255]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.255]                   if (TRUE && !signal) {
[16:12:20.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.255]                     {
[16:12:20.255]                       inherits <- base::inherits
[16:12:20.255]                       invokeRestart <- base::invokeRestart
[16:12:20.255]                       is.null <- base::is.null
[16:12:20.255]                       muffled <- FALSE
[16:12:20.255]                       if (inherits(cond, "message")) {
[16:12:20.255]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.255]                         if (muffled) 
[16:12:20.255]                           invokeRestart("muffleMessage")
[16:12:20.255]                       }
[16:12:20.255]                       else if (inherits(cond, "warning")) {
[16:12:20.255]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.255]                         if (muffled) 
[16:12:20.255]                           invokeRestart("muffleWarning")
[16:12:20.255]                       }
[16:12:20.255]                       else if (inherits(cond, "condition")) {
[16:12:20.255]                         if (!is.null(pattern)) {
[16:12:20.255]                           computeRestarts <- base::computeRestarts
[16:12:20.255]                           grepl <- base::grepl
[16:12:20.255]                           restarts <- computeRestarts(cond)
[16:12:20.255]                           for (restart in restarts) {
[16:12:20.255]                             name <- restart$name
[16:12:20.255]                             if (is.null(name)) 
[16:12:20.255]                               next
[16:12:20.255]                             if (!grepl(pattern, name)) 
[16:12:20.255]                               next
[16:12:20.255]                             invokeRestart(restart)
[16:12:20.255]                             muffled <- TRUE
[16:12:20.255]                             break
[16:12:20.255]                           }
[16:12:20.255]                         }
[16:12:20.255]                       }
[16:12:20.255]                       invisible(muffled)
[16:12:20.255]                     }
[16:12:20.255]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.255]                   }
[16:12:20.255]                 }
[16:12:20.255]                 else {
[16:12:20.255]                   if (TRUE) {
[16:12:20.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.255]                     {
[16:12:20.255]                       inherits <- base::inherits
[16:12:20.255]                       invokeRestart <- base::invokeRestart
[16:12:20.255]                       is.null <- base::is.null
[16:12:20.255]                       muffled <- FALSE
[16:12:20.255]                       if (inherits(cond, "message")) {
[16:12:20.255]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.255]                         if (muffled) 
[16:12:20.255]                           invokeRestart("muffleMessage")
[16:12:20.255]                       }
[16:12:20.255]                       else if (inherits(cond, "warning")) {
[16:12:20.255]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.255]                         if (muffled) 
[16:12:20.255]                           invokeRestart("muffleWarning")
[16:12:20.255]                       }
[16:12:20.255]                       else if (inherits(cond, "condition")) {
[16:12:20.255]                         if (!is.null(pattern)) {
[16:12:20.255]                           computeRestarts <- base::computeRestarts
[16:12:20.255]                           grepl <- base::grepl
[16:12:20.255]                           restarts <- computeRestarts(cond)
[16:12:20.255]                           for (restart in restarts) {
[16:12:20.255]                             name <- restart$name
[16:12:20.255]                             if (is.null(name)) 
[16:12:20.255]                               next
[16:12:20.255]                             if (!grepl(pattern, name)) 
[16:12:20.255]                               next
[16:12:20.255]                             invokeRestart(restart)
[16:12:20.255]                             muffled <- TRUE
[16:12:20.255]                             break
[16:12:20.255]                           }
[16:12:20.255]                         }
[16:12:20.255]                       }
[16:12:20.255]                       invisible(muffled)
[16:12:20.255]                     }
[16:12:20.255]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.255]                   }
[16:12:20.255]                 }
[16:12:20.255]             }
[16:12:20.255]         }))
[16:12:20.255]     }, error = function(ex) {
[16:12:20.255]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.255]                 ...future.rng), started = ...future.startTime, 
[16:12:20.255]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.255]             version = "1.8"), class = "FutureResult")
[16:12:20.255]     }, finally = {
[16:12:20.255]         if (!identical(...future.workdir, getwd())) 
[16:12:20.255]             setwd(...future.workdir)
[16:12:20.255]         {
[16:12:20.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.255]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.255]             }
[16:12:20.255]             base::options(...future.oldOptions)
[16:12:20.255]             if (.Platform$OS.type == "windows") {
[16:12:20.255]                 old_names <- names(...future.oldEnvVars)
[16:12:20.255]                 envs <- base::Sys.getenv()
[16:12:20.255]                 names <- names(envs)
[16:12:20.255]                 common <- intersect(names, old_names)
[16:12:20.255]                 added <- setdiff(names, old_names)
[16:12:20.255]                 removed <- setdiff(old_names, names)
[16:12:20.255]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.255]                   envs[common]]
[16:12:20.255]                 NAMES <- toupper(changed)
[16:12:20.255]                 args <- list()
[16:12:20.255]                 for (kk in seq_along(NAMES)) {
[16:12:20.255]                   name <- changed[[kk]]
[16:12:20.255]                   NAME <- NAMES[[kk]]
[16:12:20.255]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.255]                     next
[16:12:20.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.255]                 }
[16:12:20.255]                 NAMES <- toupper(added)
[16:12:20.255]                 for (kk in seq_along(NAMES)) {
[16:12:20.255]                   name <- added[[kk]]
[16:12:20.255]                   NAME <- NAMES[[kk]]
[16:12:20.255]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.255]                     next
[16:12:20.255]                   args[[name]] <- ""
[16:12:20.255]                 }
[16:12:20.255]                 NAMES <- toupper(removed)
[16:12:20.255]                 for (kk in seq_along(NAMES)) {
[16:12:20.255]                   name <- removed[[kk]]
[16:12:20.255]                   NAME <- NAMES[[kk]]
[16:12:20.255]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.255]                     next
[16:12:20.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.255]                 }
[16:12:20.255]                 if (length(args) > 0) 
[16:12:20.255]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.255]             }
[16:12:20.255]             else {
[16:12:20.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.255]             }
[16:12:20.255]             {
[16:12:20.255]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.255]                   0L) {
[16:12:20.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.255]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.255]                   base::options(opts)
[16:12:20.255]                 }
[16:12:20.255]                 {
[16:12:20.255]                   {
[16:12:20.255]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.255]                     NULL
[16:12:20.255]                   }
[16:12:20.255]                   options(future.plan = NULL)
[16:12:20.255]                   if (is.na(NA_character_)) 
[16:12:20.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.255]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.255]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.255]                     envir = parent.frame()) 
[16:12:20.255]                   {
[16:12:20.255]                     if (is.function(workers)) 
[16:12:20.255]                       workers <- workers()
[16:12:20.255]                     workers <- structure(as.integer(workers), 
[16:12:20.255]                       class = class(workers))
[16:12:20.255]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.255]                       workers >= 1)
[16:12:20.255]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.255]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.255]                     }
[16:12:20.255]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.255]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.255]                       envir = envir)
[16:12:20.255]                     if (!future$lazy) 
[16:12:20.255]                       future <- run(future)
[16:12:20.255]                     invisible(future)
[16:12:20.255]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.255]                 }
[16:12:20.255]             }
[16:12:20.255]         }
[16:12:20.255]     })
[16:12:20.255]     if (TRUE) {
[16:12:20.255]         base::sink(type = "output", split = FALSE)
[16:12:20.255]         if (TRUE) {
[16:12:20.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.255]         }
[16:12:20.255]         else {
[16:12:20.255]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.255]         }
[16:12:20.255]         base::close(...future.stdout)
[16:12:20.255]         ...future.stdout <- NULL
[16:12:20.255]     }
[16:12:20.255]     ...future.result$conditions <- ...future.conditions
[16:12:20.255]     ...future.result$finished <- base::Sys.time()
[16:12:20.255]     ...future.result
[16:12:20.255] }
[16:12:20.328] MultisessionFuture started
[16:12:20.328] - Launch lazy future ... done
[16:12:20.328] run() for ‘MultisessionFuture’ ... done
[16:12:20.328] result() for ClusterFuture ...
[16:12:20.328] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.328] - Validating connection of MultisessionFuture
[16:12:20.329] - received message: FutureResult
[16:12:20.329] - Received FutureResult
[16:12:20.329] - Erased future from FutureRegistry
[16:12:20.329] result() for ClusterFuture ...
[16:12:20.329] - result already collected: FutureResult
[16:12:20.329] result() for ClusterFuture ... done
[16:12:20.329] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.330] result() for ClusterFuture ... done
[16:12:20.330] result() for ClusterFuture ...
[16:12:20.330] - result already collected: FutureResult
[16:12:20.330] result() for ClusterFuture ... done
u$a = 2
[16:12:20.330] result() for ClusterFuture ...
[16:12:20.330] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.330] - Validating connection of MultisessionFuture
[16:12:20.360] - received message: FutureResult
[16:12:20.360] - Received FutureResult
[16:12:20.360] - Erased future from FutureRegistry
[16:12:20.360] result() for ClusterFuture ...
[16:12:20.360] - result already collected: FutureResult
[16:12:20.360] result() for ClusterFuture ... done
[16:12:20.361] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.361] result() for ClusterFuture ... done
[16:12:20.361] result() for ClusterFuture ...
[16:12:20.361] - result already collected: FutureResult
[16:12:20.361] result() for ClusterFuture ... done
v$a = 4
[16:12:20.361] getGlobalsAndPackages() ...
[16:12:20.361] Searching for globals...
[16:12:20.363] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:20.363] Searching for globals ... DONE
[16:12:20.363] Resolving globals: FALSE
[16:12:20.363] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:20.364] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:20.364] - globals: [1] ‘a’
[16:12:20.364] 
[16:12:20.364] getGlobalsAndPackages() ... DONE
[16:12:20.364] run() for ‘Future’ ...
[16:12:20.365] - state: ‘created’
[16:12:20.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.380]   - Field: ‘node’
[16:12:20.380]   - Field: ‘label’
[16:12:20.381]   - Field: ‘local’
[16:12:20.381]   - Field: ‘owner’
[16:12:20.381]   - Field: ‘envir’
[16:12:20.381]   - Field: ‘workers’
[16:12:20.381]   - Field: ‘packages’
[16:12:20.381]   - Field: ‘gc’
[16:12:20.381]   - Field: ‘conditions’
[16:12:20.381]   - Field: ‘persistent’
[16:12:20.381]   - Field: ‘expr’
[16:12:20.381]   - Field: ‘uuid’
[16:12:20.382]   - Field: ‘seed’
[16:12:20.382]   - Field: ‘version’
[16:12:20.382]   - Field: ‘result’
[16:12:20.382]   - Field: ‘asynchronous’
[16:12:20.382]   - Field: ‘calls’
[16:12:20.382]   - Field: ‘globals’
[16:12:20.382]   - Field: ‘stdout’
[16:12:20.382]   - Field: ‘earlySignal’
[16:12:20.382]   - Field: ‘lazy’
[16:12:20.383]   - Field: ‘state’
[16:12:20.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.383] - Launch lazy future ...
[16:12:20.383] Packages needed by the future expression (n = 0): <none>
[16:12:20.383] Packages needed by future strategies (n = 0): <none>
[16:12:20.384] {
[16:12:20.384]     {
[16:12:20.384]         {
[16:12:20.384]             ...future.startTime <- base::Sys.time()
[16:12:20.384]             {
[16:12:20.384]                 {
[16:12:20.384]                   {
[16:12:20.384]                     {
[16:12:20.384]                       base::local({
[16:12:20.384]                         has_future <- base::requireNamespace("future", 
[16:12:20.384]                           quietly = TRUE)
[16:12:20.384]                         if (has_future) {
[16:12:20.384]                           ns <- base::getNamespace("future")
[16:12:20.384]                           version <- ns[[".package"]][["version"]]
[16:12:20.384]                           if (is.null(version)) 
[16:12:20.384]                             version <- utils::packageVersion("future")
[16:12:20.384]                         }
[16:12:20.384]                         else {
[16:12:20.384]                           version <- NULL
[16:12:20.384]                         }
[16:12:20.384]                         if (!has_future || version < "1.8.0") {
[16:12:20.384]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.384]                             "", base::R.version$version.string), 
[16:12:20.384]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.384]                               "release", "version")], collapse = " "), 
[16:12:20.384]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.384]                             info)
[16:12:20.384]                           info <- base::paste(info, collapse = "; ")
[16:12:20.384]                           if (!has_future) {
[16:12:20.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.384]                               info)
[16:12:20.384]                           }
[16:12:20.384]                           else {
[16:12:20.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.384]                               info, version)
[16:12:20.384]                           }
[16:12:20.384]                           base::stop(msg)
[16:12:20.384]                         }
[16:12:20.384]                       })
[16:12:20.384]                     }
[16:12:20.384]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.384]                     base::options(mc.cores = 1L)
[16:12:20.384]                   }
[16:12:20.384]                   options(future.plan = NULL)
[16:12:20.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.384]                 }
[16:12:20.384]                 ...future.workdir <- getwd()
[16:12:20.384]             }
[16:12:20.384]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.384]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.384]         }
[16:12:20.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.384]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.384]             base::names(...future.oldOptions))
[16:12:20.384]     }
[16:12:20.384]     if (FALSE) {
[16:12:20.384]     }
[16:12:20.384]     else {
[16:12:20.384]         if (TRUE) {
[16:12:20.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.384]                 open = "w")
[16:12:20.384]         }
[16:12:20.384]         else {
[16:12:20.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.384]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.384]         }
[16:12:20.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.384]             base::sink(type = "output", split = FALSE)
[16:12:20.384]             base::close(...future.stdout)
[16:12:20.384]         }, add = TRUE)
[16:12:20.384]     }
[16:12:20.384]     ...future.frame <- base::sys.nframe()
[16:12:20.384]     ...future.conditions <- base::list()
[16:12:20.384]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.384]     if (FALSE) {
[16:12:20.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.384]     }
[16:12:20.384]     ...future.result <- base::tryCatch({
[16:12:20.384]         base::withCallingHandlers({
[16:12:20.384]             ...future.value <- base::withVisible(base::local({
[16:12:20.384]                 ...future.makeSendCondition <- local({
[16:12:20.384]                   sendCondition <- NULL
[16:12:20.384]                   function(frame = 1L) {
[16:12:20.384]                     if (is.function(sendCondition)) 
[16:12:20.384]                       return(sendCondition)
[16:12:20.384]                     ns <- getNamespace("parallel")
[16:12:20.384]                     if (exists("sendData", mode = "function", 
[16:12:20.384]                       envir = ns)) {
[16:12:20.384]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.384]                         envir = ns)
[16:12:20.384]                       envir <- sys.frame(frame)
[16:12:20.384]                       master <- NULL
[16:12:20.384]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.384]                         !identical(envir, emptyenv())) {
[16:12:20.384]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.384]                           inherits = FALSE)) {
[16:12:20.384]                           master <- get("master", mode = "list", 
[16:12:20.384]                             envir = envir, inherits = FALSE)
[16:12:20.384]                           if (inherits(master, c("SOCKnode", 
[16:12:20.384]                             "SOCK0node"))) {
[16:12:20.384]                             sendCondition <<- function(cond) {
[16:12:20.384]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.384]                                 success = TRUE)
[16:12:20.384]                               parallel_sendData(master, data)
[16:12:20.384]                             }
[16:12:20.384]                             return(sendCondition)
[16:12:20.384]                           }
[16:12:20.384]                         }
[16:12:20.384]                         frame <- frame + 1L
[16:12:20.384]                         envir <- sys.frame(frame)
[16:12:20.384]                       }
[16:12:20.384]                     }
[16:12:20.384]                     sendCondition <<- function(cond) NULL
[16:12:20.384]                   }
[16:12:20.384]                 })
[16:12:20.384]                 withCallingHandlers({
[16:12:20.384]                   {
[16:12:20.384]                     2 * a
[16:12:20.384]                   }
[16:12:20.384]                 }, immediateCondition = function(cond) {
[16:12:20.384]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.384]                   sendCondition(cond)
[16:12:20.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.384]                   {
[16:12:20.384]                     inherits <- base::inherits
[16:12:20.384]                     invokeRestart <- base::invokeRestart
[16:12:20.384]                     is.null <- base::is.null
[16:12:20.384]                     muffled <- FALSE
[16:12:20.384]                     if (inherits(cond, "message")) {
[16:12:20.384]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.384]                       if (muffled) 
[16:12:20.384]                         invokeRestart("muffleMessage")
[16:12:20.384]                     }
[16:12:20.384]                     else if (inherits(cond, "warning")) {
[16:12:20.384]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.384]                       if (muffled) 
[16:12:20.384]                         invokeRestart("muffleWarning")
[16:12:20.384]                     }
[16:12:20.384]                     else if (inherits(cond, "condition")) {
[16:12:20.384]                       if (!is.null(pattern)) {
[16:12:20.384]                         computeRestarts <- base::computeRestarts
[16:12:20.384]                         grepl <- base::grepl
[16:12:20.384]                         restarts <- computeRestarts(cond)
[16:12:20.384]                         for (restart in restarts) {
[16:12:20.384]                           name <- restart$name
[16:12:20.384]                           if (is.null(name)) 
[16:12:20.384]                             next
[16:12:20.384]                           if (!grepl(pattern, name)) 
[16:12:20.384]                             next
[16:12:20.384]                           invokeRestart(restart)
[16:12:20.384]                           muffled <- TRUE
[16:12:20.384]                           break
[16:12:20.384]                         }
[16:12:20.384]                       }
[16:12:20.384]                     }
[16:12:20.384]                     invisible(muffled)
[16:12:20.384]                   }
[16:12:20.384]                   muffleCondition(cond)
[16:12:20.384]                 })
[16:12:20.384]             }))
[16:12:20.384]             future::FutureResult(value = ...future.value$value, 
[16:12:20.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.384]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.384]                     ...future.globalenv.names))
[16:12:20.384]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.384]         }, condition = base::local({
[16:12:20.384]             c <- base::c
[16:12:20.384]             inherits <- base::inherits
[16:12:20.384]             invokeRestart <- base::invokeRestart
[16:12:20.384]             length <- base::length
[16:12:20.384]             list <- base::list
[16:12:20.384]             seq.int <- base::seq.int
[16:12:20.384]             signalCondition <- base::signalCondition
[16:12:20.384]             sys.calls <- base::sys.calls
[16:12:20.384]             `[[` <- base::`[[`
[16:12:20.384]             `+` <- base::`+`
[16:12:20.384]             `<<-` <- base::`<<-`
[16:12:20.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.384]                   3L)]
[16:12:20.384]             }
[16:12:20.384]             function(cond) {
[16:12:20.384]                 is_error <- inherits(cond, "error")
[16:12:20.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.384]                   NULL)
[16:12:20.384]                 if (is_error) {
[16:12:20.384]                   sessionInformation <- function() {
[16:12:20.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.384]                       search = base::search(), system = base::Sys.info())
[16:12:20.384]                   }
[16:12:20.384]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.384]                     cond$call), session = sessionInformation(), 
[16:12:20.384]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.384]                   signalCondition(cond)
[16:12:20.384]                 }
[16:12:20.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.384]                 "immediateCondition"))) {
[16:12:20.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.384]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.384]                   if (TRUE && !signal) {
[16:12:20.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.384]                     {
[16:12:20.384]                       inherits <- base::inherits
[16:12:20.384]                       invokeRestart <- base::invokeRestart
[16:12:20.384]                       is.null <- base::is.null
[16:12:20.384]                       muffled <- FALSE
[16:12:20.384]                       if (inherits(cond, "message")) {
[16:12:20.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.384]                         if (muffled) 
[16:12:20.384]                           invokeRestart("muffleMessage")
[16:12:20.384]                       }
[16:12:20.384]                       else if (inherits(cond, "warning")) {
[16:12:20.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.384]                         if (muffled) 
[16:12:20.384]                           invokeRestart("muffleWarning")
[16:12:20.384]                       }
[16:12:20.384]                       else if (inherits(cond, "condition")) {
[16:12:20.384]                         if (!is.null(pattern)) {
[16:12:20.384]                           computeRestarts <- base::computeRestarts
[16:12:20.384]                           grepl <- base::grepl
[16:12:20.384]                           restarts <- computeRestarts(cond)
[16:12:20.384]                           for (restart in restarts) {
[16:12:20.384]                             name <- restart$name
[16:12:20.384]                             if (is.null(name)) 
[16:12:20.384]                               next
[16:12:20.384]                             if (!grepl(pattern, name)) 
[16:12:20.384]                               next
[16:12:20.384]                             invokeRestart(restart)
[16:12:20.384]                             muffled <- TRUE
[16:12:20.384]                             break
[16:12:20.384]                           }
[16:12:20.384]                         }
[16:12:20.384]                       }
[16:12:20.384]                       invisible(muffled)
[16:12:20.384]                     }
[16:12:20.384]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.384]                   }
[16:12:20.384]                 }
[16:12:20.384]                 else {
[16:12:20.384]                   if (TRUE) {
[16:12:20.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.384]                     {
[16:12:20.384]                       inherits <- base::inherits
[16:12:20.384]                       invokeRestart <- base::invokeRestart
[16:12:20.384]                       is.null <- base::is.null
[16:12:20.384]                       muffled <- FALSE
[16:12:20.384]                       if (inherits(cond, "message")) {
[16:12:20.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.384]                         if (muffled) 
[16:12:20.384]                           invokeRestart("muffleMessage")
[16:12:20.384]                       }
[16:12:20.384]                       else if (inherits(cond, "warning")) {
[16:12:20.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.384]                         if (muffled) 
[16:12:20.384]                           invokeRestart("muffleWarning")
[16:12:20.384]                       }
[16:12:20.384]                       else if (inherits(cond, "condition")) {
[16:12:20.384]                         if (!is.null(pattern)) {
[16:12:20.384]                           computeRestarts <- base::computeRestarts
[16:12:20.384]                           grepl <- base::grepl
[16:12:20.384]                           restarts <- computeRestarts(cond)
[16:12:20.384]                           for (restart in restarts) {
[16:12:20.384]                             name <- restart$name
[16:12:20.384]                             if (is.null(name)) 
[16:12:20.384]                               next
[16:12:20.384]                             if (!grepl(pattern, name)) 
[16:12:20.384]                               next
[16:12:20.384]                             invokeRestart(restart)
[16:12:20.384]                             muffled <- TRUE
[16:12:20.384]                             break
[16:12:20.384]                           }
[16:12:20.384]                         }
[16:12:20.384]                       }
[16:12:20.384]                       invisible(muffled)
[16:12:20.384]                     }
[16:12:20.384]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.384]                   }
[16:12:20.384]                 }
[16:12:20.384]             }
[16:12:20.384]         }))
[16:12:20.384]     }, error = function(ex) {
[16:12:20.384]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.384]                 ...future.rng), started = ...future.startTime, 
[16:12:20.384]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.384]             version = "1.8"), class = "FutureResult")
[16:12:20.384]     }, finally = {
[16:12:20.384]         if (!identical(...future.workdir, getwd())) 
[16:12:20.384]             setwd(...future.workdir)
[16:12:20.384]         {
[16:12:20.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.384]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.384]             }
[16:12:20.384]             base::options(...future.oldOptions)
[16:12:20.384]             if (.Platform$OS.type == "windows") {
[16:12:20.384]                 old_names <- names(...future.oldEnvVars)
[16:12:20.384]                 envs <- base::Sys.getenv()
[16:12:20.384]                 names <- names(envs)
[16:12:20.384]                 common <- intersect(names, old_names)
[16:12:20.384]                 added <- setdiff(names, old_names)
[16:12:20.384]                 removed <- setdiff(old_names, names)
[16:12:20.384]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.384]                   envs[common]]
[16:12:20.384]                 NAMES <- toupper(changed)
[16:12:20.384]                 args <- list()
[16:12:20.384]                 for (kk in seq_along(NAMES)) {
[16:12:20.384]                   name <- changed[[kk]]
[16:12:20.384]                   NAME <- NAMES[[kk]]
[16:12:20.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.384]                     next
[16:12:20.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.384]                 }
[16:12:20.384]                 NAMES <- toupper(added)
[16:12:20.384]                 for (kk in seq_along(NAMES)) {
[16:12:20.384]                   name <- added[[kk]]
[16:12:20.384]                   NAME <- NAMES[[kk]]
[16:12:20.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.384]                     next
[16:12:20.384]                   args[[name]] <- ""
[16:12:20.384]                 }
[16:12:20.384]                 NAMES <- toupper(removed)
[16:12:20.384]                 for (kk in seq_along(NAMES)) {
[16:12:20.384]                   name <- removed[[kk]]
[16:12:20.384]                   NAME <- NAMES[[kk]]
[16:12:20.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.384]                     next
[16:12:20.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.384]                 }
[16:12:20.384]                 if (length(args) > 0) 
[16:12:20.384]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.384]             }
[16:12:20.384]             else {
[16:12:20.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.384]             }
[16:12:20.384]             {
[16:12:20.384]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.384]                   0L) {
[16:12:20.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.384]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.384]                   base::options(opts)
[16:12:20.384]                 }
[16:12:20.384]                 {
[16:12:20.384]                   {
[16:12:20.384]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.384]                     NULL
[16:12:20.384]                   }
[16:12:20.384]                   options(future.plan = NULL)
[16:12:20.384]                   if (is.na(NA_character_)) 
[16:12:20.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.384]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.384]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.384]                     envir = parent.frame()) 
[16:12:20.384]                   {
[16:12:20.384]                     if (is.function(workers)) 
[16:12:20.384]                       workers <- workers()
[16:12:20.384]                     workers <- structure(as.integer(workers), 
[16:12:20.384]                       class = class(workers))
[16:12:20.384]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.384]                       workers >= 1)
[16:12:20.384]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.384]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.384]                     }
[16:12:20.384]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.384]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.384]                       envir = envir)
[16:12:20.384]                     if (!future$lazy) 
[16:12:20.384]                       future <- run(future)
[16:12:20.384]                     invisible(future)
[16:12:20.384]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.384]                 }
[16:12:20.384]             }
[16:12:20.384]         }
[16:12:20.384]     })
[16:12:20.384]     if (TRUE) {
[16:12:20.384]         base::sink(type = "output", split = FALSE)
[16:12:20.384]         if (TRUE) {
[16:12:20.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.384]         }
[16:12:20.384]         else {
[16:12:20.384]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.384]         }
[16:12:20.384]         base::close(...future.stdout)
[16:12:20.384]         ...future.stdout <- NULL
[16:12:20.384]     }
[16:12:20.384]     ...future.result$conditions <- ...future.conditions
[16:12:20.384]     ...future.result$finished <- base::Sys.time()
[16:12:20.384]     ...future.result
[16:12:20.384] }
[16:12:20.387] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:20.387] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:20.388] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:20.388] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:20.388] MultisessionFuture started
[16:12:20.389] - Launch lazy future ... done
[16:12:20.389] run() for ‘MultisessionFuture’ ... done
[16:12:20.389] result() for ClusterFuture ...
[16:12:20.389] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.389] - Validating connection of MultisessionFuture
[16:12:20.437] - received message: FutureResult
[16:12:20.437] - Received FutureResult
[16:12:20.437] - Erased future from FutureRegistry
[16:12:20.437] result() for ClusterFuture ...
[16:12:20.437] - result already collected: FutureResult
[16:12:20.438] result() for ClusterFuture ... done
[16:12:20.438] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.438] result() for ClusterFuture ... done
[16:12:20.438] result() for ClusterFuture ...
[16:12:20.438] - result already collected: FutureResult
[16:12:20.438] result() for ClusterFuture ... done
[16:12:20.439] getGlobalsAndPackages() ...
[16:12:20.439] Searching for globals...
[16:12:20.440] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:20.440] Searching for globals ... DONE
[16:12:20.440] Resolving globals: FALSE
[16:12:20.441] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:20.441] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:20.441] - globals: [1] ‘a’
[16:12:20.441] 
[16:12:20.441] getGlobalsAndPackages() ... DONE
[16:12:20.442] run() for ‘Future’ ...
[16:12:20.442] - state: ‘created’
[16:12:20.444] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.458]   - Field: ‘node’
[16:12:20.458]   - Field: ‘label’
[16:12:20.458]   - Field: ‘local’
[16:12:20.458]   - Field: ‘owner’
[16:12:20.458]   - Field: ‘envir’
[16:12:20.459]   - Field: ‘workers’
[16:12:20.459]   - Field: ‘packages’
[16:12:20.459]   - Field: ‘gc’
[16:12:20.459]   - Field: ‘conditions’
[16:12:20.459]   - Field: ‘persistent’
[16:12:20.459]   - Field: ‘expr’
[16:12:20.459]   - Field: ‘uuid’
[16:12:20.459]   - Field: ‘seed’
[16:12:20.459]   - Field: ‘version’
[16:12:20.459]   - Field: ‘result’
[16:12:20.459]   - Field: ‘asynchronous’
[16:12:20.459]   - Field: ‘calls’
[16:12:20.460]   - Field: ‘globals’
[16:12:20.460]   - Field: ‘stdout’
[16:12:20.460]   - Field: ‘earlySignal’
[16:12:20.460]   - Field: ‘lazy’
[16:12:20.460]   - Field: ‘state’
[16:12:20.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.460] - Launch lazy future ...
[16:12:20.460] Packages needed by the future expression (n = 0): <none>
[16:12:20.461] Packages needed by future strategies (n = 0): <none>
[16:12:20.461] {
[16:12:20.461]     {
[16:12:20.461]         {
[16:12:20.461]             ...future.startTime <- base::Sys.time()
[16:12:20.461]             {
[16:12:20.461]                 {
[16:12:20.461]                   {
[16:12:20.461]                     {
[16:12:20.461]                       base::local({
[16:12:20.461]                         has_future <- base::requireNamespace("future", 
[16:12:20.461]                           quietly = TRUE)
[16:12:20.461]                         if (has_future) {
[16:12:20.461]                           ns <- base::getNamespace("future")
[16:12:20.461]                           version <- ns[[".package"]][["version"]]
[16:12:20.461]                           if (is.null(version)) 
[16:12:20.461]                             version <- utils::packageVersion("future")
[16:12:20.461]                         }
[16:12:20.461]                         else {
[16:12:20.461]                           version <- NULL
[16:12:20.461]                         }
[16:12:20.461]                         if (!has_future || version < "1.8.0") {
[16:12:20.461]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.461]                             "", base::R.version$version.string), 
[16:12:20.461]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.461]                               "release", "version")], collapse = " "), 
[16:12:20.461]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.461]                             info)
[16:12:20.461]                           info <- base::paste(info, collapse = "; ")
[16:12:20.461]                           if (!has_future) {
[16:12:20.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.461]                               info)
[16:12:20.461]                           }
[16:12:20.461]                           else {
[16:12:20.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.461]                               info, version)
[16:12:20.461]                           }
[16:12:20.461]                           base::stop(msg)
[16:12:20.461]                         }
[16:12:20.461]                       })
[16:12:20.461]                     }
[16:12:20.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.461]                     base::options(mc.cores = 1L)
[16:12:20.461]                   }
[16:12:20.461]                   options(future.plan = NULL)
[16:12:20.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.461]                 }
[16:12:20.461]                 ...future.workdir <- getwd()
[16:12:20.461]             }
[16:12:20.461]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.461]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.461]         }
[16:12:20.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.461]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.461]             base::names(...future.oldOptions))
[16:12:20.461]     }
[16:12:20.461]     if (FALSE) {
[16:12:20.461]     }
[16:12:20.461]     else {
[16:12:20.461]         if (TRUE) {
[16:12:20.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.461]                 open = "w")
[16:12:20.461]         }
[16:12:20.461]         else {
[16:12:20.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.461]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.461]         }
[16:12:20.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.461]             base::sink(type = "output", split = FALSE)
[16:12:20.461]             base::close(...future.stdout)
[16:12:20.461]         }, add = TRUE)
[16:12:20.461]     }
[16:12:20.461]     ...future.frame <- base::sys.nframe()
[16:12:20.461]     ...future.conditions <- base::list()
[16:12:20.461]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.461]     if (FALSE) {
[16:12:20.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.461]     }
[16:12:20.461]     ...future.result <- base::tryCatch({
[16:12:20.461]         base::withCallingHandlers({
[16:12:20.461]             ...future.value <- base::withVisible(base::local({
[16:12:20.461]                 ...future.makeSendCondition <- local({
[16:12:20.461]                   sendCondition <- NULL
[16:12:20.461]                   function(frame = 1L) {
[16:12:20.461]                     if (is.function(sendCondition)) 
[16:12:20.461]                       return(sendCondition)
[16:12:20.461]                     ns <- getNamespace("parallel")
[16:12:20.461]                     if (exists("sendData", mode = "function", 
[16:12:20.461]                       envir = ns)) {
[16:12:20.461]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.461]                         envir = ns)
[16:12:20.461]                       envir <- sys.frame(frame)
[16:12:20.461]                       master <- NULL
[16:12:20.461]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.461]                         !identical(envir, emptyenv())) {
[16:12:20.461]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.461]                           inherits = FALSE)) {
[16:12:20.461]                           master <- get("master", mode = "list", 
[16:12:20.461]                             envir = envir, inherits = FALSE)
[16:12:20.461]                           if (inherits(master, c("SOCKnode", 
[16:12:20.461]                             "SOCK0node"))) {
[16:12:20.461]                             sendCondition <<- function(cond) {
[16:12:20.461]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.461]                                 success = TRUE)
[16:12:20.461]                               parallel_sendData(master, data)
[16:12:20.461]                             }
[16:12:20.461]                             return(sendCondition)
[16:12:20.461]                           }
[16:12:20.461]                         }
[16:12:20.461]                         frame <- frame + 1L
[16:12:20.461]                         envir <- sys.frame(frame)
[16:12:20.461]                       }
[16:12:20.461]                     }
[16:12:20.461]                     sendCondition <<- function(cond) NULL
[16:12:20.461]                   }
[16:12:20.461]                 })
[16:12:20.461]                 withCallingHandlers({
[16:12:20.461]                   {
[16:12:20.461]                     2 * a
[16:12:20.461]                   }
[16:12:20.461]                 }, immediateCondition = function(cond) {
[16:12:20.461]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.461]                   sendCondition(cond)
[16:12:20.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.461]                   {
[16:12:20.461]                     inherits <- base::inherits
[16:12:20.461]                     invokeRestart <- base::invokeRestart
[16:12:20.461]                     is.null <- base::is.null
[16:12:20.461]                     muffled <- FALSE
[16:12:20.461]                     if (inherits(cond, "message")) {
[16:12:20.461]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.461]                       if (muffled) 
[16:12:20.461]                         invokeRestart("muffleMessage")
[16:12:20.461]                     }
[16:12:20.461]                     else if (inherits(cond, "warning")) {
[16:12:20.461]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.461]                       if (muffled) 
[16:12:20.461]                         invokeRestart("muffleWarning")
[16:12:20.461]                     }
[16:12:20.461]                     else if (inherits(cond, "condition")) {
[16:12:20.461]                       if (!is.null(pattern)) {
[16:12:20.461]                         computeRestarts <- base::computeRestarts
[16:12:20.461]                         grepl <- base::grepl
[16:12:20.461]                         restarts <- computeRestarts(cond)
[16:12:20.461]                         for (restart in restarts) {
[16:12:20.461]                           name <- restart$name
[16:12:20.461]                           if (is.null(name)) 
[16:12:20.461]                             next
[16:12:20.461]                           if (!grepl(pattern, name)) 
[16:12:20.461]                             next
[16:12:20.461]                           invokeRestart(restart)
[16:12:20.461]                           muffled <- TRUE
[16:12:20.461]                           break
[16:12:20.461]                         }
[16:12:20.461]                       }
[16:12:20.461]                     }
[16:12:20.461]                     invisible(muffled)
[16:12:20.461]                   }
[16:12:20.461]                   muffleCondition(cond)
[16:12:20.461]                 })
[16:12:20.461]             }))
[16:12:20.461]             future::FutureResult(value = ...future.value$value, 
[16:12:20.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.461]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.461]                     ...future.globalenv.names))
[16:12:20.461]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.461]         }, condition = base::local({
[16:12:20.461]             c <- base::c
[16:12:20.461]             inherits <- base::inherits
[16:12:20.461]             invokeRestart <- base::invokeRestart
[16:12:20.461]             length <- base::length
[16:12:20.461]             list <- base::list
[16:12:20.461]             seq.int <- base::seq.int
[16:12:20.461]             signalCondition <- base::signalCondition
[16:12:20.461]             sys.calls <- base::sys.calls
[16:12:20.461]             `[[` <- base::`[[`
[16:12:20.461]             `+` <- base::`+`
[16:12:20.461]             `<<-` <- base::`<<-`
[16:12:20.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.461]                   3L)]
[16:12:20.461]             }
[16:12:20.461]             function(cond) {
[16:12:20.461]                 is_error <- inherits(cond, "error")
[16:12:20.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.461]                   NULL)
[16:12:20.461]                 if (is_error) {
[16:12:20.461]                   sessionInformation <- function() {
[16:12:20.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.461]                       search = base::search(), system = base::Sys.info())
[16:12:20.461]                   }
[16:12:20.461]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.461]                     cond$call), session = sessionInformation(), 
[16:12:20.461]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.461]                   signalCondition(cond)
[16:12:20.461]                 }
[16:12:20.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.461]                 "immediateCondition"))) {
[16:12:20.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.461]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.461]                   if (TRUE && !signal) {
[16:12:20.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.461]                     {
[16:12:20.461]                       inherits <- base::inherits
[16:12:20.461]                       invokeRestart <- base::invokeRestart
[16:12:20.461]                       is.null <- base::is.null
[16:12:20.461]                       muffled <- FALSE
[16:12:20.461]                       if (inherits(cond, "message")) {
[16:12:20.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.461]                         if (muffled) 
[16:12:20.461]                           invokeRestart("muffleMessage")
[16:12:20.461]                       }
[16:12:20.461]                       else if (inherits(cond, "warning")) {
[16:12:20.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.461]                         if (muffled) 
[16:12:20.461]                           invokeRestart("muffleWarning")
[16:12:20.461]                       }
[16:12:20.461]                       else if (inherits(cond, "condition")) {
[16:12:20.461]                         if (!is.null(pattern)) {
[16:12:20.461]                           computeRestarts <- base::computeRestarts
[16:12:20.461]                           grepl <- base::grepl
[16:12:20.461]                           restarts <- computeRestarts(cond)
[16:12:20.461]                           for (restart in restarts) {
[16:12:20.461]                             name <- restart$name
[16:12:20.461]                             if (is.null(name)) 
[16:12:20.461]                               next
[16:12:20.461]                             if (!grepl(pattern, name)) 
[16:12:20.461]                               next
[16:12:20.461]                             invokeRestart(restart)
[16:12:20.461]                             muffled <- TRUE
[16:12:20.461]                             break
[16:12:20.461]                           }
[16:12:20.461]                         }
[16:12:20.461]                       }
[16:12:20.461]                       invisible(muffled)
[16:12:20.461]                     }
[16:12:20.461]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.461]                   }
[16:12:20.461]                 }
[16:12:20.461]                 else {
[16:12:20.461]                   if (TRUE) {
[16:12:20.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.461]                     {
[16:12:20.461]                       inherits <- base::inherits
[16:12:20.461]                       invokeRestart <- base::invokeRestart
[16:12:20.461]                       is.null <- base::is.null
[16:12:20.461]                       muffled <- FALSE
[16:12:20.461]                       if (inherits(cond, "message")) {
[16:12:20.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.461]                         if (muffled) 
[16:12:20.461]                           invokeRestart("muffleMessage")
[16:12:20.461]                       }
[16:12:20.461]                       else if (inherits(cond, "warning")) {
[16:12:20.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.461]                         if (muffled) 
[16:12:20.461]                           invokeRestart("muffleWarning")
[16:12:20.461]                       }
[16:12:20.461]                       else if (inherits(cond, "condition")) {
[16:12:20.461]                         if (!is.null(pattern)) {
[16:12:20.461]                           computeRestarts <- base::computeRestarts
[16:12:20.461]                           grepl <- base::grepl
[16:12:20.461]                           restarts <- computeRestarts(cond)
[16:12:20.461]                           for (restart in restarts) {
[16:12:20.461]                             name <- restart$name
[16:12:20.461]                             if (is.null(name)) 
[16:12:20.461]                               next
[16:12:20.461]                             if (!grepl(pattern, name)) 
[16:12:20.461]                               next
[16:12:20.461]                             invokeRestart(restart)
[16:12:20.461]                             muffled <- TRUE
[16:12:20.461]                             break
[16:12:20.461]                           }
[16:12:20.461]                         }
[16:12:20.461]                       }
[16:12:20.461]                       invisible(muffled)
[16:12:20.461]                     }
[16:12:20.461]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.461]                   }
[16:12:20.461]                 }
[16:12:20.461]             }
[16:12:20.461]         }))
[16:12:20.461]     }, error = function(ex) {
[16:12:20.461]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.461]                 ...future.rng), started = ...future.startTime, 
[16:12:20.461]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.461]             version = "1.8"), class = "FutureResult")
[16:12:20.461]     }, finally = {
[16:12:20.461]         if (!identical(...future.workdir, getwd())) 
[16:12:20.461]             setwd(...future.workdir)
[16:12:20.461]         {
[16:12:20.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.461]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.461]             }
[16:12:20.461]             base::options(...future.oldOptions)
[16:12:20.461]             if (.Platform$OS.type == "windows") {
[16:12:20.461]                 old_names <- names(...future.oldEnvVars)
[16:12:20.461]                 envs <- base::Sys.getenv()
[16:12:20.461]                 names <- names(envs)
[16:12:20.461]                 common <- intersect(names, old_names)
[16:12:20.461]                 added <- setdiff(names, old_names)
[16:12:20.461]                 removed <- setdiff(old_names, names)
[16:12:20.461]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.461]                   envs[common]]
[16:12:20.461]                 NAMES <- toupper(changed)
[16:12:20.461]                 args <- list()
[16:12:20.461]                 for (kk in seq_along(NAMES)) {
[16:12:20.461]                   name <- changed[[kk]]
[16:12:20.461]                   NAME <- NAMES[[kk]]
[16:12:20.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.461]                     next
[16:12:20.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.461]                 }
[16:12:20.461]                 NAMES <- toupper(added)
[16:12:20.461]                 for (kk in seq_along(NAMES)) {
[16:12:20.461]                   name <- added[[kk]]
[16:12:20.461]                   NAME <- NAMES[[kk]]
[16:12:20.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.461]                     next
[16:12:20.461]                   args[[name]] <- ""
[16:12:20.461]                 }
[16:12:20.461]                 NAMES <- toupper(removed)
[16:12:20.461]                 for (kk in seq_along(NAMES)) {
[16:12:20.461]                   name <- removed[[kk]]
[16:12:20.461]                   NAME <- NAMES[[kk]]
[16:12:20.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.461]                     next
[16:12:20.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.461]                 }
[16:12:20.461]                 if (length(args) > 0) 
[16:12:20.461]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.461]             }
[16:12:20.461]             else {
[16:12:20.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.461]             }
[16:12:20.461]             {
[16:12:20.461]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.461]                   0L) {
[16:12:20.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.461]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.461]                   base::options(opts)
[16:12:20.461]                 }
[16:12:20.461]                 {
[16:12:20.461]                   {
[16:12:20.461]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.461]                     NULL
[16:12:20.461]                   }
[16:12:20.461]                   options(future.plan = NULL)
[16:12:20.461]                   if (is.na(NA_character_)) 
[16:12:20.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.461]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.461]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.461]                     envir = parent.frame()) 
[16:12:20.461]                   {
[16:12:20.461]                     if (is.function(workers)) 
[16:12:20.461]                       workers <- workers()
[16:12:20.461]                     workers <- structure(as.integer(workers), 
[16:12:20.461]                       class = class(workers))
[16:12:20.461]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.461]                       workers >= 1)
[16:12:20.461]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.461]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.461]                     }
[16:12:20.461]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.461]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.461]                       envir = envir)
[16:12:20.461]                     if (!future$lazy) 
[16:12:20.461]                       future <- run(future)
[16:12:20.461]                     invisible(future)
[16:12:20.461]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.461]                 }
[16:12:20.461]             }
[16:12:20.461]         }
[16:12:20.461]     })
[16:12:20.461]     if (TRUE) {
[16:12:20.461]         base::sink(type = "output", split = FALSE)
[16:12:20.461]         if (TRUE) {
[16:12:20.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.461]         }
[16:12:20.461]         else {
[16:12:20.461]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.461]         }
[16:12:20.461]         base::close(...future.stdout)
[16:12:20.461]         ...future.stdout <- NULL
[16:12:20.461]     }
[16:12:20.461]     ...future.result$conditions <- ...future.conditions
[16:12:20.461]     ...future.result$finished <- base::Sys.time()
[16:12:20.461]     ...future.result
[16:12:20.461] }
[16:12:20.464] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:20.464] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:20.464] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:20.464] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:20.465] MultisessionFuture started
[16:12:20.465] - Launch lazy future ... done
[16:12:20.465] run() for ‘MultisessionFuture’ ... done
[16:12:20.465] result() for ClusterFuture ...
[16:12:20.465] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.465] - Validating connection of MultisessionFuture
[16:12:20.513] - received message: FutureResult
[16:12:20.513] - Received FutureResult
[16:12:20.513] - Erased future from FutureRegistry
[16:12:20.513] result() for ClusterFuture ...
[16:12:20.513] - result already collected: FutureResult
[16:12:20.513] result() for ClusterFuture ... done
[16:12:20.513] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.514] result() for ClusterFuture ... done
[16:12:20.514] result() for ClusterFuture ...
[16:12:20.514] - result already collected: FutureResult
[16:12:20.514] result() for ClusterFuture ... done
[16:12:20.514] getGlobalsAndPackages() ...
[16:12:20.514] Searching for globals...
[16:12:20.515] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:20.515] Searching for globals ... DONE
[16:12:20.515] Resolving globals: FALSE
[16:12:20.516] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:20.516] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:20.516] - globals: [1] ‘a’
[16:12:20.516] 
[16:12:20.517] getGlobalsAndPackages() ... DONE
[16:12:20.517] run() for ‘Future’ ...
[16:12:20.517] - state: ‘created’
[16:12:20.517] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.531] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.531]   - Field: ‘node’
[16:12:20.532]   - Field: ‘label’
[16:12:20.532]   - Field: ‘local’
[16:12:20.532]   - Field: ‘owner’
[16:12:20.532]   - Field: ‘envir’
[16:12:20.532]   - Field: ‘workers’
[16:12:20.532]   - Field: ‘packages’
[16:12:20.532]   - Field: ‘gc’
[16:12:20.532]   - Field: ‘conditions’
[16:12:20.532]   - Field: ‘persistent’
[16:12:20.532]   - Field: ‘expr’
[16:12:20.532]   - Field: ‘uuid’
[16:12:20.533]   - Field: ‘seed’
[16:12:20.533]   - Field: ‘version’
[16:12:20.533]   - Field: ‘result’
[16:12:20.533]   - Field: ‘asynchronous’
[16:12:20.533]   - Field: ‘calls’
[16:12:20.533]   - Field: ‘globals’
[16:12:20.533]   - Field: ‘stdout’
[16:12:20.533]   - Field: ‘earlySignal’
[16:12:20.533]   - Field: ‘lazy’
[16:12:20.533]   - Field: ‘state’
[16:12:20.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.534] - Launch lazy future ...
[16:12:20.534] Packages needed by the future expression (n = 0): <none>
[16:12:20.534] Packages needed by future strategies (n = 0): <none>
[16:12:20.534] {
[16:12:20.534]     {
[16:12:20.534]         {
[16:12:20.534]             ...future.startTime <- base::Sys.time()
[16:12:20.534]             {
[16:12:20.534]                 {
[16:12:20.534]                   {
[16:12:20.534]                     {
[16:12:20.534]                       base::local({
[16:12:20.534]                         has_future <- base::requireNamespace("future", 
[16:12:20.534]                           quietly = TRUE)
[16:12:20.534]                         if (has_future) {
[16:12:20.534]                           ns <- base::getNamespace("future")
[16:12:20.534]                           version <- ns[[".package"]][["version"]]
[16:12:20.534]                           if (is.null(version)) 
[16:12:20.534]                             version <- utils::packageVersion("future")
[16:12:20.534]                         }
[16:12:20.534]                         else {
[16:12:20.534]                           version <- NULL
[16:12:20.534]                         }
[16:12:20.534]                         if (!has_future || version < "1.8.0") {
[16:12:20.534]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.534]                             "", base::R.version$version.string), 
[16:12:20.534]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.534]                               "release", "version")], collapse = " "), 
[16:12:20.534]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.534]                             info)
[16:12:20.534]                           info <- base::paste(info, collapse = "; ")
[16:12:20.534]                           if (!has_future) {
[16:12:20.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.534]                               info)
[16:12:20.534]                           }
[16:12:20.534]                           else {
[16:12:20.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.534]                               info, version)
[16:12:20.534]                           }
[16:12:20.534]                           base::stop(msg)
[16:12:20.534]                         }
[16:12:20.534]                       })
[16:12:20.534]                     }
[16:12:20.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.534]                     base::options(mc.cores = 1L)
[16:12:20.534]                   }
[16:12:20.534]                   options(future.plan = NULL)
[16:12:20.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.534]                 }
[16:12:20.534]                 ...future.workdir <- getwd()
[16:12:20.534]             }
[16:12:20.534]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.534]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.534]         }
[16:12:20.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.534]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.534]             base::names(...future.oldOptions))
[16:12:20.534]     }
[16:12:20.534]     if (FALSE) {
[16:12:20.534]     }
[16:12:20.534]     else {
[16:12:20.534]         if (TRUE) {
[16:12:20.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.534]                 open = "w")
[16:12:20.534]         }
[16:12:20.534]         else {
[16:12:20.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.534]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.534]         }
[16:12:20.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.534]             base::sink(type = "output", split = FALSE)
[16:12:20.534]             base::close(...future.stdout)
[16:12:20.534]         }, add = TRUE)
[16:12:20.534]     }
[16:12:20.534]     ...future.frame <- base::sys.nframe()
[16:12:20.534]     ...future.conditions <- base::list()
[16:12:20.534]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.534]     if (FALSE) {
[16:12:20.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.534]     }
[16:12:20.534]     ...future.result <- base::tryCatch({
[16:12:20.534]         base::withCallingHandlers({
[16:12:20.534]             ...future.value <- base::withVisible(base::local({
[16:12:20.534]                 ...future.makeSendCondition <- local({
[16:12:20.534]                   sendCondition <- NULL
[16:12:20.534]                   function(frame = 1L) {
[16:12:20.534]                     if (is.function(sendCondition)) 
[16:12:20.534]                       return(sendCondition)
[16:12:20.534]                     ns <- getNamespace("parallel")
[16:12:20.534]                     if (exists("sendData", mode = "function", 
[16:12:20.534]                       envir = ns)) {
[16:12:20.534]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.534]                         envir = ns)
[16:12:20.534]                       envir <- sys.frame(frame)
[16:12:20.534]                       master <- NULL
[16:12:20.534]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.534]                         !identical(envir, emptyenv())) {
[16:12:20.534]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.534]                           inherits = FALSE)) {
[16:12:20.534]                           master <- get("master", mode = "list", 
[16:12:20.534]                             envir = envir, inherits = FALSE)
[16:12:20.534]                           if (inherits(master, c("SOCKnode", 
[16:12:20.534]                             "SOCK0node"))) {
[16:12:20.534]                             sendCondition <<- function(cond) {
[16:12:20.534]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.534]                                 success = TRUE)
[16:12:20.534]                               parallel_sendData(master, data)
[16:12:20.534]                             }
[16:12:20.534]                             return(sendCondition)
[16:12:20.534]                           }
[16:12:20.534]                         }
[16:12:20.534]                         frame <- frame + 1L
[16:12:20.534]                         envir <- sys.frame(frame)
[16:12:20.534]                       }
[16:12:20.534]                     }
[16:12:20.534]                     sendCondition <<- function(cond) NULL
[16:12:20.534]                   }
[16:12:20.534]                 })
[16:12:20.534]                 withCallingHandlers({
[16:12:20.534]                   {
[16:12:20.534]                     2 * a
[16:12:20.534]                   }
[16:12:20.534]                 }, immediateCondition = function(cond) {
[16:12:20.534]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.534]                   sendCondition(cond)
[16:12:20.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.534]                   {
[16:12:20.534]                     inherits <- base::inherits
[16:12:20.534]                     invokeRestart <- base::invokeRestart
[16:12:20.534]                     is.null <- base::is.null
[16:12:20.534]                     muffled <- FALSE
[16:12:20.534]                     if (inherits(cond, "message")) {
[16:12:20.534]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.534]                       if (muffled) 
[16:12:20.534]                         invokeRestart("muffleMessage")
[16:12:20.534]                     }
[16:12:20.534]                     else if (inherits(cond, "warning")) {
[16:12:20.534]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.534]                       if (muffled) 
[16:12:20.534]                         invokeRestart("muffleWarning")
[16:12:20.534]                     }
[16:12:20.534]                     else if (inherits(cond, "condition")) {
[16:12:20.534]                       if (!is.null(pattern)) {
[16:12:20.534]                         computeRestarts <- base::computeRestarts
[16:12:20.534]                         grepl <- base::grepl
[16:12:20.534]                         restarts <- computeRestarts(cond)
[16:12:20.534]                         for (restart in restarts) {
[16:12:20.534]                           name <- restart$name
[16:12:20.534]                           if (is.null(name)) 
[16:12:20.534]                             next
[16:12:20.534]                           if (!grepl(pattern, name)) 
[16:12:20.534]                             next
[16:12:20.534]                           invokeRestart(restart)
[16:12:20.534]                           muffled <- TRUE
[16:12:20.534]                           break
[16:12:20.534]                         }
[16:12:20.534]                       }
[16:12:20.534]                     }
[16:12:20.534]                     invisible(muffled)
[16:12:20.534]                   }
[16:12:20.534]                   muffleCondition(cond)
[16:12:20.534]                 })
[16:12:20.534]             }))
[16:12:20.534]             future::FutureResult(value = ...future.value$value, 
[16:12:20.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.534]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.534]                     ...future.globalenv.names))
[16:12:20.534]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.534]         }, condition = base::local({
[16:12:20.534]             c <- base::c
[16:12:20.534]             inherits <- base::inherits
[16:12:20.534]             invokeRestart <- base::invokeRestart
[16:12:20.534]             length <- base::length
[16:12:20.534]             list <- base::list
[16:12:20.534]             seq.int <- base::seq.int
[16:12:20.534]             signalCondition <- base::signalCondition
[16:12:20.534]             sys.calls <- base::sys.calls
[16:12:20.534]             `[[` <- base::`[[`
[16:12:20.534]             `+` <- base::`+`
[16:12:20.534]             `<<-` <- base::`<<-`
[16:12:20.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.534]                   3L)]
[16:12:20.534]             }
[16:12:20.534]             function(cond) {
[16:12:20.534]                 is_error <- inherits(cond, "error")
[16:12:20.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.534]                   NULL)
[16:12:20.534]                 if (is_error) {
[16:12:20.534]                   sessionInformation <- function() {
[16:12:20.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.534]                       search = base::search(), system = base::Sys.info())
[16:12:20.534]                   }
[16:12:20.534]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.534]                     cond$call), session = sessionInformation(), 
[16:12:20.534]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.534]                   signalCondition(cond)
[16:12:20.534]                 }
[16:12:20.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.534]                 "immediateCondition"))) {
[16:12:20.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.534]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.534]                   if (TRUE && !signal) {
[16:12:20.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.534]                     {
[16:12:20.534]                       inherits <- base::inherits
[16:12:20.534]                       invokeRestart <- base::invokeRestart
[16:12:20.534]                       is.null <- base::is.null
[16:12:20.534]                       muffled <- FALSE
[16:12:20.534]                       if (inherits(cond, "message")) {
[16:12:20.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.534]                         if (muffled) 
[16:12:20.534]                           invokeRestart("muffleMessage")
[16:12:20.534]                       }
[16:12:20.534]                       else if (inherits(cond, "warning")) {
[16:12:20.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.534]                         if (muffled) 
[16:12:20.534]                           invokeRestart("muffleWarning")
[16:12:20.534]                       }
[16:12:20.534]                       else if (inherits(cond, "condition")) {
[16:12:20.534]                         if (!is.null(pattern)) {
[16:12:20.534]                           computeRestarts <- base::computeRestarts
[16:12:20.534]                           grepl <- base::grepl
[16:12:20.534]                           restarts <- computeRestarts(cond)
[16:12:20.534]                           for (restart in restarts) {
[16:12:20.534]                             name <- restart$name
[16:12:20.534]                             if (is.null(name)) 
[16:12:20.534]                               next
[16:12:20.534]                             if (!grepl(pattern, name)) 
[16:12:20.534]                               next
[16:12:20.534]                             invokeRestart(restart)
[16:12:20.534]                             muffled <- TRUE
[16:12:20.534]                             break
[16:12:20.534]                           }
[16:12:20.534]                         }
[16:12:20.534]                       }
[16:12:20.534]                       invisible(muffled)
[16:12:20.534]                     }
[16:12:20.534]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.534]                   }
[16:12:20.534]                 }
[16:12:20.534]                 else {
[16:12:20.534]                   if (TRUE) {
[16:12:20.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.534]                     {
[16:12:20.534]                       inherits <- base::inherits
[16:12:20.534]                       invokeRestart <- base::invokeRestart
[16:12:20.534]                       is.null <- base::is.null
[16:12:20.534]                       muffled <- FALSE
[16:12:20.534]                       if (inherits(cond, "message")) {
[16:12:20.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.534]                         if (muffled) 
[16:12:20.534]                           invokeRestart("muffleMessage")
[16:12:20.534]                       }
[16:12:20.534]                       else if (inherits(cond, "warning")) {
[16:12:20.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.534]                         if (muffled) 
[16:12:20.534]                           invokeRestart("muffleWarning")
[16:12:20.534]                       }
[16:12:20.534]                       else if (inherits(cond, "condition")) {
[16:12:20.534]                         if (!is.null(pattern)) {
[16:12:20.534]                           computeRestarts <- base::computeRestarts
[16:12:20.534]                           grepl <- base::grepl
[16:12:20.534]                           restarts <- computeRestarts(cond)
[16:12:20.534]                           for (restart in restarts) {
[16:12:20.534]                             name <- restart$name
[16:12:20.534]                             if (is.null(name)) 
[16:12:20.534]                               next
[16:12:20.534]                             if (!grepl(pattern, name)) 
[16:12:20.534]                               next
[16:12:20.534]                             invokeRestart(restart)
[16:12:20.534]                             muffled <- TRUE
[16:12:20.534]                             break
[16:12:20.534]                           }
[16:12:20.534]                         }
[16:12:20.534]                       }
[16:12:20.534]                       invisible(muffled)
[16:12:20.534]                     }
[16:12:20.534]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.534]                   }
[16:12:20.534]                 }
[16:12:20.534]             }
[16:12:20.534]         }))
[16:12:20.534]     }, error = function(ex) {
[16:12:20.534]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.534]                 ...future.rng), started = ...future.startTime, 
[16:12:20.534]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.534]             version = "1.8"), class = "FutureResult")
[16:12:20.534]     }, finally = {
[16:12:20.534]         if (!identical(...future.workdir, getwd())) 
[16:12:20.534]             setwd(...future.workdir)
[16:12:20.534]         {
[16:12:20.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.534]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.534]             }
[16:12:20.534]             base::options(...future.oldOptions)
[16:12:20.534]             if (.Platform$OS.type == "windows") {
[16:12:20.534]                 old_names <- names(...future.oldEnvVars)
[16:12:20.534]                 envs <- base::Sys.getenv()
[16:12:20.534]                 names <- names(envs)
[16:12:20.534]                 common <- intersect(names, old_names)
[16:12:20.534]                 added <- setdiff(names, old_names)
[16:12:20.534]                 removed <- setdiff(old_names, names)
[16:12:20.534]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.534]                   envs[common]]
[16:12:20.534]                 NAMES <- toupper(changed)
[16:12:20.534]                 args <- list()
[16:12:20.534]                 for (kk in seq_along(NAMES)) {
[16:12:20.534]                   name <- changed[[kk]]
[16:12:20.534]                   NAME <- NAMES[[kk]]
[16:12:20.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.534]                     next
[16:12:20.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.534]                 }
[16:12:20.534]                 NAMES <- toupper(added)
[16:12:20.534]                 for (kk in seq_along(NAMES)) {
[16:12:20.534]                   name <- added[[kk]]
[16:12:20.534]                   NAME <- NAMES[[kk]]
[16:12:20.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.534]                     next
[16:12:20.534]                   args[[name]] <- ""
[16:12:20.534]                 }
[16:12:20.534]                 NAMES <- toupper(removed)
[16:12:20.534]                 for (kk in seq_along(NAMES)) {
[16:12:20.534]                   name <- removed[[kk]]
[16:12:20.534]                   NAME <- NAMES[[kk]]
[16:12:20.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.534]                     next
[16:12:20.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.534]                 }
[16:12:20.534]                 if (length(args) > 0) 
[16:12:20.534]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.534]             }
[16:12:20.534]             else {
[16:12:20.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.534]             }
[16:12:20.534]             {
[16:12:20.534]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.534]                   0L) {
[16:12:20.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.534]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.534]                   base::options(opts)
[16:12:20.534]                 }
[16:12:20.534]                 {
[16:12:20.534]                   {
[16:12:20.534]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.534]                     NULL
[16:12:20.534]                   }
[16:12:20.534]                   options(future.plan = NULL)
[16:12:20.534]                   if (is.na(NA_character_)) 
[16:12:20.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.534]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.534]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.534]                     envir = parent.frame()) 
[16:12:20.534]                   {
[16:12:20.534]                     if (is.function(workers)) 
[16:12:20.534]                       workers <- workers()
[16:12:20.534]                     workers <- structure(as.integer(workers), 
[16:12:20.534]                       class = class(workers))
[16:12:20.534]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.534]                       workers >= 1)
[16:12:20.534]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.534]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.534]                     }
[16:12:20.534]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.534]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.534]                       envir = envir)
[16:12:20.534]                     if (!future$lazy) 
[16:12:20.534]                       future <- run(future)
[16:12:20.534]                     invisible(future)
[16:12:20.534]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.534]                 }
[16:12:20.534]             }
[16:12:20.534]         }
[16:12:20.534]     })
[16:12:20.534]     if (TRUE) {
[16:12:20.534]         base::sink(type = "output", split = FALSE)
[16:12:20.534]         if (TRUE) {
[16:12:20.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.534]         }
[16:12:20.534]         else {
[16:12:20.534]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.534]         }
[16:12:20.534]         base::close(...future.stdout)
[16:12:20.534]         ...future.stdout <- NULL
[16:12:20.534]     }
[16:12:20.534]     ...future.result$conditions <- ...future.conditions
[16:12:20.534]     ...future.result$finished <- base::Sys.time()
[16:12:20.534]     ...future.result
[16:12:20.534] }
[16:12:20.537] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:20.537] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:20.538] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:20.538] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:20.538] MultisessionFuture started
[16:12:20.538] - Launch lazy future ... done
[16:12:20.539] run() for ‘MultisessionFuture’ ... done
[16:12:20.539] result() for ClusterFuture ...
[16:12:20.539] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.539] - Validating connection of MultisessionFuture
[16:12:20.584] - received message: FutureResult
[16:12:20.584] - Received FutureResult
[16:12:20.584] - Erased future from FutureRegistry
[16:12:20.585] result() for ClusterFuture ...
[16:12:20.585] - result already collected: FutureResult
[16:12:20.585] result() for ClusterFuture ... done
[16:12:20.585] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.585] result() for ClusterFuture ... done
[16:12:20.585] result() for ClusterFuture ...
[16:12:20.585] - result already collected: FutureResult
[16:12:20.585] result() for ClusterFuture ... done
[16:12:20.585] getGlobalsAndPackages() ...
[16:12:20.585] Searching for globals...
[16:12:20.586] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:20.586] Searching for globals ... DONE
[16:12:20.587] Resolving globals: FALSE
[16:12:20.587] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:20.587] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:20.587] - globals: [1] ‘a’
[16:12:20.587] 
[16:12:20.588] getGlobalsAndPackages() ... DONE
[16:12:20.588] run() for ‘Future’ ...
[16:12:20.588] - state: ‘created’
[16:12:20.588] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.602] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.603]   - Field: ‘node’
[16:12:20.603]   - Field: ‘label’
[16:12:20.603]   - Field: ‘local’
[16:12:20.603]   - Field: ‘owner’
[16:12:20.603]   - Field: ‘envir’
[16:12:20.603]   - Field: ‘workers’
[16:12:20.603]   - Field: ‘packages’
[16:12:20.603]   - Field: ‘gc’
[16:12:20.603]   - Field: ‘conditions’
[16:12:20.603]   - Field: ‘persistent’
[16:12:20.603]   - Field: ‘expr’
[16:12:20.604]   - Field: ‘uuid’
[16:12:20.604]   - Field: ‘seed’
[16:12:20.604]   - Field: ‘version’
[16:12:20.604]   - Field: ‘result’
[16:12:20.604]   - Field: ‘asynchronous’
[16:12:20.604]   - Field: ‘calls’
[16:12:20.604]   - Field: ‘globals’
[16:12:20.604]   - Field: ‘stdout’
[16:12:20.604]   - Field: ‘earlySignal’
[16:12:20.604]   - Field: ‘lazy’
[16:12:20.605]   - Field: ‘state’
[16:12:20.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.605] - Launch lazy future ...
[16:12:20.605] Packages needed by the future expression (n = 0): <none>
[16:12:20.605] Packages needed by future strategies (n = 0): <none>
[16:12:20.606] {
[16:12:20.606]     {
[16:12:20.606]         {
[16:12:20.606]             ...future.startTime <- base::Sys.time()
[16:12:20.606]             {
[16:12:20.606]                 {
[16:12:20.606]                   {
[16:12:20.606]                     {
[16:12:20.606]                       base::local({
[16:12:20.606]                         has_future <- base::requireNamespace("future", 
[16:12:20.606]                           quietly = TRUE)
[16:12:20.606]                         if (has_future) {
[16:12:20.606]                           ns <- base::getNamespace("future")
[16:12:20.606]                           version <- ns[[".package"]][["version"]]
[16:12:20.606]                           if (is.null(version)) 
[16:12:20.606]                             version <- utils::packageVersion("future")
[16:12:20.606]                         }
[16:12:20.606]                         else {
[16:12:20.606]                           version <- NULL
[16:12:20.606]                         }
[16:12:20.606]                         if (!has_future || version < "1.8.0") {
[16:12:20.606]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.606]                             "", base::R.version$version.string), 
[16:12:20.606]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.606]                               "release", "version")], collapse = " "), 
[16:12:20.606]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.606]                             info)
[16:12:20.606]                           info <- base::paste(info, collapse = "; ")
[16:12:20.606]                           if (!has_future) {
[16:12:20.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.606]                               info)
[16:12:20.606]                           }
[16:12:20.606]                           else {
[16:12:20.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.606]                               info, version)
[16:12:20.606]                           }
[16:12:20.606]                           base::stop(msg)
[16:12:20.606]                         }
[16:12:20.606]                       })
[16:12:20.606]                     }
[16:12:20.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.606]                     base::options(mc.cores = 1L)
[16:12:20.606]                   }
[16:12:20.606]                   options(future.plan = NULL)
[16:12:20.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.606]                 }
[16:12:20.606]                 ...future.workdir <- getwd()
[16:12:20.606]             }
[16:12:20.606]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.606]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.606]         }
[16:12:20.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.606]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.606]             base::names(...future.oldOptions))
[16:12:20.606]     }
[16:12:20.606]     if (FALSE) {
[16:12:20.606]     }
[16:12:20.606]     else {
[16:12:20.606]         if (TRUE) {
[16:12:20.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.606]                 open = "w")
[16:12:20.606]         }
[16:12:20.606]         else {
[16:12:20.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.606]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.606]         }
[16:12:20.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.606]             base::sink(type = "output", split = FALSE)
[16:12:20.606]             base::close(...future.stdout)
[16:12:20.606]         }, add = TRUE)
[16:12:20.606]     }
[16:12:20.606]     ...future.frame <- base::sys.nframe()
[16:12:20.606]     ...future.conditions <- base::list()
[16:12:20.606]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.606]     if (FALSE) {
[16:12:20.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.606]     }
[16:12:20.606]     ...future.result <- base::tryCatch({
[16:12:20.606]         base::withCallingHandlers({
[16:12:20.606]             ...future.value <- base::withVisible(base::local({
[16:12:20.606]                 ...future.makeSendCondition <- local({
[16:12:20.606]                   sendCondition <- NULL
[16:12:20.606]                   function(frame = 1L) {
[16:12:20.606]                     if (is.function(sendCondition)) 
[16:12:20.606]                       return(sendCondition)
[16:12:20.606]                     ns <- getNamespace("parallel")
[16:12:20.606]                     if (exists("sendData", mode = "function", 
[16:12:20.606]                       envir = ns)) {
[16:12:20.606]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.606]                         envir = ns)
[16:12:20.606]                       envir <- sys.frame(frame)
[16:12:20.606]                       master <- NULL
[16:12:20.606]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.606]                         !identical(envir, emptyenv())) {
[16:12:20.606]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.606]                           inherits = FALSE)) {
[16:12:20.606]                           master <- get("master", mode = "list", 
[16:12:20.606]                             envir = envir, inherits = FALSE)
[16:12:20.606]                           if (inherits(master, c("SOCKnode", 
[16:12:20.606]                             "SOCK0node"))) {
[16:12:20.606]                             sendCondition <<- function(cond) {
[16:12:20.606]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.606]                                 success = TRUE)
[16:12:20.606]                               parallel_sendData(master, data)
[16:12:20.606]                             }
[16:12:20.606]                             return(sendCondition)
[16:12:20.606]                           }
[16:12:20.606]                         }
[16:12:20.606]                         frame <- frame + 1L
[16:12:20.606]                         envir <- sys.frame(frame)
[16:12:20.606]                       }
[16:12:20.606]                     }
[16:12:20.606]                     sendCondition <<- function(cond) NULL
[16:12:20.606]                   }
[16:12:20.606]                 })
[16:12:20.606]                 withCallingHandlers({
[16:12:20.606]                   {
[16:12:20.606]                     2 * a
[16:12:20.606]                   }
[16:12:20.606]                 }, immediateCondition = function(cond) {
[16:12:20.606]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.606]                   sendCondition(cond)
[16:12:20.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.606]                   {
[16:12:20.606]                     inherits <- base::inherits
[16:12:20.606]                     invokeRestart <- base::invokeRestart
[16:12:20.606]                     is.null <- base::is.null
[16:12:20.606]                     muffled <- FALSE
[16:12:20.606]                     if (inherits(cond, "message")) {
[16:12:20.606]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.606]                       if (muffled) 
[16:12:20.606]                         invokeRestart("muffleMessage")
[16:12:20.606]                     }
[16:12:20.606]                     else if (inherits(cond, "warning")) {
[16:12:20.606]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.606]                       if (muffled) 
[16:12:20.606]                         invokeRestart("muffleWarning")
[16:12:20.606]                     }
[16:12:20.606]                     else if (inherits(cond, "condition")) {
[16:12:20.606]                       if (!is.null(pattern)) {
[16:12:20.606]                         computeRestarts <- base::computeRestarts
[16:12:20.606]                         grepl <- base::grepl
[16:12:20.606]                         restarts <- computeRestarts(cond)
[16:12:20.606]                         for (restart in restarts) {
[16:12:20.606]                           name <- restart$name
[16:12:20.606]                           if (is.null(name)) 
[16:12:20.606]                             next
[16:12:20.606]                           if (!grepl(pattern, name)) 
[16:12:20.606]                             next
[16:12:20.606]                           invokeRestart(restart)
[16:12:20.606]                           muffled <- TRUE
[16:12:20.606]                           break
[16:12:20.606]                         }
[16:12:20.606]                       }
[16:12:20.606]                     }
[16:12:20.606]                     invisible(muffled)
[16:12:20.606]                   }
[16:12:20.606]                   muffleCondition(cond)
[16:12:20.606]                 })
[16:12:20.606]             }))
[16:12:20.606]             future::FutureResult(value = ...future.value$value, 
[16:12:20.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.606]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.606]                     ...future.globalenv.names))
[16:12:20.606]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.606]         }, condition = base::local({
[16:12:20.606]             c <- base::c
[16:12:20.606]             inherits <- base::inherits
[16:12:20.606]             invokeRestart <- base::invokeRestart
[16:12:20.606]             length <- base::length
[16:12:20.606]             list <- base::list
[16:12:20.606]             seq.int <- base::seq.int
[16:12:20.606]             signalCondition <- base::signalCondition
[16:12:20.606]             sys.calls <- base::sys.calls
[16:12:20.606]             `[[` <- base::`[[`
[16:12:20.606]             `+` <- base::`+`
[16:12:20.606]             `<<-` <- base::`<<-`
[16:12:20.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.606]                   3L)]
[16:12:20.606]             }
[16:12:20.606]             function(cond) {
[16:12:20.606]                 is_error <- inherits(cond, "error")
[16:12:20.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.606]                   NULL)
[16:12:20.606]                 if (is_error) {
[16:12:20.606]                   sessionInformation <- function() {
[16:12:20.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.606]                       search = base::search(), system = base::Sys.info())
[16:12:20.606]                   }
[16:12:20.606]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.606]                     cond$call), session = sessionInformation(), 
[16:12:20.606]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.606]                   signalCondition(cond)
[16:12:20.606]                 }
[16:12:20.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.606]                 "immediateCondition"))) {
[16:12:20.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.606]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.606]                   if (TRUE && !signal) {
[16:12:20.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.606]                     {
[16:12:20.606]                       inherits <- base::inherits
[16:12:20.606]                       invokeRestart <- base::invokeRestart
[16:12:20.606]                       is.null <- base::is.null
[16:12:20.606]                       muffled <- FALSE
[16:12:20.606]                       if (inherits(cond, "message")) {
[16:12:20.606]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.606]                         if (muffled) 
[16:12:20.606]                           invokeRestart("muffleMessage")
[16:12:20.606]                       }
[16:12:20.606]                       else if (inherits(cond, "warning")) {
[16:12:20.606]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.606]                         if (muffled) 
[16:12:20.606]                           invokeRestart("muffleWarning")
[16:12:20.606]                       }
[16:12:20.606]                       else if (inherits(cond, "condition")) {
[16:12:20.606]                         if (!is.null(pattern)) {
[16:12:20.606]                           computeRestarts <- base::computeRestarts
[16:12:20.606]                           grepl <- base::grepl
[16:12:20.606]                           restarts <- computeRestarts(cond)
[16:12:20.606]                           for (restart in restarts) {
[16:12:20.606]                             name <- restart$name
[16:12:20.606]                             if (is.null(name)) 
[16:12:20.606]                               next
[16:12:20.606]                             if (!grepl(pattern, name)) 
[16:12:20.606]                               next
[16:12:20.606]                             invokeRestart(restart)
[16:12:20.606]                             muffled <- TRUE
[16:12:20.606]                             break
[16:12:20.606]                           }
[16:12:20.606]                         }
[16:12:20.606]                       }
[16:12:20.606]                       invisible(muffled)
[16:12:20.606]                     }
[16:12:20.606]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.606]                   }
[16:12:20.606]                 }
[16:12:20.606]                 else {
[16:12:20.606]                   if (TRUE) {
[16:12:20.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.606]                     {
[16:12:20.606]                       inherits <- base::inherits
[16:12:20.606]                       invokeRestart <- base::invokeRestart
[16:12:20.606]                       is.null <- base::is.null
[16:12:20.606]                       muffled <- FALSE
[16:12:20.606]                       if (inherits(cond, "message")) {
[16:12:20.606]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.606]                         if (muffled) 
[16:12:20.606]                           invokeRestart("muffleMessage")
[16:12:20.606]                       }
[16:12:20.606]                       else if (inherits(cond, "warning")) {
[16:12:20.606]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.606]                         if (muffled) 
[16:12:20.606]                           invokeRestart("muffleWarning")
[16:12:20.606]                       }
[16:12:20.606]                       else if (inherits(cond, "condition")) {
[16:12:20.606]                         if (!is.null(pattern)) {
[16:12:20.606]                           computeRestarts <- base::computeRestarts
[16:12:20.606]                           grepl <- base::grepl
[16:12:20.606]                           restarts <- computeRestarts(cond)
[16:12:20.606]                           for (restart in restarts) {
[16:12:20.606]                             name <- restart$name
[16:12:20.606]                             if (is.null(name)) 
[16:12:20.606]                               next
[16:12:20.606]                             if (!grepl(pattern, name)) 
[16:12:20.606]                               next
[16:12:20.606]                             invokeRestart(restart)
[16:12:20.606]                             muffled <- TRUE
[16:12:20.606]                             break
[16:12:20.606]                           }
[16:12:20.606]                         }
[16:12:20.606]                       }
[16:12:20.606]                       invisible(muffled)
[16:12:20.606]                     }
[16:12:20.606]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.606]                   }
[16:12:20.606]                 }
[16:12:20.606]             }
[16:12:20.606]         }))
[16:12:20.606]     }, error = function(ex) {
[16:12:20.606]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.606]                 ...future.rng), started = ...future.startTime, 
[16:12:20.606]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.606]             version = "1.8"), class = "FutureResult")
[16:12:20.606]     }, finally = {
[16:12:20.606]         if (!identical(...future.workdir, getwd())) 
[16:12:20.606]             setwd(...future.workdir)
[16:12:20.606]         {
[16:12:20.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.606]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.606]             }
[16:12:20.606]             base::options(...future.oldOptions)
[16:12:20.606]             if (.Platform$OS.type == "windows") {
[16:12:20.606]                 old_names <- names(...future.oldEnvVars)
[16:12:20.606]                 envs <- base::Sys.getenv()
[16:12:20.606]                 names <- names(envs)
[16:12:20.606]                 common <- intersect(names, old_names)
[16:12:20.606]                 added <- setdiff(names, old_names)
[16:12:20.606]                 removed <- setdiff(old_names, names)
[16:12:20.606]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.606]                   envs[common]]
[16:12:20.606]                 NAMES <- toupper(changed)
[16:12:20.606]                 args <- list()
[16:12:20.606]                 for (kk in seq_along(NAMES)) {
[16:12:20.606]                   name <- changed[[kk]]
[16:12:20.606]                   NAME <- NAMES[[kk]]
[16:12:20.606]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.606]                     next
[16:12:20.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.606]                 }
[16:12:20.606]                 NAMES <- toupper(added)
[16:12:20.606]                 for (kk in seq_along(NAMES)) {
[16:12:20.606]                   name <- added[[kk]]
[16:12:20.606]                   NAME <- NAMES[[kk]]
[16:12:20.606]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.606]                     next
[16:12:20.606]                   args[[name]] <- ""
[16:12:20.606]                 }
[16:12:20.606]                 NAMES <- toupper(removed)
[16:12:20.606]                 for (kk in seq_along(NAMES)) {
[16:12:20.606]                   name <- removed[[kk]]
[16:12:20.606]                   NAME <- NAMES[[kk]]
[16:12:20.606]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.606]                     next
[16:12:20.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.606]                 }
[16:12:20.606]                 if (length(args) > 0) 
[16:12:20.606]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.606]             }
[16:12:20.606]             else {
[16:12:20.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.606]             }
[16:12:20.606]             {
[16:12:20.606]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.606]                   0L) {
[16:12:20.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.606]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.606]                   base::options(opts)
[16:12:20.606]                 }
[16:12:20.606]                 {
[16:12:20.606]                   {
[16:12:20.606]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.606]                     NULL
[16:12:20.606]                   }
[16:12:20.606]                   options(future.plan = NULL)
[16:12:20.606]                   if (is.na(NA_character_)) 
[16:12:20.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.606]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.606]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.606]                     envir = parent.frame()) 
[16:12:20.606]                   {
[16:12:20.606]                     if (is.function(workers)) 
[16:12:20.606]                       workers <- workers()
[16:12:20.606]                     workers <- structure(as.integer(workers), 
[16:12:20.606]                       class = class(workers))
[16:12:20.606]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.606]                       workers >= 1)
[16:12:20.606]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.606]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.606]                     }
[16:12:20.606]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.606]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.606]                       envir = envir)
[16:12:20.606]                     if (!future$lazy) 
[16:12:20.606]                       future <- run(future)
[16:12:20.606]                     invisible(future)
[16:12:20.606]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.606]                 }
[16:12:20.606]             }
[16:12:20.606]         }
[16:12:20.606]     })
[16:12:20.606]     if (TRUE) {
[16:12:20.606]         base::sink(type = "output", split = FALSE)
[16:12:20.606]         if (TRUE) {
[16:12:20.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.606]         }
[16:12:20.606]         else {
[16:12:20.606]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.606]         }
[16:12:20.606]         base::close(...future.stdout)
[16:12:20.606]         ...future.stdout <- NULL
[16:12:20.606]     }
[16:12:20.606]     ...future.result$conditions <- ...future.conditions
[16:12:20.606]     ...future.result$finished <- base::Sys.time()
[16:12:20.606]     ...future.result
[16:12:20.606] }
[16:12:20.608] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:20.608] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:20.609] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:20.609] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:20.609] MultisessionFuture started
[16:12:20.609] - Launch lazy future ... done
[16:12:20.610] run() for ‘MultisessionFuture’ ... done
[16:12:20.610] result() for ClusterFuture ...
[16:12:20.610] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.610] - Validating connection of MultisessionFuture
[16:12:20.656] - received message: FutureResult
[16:12:20.657] - Received FutureResult
[16:12:20.657] - Erased future from FutureRegistry
[16:12:20.657] result() for ClusterFuture ...
[16:12:20.657] - result already collected: FutureResult
[16:12:20.657] result() for ClusterFuture ... done
[16:12:20.657] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.657] result() for ClusterFuture ... done
[16:12:20.657] result() for ClusterFuture ...
[16:12:20.657] - result already collected: FutureResult
[16:12:20.657] result() for ClusterFuture ... done
[16:12:20.658] getGlobalsAndPackages() ...
[16:12:20.658] Searching for globals...
[16:12:20.659] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:12:20.659] Searching for globals ... DONE
[16:12:20.659] Resolving globals: FALSE
[16:12:20.659] The total size of the 1 globals is 56 bytes (56 bytes)
[16:12:20.659] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:12:20.660] - globals: [1] ‘a’
[16:12:20.660] 
[16:12:20.660] getGlobalsAndPackages() ... DONE
[16:12:20.660] run() for ‘Future’ ...
[16:12:20.660] - state: ‘created’
[16:12:20.660] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:20.675] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:20.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:20.675]   - Field: ‘node’
[16:12:20.675]   - Field: ‘label’
[16:12:20.675]   - Field: ‘local’
[16:12:20.675]   - Field: ‘owner’
[16:12:20.675]   - Field: ‘envir’
[16:12:20.675]   - Field: ‘workers’
[16:12:20.675]   - Field: ‘packages’
[16:12:20.675]   - Field: ‘gc’
[16:12:20.676]   - Field: ‘conditions’
[16:12:20.676]   - Field: ‘persistent’
[16:12:20.676]   - Field: ‘expr’
[16:12:20.676]   - Field: ‘uuid’
[16:12:20.676]   - Field: ‘seed’
[16:12:20.676]   - Field: ‘version’
[16:12:20.676]   - Field: ‘result’
[16:12:20.676]   - Field: ‘asynchronous’
[16:12:20.676]   - Field: ‘calls’
[16:12:20.676]   - Field: ‘globals’
[16:12:20.677]   - Field: ‘stdout’
[16:12:20.677]   - Field: ‘earlySignal’
[16:12:20.677]   - Field: ‘lazy’
[16:12:20.677]   - Field: ‘state’
[16:12:20.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:20.677] - Launch lazy future ...
[16:12:20.677] Packages needed by the future expression (n = 0): <none>
[16:12:20.677] Packages needed by future strategies (n = 0): <none>
[16:12:20.678] {
[16:12:20.678]     {
[16:12:20.678]         {
[16:12:20.678]             ...future.startTime <- base::Sys.time()
[16:12:20.678]             {
[16:12:20.678]                 {
[16:12:20.678]                   {
[16:12:20.678]                     {
[16:12:20.678]                       base::local({
[16:12:20.678]                         has_future <- base::requireNamespace("future", 
[16:12:20.678]                           quietly = TRUE)
[16:12:20.678]                         if (has_future) {
[16:12:20.678]                           ns <- base::getNamespace("future")
[16:12:20.678]                           version <- ns[[".package"]][["version"]]
[16:12:20.678]                           if (is.null(version)) 
[16:12:20.678]                             version <- utils::packageVersion("future")
[16:12:20.678]                         }
[16:12:20.678]                         else {
[16:12:20.678]                           version <- NULL
[16:12:20.678]                         }
[16:12:20.678]                         if (!has_future || version < "1.8.0") {
[16:12:20.678]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:20.678]                             "", base::R.version$version.string), 
[16:12:20.678]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:20.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:20.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:20.678]                               "release", "version")], collapse = " "), 
[16:12:20.678]                             hostname = base::Sys.info()[["nodename"]])
[16:12:20.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:20.678]                             info)
[16:12:20.678]                           info <- base::paste(info, collapse = "; ")
[16:12:20.678]                           if (!has_future) {
[16:12:20.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:20.678]                               info)
[16:12:20.678]                           }
[16:12:20.678]                           else {
[16:12:20.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:20.678]                               info, version)
[16:12:20.678]                           }
[16:12:20.678]                           base::stop(msg)
[16:12:20.678]                         }
[16:12:20.678]                       })
[16:12:20.678]                     }
[16:12:20.678]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:20.678]                     base::options(mc.cores = 1L)
[16:12:20.678]                   }
[16:12:20.678]                   options(future.plan = NULL)
[16:12:20.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:20.678]                 }
[16:12:20.678]                 ...future.workdir <- getwd()
[16:12:20.678]             }
[16:12:20.678]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:20.678]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:20.678]         }
[16:12:20.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:20.678]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:20.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:20.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:20.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:20.678]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:20.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:20.678]             base::names(...future.oldOptions))
[16:12:20.678]     }
[16:12:20.678]     if (FALSE) {
[16:12:20.678]     }
[16:12:20.678]     else {
[16:12:20.678]         if (TRUE) {
[16:12:20.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:20.678]                 open = "w")
[16:12:20.678]         }
[16:12:20.678]         else {
[16:12:20.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:20.678]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:20.678]         }
[16:12:20.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:20.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:20.678]             base::sink(type = "output", split = FALSE)
[16:12:20.678]             base::close(...future.stdout)
[16:12:20.678]         }, add = TRUE)
[16:12:20.678]     }
[16:12:20.678]     ...future.frame <- base::sys.nframe()
[16:12:20.678]     ...future.conditions <- base::list()
[16:12:20.678]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:20.678]     if (FALSE) {
[16:12:20.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:20.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:20.678]     }
[16:12:20.678]     ...future.result <- base::tryCatch({
[16:12:20.678]         base::withCallingHandlers({
[16:12:20.678]             ...future.value <- base::withVisible(base::local({
[16:12:20.678]                 ...future.makeSendCondition <- local({
[16:12:20.678]                   sendCondition <- NULL
[16:12:20.678]                   function(frame = 1L) {
[16:12:20.678]                     if (is.function(sendCondition)) 
[16:12:20.678]                       return(sendCondition)
[16:12:20.678]                     ns <- getNamespace("parallel")
[16:12:20.678]                     if (exists("sendData", mode = "function", 
[16:12:20.678]                       envir = ns)) {
[16:12:20.678]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:20.678]                         envir = ns)
[16:12:20.678]                       envir <- sys.frame(frame)
[16:12:20.678]                       master <- NULL
[16:12:20.678]                       while (!identical(envir, .GlobalEnv) && 
[16:12:20.678]                         !identical(envir, emptyenv())) {
[16:12:20.678]                         if (exists("master", mode = "list", envir = envir, 
[16:12:20.678]                           inherits = FALSE)) {
[16:12:20.678]                           master <- get("master", mode = "list", 
[16:12:20.678]                             envir = envir, inherits = FALSE)
[16:12:20.678]                           if (inherits(master, c("SOCKnode", 
[16:12:20.678]                             "SOCK0node"))) {
[16:12:20.678]                             sendCondition <<- function(cond) {
[16:12:20.678]                               data <- list(type = "VALUE", value = cond, 
[16:12:20.678]                                 success = TRUE)
[16:12:20.678]                               parallel_sendData(master, data)
[16:12:20.678]                             }
[16:12:20.678]                             return(sendCondition)
[16:12:20.678]                           }
[16:12:20.678]                         }
[16:12:20.678]                         frame <- frame + 1L
[16:12:20.678]                         envir <- sys.frame(frame)
[16:12:20.678]                       }
[16:12:20.678]                     }
[16:12:20.678]                     sendCondition <<- function(cond) NULL
[16:12:20.678]                   }
[16:12:20.678]                 })
[16:12:20.678]                 withCallingHandlers({
[16:12:20.678]                   {
[16:12:20.678]                     2 * a
[16:12:20.678]                   }
[16:12:20.678]                 }, immediateCondition = function(cond) {
[16:12:20.678]                   sendCondition <- ...future.makeSendCondition()
[16:12:20.678]                   sendCondition(cond)
[16:12:20.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.678]                   {
[16:12:20.678]                     inherits <- base::inherits
[16:12:20.678]                     invokeRestart <- base::invokeRestart
[16:12:20.678]                     is.null <- base::is.null
[16:12:20.678]                     muffled <- FALSE
[16:12:20.678]                     if (inherits(cond, "message")) {
[16:12:20.678]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:20.678]                       if (muffled) 
[16:12:20.678]                         invokeRestart("muffleMessage")
[16:12:20.678]                     }
[16:12:20.678]                     else if (inherits(cond, "warning")) {
[16:12:20.678]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:20.678]                       if (muffled) 
[16:12:20.678]                         invokeRestart("muffleWarning")
[16:12:20.678]                     }
[16:12:20.678]                     else if (inherits(cond, "condition")) {
[16:12:20.678]                       if (!is.null(pattern)) {
[16:12:20.678]                         computeRestarts <- base::computeRestarts
[16:12:20.678]                         grepl <- base::grepl
[16:12:20.678]                         restarts <- computeRestarts(cond)
[16:12:20.678]                         for (restart in restarts) {
[16:12:20.678]                           name <- restart$name
[16:12:20.678]                           if (is.null(name)) 
[16:12:20.678]                             next
[16:12:20.678]                           if (!grepl(pattern, name)) 
[16:12:20.678]                             next
[16:12:20.678]                           invokeRestart(restart)
[16:12:20.678]                           muffled <- TRUE
[16:12:20.678]                           break
[16:12:20.678]                         }
[16:12:20.678]                       }
[16:12:20.678]                     }
[16:12:20.678]                     invisible(muffled)
[16:12:20.678]                   }
[16:12:20.678]                   muffleCondition(cond)
[16:12:20.678]                 })
[16:12:20.678]             }))
[16:12:20.678]             future::FutureResult(value = ...future.value$value, 
[16:12:20.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.678]                   ...future.rng), globalenv = if (FALSE) 
[16:12:20.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:20.678]                     ...future.globalenv.names))
[16:12:20.678]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:20.678]         }, condition = base::local({
[16:12:20.678]             c <- base::c
[16:12:20.678]             inherits <- base::inherits
[16:12:20.678]             invokeRestart <- base::invokeRestart
[16:12:20.678]             length <- base::length
[16:12:20.678]             list <- base::list
[16:12:20.678]             seq.int <- base::seq.int
[16:12:20.678]             signalCondition <- base::signalCondition
[16:12:20.678]             sys.calls <- base::sys.calls
[16:12:20.678]             `[[` <- base::`[[`
[16:12:20.678]             `+` <- base::`+`
[16:12:20.678]             `<<-` <- base::`<<-`
[16:12:20.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:20.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:20.678]                   3L)]
[16:12:20.678]             }
[16:12:20.678]             function(cond) {
[16:12:20.678]                 is_error <- inherits(cond, "error")
[16:12:20.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:20.678]                   NULL)
[16:12:20.678]                 if (is_error) {
[16:12:20.678]                   sessionInformation <- function() {
[16:12:20.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:20.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:20.678]                       search = base::search(), system = base::Sys.info())
[16:12:20.678]                   }
[16:12:20.678]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:20.678]                     cond$call), session = sessionInformation(), 
[16:12:20.678]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:20.678]                   signalCondition(cond)
[16:12:20.678]                 }
[16:12:20.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:20.678]                 "immediateCondition"))) {
[16:12:20.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:20.678]                   ...future.conditions[[length(...future.conditions) + 
[16:12:20.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:20.678]                   if (TRUE && !signal) {
[16:12:20.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.678]                     {
[16:12:20.678]                       inherits <- base::inherits
[16:12:20.678]                       invokeRestart <- base::invokeRestart
[16:12:20.678]                       is.null <- base::is.null
[16:12:20.678]                       muffled <- FALSE
[16:12:20.678]                       if (inherits(cond, "message")) {
[16:12:20.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.678]                         if (muffled) 
[16:12:20.678]                           invokeRestart("muffleMessage")
[16:12:20.678]                       }
[16:12:20.678]                       else if (inherits(cond, "warning")) {
[16:12:20.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.678]                         if (muffled) 
[16:12:20.678]                           invokeRestart("muffleWarning")
[16:12:20.678]                       }
[16:12:20.678]                       else if (inherits(cond, "condition")) {
[16:12:20.678]                         if (!is.null(pattern)) {
[16:12:20.678]                           computeRestarts <- base::computeRestarts
[16:12:20.678]                           grepl <- base::grepl
[16:12:20.678]                           restarts <- computeRestarts(cond)
[16:12:20.678]                           for (restart in restarts) {
[16:12:20.678]                             name <- restart$name
[16:12:20.678]                             if (is.null(name)) 
[16:12:20.678]                               next
[16:12:20.678]                             if (!grepl(pattern, name)) 
[16:12:20.678]                               next
[16:12:20.678]                             invokeRestart(restart)
[16:12:20.678]                             muffled <- TRUE
[16:12:20.678]                             break
[16:12:20.678]                           }
[16:12:20.678]                         }
[16:12:20.678]                       }
[16:12:20.678]                       invisible(muffled)
[16:12:20.678]                     }
[16:12:20.678]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.678]                   }
[16:12:20.678]                 }
[16:12:20.678]                 else {
[16:12:20.678]                   if (TRUE) {
[16:12:20.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:20.678]                     {
[16:12:20.678]                       inherits <- base::inherits
[16:12:20.678]                       invokeRestart <- base::invokeRestart
[16:12:20.678]                       is.null <- base::is.null
[16:12:20.678]                       muffled <- FALSE
[16:12:20.678]                       if (inherits(cond, "message")) {
[16:12:20.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:20.678]                         if (muffled) 
[16:12:20.678]                           invokeRestart("muffleMessage")
[16:12:20.678]                       }
[16:12:20.678]                       else if (inherits(cond, "warning")) {
[16:12:20.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:20.678]                         if (muffled) 
[16:12:20.678]                           invokeRestart("muffleWarning")
[16:12:20.678]                       }
[16:12:20.678]                       else if (inherits(cond, "condition")) {
[16:12:20.678]                         if (!is.null(pattern)) {
[16:12:20.678]                           computeRestarts <- base::computeRestarts
[16:12:20.678]                           grepl <- base::grepl
[16:12:20.678]                           restarts <- computeRestarts(cond)
[16:12:20.678]                           for (restart in restarts) {
[16:12:20.678]                             name <- restart$name
[16:12:20.678]                             if (is.null(name)) 
[16:12:20.678]                               next
[16:12:20.678]                             if (!grepl(pattern, name)) 
[16:12:20.678]                               next
[16:12:20.678]                             invokeRestart(restart)
[16:12:20.678]                             muffled <- TRUE
[16:12:20.678]                             break
[16:12:20.678]                           }
[16:12:20.678]                         }
[16:12:20.678]                       }
[16:12:20.678]                       invisible(muffled)
[16:12:20.678]                     }
[16:12:20.678]                     muffleCondition(cond, pattern = "^muffle")
[16:12:20.678]                   }
[16:12:20.678]                 }
[16:12:20.678]             }
[16:12:20.678]         }))
[16:12:20.678]     }, error = function(ex) {
[16:12:20.678]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:20.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:20.678]                 ...future.rng), started = ...future.startTime, 
[16:12:20.678]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:20.678]             version = "1.8"), class = "FutureResult")
[16:12:20.678]     }, finally = {
[16:12:20.678]         if (!identical(...future.workdir, getwd())) 
[16:12:20.678]             setwd(...future.workdir)
[16:12:20.678]         {
[16:12:20.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:20.678]                 ...future.oldOptions$nwarnings <- NULL
[16:12:20.678]             }
[16:12:20.678]             base::options(...future.oldOptions)
[16:12:20.678]             if (.Platform$OS.type == "windows") {
[16:12:20.678]                 old_names <- names(...future.oldEnvVars)
[16:12:20.678]                 envs <- base::Sys.getenv()
[16:12:20.678]                 names <- names(envs)
[16:12:20.678]                 common <- intersect(names, old_names)
[16:12:20.678]                 added <- setdiff(names, old_names)
[16:12:20.678]                 removed <- setdiff(old_names, names)
[16:12:20.678]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:20.678]                   envs[common]]
[16:12:20.678]                 NAMES <- toupper(changed)
[16:12:20.678]                 args <- list()
[16:12:20.678]                 for (kk in seq_along(NAMES)) {
[16:12:20.678]                   name <- changed[[kk]]
[16:12:20.678]                   NAME <- NAMES[[kk]]
[16:12:20.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.678]                     next
[16:12:20.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.678]                 }
[16:12:20.678]                 NAMES <- toupper(added)
[16:12:20.678]                 for (kk in seq_along(NAMES)) {
[16:12:20.678]                   name <- added[[kk]]
[16:12:20.678]                   NAME <- NAMES[[kk]]
[16:12:20.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.678]                     next
[16:12:20.678]                   args[[name]] <- ""
[16:12:20.678]                 }
[16:12:20.678]                 NAMES <- toupper(removed)
[16:12:20.678]                 for (kk in seq_along(NAMES)) {
[16:12:20.678]                   name <- removed[[kk]]
[16:12:20.678]                   NAME <- NAMES[[kk]]
[16:12:20.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:20.678]                     next
[16:12:20.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:20.678]                 }
[16:12:20.678]                 if (length(args) > 0) 
[16:12:20.678]                   base::do.call(base::Sys.setenv, args = args)
[16:12:20.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:20.678]             }
[16:12:20.678]             else {
[16:12:20.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:20.678]             }
[16:12:20.678]             {
[16:12:20.678]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:20.678]                   0L) {
[16:12:20.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:20.678]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:20.678]                   base::options(opts)
[16:12:20.678]                 }
[16:12:20.678]                 {
[16:12:20.678]                   {
[16:12:20.678]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:20.678]                     NULL
[16:12:20.678]                   }
[16:12:20.678]                   options(future.plan = NULL)
[16:12:20.678]                   if (is.na(NA_character_)) 
[16:12:20.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:20.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:20.678]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:20.678]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:20.678]                     envir = parent.frame()) 
[16:12:20.678]                   {
[16:12:20.678]                     if (is.function(workers)) 
[16:12:20.678]                       workers <- workers()
[16:12:20.678]                     workers <- structure(as.integer(workers), 
[16:12:20.678]                       class = class(workers))
[16:12:20.678]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:20.678]                       workers >= 1)
[16:12:20.678]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:20.678]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:20.678]                     }
[16:12:20.678]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:20.678]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:20.678]                       envir = envir)
[16:12:20.678]                     if (!future$lazy) 
[16:12:20.678]                       future <- run(future)
[16:12:20.678]                     invisible(future)
[16:12:20.678]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:20.678]                 }
[16:12:20.678]             }
[16:12:20.678]         }
[16:12:20.678]     })
[16:12:20.678]     if (TRUE) {
[16:12:20.678]         base::sink(type = "output", split = FALSE)
[16:12:20.678]         if (TRUE) {
[16:12:20.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:20.678]         }
[16:12:20.678]         else {
[16:12:20.678]             ...future.result["stdout"] <- base::list(NULL)
[16:12:20.678]         }
[16:12:20.678]         base::close(...future.stdout)
[16:12:20.678]         ...future.stdout <- NULL
[16:12:20.678]     }
[16:12:20.678]     ...future.result$conditions <- ...future.conditions
[16:12:20.678]     ...future.result$finished <- base::Sys.time()
[16:12:20.678]     ...future.result
[16:12:20.678] }
[16:12:20.680] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:12:20.681] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:12:20.681] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:12:20.681] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:12:20.682] MultisessionFuture started
[16:12:20.682] - Launch lazy future ... done
[16:12:20.682] run() for ‘MultisessionFuture’ ... done
[16:12:20.682] result() for ClusterFuture ...
[16:12:20.682] receiveMessageFromWorker() for ClusterFuture ...
[16:12:20.682] - Validating connection of MultisessionFuture
[16:12:20.728] - received message: FutureResult
[16:12:20.729] - Received FutureResult
[16:12:20.729] - Erased future from FutureRegistry
[16:12:20.729] result() for ClusterFuture ...
[16:12:20.729] - result already collected: FutureResult
[16:12:20.729] result() for ClusterFuture ... done
[16:12:20.729] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:20.729] result() for ClusterFuture ... done
[16:12:20.729] result() for ClusterFuture ...
[16:12:20.729] - result already collected: FutureResult
[16:12:20.729] result() for ClusterFuture ... done
*** futureAssign() with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ... DONE")
*** futureAssign() - lazy = TRUE / FALSE ... DONE
> 
> message("*** futureAssign() ... DONE")
*** futureAssign() ... DONE
> 
> source("incl/end.R")
[16:12:20.730] plan(): Setting new future strategy stack:
[16:12:20.730] List of future strategies:
[16:12:20.730] 1. FutureStrategy:
[16:12:20.730]    - args: function (..., envir = parent.frame())
[16:12:20.730]    - tweaked: FALSE
[16:12:20.730]    - call: future::plan(oplan)
[16:12:20.731] plan(): nbrOfWorkers() = 1
> 
