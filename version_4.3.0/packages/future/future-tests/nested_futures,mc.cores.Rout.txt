
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:21:09.548] plan(): Setting new future strategy stack:
[13:21:09.549] List of future strategies:
[13:21:09.549] 1. sequential:
[13:21:09.549]    - args: function (..., envir = parent.frame())
[13:21:09.549]    - tweaked: FALSE
[13:21:09.549]    - call: future::plan("sequential")
[13:21:09.562] plan(): nbrOfWorkers() = 1
> library("listenv")
> options(future.debug = FALSE)
> 
> ## WORKAROUND: R CMD check --as-cran on Windows will report
> ## 
> ## * checking for detritus in the temp directory ... NOTE
> ## Found the following files/directories:
> ##  'Rscript171866c62e
> ##
> ## which I think is due to a bug in R. For details, see R-devel thread 
> ## 'R for Windows leaves detritus in the temp directory' on 2021-06-15
> ## <https://stat.ethz.ch/pipermail/r-devel/2021-June/080830.html>.
> ## Until fixed, we skip the one test that triggers this bug.
> winWorkaround <- (.Platform$OS.type == "windows" && getRversion() >= "4.0.0")
> 
> message("*** Nested futures - mc.cores ...")
*** Nested futures - mc.cores ...
> 
> strategies <- NULL
> ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
> if (!isWin32) strategies <- c(strategies, "multisession")
> if (supportsMulticore()) strategies <- c(strategies, "multicore")
> pid <- Sys.getpid()
> cat(sprintf("Main PID: %d\n", pid))
Main PID: 89023
> 
> cat("Available cores on this machine:\n")
Available cores on this machine:
> cores <- availableCores()
> print(cores)
mc.cores 
       2 
> 
> for (mc in 1:2) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- mc.cores = %d ...", mc))
+   options(mc.cores = mc)
+   mc2 <- min(mc, cores)
+   
+   for (strategy in strategies) {
+     message(sprintf("plan(list('sequential', '%s')):", strategy))
+     plan(list('sequential', strategy))
+     a %<-% {
+       b1 %<-% Sys.getpid()
+       b2 %<-% Sys.getpid()
+       list(pid = Sys.getpid(), cores = availableCores(), pid1 = b1, pid2 = b2)
+     }
+     print(a)
+     stopifnot(a$pid == pid)
+     stopifnot((mc2 <= 1 && a$pid1 == pid) || (a$pid1 != pid))
+     stopifnot((mc2 <= 1 && a$pid2 == pid) || (a$pid2 != pid))
+     stopifnot(((mc2 <= 1 || a$cores <= 2) && a$pid2 == a$pid1) || (a$pid2 != a$pid1))
+ 
+     if (mc == 1L) {
+       message(sprintf("plan(list('sequential', '%s':2)):", strategy))
+       plan(list('sequential', tweak(strategy, workers = 2)))
+       a %<-% {
+         b1 %<-% Sys.getpid()
+         b2 %<-% Sys.getpid()
+         list(pid = Sys.getpid(), cores = availableCores(), pid1 = b1, pid2 = b2)
+       }
+       print(a)
+       stopifnot(a$pid == pid)
+       stopifnot((mc2 <= 1 && a$pid1 == pid) || (a$pid1 != pid))
+       stopifnot((mc2 <= 1 && a$pid2 == pid) || (a$pid2 != pid))
+       stopifnot((mc2 <= 1 && a$pid2 == a$pid1) || (a$pid2 != a$pid1))
+     }
+ 
+     message(sprintf("plan(list('%s', 'sequential')):", strategy))
+     plan(list(strategy, 'sequential'))
+     a %<-% {
+       b1 %<-% Sys.getpid()
+       b2 %<-% Sys.getpid()
+       list(pid = Sys.getpid(), cores = availableCores(), pid1 = b1, pid2 = b2)
+     }
+     print(a)
+     stopifnot((mc2 <= 1 && a$pid  == pid) || (a$pid  != pid))
+     stopifnot((mc2 <= 1 && a$pid1 == pid) || (a$pid1 != pid))
+     stopifnot((mc2 <= 1 && a$pid2 == pid) || (a$pid2 != pid))
+     stopifnot(a$pid2 == a$pid1)
+ 
+     message(sprintf("plan(list('%s', '%s')):", strategy, strategy))
+     plan(list(strategy, strategy))
+     a %<-% {
+       b1 %<-% { Sys.sleep(0.2); Sys.getpid() }
+       b2 %<-% Sys.getpid()
+       list(pid = Sys.getpid(), cores = availableCores(), pid1 = b1, pid2 = b2)
+     }
+     print(a)
+     stopifnot((mc2 <= 1 && a$pid  == pid) || (a$pid  != pid))
+     stopifnot((mc2 <= 1 && a$pid1 == pid) || (a$pid1 != pid))
+     stopifnot((mc2 <= 1 && a$pid2 == pid) || (a$pid2 != pid))
+     stopifnot(a$pid2 == a$pid1)
+ 
+     if (mc == 1L && !winWorkaround) {
+       message(sprintf("plan(list('%s':2, '%s':2)):", strategy, strategy))
+       plan(list(tweak(strategy, workers = 2), tweak(strategy, workers = 2)))
+       a %<-% {
+         b1 %<-% Sys.getpid()  ## This stalls
+         b2 %<-% Sys.getpid()
+         list(pid = Sys.getpid(), cores = availableCores(), pid1 = b1, pid2 = b2)
+       }
+       print(a)
+       stopifnot(a$pid  != pid)
+       stopifnot(a$pid1 != pid)
+       stopifnot(a$pid2 != pid)
+       stopifnot(a$pid2 != a$pid1)
+     }
+ 
+     ## Assert that nested the FutureRegistry is not inherited when using
+     ## nested strategies, particularly 'multicore'.
+     ## https://github.com/HenrikBengtsson/future/issues/231
+     fs <- lapply(1:2, FUN = function(i) future( value(future(TRUE)) ))
+     v <- value(fs)
+   } ## for (strategy ...)
+ 
+   message(sprintf(" - mc.cores = %d ... DONE", mc))
+ } ## for (mc ...)
- mc.cores = 1 ...
plan(list('sequential', 'multisession')):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89023

$pid2
[1] 89023

plan(list('sequential', 'multisession':2)):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89088

$pid2
[1] 89089

plan(list('multisession', 'sequential')):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89023

$pid2
[1] 89023

plan(list('multisession', 'multisession')):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89023

$pid2
[1] 89023

plan(list('multisession':2, 'multisession':2)):
$pid
[1] 89214

$cores
mc.cores 
       1 

$pid1
[1] 89326

$pid2
[1] 89327

plan(list('sequential', 'multicore')):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89023

$pid2
[1] 89023

plan(list('sequential', 'multicore':2)):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89582

$pid2
[1] 89583

plan(list('multicore', 'sequential')):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89023

$pid2
[1] 89023

plan(list('multicore', 'multicore')):
$pid
[1] 89023

$cores
mc.cores 
       1 

$pid1
[1] 89023

$pid2
[1] 89023

plan(list('multicore':2, 'multicore':2)):
$pid
[1] 89612

$cores
mc.cores 
       1 

$pid1
[1] 89613

$pid2
[1] 89614

 - mc.cores = 1 ... DONE
- mc.cores = 2 ...
plan(list('sequential', 'multisession')):
$pid
[1] 89023

$cores
mc.cores 
       2 

$pid1
[1] 89626

$pid2
[1] 89627

plan(list('multisession', 'sequential')):
$pid
[1] 89729

$cores
mc.cores 
       1 

$pid1
[1] 89729

$pid2
[1] 89729

plan(list('multisession', 'multisession')):
$pid
[1] 89830

$cores
mc.cores 
       1 

$pid1
[1] 89830

$pid2
[1] 89830

plan(list('sequential', 'multicore')):
$pid
[1] 89023

$cores
mc.cores 
       2 

$pid1
[1] 89969

$pid2
[1] 89974

plan(list('multicore', 'sequential')):
$pid
[1] 89983

$cores
mc.cores 
       1 

$pid1
[1] 89983

$pid2
[1] 89983

plan(list('multicore', 'multicore')):
$pid
[1] 89992

$cores
mc.cores 
       1 

$pid1
[1] 89992

$pid2
[1] 89992

 - mc.cores = 2 ... DONE
> 
> message("*** Nested futures - mc.cores ... DONE")
*** Nested futures - mc.cores ... DONE
> 
> source("incl/end.R")
> 
