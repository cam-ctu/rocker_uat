
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:13:05.106] plan(): Setting new future strategy stack:
[16:13:05.106] List of future strategies:
[16:13:05.106] 1. sequential:
[16:13:05.106]    - args: function (..., envir = parent.frame())
[16:13:05.106]    - tweaked: FALSE
[16:13:05.106]    - call: future::plan("sequential")
[16:13:05.119] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[16:13:05.171] getGlobalsAndPackages() ...
[16:13:05.171] Searching for globals...
[16:13:05.175] - globals found: [1] ‘{’
[16:13:05.175] Searching for globals ... DONE
[16:13:05.175] Resolving globals: FALSE
[16:13:05.176] 
[16:13:05.176] 
[16:13:05.176] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:05.178] Packages needed by the future expression (n = 0): <none>
[16:13:05.178] Packages needed by future strategies (n = 0): <none>
[16:13:05.179] {
[16:13:05.179]     {
[16:13:05.179]         {
[16:13:05.179]             ...future.startTime <- base::Sys.time()
[16:13:05.179]             {
[16:13:05.179]                 {
[16:13:05.179]                   {
[16:13:05.179]                     base::local({
[16:13:05.179]                       has_future <- base::requireNamespace("future", 
[16:13:05.179]                         quietly = TRUE)
[16:13:05.179]                       if (has_future) {
[16:13:05.179]                         ns <- base::getNamespace("future")
[16:13:05.179]                         version <- ns[[".package"]][["version"]]
[16:13:05.179]                         if (is.null(version)) 
[16:13:05.179]                           version <- utils::packageVersion("future")
[16:13:05.179]                       }
[16:13:05.179]                       else {
[16:13:05.179]                         version <- NULL
[16:13:05.179]                       }
[16:13:05.179]                       if (!has_future || version < "1.8.0") {
[16:13:05.179]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.179]                           "", base::R.version$version.string), 
[16:13:05.179]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.179]                             "release", "version")], collapse = " "), 
[16:13:05.179]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.179]                           info)
[16:13:05.179]                         info <- base::paste(info, collapse = "; ")
[16:13:05.179]                         if (!has_future) {
[16:13:05.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.179]                             info)
[16:13:05.179]                         }
[16:13:05.179]                         else {
[16:13:05.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.179]                             info, version)
[16:13:05.179]                         }
[16:13:05.179]                         base::stop(msg)
[16:13:05.179]                       }
[16:13:05.179]                     })
[16:13:05.179]                   }
[16:13:05.179]                   options(future.plan = NULL)
[16:13:05.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.179]                 }
[16:13:05.179]                 ...future.workdir <- getwd()
[16:13:05.179]             }
[16:13:05.179]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.179]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.179]         }
[16:13:05.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.179]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.179]             base::names(...future.oldOptions))
[16:13:05.179]     }
[16:13:05.179]     if (FALSE) {
[16:13:05.179]     }
[16:13:05.179]     else {
[16:13:05.179]         if (TRUE) {
[16:13:05.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.179]                 open = "w")
[16:13:05.179]         }
[16:13:05.179]         else {
[16:13:05.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.179]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.179]         }
[16:13:05.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.179]             base::sink(type = "output", split = FALSE)
[16:13:05.179]             base::close(...future.stdout)
[16:13:05.179]         }, add = TRUE)
[16:13:05.179]     }
[16:13:05.179]     ...future.frame <- base::sys.nframe()
[16:13:05.179]     ...future.conditions <- base::list()
[16:13:05.179]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.179]     if (FALSE) {
[16:13:05.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.179]     }
[16:13:05.179]     ...future.result <- base::tryCatch({
[16:13:05.179]         base::withCallingHandlers({
[16:13:05.179]             ...future.value <- base::withVisible(base::local({
[16:13:05.179]                 42L
[16:13:05.179]             }))
[16:13:05.179]             future::FutureResult(value = ...future.value$value, 
[16:13:05.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.179]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.179]                     ...future.globalenv.names))
[16:13:05.179]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.179]         }, condition = base::local({
[16:13:05.179]             c <- base::c
[16:13:05.179]             inherits <- base::inherits
[16:13:05.179]             invokeRestart <- base::invokeRestart
[16:13:05.179]             length <- base::length
[16:13:05.179]             list <- base::list
[16:13:05.179]             seq.int <- base::seq.int
[16:13:05.179]             signalCondition <- base::signalCondition
[16:13:05.179]             sys.calls <- base::sys.calls
[16:13:05.179]             `[[` <- base::`[[`
[16:13:05.179]             `+` <- base::`+`
[16:13:05.179]             `<<-` <- base::`<<-`
[16:13:05.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.179]                   3L)]
[16:13:05.179]             }
[16:13:05.179]             function(cond) {
[16:13:05.179]                 is_error <- inherits(cond, "error")
[16:13:05.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.179]                   NULL)
[16:13:05.179]                 if (is_error) {
[16:13:05.179]                   sessionInformation <- function() {
[16:13:05.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.179]                       search = base::search(), system = base::Sys.info())
[16:13:05.179]                   }
[16:13:05.179]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.179]                     cond$call), session = sessionInformation(), 
[16:13:05.179]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.179]                   signalCondition(cond)
[16:13:05.179]                 }
[16:13:05.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.179]                 "immediateCondition"))) {
[16:13:05.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.179]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.179]                   if (TRUE && !signal) {
[16:13:05.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.179]                     {
[16:13:05.179]                       inherits <- base::inherits
[16:13:05.179]                       invokeRestart <- base::invokeRestart
[16:13:05.179]                       is.null <- base::is.null
[16:13:05.179]                       muffled <- FALSE
[16:13:05.179]                       if (inherits(cond, "message")) {
[16:13:05.179]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.179]                         if (muffled) 
[16:13:05.179]                           invokeRestart("muffleMessage")
[16:13:05.179]                       }
[16:13:05.179]                       else if (inherits(cond, "warning")) {
[16:13:05.179]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.179]                         if (muffled) 
[16:13:05.179]                           invokeRestart("muffleWarning")
[16:13:05.179]                       }
[16:13:05.179]                       else if (inherits(cond, "condition")) {
[16:13:05.179]                         if (!is.null(pattern)) {
[16:13:05.179]                           computeRestarts <- base::computeRestarts
[16:13:05.179]                           grepl <- base::grepl
[16:13:05.179]                           restarts <- computeRestarts(cond)
[16:13:05.179]                           for (restart in restarts) {
[16:13:05.179]                             name <- restart$name
[16:13:05.179]                             if (is.null(name)) 
[16:13:05.179]                               next
[16:13:05.179]                             if (!grepl(pattern, name)) 
[16:13:05.179]                               next
[16:13:05.179]                             invokeRestart(restart)
[16:13:05.179]                             muffled <- TRUE
[16:13:05.179]                             break
[16:13:05.179]                           }
[16:13:05.179]                         }
[16:13:05.179]                       }
[16:13:05.179]                       invisible(muffled)
[16:13:05.179]                     }
[16:13:05.179]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.179]                   }
[16:13:05.179]                 }
[16:13:05.179]                 else {
[16:13:05.179]                   if (TRUE) {
[16:13:05.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.179]                     {
[16:13:05.179]                       inherits <- base::inherits
[16:13:05.179]                       invokeRestart <- base::invokeRestart
[16:13:05.179]                       is.null <- base::is.null
[16:13:05.179]                       muffled <- FALSE
[16:13:05.179]                       if (inherits(cond, "message")) {
[16:13:05.179]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.179]                         if (muffled) 
[16:13:05.179]                           invokeRestart("muffleMessage")
[16:13:05.179]                       }
[16:13:05.179]                       else if (inherits(cond, "warning")) {
[16:13:05.179]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.179]                         if (muffled) 
[16:13:05.179]                           invokeRestart("muffleWarning")
[16:13:05.179]                       }
[16:13:05.179]                       else if (inherits(cond, "condition")) {
[16:13:05.179]                         if (!is.null(pattern)) {
[16:13:05.179]                           computeRestarts <- base::computeRestarts
[16:13:05.179]                           grepl <- base::grepl
[16:13:05.179]                           restarts <- computeRestarts(cond)
[16:13:05.179]                           for (restart in restarts) {
[16:13:05.179]                             name <- restart$name
[16:13:05.179]                             if (is.null(name)) 
[16:13:05.179]                               next
[16:13:05.179]                             if (!grepl(pattern, name)) 
[16:13:05.179]                               next
[16:13:05.179]                             invokeRestart(restart)
[16:13:05.179]                             muffled <- TRUE
[16:13:05.179]                             break
[16:13:05.179]                           }
[16:13:05.179]                         }
[16:13:05.179]                       }
[16:13:05.179]                       invisible(muffled)
[16:13:05.179]                     }
[16:13:05.179]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.179]                   }
[16:13:05.179]                 }
[16:13:05.179]             }
[16:13:05.179]         }))
[16:13:05.179]     }, error = function(ex) {
[16:13:05.179]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.179]                 ...future.rng), started = ...future.startTime, 
[16:13:05.179]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.179]             version = "1.8"), class = "FutureResult")
[16:13:05.179]     }, finally = {
[16:13:05.179]         if (!identical(...future.workdir, getwd())) 
[16:13:05.179]             setwd(...future.workdir)
[16:13:05.179]         {
[16:13:05.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.179]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.179]             }
[16:13:05.179]             base::options(...future.oldOptions)
[16:13:05.179]             if (.Platform$OS.type == "windows") {
[16:13:05.179]                 old_names <- names(...future.oldEnvVars)
[16:13:05.179]                 envs <- base::Sys.getenv()
[16:13:05.179]                 names <- names(envs)
[16:13:05.179]                 common <- intersect(names, old_names)
[16:13:05.179]                 added <- setdiff(names, old_names)
[16:13:05.179]                 removed <- setdiff(old_names, names)
[16:13:05.179]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.179]                   envs[common]]
[16:13:05.179]                 NAMES <- toupper(changed)
[16:13:05.179]                 args <- list()
[16:13:05.179]                 for (kk in seq_along(NAMES)) {
[16:13:05.179]                   name <- changed[[kk]]
[16:13:05.179]                   NAME <- NAMES[[kk]]
[16:13:05.179]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.179]                     next
[16:13:05.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.179]                 }
[16:13:05.179]                 NAMES <- toupper(added)
[16:13:05.179]                 for (kk in seq_along(NAMES)) {
[16:13:05.179]                   name <- added[[kk]]
[16:13:05.179]                   NAME <- NAMES[[kk]]
[16:13:05.179]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.179]                     next
[16:13:05.179]                   args[[name]] <- ""
[16:13:05.179]                 }
[16:13:05.179]                 NAMES <- toupper(removed)
[16:13:05.179]                 for (kk in seq_along(NAMES)) {
[16:13:05.179]                   name <- removed[[kk]]
[16:13:05.179]                   NAME <- NAMES[[kk]]
[16:13:05.179]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.179]                     next
[16:13:05.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.179]                 }
[16:13:05.179]                 if (length(args) > 0) 
[16:13:05.179]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.179]             }
[16:13:05.179]             else {
[16:13:05.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.179]             }
[16:13:05.179]             {
[16:13:05.179]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.179]                   0L) {
[16:13:05.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.179]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.179]                   base::options(opts)
[16:13:05.179]                 }
[16:13:05.179]                 {
[16:13:05.179]                   {
[16:13:05.179]                     NULL
[16:13:05.179]                     RNGkind("Mersenne-Twister")
[16:13:05.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.179]                       inherits = FALSE)
[16:13:05.179]                   }
[16:13:05.179]                   options(future.plan = NULL)
[16:13:05.179]                   if (is.na(NA_character_)) 
[16:13:05.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.179]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.179]                   {
[16:13:05.179]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.179]                     if (!future$lazy) 
[16:13:05.179]                       future <- run(future)
[16:13:05.179]                     invisible(future)
[16:13:05.179]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.179]                 }
[16:13:05.179]             }
[16:13:05.179]         }
[16:13:05.179]     })
[16:13:05.179]     if (TRUE) {
[16:13:05.179]         base::sink(type = "output", split = FALSE)
[16:13:05.179]         if (TRUE) {
[16:13:05.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.179]         }
[16:13:05.179]         else {
[16:13:05.179]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.179]         }
[16:13:05.179]         base::close(...future.stdout)
[16:13:05.179]         ...future.stdout <- NULL
[16:13:05.179]     }
[16:13:05.179]     ...future.result$conditions <- ...future.conditions
[16:13:05.179]     ...future.result$finished <- base::Sys.time()
[16:13:05.179]     ...future.result
[16:13:05.179] }
[16:13:05.181] plan(): Setting new future strategy stack:
[16:13:05.181] List of future strategies:
[16:13:05.181] 1. sequential:
[16:13:05.181]    - args: function (..., envir = parent.frame())
[16:13:05.181]    - tweaked: FALSE
[16:13:05.181]    - call: NULL
[16:13:05.181] plan(): nbrOfWorkers() = 1
[16:13:05.182] plan(): Setting new future strategy stack:
[16:13:05.182] List of future strategies:
[16:13:05.182] 1. sequential:
[16:13:05.182]    - args: function (..., envir = parent.frame())
[16:13:05.182]    - tweaked: FALSE
[16:13:05.182]    - call: future::plan("sequential")
[16:13:05.185] plan(): nbrOfWorkers() = 1
[16:13:05.185] SequentialFuture started (and completed)
[16:13:05.185] resolved() for ‘SequentialFuture’ ...
[16:13:05.186] - state: ‘finished’
[16:13:05.186] - run: TRUE
[16:13:05.186] - result: ‘FutureResult’
[16:13:05.186] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[16:13:05.190] getGlobalsAndPackages() ...
[16:13:05.190] Searching for globals...
[16:13:05.195] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[16:13:05.195] Searching for globals ... DONE
[16:13:05.195] Resolving globals: FALSE
[16:13:05.196] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:05.196] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:13:05.196] - globals: [1] ‘a’
[16:13:05.196] 
[16:13:05.197] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:05.197] Packages needed by the future expression (n = 0): <none>
[16:13:05.198] Packages needed by future strategies (n = 0): <none>
[16:13:05.198] {
[16:13:05.198]     {
[16:13:05.198]         {
[16:13:05.198]             ...future.startTime <- base::Sys.time()
[16:13:05.198]             {
[16:13:05.198]                 {
[16:13:05.198]                   {
[16:13:05.198]                     base::local({
[16:13:05.198]                       has_future <- base::requireNamespace("future", 
[16:13:05.198]                         quietly = TRUE)
[16:13:05.198]                       if (has_future) {
[16:13:05.198]                         ns <- base::getNamespace("future")
[16:13:05.198]                         version <- ns[[".package"]][["version"]]
[16:13:05.198]                         if (is.null(version)) 
[16:13:05.198]                           version <- utils::packageVersion("future")
[16:13:05.198]                       }
[16:13:05.198]                       else {
[16:13:05.198]                         version <- NULL
[16:13:05.198]                       }
[16:13:05.198]                       if (!has_future || version < "1.8.0") {
[16:13:05.198]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.198]                           "", base::R.version$version.string), 
[16:13:05.198]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.198]                             "release", "version")], collapse = " "), 
[16:13:05.198]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.198]                           info)
[16:13:05.198]                         info <- base::paste(info, collapse = "; ")
[16:13:05.198]                         if (!has_future) {
[16:13:05.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.198]                             info)
[16:13:05.198]                         }
[16:13:05.198]                         else {
[16:13:05.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.198]                             info, version)
[16:13:05.198]                         }
[16:13:05.198]                         base::stop(msg)
[16:13:05.198]                       }
[16:13:05.198]                     })
[16:13:05.198]                   }
[16:13:05.198]                   options(future.plan = NULL)
[16:13:05.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.198]                 }
[16:13:05.198]                 ...future.workdir <- getwd()
[16:13:05.198]             }
[16:13:05.198]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.198]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.198]         }
[16:13:05.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.198]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.198]             base::names(...future.oldOptions))
[16:13:05.198]     }
[16:13:05.198]     if (FALSE) {
[16:13:05.198]     }
[16:13:05.198]     else {
[16:13:05.198]         if (TRUE) {
[16:13:05.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.198]                 open = "w")
[16:13:05.198]         }
[16:13:05.198]         else {
[16:13:05.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.198]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.198]         }
[16:13:05.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.198]             base::sink(type = "output", split = FALSE)
[16:13:05.198]             base::close(...future.stdout)
[16:13:05.198]         }, add = TRUE)
[16:13:05.198]     }
[16:13:05.198]     ...future.frame <- base::sys.nframe()
[16:13:05.198]     ...future.conditions <- base::list()
[16:13:05.198]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.198]     if (FALSE) {
[16:13:05.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.198]     }
[16:13:05.198]     ...future.result <- base::tryCatch({
[16:13:05.198]         base::withCallingHandlers({
[16:13:05.198]             ...future.value <- base::withVisible(base::local({
[16:13:05.198]                 b <- 3
[16:13:05.198]                 c <- 2
[16:13:05.198]                 a * b * c
[16:13:05.198]             }))
[16:13:05.198]             future::FutureResult(value = ...future.value$value, 
[16:13:05.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.198]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.198]                     ...future.globalenv.names))
[16:13:05.198]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.198]         }, condition = base::local({
[16:13:05.198]             c <- base::c
[16:13:05.198]             inherits <- base::inherits
[16:13:05.198]             invokeRestart <- base::invokeRestart
[16:13:05.198]             length <- base::length
[16:13:05.198]             list <- base::list
[16:13:05.198]             seq.int <- base::seq.int
[16:13:05.198]             signalCondition <- base::signalCondition
[16:13:05.198]             sys.calls <- base::sys.calls
[16:13:05.198]             `[[` <- base::`[[`
[16:13:05.198]             `+` <- base::`+`
[16:13:05.198]             `<<-` <- base::`<<-`
[16:13:05.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.198]                   3L)]
[16:13:05.198]             }
[16:13:05.198]             function(cond) {
[16:13:05.198]                 is_error <- inherits(cond, "error")
[16:13:05.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.198]                   NULL)
[16:13:05.198]                 if (is_error) {
[16:13:05.198]                   sessionInformation <- function() {
[16:13:05.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.198]                       search = base::search(), system = base::Sys.info())
[16:13:05.198]                   }
[16:13:05.198]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.198]                     cond$call), session = sessionInformation(), 
[16:13:05.198]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.198]                   signalCondition(cond)
[16:13:05.198]                 }
[16:13:05.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.198]                 "immediateCondition"))) {
[16:13:05.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.198]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.198]                   if (TRUE && !signal) {
[16:13:05.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.198]                     {
[16:13:05.198]                       inherits <- base::inherits
[16:13:05.198]                       invokeRestart <- base::invokeRestart
[16:13:05.198]                       is.null <- base::is.null
[16:13:05.198]                       muffled <- FALSE
[16:13:05.198]                       if (inherits(cond, "message")) {
[16:13:05.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.198]                         if (muffled) 
[16:13:05.198]                           invokeRestart("muffleMessage")
[16:13:05.198]                       }
[16:13:05.198]                       else if (inherits(cond, "warning")) {
[16:13:05.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.198]                         if (muffled) 
[16:13:05.198]                           invokeRestart("muffleWarning")
[16:13:05.198]                       }
[16:13:05.198]                       else if (inherits(cond, "condition")) {
[16:13:05.198]                         if (!is.null(pattern)) {
[16:13:05.198]                           computeRestarts <- base::computeRestarts
[16:13:05.198]                           grepl <- base::grepl
[16:13:05.198]                           restarts <- computeRestarts(cond)
[16:13:05.198]                           for (restart in restarts) {
[16:13:05.198]                             name <- restart$name
[16:13:05.198]                             if (is.null(name)) 
[16:13:05.198]                               next
[16:13:05.198]                             if (!grepl(pattern, name)) 
[16:13:05.198]                               next
[16:13:05.198]                             invokeRestart(restart)
[16:13:05.198]                             muffled <- TRUE
[16:13:05.198]                             break
[16:13:05.198]                           }
[16:13:05.198]                         }
[16:13:05.198]                       }
[16:13:05.198]                       invisible(muffled)
[16:13:05.198]                     }
[16:13:05.198]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.198]                   }
[16:13:05.198]                 }
[16:13:05.198]                 else {
[16:13:05.198]                   if (TRUE) {
[16:13:05.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.198]                     {
[16:13:05.198]                       inherits <- base::inherits
[16:13:05.198]                       invokeRestart <- base::invokeRestart
[16:13:05.198]                       is.null <- base::is.null
[16:13:05.198]                       muffled <- FALSE
[16:13:05.198]                       if (inherits(cond, "message")) {
[16:13:05.198]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.198]                         if (muffled) 
[16:13:05.198]                           invokeRestart("muffleMessage")
[16:13:05.198]                       }
[16:13:05.198]                       else if (inherits(cond, "warning")) {
[16:13:05.198]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.198]                         if (muffled) 
[16:13:05.198]                           invokeRestart("muffleWarning")
[16:13:05.198]                       }
[16:13:05.198]                       else if (inherits(cond, "condition")) {
[16:13:05.198]                         if (!is.null(pattern)) {
[16:13:05.198]                           computeRestarts <- base::computeRestarts
[16:13:05.198]                           grepl <- base::grepl
[16:13:05.198]                           restarts <- computeRestarts(cond)
[16:13:05.198]                           for (restart in restarts) {
[16:13:05.198]                             name <- restart$name
[16:13:05.198]                             if (is.null(name)) 
[16:13:05.198]                               next
[16:13:05.198]                             if (!grepl(pattern, name)) 
[16:13:05.198]                               next
[16:13:05.198]                             invokeRestart(restart)
[16:13:05.198]                             muffled <- TRUE
[16:13:05.198]                             break
[16:13:05.198]                           }
[16:13:05.198]                         }
[16:13:05.198]                       }
[16:13:05.198]                       invisible(muffled)
[16:13:05.198]                     }
[16:13:05.198]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.198]                   }
[16:13:05.198]                 }
[16:13:05.198]             }
[16:13:05.198]         }))
[16:13:05.198]     }, error = function(ex) {
[16:13:05.198]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.198]                 ...future.rng), started = ...future.startTime, 
[16:13:05.198]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.198]             version = "1.8"), class = "FutureResult")
[16:13:05.198]     }, finally = {
[16:13:05.198]         if (!identical(...future.workdir, getwd())) 
[16:13:05.198]             setwd(...future.workdir)
[16:13:05.198]         {
[16:13:05.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.198]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.198]             }
[16:13:05.198]             base::options(...future.oldOptions)
[16:13:05.198]             if (.Platform$OS.type == "windows") {
[16:13:05.198]                 old_names <- names(...future.oldEnvVars)
[16:13:05.198]                 envs <- base::Sys.getenv()
[16:13:05.198]                 names <- names(envs)
[16:13:05.198]                 common <- intersect(names, old_names)
[16:13:05.198]                 added <- setdiff(names, old_names)
[16:13:05.198]                 removed <- setdiff(old_names, names)
[16:13:05.198]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.198]                   envs[common]]
[16:13:05.198]                 NAMES <- toupper(changed)
[16:13:05.198]                 args <- list()
[16:13:05.198]                 for (kk in seq_along(NAMES)) {
[16:13:05.198]                   name <- changed[[kk]]
[16:13:05.198]                   NAME <- NAMES[[kk]]
[16:13:05.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.198]                     next
[16:13:05.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.198]                 }
[16:13:05.198]                 NAMES <- toupper(added)
[16:13:05.198]                 for (kk in seq_along(NAMES)) {
[16:13:05.198]                   name <- added[[kk]]
[16:13:05.198]                   NAME <- NAMES[[kk]]
[16:13:05.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.198]                     next
[16:13:05.198]                   args[[name]] <- ""
[16:13:05.198]                 }
[16:13:05.198]                 NAMES <- toupper(removed)
[16:13:05.198]                 for (kk in seq_along(NAMES)) {
[16:13:05.198]                   name <- removed[[kk]]
[16:13:05.198]                   NAME <- NAMES[[kk]]
[16:13:05.198]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.198]                     next
[16:13:05.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.198]                 }
[16:13:05.198]                 if (length(args) > 0) 
[16:13:05.198]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.198]             }
[16:13:05.198]             else {
[16:13:05.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.198]             }
[16:13:05.198]             {
[16:13:05.198]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.198]                   0L) {
[16:13:05.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.198]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.198]                   base::options(opts)
[16:13:05.198]                 }
[16:13:05.198]                 {
[16:13:05.198]                   {
[16:13:05.198]                     NULL
[16:13:05.198]                     RNGkind("Mersenne-Twister")
[16:13:05.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.198]                       inherits = FALSE)
[16:13:05.198]                   }
[16:13:05.198]                   options(future.plan = NULL)
[16:13:05.198]                   if (is.na(NA_character_)) 
[16:13:05.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.198]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.198]                   {
[16:13:05.198]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.198]                     if (!future$lazy) 
[16:13:05.198]                       future <- run(future)
[16:13:05.198]                     invisible(future)
[16:13:05.198]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.198]                 }
[16:13:05.198]             }
[16:13:05.198]         }
[16:13:05.198]     })
[16:13:05.198]     if (TRUE) {
[16:13:05.198]         base::sink(type = "output", split = FALSE)
[16:13:05.198]         if (TRUE) {
[16:13:05.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.198]         }
[16:13:05.198]         else {
[16:13:05.198]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.198]         }
[16:13:05.198]         base::close(...future.stdout)
[16:13:05.198]         ...future.stdout <- NULL
[16:13:05.198]     }
[16:13:05.198]     ...future.result$conditions <- ...future.conditions
[16:13:05.198]     ...future.result$finished <- base::Sys.time()
[16:13:05.198]     ...future.result
[16:13:05.198] }
[16:13:05.200] assign_globals() ...
[16:13:05.200] List of 1
[16:13:05.200]  $ a: num 0
[16:13:05.200]  - attr(*, "where")=List of 1
[16:13:05.200]   ..$ a:<environment: R_EmptyEnv> 
[16:13:05.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:05.200]  - attr(*, "resolved")= logi FALSE
[16:13:05.200]  - attr(*, "total_size")= num 56
[16:13:05.204] - copied ‘a’ to environment
[16:13:05.204] assign_globals() ... done
[16:13:05.205] plan(): Setting new future strategy stack:
[16:13:05.205] List of future strategies:
[16:13:05.205] 1. sequential:
[16:13:05.205]    - args: function (..., envir = parent.frame())
[16:13:05.205]    - tweaked: FALSE
[16:13:05.205]    - call: NULL
[16:13:05.205] plan(): nbrOfWorkers() = 1
[16:13:05.206] plan(): Setting new future strategy stack:
[16:13:05.206] List of future strategies:
[16:13:05.206] 1. sequential:
[16:13:05.206]    - args: function (..., envir = parent.frame())
[16:13:05.206]    - tweaked: FALSE
[16:13:05.206]    - call: future::plan("sequential")
[16:13:05.206] plan(): nbrOfWorkers() = 1
[16:13:05.206] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[16:13:05.210] getGlobalsAndPackages() ...
[16:13:05.210] Searching for globals...
[16:13:05.211] - globals found: [2] ‘{’, ‘ii’
[16:13:05.211] Searching for globals ... DONE
[16:13:05.211] Resolving globals: FALSE
[16:13:05.211] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:05.211] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:05.212] - globals: [1] ‘ii’
[16:13:05.212] 
[16:13:05.212] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[16:13:05.215] getGlobalsAndPackages() ...
[16:13:05.215] Searching for globals...
[16:13:05.216] - globals found: [2] ‘{’, ‘ii’
[16:13:05.216] Searching for globals ... DONE
[16:13:05.216] Resolving globals: FALSE
[16:13:05.217] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:05.217] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:05.217] - globals: [1] ‘ii’
[16:13:05.217] 
[16:13:05.217] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[16:13:05.218] Packages needed by the future expression (n = 0): <none>
[16:13:05.218] Packages needed by future strategies (n = 0): <none>
[16:13:05.218] {
[16:13:05.218]     {
[16:13:05.218]         {
[16:13:05.218]             ...future.startTime <- base::Sys.time()
[16:13:05.218]             {
[16:13:05.218]                 {
[16:13:05.218]                   {
[16:13:05.218]                     base::local({
[16:13:05.218]                       has_future <- base::requireNamespace("future", 
[16:13:05.218]                         quietly = TRUE)
[16:13:05.218]                       if (has_future) {
[16:13:05.218]                         ns <- base::getNamespace("future")
[16:13:05.218]                         version <- ns[[".package"]][["version"]]
[16:13:05.218]                         if (is.null(version)) 
[16:13:05.218]                           version <- utils::packageVersion("future")
[16:13:05.218]                       }
[16:13:05.218]                       else {
[16:13:05.218]                         version <- NULL
[16:13:05.218]                       }
[16:13:05.218]                       if (!has_future || version < "1.8.0") {
[16:13:05.218]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.218]                           "", base::R.version$version.string), 
[16:13:05.218]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.218]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.218]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.218]                             "release", "version")], collapse = " "), 
[16:13:05.218]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.218]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.218]                           info)
[16:13:05.218]                         info <- base::paste(info, collapse = "; ")
[16:13:05.218]                         if (!has_future) {
[16:13:05.218]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.218]                             info)
[16:13:05.218]                         }
[16:13:05.218]                         else {
[16:13:05.218]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.218]                             info, version)
[16:13:05.218]                         }
[16:13:05.218]                         base::stop(msg)
[16:13:05.218]                       }
[16:13:05.218]                     })
[16:13:05.218]                   }
[16:13:05.218]                   options(future.plan = NULL)
[16:13:05.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.218]                 }
[16:13:05.218]                 ...future.workdir <- getwd()
[16:13:05.218]             }
[16:13:05.218]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.218]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.218]         }
[16:13:05.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.218]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.218]             base::names(...future.oldOptions))
[16:13:05.218]     }
[16:13:05.218]     if (FALSE) {
[16:13:05.218]     }
[16:13:05.218]     else {
[16:13:05.218]         if (TRUE) {
[16:13:05.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.218]                 open = "w")
[16:13:05.218]         }
[16:13:05.218]         else {
[16:13:05.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.218]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.218]         }
[16:13:05.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.218]             base::sink(type = "output", split = FALSE)
[16:13:05.218]             base::close(...future.stdout)
[16:13:05.218]         }, add = TRUE)
[16:13:05.218]     }
[16:13:05.218]     ...future.frame <- base::sys.nframe()
[16:13:05.218]     ...future.conditions <- base::list()
[16:13:05.218]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.218]     if (FALSE) {
[16:13:05.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.218]     }
[16:13:05.218]     ...future.result <- base::tryCatch({
[16:13:05.218]         base::withCallingHandlers({
[16:13:05.218]             ...future.value <- base::withVisible(base::local({
[16:13:05.218]                 ii
[16:13:05.218]             }))
[16:13:05.218]             future::FutureResult(value = ...future.value$value, 
[16:13:05.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.218]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.218]                     ...future.globalenv.names))
[16:13:05.218]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.218]         }, condition = base::local({
[16:13:05.218]             c <- base::c
[16:13:05.218]             inherits <- base::inherits
[16:13:05.218]             invokeRestart <- base::invokeRestart
[16:13:05.218]             length <- base::length
[16:13:05.218]             list <- base::list
[16:13:05.218]             seq.int <- base::seq.int
[16:13:05.218]             signalCondition <- base::signalCondition
[16:13:05.218]             sys.calls <- base::sys.calls
[16:13:05.218]             `[[` <- base::`[[`
[16:13:05.218]             `+` <- base::`+`
[16:13:05.218]             `<<-` <- base::`<<-`
[16:13:05.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.218]                   3L)]
[16:13:05.218]             }
[16:13:05.218]             function(cond) {
[16:13:05.218]                 is_error <- inherits(cond, "error")
[16:13:05.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.218]                   NULL)
[16:13:05.218]                 if (is_error) {
[16:13:05.218]                   sessionInformation <- function() {
[16:13:05.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.218]                       search = base::search(), system = base::Sys.info())
[16:13:05.218]                   }
[16:13:05.218]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.218]                     cond$call), session = sessionInformation(), 
[16:13:05.218]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.218]                   signalCondition(cond)
[16:13:05.218]                 }
[16:13:05.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.218]                 "immediateCondition"))) {
[16:13:05.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.218]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.218]                   if (TRUE && !signal) {
[16:13:05.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.218]                     {
[16:13:05.218]                       inherits <- base::inherits
[16:13:05.218]                       invokeRestart <- base::invokeRestart
[16:13:05.218]                       is.null <- base::is.null
[16:13:05.218]                       muffled <- FALSE
[16:13:05.218]                       if (inherits(cond, "message")) {
[16:13:05.218]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.218]                         if (muffled) 
[16:13:05.218]                           invokeRestart("muffleMessage")
[16:13:05.218]                       }
[16:13:05.218]                       else if (inherits(cond, "warning")) {
[16:13:05.218]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.218]                         if (muffled) 
[16:13:05.218]                           invokeRestart("muffleWarning")
[16:13:05.218]                       }
[16:13:05.218]                       else if (inherits(cond, "condition")) {
[16:13:05.218]                         if (!is.null(pattern)) {
[16:13:05.218]                           computeRestarts <- base::computeRestarts
[16:13:05.218]                           grepl <- base::grepl
[16:13:05.218]                           restarts <- computeRestarts(cond)
[16:13:05.218]                           for (restart in restarts) {
[16:13:05.218]                             name <- restart$name
[16:13:05.218]                             if (is.null(name)) 
[16:13:05.218]                               next
[16:13:05.218]                             if (!grepl(pattern, name)) 
[16:13:05.218]                               next
[16:13:05.218]                             invokeRestart(restart)
[16:13:05.218]                             muffled <- TRUE
[16:13:05.218]                             break
[16:13:05.218]                           }
[16:13:05.218]                         }
[16:13:05.218]                       }
[16:13:05.218]                       invisible(muffled)
[16:13:05.218]                     }
[16:13:05.218]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.218]                   }
[16:13:05.218]                 }
[16:13:05.218]                 else {
[16:13:05.218]                   if (TRUE) {
[16:13:05.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.218]                     {
[16:13:05.218]                       inherits <- base::inherits
[16:13:05.218]                       invokeRestart <- base::invokeRestart
[16:13:05.218]                       is.null <- base::is.null
[16:13:05.218]                       muffled <- FALSE
[16:13:05.218]                       if (inherits(cond, "message")) {
[16:13:05.218]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.218]                         if (muffled) 
[16:13:05.218]                           invokeRestart("muffleMessage")
[16:13:05.218]                       }
[16:13:05.218]                       else if (inherits(cond, "warning")) {
[16:13:05.218]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.218]                         if (muffled) 
[16:13:05.218]                           invokeRestart("muffleWarning")
[16:13:05.218]                       }
[16:13:05.218]                       else if (inherits(cond, "condition")) {
[16:13:05.218]                         if (!is.null(pattern)) {
[16:13:05.218]                           computeRestarts <- base::computeRestarts
[16:13:05.218]                           grepl <- base::grepl
[16:13:05.218]                           restarts <- computeRestarts(cond)
[16:13:05.218]                           for (restart in restarts) {
[16:13:05.218]                             name <- restart$name
[16:13:05.218]                             if (is.null(name)) 
[16:13:05.218]                               next
[16:13:05.218]                             if (!grepl(pattern, name)) 
[16:13:05.218]                               next
[16:13:05.218]                             invokeRestart(restart)
[16:13:05.218]                             muffled <- TRUE
[16:13:05.218]                             break
[16:13:05.218]                           }
[16:13:05.218]                         }
[16:13:05.218]                       }
[16:13:05.218]                       invisible(muffled)
[16:13:05.218]                     }
[16:13:05.218]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.218]                   }
[16:13:05.218]                 }
[16:13:05.218]             }
[16:13:05.218]         }))
[16:13:05.218]     }, error = function(ex) {
[16:13:05.218]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.218]                 ...future.rng), started = ...future.startTime, 
[16:13:05.218]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.218]             version = "1.8"), class = "FutureResult")
[16:13:05.218]     }, finally = {
[16:13:05.218]         if (!identical(...future.workdir, getwd())) 
[16:13:05.218]             setwd(...future.workdir)
[16:13:05.218]         {
[16:13:05.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.218]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.218]             }
[16:13:05.218]             base::options(...future.oldOptions)
[16:13:05.218]             if (.Platform$OS.type == "windows") {
[16:13:05.218]                 old_names <- names(...future.oldEnvVars)
[16:13:05.218]                 envs <- base::Sys.getenv()
[16:13:05.218]                 names <- names(envs)
[16:13:05.218]                 common <- intersect(names, old_names)
[16:13:05.218]                 added <- setdiff(names, old_names)
[16:13:05.218]                 removed <- setdiff(old_names, names)
[16:13:05.218]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.218]                   envs[common]]
[16:13:05.218]                 NAMES <- toupper(changed)
[16:13:05.218]                 args <- list()
[16:13:05.218]                 for (kk in seq_along(NAMES)) {
[16:13:05.218]                   name <- changed[[kk]]
[16:13:05.218]                   NAME <- NAMES[[kk]]
[16:13:05.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.218]                     next
[16:13:05.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.218]                 }
[16:13:05.218]                 NAMES <- toupper(added)
[16:13:05.218]                 for (kk in seq_along(NAMES)) {
[16:13:05.218]                   name <- added[[kk]]
[16:13:05.218]                   NAME <- NAMES[[kk]]
[16:13:05.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.218]                     next
[16:13:05.218]                   args[[name]] <- ""
[16:13:05.218]                 }
[16:13:05.218]                 NAMES <- toupper(removed)
[16:13:05.218]                 for (kk in seq_along(NAMES)) {
[16:13:05.218]                   name <- removed[[kk]]
[16:13:05.218]                   NAME <- NAMES[[kk]]
[16:13:05.218]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.218]                     next
[16:13:05.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.218]                 }
[16:13:05.218]                 if (length(args) > 0) 
[16:13:05.218]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.218]             }
[16:13:05.218]             else {
[16:13:05.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.218]             }
[16:13:05.218]             {
[16:13:05.218]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.218]                   0L) {
[16:13:05.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.218]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.218]                   base::options(opts)
[16:13:05.218]                 }
[16:13:05.218]                 {
[16:13:05.218]                   {
[16:13:05.218]                     NULL
[16:13:05.218]                     RNGkind("Mersenne-Twister")
[16:13:05.218]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.218]                       inherits = FALSE)
[16:13:05.218]                   }
[16:13:05.218]                   options(future.plan = NULL)
[16:13:05.218]                   if (is.na(NA_character_)) 
[16:13:05.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.218]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.218]                   {
[16:13:05.218]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.218]                     if (!future$lazy) 
[16:13:05.218]                       future <- run(future)
[16:13:05.218]                     invisible(future)
[16:13:05.218]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.218]                 }
[16:13:05.218]             }
[16:13:05.218]         }
[16:13:05.218]     })
[16:13:05.218]     if (TRUE) {
[16:13:05.218]         base::sink(type = "output", split = FALSE)
[16:13:05.218]         if (TRUE) {
[16:13:05.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.218]         }
[16:13:05.218]         else {
[16:13:05.218]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.218]         }
[16:13:05.218]         base::close(...future.stdout)
[16:13:05.218]         ...future.stdout <- NULL
[16:13:05.218]     }
[16:13:05.218]     ...future.result$conditions <- ...future.conditions
[16:13:05.218]     ...future.result$finished <- base::Sys.time()
[16:13:05.218]     ...future.result
[16:13:05.218] }
[16:13:05.220] assign_globals() ...
[16:13:05.220] List of 1
[16:13:05.220]  $ ii: int 1
[16:13:05.220]  - attr(*, "where")=List of 1
[16:13:05.220]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:05.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:05.220]  - attr(*, "resolved")= logi FALSE
[16:13:05.220]  - attr(*, "total_size")= num 56
[16:13:05.222] - copied ‘ii’ to environment
[16:13:05.222] assign_globals() ... done
[16:13:05.222] plan(): Setting new future strategy stack:
[16:13:05.223] List of future strategies:
[16:13:05.223] 1. sequential:
[16:13:05.223]    - args: function (..., envir = parent.frame())
[16:13:05.223]    - tweaked: FALSE
[16:13:05.223]    - call: NULL
[16:13:05.223] plan(): nbrOfWorkers() = 1
[16:13:05.224] plan(): Setting new future strategy stack:
[16:13:05.224] List of future strategies:
[16:13:05.224] 1. sequential:
[16:13:05.224]    - args: function (..., envir = parent.frame())
[16:13:05.224]    - tweaked: FALSE
[16:13:05.224]    - call: future::plan("sequential")
[16:13:05.224] plan(): nbrOfWorkers() = 1
[16:13:05.226] SequentialFuture started (and completed)
[16:13:05.227] Packages needed by the future expression (n = 0): <none>
[16:13:05.227] Packages needed by future strategies (n = 0): <none>
[16:13:05.227] {
[16:13:05.227]     {
[16:13:05.227]         {
[16:13:05.227]             ...future.startTime <- base::Sys.time()
[16:13:05.227]             {
[16:13:05.227]                 {
[16:13:05.227]                   {
[16:13:05.227]                     base::local({
[16:13:05.227]                       has_future <- base::requireNamespace("future", 
[16:13:05.227]                         quietly = TRUE)
[16:13:05.227]                       if (has_future) {
[16:13:05.227]                         ns <- base::getNamespace("future")
[16:13:05.227]                         version <- ns[[".package"]][["version"]]
[16:13:05.227]                         if (is.null(version)) 
[16:13:05.227]                           version <- utils::packageVersion("future")
[16:13:05.227]                       }
[16:13:05.227]                       else {
[16:13:05.227]                         version <- NULL
[16:13:05.227]                       }
[16:13:05.227]                       if (!has_future || version < "1.8.0") {
[16:13:05.227]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.227]                           "", base::R.version$version.string), 
[16:13:05.227]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.227]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.227]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.227]                             "release", "version")], collapse = " "), 
[16:13:05.227]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.227]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.227]                           info)
[16:13:05.227]                         info <- base::paste(info, collapse = "; ")
[16:13:05.227]                         if (!has_future) {
[16:13:05.227]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.227]                             info)
[16:13:05.227]                         }
[16:13:05.227]                         else {
[16:13:05.227]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.227]                             info, version)
[16:13:05.227]                         }
[16:13:05.227]                         base::stop(msg)
[16:13:05.227]                       }
[16:13:05.227]                     })
[16:13:05.227]                   }
[16:13:05.227]                   options(future.plan = NULL)
[16:13:05.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.227]                 }
[16:13:05.227]                 ...future.workdir <- getwd()
[16:13:05.227]             }
[16:13:05.227]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.227]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.227]         }
[16:13:05.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.227]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.227]             base::names(...future.oldOptions))
[16:13:05.227]     }
[16:13:05.227]     if (FALSE) {
[16:13:05.227]     }
[16:13:05.227]     else {
[16:13:05.227]         if (TRUE) {
[16:13:05.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.227]                 open = "w")
[16:13:05.227]         }
[16:13:05.227]         else {
[16:13:05.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.227]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.227]         }
[16:13:05.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.227]             base::sink(type = "output", split = FALSE)
[16:13:05.227]             base::close(...future.stdout)
[16:13:05.227]         }, add = TRUE)
[16:13:05.227]     }
[16:13:05.227]     ...future.frame <- base::sys.nframe()
[16:13:05.227]     ...future.conditions <- base::list()
[16:13:05.227]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.227]     if (FALSE) {
[16:13:05.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.227]     }
[16:13:05.227]     ...future.result <- base::tryCatch({
[16:13:05.227]         base::withCallingHandlers({
[16:13:05.227]             ...future.value <- base::withVisible(base::local({
[16:13:05.227]                 ii
[16:13:05.227]             }))
[16:13:05.227]             future::FutureResult(value = ...future.value$value, 
[16:13:05.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.227]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.227]                     ...future.globalenv.names))
[16:13:05.227]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.227]         }, condition = base::local({
[16:13:05.227]             c <- base::c
[16:13:05.227]             inherits <- base::inherits
[16:13:05.227]             invokeRestart <- base::invokeRestart
[16:13:05.227]             length <- base::length
[16:13:05.227]             list <- base::list
[16:13:05.227]             seq.int <- base::seq.int
[16:13:05.227]             signalCondition <- base::signalCondition
[16:13:05.227]             sys.calls <- base::sys.calls
[16:13:05.227]             `[[` <- base::`[[`
[16:13:05.227]             `+` <- base::`+`
[16:13:05.227]             `<<-` <- base::`<<-`
[16:13:05.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.227]                   3L)]
[16:13:05.227]             }
[16:13:05.227]             function(cond) {
[16:13:05.227]                 is_error <- inherits(cond, "error")
[16:13:05.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.227]                   NULL)
[16:13:05.227]                 if (is_error) {
[16:13:05.227]                   sessionInformation <- function() {
[16:13:05.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.227]                       search = base::search(), system = base::Sys.info())
[16:13:05.227]                   }
[16:13:05.227]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.227]                     cond$call), session = sessionInformation(), 
[16:13:05.227]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.227]                   signalCondition(cond)
[16:13:05.227]                 }
[16:13:05.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.227]                 "immediateCondition"))) {
[16:13:05.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.227]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.227]                   if (TRUE && !signal) {
[16:13:05.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.227]                     {
[16:13:05.227]                       inherits <- base::inherits
[16:13:05.227]                       invokeRestart <- base::invokeRestart
[16:13:05.227]                       is.null <- base::is.null
[16:13:05.227]                       muffled <- FALSE
[16:13:05.227]                       if (inherits(cond, "message")) {
[16:13:05.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.227]                         if (muffled) 
[16:13:05.227]                           invokeRestart("muffleMessage")
[16:13:05.227]                       }
[16:13:05.227]                       else if (inherits(cond, "warning")) {
[16:13:05.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.227]                         if (muffled) 
[16:13:05.227]                           invokeRestart("muffleWarning")
[16:13:05.227]                       }
[16:13:05.227]                       else if (inherits(cond, "condition")) {
[16:13:05.227]                         if (!is.null(pattern)) {
[16:13:05.227]                           computeRestarts <- base::computeRestarts
[16:13:05.227]                           grepl <- base::grepl
[16:13:05.227]                           restarts <- computeRestarts(cond)
[16:13:05.227]                           for (restart in restarts) {
[16:13:05.227]                             name <- restart$name
[16:13:05.227]                             if (is.null(name)) 
[16:13:05.227]                               next
[16:13:05.227]                             if (!grepl(pattern, name)) 
[16:13:05.227]                               next
[16:13:05.227]                             invokeRestart(restart)
[16:13:05.227]                             muffled <- TRUE
[16:13:05.227]                             break
[16:13:05.227]                           }
[16:13:05.227]                         }
[16:13:05.227]                       }
[16:13:05.227]                       invisible(muffled)
[16:13:05.227]                     }
[16:13:05.227]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.227]                   }
[16:13:05.227]                 }
[16:13:05.227]                 else {
[16:13:05.227]                   if (TRUE) {
[16:13:05.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.227]                     {
[16:13:05.227]                       inherits <- base::inherits
[16:13:05.227]                       invokeRestart <- base::invokeRestart
[16:13:05.227]                       is.null <- base::is.null
[16:13:05.227]                       muffled <- FALSE
[16:13:05.227]                       if (inherits(cond, "message")) {
[16:13:05.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.227]                         if (muffled) 
[16:13:05.227]                           invokeRestart("muffleMessage")
[16:13:05.227]                       }
[16:13:05.227]                       else if (inherits(cond, "warning")) {
[16:13:05.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.227]                         if (muffled) 
[16:13:05.227]                           invokeRestart("muffleWarning")
[16:13:05.227]                       }
[16:13:05.227]                       else if (inherits(cond, "condition")) {
[16:13:05.227]                         if (!is.null(pattern)) {
[16:13:05.227]                           computeRestarts <- base::computeRestarts
[16:13:05.227]                           grepl <- base::grepl
[16:13:05.227]                           restarts <- computeRestarts(cond)
[16:13:05.227]                           for (restart in restarts) {
[16:13:05.227]                             name <- restart$name
[16:13:05.227]                             if (is.null(name)) 
[16:13:05.227]                               next
[16:13:05.227]                             if (!grepl(pattern, name)) 
[16:13:05.227]                               next
[16:13:05.227]                             invokeRestart(restart)
[16:13:05.227]                             muffled <- TRUE
[16:13:05.227]                             break
[16:13:05.227]                           }
[16:13:05.227]                         }
[16:13:05.227]                       }
[16:13:05.227]                       invisible(muffled)
[16:13:05.227]                     }
[16:13:05.227]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.227]                   }
[16:13:05.227]                 }
[16:13:05.227]             }
[16:13:05.227]         }))
[16:13:05.227]     }, error = function(ex) {
[16:13:05.227]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.227]                 ...future.rng), started = ...future.startTime, 
[16:13:05.227]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.227]             version = "1.8"), class = "FutureResult")
[16:13:05.227]     }, finally = {
[16:13:05.227]         if (!identical(...future.workdir, getwd())) 
[16:13:05.227]             setwd(...future.workdir)
[16:13:05.227]         {
[16:13:05.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.227]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.227]             }
[16:13:05.227]             base::options(...future.oldOptions)
[16:13:05.227]             if (.Platform$OS.type == "windows") {
[16:13:05.227]                 old_names <- names(...future.oldEnvVars)
[16:13:05.227]                 envs <- base::Sys.getenv()
[16:13:05.227]                 names <- names(envs)
[16:13:05.227]                 common <- intersect(names, old_names)
[16:13:05.227]                 added <- setdiff(names, old_names)
[16:13:05.227]                 removed <- setdiff(old_names, names)
[16:13:05.227]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.227]                   envs[common]]
[16:13:05.227]                 NAMES <- toupper(changed)
[16:13:05.227]                 args <- list()
[16:13:05.227]                 for (kk in seq_along(NAMES)) {
[16:13:05.227]                   name <- changed[[kk]]
[16:13:05.227]                   NAME <- NAMES[[kk]]
[16:13:05.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.227]                     next
[16:13:05.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.227]                 }
[16:13:05.227]                 NAMES <- toupper(added)
[16:13:05.227]                 for (kk in seq_along(NAMES)) {
[16:13:05.227]                   name <- added[[kk]]
[16:13:05.227]                   NAME <- NAMES[[kk]]
[16:13:05.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.227]                     next
[16:13:05.227]                   args[[name]] <- ""
[16:13:05.227]                 }
[16:13:05.227]                 NAMES <- toupper(removed)
[16:13:05.227]                 for (kk in seq_along(NAMES)) {
[16:13:05.227]                   name <- removed[[kk]]
[16:13:05.227]                   NAME <- NAMES[[kk]]
[16:13:05.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.227]                     next
[16:13:05.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.227]                 }
[16:13:05.227]                 if (length(args) > 0) 
[16:13:05.227]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.227]             }
[16:13:05.227]             else {
[16:13:05.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.227]             }
[16:13:05.227]             {
[16:13:05.227]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.227]                   0L) {
[16:13:05.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.227]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.227]                   base::options(opts)
[16:13:05.227]                 }
[16:13:05.227]                 {
[16:13:05.227]                   {
[16:13:05.227]                     NULL
[16:13:05.227]                     RNGkind("Mersenne-Twister")
[16:13:05.227]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.227]                       inherits = FALSE)
[16:13:05.227]                   }
[16:13:05.227]                   options(future.plan = NULL)
[16:13:05.227]                   if (is.na(NA_character_)) 
[16:13:05.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.227]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.227]                   {
[16:13:05.227]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.227]                     if (!future$lazy) 
[16:13:05.227]                       future <- run(future)
[16:13:05.227]                     invisible(future)
[16:13:05.227]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.227]                 }
[16:13:05.227]             }
[16:13:05.227]         }
[16:13:05.227]     })
[16:13:05.227]     if (TRUE) {
[16:13:05.227]         base::sink(type = "output", split = FALSE)
[16:13:05.227]         if (TRUE) {
[16:13:05.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.227]         }
[16:13:05.227]         else {
[16:13:05.227]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.227]         }
[16:13:05.227]         base::close(...future.stdout)
[16:13:05.227]         ...future.stdout <- NULL
[16:13:05.227]     }
[16:13:05.227]     ...future.result$conditions <- ...future.conditions
[16:13:05.227]     ...future.result$finished <- base::Sys.time()
[16:13:05.227]     ...future.result
[16:13:05.227] }
[16:13:05.229] assign_globals() ...
[16:13:05.229] List of 1
[16:13:05.229]  $ ii: int 2
[16:13:05.229]  - attr(*, "where")=List of 1
[16:13:05.229]   ..$ ii:<environment: R_EmptyEnv> 
[16:13:05.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:05.229]  - attr(*, "resolved")= logi FALSE
[16:13:05.229]  - attr(*, "total_size")= num 56
[16:13:05.231] - copied ‘ii’ to environment
[16:13:05.231] assign_globals() ... done
[16:13:05.231] plan(): Setting new future strategy stack:
[16:13:05.231] List of future strategies:
[16:13:05.231] 1. sequential:
[16:13:05.231]    - args: function (..., envir = parent.frame())
[16:13:05.231]    - tweaked: FALSE
[16:13:05.231]    - call: NULL
[16:13:05.232] plan(): nbrOfWorkers() = 1
[16:13:05.233] plan(): Setting new future strategy stack:
[16:13:05.233] List of future strategies:
[16:13:05.233] 1. sequential:
[16:13:05.233]    - args: function (..., envir = parent.frame())
[16:13:05.233]    - tweaked: FALSE
[16:13:05.233]    - call: future::plan("sequential")
[16:13:05.233] plan(): nbrOfWorkers() = 1
[16:13:05.233] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[16:13:05.233] getGlobalsAndPackages() ...
[16:13:05.234] Searching for globals...
[16:13:05.234] - globals found: [1] ‘.libPaths’
[16:13:05.234] Searching for globals ... DONE
[16:13:05.234] Resolving globals: FALSE
[16:13:05.234] 
[16:13:05.235] 
[16:13:05.235] getGlobalsAndPackages() ... DONE
[16:13:05.235] run() for ‘Future’ ...
[16:13:05.235] - state: ‘created’
[16:13:05.235] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:05.236] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:05.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:05.236]   - Field: ‘label’
[16:13:05.236]   - Field: ‘local’
[16:13:05.236]   - Field: ‘owner’
[16:13:05.236]   - Field: ‘envir’
[16:13:05.236]   - Field: ‘packages’
[16:13:05.236]   - Field: ‘gc’
[16:13:05.236]   - Field: ‘conditions’
[16:13:05.237]   - Field: ‘expr’
[16:13:05.237]   - Field: ‘uuid’
[16:13:05.237]   - Field: ‘seed’
[16:13:05.237]   - Field: ‘version’
[16:13:05.237]   - Field: ‘result’
[16:13:05.237]   - Field: ‘asynchronous’
[16:13:05.237]   - Field: ‘calls’
[16:13:05.237]   - Field: ‘globals’
[16:13:05.237]   - Field: ‘stdout’
[16:13:05.237]   - Field: ‘earlySignal’
[16:13:05.237]   - Field: ‘lazy’
[16:13:05.238]   - Field: ‘state’
[16:13:05.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:05.238] - Launch lazy future ...
[16:13:05.238] Packages needed by the future expression (n = 0): <none>
[16:13:05.238] Packages needed by future strategies (n = 0): <none>
[16:13:05.238] {
[16:13:05.238]     {
[16:13:05.238]         {
[16:13:05.238]             ...future.startTime <- base::Sys.time()
[16:13:05.238]             {
[16:13:05.238]                 {
[16:13:05.238]                   {
[16:13:05.238]                     base::local({
[16:13:05.238]                       has_future <- base::requireNamespace("future", 
[16:13:05.238]                         quietly = TRUE)
[16:13:05.238]                       if (has_future) {
[16:13:05.238]                         ns <- base::getNamespace("future")
[16:13:05.238]                         version <- ns[[".package"]][["version"]]
[16:13:05.238]                         if (is.null(version)) 
[16:13:05.238]                           version <- utils::packageVersion("future")
[16:13:05.238]                       }
[16:13:05.238]                       else {
[16:13:05.238]                         version <- NULL
[16:13:05.238]                       }
[16:13:05.238]                       if (!has_future || version < "1.8.0") {
[16:13:05.238]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.238]                           "", base::R.version$version.string), 
[16:13:05.238]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.238]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.238]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.238]                             "release", "version")], collapse = " "), 
[16:13:05.238]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.238]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.238]                           info)
[16:13:05.238]                         info <- base::paste(info, collapse = "; ")
[16:13:05.238]                         if (!has_future) {
[16:13:05.238]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.238]                             info)
[16:13:05.238]                         }
[16:13:05.238]                         else {
[16:13:05.238]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.238]                             info, version)
[16:13:05.238]                         }
[16:13:05.238]                         base::stop(msg)
[16:13:05.238]                       }
[16:13:05.238]                     })
[16:13:05.238]                   }
[16:13:05.238]                   options(future.plan = NULL)
[16:13:05.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.238]                 }
[16:13:05.238]                 ...future.workdir <- getwd()
[16:13:05.238]             }
[16:13:05.238]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.238]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.238]         }
[16:13:05.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.238]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.238]             base::names(...future.oldOptions))
[16:13:05.238]     }
[16:13:05.238]     if (FALSE) {
[16:13:05.238]     }
[16:13:05.238]     else {
[16:13:05.238]         if (TRUE) {
[16:13:05.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.238]                 open = "w")
[16:13:05.238]         }
[16:13:05.238]         else {
[16:13:05.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.238]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.238]         }
[16:13:05.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.238]             base::sink(type = "output", split = FALSE)
[16:13:05.238]             base::close(...future.stdout)
[16:13:05.238]         }, add = TRUE)
[16:13:05.238]     }
[16:13:05.238]     ...future.frame <- base::sys.nframe()
[16:13:05.238]     ...future.conditions <- base::list()
[16:13:05.238]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.238]     if (FALSE) {
[16:13:05.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.238]     }
[16:13:05.238]     ...future.result <- base::tryCatch({
[16:13:05.238]         base::withCallingHandlers({
[16:13:05.238]             ...future.value <- base::withVisible(base::local(.libPaths()))
[16:13:05.238]             future::FutureResult(value = ...future.value$value, 
[16:13:05.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.238]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.238]                     ...future.globalenv.names))
[16:13:05.238]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.238]         }, condition = base::local({
[16:13:05.238]             c <- base::c
[16:13:05.238]             inherits <- base::inherits
[16:13:05.238]             invokeRestart <- base::invokeRestart
[16:13:05.238]             length <- base::length
[16:13:05.238]             list <- base::list
[16:13:05.238]             seq.int <- base::seq.int
[16:13:05.238]             signalCondition <- base::signalCondition
[16:13:05.238]             sys.calls <- base::sys.calls
[16:13:05.238]             `[[` <- base::`[[`
[16:13:05.238]             `+` <- base::`+`
[16:13:05.238]             `<<-` <- base::`<<-`
[16:13:05.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.238]                   3L)]
[16:13:05.238]             }
[16:13:05.238]             function(cond) {
[16:13:05.238]                 is_error <- inherits(cond, "error")
[16:13:05.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.238]                   NULL)
[16:13:05.238]                 if (is_error) {
[16:13:05.238]                   sessionInformation <- function() {
[16:13:05.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.238]                       search = base::search(), system = base::Sys.info())
[16:13:05.238]                   }
[16:13:05.238]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.238]                     cond$call), session = sessionInformation(), 
[16:13:05.238]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.238]                   signalCondition(cond)
[16:13:05.238]                 }
[16:13:05.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.238]                 "immediateCondition"))) {
[16:13:05.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.238]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.238]                   if (TRUE && !signal) {
[16:13:05.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.238]                     {
[16:13:05.238]                       inherits <- base::inherits
[16:13:05.238]                       invokeRestart <- base::invokeRestart
[16:13:05.238]                       is.null <- base::is.null
[16:13:05.238]                       muffled <- FALSE
[16:13:05.238]                       if (inherits(cond, "message")) {
[16:13:05.238]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.238]                         if (muffled) 
[16:13:05.238]                           invokeRestart("muffleMessage")
[16:13:05.238]                       }
[16:13:05.238]                       else if (inherits(cond, "warning")) {
[16:13:05.238]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.238]                         if (muffled) 
[16:13:05.238]                           invokeRestart("muffleWarning")
[16:13:05.238]                       }
[16:13:05.238]                       else if (inherits(cond, "condition")) {
[16:13:05.238]                         if (!is.null(pattern)) {
[16:13:05.238]                           computeRestarts <- base::computeRestarts
[16:13:05.238]                           grepl <- base::grepl
[16:13:05.238]                           restarts <- computeRestarts(cond)
[16:13:05.238]                           for (restart in restarts) {
[16:13:05.238]                             name <- restart$name
[16:13:05.238]                             if (is.null(name)) 
[16:13:05.238]                               next
[16:13:05.238]                             if (!grepl(pattern, name)) 
[16:13:05.238]                               next
[16:13:05.238]                             invokeRestart(restart)
[16:13:05.238]                             muffled <- TRUE
[16:13:05.238]                             break
[16:13:05.238]                           }
[16:13:05.238]                         }
[16:13:05.238]                       }
[16:13:05.238]                       invisible(muffled)
[16:13:05.238]                     }
[16:13:05.238]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.238]                   }
[16:13:05.238]                 }
[16:13:05.238]                 else {
[16:13:05.238]                   if (TRUE) {
[16:13:05.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.238]                     {
[16:13:05.238]                       inherits <- base::inherits
[16:13:05.238]                       invokeRestart <- base::invokeRestart
[16:13:05.238]                       is.null <- base::is.null
[16:13:05.238]                       muffled <- FALSE
[16:13:05.238]                       if (inherits(cond, "message")) {
[16:13:05.238]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.238]                         if (muffled) 
[16:13:05.238]                           invokeRestart("muffleMessage")
[16:13:05.238]                       }
[16:13:05.238]                       else if (inherits(cond, "warning")) {
[16:13:05.238]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.238]                         if (muffled) 
[16:13:05.238]                           invokeRestart("muffleWarning")
[16:13:05.238]                       }
[16:13:05.238]                       else if (inherits(cond, "condition")) {
[16:13:05.238]                         if (!is.null(pattern)) {
[16:13:05.238]                           computeRestarts <- base::computeRestarts
[16:13:05.238]                           grepl <- base::grepl
[16:13:05.238]                           restarts <- computeRestarts(cond)
[16:13:05.238]                           for (restart in restarts) {
[16:13:05.238]                             name <- restart$name
[16:13:05.238]                             if (is.null(name)) 
[16:13:05.238]                               next
[16:13:05.238]                             if (!grepl(pattern, name)) 
[16:13:05.238]                               next
[16:13:05.238]                             invokeRestart(restart)
[16:13:05.238]                             muffled <- TRUE
[16:13:05.238]                             break
[16:13:05.238]                           }
[16:13:05.238]                         }
[16:13:05.238]                       }
[16:13:05.238]                       invisible(muffled)
[16:13:05.238]                     }
[16:13:05.238]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.238]                   }
[16:13:05.238]                 }
[16:13:05.238]             }
[16:13:05.238]         }))
[16:13:05.238]     }, error = function(ex) {
[16:13:05.238]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.238]                 ...future.rng), started = ...future.startTime, 
[16:13:05.238]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.238]             version = "1.8"), class = "FutureResult")
[16:13:05.238]     }, finally = {
[16:13:05.238]         if (!identical(...future.workdir, getwd())) 
[16:13:05.238]             setwd(...future.workdir)
[16:13:05.238]         {
[16:13:05.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.238]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.238]             }
[16:13:05.238]             base::options(...future.oldOptions)
[16:13:05.238]             if (.Platform$OS.type == "windows") {
[16:13:05.238]                 old_names <- names(...future.oldEnvVars)
[16:13:05.238]                 envs <- base::Sys.getenv()
[16:13:05.238]                 names <- names(envs)
[16:13:05.238]                 common <- intersect(names, old_names)
[16:13:05.238]                 added <- setdiff(names, old_names)
[16:13:05.238]                 removed <- setdiff(old_names, names)
[16:13:05.238]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.238]                   envs[common]]
[16:13:05.238]                 NAMES <- toupper(changed)
[16:13:05.238]                 args <- list()
[16:13:05.238]                 for (kk in seq_along(NAMES)) {
[16:13:05.238]                   name <- changed[[kk]]
[16:13:05.238]                   NAME <- NAMES[[kk]]
[16:13:05.238]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.238]                     next
[16:13:05.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.238]                 }
[16:13:05.238]                 NAMES <- toupper(added)
[16:13:05.238]                 for (kk in seq_along(NAMES)) {
[16:13:05.238]                   name <- added[[kk]]
[16:13:05.238]                   NAME <- NAMES[[kk]]
[16:13:05.238]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.238]                     next
[16:13:05.238]                   args[[name]] <- ""
[16:13:05.238]                 }
[16:13:05.238]                 NAMES <- toupper(removed)
[16:13:05.238]                 for (kk in seq_along(NAMES)) {
[16:13:05.238]                   name <- removed[[kk]]
[16:13:05.238]                   NAME <- NAMES[[kk]]
[16:13:05.238]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.238]                     next
[16:13:05.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.238]                 }
[16:13:05.238]                 if (length(args) > 0) 
[16:13:05.238]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.238]             }
[16:13:05.238]             else {
[16:13:05.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.238]             }
[16:13:05.238]             {
[16:13:05.238]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.238]                   0L) {
[16:13:05.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.238]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.238]                   base::options(opts)
[16:13:05.238]                 }
[16:13:05.238]                 {
[16:13:05.238]                   {
[16:13:05.238]                     NULL
[16:13:05.238]                     RNGkind("Mersenne-Twister")
[16:13:05.238]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.238]                       inherits = FALSE)
[16:13:05.238]                   }
[16:13:05.238]                   options(future.plan = NULL)
[16:13:05.238]                   if (is.na(NA_character_)) 
[16:13:05.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.238]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.238]                   {
[16:13:05.238]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.238]                     if (!future$lazy) 
[16:13:05.238]                       future <- run(future)
[16:13:05.238]                     invisible(future)
[16:13:05.238]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.238]                 }
[16:13:05.238]             }
[16:13:05.238]         }
[16:13:05.238]     })
[16:13:05.238]     if (TRUE) {
[16:13:05.238]         base::sink(type = "output", split = FALSE)
[16:13:05.238]         if (TRUE) {
[16:13:05.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.238]         }
[16:13:05.238]         else {
[16:13:05.238]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.238]         }
[16:13:05.238]         base::close(...future.stdout)
[16:13:05.238]         ...future.stdout <- NULL
[16:13:05.238]     }
[16:13:05.238]     ...future.result$conditions <- ...future.conditions
[16:13:05.238]     ...future.result$finished <- base::Sys.time()
[16:13:05.238]     ...future.result
[16:13:05.238] }
[16:13:05.240] plan(): Setting new future strategy stack:
[16:13:05.240] List of future strategies:
[16:13:05.240] 1. sequential:
[16:13:05.240]    - args: function (..., envir = parent.frame())
[16:13:05.240]    - tweaked: FALSE
[16:13:05.240]    - call: NULL
[16:13:05.241] plan(): nbrOfWorkers() = 1
[16:13:05.241] plan(): Setting new future strategy stack:
[16:13:05.241] List of future strategies:
[16:13:05.241] 1. sequential:
[16:13:05.241]    - args: function (..., envir = parent.frame())
[16:13:05.241]    - tweaked: FALSE
[16:13:05.241]    - call: future::plan("sequential")
[16:13:05.242] plan(): nbrOfWorkers() = 1
[16:13:05.242] SequentialFuture started (and completed)
[16:13:05.242] - Launch lazy future ... done
[16:13:05.242] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[16:13:05.246] getGlobalsAndPackages() ...
[16:13:05.246] Searching for globals...
[16:13:05.247] - globals found: [2] ‘{’, ‘stop’
[16:13:05.247] Searching for globals ... DONE
[16:13:05.247] Resolving globals: FALSE
[16:13:05.248] 
[16:13:05.248] 
[16:13:05.248] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:05.249] Packages needed by the future expression (n = 0): <none>
[16:13:05.249] Packages needed by future strategies (n = 0): <none>
[16:13:05.249] {
[16:13:05.249]     {
[16:13:05.249]         {
[16:13:05.249]             ...future.startTime <- base::Sys.time()
[16:13:05.249]             {
[16:13:05.249]                 {
[16:13:05.249]                   {
[16:13:05.249]                     base::local({
[16:13:05.249]                       has_future <- base::requireNamespace("future", 
[16:13:05.249]                         quietly = TRUE)
[16:13:05.249]                       if (has_future) {
[16:13:05.249]                         ns <- base::getNamespace("future")
[16:13:05.249]                         version <- ns[[".package"]][["version"]]
[16:13:05.249]                         if (is.null(version)) 
[16:13:05.249]                           version <- utils::packageVersion("future")
[16:13:05.249]                       }
[16:13:05.249]                       else {
[16:13:05.249]                         version <- NULL
[16:13:05.249]                       }
[16:13:05.249]                       if (!has_future || version < "1.8.0") {
[16:13:05.249]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.249]                           "", base::R.version$version.string), 
[16:13:05.249]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.249]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.249]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.249]                             "release", "version")], collapse = " "), 
[16:13:05.249]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.249]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.249]                           info)
[16:13:05.249]                         info <- base::paste(info, collapse = "; ")
[16:13:05.249]                         if (!has_future) {
[16:13:05.249]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.249]                             info)
[16:13:05.249]                         }
[16:13:05.249]                         else {
[16:13:05.249]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.249]                             info, version)
[16:13:05.249]                         }
[16:13:05.249]                         base::stop(msg)
[16:13:05.249]                       }
[16:13:05.249]                     })
[16:13:05.249]                   }
[16:13:05.249]                   options(future.plan = NULL)
[16:13:05.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.249]                 }
[16:13:05.249]                 ...future.workdir <- getwd()
[16:13:05.249]             }
[16:13:05.249]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.249]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.249]         }
[16:13:05.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.249]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.249]             base::names(...future.oldOptions))
[16:13:05.249]     }
[16:13:05.249]     if (FALSE) {
[16:13:05.249]     }
[16:13:05.249]     else {
[16:13:05.249]         if (TRUE) {
[16:13:05.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.249]                 open = "w")
[16:13:05.249]         }
[16:13:05.249]         else {
[16:13:05.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.249]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.249]         }
[16:13:05.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.249]             base::sink(type = "output", split = FALSE)
[16:13:05.249]             base::close(...future.stdout)
[16:13:05.249]         }, add = TRUE)
[16:13:05.249]     }
[16:13:05.249]     ...future.frame <- base::sys.nframe()
[16:13:05.249]     ...future.conditions <- base::list()
[16:13:05.249]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.249]     if (FALSE) {
[16:13:05.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.249]     }
[16:13:05.249]     ...future.result <- base::tryCatch({
[16:13:05.249]         base::withCallingHandlers({
[16:13:05.249]             ...future.value <- base::withVisible(base::local({
[16:13:05.249]                 stop("Whoops!")
[16:13:05.249]                 1
[16:13:05.249]             }))
[16:13:05.249]             future::FutureResult(value = ...future.value$value, 
[16:13:05.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.249]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.249]                     ...future.globalenv.names))
[16:13:05.249]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.249]         }, condition = base::local({
[16:13:05.249]             c <- base::c
[16:13:05.249]             inherits <- base::inherits
[16:13:05.249]             invokeRestart <- base::invokeRestart
[16:13:05.249]             length <- base::length
[16:13:05.249]             list <- base::list
[16:13:05.249]             seq.int <- base::seq.int
[16:13:05.249]             signalCondition <- base::signalCondition
[16:13:05.249]             sys.calls <- base::sys.calls
[16:13:05.249]             `[[` <- base::`[[`
[16:13:05.249]             `+` <- base::`+`
[16:13:05.249]             `<<-` <- base::`<<-`
[16:13:05.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.249]                   3L)]
[16:13:05.249]             }
[16:13:05.249]             function(cond) {
[16:13:05.249]                 is_error <- inherits(cond, "error")
[16:13:05.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.249]                   NULL)
[16:13:05.249]                 if (is_error) {
[16:13:05.249]                   sessionInformation <- function() {
[16:13:05.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.249]                       search = base::search(), system = base::Sys.info())
[16:13:05.249]                   }
[16:13:05.249]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.249]                     cond$call), session = sessionInformation(), 
[16:13:05.249]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.249]                   signalCondition(cond)
[16:13:05.249]                 }
[16:13:05.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.249]                 "immediateCondition"))) {
[16:13:05.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.249]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.249]                   if (TRUE && !signal) {
[16:13:05.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.249]                     {
[16:13:05.249]                       inherits <- base::inherits
[16:13:05.249]                       invokeRestart <- base::invokeRestart
[16:13:05.249]                       is.null <- base::is.null
[16:13:05.249]                       muffled <- FALSE
[16:13:05.249]                       if (inherits(cond, "message")) {
[16:13:05.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.249]                         if (muffled) 
[16:13:05.249]                           invokeRestart("muffleMessage")
[16:13:05.249]                       }
[16:13:05.249]                       else if (inherits(cond, "warning")) {
[16:13:05.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.249]                         if (muffled) 
[16:13:05.249]                           invokeRestart("muffleWarning")
[16:13:05.249]                       }
[16:13:05.249]                       else if (inherits(cond, "condition")) {
[16:13:05.249]                         if (!is.null(pattern)) {
[16:13:05.249]                           computeRestarts <- base::computeRestarts
[16:13:05.249]                           grepl <- base::grepl
[16:13:05.249]                           restarts <- computeRestarts(cond)
[16:13:05.249]                           for (restart in restarts) {
[16:13:05.249]                             name <- restart$name
[16:13:05.249]                             if (is.null(name)) 
[16:13:05.249]                               next
[16:13:05.249]                             if (!grepl(pattern, name)) 
[16:13:05.249]                               next
[16:13:05.249]                             invokeRestart(restart)
[16:13:05.249]                             muffled <- TRUE
[16:13:05.249]                             break
[16:13:05.249]                           }
[16:13:05.249]                         }
[16:13:05.249]                       }
[16:13:05.249]                       invisible(muffled)
[16:13:05.249]                     }
[16:13:05.249]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.249]                   }
[16:13:05.249]                 }
[16:13:05.249]                 else {
[16:13:05.249]                   if (TRUE) {
[16:13:05.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.249]                     {
[16:13:05.249]                       inherits <- base::inherits
[16:13:05.249]                       invokeRestart <- base::invokeRestart
[16:13:05.249]                       is.null <- base::is.null
[16:13:05.249]                       muffled <- FALSE
[16:13:05.249]                       if (inherits(cond, "message")) {
[16:13:05.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.249]                         if (muffled) 
[16:13:05.249]                           invokeRestart("muffleMessage")
[16:13:05.249]                       }
[16:13:05.249]                       else if (inherits(cond, "warning")) {
[16:13:05.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.249]                         if (muffled) 
[16:13:05.249]                           invokeRestart("muffleWarning")
[16:13:05.249]                       }
[16:13:05.249]                       else if (inherits(cond, "condition")) {
[16:13:05.249]                         if (!is.null(pattern)) {
[16:13:05.249]                           computeRestarts <- base::computeRestarts
[16:13:05.249]                           grepl <- base::grepl
[16:13:05.249]                           restarts <- computeRestarts(cond)
[16:13:05.249]                           for (restart in restarts) {
[16:13:05.249]                             name <- restart$name
[16:13:05.249]                             if (is.null(name)) 
[16:13:05.249]                               next
[16:13:05.249]                             if (!grepl(pattern, name)) 
[16:13:05.249]                               next
[16:13:05.249]                             invokeRestart(restart)
[16:13:05.249]                             muffled <- TRUE
[16:13:05.249]                             break
[16:13:05.249]                           }
[16:13:05.249]                         }
[16:13:05.249]                       }
[16:13:05.249]                       invisible(muffled)
[16:13:05.249]                     }
[16:13:05.249]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.249]                   }
[16:13:05.249]                 }
[16:13:05.249]             }
[16:13:05.249]         }))
[16:13:05.249]     }, error = function(ex) {
[16:13:05.249]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.249]                 ...future.rng), started = ...future.startTime, 
[16:13:05.249]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.249]             version = "1.8"), class = "FutureResult")
[16:13:05.249]     }, finally = {
[16:13:05.249]         if (!identical(...future.workdir, getwd())) 
[16:13:05.249]             setwd(...future.workdir)
[16:13:05.249]         {
[16:13:05.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.249]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.249]             }
[16:13:05.249]             base::options(...future.oldOptions)
[16:13:05.249]             if (.Platform$OS.type == "windows") {
[16:13:05.249]                 old_names <- names(...future.oldEnvVars)
[16:13:05.249]                 envs <- base::Sys.getenv()
[16:13:05.249]                 names <- names(envs)
[16:13:05.249]                 common <- intersect(names, old_names)
[16:13:05.249]                 added <- setdiff(names, old_names)
[16:13:05.249]                 removed <- setdiff(old_names, names)
[16:13:05.249]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.249]                   envs[common]]
[16:13:05.249]                 NAMES <- toupper(changed)
[16:13:05.249]                 args <- list()
[16:13:05.249]                 for (kk in seq_along(NAMES)) {
[16:13:05.249]                   name <- changed[[kk]]
[16:13:05.249]                   NAME <- NAMES[[kk]]
[16:13:05.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.249]                     next
[16:13:05.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.249]                 }
[16:13:05.249]                 NAMES <- toupper(added)
[16:13:05.249]                 for (kk in seq_along(NAMES)) {
[16:13:05.249]                   name <- added[[kk]]
[16:13:05.249]                   NAME <- NAMES[[kk]]
[16:13:05.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.249]                     next
[16:13:05.249]                   args[[name]] <- ""
[16:13:05.249]                 }
[16:13:05.249]                 NAMES <- toupper(removed)
[16:13:05.249]                 for (kk in seq_along(NAMES)) {
[16:13:05.249]                   name <- removed[[kk]]
[16:13:05.249]                   NAME <- NAMES[[kk]]
[16:13:05.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.249]                     next
[16:13:05.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.249]                 }
[16:13:05.249]                 if (length(args) > 0) 
[16:13:05.249]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.249]             }
[16:13:05.249]             else {
[16:13:05.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.249]             }
[16:13:05.249]             {
[16:13:05.249]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.249]                   0L) {
[16:13:05.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.249]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.249]                   base::options(opts)
[16:13:05.249]                 }
[16:13:05.249]                 {
[16:13:05.249]                   {
[16:13:05.249]                     NULL
[16:13:05.249]                     RNGkind("Mersenne-Twister")
[16:13:05.249]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.249]                       inherits = FALSE)
[16:13:05.249]                   }
[16:13:05.249]                   options(future.plan = NULL)
[16:13:05.249]                   if (is.na(NA_character_)) 
[16:13:05.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.249]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.249]                   {
[16:13:05.249]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.249]                     if (!future$lazy) 
[16:13:05.249]                       future <- run(future)
[16:13:05.249]                     invisible(future)
[16:13:05.249]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.249]                 }
[16:13:05.249]             }
[16:13:05.249]         }
[16:13:05.249]     })
[16:13:05.249]     if (TRUE) {
[16:13:05.249]         base::sink(type = "output", split = FALSE)
[16:13:05.249]         if (TRUE) {
[16:13:05.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.249]         }
[16:13:05.249]         else {
[16:13:05.249]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.249]         }
[16:13:05.249]         base::close(...future.stdout)
[16:13:05.249]         ...future.stdout <- NULL
[16:13:05.249]     }
[16:13:05.249]     ...future.result$conditions <- ...future.conditions
[16:13:05.249]     ...future.result$finished <- base::Sys.time()
[16:13:05.249]     ...future.result
[16:13:05.249] }
[16:13:05.251] plan(): Setting new future strategy stack:
[16:13:05.251] List of future strategies:
[16:13:05.251] 1. sequential:
[16:13:05.251]    - args: function (..., envir = parent.frame())
[16:13:05.251]    - tweaked: FALSE
[16:13:05.251]    - call: NULL
[16:13:05.251] plan(): nbrOfWorkers() = 1
[16:13:05.252] plan(): Setting new future strategy stack:
[16:13:05.252] List of future strategies:
[16:13:05.252] 1. sequential:
[16:13:05.252]    - args: function (..., envir = parent.frame())
[16:13:05.252]    - tweaked: FALSE
[16:13:05.252]    - call: future::plan("sequential")
[16:13:05.253] plan(): nbrOfWorkers() = 1
[16:13:05.253] SequentialFuture started (and completed)
[16:13:05.253] signalConditions() ...
[16:13:05.253]  - include = ‘immediateCondition’
[16:13:05.253]  - exclude = 
[16:13:05.253]  - resignal = FALSE
[16:13:05.253]  - Number of conditions: 1
[16:13:05.253] signalConditions() ... done
[16:13:05.253] signalConditions() ...
[16:13:05.253]  - include = ‘immediateCondition’
[16:13:05.254]  - exclude = 
[16:13:05.254]  - resignal = FALSE
[16:13:05.254]  - Number of conditions: 1
[16:13:05.254] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:05.254] signalConditions() ...
[16:13:05.254]  - include = ‘immediateCondition’
[16:13:05.254]  - exclude = 
[16:13:05.254]  - resignal = FALSE
[16:13:05.255]  - Number of conditions: 1
[16:13:05.255] signalConditions() ... done
[16:13:05.255] Future state: ‘finished’
[16:13:05.255] signalConditions() ...
[16:13:05.255]  - include = ‘condition’
[16:13:05.255]  - exclude = ‘immediateCondition’
[16:13:05.255]  - resignal = TRUE
[16:13:05.255]  - Number of conditions: 1
[16:13:05.255]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:05.255] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:05.256] signalConditions() ...
[16:13:05.256]  - include = ‘immediateCondition’
[16:13:05.256]  - exclude = 
[16:13:05.256]  - resignal = FALSE
[16:13:05.256]  - Number of conditions: 1
[16:13:05.256] signalConditions() ... done
[16:13:05.256] Future state: ‘finished’
[16:13:05.256] signalConditions() ...
[16:13:05.257]  - include = ‘condition’
[16:13:05.257]  - exclude = ‘immediateCondition’
[16:13:05.257]  - resignal = TRUE
[16:13:05.257]  - Number of conditions: 1
[16:13:05.257]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:05.257] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:13:05.260] getGlobalsAndPackages() ...
[16:13:05.260] Searching for globals...
[16:13:05.263] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[16:13:05.263] Searching for globals ... DONE
[16:13:05.263] Resolving globals: FALSE
[16:13:05.263] 
[16:13:05.264] 
[16:13:05.264] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:05.264] Packages needed by the future expression (n = 0): <none>
[16:13:05.264] Packages needed by future strategies (n = 0): <none>
[16:13:05.265] {
[16:13:05.265]     {
[16:13:05.265]         {
[16:13:05.265]             ...future.startTime <- base::Sys.time()
[16:13:05.265]             {
[16:13:05.265]                 {
[16:13:05.265]                   {
[16:13:05.265]                     base::local({
[16:13:05.265]                       has_future <- base::requireNamespace("future", 
[16:13:05.265]                         quietly = TRUE)
[16:13:05.265]                       if (has_future) {
[16:13:05.265]                         ns <- base::getNamespace("future")
[16:13:05.265]                         version <- ns[[".package"]][["version"]]
[16:13:05.265]                         if (is.null(version)) 
[16:13:05.265]                           version <- utils::packageVersion("future")
[16:13:05.265]                       }
[16:13:05.265]                       else {
[16:13:05.265]                         version <- NULL
[16:13:05.265]                       }
[16:13:05.265]                       if (!has_future || version < "1.8.0") {
[16:13:05.265]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.265]                           "", base::R.version$version.string), 
[16:13:05.265]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:05.265]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.265]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.265]                             "release", "version")], collapse = " "), 
[16:13:05.265]                           hostname = base::Sys.info()[["nodename"]])
[16:13:05.265]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.265]                           info)
[16:13:05.265]                         info <- base::paste(info, collapse = "; ")
[16:13:05.265]                         if (!has_future) {
[16:13:05.265]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.265]                             info)
[16:13:05.265]                         }
[16:13:05.265]                         else {
[16:13:05.265]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.265]                             info, version)
[16:13:05.265]                         }
[16:13:05.265]                         base::stop(msg)
[16:13:05.265]                       }
[16:13:05.265]                     })
[16:13:05.265]                   }
[16:13:05.265]                   options(future.plan = NULL)
[16:13:05.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.265]                 }
[16:13:05.265]                 ...future.workdir <- getwd()
[16:13:05.265]             }
[16:13:05.265]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.265]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.265]         }
[16:13:05.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.265]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.265]             base::names(...future.oldOptions))
[16:13:05.265]     }
[16:13:05.265]     if (FALSE) {
[16:13:05.265]     }
[16:13:05.265]     else {
[16:13:05.265]         if (TRUE) {
[16:13:05.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.265]                 open = "w")
[16:13:05.265]         }
[16:13:05.265]         else {
[16:13:05.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.265]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.265]         }
[16:13:05.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.265]             base::sink(type = "output", split = FALSE)
[16:13:05.265]             base::close(...future.stdout)
[16:13:05.265]         }, add = TRUE)
[16:13:05.265]     }
[16:13:05.265]     ...future.frame <- base::sys.nframe()
[16:13:05.265]     ...future.conditions <- base::list()
[16:13:05.265]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.265]     if (FALSE) {
[16:13:05.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.265]     }
[16:13:05.265]     ...future.result <- base::tryCatch({
[16:13:05.265]         base::withCallingHandlers({
[16:13:05.265]             ...future.value <- base::withVisible(base::local({
[16:13:05.265]                 stop(structure(list(message = "boom"), class = c("MyError", 
[16:13:05.265]                   "error", "condition")))
[16:13:05.265]             }))
[16:13:05.265]             future::FutureResult(value = ...future.value$value, 
[16:13:05.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.265]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.265]                     ...future.globalenv.names))
[16:13:05.265]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.265]         }, condition = base::local({
[16:13:05.265]             c <- base::c
[16:13:05.265]             inherits <- base::inherits
[16:13:05.265]             invokeRestart <- base::invokeRestart
[16:13:05.265]             length <- base::length
[16:13:05.265]             list <- base::list
[16:13:05.265]             seq.int <- base::seq.int
[16:13:05.265]             signalCondition <- base::signalCondition
[16:13:05.265]             sys.calls <- base::sys.calls
[16:13:05.265]             `[[` <- base::`[[`
[16:13:05.265]             `+` <- base::`+`
[16:13:05.265]             `<<-` <- base::`<<-`
[16:13:05.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.265]                   3L)]
[16:13:05.265]             }
[16:13:05.265]             function(cond) {
[16:13:05.265]                 is_error <- inherits(cond, "error")
[16:13:05.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.265]                   NULL)
[16:13:05.265]                 if (is_error) {
[16:13:05.265]                   sessionInformation <- function() {
[16:13:05.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.265]                       search = base::search(), system = base::Sys.info())
[16:13:05.265]                   }
[16:13:05.265]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.265]                     cond$call), session = sessionInformation(), 
[16:13:05.265]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.265]                   signalCondition(cond)
[16:13:05.265]                 }
[16:13:05.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.265]                 "immediateCondition"))) {
[16:13:05.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.265]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.265]                   if (TRUE && !signal) {
[16:13:05.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.265]                     {
[16:13:05.265]                       inherits <- base::inherits
[16:13:05.265]                       invokeRestart <- base::invokeRestart
[16:13:05.265]                       is.null <- base::is.null
[16:13:05.265]                       muffled <- FALSE
[16:13:05.265]                       if (inherits(cond, "message")) {
[16:13:05.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.265]                         if (muffled) 
[16:13:05.265]                           invokeRestart("muffleMessage")
[16:13:05.265]                       }
[16:13:05.265]                       else if (inherits(cond, "warning")) {
[16:13:05.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.265]                         if (muffled) 
[16:13:05.265]                           invokeRestart("muffleWarning")
[16:13:05.265]                       }
[16:13:05.265]                       else if (inherits(cond, "condition")) {
[16:13:05.265]                         if (!is.null(pattern)) {
[16:13:05.265]                           computeRestarts <- base::computeRestarts
[16:13:05.265]                           grepl <- base::grepl
[16:13:05.265]                           restarts <- computeRestarts(cond)
[16:13:05.265]                           for (restart in restarts) {
[16:13:05.265]                             name <- restart$name
[16:13:05.265]                             if (is.null(name)) 
[16:13:05.265]                               next
[16:13:05.265]                             if (!grepl(pattern, name)) 
[16:13:05.265]                               next
[16:13:05.265]                             invokeRestart(restart)
[16:13:05.265]                             muffled <- TRUE
[16:13:05.265]                             break
[16:13:05.265]                           }
[16:13:05.265]                         }
[16:13:05.265]                       }
[16:13:05.265]                       invisible(muffled)
[16:13:05.265]                     }
[16:13:05.265]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.265]                   }
[16:13:05.265]                 }
[16:13:05.265]                 else {
[16:13:05.265]                   if (TRUE) {
[16:13:05.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.265]                     {
[16:13:05.265]                       inherits <- base::inherits
[16:13:05.265]                       invokeRestart <- base::invokeRestart
[16:13:05.265]                       is.null <- base::is.null
[16:13:05.265]                       muffled <- FALSE
[16:13:05.265]                       if (inherits(cond, "message")) {
[16:13:05.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.265]                         if (muffled) 
[16:13:05.265]                           invokeRestart("muffleMessage")
[16:13:05.265]                       }
[16:13:05.265]                       else if (inherits(cond, "warning")) {
[16:13:05.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.265]                         if (muffled) 
[16:13:05.265]                           invokeRestart("muffleWarning")
[16:13:05.265]                       }
[16:13:05.265]                       else if (inherits(cond, "condition")) {
[16:13:05.265]                         if (!is.null(pattern)) {
[16:13:05.265]                           computeRestarts <- base::computeRestarts
[16:13:05.265]                           grepl <- base::grepl
[16:13:05.265]                           restarts <- computeRestarts(cond)
[16:13:05.265]                           for (restart in restarts) {
[16:13:05.265]                             name <- restart$name
[16:13:05.265]                             if (is.null(name)) 
[16:13:05.265]                               next
[16:13:05.265]                             if (!grepl(pattern, name)) 
[16:13:05.265]                               next
[16:13:05.265]                             invokeRestart(restart)
[16:13:05.265]                             muffled <- TRUE
[16:13:05.265]                             break
[16:13:05.265]                           }
[16:13:05.265]                         }
[16:13:05.265]                       }
[16:13:05.265]                       invisible(muffled)
[16:13:05.265]                     }
[16:13:05.265]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.265]                   }
[16:13:05.265]                 }
[16:13:05.265]             }
[16:13:05.265]         }))
[16:13:05.265]     }, error = function(ex) {
[16:13:05.265]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.265]                 ...future.rng), started = ...future.startTime, 
[16:13:05.265]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.265]             version = "1.8"), class = "FutureResult")
[16:13:05.265]     }, finally = {
[16:13:05.265]         if (!identical(...future.workdir, getwd())) 
[16:13:05.265]             setwd(...future.workdir)
[16:13:05.265]         {
[16:13:05.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.265]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.265]             }
[16:13:05.265]             base::options(...future.oldOptions)
[16:13:05.265]             if (.Platform$OS.type == "windows") {
[16:13:05.265]                 old_names <- names(...future.oldEnvVars)
[16:13:05.265]                 envs <- base::Sys.getenv()
[16:13:05.265]                 names <- names(envs)
[16:13:05.265]                 common <- intersect(names, old_names)
[16:13:05.265]                 added <- setdiff(names, old_names)
[16:13:05.265]                 removed <- setdiff(old_names, names)
[16:13:05.265]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.265]                   envs[common]]
[16:13:05.265]                 NAMES <- toupper(changed)
[16:13:05.265]                 args <- list()
[16:13:05.265]                 for (kk in seq_along(NAMES)) {
[16:13:05.265]                   name <- changed[[kk]]
[16:13:05.265]                   NAME <- NAMES[[kk]]
[16:13:05.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.265]                     next
[16:13:05.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.265]                 }
[16:13:05.265]                 NAMES <- toupper(added)
[16:13:05.265]                 for (kk in seq_along(NAMES)) {
[16:13:05.265]                   name <- added[[kk]]
[16:13:05.265]                   NAME <- NAMES[[kk]]
[16:13:05.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.265]                     next
[16:13:05.265]                   args[[name]] <- ""
[16:13:05.265]                 }
[16:13:05.265]                 NAMES <- toupper(removed)
[16:13:05.265]                 for (kk in seq_along(NAMES)) {
[16:13:05.265]                   name <- removed[[kk]]
[16:13:05.265]                   NAME <- NAMES[[kk]]
[16:13:05.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.265]                     next
[16:13:05.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.265]                 }
[16:13:05.265]                 if (length(args) > 0) 
[16:13:05.265]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.265]             }
[16:13:05.265]             else {
[16:13:05.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.265]             }
[16:13:05.265]             {
[16:13:05.265]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.265]                   0L) {
[16:13:05.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.265]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.265]                   base::options(opts)
[16:13:05.265]                 }
[16:13:05.265]                 {
[16:13:05.265]                   {
[16:13:05.265]                     NULL
[16:13:05.265]                     RNGkind("Mersenne-Twister")
[16:13:05.265]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:05.265]                       inherits = FALSE)
[16:13:05.265]                   }
[16:13:05.265]                   options(future.plan = NULL)
[16:13:05.265]                   if (is.na(NA_character_)) 
[16:13:05.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.265]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.265]                   {
[16:13:05.265]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.265]                     if (!future$lazy) 
[16:13:05.265]                       future <- run(future)
[16:13:05.265]                     invisible(future)
[16:13:05.265]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.265]                 }
[16:13:05.265]             }
[16:13:05.265]         }
[16:13:05.265]     })
[16:13:05.265]     if (TRUE) {
[16:13:05.265]         base::sink(type = "output", split = FALSE)
[16:13:05.265]         if (TRUE) {
[16:13:05.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.265]         }
[16:13:05.265]         else {
[16:13:05.265]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.265]         }
[16:13:05.265]         base::close(...future.stdout)
[16:13:05.265]         ...future.stdout <- NULL
[16:13:05.265]     }
[16:13:05.265]     ...future.result$conditions <- ...future.conditions
[16:13:05.265]     ...future.result$finished <- base::Sys.time()
[16:13:05.265]     ...future.result
[16:13:05.265] }
[16:13:05.267] plan(): Setting new future strategy stack:
[16:13:05.267] List of future strategies:
[16:13:05.267] 1. sequential:
[16:13:05.267]    - args: function (..., envir = parent.frame())
[16:13:05.267]    - tweaked: FALSE
[16:13:05.267]    - call: NULL
[16:13:05.267] plan(): nbrOfWorkers() = 1
[16:13:05.268] plan(): Setting new future strategy stack:
[16:13:05.268] List of future strategies:
[16:13:05.268] 1. sequential:
[16:13:05.268]    - args: function (..., envir = parent.frame())
[16:13:05.268]    - tweaked: FALSE
[16:13:05.268]    - call: future::plan("sequential")
[16:13:05.268] plan(): nbrOfWorkers() = 1
[16:13:05.269] SequentialFuture started (and completed)
[16:13:05.269] signalConditions() ...
[16:13:05.269]  - include = ‘immediateCondition’
[16:13:05.269]  - exclude = 
[16:13:05.269]  - resignal = FALSE
[16:13:05.269]  - Number of conditions: 1
[16:13:05.269] signalConditions() ... done
[16:13:05.269] signalConditions() ...
[16:13:05.269]  - include = ‘immediateCondition’
[16:13:05.269]  - exclude = 
[16:13:05.269]  - resignal = FALSE
[16:13:05.270]  - Number of conditions: 1
[16:13:05.270] signalConditions() ... done
<MyError: boom>
[16:13:05.270] signalConditions() ...
[16:13:05.270]  - include = ‘immediateCondition’
[16:13:05.270]  - exclude = 
[16:13:05.270]  - resignal = FALSE
[16:13:05.270]  - Number of conditions: 1
[16:13:05.270] signalConditions() ... done
[16:13:05.270] Future state: ‘finished’
[16:13:05.271] signalConditions() ...
[16:13:05.271]  - include = ‘condition’
[16:13:05.271]  - exclude = ‘immediateCondition’
[16:13:05.271]  - resignal = TRUE
[16:13:05.271]  - Number of conditions: 1
[16:13:05.271]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:13:05.271] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[16:13:05.276] getGlobalsAndPackages() ...
[16:13:05.276] 
[16:13:05.277] - globals: [0] <none>
[16:13:05.277] getGlobalsAndPackages() ... DONE
[16:13:05.277] [local output] makeClusterPSOCK() ...
[16:13:05.306] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:05.311] [local output] Base port: 11210
[16:13:05.311] [local output] Getting setup options for 2 cluster nodes ...
[16:13:05.312] [local output]  - Node 1 of 2 ...
[16:13:05.312] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:05.313] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.1548134ec961b.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.1548134ec961b.pid")'’
[16:13:05.500] - Possible to infer worker's PID: TRUE
[16:13:05.500] [local output] Rscript port: 11210

[16:13:05.500] [local output]  - Node 2 of 2 ...
[16:13:05.501] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:05.501] [local output] Rscript port: 11210

[16:13:05.502] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:05.502] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:05.502] [local output] Setting up PSOCK nodes in parallel
[16:13:05.502] List of 36
[16:13:05.502]  $ worker          : chr "localhost"
[16:13:05.502]   ..- attr(*, "localhost")= logi TRUE
[16:13:05.502]  $ master          : chr "localhost"
[16:13:05.502]  $ port            : int 11210
[16:13:05.502]  $ connectTimeout  : num 120
[16:13:05.502]  $ timeout         : num 2592000
[16:13:05.502]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:05.502]  $ homogeneous     : logi TRUE
[16:13:05.502]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:05.502]  $ rscript_envs    : NULL
[16:13:05.502]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:05.502]  $ rscript_startup : NULL
[16:13:05.502]  $ rscript_sh      : chr "sh"
[16:13:05.502]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:05.502]  $ methods         : logi TRUE
[16:13:05.502]  $ socketOptions   : chr "no-delay"
[16:13:05.502]  $ useXDR          : logi FALSE
[16:13:05.502]  $ outfile         : chr "/dev/null"
[16:13:05.502]  $ renice          : int NA
[16:13:05.502]  $ rshcmd          : NULL
[16:13:05.502]  $ user            : chr(0) 
[16:13:05.502]  $ revtunnel       : logi FALSE
[16:13:05.502]  $ rshlogfile      : NULL
[16:13:05.502]  $ rshopts         : chr(0) 
[16:13:05.502]  $ rank            : int 1
[16:13:05.502]  $ manual          : logi FALSE
[16:13:05.502]  $ dryrun          : logi FALSE
[16:13:05.502]  $ quiet           : logi FALSE
[16:13:05.502]  $ setup_strategy  : chr "parallel"
[16:13:05.502]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:05.502]  $ pidfile         : chr "/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.1548134ec961b.pid"
[16:13:05.502]  $ rshcmd_label    : NULL
[16:13:05.502]  $ rsh_call        : NULL
[16:13:05.502]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:05.502]  $ localMachine    : logi TRUE
[16:13:05.502]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:05.502]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:05.502]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:05.502]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:05.502]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:05.502]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:05.502]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:05.502]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:05.502]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:05.502]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:05.502]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:05.502]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:05.502]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:05.502]  $ arguments       :List of 28
[16:13:05.502]   ..$ worker          : chr "localhost"
[16:13:05.502]   ..$ master          : NULL
[16:13:05.502]   ..$ port            : int 11210
[16:13:05.502]   ..$ connectTimeout  : num 120
[16:13:05.502]   ..$ timeout         : num 2592000
[16:13:05.502]   ..$ rscript         : NULL
[16:13:05.502]   ..$ homogeneous     : NULL
[16:13:05.502]   ..$ rscript_args    : NULL
[16:13:05.502]   ..$ rscript_envs    : NULL
[16:13:05.502]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:05.502]   ..$ rscript_startup : NULL
[16:13:05.502]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:05.502]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:05.502]   ..$ methods         : logi TRUE
[16:13:05.502]   ..$ socketOptions   : chr "no-delay"
[16:13:05.502]   ..$ useXDR          : logi FALSE
[16:13:05.502]   ..$ outfile         : chr "/dev/null"
[16:13:05.502]   ..$ renice          : int NA
[16:13:05.502]   ..$ rshcmd          : NULL
[16:13:05.502]   ..$ user            : NULL
[16:13:05.502]   ..$ revtunnel       : logi NA
[16:13:05.502]   ..$ rshlogfile      : NULL
[16:13:05.502]   ..$ rshopts         : NULL
[16:13:05.502]   ..$ rank            : int 1
[16:13:05.502]   ..$ manual          : logi FALSE
[16:13:05.502]   ..$ dryrun          : logi FALSE
[16:13:05.502]   ..$ quiet           : logi FALSE
[16:13:05.502]   ..$ setup_strategy  : chr "parallel"
[16:13:05.502]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:05.519] [local output] System call to launch all workers:
[16:13:05.519] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.1548134ec961b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11210 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:05.519] [local output] Starting PSOCK main server
[16:13:05.521] [local output] Workers launched
[16:13:05.521] [local output] Waiting for workers to connect back
[16:13:05.521]  - [local output] 0 workers out of 2 ready
[16:13:05.765]  - [local output] 0 workers out of 2 ready
[16:13:05.765]  - [local output] 1 workers out of 2 ready
[16:13:05.765]  - [local output] 2 workers out of 2 ready
[16:13:05.766] [local output] Launching of workers completed
[16:13:05.766] [local output] Collecting session information from workers
[16:13:05.767] [local output]  - Worker #1 of 2
[16:13:05.767] [local output]  - Worker #2 of 2
[16:13:05.767] [local output] makeClusterPSOCK() ... done
[16:13:05.780] Packages needed by the future expression (n = 0): <none>
[16:13:05.780] Packages needed by future strategies (n = 0): <none>
[16:13:05.780] {
[16:13:05.780]     {
[16:13:05.780]         {
[16:13:05.780]             ...future.startTime <- base::Sys.time()
[16:13:05.780]             {
[16:13:05.780]                 {
[16:13:05.780]                   {
[16:13:05.780]                     {
[16:13:05.780]                       base::local({
[16:13:05.780]                         has_future <- base::requireNamespace("future", 
[16:13:05.780]                           quietly = TRUE)
[16:13:05.780]                         if (has_future) {
[16:13:05.780]                           ns <- base::getNamespace("future")
[16:13:05.780]                           version <- ns[[".package"]][["version"]]
[16:13:05.780]                           if (is.null(version)) 
[16:13:05.780]                             version <- utils::packageVersion("future")
[16:13:05.780]                         }
[16:13:05.780]                         else {
[16:13:05.780]                           version <- NULL
[16:13:05.780]                         }
[16:13:05.780]                         if (!has_future || version < "1.8.0") {
[16:13:05.780]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.780]                             "", base::R.version$version.string), 
[16:13:05.780]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:05.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.780]                               "release", "version")], collapse = " "), 
[16:13:05.780]                             hostname = base::Sys.info()[["nodename"]])
[16:13:05.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.780]                             info)
[16:13:05.780]                           info <- base::paste(info, collapse = "; ")
[16:13:05.780]                           if (!has_future) {
[16:13:05.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.780]                               info)
[16:13:05.780]                           }
[16:13:05.780]                           else {
[16:13:05.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.780]                               info, version)
[16:13:05.780]                           }
[16:13:05.780]                           base::stop(msg)
[16:13:05.780]                         }
[16:13:05.780]                       })
[16:13:05.780]                     }
[16:13:05.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:05.780]                     base::options(mc.cores = 1L)
[16:13:05.780]                   }
[16:13:05.780]                   options(future.plan = NULL)
[16:13:05.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.780]                 }
[16:13:05.780]                 ...future.workdir <- getwd()
[16:13:05.780]             }
[16:13:05.780]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.780]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.780]         }
[16:13:05.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.780]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.780]             base::names(...future.oldOptions))
[16:13:05.780]     }
[16:13:05.780]     if (FALSE) {
[16:13:05.780]     }
[16:13:05.780]     else {
[16:13:05.780]         if (TRUE) {
[16:13:05.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.780]                 open = "w")
[16:13:05.780]         }
[16:13:05.780]         else {
[16:13:05.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.780]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.780]         }
[16:13:05.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.780]             base::sink(type = "output", split = FALSE)
[16:13:05.780]             base::close(...future.stdout)
[16:13:05.780]         }, add = TRUE)
[16:13:05.780]     }
[16:13:05.780]     ...future.frame <- base::sys.nframe()
[16:13:05.780]     ...future.conditions <- base::list()
[16:13:05.780]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.780]     if (FALSE) {
[16:13:05.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.780]     }
[16:13:05.780]     ...future.result <- base::tryCatch({
[16:13:05.780]         base::withCallingHandlers({
[16:13:05.780]             ...future.value <- base::withVisible(base::local({
[16:13:05.780]                 ...future.makeSendCondition <- local({
[16:13:05.780]                   sendCondition <- NULL
[16:13:05.780]                   function(frame = 1L) {
[16:13:05.780]                     if (is.function(sendCondition)) 
[16:13:05.780]                       return(sendCondition)
[16:13:05.780]                     ns <- getNamespace("parallel")
[16:13:05.780]                     if (exists("sendData", mode = "function", 
[16:13:05.780]                       envir = ns)) {
[16:13:05.780]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:05.780]                         envir = ns)
[16:13:05.780]                       envir <- sys.frame(frame)
[16:13:05.780]                       master <- NULL
[16:13:05.780]                       while (!identical(envir, .GlobalEnv) && 
[16:13:05.780]                         !identical(envir, emptyenv())) {
[16:13:05.780]                         if (exists("master", mode = "list", envir = envir, 
[16:13:05.780]                           inherits = FALSE)) {
[16:13:05.780]                           master <- get("master", mode = "list", 
[16:13:05.780]                             envir = envir, inherits = FALSE)
[16:13:05.780]                           if (inherits(master, c("SOCKnode", 
[16:13:05.780]                             "SOCK0node"))) {
[16:13:05.780]                             sendCondition <<- function(cond) {
[16:13:05.780]                               data <- list(type = "VALUE", value = cond, 
[16:13:05.780]                                 success = TRUE)
[16:13:05.780]                               parallel_sendData(master, data)
[16:13:05.780]                             }
[16:13:05.780]                             return(sendCondition)
[16:13:05.780]                           }
[16:13:05.780]                         }
[16:13:05.780]                         frame <- frame + 1L
[16:13:05.780]                         envir <- sys.frame(frame)
[16:13:05.780]                       }
[16:13:05.780]                     }
[16:13:05.780]                     sendCondition <<- function(cond) NULL
[16:13:05.780]                   }
[16:13:05.780]                 })
[16:13:05.780]                 withCallingHandlers({
[16:13:05.780]                   {
[16:13:05.780]                     42L
[16:13:05.780]                   }
[16:13:05.780]                 }, immediateCondition = function(cond) {
[16:13:05.780]                   sendCondition <- ...future.makeSendCondition()
[16:13:05.780]                   sendCondition(cond)
[16:13:05.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.780]                   {
[16:13:05.780]                     inherits <- base::inherits
[16:13:05.780]                     invokeRestart <- base::invokeRestart
[16:13:05.780]                     is.null <- base::is.null
[16:13:05.780]                     muffled <- FALSE
[16:13:05.780]                     if (inherits(cond, "message")) {
[16:13:05.780]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:05.780]                       if (muffled) 
[16:13:05.780]                         invokeRestart("muffleMessage")
[16:13:05.780]                     }
[16:13:05.780]                     else if (inherits(cond, "warning")) {
[16:13:05.780]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:05.780]                       if (muffled) 
[16:13:05.780]                         invokeRestart("muffleWarning")
[16:13:05.780]                     }
[16:13:05.780]                     else if (inherits(cond, "condition")) {
[16:13:05.780]                       if (!is.null(pattern)) {
[16:13:05.780]                         computeRestarts <- base::computeRestarts
[16:13:05.780]                         grepl <- base::grepl
[16:13:05.780]                         restarts <- computeRestarts(cond)
[16:13:05.780]                         for (restart in restarts) {
[16:13:05.780]                           name <- restart$name
[16:13:05.780]                           if (is.null(name)) 
[16:13:05.780]                             next
[16:13:05.780]                           if (!grepl(pattern, name)) 
[16:13:05.780]                             next
[16:13:05.780]                           invokeRestart(restart)
[16:13:05.780]                           muffled <- TRUE
[16:13:05.780]                           break
[16:13:05.780]                         }
[16:13:05.780]                       }
[16:13:05.780]                     }
[16:13:05.780]                     invisible(muffled)
[16:13:05.780]                   }
[16:13:05.780]                   muffleCondition(cond)
[16:13:05.780]                 })
[16:13:05.780]             }))
[16:13:05.780]             future::FutureResult(value = ...future.value$value, 
[16:13:05.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.780]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.780]                     ...future.globalenv.names))
[16:13:05.780]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.780]         }, condition = base::local({
[16:13:05.780]             c <- base::c
[16:13:05.780]             inherits <- base::inherits
[16:13:05.780]             invokeRestart <- base::invokeRestart
[16:13:05.780]             length <- base::length
[16:13:05.780]             list <- base::list
[16:13:05.780]             seq.int <- base::seq.int
[16:13:05.780]             signalCondition <- base::signalCondition
[16:13:05.780]             sys.calls <- base::sys.calls
[16:13:05.780]             `[[` <- base::`[[`
[16:13:05.780]             `+` <- base::`+`
[16:13:05.780]             `<<-` <- base::`<<-`
[16:13:05.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.780]                   3L)]
[16:13:05.780]             }
[16:13:05.780]             function(cond) {
[16:13:05.780]                 is_error <- inherits(cond, "error")
[16:13:05.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.780]                   NULL)
[16:13:05.780]                 if (is_error) {
[16:13:05.780]                   sessionInformation <- function() {
[16:13:05.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.780]                       search = base::search(), system = base::Sys.info())
[16:13:05.780]                   }
[16:13:05.780]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.780]                     cond$call), session = sessionInformation(), 
[16:13:05.780]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.780]                   signalCondition(cond)
[16:13:05.780]                 }
[16:13:05.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.780]                 "immediateCondition"))) {
[16:13:05.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.780]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.780]                   if (TRUE && !signal) {
[16:13:05.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.780]                     {
[16:13:05.780]                       inherits <- base::inherits
[16:13:05.780]                       invokeRestart <- base::invokeRestart
[16:13:05.780]                       is.null <- base::is.null
[16:13:05.780]                       muffled <- FALSE
[16:13:05.780]                       if (inherits(cond, "message")) {
[16:13:05.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.780]                         if (muffled) 
[16:13:05.780]                           invokeRestart("muffleMessage")
[16:13:05.780]                       }
[16:13:05.780]                       else if (inherits(cond, "warning")) {
[16:13:05.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.780]                         if (muffled) 
[16:13:05.780]                           invokeRestart("muffleWarning")
[16:13:05.780]                       }
[16:13:05.780]                       else if (inherits(cond, "condition")) {
[16:13:05.780]                         if (!is.null(pattern)) {
[16:13:05.780]                           computeRestarts <- base::computeRestarts
[16:13:05.780]                           grepl <- base::grepl
[16:13:05.780]                           restarts <- computeRestarts(cond)
[16:13:05.780]                           for (restart in restarts) {
[16:13:05.780]                             name <- restart$name
[16:13:05.780]                             if (is.null(name)) 
[16:13:05.780]                               next
[16:13:05.780]                             if (!grepl(pattern, name)) 
[16:13:05.780]                               next
[16:13:05.780]                             invokeRestart(restart)
[16:13:05.780]                             muffled <- TRUE
[16:13:05.780]                             break
[16:13:05.780]                           }
[16:13:05.780]                         }
[16:13:05.780]                       }
[16:13:05.780]                       invisible(muffled)
[16:13:05.780]                     }
[16:13:05.780]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.780]                   }
[16:13:05.780]                 }
[16:13:05.780]                 else {
[16:13:05.780]                   if (TRUE) {
[16:13:05.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.780]                     {
[16:13:05.780]                       inherits <- base::inherits
[16:13:05.780]                       invokeRestart <- base::invokeRestart
[16:13:05.780]                       is.null <- base::is.null
[16:13:05.780]                       muffled <- FALSE
[16:13:05.780]                       if (inherits(cond, "message")) {
[16:13:05.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.780]                         if (muffled) 
[16:13:05.780]                           invokeRestart("muffleMessage")
[16:13:05.780]                       }
[16:13:05.780]                       else if (inherits(cond, "warning")) {
[16:13:05.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.780]                         if (muffled) 
[16:13:05.780]                           invokeRestart("muffleWarning")
[16:13:05.780]                       }
[16:13:05.780]                       else if (inherits(cond, "condition")) {
[16:13:05.780]                         if (!is.null(pattern)) {
[16:13:05.780]                           computeRestarts <- base::computeRestarts
[16:13:05.780]                           grepl <- base::grepl
[16:13:05.780]                           restarts <- computeRestarts(cond)
[16:13:05.780]                           for (restart in restarts) {
[16:13:05.780]                             name <- restart$name
[16:13:05.780]                             if (is.null(name)) 
[16:13:05.780]                               next
[16:13:05.780]                             if (!grepl(pattern, name)) 
[16:13:05.780]                               next
[16:13:05.780]                             invokeRestart(restart)
[16:13:05.780]                             muffled <- TRUE
[16:13:05.780]                             break
[16:13:05.780]                           }
[16:13:05.780]                         }
[16:13:05.780]                       }
[16:13:05.780]                       invisible(muffled)
[16:13:05.780]                     }
[16:13:05.780]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.780]                   }
[16:13:05.780]                 }
[16:13:05.780]             }
[16:13:05.780]         }))
[16:13:05.780]     }, error = function(ex) {
[16:13:05.780]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.780]                 ...future.rng), started = ...future.startTime, 
[16:13:05.780]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.780]             version = "1.8"), class = "FutureResult")
[16:13:05.780]     }, finally = {
[16:13:05.780]         if (!identical(...future.workdir, getwd())) 
[16:13:05.780]             setwd(...future.workdir)
[16:13:05.780]         {
[16:13:05.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.780]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.780]             }
[16:13:05.780]             base::options(...future.oldOptions)
[16:13:05.780]             if (.Platform$OS.type == "windows") {
[16:13:05.780]                 old_names <- names(...future.oldEnvVars)
[16:13:05.780]                 envs <- base::Sys.getenv()
[16:13:05.780]                 names <- names(envs)
[16:13:05.780]                 common <- intersect(names, old_names)
[16:13:05.780]                 added <- setdiff(names, old_names)
[16:13:05.780]                 removed <- setdiff(old_names, names)
[16:13:05.780]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.780]                   envs[common]]
[16:13:05.780]                 NAMES <- toupper(changed)
[16:13:05.780]                 args <- list()
[16:13:05.780]                 for (kk in seq_along(NAMES)) {
[16:13:05.780]                   name <- changed[[kk]]
[16:13:05.780]                   NAME <- NAMES[[kk]]
[16:13:05.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.780]                     next
[16:13:05.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.780]                 }
[16:13:05.780]                 NAMES <- toupper(added)
[16:13:05.780]                 for (kk in seq_along(NAMES)) {
[16:13:05.780]                   name <- added[[kk]]
[16:13:05.780]                   NAME <- NAMES[[kk]]
[16:13:05.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.780]                     next
[16:13:05.780]                   args[[name]] <- ""
[16:13:05.780]                 }
[16:13:05.780]                 NAMES <- toupper(removed)
[16:13:05.780]                 for (kk in seq_along(NAMES)) {
[16:13:05.780]                   name <- removed[[kk]]
[16:13:05.780]                   NAME <- NAMES[[kk]]
[16:13:05.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.780]                     next
[16:13:05.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.780]                 }
[16:13:05.780]                 if (length(args) > 0) 
[16:13:05.780]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.780]             }
[16:13:05.780]             else {
[16:13:05.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.780]             }
[16:13:05.780]             {
[16:13:05.780]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.780]                   0L) {
[16:13:05.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.780]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.780]                   base::options(opts)
[16:13:05.780]                 }
[16:13:05.780]                 {
[16:13:05.780]                   {
[16:13:05.780]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:05.780]                     NULL
[16:13:05.780]                   }
[16:13:05.780]                   options(future.plan = NULL)
[16:13:05.780]                   if (is.na(NA_character_)) 
[16:13:05.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.780]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.780]                   {
[16:13:05.780]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.780]                     if (!future$lazy) 
[16:13:05.780]                       future <- run(future)
[16:13:05.780]                     invisible(future)
[16:13:05.780]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.780]                 }
[16:13:05.780]             }
[16:13:05.780]         }
[16:13:05.780]     })
[16:13:05.780]     if (TRUE) {
[16:13:05.780]         base::sink(type = "output", split = FALSE)
[16:13:05.780]         if (TRUE) {
[16:13:05.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.780]         }
[16:13:05.780]         else {
[16:13:05.780]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.780]         }
[16:13:05.780]         base::close(...future.stdout)
[16:13:05.780]         ...future.stdout <- NULL
[16:13:05.780]     }
[16:13:05.780]     ...future.result$conditions <- ...future.conditions
[16:13:05.780]     ...future.result$finished <- base::Sys.time()
[16:13:05.780]     ...future.result
[16:13:05.780] }
[16:13:05.852] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[16:13:05.876] result() for ClusterFuture ...
[16:13:05.876] receiveMessageFromWorker() for ClusterFuture ...
[16:13:05.877] - Validating connection of MultisessionFuture
[16:13:05.879] - received message: FutureResult
[16:13:05.879] - Received FutureResult
[16:13:05.882] - Erased future from FutureRegistry
[16:13:05.882] result() for ClusterFuture ...
[16:13:05.882] - result already collected: FutureResult
[16:13:05.882] result() for ClusterFuture ... done
[16:13:05.882] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:05.883] result() for ClusterFuture ... done
[16:13:05.883] result() for ClusterFuture ...
[16:13:05.883] - result already collected: FutureResult
[16:13:05.883] result() for ClusterFuture ... done
[1] 42
[16:13:05.887] getGlobalsAndPackages() ...
[16:13:05.887] Searching for globals...
[16:13:05.889] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[16:13:05.889] Searching for globals ... DONE
[16:13:05.890] Resolving globals: FALSE
[16:13:05.890] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:05.891] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:13:05.891] - globals: [1] ‘a’
[16:13:05.891] 
[16:13:05.891] getGlobalsAndPackages() ... DONE
[16:13:05.903] Packages needed by the future expression (n = 0): <none>
[16:13:05.903] Packages needed by future strategies (n = 0): <none>
[16:13:05.903] {
[16:13:05.903]     {
[16:13:05.903]         {
[16:13:05.903]             ...future.startTime <- base::Sys.time()
[16:13:05.903]             {
[16:13:05.903]                 {
[16:13:05.903]                   {
[16:13:05.903]                     {
[16:13:05.903]                       base::local({
[16:13:05.903]                         has_future <- base::requireNamespace("future", 
[16:13:05.903]                           quietly = TRUE)
[16:13:05.903]                         if (has_future) {
[16:13:05.903]                           ns <- base::getNamespace("future")
[16:13:05.903]                           version <- ns[[".package"]][["version"]]
[16:13:05.903]                           if (is.null(version)) 
[16:13:05.903]                             version <- utils::packageVersion("future")
[16:13:05.903]                         }
[16:13:05.903]                         else {
[16:13:05.903]                           version <- NULL
[16:13:05.903]                         }
[16:13:05.903]                         if (!has_future || version < "1.8.0") {
[16:13:05.903]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.903]                             "", base::R.version$version.string), 
[16:13:05.903]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:05.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.903]                               "release", "version")], collapse = " "), 
[16:13:05.903]                             hostname = base::Sys.info()[["nodename"]])
[16:13:05.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.903]                             info)
[16:13:05.903]                           info <- base::paste(info, collapse = "; ")
[16:13:05.903]                           if (!has_future) {
[16:13:05.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.903]                               info)
[16:13:05.903]                           }
[16:13:05.903]                           else {
[16:13:05.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.903]                               info, version)
[16:13:05.903]                           }
[16:13:05.903]                           base::stop(msg)
[16:13:05.903]                         }
[16:13:05.903]                       })
[16:13:05.903]                     }
[16:13:05.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:05.903]                     base::options(mc.cores = 1L)
[16:13:05.903]                   }
[16:13:05.903]                   options(future.plan = NULL)
[16:13:05.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.903]                 }
[16:13:05.903]                 ...future.workdir <- getwd()
[16:13:05.903]             }
[16:13:05.903]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.903]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.903]         }
[16:13:05.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.903]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.903]             base::names(...future.oldOptions))
[16:13:05.903]     }
[16:13:05.903]     if (FALSE) {
[16:13:05.903]     }
[16:13:05.903]     else {
[16:13:05.903]         if (TRUE) {
[16:13:05.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.903]                 open = "w")
[16:13:05.903]         }
[16:13:05.903]         else {
[16:13:05.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.903]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.903]         }
[16:13:05.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.903]             base::sink(type = "output", split = FALSE)
[16:13:05.903]             base::close(...future.stdout)
[16:13:05.903]         }, add = TRUE)
[16:13:05.903]     }
[16:13:05.903]     ...future.frame <- base::sys.nframe()
[16:13:05.903]     ...future.conditions <- base::list()
[16:13:05.903]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.903]     if (FALSE) {
[16:13:05.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.903]     }
[16:13:05.903]     ...future.result <- base::tryCatch({
[16:13:05.903]         base::withCallingHandlers({
[16:13:05.903]             ...future.value <- base::withVisible(base::local({
[16:13:05.903]                 ...future.makeSendCondition <- local({
[16:13:05.903]                   sendCondition <- NULL
[16:13:05.903]                   function(frame = 1L) {
[16:13:05.903]                     if (is.function(sendCondition)) 
[16:13:05.903]                       return(sendCondition)
[16:13:05.903]                     ns <- getNamespace("parallel")
[16:13:05.903]                     if (exists("sendData", mode = "function", 
[16:13:05.903]                       envir = ns)) {
[16:13:05.903]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:05.903]                         envir = ns)
[16:13:05.903]                       envir <- sys.frame(frame)
[16:13:05.903]                       master <- NULL
[16:13:05.903]                       while (!identical(envir, .GlobalEnv) && 
[16:13:05.903]                         !identical(envir, emptyenv())) {
[16:13:05.903]                         if (exists("master", mode = "list", envir = envir, 
[16:13:05.903]                           inherits = FALSE)) {
[16:13:05.903]                           master <- get("master", mode = "list", 
[16:13:05.903]                             envir = envir, inherits = FALSE)
[16:13:05.903]                           if (inherits(master, c("SOCKnode", 
[16:13:05.903]                             "SOCK0node"))) {
[16:13:05.903]                             sendCondition <<- function(cond) {
[16:13:05.903]                               data <- list(type = "VALUE", value = cond, 
[16:13:05.903]                                 success = TRUE)
[16:13:05.903]                               parallel_sendData(master, data)
[16:13:05.903]                             }
[16:13:05.903]                             return(sendCondition)
[16:13:05.903]                           }
[16:13:05.903]                         }
[16:13:05.903]                         frame <- frame + 1L
[16:13:05.903]                         envir <- sys.frame(frame)
[16:13:05.903]                       }
[16:13:05.903]                     }
[16:13:05.903]                     sendCondition <<- function(cond) NULL
[16:13:05.903]                   }
[16:13:05.903]                 })
[16:13:05.903]                 withCallingHandlers({
[16:13:05.903]                   {
[16:13:05.903]                     b <- 3
[16:13:05.903]                     c <- 2
[16:13:05.903]                     a * b * c
[16:13:05.903]                   }
[16:13:05.903]                 }, immediateCondition = function(cond) {
[16:13:05.903]                   sendCondition <- ...future.makeSendCondition()
[16:13:05.903]                   sendCondition(cond)
[16:13:05.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.903]                   {
[16:13:05.903]                     inherits <- base::inherits
[16:13:05.903]                     invokeRestart <- base::invokeRestart
[16:13:05.903]                     is.null <- base::is.null
[16:13:05.903]                     muffled <- FALSE
[16:13:05.903]                     if (inherits(cond, "message")) {
[16:13:05.903]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:05.903]                       if (muffled) 
[16:13:05.903]                         invokeRestart("muffleMessage")
[16:13:05.903]                     }
[16:13:05.903]                     else if (inherits(cond, "warning")) {
[16:13:05.903]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:05.903]                       if (muffled) 
[16:13:05.903]                         invokeRestart("muffleWarning")
[16:13:05.903]                     }
[16:13:05.903]                     else if (inherits(cond, "condition")) {
[16:13:05.903]                       if (!is.null(pattern)) {
[16:13:05.903]                         computeRestarts <- base::computeRestarts
[16:13:05.903]                         grepl <- base::grepl
[16:13:05.903]                         restarts <- computeRestarts(cond)
[16:13:05.903]                         for (restart in restarts) {
[16:13:05.903]                           name <- restart$name
[16:13:05.903]                           if (is.null(name)) 
[16:13:05.903]                             next
[16:13:05.903]                           if (!grepl(pattern, name)) 
[16:13:05.903]                             next
[16:13:05.903]                           invokeRestart(restart)
[16:13:05.903]                           muffled <- TRUE
[16:13:05.903]                           break
[16:13:05.903]                         }
[16:13:05.903]                       }
[16:13:05.903]                     }
[16:13:05.903]                     invisible(muffled)
[16:13:05.903]                   }
[16:13:05.903]                   muffleCondition(cond)
[16:13:05.903]                 })
[16:13:05.903]             }))
[16:13:05.903]             future::FutureResult(value = ...future.value$value, 
[16:13:05.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.903]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.903]                     ...future.globalenv.names))
[16:13:05.903]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.903]         }, condition = base::local({
[16:13:05.903]             c <- base::c
[16:13:05.903]             inherits <- base::inherits
[16:13:05.903]             invokeRestart <- base::invokeRestart
[16:13:05.903]             length <- base::length
[16:13:05.903]             list <- base::list
[16:13:05.903]             seq.int <- base::seq.int
[16:13:05.903]             signalCondition <- base::signalCondition
[16:13:05.903]             sys.calls <- base::sys.calls
[16:13:05.903]             `[[` <- base::`[[`
[16:13:05.903]             `+` <- base::`+`
[16:13:05.903]             `<<-` <- base::`<<-`
[16:13:05.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.903]                   3L)]
[16:13:05.903]             }
[16:13:05.903]             function(cond) {
[16:13:05.903]                 is_error <- inherits(cond, "error")
[16:13:05.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.903]                   NULL)
[16:13:05.903]                 if (is_error) {
[16:13:05.903]                   sessionInformation <- function() {
[16:13:05.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.903]                       search = base::search(), system = base::Sys.info())
[16:13:05.903]                   }
[16:13:05.903]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.903]                     cond$call), session = sessionInformation(), 
[16:13:05.903]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.903]                   signalCondition(cond)
[16:13:05.903]                 }
[16:13:05.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.903]                 "immediateCondition"))) {
[16:13:05.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.903]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.903]                   if (TRUE && !signal) {
[16:13:05.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.903]                     {
[16:13:05.903]                       inherits <- base::inherits
[16:13:05.903]                       invokeRestart <- base::invokeRestart
[16:13:05.903]                       is.null <- base::is.null
[16:13:05.903]                       muffled <- FALSE
[16:13:05.903]                       if (inherits(cond, "message")) {
[16:13:05.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.903]                         if (muffled) 
[16:13:05.903]                           invokeRestart("muffleMessage")
[16:13:05.903]                       }
[16:13:05.903]                       else if (inherits(cond, "warning")) {
[16:13:05.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.903]                         if (muffled) 
[16:13:05.903]                           invokeRestart("muffleWarning")
[16:13:05.903]                       }
[16:13:05.903]                       else if (inherits(cond, "condition")) {
[16:13:05.903]                         if (!is.null(pattern)) {
[16:13:05.903]                           computeRestarts <- base::computeRestarts
[16:13:05.903]                           grepl <- base::grepl
[16:13:05.903]                           restarts <- computeRestarts(cond)
[16:13:05.903]                           for (restart in restarts) {
[16:13:05.903]                             name <- restart$name
[16:13:05.903]                             if (is.null(name)) 
[16:13:05.903]                               next
[16:13:05.903]                             if (!grepl(pattern, name)) 
[16:13:05.903]                               next
[16:13:05.903]                             invokeRestart(restart)
[16:13:05.903]                             muffled <- TRUE
[16:13:05.903]                             break
[16:13:05.903]                           }
[16:13:05.903]                         }
[16:13:05.903]                       }
[16:13:05.903]                       invisible(muffled)
[16:13:05.903]                     }
[16:13:05.903]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.903]                   }
[16:13:05.903]                 }
[16:13:05.903]                 else {
[16:13:05.903]                   if (TRUE) {
[16:13:05.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.903]                     {
[16:13:05.903]                       inherits <- base::inherits
[16:13:05.903]                       invokeRestart <- base::invokeRestart
[16:13:05.903]                       is.null <- base::is.null
[16:13:05.903]                       muffled <- FALSE
[16:13:05.903]                       if (inherits(cond, "message")) {
[16:13:05.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.903]                         if (muffled) 
[16:13:05.903]                           invokeRestart("muffleMessage")
[16:13:05.903]                       }
[16:13:05.903]                       else if (inherits(cond, "warning")) {
[16:13:05.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.903]                         if (muffled) 
[16:13:05.903]                           invokeRestart("muffleWarning")
[16:13:05.903]                       }
[16:13:05.903]                       else if (inherits(cond, "condition")) {
[16:13:05.903]                         if (!is.null(pattern)) {
[16:13:05.903]                           computeRestarts <- base::computeRestarts
[16:13:05.903]                           grepl <- base::grepl
[16:13:05.903]                           restarts <- computeRestarts(cond)
[16:13:05.903]                           for (restart in restarts) {
[16:13:05.903]                             name <- restart$name
[16:13:05.903]                             if (is.null(name)) 
[16:13:05.903]                               next
[16:13:05.903]                             if (!grepl(pattern, name)) 
[16:13:05.903]                               next
[16:13:05.903]                             invokeRestart(restart)
[16:13:05.903]                             muffled <- TRUE
[16:13:05.903]                             break
[16:13:05.903]                           }
[16:13:05.903]                         }
[16:13:05.903]                       }
[16:13:05.903]                       invisible(muffled)
[16:13:05.903]                     }
[16:13:05.903]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.903]                   }
[16:13:05.903]                 }
[16:13:05.903]             }
[16:13:05.903]         }))
[16:13:05.903]     }, error = function(ex) {
[16:13:05.903]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.903]                 ...future.rng), started = ...future.startTime, 
[16:13:05.903]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.903]             version = "1.8"), class = "FutureResult")
[16:13:05.903]     }, finally = {
[16:13:05.903]         if (!identical(...future.workdir, getwd())) 
[16:13:05.903]             setwd(...future.workdir)
[16:13:05.903]         {
[16:13:05.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.903]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.903]             }
[16:13:05.903]             base::options(...future.oldOptions)
[16:13:05.903]             if (.Platform$OS.type == "windows") {
[16:13:05.903]                 old_names <- names(...future.oldEnvVars)
[16:13:05.903]                 envs <- base::Sys.getenv()
[16:13:05.903]                 names <- names(envs)
[16:13:05.903]                 common <- intersect(names, old_names)
[16:13:05.903]                 added <- setdiff(names, old_names)
[16:13:05.903]                 removed <- setdiff(old_names, names)
[16:13:05.903]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.903]                   envs[common]]
[16:13:05.903]                 NAMES <- toupper(changed)
[16:13:05.903]                 args <- list()
[16:13:05.903]                 for (kk in seq_along(NAMES)) {
[16:13:05.903]                   name <- changed[[kk]]
[16:13:05.903]                   NAME <- NAMES[[kk]]
[16:13:05.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.903]                     next
[16:13:05.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.903]                 }
[16:13:05.903]                 NAMES <- toupper(added)
[16:13:05.903]                 for (kk in seq_along(NAMES)) {
[16:13:05.903]                   name <- added[[kk]]
[16:13:05.903]                   NAME <- NAMES[[kk]]
[16:13:05.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.903]                     next
[16:13:05.903]                   args[[name]] <- ""
[16:13:05.903]                 }
[16:13:05.903]                 NAMES <- toupper(removed)
[16:13:05.903]                 for (kk in seq_along(NAMES)) {
[16:13:05.903]                   name <- removed[[kk]]
[16:13:05.903]                   NAME <- NAMES[[kk]]
[16:13:05.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.903]                     next
[16:13:05.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.903]                 }
[16:13:05.903]                 if (length(args) > 0) 
[16:13:05.903]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.903]             }
[16:13:05.903]             else {
[16:13:05.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.903]             }
[16:13:05.903]             {
[16:13:05.903]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.903]                   0L) {
[16:13:05.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.903]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.903]                   base::options(opts)
[16:13:05.903]                 }
[16:13:05.903]                 {
[16:13:05.903]                   {
[16:13:05.903]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:05.903]                     NULL
[16:13:05.903]                   }
[16:13:05.903]                   options(future.plan = NULL)
[16:13:05.903]                   if (is.na(NA_character_)) 
[16:13:05.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.903]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.903]                   {
[16:13:05.903]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.903]                     if (!future$lazy) 
[16:13:05.903]                       future <- run(future)
[16:13:05.903]                     invisible(future)
[16:13:05.903]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.903]                 }
[16:13:05.903]             }
[16:13:05.903]         }
[16:13:05.903]     })
[16:13:05.903]     if (TRUE) {
[16:13:05.903]         base::sink(type = "output", split = FALSE)
[16:13:05.903]         if (TRUE) {
[16:13:05.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.903]         }
[16:13:05.903]         else {
[16:13:05.903]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.903]         }
[16:13:05.903]         base::close(...future.stdout)
[16:13:05.903]         ...future.stdout <- NULL
[16:13:05.903]     }
[16:13:05.903]     ...future.result$conditions <- ...future.conditions
[16:13:05.903]     ...future.result$finished <- base::Sys.time()
[16:13:05.903]     ...future.result
[16:13:05.903] }
[16:13:05.906] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:13:05.906] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:13:05.907] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:13:05.907] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:13:05.907] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:05.919] result() for ClusterFuture ...
[16:13:05.919] receiveMessageFromWorker() for ClusterFuture ...
[16:13:05.919] - Validating connection of MultisessionFuture
[16:13:05.949] - received message: FutureResult
[16:13:05.949] - Received FutureResult
[16:13:05.949] - Erased future from FutureRegistry
[16:13:05.949] result() for ClusterFuture ...
[16:13:05.950] - result already collected: FutureResult
[16:13:05.950] result() for ClusterFuture ... done
[16:13:05.950] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:05.950] result() for ClusterFuture ... done
[16:13:05.950] result() for ClusterFuture ...
[16:13:05.950] - result already collected: FutureResult
[16:13:05.950] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[16:13:05.954] getGlobalsAndPackages() ...
[16:13:05.954] Searching for globals...
[16:13:05.955] - globals found: [2] ‘{’, ‘ii’
[16:13:05.955] Searching for globals ... DONE
[16:13:05.955] Resolving globals: FALSE
[16:13:05.956] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:05.956] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:05.956] - globals: [1] ‘ii’
[16:13:05.956] 
[16:13:05.956] getGlobalsAndPackages() ... DONE
[16:13:05.968] Packages needed by the future expression (n = 0): <none>
[16:13:05.968] Packages needed by future strategies (n = 0): <none>
[16:13:05.969] {
[16:13:05.969]     {
[16:13:05.969]         {
[16:13:05.969]             ...future.startTime <- base::Sys.time()
[16:13:05.969]             {
[16:13:05.969]                 {
[16:13:05.969]                   {
[16:13:05.969]                     {
[16:13:05.969]                       base::local({
[16:13:05.969]                         has_future <- base::requireNamespace("future", 
[16:13:05.969]                           quietly = TRUE)
[16:13:05.969]                         if (has_future) {
[16:13:05.969]                           ns <- base::getNamespace("future")
[16:13:05.969]                           version <- ns[[".package"]][["version"]]
[16:13:05.969]                           if (is.null(version)) 
[16:13:05.969]                             version <- utils::packageVersion("future")
[16:13:05.969]                         }
[16:13:05.969]                         else {
[16:13:05.969]                           version <- NULL
[16:13:05.969]                         }
[16:13:05.969]                         if (!has_future || version < "1.8.0") {
[16:13:05.969]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.969]                             "", base::R.version$version.string), 
[16:13:05.969]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:05.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.969]                               "release", "version")], collapse = " "), 
[16:13:05.969]                             hostname = base::Sys.info()[["nodename"]])
[16:13:05.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.969]                             info)
[16:13:05.969]                           info <- base::paste(info, collapse = "; ")
[16:13:05.969]                           if (!has_future) {
[16:13:05.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.969]                               info)
[16:13:05.969]                           }
[16:13:05.969]                           else {
[16:13:05.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.969]                               info, version)
[16:13:05.969]                           }
[16:13:05.969]                           base::stop(msg)
[16:13:05.969]                         }
[16:13:05.969]                       })
[16:13:05.969]                     }
[16:13:05.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:05.969]                     base::options(mc.cores = 1L)
[16:13:05.969]                   }
[16:13:05.969]                   options(future.plan = NULL)
[16:13:05.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.969]                 }
[16:13:05.969]                 ...future.workdir <- getwd()
[16:13:05.969]             }
[16:13:05.969]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.969]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.969]         }
[16:13:05.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.969]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.969]             base::names(...future.oldOptions))
[16:13:05.969]     }
[16:13:05.969]     if (FALSE) {
[16:13:05.969]     }
[16:13:05.969]     else {
[16:13:05.969]         if (TRUE) {
[16:13:05.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.969]                 open = "w")
[16:13:05.969]         }
[16:13:05.969]         else {
[16:13:05.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.969]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.969]         }
[16:13:05.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.969]             base::sink(type = "output", split = FALSE)
[16:13:05.969]             base::close(...future.stdout)
[16:13:05.969]         }, add = TRUE)
[16:13:05.969]     }
[16:13:05.969]     ...future.frame <- base::sys.nframe()
[16:13:05.969]     ...future.conditions <- base::list()
[16:13:05.969]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.969]     if (FALSE) {
[16:13:05.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.969]     }
[16:13:05.969]     ...future.result <- base::tryCatch({
[16:13:05.969]         base::withCallingHandlers({
[16:13:05.969]             ...future.value <- base::withVisible(base::local({
[16:13:05.969]                 ...future.makeSendCondition <- local({
[16:13:05.969]                   sendCondition <- NULL
[16:13:05.969]                   function(frame = 1L) {
[16:13:05.969]                     if (is.function(sendCondition)) 
[16:13:05.969]                       return(sendCondition)
[16:13:05.969]                     ns <- getNamespace("parallel")
[16:13:05.969]                     if (exists("sendData", mode = "function", 
[16:13:05.969]                       envir = ns)) {
[16:13:05.969]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:05.969]                         envir = ns)
[16:13:05.969]                       envir <- sys.frame(frame)
[16:13:05.969]                       master <- NULL
[16:13:05.969]                       while (!identical(envir, .GlobalEnv) && 
[16:13:05.969]                         !identical(envir, emptyenv())) {
[16:13:05.969]                         if (exists("master", mode = "list", envir = envir, 
[16:13:05.969]                           inherits = FALSE)) {
[16:13:05.969]                           master <- get("master", mode = "list", 
[16:13:05.969]                             envir = envir, inherits = FALSE)
[16:13:05.969]                           if (inherits(master, c("SOCKnode", 
[16:13:05.969]                             "SOCK0node"))) {
[16:13:05.969]                             sendCondition <<- function(cond) {
[16:13:05.969]                               data <- list(type = "VALUE", value = cond, 
[16:13:05.969]                                 success = TRUE)
[16:13:05.969]                               parallel_sendData(master, data)
[16:13:05.969]                             }
[16:13:05.969]                             return(sendCondition)
[16:13:05.969]                           }
[16:13:05.969]                         }
[16:13:05.969]                         frame <- frame + 1L
[16:13:05.969]                         envir <- sys.frame(frame)
[16:13:05.969]                       }
[16:13:05.969]                     }
[16:13:05.969]                     sendCondition <<- function(cond) NULL
[16:13:05.969]                   }
[16:13:05.969]                 })
[16:13:05.969]                 withCallingHandlers({
[16:13:05.969]                   {
[16:13:05.969]                     ii
[16:13:05.969]                   }
[16:13:05.969]                 }, immediateCondition = function(cond) {
[16:13:05.969]                   sendCondition <- ...future.makeSendCondition()
[16:13:05.969]                   sendCondition(cond)
[16:13:05.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.969]                   {
[16:13:05.969]                     inherits <- base::inherits
[16:13:05.969]                     invokeRestart <- base::invokeRestart
[16:13:05.969]                     is.null <- base::is.null
[16:13:05.969]                     muffled <- FALSE
[16:13:05.969]                     if (inherits(cond, "message")) {
[16:13:05.969]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:05.969]                       if (muffled) 
[16:13:05.969]                         invokeRestart("muffleMessage")
[16:13:05.969]                     }
[16:13:05.969]                     else if (inherits(cond, "warning")) {
[16:13:05.969]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:05.969]                       if (muffled) 
[16:13:05.969]                         invokeRestart("muffleWarning")
[16:13:05.969]                     }
[16:13:05.969]                     else if (inherits(cond, "condition")) {
[16:13:05.969]                       if (!is.null(pattern)) {
[16:13:05.969]                         computeRestarts <- base::computeRestarts
[16:13:05.969]                         grepl <- base::grepl
[16:13:05.969]                         restarts <- computeRestarts(cond)
[16:13:05.969]                         for (restart in restarts) {
[16:13:05.969]                           name <- restart$name
[16:13:05.969]                           if (is.null(name)) 
[16:13:05.969]                             next
[16:13:05.969]                           if (!grepl(pattern, name)) 
[16:13:05.969]                             next
[16:13:05.969]                           invokeRestart(restart)
[16:13:05.969]                           muffled <- TRUE
[16:13:05.969]                           break
[16:13:05.969]                         }
[16:13:05.969]                       }
[16:13:05.969]                     }
[16:13:05.969]                     invisible(muffled)
[16:13:05.969]                   }
[16:13:05.969]                   muffleCondition(cond)
[16:13:05.969]                 })
[16:13:05.969]             }))
[16:13:05.969]             future::FutureResult(value = ...future.value$value, 
[16:13:05.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.969]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.969]                     ...future.globalenv.names))
[16:13:05.969]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.969]         }, condition = base::local({
[16:13:05.969]             c <- base::c
[16:13:05.969]             inherits <- base::inherits
[16:13:05.969]             invokeRestart <- base::invokeRestart
[16:13:05.969]             length <- base::length
[16:13:05.969]             list <- base::list
[16:13:05.969]             seq.int <- base::seq.int
[16:13:05.969]             signalCondition <- base::signalCondition
[16:13:05.969]             sys.calls <- base::sys.calls
[16:13:05.969]             `[[` <- base::`[[`
[16:13:05.969]             `+` <- base::`+`
[16:13:05.969]             `<<-` <- base::`<<-`
[16:13:05.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.969]                   3L)]
[16:13:05.969]             }
[16:13:05.969]             function(cond) {
[16:13:05.969]                 is_error <- inherits(cond, "error")
[16:13:05.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.969]                   NULL)
[16:13:05.969]                 if (is_error) {
[16:13:05.969]                   sessionInformation <- function() {
[16:13:05.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.969]                       search = base::search(), system = base::Sys.info())
[16:13:05.969]                   }
[16:13:05.969]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.969]                     cond$call), session = sessionInformation(), 
[16:13:05.969]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.969]                   signalCondition(cond)
[16:13:05.969]                 }
[16:13:05.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.969]                 "immediateCondition"))) {
[16:13:05.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.969]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.969]                   if (TRUE && !signal) {
[16:13:05.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.969]                     {
[16:13:05.969]                       inherits <- base::inherits
[16:13:05.969]                       invokeRestart <- base::invokeRestart
[16:13:05.969]                       is.null <- base::is.null
[16:13:05.969]                       muffled <- FALSE
[16:13:05.969]                       if (inherits(cond, "message")) {
[16:13:05.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.969]                         if (muffled) 
[16:13:05.969]                           invokeRestart("muffleMessage")
[16:13:05.969]                       }
[16:13:05.969]                       else if (inherits(cond, "warning")) {
[16:13:05.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.969]                         if (muffled) 
[16:13:05.969]                           invokeRestart("muffleWarning")
[16:13:05.969]                       }
[16:13:05.969]                       else if (inherits(cond, "condition")) {
[16:13:05.969]                         if (!is.null(pattern)) {
[16:13:05.969]                           computeRestarts <- base::computeRestarts
[16:13:05.969]                           grepl <- base::grepl
[16:13:05.969]                           restarts <- computeRestarts(cond)
[16:13:05.969]                           for (restart in restarts) {
[16:13:05.969]                             name <- restart$name
[16:13:05.969]                             if (is.null(name)) 
[16:13:05.969]                               next
[16:13:05.969]                             if (!grepl(pattern, name)) 
[16:13:05.969]                               next
[16:13:05.969]                             invokeRestart(restart)
[16:13:05.969]                             muffled <- TRUE
[16:13:05.969]                             break
[16:13:05.969]                           }
[16:13:05.969]                         }
[16:13:05.969]                       }
[16:13:05.969]                       invisible(muffled)
[16:13:05.969]                     }
[16:13:05.969]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.969]                   }
[16:13:05.969]                 }
[16:13:05.969]                 else {
[16:13:05.969]                   if (TRUE) {
[16:13:05.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.969]                     {
[16:13:05.969]                       inherits <- base::inherits
[16:13:05.969]                       invokeRestart <- base::invokeRestart
[16:13:05.969]                       is.null <- base::is.null
[16:13:05.969]                       muffled <- FALSE
[16:13:05.969]                       if (inherits(cond, "message")) {
[16:13:05.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.969]                         if (muffled) 
[16:13:05.969]                           invokeRestart("muffleMessage")
[16:13:05.969]                       }
[16:13:05.969]                       else if (inherits(cond, "warning")) {
[16:13:05.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.969]                         if (muffled) 
[16:13:05.969]                           invokeRestart("muffleWarning")
[16:13:05.969]                       }
[16:13:05.969]                       else if (inherits(cond, "condition")) {
[16:13:05.969]                         if (!is.null(pattern)) {
[16:13:05.969]                           computeRestarts <- base::computeRestarts
[16:13:05.969]                           grepl <- base::grepl
[16:13:05.969]                           restarts <- computeRestarts(cond)
[16:13:05.969]                           for (restart in restarts) {
[16:13:05.969]                             name <- restart$name
[16:13:05.969]                             if (is.null(name)) 
[16:13:05.969]                               next
[16:13:05.969]                             if (!grepl(pattern, name)) 
[16:13:05.969]                               next
[16:13:05.969]                             invokeRestart(restart)
[16:13:05.969]                             muffled <- TRUE
[16:13:05.969]                             break
[16:13:05.969]                           }
[16:13:05.969]                         }
[16:13:05.969]                       }
[16:13:05.969]                       invisible(muffled)
[16:13:05.969]                     }
[16:13:05.969]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.969]                   }
[16:13:05.969]                 }
[16:13:05.969]             }
[16:13:05.969]         }))
[16:13:05.969]     }, error = function(ex) {
[16:13:05.969]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.969]                 ...future.rng), started = ...future.startTime, 
[16:13:05.969]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.969]             version = "1.8"), class = "FutureResult")
[16:13:05.969]     }, finally = {
[16:13:05.969]         if (!identical(...future.workdir, getwd())) 
[16:13:05.969]             setwd(...future.workdir)
[16:13:05.969]         {
[16:13:05.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.969]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.969]             }
[16:13:05.969]             base::options(...future.oldOptions)
[16:13:05.969]             if (.Platform$OS.type == "windows") {
[16:13:05.969]                 old_names <- names(...future.oldEnvVars)
[16:13:05.969]                 envs <- base::Sys.getenv()
[16:13:05.969]                 names <- names(envs)
[16:13:05.969]                 common <- intersect(names, old_names)
[16:13:05.969]                 added <- setdiff(names, old_names)
[16:13:05.969]                 removed <- setdiff(old_names, names)
[16:13:05.969]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.969]                   envs[common]]
[16:13:05.969]                 NAMES <- toupper(changed)
[16:13:05.969]                 args <- list()
[16:13:05.969]                 for (kk in seq_along(NAMES)) {
[16:13:05.969]                   name <- changed[[kk]]
[16:13:05.969]                   NAME <- NAMES[[kk]]
[16:13:05.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.969]                     next
[16:13:05.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.969]                 }
[16:13:05.969]                 NAMES <- toupper(added)
[16:13:05.969]                 for (kk in seq_along(NAMES)) {
[16:13:05.969]                   name <- added[[kk]]
[16:13:05.969]                   NAME <- NAMES[[kk]]
[16:13:05.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.969]                     next
[16:13:05.969]                   args[[name]] <- ""
[16:13:05.969]                 }
[16:13:05.969]                 NAMES <- toupper(removed)
[16:13:05.969]                 for (kk in seq_along(NAMES)) {
[16:13:05.969]                   name <- removed[[kk]]
[16:13:05.969]                   NAME <- NAMES[[kk]]
[16:13:05.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.969]                     next
[16:13:05.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.969]                 }
[16:13:05.969]                 if (length(args) > 0) 
[16:13:05.969]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.969]             }
[16:13:05.969]             else {
[16:13:05.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.969]             }
[16:13:05.969]             {
[16:13:05.969]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.969]                   0L) {
[16:13:05.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.969]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.969]                   base::options(opts)
[16:13:05.969]                 }
[16:13:05.969]                 {
[16:13:05.969]                   {
[16:13:05.969]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:05.969]                     NULL
[16:13:05.969]                   }
[16:13:05.969]                   options(future.plan = NULL)
[16:13:05.969]                   if (is.na(NA_character_)) 
[16:13:05.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.969]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.969]                   {
[16:13:05.969]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.969]                     if (!future$lazy) 
[16:13:05.969]                       future <- run(future)
[16:13:05.969]                     invisible(future)
[16:13:05.969]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.969]                 }
[16:13:05.969]             }
[16:13:05.969]         }
[16:13:05.969]     })
[16:13:05.969]     if (TRUE) {
[16:13:05.969]         base::sink(type = "output", split = FALSE)
[16:13:05.969]         if (TRUE) {
[16:13:05.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.969]         }
[16:13:05.969]         else {
[16:13:05.969]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.969]         }
[16:13:05.969]         base::close(...future.stdout)
[16:13:05.969]         ...future.stdout <- NULL
[16:13:05.969]     }
[16:13:05.969]     ...future.result$conditions <- ...future.conditions
[16:13:05.969]     ...future.result$finished <- base::Sys.time()
[16:13:05.969]     ...future.result
[16:13:05.969] }
[16:13:05.971] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:13:05.972] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[16:13:05.972] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[16:13:05.972] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:13:05.973] MultisessionFuture started
 - Creating multisession future #1 ...
[16:13:05.976] getGlobalsAndPackages() ...
[16:13:05.976] Searching for globals...
[16:13:05.977] - globals found: [2] ‘{’, ‘ii’
[16:13:05.977] Searching for globals ... DONE
[16:13:05.977] Resolving globals: FALSE
[16:13:05.978] The total size of the 1 globals is 56 bytes (56 bytes)
[16:13:05.978] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:13:05.978] - globals: [1] ‘ii’
[16:13:05.979] 
[16:13:05.979] getGlobalsAndPackages() ... DONE
[16:13:05.990] Packages needed by the future expression (n = 0): <none>
[16:13:05.990] Packages needed by future strategies (n = 0): <none>
[16:13:05.991] {
[16:13:05.991]     {
[16:13:05.991]         {
[16:13:05.991]             ...future.startTime <- base::Sys.time()
[16:13:05.991]             {
[16:13:05.991]                 {
[16:13:05.991]                   {
[16:13:05.991]                     {
[16:13:05.991]                       base::local({
[16:13:05.991]                         has_future <- base::requireNamespace("future", 
[16:13:05.991]                           quietly = TRUE)
[16:13:05.991]                         if (has_future) {
[16:13:05.991]                           ns <- base::getNamespace("future")
[16:13:05.991]                           version <- ns[[".package"]][["version"]]
[16:13:05.991]                           if (is.null(version)) 
[16:13:05.991]                             version <- utils::packageVersion("future")
[16:13:05.991]                         }
[16:13:05.991]                         else {
[16:13:05.991]                           version <- NULL
[16:13:05.991]                         }
[16:13:05.991]                         if (!has_future || version < "1.8.0") {
[16:13:05.991]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:05.991]                             "", base::R.version$version.string), 
[16:13:05.991]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:05.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:05.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:05.991]                               "release", "version")], collapse = " "), 
[16:13:05.991]                             hostname = base::Sys.info()[["nodename"]])
[16:13:05.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:05.991]                             info)
[16:13:05.991]                           info <- base::paste(info, collapse = "; ")
[16:13:05.991]                           if (!has_future) {
[16:13:05.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:05.991]                               info)
[16:13:05.991]                           }
[16:13:05.991]                           else {
[16:13:05.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:05.991]                               info, version)
[16:13:05.991]                           }
[16:13:05.991]                           base::stop(msg)
[16:13:05.991]                         }
[16:13:05.991]                       })
[16:13:05.991]                     }
[16:13:05.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:05.991]                     base::options(mc.cores = 1L)
[16:13:05.991]                   }
[16:13:05.991]                   options(future.plan = NULL)
[16:13:05.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:05.991]                 }
[16:13:05.991]                 ...future.workdir <- getwd()
[16:13:05.991]             }
[16:13:05.991]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:05.991]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:05.991]         }
[16:13:05.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:05.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:05.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:05.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:05.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:05.991]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:05.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:05.991]             base::names(...future.oldOptions))
[16:13:05.991]     }
[16:13:05.991]     if (FALSE) {
[16:13:05.991]     }
[16:13:05.991]     else {
[16:13:05.991]         if (TRUE) {
[16:13:05.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:05.991]                 open = "w")
[16:13:05.991]         }
[16:13:05.991]         else {
[16:13:05.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:05.991]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:05.991]         }
[16:13:05.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:05.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:05.991]             base::sink(type = "output", split = FALSE)
[16:13:05.991]             base::close(...future.stdout)
[16:13:05.991]         }, add = TRUE)
[16:13:05.991]     }
[16:13:05.991]     ...future.frame <- base::sys.nframe()
[16:13:05.991]     ...future.conditions <- base::list()
[16:13:05.991]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:05.991]     if (FALSE) {
[16:13:05.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:05.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:05.991]     }
[16:13:05.991]     ...future.result <- base::tryCatch({
[16:13:05.991]         base::withCallingHandlers({
[16:13:05.991]             ...future.value <- base::withVisible(base::local({
[16:13:05.991]                 ...future.makeSendCondition <- local({
[16:13:05.991]                   sendCondition <- NULL
[16:13:05.991]                   function(frame = 1L) {
[16:13:05.991]                     if (is.function(sendCondition)) 
[16:13:05.991]                       return(sendCondition)
[16:13:05.991]                     ns <- getNamespace("parallel")
[16:13:05.991]                     if (exists("sendData", mode = "function", 
[16:13:05.991]                       envir = ns)) {
[16:13:05.991]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:05.991]                         envir = ns)
[16:13:05.991]                       envir <- sys.frame(frame)
[16:13:05.991]                       master <- NULL
[16:13:05.991]                       while (!identical(envir, .GlobalEnv) && 
[16:13:05.991]                         !identical(envir, emptyenv())) {
[16:13:05.991]                         if (exists("master", mode = "list", envir = envir, 
[16:13:05.991]                           inherits = FALSE)) {
[16:13:05.991]                           master <- get("master", mode = "list", 
[16:13:05.991]                             envir = envir, inherits = FALSE)
[16:13:05.991]                           if (inherits(master, c("SOCKnode", 
[16:13:05.991]                             "SOCK0node"))) {
[16:13:05.991]                             sendCondition <<- function(cond) {
[16:13:05.991]                               data <- list(type = "VALUE", value = cond, 
[16:13:05.991]                                 success = TRUE)
[16:13:05.991]                               parallel_sendData(master, data)
[16:13:05.991]                             }
[16:13:05.991]                             return(sendCondition)
[16:13:05.991]                           }
[16:13:05.991]                         }
[16:13:05.991]                         frame <- frame + 1L
[16:13:05.991]                         envir <- sys.frame(frame)
[16:13:05.991]                       }
[16:13:05.991]                     }
[16:13:05.991]                     sendCondition <<- function(cond) NULL
[16:13:05.991]                   }
[16:13:05.991]                 })
[16:13:05.991]                 withCallingHandlers({
[16:13:05.991]                   {
[16:13:05.991]                     ii
[16:13:05.991]                   }
[16:13:05.991]                 }, immediateCondition = function(cond) {
[16:13:05.991]                   sendCondition <- ...future.makeSendCondition()
[16:13:05.991]                   sendCondition(cond)
[16:13:05.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.991]                   {
[16:13:05.991]                     inherits <- base::inherits
[16:13:05.991]                     invokeRestart <- base::invokeRestart
[16:13:05.991]                     is.null <- base::is.null
[16:13:05.991]                     muffled <- FALSE
[16:13:05.991]                     if (inherits(cond, "message")) {
[16:13:05.991]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:05.991]                       if (muffled) 
[16:13:05.991]                         invokeRestart("muffleMessage")
[16:13:05.991]                     }
[16:13:05.991]                     else if (inherits(cond, "warning")) {
[16:13:05.991]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:05.991]                       if (muffled) 
[16:13:05.991]                         invokeRestart("muffleWarning")
[16:13:05.991]                     }
[16:13:05.991]                     else if (inherits(cond, "condition")) {
[16:13:05.991]                       if (!is.null(pattern)) {
[16:13:05.991]                         computeRestarts <- base::computeRestarts
[16:13:05.991]                         grepl <- base::grepl
[16:13:05.991]                         restarts <- computeRestarts(cond)
[16:13:05.991]                         for (restart in restarts) {
[16:13:05.991]                           name <- restart$name
[16:13:05.991]                           if (is.null(name)) 
[16:13:05.991]                             next
[16:13:05.991]                           if (!grepl(pattern, name)) 
[16:13:05.991]                             next
[16:13:05.991]                           invokeRestart(restart)
[16:13:05.991]                           muffled <- TRUE
[16:13:05.991]                           break
[16:13:05.991]                         }
[16:13:05.991]                       }
[16:13:05.991]                     }
[16:13:05.991]                     invisible(muffled)
[16:13:05.991]                   }
[16:13:05.991]                   muffleCondition(cond)
[16:13:05.991]                 })
[16:13:05.991]             }))
[16:13:05.991]             future::FutureResult(value = ...future.value$value, 
[16:13:05.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.991]                   ...future.rng), globalenv = if (FALSE) 
[16:13:05.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:05.991]                     ...future.globalenv.names))
[16:13:05.991]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:05.991]         }, condition = base::local({
[16:13:05.991]             c <- base::c
[16:13:05.991]             inherits <- base::inherits
[16:13:05.991]             invokeRestart <- base::invokeRestart
[16:13:05.991]             length <- base::length
[16:13:05.991]             list <- base::list
[16:13:05.991]             seq.int <- base::seq.int
[16:13:05.991]             signalCondition <- base::signalCondition
[16:13:05.991]             sys.calls <- base::sys.calls
[16:13:05.991]             `[[` <- base::`[[`
[16:13:05.991]             `+` <- base::`+`
[16:13:05.991]             `<<-` <- base::`<<-`
[16:13:05.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:05.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:05.991]                   3L)]
[16:13:05.991]             }
[16:13:05.991]             function(cond) {
[16:13:05.991]                 is_error <- inherits(cond, "error")
[16:13:05.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:05.991]                   NULL)
[16:13:05.991]                 if (is_error) {
[16:13:05.991]                   sessionInformation <- function() {
[16:13:05.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:05.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:05.991]                       search = base::search(), system = base::Sys.info())
[16:13:05.991]                   }
[16:13:05.991]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:05.991]                     cond$call), session = sessionInformation(), 
[16:13:05.991]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:05.991]                   signalCondition(cond)
[16:13:05.991]                 }
[16:13:05.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:05.991]                 "immediateCondition"))) {
[16:13:05.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:05.991]                   ...future.conditions[[length(...future.conditions) + 
[16:13:05.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:05.991]                   if (TRUE && !signal) {
[16:13:05.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.991]                     {
[16:13:05.991]                       inherits <- base::inherits
[16:13:05.991]                       invokeRestart <- base::invokeRestart
[16:13:05.991]                       is.null <- base::is.null
[16:13:05.991]                       muffled <- FALSE
[16:13:05.991]                       if (inherits(cond, "message")) {
[16:13:05.991]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.991]                         if (muffled) 
[16:13:05.991]                           invokeRestart("muffleMessage")
[16:13:05.991]                       }
[16:13:05.991]                       else if (inherits(cond, "warning")) {
[16:13:05.991]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.991]                         if (muffled) 
[16:13:05.991]                           invokeRestart("muffleWarning")
[16:13:05.991]                       }
[16:13:05.991]                       else if (inherits(cond, "condition")) {
[16:13:05.991]                         if (!is.null(pattern)) {
[16:13:05.991]                           computeRestarts <- base::computeRestarts
[16:13:05.991]                           grepl <- base::grepl
[16:13:05.991]                           restarts <- computeRestarts(cond)
[16:13:05.991]                           for (restart in restarts) {
[16:13:05.991]                             name <- restart$name
[16:13:05.991]                             if (is.null(name)) 
[16:13:05.991]                               next
[16:13:05.991]                             if (!grepl(pattern, name)) 
[16:13:05.991]                               next
[16:13:05.991]                             invokeRestart(restart)
[16:13:05.991]                             muffled <- TRUE
[16:13:05.991]                             break
[16:13:05.991]                           }
[16:13:05.991]                         }
[16:13:05.991]                       }
[16:13:05.991]                       invisible(muffled)
[16:13:05.991]                     }
[16:13:05.991]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.991]                   }
[16:13:05.991]                 }
[16:13:05.991]                 else {
[16:13:05.991]                   if (TRUE) {
[16:13:05.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:05.991]                     {
[16:13:05.991]                       inherits <- base::inherits
[16:13:05.991]                       invokeRestart <- base::invokeRestart
[16:13:05.991]                       is.null <- base::is.null
[16:13:05.991]                       muffled <- FALSE
[16:13:05.991]                       if (inherits(cond, "message")) {
[16:13:05.991]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:05.991]                         if (muffled) 
[16:13:05.991]                           invokeRestart("muffleMessage")
[16:13:05.991]                       }
[16:13:05.991]                       else if (inherits(cond, "warning")) {
[16:13:05.991]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:05.991]                         if (muffled) 
[16:13:05.991]                           invokeRestart("muffleWarning")
[16:13:05.991]                       }
[16:13:05.991]                       else if (inherits(cond, "condition")) {
[16:13:05.991]                         if (!is.null(pattern)) {
[16:13:05.991]                           computeRestarts <- base::computeRestarts
[16:13:05.991]                           grepl <- base::grepl
[16:13:05.991]                           restarts <- computeRestarts(cond)
[16:13:05.991]                           for (restart in restarts) {
[16:13:05.991]                             name <- restart$name
[16:13:05.991]                             if (is.null(name)) 
[16:13:05.991]                               next
[16:13:05.991]                             if (!grepl(pattern, name)) 
[16:13:05.991]                               next
[16:13:05.991]                             invokeRestart(restart)
[16:13:05.991]                             muffled <- TRUE
[16:13:05.991]                             break
[16:13:05.991]                           }
[16:13:05.991]                         }
[16:13:05.991]                       }
[16:13:05.991]                       invisible(muffled)
[16:13:05.991]                     }
[16:13:05.991]                     muffleCondition(cond, pattern = "^muffle")
[16:13:05.991]                   }
[16:13:05.991]                 }
[16:13:05.991]             }
[16:13:05.991]         }))
[16:13:05.991]     }, error = function(ex) {
[16:13:05.991]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:05.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:05.991]                 ...future.rng), started = ...future.startTime, 
[16:13:05.991]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:05.991]             version = "1.8"), class = "FutureResult")
[16:13:05.991]     }, finally = {
[16:13:05.991]         if (!identical(...future.workdir, getwd())) 
[16:13:05.991]             setwd(...future.workdir)
[16:13:05.991]         {
[16:13:05.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:05.991]                 ...future.oldOptions$nwarnings <- NULL
[16:13:05.991]             }
[16:13:05.991]             base::options(...future.oldOptions)
[16:13:05.991]             if (.Platform$OS.type == "windows") {
[16:13:05.991]                 old_names <- names(...future.oldEnvVars)
[16:13:05.991]                 envs <- base::Sys.getenv()
[16:13:05.991]                 names <- names(envs)
[16:13:05.991]                 common <- intersect(names, old_names)
[16:13:05.991]                 added <- setdiff(names, old_names)
[16:13:05.991]                 removed <- setdiff(old_names, names)
[16:13:05.991]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:05.991]                   envs[common]]
[16:13:05.991]                 NAMES <- toupper(changed)
[16:13:05.991]                 args <- list()
[16:13:05.991]                 for (kk in seq_along(NAMES)) {
[16:13:05.991]                   name <- changed[[kk]]
[16:13:05.991]                   NAME <- NAMES[[kk]]
[16:13:05.991]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.991]                     next
[16:13:05.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.991]                 }
[16:13:05.991]                 NAMES <- toupper(added)
[16:13:05.991]                 for (kk in seq_along(NAMES)) {
[16:13:05.991]                   name <- added[[kk]]
[16:13:05.991]                   NAME <- NAMES[[kk]]
[16:13:05.991]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.991]                     next
[16:13:05.991]                   args[[name]] <- ""
[16:13:05.991]                 }
[16:13:05.991]                 NAMES <- toupper(removed)
[16:13:05.991]                 for (kk in seq_along(NAMES)) {
[16:13:05.991]                   name <- removed[[kk]]
[16:13:05.991]                   NAME <- NAMES[[kk]]
[16:13:05.991]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:05.991]                     next
[16:13:05.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:05.991]                 }
[16:13:05.991]                 if (length(args) > 0) 
[16:13:05.991]                   base::do.call(base::Sys.setenv, args = args)
[16:13:05.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:05.991]             }
[16:13:05.991]             else {
[16:13:05.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:05.991]             }
[16:13:05.991]             {
[16:13:05.991]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:05.991]                   0L) {
[16:13:05.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:05.991]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:05.991]                   base::options(opts)
[16:13:05.991]                 }
[16:13:05.991]                 {
[16:13:05.991]                   {
[16:13:05.991]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:05.991]                     NULL
[16:13:05.991]                   }
[16:13:05.991]                   options(future.plan = NULL)
[16:13:05.991]                   if (is.na(NA_character_)) 
[16:13:05.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:05.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:05.991]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:05.991]                   {
[16:13:05.991]                     future <- SequentialFuture(..., envir = envir)
[16:13:05.991]                     if (!future$lazy) 
[16:13:05.991]                       future <- run(future)
[16:13:05.991]                     invisible(future)
[16:13:05.991]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:05.991]                 }
[16:13:05.991]             }
[16:13:05.991]         }
[16:13:05.991]     })
[16:13:05.991]     if (TRUE) {
[16:13:05.991]         base::sink(type = "output", split = FALSE)
[16:13:05.991]         if (TRUE) {
[16:13:05.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:05.991]         }
[16:13:05.991]         else {
[16:13:05.991]             ...future.result["stdout"] <- base::list(NULL)
[16:13:05.991]         }
[16:13:05.991]         base::close(...future.stdout)
[16:13:05.991]         ...future.stdout <- NULL
[16:13:05.991]     }
[16:13:05.991]     ...future.result$conditions <- ...future.conditions
[16:13:05.991]     ...future.result$finished <- base::Sys.time()
[16:13:05.991]     ...future.result
[16:13:05.991] }
[16:13:06.061] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:13:06.061] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[16:13:06.062] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[16:13:06.062] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:13:06.063] MultisessionFuture started
 - Resolving 2 multisession futures
[16:13:06.063] result() for ClusterFuture ...
[16:13:06.063] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.063] - Validating connection of MultisessionFuture
[16:13:06.129] - received message: FutureResult
[16:13:06.129] - Received FutureResult
[16:13:06.129] - Erased future from FutureRegistry
[16:13:06.129] result() for ClusterFuture ...
[16:13:06.129] - result already collected: FutureResult
[16:13:06.130] result() for ClusterFuture ... done
[16:13:06.130] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.130] result() for ClusterFuture ... done
[16:13:06.130] result() for ClusterFuture ...
[16:13:06.130] - result already collected: FutureResult
[16:13:06.130] result() for ClusterFuture ... done
[16:13:06.130] result() for ClusterFuture ...
[16:13:06.130] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.131] - Validating connection of MultisessionFuture
[16:13:06.131] - received message: FutureResult
[16:13:06.131] - Received FutureResult
[16:13:06.131] - Erased future from FutureRegistry
[16:13:06.131] result() for ClusterFuture ...
[16:13:06.131] - result already collected: FutureResult
[16:13:06.131] result() for ClusterFuture ... done
[16:13:06.131] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.132] result() for ClusterFuture ... done
[16:13:06.132] result() for ClusterFuture ...
[16:13:06.132] - result already collected: FutureResult
[16:13:06.132] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[16:13:06.132] getGlobalsAndPackages() ...
[16:13:06.132] Searching for globals...
[16:13:06.133] - globals found: [1] ‘.libPaths’
[16:13:06.133] Searching for globals ... DONE
[16:13:06.133] Resolving globals: FALSE
[16:13:06.134] 
[16:13:06.134] 
[16:13:06.134] getGlobalsAndPackages() ... DONE
[16:13:06.134] run() for ‘Future’ ...
[16:13:06.134] - state: ‘created’
[16:13:06.135] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:13:06.135] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:06.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:13:06.135]   - Field: ‘label’
[16:13:06.135]   - Field: ‘local’
[16:13:06.135]   - Field: ‘owner’
[16:13:06.135]   - Field: ‘envir’
[16:13:06.136]   - Field: ‘packages’
[16:13:06.136]   - Field: ‘gc’
[16:13:06.136]   - Field: ‘conditions’
[16:13:06.136]   - Field: ‘expr’
[16:13:06.136]   - Field: ‘uuid’
[16:13:06.136]   - Field: ‘seed’
[16:13:06.136]   - Field: ‘version’
[16:13:06.136]   - Field: ‘result’
[16:13:06.137]   - Field: ‘asynchronous’
[16:13:06.137]   - Field: ‘calls’
[16:13:06.137]   - Field: ‘globals’
[16:13:06.137]   - Field: ‘stdout’
[16:13:06.137]   - Field: ‘earlySignal’
[16:13:06.137]   - Field: ‘lazy’
[16:13:06.137]   - Field: ‘state’
[16:13:06.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:13:06.138] - Launch lazy future ...
[16:13:06.138] Packages needed by the future expression (n = 0): <none>
[16:13:06.138] Packages needed by future strategies (n = 0): <none>
[16:13:06.138] {
[16:13:06.138]     {
[16:13:06.138]         {
[16:13:06.138]             ...future.startTime <- base::Sys.time()
[16:13:06.138]             {
[16:13:06.138]                 {
[16:13:06.138]                   {
[16:13:06.138]                     base::local({
[16:13:06.138]                       has_future <- base::requireNamespace("future", 
[16:13:06.138]                         quietly = TRUE)
[16:13:06.138]                       if (has_future) {
[16:13:06.138]                         ns <- base::getNamespace("future")
[16:13:06.138]                         version <- ns[[".package"]][["version"]]
[16:13:06.138]                         if (is.null(version)) 
[16:13:06.138]                           version <- utils::packageVersion("future")
[16:13:06.138]                       }
[16:13:06.138]                       else {
[16:13:06.138]                         version <- NULL
[16:13:06.138]                       }
[16:13:06.138]                       if (!has_future || version < "1.8.0") {
[16:13:06.138]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.138]                           "", base::R.version$version.string), 
[16:13:06.138]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:06.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.138]                             "release", "version")], collapse = " "), 
[16:13:06.138]                           hostname = base::Sys.info()[["nodename"]])
[16:13:06.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.138]                           info)
[16:13:06.138]                         info <- base::paste(info, collapse = "; ")
[16:13:06.138]                         if (!has_future) {
[16:13:06.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.138]                             info)
[16:13:06.138]                         }
[16:13:06.138]                         else {
[16:13:06.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.138]                             info, version)
[16:13:06.138]                         }
[16:13:06.138]                         base::stop(msg)
[16:13:06.138]                       }
[16:13:06.138]                     })
[16:13:06.138]                   }
[16:13:06.138]                   options(future.plan = NULL)
[16:13:06.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.138]                 }
[16:13:06.138]                 ...future.workdir <- getwd()
[16:13:06.138]             }
[16:13:06.138]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.138]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.138]         }
[16:13:06.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.138]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.138]             base::names(...future.oldOptions))
[16:13:06.138]     }
[16:13:06.138]     if (FALSE) {
[16:13:06.138]     }
[16:13:06.138]     else {
[16:13:06.138]         if (TRUE) {
[16:13:06.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.138]                 open = "w")
[16:13:06.138]         }
[16:13:06.138]         else {
[16:13:06.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.138]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.138]         }
[16:13:06.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.138]             base::sink(type = "output", split = FALSE)
[16:13:06.138]             base::close(...future.stdout)
[16:13:06.138]         }, add = TRUE)
[16:13:06.138]     }
[16:13:06.138]     ...future.frame <- base::sys.nframe()
[16:13:06.138]     ...future.conditions <- base::list()
[16:13:06.138]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.138]     if (FALSE) {
[16:13:06.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.138]     }
[16:13:06.138]     ...future.result <- base::tryCatch({
[16:13:06.138]         base::withCallingHandlers({
[16:13:06.138]             ...future.value <- base::withVisible(base::local(.libPaths()))
[16:13:06.138]             future::FutureResult(value = ...future.value$value, 
[16:13:06.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.138]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.138]                     ...future.globalenv.names))
[16:13:06.138]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.138]         }, condition = base::local({
[16:13:06.138]             c <- base::c
[16:13:06.138]             inherits <- base::inherits
[16:13:06.138]             invokeRestart <- base::invokeRestart
[16:13:06.138]             length <- base::length
[16:13:06.138]             list <- base::list
[16:13:06.138]             seq.int <- base::seq.int
[16:13:06.138]             signalCondition <- base::signalCondition
[16:13:06.138]             sys.calls <- base::sys.calls
[16:13:06.138]             `[[` <- base::`[[`
[16:13:06.138]             `+` <- base::`+`
[16:13:06.138]             `<<-` <- base::`<<-`
[16:13:06.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.138]                   3L)]
[16:13:06.138]             }
[16:13:06.138]             function(cond) {
[16:13:06.138]                 is_error <- inherits(cond, "error")
[16:13:06.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.138]                   NULL)
[16:13:06.138]                 if (is_error) {
[16:13:06.138]                   sessionInformation <- function() {
[16:13:06.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.138]                       search = base::search(), system = base::Sys.info())
[16:13:06.138]                   }
[16:13:06.138]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.138]                     cond$call), session = sessionInformation(), 
[16:13:06.138]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.138]                   signalCondition(cond)
[16:13:06.138]                 }
[16:13:06.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.138]                 "immediateCondition"))) {
[16:13:06.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.138]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.138]                   if (TRUE && !signal) {
[16:13:06.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.138]                     {
[16:13:06.138]                       inherits <- base::inherits
[16:13:06.138]                       invokeRestart <- base::invokeRestart
[16:13:06.138]                       is.null <- base::is.null
[16:13:06.138]                       muffled <- FALSE
[16:13:06.138]                       if (inherits(cond, "message")) {
[16:13:06.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.138]                         if (muffled) 
[16:13:06.138]                           invokeRestart("muffleMessage")
[16:13:06.138]                       }
[16:13:06.138]                       else if (inherits(cond, "warning")) {
[16:13:06.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.138]                         if (muffled) 
[16:13:06.138]                           invokeRestart("muffleWarning")
[16:13:06.138]                       }
[16:13:06.138]                       else if (inherits(cond, "condition")) {
[16:13:06.138]                         if (!is.null(pattern)) {
[16:13:06.138]                           computeRestarts <- base::computeRestarts
[16:13:06.138]                           grepl <- base::grepl
[16:13:06.138]                           restarts <- computeRestarts(cond)
[16:13:06.138]                           for (restart in restarts) {
[16:13:06.138]                             name <- restart$name
[16:13:06.138]                             if (is.null(name)) 
[16:13:06.138]                               next
[16:13:06.138]                             if (!grepl(pattern, name)) 
[16:13:06.138]                               next
[16:13:06.138]                             invokeRestart(restart)
[16:13:06.138]                             muffled <- TRUE
[16:13:06.138]                             break
[16:13:06.138]                           }
[16:13:06.138]                         }
[16:13:06.138]                       }
[16:13:06.138]                       invisible(muffled)
[16:13:06.138]                     }
[16:13:06.138]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.138]                   }
[16:13:06.138]                 }
[16:13:06.138]                 else {
[16:13:06.138]                   if (TRUE) {
[16:13:06.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.138]                     {
[16:13:06.138]                       inherits <- base::inherits
[16:13:06.138]                       invokeRestart <- base::invokeRestart
[16:13:06.138]                       is.null <- base::is.null
[16:13:06.138]                       muffled <- FALSE
[16:13:06.138]                       if (inherits(cond, "message")) {
[16:13:06.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.138]                         if (muffled) 
[16:13:06.138]                           invokeRestart("muffleMessage")
[16:13:06.138]                       }
[16:13:06.138]                       else if (inherits(cond, "warning")) {
[16:13:06.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.138]                         if (muffled) 
[16:13:06.138]                           invokeRestart("muffleWarning")
[16:13:06.138]                       }
[16:13:06.138]                       else if (inherits(cond, "condition")) {
[16:13:06.138]                         if (!is.null(pattern)) {
[16:13:06.138]                           computeRestarts <- base::computeRestarts
[16:13:06.138]                           grepl <- base::grepl
[16:13:06.138]                           restarts <- computeRestarts(cond)
[16:13:06.138]                           for (restart in restarts) {
[16:13:06.138]                             name <- restart$name
[16:13:06.138]                             if (is.null(name)) 
[16:13:06.138]                               next
[16:13:06.138]                             if (!grepl(pattern, name)) 
[16:13:06.138]                               next
[16:13:06.138]                             invokeRestart(restart)
[16:13:06.138]                             muffled <- TRUE
[16:13:06.138]                             break
[16:13:06.138]                           }
[16:13:06.138]                         }
[16:13:06.138]                       }
[16:13:06.138]                       invisible(muffled)
[16:13:06.138]                     }
[16:13:06.138]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.138]                   }
[16:13:06.138]                 }
[16:13:06.138]             }
[16:13:06.138]         }))
[16:13:06.138]     }, error = function(ex) {
[16:13:06.138]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.138]                 ...future.rng), started = ...future.startTime, 
[16:13:06.138]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.138]             version = "1.8"), class = "FutureResult")
[16:13:06.138]     }, finally = {
[16:13:06.138]         if (!identical(...future.workdir, getwd())) 
[16:13:06.138]             setwd(...future.workdir)
[16:13:06.138]         {
[16:13:06.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.138]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.138]             }
[16:13:06.138]             base::options(...future.oldOptions)
[16:13:06.138]             if (.Platform$OS.type == "windows") {
[16:13:06.138]                 old_names <- names(...future.oldEnvVars)
[16:13:06.138]                 envs <- base::Sys.getenv()
[16:13:06.138]                 names <- names(envs)
[16:13:06.138]                 common <- intersect(names, old_names)
[16:13:06.138]                 added <- setdiff(names, old_names)
[16:13:06.138]                 removed <- setdiff(old_names, names)
[16:13:06.138]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.138]                   envs[common]]
[16:13:06.138]                 NAMES <- toupper(changed)
[16:13:06.138]                 args <- list()
[16:13:06.138]                 for (kk in seq_along(NAMES)) {
[16:13:06.138]                   name <- changed[[kk]]
[16:13:06.138]                   NAME <- NAMES[[kk]]
[16:13:06.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.138]                     next
[16:13:06.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.138]                 }
[16:13:06.138]                 NAMES <- toupper(added)
[16:13:06.138]                 for (kk in seq_along(NAMES)) {
[16:13:06.138]                   name <- added[[kk]]
[16:13:06.138]                   NAME <- NAMES[[kk]]
[16:13:06.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.138]                     next
[16:13:06.138]                   args[[name]] <- ""
[16:13:06.138]                 }
[16:13:06.138]                 NAMES <- toupper(removed)
[16:13:06.138]                 for (kk in seq_along(NAMES)) {
[16:13:06.138]                   name <- removed[[kk]]
[16:13:06.138]                   NAME <- NAMES[[kk]]
[16:13:06.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.138]                     next
[16:13:06.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.138]                 }
[16:13:06.138]                 if (length(args) > 0) 
[16:13:06.138]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.138]             }
[16:13:06.138]             else {
[16:13:06.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.138]             }
[16:13:06.138]             {
[16:13:06.138]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.138]                   0L) {
[16:13:06.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.138]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.138]                   base::options(opts)
[16:13:06.138]                 }
[16:13:06.138]                 {
[16:13:06.138]                   {
[16:13:06.138]                     NULL
[16:13:06.138]                     RNGkind("Mersenne-Twister")
[16:13:06.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:06.138]                       inherits = FALSE)
[16:13:06.138]                   }
[16:13:06.138]                   options(future.plan = NULL)
[16:13:06.138]                   if (is.na(NA_character_)) 
[16:13:06.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.138]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:06.138]                   {
[16:13:06.138]                     future <- SequentialFuture(..., envir = envir)
[16:13:06.138]                     if (!future$lazy) 
[16:13:06.138]                       future <- run(future)
[16:13:06.138]                     invisible(future)
[16:13:06.138]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:06.138]                 }
[16:13:06.138]             }
[16:13:06.138]         }
[16:13:06.138]     })
[16:13:06.138]     if (TRUE) {
[16:13:06.138]         base::sink(type = "output", split = FALSE)
[16:13:06.138]         if (TRUE) {
[16:13:06.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.138]         }
[16:13:06.138]         else {
[16:13:06.138]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.138]         }
[16:13:06.138]         base::close(...future.stdout)
[16:13:06.138]         ...future.stdout <- NULL
[16:13:06.138]     }
[16:13:06.138]     ...future.result$conditions <- ...future.conditions
[16:13:06.138]     ...future.result$finished <- base::Sys.time()
[16:13:06.138]     ...future.result
[16:13:06.138] }
[16:13:06.141] plan(): Setting new future strategy stack:
[16:13:06.141] List of future strategies:
[16:13:06.141] 1. sequential:
[16:13:06.141]    - args: function (..., envir = parent.frame())
[16:13:06.141]    - tweaked: FALSE
[16:13:06.141]    - call: NULL
[16:13:06.143] plan(): nbrOfWorkers() = 1
[16:13:06.144] plan(): Setting new future strategy stack:
[16:13:06.144] List of future strategies:
[16:13:06.144] 1. sequential:
[16:13:06.144]    - args: function (..., envir = parent.frame())
[16:13:06.144]    - tweaked: FALSE
[16:13:06.144]    - call: future::plan("sequential")
[16:13:06.145] plan(): nbrOfWorkers() = 1
[16:13:06.145] SequentialFuture started (and completed)
[16:13:06.145] - Launch lazy future ... done
[16:13:06.145] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[16:13:06.149] getGlobalsAndPackages() ...
[16:13:06.150] 
[16:13:06.150] - globals: [0] <none>
[16:13:06.150] getGlobalsAndPackages() ... DONE
[16:13:06.161] Packages needed by the future expression (n = 0): <none>
[16:13:06.161] Packages needed by future strategies (n = 0): <none>
[16:13:06.161] {
[16:13:06.161]     {
[16:13:06.161]         {
[16:13:06.161]             ...future.startTime <- base::Sys.time()
[16:13:06.161]             {
[16:13:06.161]                 {
[16:13:06.161]                   {
[16:13:06.161]                     {
[16:13:06.161]                       base::local({
[16:13:06.161]                         has_future <- base::requireNamespace("future", 
[16:13:06.161]                           quietly = TRUE)
[16:13:06.161]                         if (has_future) {
[16:13:06.161]                           ns <- base::getNamespace("future")
[16:13:06.161]                           version <- ns[[".package"]][["version"]]
[16:13:06.161]                           if (is.null(version)) 
[16:13:06.161]                             version <- utils::packageVersion("future")
[16:13:06.161]                         }
[16:13:06.161]                         else {
[16:13:06.161]                           version <- NULL
[16:13:06.161]                         }
[16:13:06.161]                         if (!has_future || version < "1.8.0") {
[16:13:06.161]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.161]                             "", base::R.version$version.string), 
[16:13:06.161]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.161]                               "release", "version")], collapse = " "), 
[16:13:06.161]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.161]                             info)
[16:13:06.161]                           info <- base::paste(info, collapse = "; ")
[16:13:06.161]                           if (!has_future) {
[16:13:06.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.161]                               info)
[16:13:06.161]                           }
[16:13:06.161]                           else {
[16:13:06.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.161]                               info, version)
[16:13:06.161]                           }
[16:13:06.161]                           base::stop(msg)
[16:13:06.161]                         }
[16:13:06.161]                       })
[16:13:06.161]                     }
[16:13:06.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.161]                     base::options(mc.cores = 1L)
[16:13:06.161]                   }
[16:13:06.161]                   options(future.plan = NULL)
[16:13:06.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.161]                 }
[16:13:06.161]                 ...future.workdir <- getwd()
[16:13:06.161]             }
[16:13:06.161]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.161]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.161]         }
[16:13:06.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.161]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.161]             base::names(...future.oldOptions))
[16:13:06.161]     }
[16:13:06.161]     if (FALSE) {
[16:13:06.161]     }
[16:13:06.161]     else {
[16:13:06.161]         if (TRUE) {
[16:13:06.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.161]                 open = "w")
[16:13:06.161]         }
[16:13:06.161]         else {
[16:13:06.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.161]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.161]         }
[16:13:06.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.161]             base::sink(type = "output", split = FALSE)
[16:13:06.161]             base::close(...future.stdout)
[16:13:06.161]         }, add = TRUE)
[16:13:06.161]     }
[16:13:06.161]     ...future.frame <- base::sys.nframe()
[16:13:06.161]     ...future.conditions <- base::list()
[16:13:06.161]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.161]     if (FALSE) {
[16:13:06.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.161]     }
[16:13:06.161]     ...future.result <- base::tryCatch({
[16:13:06.161]         base::withCallingHandlers({
[16:13:06.161]             ...future.value <- base::withVisible(base::local({
[16:13:06.161]                 ...future.makeSendCondition <- local({
[16:13:06.161]                   sendCondition <- NULL
[16:13:06.161]                   function(frame = 1L) {
[16:13:06.161]                     if (is.function(sendCondition)) 
[16:13:06.161]                       return(sendCondition)
[16:13:06.161]                     ns <- getNamespace("parallel")
[16:13:06.161]                     if (exists("sendData", mode = "function", 
[16:13:06.161]                       envir = ns)) {
[16:13:06.161]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.161]                         envir = ns)
[16:13:06.161]                       envir <- sys.frame(frame)
[16:13:06.161]                       master <- NULL
[16:13:06.161]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.161]                         !identical(envir, emptyenv())) {
[16:13:06.161]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.161]                           inherits = FALSE)) {
[16:13:06.161]                           master <- get("master", mode = "list", 
[16:13:06.161]                             envir = envir, inherits = FALSE)
[16:13:06.161]                           if (inherits(master, c("SOCKnode", 
[16:13:06.161]                             "SOCK0node"))) {
[16:13:06.161]                             sendCondition <<- function(cond) {
[16:13:06.161]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.161]                                 success = TRUE)
[16:13:06.161]                               parallel_sendData(master, data)
[16:13:06.161]                             }
[16:13:06.161]                             return(sendCondition)
[16:13:06.161]                           }
[16:13:06.161]                         }
[16:13:06.161]                         frame <- frame + 1L
[16:13:06.161]                         envir <- sys.frame(frame)
[16:13:06.161]                       }
[16:13:06.161]                     }
[16:13:06.161]                     sendCondition <<- function(cond) NULL
[16:13:06.161]                   }
[16:13:06.161]                 })
[16:13:06.161]                 withCallingHandlers({
[16:13:06.161]                   {
[16:13:06.161]                     stop("Whoops!")
[16:13:06.161]                     1
[16:13:06.161]                   }
[16:13:06.161]                 }, immediateCondition = function(cond) {
[16:13:06.161]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.161]                   sendCondition(cond)
[16:13:06.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.161]                   {
[16:13:06.161]                     inherits <- base::inherits
[16:13:06.161]                     invokeRestart <- base::invokeRestart
[16:13:06.161]                     is.null <- base::is.null
[16:13:06.161]                     muffled <- FALSE
[16:13:06.161]                     if (inherits(cond, "message")) {
[16:13:06.161]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.161]                       if (muffled) 
[16:13:06.161]                         invokeRestart("muffleMessage")
[16:13:06.161]                     }
[16:13:06.161]                     else if (inherits(cond, "warning")) {
[16:13:06.161]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.161]                       if (muffled) 
[16:13:06.161]                         invokeRestart("muffleWarning")
[16:13:06.161]                     }
[16:13:06.161]                     else if (inherits(cond, "condition")) {
[16:13:06.161]                       if (!is.null(pattern)) {
[16:13:06.161]                         computeRestarts <- base::computeRestarts
[16:13:06.161]                         grepl <- base::grepl
[16:13:06.161]                         restarts <- computeRestarts(cond)
[16:13:06.161]                         for (restart in restarts) {
[16:13:06.161]                           name <- restart$name
[16:13:06.161]                           if (is.null(name)) 
[16:13:06.161]                             next
[16:13:06.161]                           if (!grepl(pattern, name)) 
[16:13:06.161]                             next
[16:13:06.161]                           invokeRestart(restart)
[16:13:06.161]                           muffled <- TRUE
[16:13:06.161]                           break
[16:13:06.161]                         }
[16:13:06.161]                       }
[16:13:06.161]                     }
[16:13:06.161]                     invisible(muffled)
[16:13:06.161]                   }
[16:13:06.161]                   muffleCondition(cond)
[16:13:06.161]                 })
[16:13:06.161]             }))
[16:13:06.161]             future::FutureResult(value = ...future.value$value, 
[16:13:06.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.161]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.161]                     ...future.globalenv.names))
[16:13:06.161]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.161]         }, condition = base::local({
[16:13:06.161]             c <- base::c
[16:13:06.161]             inherits <- base::inherits
[16:13:06.161]             invokeRestart <- base::invokeRestart
[16:13:06.161]             length <- base::length
[16:13:06.161]             list <- base::list
[16:13:06.161]             seq.int <- base::seq.int
[16:13:06.161]             signalCondition <- base::signalCondition
[16:13:06.161]             sys.calls <- base::sys.calls
[16:13:06.161]             `[[` <- base::`[[`
[16:13:06.161]             `+` <- base::`+`
[16:13:06.161]             `<<-` <- base::`<<-`
[16:13:06.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.161]                   3L)]
[16:13:06.161]             }
[16:13:06.161]             function(cond) {
[16:13:06.161]                 is_error <- inherits(cond, "error")
[16:13:06.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.161]                   NULL)
[16:13:06.161]                 if (is_error) {
[16:13:06.161]                   sessionInformation <- function() {
[16:13:06.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.161]                       search = base::search(), system = base::Sys.info())
[16:13:06.161]                   }
[16:13:06.161]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.161]                     cond$call), session = sessionInformation(), 
[16:13:06.161]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.161]                   signalCondition(cond)
[16:13:06.161]                 }
[16:13:06.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.161]                 "immediateCondition"))) {
[16:13:06.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.161]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.161]                   if (TRUE && !signal) {
[16:13:06.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.161]                     {
[16:13:06.161]                       inherits <- base::inherits
[16:13:06.161]                       invokeRestart <- base::invokeRestart
[16:13:06.161]                       is.null <- base::is.null
[16:13:06.161]                       muffled <- FALSE
[16:13:06.161]                       if (inherits(cond, "message")) {
[16:13:06.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.161]                         if (muffled) 
[16:13:06.161]                           invokeRestart("muffleMessage")
[16:13:06.161]                       }
[16:13:06.161]                       else if (inherits(cond, "warning")) {
[16:13:06.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.161]                         if (muffled) 
[16:13:06.161]                           invokeRestart("muffleWarning")
[16:13:06.161]                       }
[16:13:06.161]                       else if (inherits(cond, "condition")) {
[16:13:06.161]                         if (!is.null(pattern)) {
[16:13:06.161]                           computeRestarts <- base::computeRestarts
[16:13:06.161]                           grepl <- base::grepl
[16:13:06.161]                           restarts <- computeRestarts(cond)
[16:13:06.161]                           for (restart in restarts) {
[16:13:06.161]                             name <- restart$name
[16:13:06.161]                             if (is.null(name)) 
[16:13:06.161]                               next
[16:13:06.161]                             if (!grepl(pattern, name)) 
[16:13:06.161]                               next
[16:13:06.161]                             invokeRestart(restart)
[16:13:06.161]                             muffled <- TRUE
[16:13:06.161]                             break
[16:13:06.161]                           }
[16:13:06.161]                         }
[16:13:06.161]                       }
[16:13:06.161]                       invisible(muffled)
[16:13:06.161]                     }
[16:13:06.161]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.161]                   }
[16:13:06.161]                 }
[16:13:06.161]                 else {
[16:13:06.161]                   if (TRUE) {
[16:13:06.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.161]                     {
[16:13:06.161]                       inherits <- base::inherits
[16:13:06.161]                       invokeRestart <- base::invokeRestart
[16:13:06.161]                       is.null <- base::is.null
[16:13:06.161]                       muffled <- FALSE
[16:13:06.161]                       if (inherits(cond, "message")) {
[16:13:06.161]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.161]                         if (muffled) 
[16:13:06.161]                           invokeRestart("muffleMessage")
[16:13:06.161]                       }
[16:13:06.161]                       else if (inherits(cond, "warning")) {
[16:13:06.161]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.161]                         if (muffled) 
[16:13:06.161]                           invokeRestart("muffleWarning")
[16:13:06.161]                       }
[16:13:06.161]                       else if (inherits(cond, "condition")) {
[16:13:06.161]                         if (!is.null(pattern)) {
[16:13:06.161]                           computeRestarts <- base::computeRestarts
[16:13:06.161]                           grepl <- base::grepl
[16:13:06.161]                           restarts <- computeRestarts(cond)
[16:13:06.161]                           for (restart in restarts) {
[16:13:06.161]                             name <- restart$name
[16:13:06.161]                             if (is.null(name)) 
[16:13:06.161]                               next
[16:13:06.161]                             if (!grepl(pattern, name)) 
[16:13:06.161]                               next
[16:13:06.161]                             invokeRestart(restart)
[16:13:06.161]                             muffled <- TRUE
[16:13:06.161]                             break
[16:13:06.161]                           }
[16:13:06.161]                         }
[16:13:06.161]                       }
[16:13:06.161]                       invisible(muffled)
[16:13:06.161]                     }
[16:13:06.161]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.161]                   }
[16:13:06.161]                 }
[16:13:06.161]             }
[16:13:06.161]         }))
[16:13:06.161]     }, error = function(ex) {
[16:13:06.161]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.161]                 ...future.rng), started = ...future.startTime, 
[16:13:06.161]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.161]             version = "1.8"), class = "FutureResult")
[16:13:06.161]     }, finally = {
[16:13:06.161]         if (!identical(...future.workdir, getwd())) 
[16:13:06.161]             setwd(...future.workdir)
[16:13:06.161]         {
[16:13:06.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.161]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.161]             }
[16:13:06.161]             base::options(...future.oldOptions)
[16:13:06.161]             if (.Platform$OS.type == "windows") {
[16:13:06.161]                 old_names <- names(...future.oldEnvVars)
[16:13:06.161]                 envs <- base::Sys.getenv()
[16:13:06.161]                 names <- names(envs)
[16:13:06.161]                 common <- intersect(names, old_names)
[16:13:06.161]                 added <- setdiff(names, old_names)
[16:13:06.161]                 removed <- setdiff(old_names, names)
[16:13:06.161]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.161]                   envs[common]]
[16:13:06.161]                 NAMES <- toupper(changed)
[16:13:06.161]                 args <- list()
[16:13:06.161]                 for (kk in seq_along(NAMES)) {
[16:13:06.161]                   name <- changed[[kk]]
[16:13:06.161]                   NAME <- NAMES[[kk]]
[16:13:06.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.161]                     next
[16:13:06.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.161]                 }
[16:13:06.161]                 NAMES <- toupper(added)
[16:13:06.161]                 for (kk in seq_along(NAMES)) {
[16:13:06.161]                   name <- added[[kk]]
[16:13:06.161]                   NAME <- NAMES[[kk]]
[16:13:06.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.161]                     next
[16:13:06.161]                   args[[name]] <- ""
[16:13:06.161]                 }
[16:13:06.161]                 NAMES <- toupper(removed)
[16:13:06.161]                 for (kk in seq_along(NAMES)) {
[16:13:06.161]                   name <- removed[[kk]]
[16:13:06.161]                   NAME <- NAMES[[kk]]
[16:13:06.161]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.161]                     next
[16:13:06.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.161]                 }
[16:13:06.161]                 if (length(args) > 0) 
[16:13:06.161]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.161]             }
[16:13:06.161]             else {
[16:13:06.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.161]             }
[16:13:06.161]             {
[16:13:06.161]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.161]                   0L) {
[16:13:06.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.161]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.161]                   base::options(opts)
[16:13:06.161]                 }
[16:13:06.161]                 {
[16:13:06.161]                   {
[16:13:06.161]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.161]                     NULL
[16:13:06.161]                   }
[16:13:06.161]                   options(future.plan = NULL)
[16:13:06.161]                   if (is.na(NA_character_)) 
[16:13:06.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.161]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:06.161]                   {
[16:13:06.161]                     future <- SequentialFuture(..., envir = envir)
[16:13:06.161]                     if (!future$lazy) 
[16:13:06.161]                       future <- run(future)
[16:13:06.161]                     invisible(future)
[16:13:06.161]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:06.161]                 }
[16:13:06.161]             }
[16:13:06.161]         }
[16:13:06.161]     })
[16:13:06.161]     if (TRUE) {
[16:13:06.161]         base::sink(type = "output", split = FALSE)
[16:13:06.161]         if (TRUE) {
[16:13:06.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.161]         }
[16:13:06.161]         else {
[16:13:06.161]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.161]         }
[16:13:06.161]         base::close(...future.stdout)
[16:13:06.161]         ...future.stdout <- NULL
[16:13:06.161]     }
[16:13:06.161]     ...future.result$conditions <- ...future.conditions
[16:13:06.161]     ...future.result$finished <- base::Sys.time()
[16:13:06.161]     ...future.result
[16:13:06.161] }
[16:13:06.164] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:06.175] result() for ClusterFuture ...
[16:13:06.176] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.176] - Validating connection of MultisessionFuture
[16:13:06.210] - received message: FutureResult
[16:13:06.210] - Received FutureResult
[16:13:06.210] - Erased future from FutureRegistry
[16:13:06.210] result() for ClusterFuture ...
[16:13:06.210] - result already collected: FutureResult
[16:13:06.210] result() for ClusterFuture ... done
[16:13:06.211] signalConditions() ...
[16:13:06.211]  - include = ‘immediateCondition’
[16:13:06.211]  - exclude = 
[16:13:06.211]  - resignal = FALSE
[16:13:06.211]  - Number of conditions: 1
[16:13:06.211] signalConditions() ... done
[16:13:06.211] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.211] result() for ClusterFuture ... done
[16:13:06.211] result() for ClusterFuture ...
[16:13:06.211] - result already collected: FutureResult
[16:13:06.211] result() for ClusterFuture ... done
[16:13:06.211] signalConditions() ...
[16:13:06.212]  - include = ‘immediateCondition’
[16:13:06.212]  - exclude = 
[16:13:06.212]  - resignal = FALSE
[16:13:06.212]  - Number of conditions: 1
[16:13:06.212] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:06.212] result() for ClusterFuture ...
[16:13:06.212] - result already collected: FutureResult
[16:13:06.213] result() for ClusterFuture ... done
[16:13:06.213] result() for ClusterFuture ...
[16:13:06.213] - result already collected: FutureResult
[16:13:06.213] result() for ClusterFuture ... done
[16:13:06.213] signalConditions() ...
[16:13:06.213]  - include = ‘immediateCondition’
[16:13:06.213]  - exclude = 
[16:13:06.213]  - resignal = FALSE
[16:13:06.213]  - Number of conditions: 1
[16:13:06.213] signalConditions() ... done
[16:13:06.213] Future state: ‘finished’
[16:13:06.214] result() for ClusterFuture ...
[16:13:06.214] - result already collected: FutureResult
[16:13:06.214] result() for ClusterFuture ... done
[16:13:06.214] signalConditions() ...
[16:13:06.214]  - include = ‘condition’
[16:13:06.214]  - exclude = ‘immediateCondition’
[16:13:06.214]  - resignal = TRUE
[16:13:06.214]  - Number of conditions: 1
[16:13:06.214]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:06.214] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:06.215] result() for ClusterFuture ...
[16:13:06.215] - result already collected: FutureResult
[16:13:06.215] result() for ClusterFuture ... done
[16:13:06.215] result() for ClusterFuture ...
[16:13:06.215] - result already collected: FutureResult
[16:13:06.215] result() for ClusterFuture ... done
[16:13:06.215] signalConditions() ...
[16:13:06.215]  - include = ‘immediateCondition’
[16:13:06.216]  - exclude = 
[16:13:06.216]  - resignal = FALSE
[16:13:06.216]  - Number of conditions: 1
[16:13:06.216] signalConditions() ... done
[16:13:06.216] Future state: ‘finished’
[16:13:06.216] result() for ClusterFuture ...
[16:13:06.216] - result already collected: FutureResult
[16:13:06.216] result() for ClusterFuture ... done
[16:13:06.216] signalConditions() ...
[16:13:06.216]  - include = ‘condition’
[16:13:06.216]  - exclude = ‘immediateCondition’
[16:13:06.217]  - resignal = TRUE
[16:13:06.217]  - Number of conditions: 1
[16:13:06.217]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:13:06.217] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:13:06.220] getGlobalsAndPackages() ...
[16:13:06.221] 
[16:13:06.221] - globals: [0] <none>
[16:13:06.221] getGlobalsAndPackages() ... DONE
[16:13:06.232] Packages needed by the future expression (n = 0): <none>
[16:13:06.232] Packages needed by future strategies (n = 0): <none>
[16:13:06.232] {
[16:13:06.232]     {
[16:13:06.232]         {
[16:13:06.232]             ...future.startTime <- base::Sys.time()
[16:13:06.232]             {
[16:13:06.232]                 {
[16:13:06.232]                   {
[16:13:06.232]                     {
[16:13:06.232]                       base::local({
[16:13:06.232]                         has_future <- base::requireNamespace("future", 
[16:13:06.232]                           quietly = TRUE)
[16:13:06.232]                         if (has_future) {
[16:13:06.232]                           ns <- base::getNamespace("future")
[16:13:06.232]                           version <- ns[[".package"]][["version"]]
[16:13:06.232]                           if (is.null(version)) 
[16:13:06.232]                             version <- utils::packageVersion("future")
[16:13:06.232]                         }
[16:13:06.232]                         else {
[16:13:06.232]                           version <- NULL
[16:13:06.232]                         }
[16:13:06.232]                         if (!has_future || version < "1.8.0") {
[16:13:06.232]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.232]                             "", base::R.version$version.string), 
[16:13:06.232]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.232]                               "release", "version")], collapse = " "), 
[16:13:06.232]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.232]                             info)
[16:13:06.232]                           info <- base::paste(info, collapse = "; ")
[16:13:06.232]                           if (!has_future) {
[16:13:06.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.232]                               info)
[16:13:06.232]                           }
[16:13:06.232]                           else {
[16:13:06.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.232]                               info, version)
[16:13:06.232]                           }
[16:13:06.232]                           base::stop(msg)
[16:13:06.232]                         }
[16:13:06.232]                       })
[16:13:06.232]                     }
[16:13:06.232]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.232]                     base::options(mc.cores = 1L)
[16:13:06.232]                   }
[16:13:06.232]                   options(future.plan = NULL)
[16:13:06.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.232]                 }
[16:13:06.232]                 ...future.workdir <- getwd()
[16:13:06.232]             }
[16:13:06.232]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.232]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.232]         }
[16:13:06.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.232]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.232]             base::names(...future.oldOptions))
[16:13:06.232]     }
[16:13:06.232]     if (FALSE) {
[16:13:06.232]     }
[16:13:06.232]     else {
[16:13:06.232]         if (TRUE) {
[16:13:06.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.232]                 open = "w")
[16:13:06.232]         }
[16:13:06.232]         else {
[16:13:06.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.232]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.232]         }
[16:13:06.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.232]             base::sink(type = "output", split = FALSE)
[16:13:06.232]             base::close(...future.stdout)
[16:13:06.232]         }, add = TRUE)
[16:13:06.232]     }
[16:13:06.232]     ...future.frame <- base::sys.nframe()
[16:13:06.232]     ...future.conditions <- base::list()
[16:13:06.232]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.232]     if (FALSE) {
[16:13:06.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.232]     }
[16:13:06.232]     ...future.result <- base::tryCatch({
[16:13:06.232]         base::withCallingHandlers({
[16:13:06.232]             ...future.value <- base::withVisible(base::local({
[16:13:06.232]                 ...future.makeSendCondition <- local({
[16:13:06.232]                   sendCondition <- NULL
[16:13:06.232]                   function(frame = 1L) {
[16:13:06.232]                     if (is.function(sendCondition)) 
[16:13:06.232]                       return(sendCondition)
[16:13:06.232]                     ns <- getNamespace("parallel")
[16:13:06.232]                     if (exists("sendData", mode = "function", 
[16:13:06.232]                       envir = ns)) {
[16:13:06.232]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.232]                         envir = ns)
[16:13:06.232]                       envir <- sys.frame(frame)
[16:13:06.232]                       master <- NULL
[16:13:06.232]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.232]                         !identical(envir, emptyenv())) {
[16:13:06.232]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.232]                           inherits = FALSE)) {
[16:13:06.232]                           master <- get("master", mode = "list", 
[16:13:06.232]                             envir = envir, inherits = FALSE)
[16:13:06.232]                           if (inherits(master, c("SOCKnode", 
[16:13:06.232]                             "SOCK0node"))) {
[16:13:06.232]                             sendCondition <<- function(cond) {
[16:13:06.232]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.232]                                 success = TRUE)
[16:13:06.232]                               parallel_sendData(master, data)
[16:13:06.232]                             }
[16:13:06.232]                             return(sendCondition)
[16:13:06.232]                           }
[16:13:06.232]                         }
[16:13:06.232]                         frame <- frame + 1L
[16:13:06.232]                         envir <- sys.frame(frame)
[16:13:06.232]                       }
[16:13:06.232]                     }
[16:13:06.232]                     sendCondition <<- function(cond) NULL
[16:13:06.232]                   }
[16:13:06.232]                 })
[16:13:06.232]                 withCallingHandlers({
[16:13:06.232]                   {
[16:13:06.232]                     stop(structure(list(message = "boom"), class = c("MyError", 
[16:13:06.232]                       "error", "condition")))
[16:13:06.232]                   }
[16:13:06.232]                 }, immediateCondition = function(cond) {
[16:13:06.232]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.232]                   sendCondition(cond)
[16:13:06.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.232]                   {
[16:13:06.232]                     inherits <- base::inherits
[16:13:06.232]                     invokeRestart <- base::invokeRestart
[16:13:06.232]                     is.null <- base::is.null
[16:13:06.232]                     muffled <- FALSE
[16:13:06.232]                     if (inherits(cond, "message")) {
[16:13:06.232]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.232]                       if (muffled) 
[16:13:06.232]                         invokeRestart("muffleMessage")
[16:13:06.232]                     }
[16:13:06.232]                     else if (inherits(cond, "warning")) {
[16:13:06.232]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.232]                       if (muffled) 
[16:13:06.232]                         invokeRestart("muffleWarning")
[16:13:06.232]                     }
[16:13:06.232]                     else if (inherits(cond, "condition")) {
[16:13:06.232]                       if (!is.null(pattern)) {
[16:13:06.232]                         computeRestarts <- base::computeRestarts
[16:13:06.232]                         grepl <- base::grepl
[16:13:06.232]                         restarts <- computeRestarts(cond)
[16:13:06.232]                         for (restart in restarts) {
[16:13:06.232]                           name <- restart$name
[16:13:06.232]                           if (is.null(name)) 
[16:13:06.232]                             next
[16:13:06.232]                           if (!grepl(pattern, name)) 
[16:13:06.232]                             next
[16:13:06.232]                           invokeRestart(restart)
[16:13:06.232]                           muffled <- TRUE
[16:13:06.232]                           break
[16:13:06.232]                         }
[16:13:06.232]                       }
[16:13:06.232]                     }
[16:13:06.232]                     invisible(muffled)
[16:13:06.232]                   }
[16:13:06.232]                   muffleCondition(cond)
[16:13:06.232]                 })
[16:13:06.232]             }))
[16:13:06.232]             future::FutureResult(value = ...future.value$value, 
[16:13:06.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.232]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.232]                     ...future.globalenv.names))
[16:13:06.232]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.232]         }, condition = base::local({
[16:13:06.232]             c <- base::c
[16:13:06.232]             inherits <- base::inherits
[16:13:06.232]             invokeRestart <- base::invokeRestart
[16:13:06.232]             length <- base::length
[16:13:06.232]             list <- base::list
[16:13:06.232]             seq.int <- base::seq.int
[16:13:06.232]             signalCondition <- base::signalCondition
[16:13:06.232]             sys.calls <- base::sys.calls
[16:13:06.232]             `[[` <- base::`[[`
[16:13:06.232]             `+` <- base::`+`
[16:13:06.232]             `<<-` <- base::`<<-`
[16:13:06.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.232]                   3L)]
[16:13:06.232]             }
[16:13:06.232]             function(cond) {
[16:13:06.232]                 is_error <- inherits(cond, "error")
[16:13:06.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.232]                   NULL)
[16:13:06.232]                 if (is_error) {
[16:13:06.232]                   sessionInformation <- function() {
[16:13:06.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.232]                       search = base::search(), system = base::Sys.info())
[16:13:06.232]                   }
[16:13:06.232]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.232]                     cond$call), session = sessionInformation(), 
[16:13:06.232]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.232]                   signalCondition(cond)
[16:13:06.232]                 }
[16:13:06.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.232]                 "immediateCondition"))) {
[16:13:06.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.232]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.232]                   if (TRUE && !signal) {
[16:13:06.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.232]                     {
[16:13:06.232]                       inherits <- base::inherits
[16:13:06.232]                       invokeRestart <- base::invokeRestart
[16:13:06.232]                       is.null <- base::is.null
[16:13:06.232]                       muffled <- FALSE
[16:13:06.232]                       if (inherits(cond, "message")) {
[16:13:06.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.232]                         if (muffled) 
[16:13:06.232]                           invokeRestart("muffleMessage")
[16:13:06.232]                       }
[16:13:06.232]                       else if (inherits(cond, "warning")) {
[16:13:06.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.232]                         if (muffled) 
[16:13:06.232]                           invokeRestart("muffleWarning")
[16:13:06.232]                       }
[16:13:06.232]                       else if (inherits(cond, "condition")) {
[16:13:06.232]                         if (!is.null(pattern)) {
[16:13:06.232]                           computeRestarts <- base::computeRestarts
[16:13:06.232]                           grepl <- base::grepl
[16:13:06.232]                           restarts <- computeRestarts(cond)
[16:13:06.232]                           for (restart in restarts) {
[16:13:06.232]                             name <- restart$name
[16:13:06.232]                             if (is.null(name)) 
[16:13:06.232]                               next
[16:13:06.232]                             if (!grepl(pattern, name)) 
[16:13:06.232]                               next
[16:13:06.232]                             invokeRestart(restart)
[16:13:06.232]                             muffled <- TRUE
[16:13:06.232]                             break
[16:13:06.232]                           }
[16:13:06.232]                         }
[16:13:06.232]                       }
[16:13:06.232]                       invisible(muffled)
[16:13:06.232]                     }
[16:13:06.232]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.232]                   }
[16:13:06.232]                 }
[16:13:06.232]                 else {
[16:13:06.232]                   if (TRUE) {
[16:13:06.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.232]                     {
[16:13:06.232]                       inherits <- base::inherits
[16:13:06.232]                       invokeRestart <- base::invokeRestart
[16:13:06.232]                       is.null <- base::is.null
[16:13:06.232]                       muffled <- FALSE
[16:13:06.232]                       if (inherits(cond, "message")) {
[16:13:06.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.232]                         if (muffled) 
[16:13:06.232]                           invokeRestart("muffleMessage")
[16:13:06.232]                       }
[16:13:06.232]                       else if (inherits(cond, "warning")) {
[16:13:06.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.232]                         if (muffled) 
[16:13:06.232]                           invokeRestart("muffleWarning")
[16:13:06.232]                       }
[16:13:06.232]                       else if (inherits(cond, "condition")) {
[16:13:06.232]                         if (!is.null(pattern)) {
[16:13:06.232]                           computeRestarts <- base::computeRestarts
[16:13:06.232]                           grepl <- base::grepl
[16:13:06.232]                           restarts <- computeRestarts(cond)
[16:13:06.232]                           for (restart in restarts) {
[16:13:06.232]                             name <- restart$name
[16:13:06.232]                             if (is.null(name)) 
[16:13:06.232]                               next
[16:13:06.232]                             if (!grepl(pattern, name)) 
[16:13:06.232]                               next
[16:13:06.232]                             invokeRestart(restart)
[16:13:06.232]                             muffled <- TRUE
[16:13:06.232]                             break
[16:13:06.232]                           }
[16:13:06.232]                         }
[16:13:06.232]                       }
[16:13:06.232]                       invisible(muffled)
[16:13:06.232]                     }
[16:13:06.232]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.232]                   }
[16:13:06.232]                 }
[16:13:06.232]             }
[16:13:06.232]         }))
[16:13:06.232]     }, error = function(ex) {
[16:13:06.232]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.232]                 ...future.rng), started = ...future.startTime, 
[16:13:06.232]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.232]             version = "1.8"), class = "FutureResult")
[16:13:06.232]     }, finally = {
[16:13:06.232]         if (!identical(...future.workdir, getwd())) 
[16:13:06.232]             setwd(...future.workdir)
[16:13:06.232]         {
[16:13:06.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.232]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.232]             }
[16:13:06.232]             base::options(...future.oldOptions)
[16:13:06.232]             if (.Platform$OS.type == "windows") {
[16:13:06.232]                 old_names <- names(...future.oldEnvVars)
[16:13:06.232]                 envs <- base::Sys.getenv()
[16:13:06.232]                 names <- names(envs)
[16:13:06.232]                 common <- intersect(names, old_names)
[16:13:06.232]                 added <- setdiff(names, old_names)
[16:13:06.232]                 removed <- setdiff(old_names, names)
[16:13:06.232]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.232]                   envs[common]]
[16:13:06.232]                 NAMES <- toupper(changed)
[16:13:06.232]                 args <- list()
[16:13:06.232]                 for (kk in seq_along(NAMES)) {
[16:13:06.232]                   name <- changed[[kk]]
[16:13:06.232]                   NAME <- NAMES[[kk]]
[16:13:06.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.232]                     next
[16:13:06.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.232]                 }
[16:13:06.232]                 NAMES <- toupper(added)
[16:13:06.232]                 for (kk in seq_along(NAMES)) {
[16:13:06.232]                   name <- added[[kk]]
[16:13:06.232]                   NAME <- NAMES[[kk]]
[16:13:06.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.232]                     next
[16:13:06.232]                   args[[name]] <- ""
[16:13:06.232]                 }
[16:13:06.232]                 NAMES <- toupper(removed)
[16:13:06.232]                 for (kk in seq_along(NAMES)) {
[16:13:06.232]                   name <- removed[[kk]]
[16:13:06.232]                   NAME <- NAMES[[kk]]
[16:13:06.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.232]                     next
[16:13:06.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.232]                 }
[16:13:06.232]                 if (length(args) > 0) 
[16:13:06.232]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.232]             }
[16:13:06.232]             else {
[16:13:06.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.232]             }
[16:13:06.232]             {
[16:13:06.232]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.232]                   0L) {
[16:13:06.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.232]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.232]                   base::options(opts)
[16:13:06.232]                 }
[16:13:06.232]                 {
[16:13:06.232]                   {
[16:13:06.232]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.232]                     NULL
[16:13:06.232]                   }
[16:13:06.232]                   options(future.plan = NULL)
[16:13:06.232]                   if (is.na(NA_character_)) 
[16:13:06.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.232]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:06.232]                   {
[16:13:06.232]                     future <- SequentialFuture(..., envir = envir)
[16:13:06.232]                     if (!future$lazy) 
[16:13:06.232]                       future <- run(future)
[16:13:06.232]                     invisible(future)
[16:13:06.232]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:06.232]                 }
[16:13:06.232]             }
[16:13:06.232]         }
[16:13:06.232]     })
[16:13:06.232]     if (TRUE) {
[16:13:06.232]         base::sink(type = "output", split = FALSE)
[16:13:06.232]         if (TRUE) {
[16:13:06.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.232]         }
[16:13:06.232]         else {
[16:13:06.232]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.232]         }
[16:13:06.232]         base::close(...future.stdout)
[16:13:06.232]         ...future.stdout <- NULL
[16:13:06.232]     }
[16:13:06.232]     ...future.result$conditions <- ...future.conditions
[16:13:06.232]     ...future.result$finished <- base::Sys.time()
[16:13:06.232]     ...future.result
[16:13:06.232] }
[16:13:06.235] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:06.237] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.237] - Validating connection of MultisessionFuture
[16:13:06.237] - received message: FutureResult
[16:13:06.237] - Received FutureResult
[16:13:06.237] - Erased future from FutureRegistry
[16:13:06.238] result() for ClusterFuture ...
[16:13:06.238] - result already collected: FutureResult
[16:13:06.238] result() for ClusterFuture ... done
[16:13:06.238] signalConditions() ...
[16:13:06.238]  - include = ‘immediateCondition’
[16:13:06.238]  - exclude = 
[16:13:06.238]  - resignal = FALSE
[16:13:06.238]  - Number of conditions: 1
[16:13:06.238] signalConditions() ... done
[16:13:06.238] receiveMessageFromWorker() for ClusterFuture ... done
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:06.239] result() for ClusterFuture ...
[16:13:06.239] - result already collected: FutureResult
[16:13:06.239] result() for ClusterFuture ... done
[16:13:06.239] result() for ClusterFuture ...
[16:13:06.239] - result already collected: FutureResult
[16:13:06.239] result() for ClusterFuture ... done
[16:13:06.239] signalConditions() ...
[16:13:06.239]  - include = ‘immediateCondition’
[16:13:06.239]  - exclude = 
[16:13:06.239]  - resignal = FALSE
[16:13:06.239]  - Number of conditions: 1
[16:13:06.239] signalConditions() ... done
<MyError: boom>
[16:13:06.240] result() for ClusterFuture ...
[16:13:06.240] - result already collected: FutureResult
[16:13:06.240] result() for ClusterFuture ... done
[16:13:06.240] result() for ClusterFuture ...
[16:13:06.240] - result already collected: FutureResult
[16:13:06.240] result() for ClusterFuture ... done
[16:13:06.240] signalConditions() ...
[16:13:06.240]  - include = ‘immediateCondition’
[16:13:06.240]  - exclude = 
[16:13:06.240]  - resignal = FALSE
[16:13:06.241]  - Number of conditions: 1
[16:13:06.241] signalConditions() ... done
[16:13:06.241] Future state: ‘finished’
[16:13:06.241] result() for ClusterFuture ...
[16:13:06.241] - result already collected: FutureResult
[16:13:06.241] result() for ClusterFuture ... done
[16:13:06.241] signalConditions() ...
[16:13:06.241]  - include = ‘condition’
[16:13:06.241]  - exclude = ‘immediateCondition’
[16:13:06.241]  - resignal = TRUE
[16:13:06.241]  - Number of conditions: 1
[16:13:06.242]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:13:06.242] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ...")
*** multisession() - too large globals ...
> ooptsT <- options(future.globals.maxSize = object.size(1:1014))
> 
> limit <- getOption("future.globals.maxSize")
> cat(sprintf("Max total size of globals: %g bytes\n", limit))
Max total size of globals: 4104 bytes
> 
> for (workers in unique(c(1L, availableCores()))) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message("Max number of sessions: ", workers)
+ 
+   ## A large object
+   a <- 1:1014
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   f <- multisession({ sum(a) }, globals = TRUE, workers = workers)
+   print(f)
+   rm(list = "a")
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+ 
+   ## A too large object
+   a <- 1:1015
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   res <- try(f <- multisession({ sum(a) }, globals = TRUE, workers = workers), silent = TRUE)
+   rm(list = "a")
+   stopifnot(inherits(res, "try-error"))
+ } ## for (workers in ...)
Max number of sessions: 1
a: 4104 bytes
[16:13:06.257] getGlobalsAndPackages() ...
[16:13:06.257] Searching for globals...
[16:13:06.258] - globals found: [3] ‘{’, ‘sum’, ‘a’
[16:13:06.258] Searching for globals ... DONE
[16:13:06.258] Resolving globals: FALSE
[16:13:06.259] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[16:13:06.259] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[16:13:06.259] - globals: [1] ‘a’
[16:13:06.259] 
[16:13:06.259] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:13:06.260] Packages needed by the future expression (n = 0): <none>
[16:13:06.260] Packages needed by future strategies (n = 0): <none>
[16:13:06.261] {
[16:13:06.261]     {
[16:13:06.261]         {
[16:13:06.261]             ...future.startTime <- base::Sys.time()
[16:13:06.261]             {
[16:13:06.261]                 {
[16:13:06.261]                   {
[16:13:06.261]                     base::local({
[16:13:06.261]                       has_future <- base::requireNamespace("future", 
[16:13:06.261]                         quietly = TRUE)
[16:13:06.261]                       if (has_future) {
[16:13:06.261]                         ns <- base::getNamespace("future")
[16:13:06.261]                         version <- ns[[".package"]][["version"]]
[16:13:06.261]                         if (is.null(version)) 
[16:13:06.261]                           version <- utils::packageVersion("future")
[16:13:06.261]                       }
[16:13:06.261]                       else {
[16:13:06.261]                         version <- NULL
[16:13:06.261]                       }
[16:13:06.261]                       if (!has_future || version < "1.8.0") {
[16:13:06.261]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.261]                           "", base::R.version$version.string), 
[16:13:06.261]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:06.261]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.261]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.261]                             "release", "version")], collapse = " "), 
[16:13:06.261]                           hostname = base::Sys.info()[["nodename"]])
[16:13:06.261]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.261]                           info)
[16:13:06.261]                         info <- base::paste(info, collapse = "; ")
[16:13:06.261]                         if (!has_future) {
[16:13:06.261]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.261]                             info)
[16:13:06.261]                         }
[16:13:06.261]                         else {
[16:13:06.261]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.261]                             info, version)
[16:13:06.261]                         }
[16:13:06.261]                         base::stop(msg)
[16:13:06.261]                       }
[16:13:06.261]                     })
[16:13:06.261]                   }
[16:13:06.261]                   options(future.plan = NULL)
[16:13:06.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.261]                 }
[16:13:06.261]                 ...future.workdir <- getwd()
[16:13:06.261]             }
[16:13:06.261]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.261]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.261]         }
[16:13:06.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.261]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[16:13:06.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.261]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.261]             base::names(...future.oldOptions))
[16:13:06.261]     }
[16:13:06.261]     if (FALSE) {
[16:13:06.261]     }
[16:13:06.261]     else {
[16:13:06.261]         if (TRUE) {
[16:13:06.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.261]                 open = "w")
[16:13:06.261]         }
[16:13:06.261]         else {
[16:13:06.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.261]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.261]         }
[16:13:06.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.261]             base::sink(type = "output", split = FALSE)
[16:13:06.261]             base::close(...future.stdout)
[16:13:06.261]         }, add = TRUE)
[16:13:06.261]     }
[16:13:06.261]     ...future.frame <- base::sys.nframe()
[16:13:06.261]     ...future.conditions <- base::list()
[16:13:06.261]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.261]     if (FALSE) {
[16:13:06.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.261]     }
[16:13:06.261]     ...future.result <- base::tryCatch({
[16:13:06.261]         base::withCallingHandlers({
[16:13:06.261]             ...future.value <- base::withVisible(base::local({
[16:13:06.261]                 sum(a)
[16:13:06.261]             }))
[16:13:06.261]             future::FutureResult(value = ...future.value$value, 
[16:13:06.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.261]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.261]                     ...future.globalenv.names))
[16:13:06.261]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.261]         }, condition = base::local({
[16:13:06.261]             c <- base::c
[16:13:06.261]             inherits <- base::inherits
[16:13:06.261]             invokeRestart <- base::invokeRestart
[16:13:06.261]             length <- base::length
[16:13:06.261]             list <- base::list
[16:13:06.261]             seq.int <- base::seq.int
[16:13:06.261]             signalCondition <- base::signalCondition
[16:13:06.261]             sys.calls <- base::sys.calls
[16:13:06.261]             `[[` <- base::`[[`
[16:13:06.261]             `+` <- base::`+`
[16:13:06.261]             `<<-` <- base::`<<-`
[16:13:06.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.261]                   3L)]
[16:13:06.261]             }
[16:13:06.261]             function(cond) {
[16:13:06.261]                 is_error <- inherits(cond, "error")
[16:13:06.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.261]                   NULL)
[16:13:06.261]                 if (is_error) {
[16:13:06.261]                   sessionInformation <- function() {
[16:13:06.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.261]                       search = base::search(), system = base::Sys.info())
[16:13:06.261]                   }
[16:13:06.261]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.261]                     cond$call), session = sessionInformation(), 
[16:13:06.261]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.261]                   signalCondition(cond)
[16:13:06.261]                 }
[16:13:06.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.261]                 "immediateCondition"))) {
[16:13:06.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.261]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.261]                   if (TRUE && !signal) {
[16:13:06.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.261]                     {
[16:13:06.261]                       inherits <- base::inherits
[16:13:06.261]                       invokeRestart <- base::invokeRestart
[16:13:06.261]                       is.null <- base::is.null
[16:13:06.261]                       muffled <- FALSE
[16:13:06.261]                       if (inherits(cond, "message")) {
[16:13:06.261]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.261]                         if (muffled) 
[16:13:06.261]                           invokeRestart("muffleMessage")
[16:13:06.261]                       }
[16:13:06.261]                       else if (inherits(cond, "warning")) {
[16:13:06.261]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.261]                         if (muffled) 
[16:13:06.261]                           invokeRestart("muffleWarning")
[16:13:06.261]                       }
[16:13:06.261]                       else if (inherits(cond, "condition")) {
[16:13:06.261]                         if (!is.null(pattern)) {
[16:13:06.261]                           computeRestarts <- base::computeRestarts
[16:13:06.261]                           grepl <- base::grepl
[16:13:06.261]                           restarts <- computeRestarts(cond)
[16:13:06.261]                           for (restart in restarts) {
[16:13:06.261]                             name <- restart$name
[16:13:06.261]                             if (is.null(name)) 
[16:13:06.261]                               next
[16:13:06.261]                             if (!grepl(pattern, name)) 
[16:13:06.261]                               next
[16:13:06.261]                             invokeRestart(restart)
[16:13:06.261]                             muffled <- TRUE
[16:13:06.261]                             break
[16:13:06.261]                           }
[16:13:06.261]                         }
[16:13:06.261]                       }
[16:13:06.261]                       invisible(muffled)
[16:13:06.261]                     }
[16:13:06.261]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.261]                   }
[16:13:06.261]                 }
[16:13:06.261]                 else {
[16:13:06.261]                   if (TRUE) {
[16:13:06.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.261]                     {
[16:13:06.261]                       inherits <- base::inherits
[16:13:06.261]                       invokeRestart <- base::invokeRestart
[16:13:06.261]                       is.null <- base::is.null
[16:13:06.261]                       muffled <- FALSE
[16:13:06.261]                       if (inherits(cond, "message")) {
[16:13:06.261]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.261]                         if (muffled) 
[16:13:06.261]                           invokeRestart("muffleMessage")
[16:13:06.261]                       }
[16:13:06.261]                       else if (inherits(cond, "warning")) {
[16:13:06.261]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.261]                         if (muffled) 
[16:13:06.261]                           invokeRestart("muffleWarning")
[16:13:06.261]                       }
[16:13:06.261]                       else if (inherits(cond, "condition")) {
[16:13:06.261]                         if (!is.null(pattern)) {
[16:13:06.261]                           computeRestarts <- base::computeRestarts
[16:13:06.261]                           grepl <- base::grepl
[16:13:06.261]                           restarts <- computeRestarts(cond)
[16:13:06.261]                           for (restart in restarts) {
[16:13:06.261]                             name <- restart$name
[16:13:06.261]                             if (is.null(name)) 
[16:13:06.261]                               next
[16:13:06.261]                             if (!grepl(pattern, name)) 
[16:13:06.261]                               next
[16:13:06.261]                             invokeRestart(restart)
[16:13:06.261]                             muffled <- TRUE
[16:13:06.261]                             break
[16:13:06.261]                           }
[16:13:06.261]                         }
[16:13:06.261]                       }
[16:13:06.261]                       invisible(muffled)
[16:13:06.261]                     }
[16:13:06.261]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.261]                   }
[16:13:06.261]                 }
[16:13:06.261]             }
[16:13:06.261]         }))
[16:13:06.261]     }, error = function(ex) {
[16:13:06.261]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.261]                 ...future.rng), started = ...future.startTime, 
[16:13:06.261]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.261]             version = "1.8"), class = "FutureResult")
[16:13:06.261]     }, finally = {
[16:13:06.261]         if (!identical(...future.workdir, getwd())) 
[16:13:06.261]             setwd(...future.workdir)
[16:13:06.261]         {
[16:13:06.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.261]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.261]             }
[16:13:06.261]             base::options(...future.oldOptions)
[16:13:06.261]             if (.Platform$OS.type == "windows") {
[16:13:06.261]                 old_names <- names(...future.oldEnvVars)
[16:13:06.261]                 envs <- base::Sys.getenv()
[16:13:06.261]                 names <- names(envs)
[16:13:06.261]                 common <- intersect(names, old_names)
[16:13:06.261]                 added <- setdiff(names, old_names)
[16:13:06.261]                 removed <- setdiff(old_names, names)
[16:13:06.261]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.261]                   envs[common]]
[16:13:06.261]                 NAMES <- toupper(changed)
[16:13:06.261]                 args <- list()
[16:13:06.261]                 for (kk in seq_along(NAMES)) {
[16:13:06.261]                   name <- changed[[kk]]
[16:13:06.261]                   NAME <- NAMES[[kk]]
[16:13:06.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.261]                     next
[16:13:06.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.261]                 }
[16:13:06.261]                 NAMES <- toupper(added)
[16:13:06.261]                 for (kk in seq_along(NAMES)) {
[16:13:06.261]                   name <- added[[kk]]
[16:13:06.261]                   NAME <- NAMES[[kk]]
[16:13:06.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.261]                     next
[16:13:06.261]                   args[[name]] <- ""
[16:13:06.261]                 }
[16:13:06.261]                 NAMES <- toupper(removed)
[16:13:06.261]                 for (kk in seq_along(NAMES)) {
[16:13:06.261]                   name <- removed[[kk]]
[16:13:06.261]                   NAME <- NAMES[[kk]]
[16:13:06.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.261]                     next
[16:13:06.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.261]                 }
[16:13:06.261]                 if (length(args) > 0) 
[16:13:06.261]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.261]             }
[16:13:06.261]             else {
[16:13:06.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.261]             }
[16:13:06.261]             {
[16:13:06.261]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.261]                   0L) {
[16:13:06.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.261]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.261]                   base::options(opts)
[16:13:06.261]                 }
[16:13:06.261]                 {
[16:13:06.261]                   {
[16:13:06.261]                     NULL
[16:13:06.261]                     RNGkind("Mersenne-Twister")
[16:13:06.261]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:06.261]                       inherits = FALSE)
[16:13:06.261]                   }
[16:13:06.261]                   options(future.plan = NULL)
[16:13:06.261]                   if (is.na(NA_character_)) 
[16:13:06.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.261]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:06.261]                   {
[16:13:06.261]                     future <- SequentialFuture(..., envir = envir)
[16:13:06.261]                     if (!future$lazy) 
[16:13:06.261]                       future <- run(future)
[16:13:06.261]                     invisible(future)
[16:13:06.261]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:06.261]                 }
[16:13:06.261]             }
[16:13:06.261]         }
[16:13:06.261]     })
[16:13:06.261]     if (TRUE) {
[16:13:06.261]         base::sink(type = "output", split = FALSE)
[16:13:06.261]         if (TRUE) {
[16:13:06.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.261]         }
[16:13:06.261]         else {
[16:13:06.261]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.261]         }
[16:13:06.261]         base::close(...future.stdout)
[16:13:06.261]         ...future.stdout <- NULL
[16:13:06.261]     }
[16:13:06.261]     ...future.result$conditions <- ...future.conditions
[16:13:06.261]     ...future.result$finished <- base::Sys.time()
[16:13:06.261]     ...future.result
[16:13:06.261] }
[16:13:06.262] assign_globals() ...
[16:13:06.262] List of 1
[16:13:06.262]  $ a: int [1:1014] 1 2 3 4 5 6 7 8 9 10 ...
[16:13:06.262]  - attr(*, "where")=List of 1
[16:13:06.262]   ..$ a:<environment: R_EmptyEnv> 
[16:13:06.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:06.262]  - attr(*, "resolved")= logi FALSE
[16:13:06.262]  - attr(*, "total_size")= num 4104
[16:13:06.264] - copied ‘a’ to environment
[16:13:06.265] assign_globals() ... done
[16:13:06.265] plan(): Setting new future strategy stack:
[16:13:06.265] List of future strategies:
[16:13:06.265] 1. sequential:
[16:13:06.265]    - args: function (..., envir = parent.frame())
[16:13:06.265]    - tweaked: FALSE
[16:13:06.265]    - call: NULL
[16:13:06.265] plan(): nbrOfWorkers() = 1
[16:13:06.266] plan(): Setting new future strategy stack:
[16:13:06.266] List of future strategies:
[16:13:06.266] 1. sequential:
[16:13:06.266]    - args: function (..., envir = parent.frame())
[16:13:06.266]    - tweaked: FALSE
[16:13:06.266]    - call: future::plan("sequential")
[16:13:06.266] plan(): nbrOfWorkers() = 1
[16:13:06.267] SequentialFuture started (and completed)
[1] 514605
a: 4112 bytes
[16:13:06.267] getGlobalsAndPackages() ...
[16:13:06.267] Searching for globals...
[16:13:06.268] - globals found: [3] ‘{’, ‘sum’, ‘a’
[16:13:06.268] Searching for globals ... DONE
[16:13:06.268] Resolving globals: FALSE
[16:13:06.268] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[16:13:06.269] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
Max number of sessions: 2
a: 4104 bytes
[16:13:06.269] getGlobalsAndPackages() ...
[16:13:06.269] Searching for globals...
[16:13:06.270] - globals found: [3] ‘{’, ‘sum’, ‘a’
[16:13:06.270] Searching for globals ... DONE
[16:13:06.270] Resolving globals: FALSE
[16:13:06.270] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[16:13:06.271] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[16:13:06.271] - globals: [1] ‘a’
[16:13:06.271] 
[16:13:06.271] getGlobalsAndPackages() ... DONE
[16:13:06.282] Packages needed by the future expression (n = 0): <none>
[16:13:06.282] Packages needed by future strategies (n = 0): <none>
[16:13:06.282] {
[16:13:06.282]     {
[16:13:06.282]         {
[16:13:06.282]             ...future.startTime <- base::Sys.time()
[16:13:06.282]             {
[16:13:06.282]                 {
[16:13:06.282]                   {
[16:13:06.282]                     {
[16:13:06.282]                       base::local({
[16:13:06.282]                         has_future <- base::requireNamespace("future", 
[16:13:06.282]                           quietly = TRUE)
[16:13:06.282]                         if (has_future) {
[16:13:06.282]                           ns <- base::getNamespace("future")
[16:13:06.282]                           version <- ns[[".package"]][["version"]]
[16:13:06.282]                           if (is.null(version)) 
[16:13:06.282]                             version <- utils::packageVersion("future")
[16:13:06.282]                         }
[16:13:06.282]                         else {
[16:13:06.282]                           version <- NULL
[16:13:06.282]                         }
[16:13:06.282]                         if (!has_future || version < "1.8.0") {
[16:13:06.282]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.282]                             "", base::R.version$version.string), 
[16:13:06.282]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.282]                               "release", "version")], collapse = " "), 
[16:13:06.282]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.282]                             info)
[16:13:06.282]                           info <- base::paste(info, collapse = "; ")
[16:13:06.282]                           if (!has_future) {
[16:13:06.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.282]                               info)
[16:13:06.282]                           }
[16:13:06.282]                           else {
[16:13:06.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.282]                               info, version)
[16:13:06.282]                           }
[16:13:06.282]                           base::stop(msg)
[16:13:06.282]                         }
[16:13:06.282]                       })
[16:13:06.282]                     }
[16:13:06.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.282]                     base::options(mc.cores = 1L)
[16:13:06.282]                   }
[16:13:06.282]                   options(future.plan = NULL)
[16:13:06.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.282]                 }
[16:13:06.282]                 ...future.workdir <- getwd()
[16:13:06.282]             }
[16:13:06.282]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.282]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.282]         }
[16:13:06.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.282]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[16:13:06.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.282]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.282]             base::names(...future.oldOptions))
[16:13:06.282]     }
[16:13:06.282]     if (FALSE) {
[16:13:06.282]     }
[16:13:06.282]     else {
[16:13:06.282]         if (TRUE) {
[16:13:06.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.282]                 open = "w")
[16:13:06.282]         }
[16:13:06.282]         else {
[16:13:06.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.282]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.282]         }
[16:13:06.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.282]             base::sink(type = "output", split = FALSE)
[16:13:06.282]             base::close(...future.stdout)
[16:13:06.282]         }, add = TRUE)
[16:13:06.282]     }
[16:13:06.282]     ...future.frame <- base::sys.nframe()
[16:13:06.282]     ...future.conditions <- base::list()
[16:13:06.282]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.282]     if (FALSE) {
[16:13:06.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.282]     }
[16:13:06.282]     ...future.result <- base::tryCatch({
[16:13:06.282]         base::withCallingHandlers({
[16:13:06.282]             ...future.value <- base::withVisible(base::local({
[16:13:06.282]                 ...future.makeSendCondition <- local({
[16:13:06.282]                   sendCondition <- NULL
[16:13:06.282]                   function(frame = 1L) {
[16:13:06.282]                     if (is.function(sendCondition)) 
[16:13:06.282]                       return(sendCondition)
[16:13:06.282]                     ns <- getNamespace("parallel")
[16:13:06.282]                     if (exists("sendData", mode = "function", 
[16:13:06.282]                       envir = ns)) {
[16:13:06.282]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.282]                         envir = ns)
[16:13:06.282]                       envir <- sys.frame(frame)
[16:13:06.282]                       master <- NULL
[16:13:06.282]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.282]                         !identical(envir, emptyenv())) {
[16:13:06.282]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.282]                           inherits = FALSE)) {
[16:13:06.282]                           master <- get("master", mode = "list", 
[16:13:06.282]                             envir = envir, inherits = FALSE)
[16:13:06.282]                           if (inherits(master, c("SOCKnode", 
[16:13:06.282]                             "SOCK0node"))) {
[16:13:06.282]                             sendCondition <<- function(cond) {
[16:13:06.282]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.282]                                 success = TRUE)
[16:13:06.282]                               parallel_sendData(master, data)
[16:13:06.282]                             }
[16:13:06.282]                             return(sendCondition)
[16:13:06.282]                           }
[16:13:06.282]                         }
[16:13:06.282]                         frame <- frame + 1L
[16:13:06.282]                         envir <- sys.frame(frame)
[16:13:06.282]                       }
[16:13:06.282]                     }
[16:13:06.282]                     sendCondition <<- function(cond) NULL
[16:13:06.282]                   }
[16:13:06.282]                 })
[16:13:06.282]                 withCallingHandlers({
[16:13:06.282]                   {
[16:13:06.282]                     sum(a)
[16:13:06.282]                   }
[16:13:06.282]                 }, immediateCondition = function(cond) {
[16:13:06.282]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.282]                   sendCondition(cond)
[16:13:06.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.282]                   {
[16:13:06.282]                     inherits <- base::inherits
[16:13:06.282]                     invokeRestart <- base::invokeRestart
[16:13:06.282]                     is.null <- base::is.null
[16:13:06.282]                     muffled <- FALSE
[16:13:06.282]                     if (inherits(cond, "message")) {
[16:13:06.282]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.282]                       if (muffled) 
[16:13:06.282]                         invokeRestart("muffleMessage")
[16:13:06.282]                     }
[16:13:06.282]                     else if (inherits(cond, "warning")) {
[16:13:06.282]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.282]                       if (muffled) 
[16:13:06.282]                         invokeRestart("muffleWarning")
[16:13:06.282]                     }
[16:13:06.282]                     else if (inherits(cond, "condition")) {
[16:13:06.282]                       if (!is.null(pattern)) {
[16:13:06.282]                         computeRestarts <- base::computeRestarts
[16:13:06.282]                         grepl <- base::grepl
[16:13:06.282]                         restarts <- computeRestarts(cond)
[16:13:06.282]                         for (restart in restarts) {
[16:13:06.282]                           name <- restart$name
[16:13:06.282]                           if (is.null(name)) 
[16:13:06.282]                             next
[16:13:06.282]                           if (!grepl(pattern, name)) 
[16:13:06.282]                             next
[16:13:06.282]                           invokeRestart(restart)
[16:13:06.282]                           muffled <- TRUE
[16:13:06.282]                           break
[16:13:06.282]                         }
[16:13:06.282]                       }
[16:13:06.282]                     }
[16:13:06.282]                     invisible(muffled)
[16:13:06.282]                   }
[16:13:06.282]                   muffleCondition(cond)
[16:13:06.282]                 })
[16:13:06.282]             }))
[16:13:06.282]             future::FutureResult(value = ...future.value$value, 
[16:13:06.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.282]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.282]                     ...future.globalenv.names))
[16:13:06.282]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.282]         }, condition = base::local({
[16:13:06.282]             c <- base::c
[16:13:06.282]             inherits <- base::inherits
[16:13:06.282]             invokeRestart <- base::invokeRestart
[16:13:06.282]             length <- base::length
[16:13:06.282]             list <- base::list
[16:13:06.282]             seq.int <- base::seq.int
[16:13:06.282]             signalCondition <- base::signalCondition
[16:13:06.282]             sys.calls <- base::sys.calls
[16:13:06.282]             `[[` <- base::`[[`
[16:13:06.282]             `+` <- base::`+`
[16:13:06.282]             `<<-` <- base::`<<-`
[16:13:06.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.282]                   3L)]
[16:13:06.282]             }
[16:13:06.282]             function(cond) {
[16:13:06.282]                 is_error <- inherits(cond, "error")
[16:13:06.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.282]                   NULL)
[16:13:06.282]                 if (is_error) {
[16:13:06.282]                   sessionInformation <- function() {
[16:13:06.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.282]                       search = base::search(), system = base::Sys.info())
[16:13:06.282]                   }
[16:13:06.282]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.282]                     cond$call), session = sessionInformation(), 
[16:13:06.282]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.282]                   signalCondition(cond)
[16:13:06.282]                 }
[16:13:06.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.282]                 "immediateCondition"))) {
[16:13:06.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.282]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.282]                   if (TRUE && !signal) {
[16:13:06.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.282]                     {
[16:13:06.282]                       inherits <- base::inherits
[16:13:06.282]                       invokeRestart <- base::invokeRestart
[16:13:06.282]                       is.null <- base::is.null
[16:13:06.282]                       muffled <- FALSE
[16:13:06.282]                       if (inherits(cond, "message")) {
[16:13:06.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.282]                         if (muffled) 
[16:13:06.282]                           invokeRestart("muffleMessage")
[16:13:06.282]                       }
[16:13:06.282]                       else if (inherits(cond, "warning")) {
[16:13:06.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.282]                         if (muffled) 
[16:13:06.282]                           invokeRestart("muffleWarning")
[16:13:06.282]                       }
[16:13:06.282]                       else if (inherits(cond, "condition")) {
[16:13:06.282]                         if (!is.null(pattern)) {
[16:13:06.282]                           computeRestarts <- base::computeRestarts
[16:13:06.282]                           grepl <- base::grepl
[16:13:06.282]                           restarts <- computeRestarts(cond)
[16:13:06.282]                           for (restart in restarts) {
[16:13:06.282]                             name <- restart$name
[16:13:06.282]                             if (is.null(name)) 
[16:13:06.282]                               next
[16:13:06.282]                             if (!grepl(pattern, name)) 
[16:13:06.282]                               next
[16:13:06.282]                             invokeRestart(restart)
[16:13:06.282]                             muffled <- TRUE
[16:13:06.282]                             break
[16:13:06.282]                           }
[16:13:06.282]                         }
[16:13:06.282]                       }
[16:13:06.282]                       invisible(muffled)
[16:13:06.282]                     }
[16:13:06.282]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.282]                   }
[16:13:06.282]                 }
[16:13:06.282]                 else {
[16:13:06.282]                   if (TRUE) {
[16:13:06.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.282]                     {
[16:13:06.282]                       inherits <- base::inherits
[16:13:06.282]                       invokeRestart <- base::invokeRestart
[16:13:06.282]                       is.null <- base::is.null
[16:13:06.282]                       muffled <- FALSE
[16:13:06.282]                       if (inherits(cond, "message")) {
[16:13:06.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.282]                         if (muffled) 
[16:13:06.282]                           invokeRestart("muffleMessage")
[16:13:06.282]                       }
[16:13:06.282]                       else if (inherits(cond, "warning")) {
[16:13:06.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.282]                         if (muffled) 
[16:13:06.282]                           invokeRestart("muffleWarning")
[16:13:06.282]                       }
[16:13:06.282]                       else if (inherits(cond, "condition")) {
[16:13:06.282]                         if (!is.null(pattern)) {
[16:13:06.282]                           computeRestarts <- base::computeRestarts
[16:13:06.282]                           grepl <- base::grepl
[16:13:06.282]                           restarts <- computeRestarts(cond)
[16:13:06.282]                           for (restart in restarts) {
[16:13:06.282]                             name <- restart$name
[16:13:06.282]                             if (is.null(name)) 
[16:13:06.282]                               next
[16:13:06.282]                             if (!grepl(pattern, name)) 
[16:13:06.282]                               next
[16:13:06.282]                             invokeRestart(restart)
[16:13:06.282]                             muffled <- TRUE
[16:13:06.282]                             break
[16:13:06.282]                           }
[16:13:06.282]                         }
[16:13:06.282]                       }
[16:13:06.282]                       invisible(muffled)
[16:13:06.282]                     }
[16:13:06.282]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.282]                   }
[16:13:06.282]                 }
[16:13:06.282]             }
[16:13:06.282]         }))
[16:13:06.282]     }, error = function(ex) {
[16:13:06.282]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.282]                 ...future.rng), started = ...future.startTime, 
[16:13:06.282]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.282]             version = "1.8"), class = "FutureResult")
[16:13:06.282]     }, finally = {
[16:13:06.282]         if (!identical(...future.workdir, getwd())) 
[16:13:06.282]             setwd(...future.workdir)
[16:13:06.282]         {
[16:13:06.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.282]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.282]             }
[16:13:06.282]             base::options(...future.oldOptions)
[16:13:06.282]             if (.Platform$OS.type == "windows") {
[16:13:06.282]                 old_names <- names(...future.oldEnvVars)
[16:13:06.282]                 envs <- base::Sys.getenv()
[16:13:06.282]                 names <- names(envs)
[16:13:06.282]                 common <- intersect(names, old_names)
[16:13:06.282]                 added <- setdiff(names, old_names)
[16:13:06.282]                 removed <- setdiff(old_names, names)
[16:13:06.282]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.282]                   envs[common]]
[16:13:06.282]                 NAMES <- toupper(changed)
[16:13:06.282]                 args <- list()
[16:13:06.282]                 for (kk in seq_along(NAMES)) {
[16:13:06.282]                   name <- changed[[kk]]
[16:13:06.282]                   NAME <- NAMES[[kk]]
[16:13:06.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.282]                     next
[16:13:06.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.282]                 }
[16:13:06.282]                 NAMES <- toupper(added)
[16:13:06.282]                 for (kk in seq_along(NAMES)) {
[16:13:06.282]                   name <- added[[kk]]
[16:13:06.282]                   NAME <- NAMES[[kk]]
[16:13:06.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.282]                     next
[16:13:06.282]                   args[[name]] <- ""
[16:13:06.282]                 }
[16:13:06.282]                 NAMES <- toupper(removed)
[16:13:06.282]                 for (kk in seq_along(NAMES)) {
[16:13:06.282]                   name <- removed[[kk]]
[16:13:06.282]                   NAME <- NAMES[[kk]]
[16:13:06.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.282]                     next
[16:13:06.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.282]                 }
[16:13:06.282]                 if (length(args) > 0) 
[16:13:06.282]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.282]             }
[16:13:06.282]             else {
[16:13:06.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.282]             }
[16:13:06.282]             {
[16:13:06.282]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.282]                   0L) {
[16:13:06.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.282]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.282]                   base::options(opts)
[16:13:06.282]                 }
[16:13:06.282]                 {
[16:13:06.282]                   {
[16:13:06.282]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.282]                     NULL
[16:13:06.282]                   }
[16:13:06.282]                   options(future.plan = NULL)
[16:13:06.282]                   if (is.na(NA_character_)) 
[16:13:06.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.282]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:06.282]                   {
[16:13:06.282]                     future <- SequentialFuture(..., envir = envir)
[16:13:06.282]                     if (!future$lazy) 
[16:13:06.282]                       future <- run(future)
[16:13:06.282]                     invisible(future)
[16:13:06.282]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:06.282]                 }
[16:13:06.282]             }
[16:13:06.282]         }
[16:13:06.282]     })
[16:13:06.282]     if (TRUE) {
[16:13:06.282]         base::sink(type = "output", split = FALSE)
[16:13:06.282]         if (TRUE) {
[16:13:06.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.282]         }
[16:13:06.282]         else {
[16:13:06.282]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.282]         }
[16:13:06.282]         base::close(...future.stdout)
[16:13:06.282]         ...future.stdout <- NULL
[16:13:06.282]     }
[16:13:06.282]     ...future.result$conditions <- ...future.conditions
[16:13:06.282]     ...future.result$finished <- base::Sys.time()
[16:13:06.282]     ...future.result
[16:13:06.282] }
[16:13:06.285] Exporting 1 global objects (4.01 KiB) to cluster node #1 ...
[16:13:06.285] Exporting ‘a’ (4.01 KiB) to cluster node #1 ...
[16:13:06.285] Exporting ‘a’ (4.01 KiB) to cluster node #1 ... DONE
[16:13:06.286] Exporting 1 global objects (4.01 KiB) to cluster node #1 ... DONE
[16:13:06.286] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:13:06.287] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.288] - Validating connection of MultisessionFuture
[16:13:06.288] - received message: FutureResult
[16:13:06.288] - Received FutureResult
[16:13:06.288] - Erased future from FutureRegistry
[16:13:06.288] result() for ClusterFuture ...
[16:13:06.288] - result already collected: FutureResult
[16:13:06.288] result() for ClusterFuture ... done
[16:13:06.288] receiveMessageFromWorker() for ClusterFuture ... done
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 567abbd8-551d-2de0-14a2-08bd408c7fac
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:06.289] result() for ClusterFuture ...
[16:13:06.289] - result already collected: FutureResult
[16:13:06.289] result() for ClusterFuture ... done
[16:13:06.289] result() for ClusterFuture ...
[16:13:06.289] - result already collected: FutureResult
[16:13:06.289] result() for ClusterFuture ... done
[1] 514605
a: 4112 bytes
[16:13:06.289] getGlobalsAndPackages() ...
[16:13:06.289] Searching for globals...
[16:13:06.290] - globals found: [3] ‘{’, ‘sum’, ‘a’
[16:13:06.290] Searching for globals ... DONE
[16:13:06.290] Resolving globals: FALSE
[16:13:06.291] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[16:13:06.291] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
> 
> ## Undo options changed in this test
> options(ooptsT)
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[16:13:06.292] getGlobalsAndPackages() ...
[16:13:06.292] Searching for globals...
[16:13:06.292] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[16:13:06.293] Searching for globals ... DONE
[16:13:06.293] Resolving globals: FALSE
[16:13:06.293] The total size of the 2 globals is 112 bytes (112 bytes)
[16:13:06.293] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[16:13:06.293] - globals: [2] ‘a’, ‘b’
[16:13:06.294] 
[16:13:06.294] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[16:13:06.294] Packages needed by the future expression (n = 0): <none>
[16:13:06.294] Packages needed by future strategies (n = 0): <none>
[16:13:06.294] {
[16:13:06.294]     {
[16:13:06.294]         {
[16:13:06.294]             ...future.startTime <- base::Sys.time()
[16:13:06.294]             {
[16:13:06.294]                 {
[16:13:06.294]                   {
[16:13:06.294]                     base::local({
[16:13:06.294]                       has_future <- base::requireNamespace("future", 
[16:13:06.294]                         quietly = TRUE)
[16:13:06.294]                       if (has_future) {
[16:13:06.294]                         ns <- base::getNamespace("future")
[16:13:06.294]                         version <- ns[[".package"]][["version"]]
[16:13:06.294]                         if (is.null(version)) 
[16:13:06.294]                           version <- utils::packageVersion("future")
[16:13:06.294]                       }
[16:13:06.294]                       else {
[16:13:06.294]                         version <- NULL
[16:13:06.294]                       }
[16:13:06.294]                       if (!has_future || version < "1.8.0") {
[16:13:06.294]                         info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.294]                           "", base::R.version$version.string), 
[16:13:06.294]                           platform = base::sprintf("%s (%s-bit)", 
[16:13:06.294]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.294]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.294]                             "release", "version")], collapse = " "), 
[16:13:06.294]                           hostname = base::Sys.info()[["nodename"]])
[16:13:06.294]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.294]                           info)
[16:13:06.294]                         info <- base::paste(info, collapse = "; ")
[16:13:06.294]                         if (!has_future) {
[16:13:06.294]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.294]                             info)
[16:13:06.294]                         }
[16:13:06.294]                         else {
[16:13:06.294]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.294]                             info, version)
[16:13:06.294]                         }
[16:13:06.294]                         base::stop(msg)
[16:13:06.294]                       }
[16:13:06.294]                     })
[16:13:06.294]                   }
[16:13:06.294]                   options(future.plan = NULL)
[16:13:06.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.294]                 }
[16:13:06.294]                 ...future.workdir <- getwd()
[16:13:06.294]             }
[16:13:06.294]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.294]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.294]         }
[16:13:06.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.294]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.294]             base::names(...future.oldOptions))
[16:13:06.294]     }
[16:13:06.294]     if (FALSE) {
[16:13:06.294]     }
[16:13:06.294]     else {
[16:13:06.294]         if (TRUE) {
[16:13:06.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.294]                 open = "w")
[16:13:06.294]         }
[16:13:06.294]         else {
[16:13:06.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.294]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.294]         }
[16:13:06.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.294]             base::sink(type = "output", split = FALSE)
[16:13:06.294]             base::close(...future.stdout)
[16:13:06.294]         }, add = TRUE)
[16:13:06.294]     }
[16:13:06.294]     ...future.frame <- base::sys.nframe()
[16:13:06.294]     ...future.conditions <- base::list()
[16:13:06.294]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.294]     if (FALSE) {
[16:13:06.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.294]     }
[16:13:06.294]     ...future.result <- base::tryCatch({
[16:13:06.294]         base::withCallingHandlers({
[16:13:06.294]             ...future.value <- base::withVisible(base::local({
[16:13:06.294]                 a * b
[16:13:06.294]             }))
[16:13:06.294]             future::FutureResult(value = ...future.value$value, 
[16:13:06.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.294]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.294]                     ...future.globalenv.names))
[16:13:06.294]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.294]         }, condition = base::local({
[16:13:06.294]             c <- base::c
[16:13:06.294]             inherits <- base::inherits
[16:13:06.294]             invokeRestart <- base::invokeRestart
[16:13:06.294]             length <- base::length
[16:13:06.294]             list <- base::list
[16:13:06.294]             seq.int <- base::seq.int
[16:13:06.294]             signalCondition <- base::signalCondition
[16:13:06.294]             sys.calls <- base::sys.calls
[16:13:06.294]             `[[` <- base::`[[`
[16:13:06.294]             `+` <- base::`+`
[16:13:06.294]             `<<-` <- base::`<<-`
[16:13:06.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.294]                   3L)]
[16:13:06.294]             }
[16:13:06.294]             function(cond) {
[16:13:06.294]                 is_error <- inherits(cond, "error")
[16:13:06.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.294]                   NULL)
[16:13:06.294]                 if (is_error) {
[16:13:06.294]                   sessionInformation <- function() {
[16:13:06.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.294]                       search = base::search(), system = base::Sys.info())
[16:13:06.294]                   }
[16:13:06.294]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.294]                     cond$call), session = sessionInformation(), 
[16:13:06.294]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.294]                   signalCondition(cond)
[16:13:06.294]                 }
[16:13:06.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.294]                 "immediateCondition"))) {
[16:13:06.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.294]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.294]                   if (TRUE && !signal) {
[16:13:06.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.294]                     {
[16:13:06.294]                       inherits <- base::inherits
[16:13:06.294]                       invokeRestart <- base::invokeRestart
[16:13:06.294]                       is.null <- base::is.null
[16:13:06.294]                       muffled <- FALSE
[16:13:06.294]                       if (inherits(cond, "message")) {
[16:13:06.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.294]                         if (muffled) 
[16:13:06.294]                           invokeRestart("muffleMessage")
[16:13:06.294]                       }
[16:13:06.294]                       else if (inherits(cond, "warning")) {
[16:13:06.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.294]                         if (muffled) 
[16:13:06.294]                           invokeRestart("muffleWarning")
[16:13:06.294]                       }
[16:13:06.294]                       else if (inherits(cond, "condition")) {
[16:13:06.294]                         if (!is.null(pattern)) {
[16:13:06.294]                           computeRestarts <- base::computeRestarts
[16:13:06.294]                           grepl <- base::grepl
[16:13:06.294]                           restarts <- computeRestarts(cond)
[16:13:06.294]                           for (restart in restarts) {
[16:13:06.294]                             name <- restart$name
[16:13:06.294]                             if (is.null(name)) 
[16:13:06.294]                               next
[16:13:06.294]                             if (!grepl(pattern, name)) 
[16:13:06.294]                               next
[16:13:06.294]                             invokeRestart(restart)
[16:13:06.294]                             muffled <- TRUE
[16:13:06.294]                             break
[16:13:06.294]                           }
[16:13:06.294]                         }
[16:13:06.294]                       }
[16:13:06.294]                       invisible(muffled)
[16:13:06.294]                     }
[16:13:06.294]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.294]                   }
[16:13:06.294]                 }
[16:13:06.294]                 else {
[16:13:06.294]                   if (TRUE) {
[16:13:06.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.294]                     {
[16:13:06.294]                       inherits <- base::inherits
[16:13:06.294]                       invokeRestart <- base::invokeRestart
[16:13:06.294]                       is.null <- base::is.null
[16:13:06.294]                       muffled <- FALSE
[16:13:06.294]                       if (inherits(cond, "message")) {
[16:13:06.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.294]                         if (muffled) 
[16:13:06.294]                           invokeRestart("muffleMessage")
[16:13:06.294]                       }
[16:13:06.294]                       else if (inherits(cond, "warning")) {
[16:13:06.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.294]                         if (muffled) 
[16:13:06.294]                           invokeRestart("muffleWarning")
[16:13:06.294]                       }
[16:13:06.294]                       else if (inherits(cond, "condition")) {
[16:13:06.294]                         if (!is.null(pattern)) {
[16:13:06.294]                           computeRestarts <- base::computeRestarts
[16:13:06.294]                           grepl <- base::grepl
[16:13:06.294]                           restarts <- computeRestarts(cond)
[16:13:06.294]                           for (restart in restarts) {
[16:13:06.294]                             name <- restart$name
[16:13:06.294]                             if (is.null(name)) 
[16:13:06.294]                               next
[16:13:06.294]                             if (!grepl(pattern, name)) 
[16:13:06.294]                               next
[16:13:06.294]                             invokeRestart(restart)
[16:13:06.294]                             muffled <- TRUE
[16:13:06.294]                             break
[16:13:06.294]                           }
[16:13:06.294]                         }
[16:13:06.294]                       }
[16:13:06.294]                       invisible(muffled)
[16:13:06.294]                     }
[16:13:06.294]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.294]                   }
[16:13:06.294]                 }
[16:13:06.294]             }
[16:13:06.294]         }))
[16:13:06.294]     }, error = function(ex) {
[16:13:06.294]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.294]                 ...future.rng), started = ...future.startTime, 
[16:13:06.294]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.294]             version = "1.8"), class = "FutureResult")
[16:13:06.294]     }, finally = {
[16:13:06.294]         if (!identical(...future.workdir, getwd())) 
[16:13:06.294]             setwd(...future.workdir)
[16:13:06.294]         {
[16:13:06.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.294]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.294]             }
[16:13:06.294]             base::options(...future.oldOptions)
[16:13:06.294]             if (.Platform$OS.type == "windows") {
[16:13:06.294]                 old_names <- names(...future.oldEnvVars)
[16:13:06.294]                 envs <- base::Sys.getenv()
[16:13:06.294]                 names <- names(envs)
[16:13:06.294]                 common <- intersect(names, old_names)
[16:13:06.294]                 added <- setdiff(names, old_names)
[16:13:06.294]                 removed <- setdiff(old_names, names)
[16:13:06.294]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.294]                   envs[common]]
[16:13:06.294]                 NAMES <- toupper(changed)
[16:13:06.294]                 args <- list()
[16:13:06.294]                 for (kk in seq_along(NAMES)) {
[16:13:06.294]                   name <- changed[[kk]]
[16:13:06.294]                   NAME <- NAMES[[kk]]
[16:13:06.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.294]                     next
[16:13:06.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.294]                 }
[16:13:06.294]                 NAMES <- toupper(added)
[16:13:06.294]                 for (kk in seq_along(NAMES)) {
[16:13:06.294]                   name <- added[[kk]]
[16:13:06.294]                   NAME <- NAMES[[kk]]
[16:13:06.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.294]                     next
[16:13:06.294]                   args[[name]] <- ""
[16:13:06.294]                 }
[16:13:06.294]                 NAMES <- toupper(removed)
[16:13:06.294]                 for (kk in seq_along(NAMES)) {
[16:13:06.294]                   name <- removed[[kk]]
[16:13:06.294]                   NAME <- NAMES[[kk]]
[16:13:06.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.294]                     next
[16:13:06.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.294]                 }
[16:13:06.294]                 if (length(args) > 0) 
[16:13:06.294]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.294]             }
[16:13:06.294]             else {
[16:13:06.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.294]             }
[16:13:06.294]             {
[16:13:06.294]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.294]                   0L) {
[16:13:06.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.294]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.294]                   base::options(opts)
[16:13:06.294]                 }
[16:13:06.294]                 {
[16:13:06.294]                   {
[16:13:06.294]                     NULL
[16:13:06.294]                     RNGkind("Mersenne-Twister")
[16:13:06.294]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:13:06.294]                       inherits = FALSE)
[16:13:06.294]                   }
[16:13:06.294]                   options(future.plan = NULL)
[16:13:06.294]                   if (is.na(NA_character_)) 
[16:13:06.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.294]                   future::plan(list(function (..., envir = parent.frame()) 
[16:13:06.294]                   {
[16:13:06.294]                     future <- SequentialFuture(..., envir = envir)
[16:13:06.294]                     if (!future$lazy) 
[16:13:06.294]                       future <- run(future)
[16:13:06.294]                     invisible(future)
[16:13:06.294]                   }), .cleanup = FALSE, .init = FALSE)
[16:13:06.294]                 }
[16:13:06.294]             }
[16:13:06.294]         }
[16:13:06.294]     })
[16:13:06.294]     if (TRUE) {
[16:13:06.294]         base::sink(type = "output", split = FALSE)
[16:13:06.294]         if (TRUE) {
[16:13:06.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.294]         }
[16:13:06.294]         else {
[16:13:06.294]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.294]         }
[16:13:06.294]         base::close(...future.stdout)
[16:13:06.294]         ...future.stdout <- NULL
[16:13:06.294]     }
[16:13:06.294]     ...future.result$conditions <- ...future.conditions
[16:13:06.294]     ...future.result$finished <- base::Sys.time()
[16:13:06.294]     ...future.result
[16:13:06.294] }
[16:13:06.296] assign_globals() ...
[16:13:06.296] List of 2
[16:13:06.296]  $ a: num 2
[16:13:06.296]  $ b: num 3
[16:13:06.296]  - attr(*, "where")=List of 2
[16:13:06.296]   ..$ a:<environment: R_EmptyEnv> 
[16:13:06.296]   ..$ b:<environment: R_EmptyEnv> 
[16:13:06.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:13:06.296]  - attr(*, "resolved")= logi FALSE
[16:13:06.296]  - attr(*, "total_size")= num 112
[16:13:06.300] - copied ‘a’ to environment
[16:13:06.301] - copied ‘b’ to environment
[16:13:06.301] assign_globals() ... done
[16:13:06.301] plan(): Setting new future strategy stack:
[16:13:06.301] List of future strategies:
[16:13:06.301] 1. sequential:
[16:13:06.301]    - args: function (..., envir = parent.frame())
[16:13:06.301]    - tweaked: FALSE
[16:13:06.301]    - call: NULL
[16:13:06.301] plan(): nbrOfWorkers() = 1
[16:13:06.302] plan(): Setting new future strategy stack:
[16:13:06.302] List of future strategies:
[16:13:06.302] 1. sequential:
[16:13:06.302]    - args: function (..., envir = parent.frame())
[16:13:06.302]    - tweaked: FALSE
[16:13:06.302]    - call: future::plan("sequential")
[16:13:06.302] plan(): nbrOfWorkers() = 1
[16:13:06.303] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[16:13:06.304] plan(): Setting new future strategy stack:
[16:13:06.304] List of future strategies:
[16:13:06.304] 1. multisession:
[16:13:06.304]    - args: function (..., workers = 2L, envir = parent.frame())
[16:13:06.304]    - tweaked: TRUE
[16:13:06.304]    - call: plan(multisession, workers = 2L)
[16:13:06.315] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:13:06.316] multisession:
[16:13:06.316] - args: function (..., workers = 2L, envir = parent.frame())
[16:13:06.316] - tweaked: TRUE
[16:13:06.316] - call: plan(multisession, workers = 2L)
[16:13:06.316] getGlobalsAndPackages() ...
[16:13:06.316] Not searching for globals
[16:13:06.316] - globals: [0] <none>
[16:13:06.316] getGlobalsAndPackages() ... DONE
[16:13:06.317] [local output] makeClusterPSOCK() ...
[16:13:06.317] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:06.318] [local output] Base port: 11048
[16:13:06.318] [local output] Getting setup options for 2 cluster nodes ...
[16:13:06.318] [local output]  - Node 1 of 2 ...
[16:13:06.318] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:06.319] [local output] Rscript port: 11048

[16:13:06.319] [local output]  - Node 2 of 2 ...
[16:13:06.319] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:06.320] [local output] Rscript port: 11048

[16:13:06.320] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:06.320] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:06.321] [local output] Setting up PSOCK nodes in parallel
[16:13:06.321] List of 36
[16:13:06.321]  $ worker          : chr "localhost"
[16:13:06.321]   ..- attr(*, "localhost")= logi TRUE
[16:13:06.321]  $ master          : chr "localhost"
[16:13:06.321]  $ port            : int 11048
[16:13:06.321]  $ connectTimeout  : num 120
[16:13:06.321]  $ timeout         : num 2592000
[16:13:06.321]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:06.321]  $ homogeneous     : logi TRUE
[16:13:06.321]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:06.321]  $ rscript_envs    : NULL
[16:13:06.321]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:06.321]  $ rscript_startup : NULL
[16:13:06.321]  $ rscript_sh      : chr "sh"
[16:13:06.321]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:06.321]  $ methods         : logi TRUE
[16:13:06.321]  $ socketOptions   : chr "no-delay"
[16:13:06.321]  $ useXDR          : logi FALSE
[16:13:06.321]  $ outfile         : chr "/dev/null"
[16:13:06.321]  $ renice          : int NA
[16:13:06.321]  $ rshcmd          : NULL
[16:13:06.321]  $ user            : chr(0) 
[16:13:06.321]  $ revtunnel       : logi FALSE
[16:13:06.321]  $ rshlogfile      : NULL
[16:13:06.321]  $ rshopts         : chr(0) 
[16:13:06.321]  $ rank            : int 1
[16:13:06.321]  $ manual          : logi FALSE
[16:13:06.321]  $ dryrun          : logi FALSE
[16:13:06.321]  $ quiet           : logi FALSE
[16:13:06.321]  $ setup_strategy  : chr "parallel"
[16:13:06.321]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:06.321]  $ pidfile         : chr "/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.154814c3bc269.pid"
[16:13:06.321]  $ rshcmd_label    : NULL
[16:13:06.321]  $ rsh_call        : NULL
[16:13:06.321]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:06.321]  $ localMachine    : logi TRUE
[16:13:06.321]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:06.321]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:06.321]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:06.321]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:06.321]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:06.321]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:06.321]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:06.321]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:06.321]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:06.321]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:06.321]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:06.321]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:06.321]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:06.321]  $ arguments       :List of 28
[16:13:06.321]   ..$ worker          : chr "localhost"
[16:13:06.321]   ..$ master          : NULL
[16:13:06.321]   ..$ port            : int 11048
[16:13:06.321]   ..$ connectTimeout  : num 120
[16:13:06.321]   ..$ timeout         : num 2592000
[16:13:06.321]   ..$ rscript         : NULL
[16:13:06.321]   ..$ homogeneous     : NULL
[16:13:06.321]   ..$ rscript_args    : NULL
[16:13:06.321]   ..$ rscript_envs    : NULL
[16:13:06.321]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:06.321]   ..$ rscript_startup : NULL
[16:13:06.321]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:06.321]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:06.321]   ..$ methods         : logi TRUE
[16:13:06.321]   ..$ socketOptions   : chr "no-delay"
[16:13:06.321]   ..$ useXDR          : logi FALSE
[16:13:06.321]   ..$ outfile         : chr "/dev/null"
[16:13:06.321]   ..$ renice          : int NA
[16:13:06.321]   ..$ rshcmd          : NULL
[16:13:06.321]   ..$ user            : NULL
[16:13:06.321]   ..$ revtunnel       : logi NA
[16:13:06.321]   ..$ rshlogfile      : NULL
[16:13:06.321]   ..$ rshopts         : NULL
[16:13:06.321]   ..$ rank            : int 1
[16:13:06.321]   ..$ manual          : logi FALSE
[16:13:06.321]   ..$ dryrun          : logi FALSE
[16:13:06.321]   ..$ quiet           : logi FALSE
[16:13:06.321]   ..$ setup_strategy  : chr "parallel"
[16:13:06.321]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:06.337] [local output] System call to launch all workers:
[16:13:06.338] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.154814c3bc269.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11048 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:06.338] [local output] Starting PSOCK main server
[16:13:06.339] [local output] Workers launched
[16:13:06.339] [local output] Waiting for workers to connect back
[16:13:06.339]  - [local output] 0 workers out of 2 ready
[16:13:06.585]  - [local output] 0 workers out of 2 ready
[16:13:06.585]  - [local output] 1 workers out of 2 ready
[16:13:06.587]  - [local output] 1 workers out of 2 ready
[16:13:06.587]  - [local output] 2 workers out of 2 ready
[16:13:06.587] [local output] Launching of workers completed
[16:13:06.588] [local output] Collecting session information from workers
[16:13:06.588] [local output]  - Worker #1 of 2
[16:13:06.589] [local output]  - Worker #2 of 2
[16:13:06.589] [local output] makeClusterPSOCK() ... done
[16:13:06.600] Packages needed by the future expression (n = 0): <none>
[16:13:06.600] Packages needed by future strategies (n = 0): <none>
[16:13:06.600] {
[16:13:06.600]     {
[16:13:06.600]         {
[16:13:06.600]             ...future.startTime <- base::Sys.time()
[16:13:06.600]             {
[16:13:06.600]                 {
[16:13:06.600]                   {
[16:13:06.600]                     {
[16:13:06.600]                       base::local({
[16:13:06.600]                         has_future <- base::requireNamespace("future", 
[16:13:06.600]                           quietly = TRUE)
[16:13:06.600]                         if (has_future) {
[16:13:06.600]                           ns <- base::getNamespace("future")
[16:13:06.600]                           version <- ns[[".package"]][["version"]]
[16:13:06.600]                           if (is.null(version)) 
[16:13:06.600]                             version <- utils::packageVersion("future")
[16:13:06.600]                         }
[16:13:06.600]                         else {
[16:13:06.600]                           version <- NULL
[16:13:06.600]                         }
[16:13:06.600]                         if (!has_future || version < "1.8.0") {
[16:13:06.600]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.600]                             "", base::R.version$version.string), 
[16:13:06.600]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.600]                               "release", "version")], collapse = " "), 
[16:13:06.600]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.600]                             info)
[16:13:06.600]                           info <- base::paste(info, collapse = "; ")
[16:13:06.600]                           if (!has_future) {
[16:13:06.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.600]                               info)
[16:13:06.600]                           }
[16:13:06.600]                           else {
[16:13:06.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.600]                               info, version)
[16:13:06.600]                           }
[16:13:06.600]                           base::stop(msg)
[16:13:06.600]                         }
[16:13:06.600]                       })
[16:13:06.600]                     }
[16:13:06.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.600]                     base::options(mc.cores = 1L)
[16:13:06.600]                   }
[16:13:06.600]                   options(future.plan = NULL)
[16:13:06.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.600]                 }
[16:13:06.600]                 ...future.workdir <- getwd()
[16:13:06.600]             }
[16:13:06.600]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.600]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.600]         }
[16:13:06.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.600]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.600]             base::names(...future.oldOptions))
[16:13:06.600]     }
[16:13:06.600]     if (FALSE) {
[16:13:06.600]     }
[16:13:06.600]     else {
[16:13:06.600]         if (TRUE) {
[16:13:06.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.600]                 open = "w")
[16:13:06.600]         }
[16:13:06.600]         else {
[16:13:06.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.600]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.600]         }
[16:13:06.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.600]             base::sink(type = "output", split = FALSE)
[16:13:06.600]             base::close(...future.stdout)
[16:13:06.600]         }, add = TRUE)
[16:13:06.600]     }
[16:13:06.600]     ...future.frame <- base::sys.nframe()
[16:13:06.600]     ...future.conditions <- base::list()
[16:13:06.600]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.600]     if (FALSE) {
[16:13:06.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.600]     }
[16:13:06.600]     ...future.result <- base::tryCatch({
[16:13:06.600]         base::withCallingHandlers({
[16:13:06.600]             ...future.value <- base::withVisible(base::local({
[16:13:06.600]                 ...future.makeSendCondition <- local({
[16:13:06.600]                   sendCondition <- NULL
[16:13:06.600]                   function(frame = 1L) {
[16:13:06.600]                     if (is.function(sendCondition)) 
[16:13:06.600]                       return(sendCondition)
[16:13:06.600]                     ns <- getNamespace("parallel")
[16:13:06.600]                     if (exists("sendData", mode = "function", 
[16:13:06.600]                       envir = ns)) {
[16:13:06.600]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.600]                         envir = ns)
[16:13:06.600]                       envir <- sys.frame(frame)
[16:13:06.600]                       master <- NULL
[16:13:06.600]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.600]                         !identical(envir, emptyenv())) {
[16:13:06.600]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.600]                           inherits = FALSE)) {
[16:13:06.600]                           master <- get("master", mode = "list", 
[16:13:06.600]                             envir = envir, inherits = FALSE)
[16:13:06.600]                           if (inherits(master, c("SOCKnode", 
[16:13:06.600]                             "SOCK0node"))) {
[16:13:06.600]                             sendCondition <<- function(cond) {
[16:13:06.600]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.600]                                 success = TRUE)
[16:13:06.600]                               parallel_sendData(master, data)
[16:13:06.600]                             }
[16:13:06.600]                             return(sendCondition)
[16:13:06.600]                           }
[16:13:06.600]                         }
[16:13:06.600]                         frame <- frame + 1L
[16:13:06.600]                         envir <- sys.frame(frame)
[16:13:06.600]                       }
[16:13:06.600]                     }
[16:13:06.600]                     sendCondition <<- function(cond) NULL
[16:13:06.600]                   }
[16:13:06.600]                 })
[16:13:06.600]                 withCallingHandlers({
[16:13:06.600]                   NA
[16:13:06.600]                 }, immediateCondition = function(cond) {
[16:13:06.600]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.600]                   sendCondition(cond)
[16:13:06.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.600]                   {
[16:13:06.600]                     inherits <- base::inherits
[16:13:06.600]                     invokeRestart <- base::invokeRestart
[16:13:06.600]                     is.null <- base::is.null
[16:13:06.600]                     muffled <- FALSE
[16:13:06.600]                     if (inherits(cond, "message")) {
[16:13:06.600]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.600]                       if (muffled) 
[16:13:06.600]                         invokeRestart("muffleMessage")
[16:13:06.600]                     }
[16:13:06.600]                     else if (inherits(cond, "warning")) {
[16:13:06.600]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.600]                       if (muffled) 
[16:13:06.600]                         invokeRestart("muffleWarning")
[16:13:06.600]                     }
[16:13:06.600]                     else if (inherits(cond, "condition")) {
[16:13:06.600]                       if (!is.null(pattern)) {
[16:13:06.600]                         computeRestarts <- base::computeRestarts
[16:13:06.600]                         grepl <- base::grepl
[16:13:06.600]                         restarts <- computeRestarts(cond)
[16:13:06.600]                         for (restart in restarts) {
[16:13:06.600]                           name <- restart$name
[16:13:06.600]                           if (is.null(name)) 
[16:13:06.600]                             next
[16:13:06.600]                           if (!grepl(pattern, name)) 
[16:13:06.600]                             next
[16:13:06.600]                           invokeRestart(restart)
[16:13:06.600]                           muffled <- TRUE
[16:13:06.600]                           break
[16:13:06.600]                         }
[16:13:06.600]                       }
[16:13:06.600]                     }
[16:13:06.600]                     invisible(muffled)
[16:13:06.600]                   }
[16:13:06.600]                   muffleCondition(cond)
[16:13:06.600]                 })
[16:13:06.600]             }))
[16:13:06.600]             future::FutureResult(value = ...future.value$value, 
[16:13:06.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.600]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.600]                     ...future.globalenv.names))
[16:13:06.600]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.600]         }, condition = base::local({
[16:13:06.600]             c <- base::c
[16:13:06.600]             inherits <- base::inherits
[16:13:06.600]             invokeRestart <- base::invokeRestart
[16:13:06.600]             length <- base::length
[16:13:06.600]             list <- base::list
[16:13:06.600]             seq.int <- base::seq.int
[16:13:06.600]             signalCondition <- base::signalCondition
[16:13:06.600]             sys.calls <- base::sys.calls
[16:13:06.600]             `[[` <- base::`[[`
[16:13:06.600]             `+` <- base::`+`
[16:13:06.600]             `<<-` <- base::`<<-`
[16:13:06.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.600]                   3L)]
[16:13:06.600]             }
[16:13:06.600]             function(cond) {
[16:13:06.600]                 is_error <- inherits(cond, "error")
[16:13:06.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.600]                   NULL)
[16:13:06.600]                 if (is_error) {
[16:13:06.600]                   sessionInformation <- function() {
[16:13:06.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.600]                       search = base::search(), system = base::Sys.info())
[16:13:06.600]                   }
[16:13:06.600]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.600]                     cond$call), session = sessionInformation(), 
[16:13:06.600]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.600]                   signalCondition(cond)
[16:13:06.600]                 }
[16:13:06.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.600]                 "immediateCondition"))) {
[16:13:06.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.600]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.600]                   if (TRUE && !signal) {
[16:13:06.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.600]                     {
[16:13:06.600]                       inherits <- base::inherits
[16:13:06.600]                       invokeRestart <- base::invokeRestart
[16:13:06.600]                       is.null <- base::is.null
[16:13:06.600]                       muffled <- FALSE
[16:13:06.600]                       if (inherits(cond, "message")) {
[16:13:06.600]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.600]                         if (muffled) 
[16:13:06.600]                           invokeRestart("muffleMessage")
[16:13:06.600]                       }
[16:13:06.600]                       else if (inherits(cond, "warning")) {
[16:13:06.600]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.600]                         if (muffled) 
[16:13:06.600]                           invokeRestart("muffleWarning")
[16:13:06.600]                       }
[16:13:06.600]                       else if (inherits(cond, "condition")) {
[16:13:06.600]                         if (!is.null(pattern)) {
[16:13:06.600]                           computeRestarts <- base::computeRestarts
[16:13:06.600]                           grepl <- base::grepl
[16:13:06.600]                           restarts <- computeRestarts(cond)
[16:13:06.600]                           for (restart in restarts) {
[16:13:06.600]                             name <- restart$name
[16:13:06.600]                             if (is.null(name)) 
[16:13:06.600]                               next
[16:13:06.600]                             if (!grepl(pattern, name)) 
[16:13:06.600]                               next
[16:13:06.600]                             invokeRestart(restart)
[16:13:06.600]                             muffled <- TRUE
[16:13:06.600]                             break
[16:13:06.600]                           }
[16:13:06.600]                         }
[16:13:06.600]                       }
[16:13:06.600]                       invisible(muffled)
[16:13:06.600]                     }
[16:13:06.600]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.600]                   }
[16:13:06.600]                 }
[16:13:06.600]                 else {
[16:13:06.600]                   if (TRUE) {
[16:13:06.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.600]                     {
[16:13:06.600]                       inherits <- base::inherits
[16:13:06.600]                       invokeRestart <- base::invokeRestart
[16:13:06.600]                       is.null <- base::is.null
[16:13:06.600]                       muffled <- FALSE
[16:13:06.600]                       if (inherits(cond, "message")) {
[16:13:06.600]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.600]                         if (muffled) 
[16:13:06.600]                           invokeRestart("muffleMessage")
[16:13:06.600]                       }
[16:13:06.600]                       else if (inherits(cond, "warning")) {
[16:13:06.600]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.600]                         if (muffled) 
[16:13:06.600]                           invokeRestart("muffleWarning")
[16:13:06.600]                       }
[16:13:06.600]                       else if (inherits(cond, "condition")) {
[16:13:06.600]                         if (!is.null(pattern)) {
[16:13:06.600]                           computeRestarts <- base::computeRestarts
[16:13:06.600]                           grepl <- base::grepl
[16:13:06.600]                           restarts <- computeRestarts(cond)
[16:13:06.600]                           for (restart in restarts) {
[16:13:06.600]                             name <- restart$name
[16:13:06.600]                             if (is.null(name)) 
[16:13:06.600]                               next
[16:13:06.600]                             if (!grepl(pattern, name)) 
[16:13:06.600]                               next
[16:13:06.600]                             invokeRestart(restart)
[16:13:06.600]                             muffled <- TRUE
[16:13:06.600]                             break
[16:13:06.600]                           }
[16:13:06.600]                         }
[16:13:06.600]                       }
[16:13:06.600]                       invisible(muffled)
[16:13:06.600]                     }
[16:13:06.600]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.600]                   }
[16:13:06.600]                 }
[16:13:06.600]             }
[16:13:06.600]         }))
[16:13:06.600]     }, error = function(ex) {
[16:13:06.600]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.600]                 ...future.rng), started = ...future.startTime, 
[16:13:06.600]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.600]             version = "1.8"), class = "FutureResult")
[16:13:06.600]     }, finally = {
[16:13:06.600]         if (!identical(...future.workdir, getwd())) 
[16:13:06.600]             setwd(...future.workdir)
[16:13:06.600]         {
[16:13:06.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.600]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.600]             }
[16:13:06.600]             base::options(...future.oldOptions)
[16:13:06.600]             if (.Platform$OS.type == "windows") {
[16:13:06.600]                 old_names <- names(...future.oldEnvVars)
[16:13:06.600]                 envs <- base::Sys.getenv()
[16:13:06.600]                 names <- names(envs)
[16:13:06.600]                 common <- intersect(names, old_names)
[16:13:06.600]                 added <- setdiff(names, old_names)
[16:13:06.600]                 removed <- setdiff(old_names, names)
[16:13:06.600]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.600]                   envs[common]]
[16:13:06.600]                 NAMES <- toupper(changed)
[16:13:06.600]                 args <- list()
[16:13:06.600]                 for (kk in seq_along(NAMES)) {
[16:13:06.600]                   name <- changed[[kk]]
[16:13:06.600]                   NAME <- NAMES[[kk]]
[16:13:06.600]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.600]                     next
[16:13:06.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.600]                 }
[16:13:06.600]                 NAMES <- toupper(added)
[16:13:06.600]                 for (kk in seq_along(NAMES)) {
[16:13:06.600]                   name <- added[[kk]]
[16:13:06.600]                   NAME <- NAMES[[kk]]
[16:13:06.600]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.600]                     next
[16:13:06.600]                   args[[name]] <- ""
[16:13:06.600]                 }
[16:13:06.600]                 NAMES <- toupper(removed)
[16:13:06.600]                 for (kk in seq_along(NAMES)) {
[16:13:06.600]                   name <- removed[[kk]]
[16:13:06.600]                   NAME <- NAMES[[kk]]
[16:13:06.600]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.600]                     next
[16:13:06.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.600]                 }
[16:13:06.600]                 if (length(args) > 0) 
[16:13:06.600]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.600]             }
[16:13:06.600]             else {
[16:13:06.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.600]             }
[16:13:06.600]             {
[16:13:06.600]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.600]                   0L) {
[16:13:06.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.600]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.600]                   base::options(opts)
[16:13:06.600]                 }
[16:13:06.600]                 {
[16:13:06.600]                   {
[16:13:06.600]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.600]                     NULL
[16:13:06.600]                   }
[16:13:06.600]                   options(future.plan = NULL)
[16:13:06.600]                   if (is.na(NA_character_)) 
[16:13:06.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.600]                   future::plan(list(function (..., workers = 2L, 
[16:13:06.600]                     envir = parent.frame()) 
[16:13:06.600]                   strategy(..., workers = workers, envir = envir)), 
[16:13:06.600]                     .cleanup = FALSE, .init = FALSE)
[16:13:06.600]                 }
[16:13:06.600]             }
[16:13:06.600]         }
[16:13:06.600]     })
[16:13:06.600]     if (TRUE) {
[16:13:06.600]         base::sink(type = "output", split = FALSE)
[16:13:06.600]         if (TRUE) {
[16:13:06.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.600]         }
[16:13:06.600]         else {
[16:13:06.600]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.600]         }
[16:13:06.600]         base::close(...future.stdout)
[16:13:06.600]         ...future.stdout <- NULL
[16:13:06.600]     }
[16:13:06.600]     ...future.result$conditions <- ...future.conditions
[16:13:06.600]     ...future.result$finished <- base::Sys.time()
[16:13:06.600]     ...future.result
[16:13:06.600] }
[16:13:06.670] MultisessionFuture started
[16:13:06.671] result() for ClusterFuture ...
[16:13:06.671] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.671] - Validating connection of MultisessionFuture
[16:13:06.695] - received message: FutureResult
[16:13:06.695] - Received FutureResult
[16:13:06.695] - Erased future from FutureRegistry
[16:13:06.695] result() for ClusterFuture ...
[16:13:06.696] - result already collected: FutureResult
[16:13:06.696] result() for ClusterFuture ... done
[16:13:06.696] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.696] result() for ClusterFuture ... done
[16:13:06.696] result() for ClusterFuture ...
[16:13:06.696] - result already collected: FutureResult
[16:13:06.696] result() for ClusterFuture ... done
[16:13:06.696] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:13:06.697] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[16:13:06.697] getGlobalsAndPackages() ...
[16:13:06.697] Searching for globals...
[16:13:06.698] - globals found: [2] ‘{’, ‘gc’
[16:13:06.698] Searching for globals ... DONE
[16:13:06.698] Resolving globals: FALSE
[16:13:06.698] 
[16:13:06.698] 
[16:13:06.698] getGlobalsAndPackages() ... DONE
[16:13:06.699] run() for ‘Future’ ...
[16:13:06.699] - state: ‘created’
[16:13:06.699] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:06.710] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:06.710] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:06.710]   - Field: ‘node’
[16:13:06.710]   - Field: ‘label’
[16:13:06.710]   - Field: ‘local’
[16:13:06.710]   - Field: ‘owner’
[16:13:06.711]   - Field: ‘envir’
[16:13:06.711]   - Field: ‘workers’
[16:13:06.711]   - Field: ‘packages’
[16:13:06.711]   - Field: ‘gc’
[16:13:06.711]   - Field: ‘conditions’
[16:13:06.711]   - Field: ‘persistent’
[16:13:06.711]   - Field: ‘expr’
[16:13:06.711]   - Field: ‘uuid’
[16:13:06.711]   - Field: ‘seed’
[16:13:06.711]   - Field: ‘version’
[16:13:06.711]   - Field: ‘result’
[16:13:06.712]   - Field: ‘asynchronous’
[16:13:06.712]   - Field: ‘calls’
[16:13:06.712]   - Field: ‘globals’
[16:13:06.712]   - Field: ‘stdout’
[16:13:06.712]   - Field: ‘earlySignal’
[16:13:06.712]   - Field: ‘lazy’
[16:13:06.712]   - Field: ‘state’
[16:13:06.712] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:06.712] - Launch lazy future ...
[16:13:06.713] Packages needed by the future expression (n = 0): <none>
[16:13:06.713] Packages needed by future strategies (n = 0): <none>
[16:13:06.713] {
[16:13:06.713]     {
[16:13:06.713]         {
[16:13:06.713]             ...future.startTime <- base::Sys.time()
[16:13:06.713]             {
[16:13:06.713]                 {
[16:13:06.713]                   {
[16:13:06.713]                     {
[16:13:06.713]                       base::local({
[16:13:06.713]                         has_future <- base::requireNamespace("future", 
[16:13:06.713]                           quietly = TRUE)
[16:13:06.713]                         if (has_future) {
[16:13:06.713]                           ns <- base::getNamespace("future")
[16:13:06.713]                           version <- ns[[".package"]][["version"]]
[16:13:06.713]                           if (is.null(version)) 
[16:13:06.713]                             version <- utils::packageVersion("future")
[16:13:06.713]                         }
[16:13:06.713]                         else {
[16:13:06.713]                           version <- NULL
[16:13:06.713]                         }
[16:13:06.713]                         if (!has_future || version < "1.8.0") {
[16:13:06.713]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.713]                             "", base::R.version$version.string), 
[16:13:06.713]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.713]                               "release", "version")], collapse = " "), 
[16:13:06.713]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.713]                             info)
[16:13:06.713]                           info <- base::paste(info, collapse = "; ")
[16:13:06.713]                           if (!has_future) {
[16:13:06.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.713]                               info)
[16:13:06.713]                           }
[16:13:06.713]                           else {
[16:13:06.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.713]                               info, version)
[16:13:06.713]                           }
[16:13:06.713]                           base::stop(msg)
[16:13:06.713]                         }
[16:13:06.713]                       })
[16:13:06.713]                     }
[16:13:06.713]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.713]                     base::options(mc.cores = 1L)
[16:13:06.713]                   }
[16:13:06.713]                   options(future.plan = NULL)
[16:13:06.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.713]                 }
[16:13:06.713]                 ...future.workdir <- getwd()
[16:13:06.713]             }
[16:13:06.713]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.713]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.713]         }
[16:13:06.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.713]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.713]             base::names(...future.oldOptions))
[16:13:06.713]     }
[16:13:06.713]     if (FALSE) {
[16:13:06.713]     }
[16:13:06.713]     else {
[16:13:06.713]         if (TRUE) {
[16:13:06.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.713]                 open = "w")
[16:13:06.713]         }
[16:13:06.713]         else {
[16:13:06.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.713]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.713]         }
[16:13:06.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.713]             base::sink(type = "output", split = FALSE)
[16:13:06.713]             base::close(...future.stdout)
[16:13:06.713]         }, add = TRUE)
[16:13:06.713]     }
[16:13:06.713]     ...future.frame <- base::sys.nframe()
[16:13:06.713]     ...future.conditions <- base::list()
[16:13:06.713]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.713]     if (FALSE) {
[16:13:06.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.713]     }
[16:13:06.713]     ...future.result <- base::tryCatch({
[16:13:06.713]         base::withCallingHandlers({
[16:13:06.713]             ...future.value <- base::withVisible(base::local({
[16:13:06.713]                 ...future.makeSendCondition <- local({
[16:13:06.713]                   sendCondition <- NULL
[16:13:06.713]                   function(frame = 1L) {
[16:13:06.713]                     if (is.function(sendCondition)) 
[16:13:06.713]                       return(sendCondition)
[16:13:06.713]                     ns <- getNamespace("parallel")
[16:13:06.713]                     if (exists("sendData", mode = "function", 
[16:13:06.713]                       envir = ns)) {
[16:13:06.713]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.713]                         envir = ns)
[16:13:06.713]                       envir <- sys.frame(frame)
[16:13:06.713]                       master <- NULL
[16:13:06.713]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.713]                         !identical(envir, emptyenv())) {
[16:13:06.713]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.713]                           inherits = FALSE)) {
[16:13:06.713]                           master <- get("master", mode = "list", 
[16:13:06.713]                             envir = envir, inherits = FALSE)
[16:13:06.713]                           if (inherits(master, c("SOCKnode", 
[16:13:06.713]                             "SOCK0node"))) {
[16:13:06.713]                             sendCondition <<- function(cond) {
[16:13:06.713]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.713]                                 success = TRUE)
[16:13:06.713]                               parallel_sendData(master, data)
[16:13:06.713]                             }
[16:13:06.713]                             return(sendCondition)
[16:13:06.713]                           }
[16:13:06.713]                         }
[16:13:06.713]                         frame <- frame + 1L
[16:13:06.713]                         envir <- sys.frame(frame)
[16:13:06.713]                       }
[16:13:06.713]                     }
[16:13:06.713]                     sendCondition <<- function(cond) NULL
[16:13:06.713]                   }
[16:13:06.713]                 })
[16:13:06.713]                 withCallingHandlers({
[16:13:06.713]                   {
[16:13:06.713]                     gc()
[16:13:06.713]                   }
[16:13:06.713]                 }, immediateCondition = function(cond) {
[16:13:06.713]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.713]                   sendCondition(cond)
[16:13:06.713]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.713]                   {
[16:13:06.713]                     inherits <- base::inherits
[16:13:06.713]                     invokeRestart <- base::invokeRestart
[16:13:06.713]                     is.null <- base::is.null
[16:13:06.713]                     muffled <- FALSE
[16:13:06.713]                     if (inherits(cond, "message")) {
[16:13:06.713]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.713]                       if (muffled) 
[16:13:06.713]                         invokeRestart("muffleMessage")
[16:13:06.713]                     }
[16:13:06.713]                     else if (inherits(cond, "warning")) {
[16:13:06.713]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.713]                       if (muffled) 
[16:13:06.713]                         invokeRestart("muffleWarning")
[16:13:06.713]                     }
[16:13:06.713]                     else if (inherits(cond, "condition")) {
[16:13:06.713]                       if (!is.null(pattern)) {
[16:13:06.713]                         computeRestarts <- base::computeRestarts
[16:13:06.713]                         grepl <- base::grepl
[16:13:06.713]                         restarts <- computeRestarts(cond)
[16:13:06.713]                         for (restart in restarts) {
[16:13:06.713]                           name <- restart$name
[16:13:06.713]                           if (is.null(name)) 
[16:13:06.713]                             next
[16:13:06.713]                           if (!grepl(pattern, name)) 
[16:13:06.713]                             next
[16:13:06.713]                           invokeRestart(restart)
[16:13:06.713]                           muffled <- TRUE
[16:13:06.713]                           break
[16:13:06.713]                         }
[16:13:06.713]                       }
[16:13:06.713]                     }
[16:13:06.713]                     invisible(muffled)
[16:13:06.713]                   }
[16:13:06.713]                   muffleCondition(cond)
[16:13:06.713]                 })
[16:13:06.713]             }))
[16:13:06.713]             future::FutureResult(value = ...future.value$value, 
[16:13:06.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.713]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.713]                     ...future.globalenv.names))
[16:13:06.713]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.713]         }, condition = base::local({
[16:13:06.713]             c <- base::c
[16:13:06.713]             inherits <- base::inherits
[16:13:06.713]             invokeRestart <- base::invokeRestart
[16:13:06.713]             length <- base::length
[16:13:06.713]             list <- base::list
[16:13:06.713]             seq.int <- base::seq.int
[16:13:06.713]             signalCondition <- base::signalCondition
[16:13:06.713]             sys.calls <- base::sys.calls
[16:13:06.713]             `[[` <- base::`[[`
[16:13:06.713]             `+` <- base::`+`
[16:13:06.713]             `<<-` <- base::`<<-`
[16:13:06.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.713]                   3L)]
[16:13:06.713]             }
[16:13:06.713]             function(cond) {
[16:13:06.713]                 is_error <- inherits(cond, "error")
[16:13:06.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.713]                   NULL)
[16:13:06.713]                 if (is_error) {
[16:13:06.713]                   sessionInformation <- function() {
[16:13:06.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.713]                       search = base::search(), system = base::Sys.info())
[16:13:06.713]                   }
[16:13:06.713]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.713]                     cond$call), session = sessionInformation(), 
[16:13:06.713]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.713]                   signalCondition(cond)
[16:13:06.713]                 }
[16:13:06.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.713]                 "immediateCondition"))) {
[16:13:06.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.713]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.713]                   if (TRUE && !signal) {
[16:13:06.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.713]                     {
[16:13:06.713]                       inherits <- base::inherits
[16:13:06.713]                       invokeRestart <- base::invokeRestart
[16:13:06.713]                       is.null <- base::is.null
[16:13:06.713]                       muffled <- FALSE
[16:13:06.713]                       if (inherits(cond, "message")) {
[16:13:06.713]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.713]                         if (muffled) 
[16:13:06.713]                           invokeRestart("muffleMessage")
[16:13:06.713]                       }
[16:13:06.713]                       else if (inherits(cond, "warning")) {
[16:13:06.713]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.713]                         if (muffled) 
[16:13:06.713]                           invokeRestart("muffleWarning")
[16:13:06.713]                       }
[16:13:06.713]                       else if (inherits(cond, "condition")) {
[16:13:06.713]                         if (!is.null(pattern)) {
[16:13:06.713]                           computeRestarts <- base::computeRestarts
[16:13:06.713]                           grepl <- base::grepl
[16:13:06.713]                           restarts <- computeRestarts(cond)
[16:13:06.713]                           for (restart in restarts) {
[16:13:06.713]                             name <- restart$name
[16:13:06.713]                             if (is.null(name)) 
[16:13:06.713]                               next
[16:13:06.713]                             if (!grepl(pattern, name)) 
[16:13:06.713]                               next
[16:13:06.713]                             invokeRestart(restart)
[16:13:06.713]                             muffled <- TRUE
[16:13:06.713]                             break
[16:13:06.713]                           }
[16:13:06.713]                         }
[16:13:06.713]                       }
[16:13:06.713]                       invisible(muffled)
[16:13:06.713]                     }
[16:13:06.713]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.713]                   }
[16:13:06.713]                 }
[16:13:06.713]                 else {
[16:13:06.713]                   if (TRUE) {
[16:13:06.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.713]                     {
[16:13:06.713]                       inherits <- base::inherits
[16:13:06.713]                       invokeRestart <- base::invokeRestart
[16:13:06.713]                       is.null <- base::is.null
[16:13:06.713]                       muffled <- FALSE
[16:13:06.713]                       if (inherits(cond, "message")) {
[16:13:06.713]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.713]                         if (muffled) 
[16:13:06.713]                           invokeRestart("muffleMessage")
[16:13:06.713]                       }
[16:13:06.713]                       else if (inherits(cond, "warning")) {
[16:13:06.713]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.713]                         if (muffled) 
[16:13:06.713]                           invokeRestart("muffleWarning")
[16:13:06.713]                       }
[16:13:06.713]                       else if (inherits(cond, "condition")) {
[16:13:06.713]                         if (!is.null(pattern)) {
[16:13:06.713]                           computeRestarts <- base::computeRestarts
[16:13:06.713]                           grepl <- base::grepl
[16:13:06.713]                           restarts <- computeRestarts(cond)
[16:13:06.713]                           for (restart in restarts) {
[16:13:06.713]                             name <- restart$name
[16:13:06.713]                             if (is.null(name)) 
[16:13:06.713]                               next
[16:13:06.713]                             if (!grepl(pattern, name)) 
[16:13:06.713]                               next
[16:13:06.713]                             invokeRestart(restart)
[16:13:06.713]                             muffled <- TRUE
[16:13:06.713]                             break
[16:13:06.713]                           }
[16:13:06.713]                         }
[16:13:06.713]                       }
[16:13:06.713]                       invisible(muffled)
[16:13:06.713]                     }
[16:13:06.713]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.713]                   }
[16:13:06.713]                 }
[16:13:06.713]             }
[16:13:06.713]         }))
[16:13:06.713]     }, error = function(ex) {
[16:13:06.713]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.713]                 ...future.rng), started = ...future.startTime, 
[16:13:06.713]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.713]             version = "1.8"), class = "FutureResult")
[16:13:06.713]     }, finally = {
[16:13:06.713]         if (!identical(...future.workdir, getwd())) 
[16:13:06.713]             setwd(...future.workdir)
[16:13:06.713]         {
[16:13:06.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.713]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.713]             }
[16:13:06.713]             base::options(...future.oldOptions)
[16:13:06.713]             if (.Platform$OS.type == "windows") {
[16:13:06.713]                 old_names <- names(...future.oldEnvVars)
[16:13:06.713]                 envs <- base::Sys.getenv()
[16:13:06.713]                 names <- names(envs)
[16:13:06.713]                 common <- intersect(names, old_names)
[16:13:06.713]                 added <- setdiff(names, old_names)
[16:13:06.713]                 removed <- setdiff(old_names, names)
[16:13:06.713]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.713]                   envs[common]]
[16:13:06.713]                 NAMES <- toupper(changed)
[16:13:06.713]                 args <- list()
[16:13:06.713]                 for (kk in seq_along(NAMES)) {
[16:13:06.713]                   name <- changed[[kk]]
[16:13:06.713]                   NAME <- NAMES[[kk]]
[16:13:06.713]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.713]                     next
[16:13:06.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.713]                 }
[16:13:06.713]                 NAMES <- toupper(added)
[16:13:06.713]                 for (kk in seq_along(NAMES)) {
[16:13:06.713]                   name <- added[[kk]]
[16:13:06.713]                   NAME <- NAMES[[kk]]
[16:13:06.713]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.713]                     next
[16:13:06.713]                   args[[name]] <- ""
[16:13:06.713]                 }
[16:13:06.713]                 NAMES <- toupper(removed)
[16:13:06.713]                 for (kk in seq_along(NAMES)) {
[16:13:06.713]                   name <- removed[[kk]]
[16:13:06.713]                   NAME <- NAMES[[kk]]
[16:13:06.713]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.713]                     next
[16:13:06.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.713]                 }
[16:13:06.713]                 if (length(args) > 0) 
[16:13:06.713]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.713]             }
[16:13:06.713]             else {
[16:13:06.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.713]             }
[16:13:06.713]             {
[16:13:06.713]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.713]                   0L) {
[16:13:06.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.713]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.713]                   base::options(opts)
[16:13:06.713]                 }
[16:13:06.713]                 {
[16:13:06.713]                   {
[16:13:06.713]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.713]                     NULL
[16:13:06.713]                   }
[16:13:06.713]                   options(future.plan = NULL)
[16:13:06.713]                   if (is.na(NA_character_)) 
[16:13:06.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.713]                   future::plan(list(function (..., workers = 2L, 
[16:13:06.713]                     envir = parent.frame()) 
[16:13:06.713]                   strategy(..., workers = workers, envir = envir)), 
[16:13:06.713]                     .cleanup = FALSE, .init = FALSE)
[16:13:06.713]                 }
[16:13:06.713]             }
[16:13:06.713]         }
[16:13:06.713]     })
[16:13:06.713]     if (TRUE) {
[16:13:06.713]         base::sink(type = "output", split = FALSE)
[16:13:06.713]         if (TRUE) {
[16:13:06.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.713]         }
[16:13:06.713]         else {
[16:13:06.713]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.713]         }
[16:13:06.713]         base::close(...future.stdout)
[16:13:06.713]         ...future.stdout <- NULL
[16:13:06.713]     }
[16:13:06.713]     ...future.result$conditions <- ...future.conditions
[16:13:06.713]     ...future.result$finished <- base::Sys.time()
[16:13:06.713]     ...future.result
[16:13:06.713] }
[16:13:06.716] MultisessionFuture started
[16:13:06.716] - Launch lazy future ... done
[16:13:06.716] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[16:13:06.717] result() for ClusterFuture ...
[16:13:06.717] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.717] - Validating connection of MultisessionFuture
[16:13:06.782] - received message: FutureResult
[16:13:06.782] - Received FutureResult
[16:13:06.782] - Erased future from FutureRegistry
[16:13:06.782] result() for ClusterFuture ...
[16:13:06.783] - result already collected: FutureResult
[16:13:06.783] result() for ClusterFuture ... done
[16:13:06.783] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.783] result() for ClusterFuture ... done
[16:13:06.783] result() for ClusterFuture ...
[16:13:06.783] - result already collected: FutureResult
[16:13:06.783] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 395195 21.2     836944 44.7   664120 35.5
Vcells 704995  5.4    8388608 64.0  1814288 13.9
> 
> f <- future({ integer(10e6) })
[16:13:06.783] getGlobalsAndPackages() ...
[16:13:06.784] Searching for globals...
[16:13:06.784] - globals found: [2] ‘{’, ‘integer’
[16:13:06.785] Searching for globals ... DONE
[16:13:06.785] Resolving globals: FALSE
[16:13:06.785] 
[16:13:06.785] 
[16:13:06.785] getGlobalsAndPackages() ... DONE
[16:13:06.785] run() for ‘Future’ ...
[16:13:06.786] - state: ‘created’
[16:13:06.786] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:06.797] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:06.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:06.797]   - Field: ‘node’
[16:13:06.797]   - Field: ‘label’
[16:13:06.797]   - Field: ‘local’
[16:13:06.797]   - Field: ‘owner’
[16:13:06.797]   - Field: ‘envir’
[16:13:06.797]   - Field: ‘workers’
[16:13:06.798]   - Field: ‘packages’
[16:13:06.798]   - Field: ‘gc’
[16:13:06.798]   - Field: ‘conditions’
[16:13:06.798]   - Field: ‘persistent’
[16:13:06.798]   - Field: ‘expr’
[16:13:06.798]   - Field: ‘uuid’
[16:13:06.798]   - Field: ‘seed’
[16:13:06.798]   - Field: ‘version’
[16:13:06.798]   - Field: ‘result’
[16:13:06.798]   - Field: ‘asynchronous’
[16:13:06.799]   - Field: ‘calls’
[16:13:06.799]   - Field: ‘globals’
[16:13:06.801]   - Field: ‘stdout’
[16:13:06.801]   - Field: ‘earlySignal’
[16:13:06.801]   - Field: ‘lazy’
[16:13:06.801]   - Field: ‘state’
[16:13:06.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:06.801] - Launch lazy future ...
[16:13:06.801] Packages needed by the future expression (n = 0): <none>
[16:13:06.802] Packages needed by future strategies (n = 0): <none>
[16:13:06.802] {
[16:13:06.802]     {
[16:13:06.802]         {
[16:13:06.802]             ...future.startTime <- base::Sys.time()
[16:13:06.802]             {
[16:13:06.802]                 {
[16:13:06.802]                   {
[16:13:06.802]                     {
[16:13:06.802]                       base::local({
[16:13:06.802]                         has_future <- base::requireNamespace("future", 
[16:13:06.802]                           quietly = TRUE)
[16:13:06.802]                         if (has_future) {
[16:13:06.802]                           ns <- base::getNamespace("future")
[16:13:06.802]                           version <- ns[[".package"]][["version"]]
[16:13:06.802]                           if (is.null(version)) 
[16:13:06.802]                             version <- utils::packageVersion("future")
[16:13:06.802]                         }
[16:13:06.802]                         else {
[16:13:06.802]                           version <- NULL
[16:13:06.802]                         }
[16:13:06.802]                         if (!has_future || version < "1.8.0") {
[16:13:06.802]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.802]                             "", base::R.version$version.string), 
[16:13:06.802]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.802]                               "release", "version")], collapse = " "), 
[16:13:06.802]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.802]                             info)
[16:13:06.802]                           info <- base::paste(info, collapse = "; ")
[16:13:06.802]                           if (!has_future) {
[16:13:06.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.802]                               info)
[16:13:06.802]                           }
[16:13:06.802]                           else {
[16:13:06.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.802]                               info, version)
[16:13:06.802]                           }
[16:13:06.802]                           base::stop(msg)
[16:13:06.802]                         }
[16:13:06.802]                       })
[16:13:06.802]                     }
[16:13:06.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.802]                     base::options(mc.cores = 1L)
[16:13:06.802]                   }
[16:13:06.802]                   options(future.plan = NULL)
[16:13:06.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.802]                 }
[16:13:06.802]                 ...future.workdir <- getwd()
[16:13:06.802]             }
[16:13:06.802]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.802]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.802]         }
[16:13:06.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.802]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.802]             base::names(...future.oldOptions))
[16:13:06.802]     }
[16:13:06.802]     if (FALSE) {
[16:13:06.802]     }
[16:13:06.802]     else {
[16:13:06.802]         if (TRUE) {
[16:13:06.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.802]                 open = "w")
[16:13:06.802]         }
[16:13:06.802]         else {
[16:13:06.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.802]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.802]         }
[16:13:06.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.802]             base::sink(type = "output", split = FALSE)
[16:13:06.802]             base::close(...future.stdout)
[16:13:06.802]         }, add = TRUE)
[16:13:06.802]     }
[16:13:06.802]     ...future.frame <- base::sys.nframe()
[16:13:06.802]     ...future.conditions <- base::list()
[16:13:06.802]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.802]     if (FALSE) {
[16:13:06.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.802]     }
[16:13:06.802]     ...future.result <- base::tryCatch({
[16:13:06.802]         base::withCallingHandlers({
[16:13:06.802]             ...future.value <- base::withVisible(base::local({
[16:13:06.802]                 ...future.makeSendCondition <- local({
[16:13:06.802]                   sendCondition <- NULL
[16:13:06.802]                   function(frame = 1L) {
[16:13:06.802]                     if (is.function(sendCondition)) 
[16:13:06.802]                       return(sendCondition)
[16:13:06.802]                     ns <- getNamespace("parallel")
[16:13:06.802]                     if (exists("sendData", mode = "function", 
[16:13:06.802]                       envir = ns)) {
[16:13:06.802]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.802]                         envir = ns)
[16:13:06.802]                       envir <- sys.frame(frame)
[16:13:06.802]                       master <- NULL
[16:13:06.802]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.802]                         !identical(envir, emptyenv())) {
[16:13:06.802]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.802]                           inherits = FALSE)) {
[16:13:06.802]                           master <- get("master", mode = "list", 
[16:13:06.802]                             envir = envir, inherits = FALSE)
[16:13:06.802]                           if (inherits(master, c("SOCKnode", 
[16:13:06.802]                             "SOCK0node"))) {
[16:13:06.802]                             sendCondition <<- function(cond) {
[16:13:06.802]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.802]                                 success = TRUE)
[16:13:06.802]                               parallel_sendData(master, data)
[16:13:06.802]                             }
[16:13:06.802]                             return(sendCondition)
[16:13:06.802]                           }
[16:13:06.802]                         }
[16:13:06.802]                         frame <- frame + 1L
[16:13:06.802]                         envir <- sys.frame(frame)
[16:13:06.802]                       }
[16:13:06.802]                     }
[16:13:06.802]                     sendCondition <<- function(cond) NULL
[16:13:06.802]                   }
[16:13:06.802]                 })
[16:13:06.802]                 withCallingHandlers({
[16:13:06.802]                   {
[16:13:06.802]                     integer(1e+07)
[16:13:06.802]                   }
[16:13:06.802]                 }, immediateCondition = function(cond) {
[16:13:06.802]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.802]                   sendCondition(cond)
[16:13:06.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.802]                   {
[16:13:06.802]                     inherits <- base::inherits
[16:13:06.802]                     invokeRestart <- base::invokeRestart
[16:13:06.802]                     is.null <- base::is.null
[16:13:06.802]                     muffled <- FALSE
[16:13:06.802]                     if (inherits(cond, "message")) {
[16:13:06.802]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.802]                       if (muffled) 
[16:13:06.802]                         invokeRestart("muffleMessage")
[16:13:06.802]                     }
[16:13:06.802]                     else if (inherits(cond, "warning")) {
[16:13:06.802]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.802]                       if (muffled) 
[16:13:06.802]                         invokeRestart("muffleWarning")
[16:13:06.802]                     }
[16:13:06.802]                     else if (inherits(cond, "condition")) {
[16:13:06.802]                       if (!is.null(pattern)) {
[16:13:06.802]                         computeRestarts <- base::computeRestarts
[16:13:06.802]                         grepl <- base::grepl
[16:13:06.802]                         restarts <- computeRestarts(cond)
[16:13:06.802]                         for (restart in restarts) {
[16:13:06.802]                           name <- restart$name
[16:13:06.802]                           if (is.null(name)) 
[16:13:06.802]                             next
[16:13:06.802]                           if (!grepl(pattern, name)) 
[16:13:06.802]                             next
[16:13:06.802]                           invokeRestart(restart)
[16:13:06.802]                           muffled <- TRUE
[16:13:06.802]                           break
[16:13:06.802]                         }
[16:13:06.802]                       }
[16:13:06.802]                     }
[16:13:06.802]                     invisible(muffled)
[16:13:06.802]                   }
[16:13:06.802]                   muffleCondition(cond)
[16:13:06.802]                 })
[16:13:06.802]             }))
[16:13:06.802]             future::FutureResult(value = ...future.value$value, 
[16:13:06.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.802]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.802]                     ...future.globalenv.names))
[16:13:06.802]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.802]         }, condition = base::local({
[16:13:06.802]             c <- base::c
[16:13:06.802]             inherits <- base::inherits
[16:13:06.802]             invokeRestart <- base::invokeRestart
[16:13:06.802]             length <- base::length
[16:13:06.802]             list <- base::list
[16:13:06.802]             seq.int <- base::seq.int
[16:13:06.802]             signalCondition <- base::signalCondition
[16:13:06.802]             sys.calls <- base::sys.calls
[16:13:06.802]             `[[` <- base::`[[`
[16:13:06.802]             `+` <- base::`+`
[16:13:06.802]             `<<-` <- base::`<<-`
[16:13:06.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.802]                   3L)]
[16:13:06.802]             }
[16:13:06.802]             function(cond) {
[16:13:06.802]                 is_error <- inherits(cond, "error")
[16:13:06.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.802]                   NULL)
[16:13:06.802]                 if (is_error) {
[16:13:06.802]                   sessionInformation <- function() {
[16:13:06.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.802]                       search = base::search(), system = base::Sys.info())
[16:13:06.802]                   }
[16:13:06.802]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.802]                     cond$call), session = sessionInformation(), 
[16:13:06.802]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.802]                   signalCondition(cond)
[16:13:06.802]                 }
[16:13:06.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.802]                 "immediateCondition"))) {
[16:13:06.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.802]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.802]                   if (TRUE && !signal) {
[16:13:06.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.802]                     {
[16:13:06.802]                       inherits <- base::inherits
[16:13:06.802]                       invokeRestart <- base::invokeRestart
[16:13:06.802]                       is.null <- base::is.null
[16:13:06.802]                       muffled <- FALSE
[16:13:06.802]                       if (inherits(cond, "message")) {
[16:13:06.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.802]                         if (muffled) 
[16:13:06.802]                           invokeRestart("muffleMessage")
[16:13:06.802]                       }
[16:13:06.802]                       else if (inherits(cond, "warning")) {
[16:13:06.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.802]                         if (muffled) 
[16:13:06.802]                           invokeRestart("muffleWarning")
[16:13:06.802]                       }
[16:13:06.802]                       else if (inherits(cond, "condition")) {
[16:13:06.802]                         if (!is.null(pattern)) {
[16:13:06.802]                           computeRestarts <- base::computeRestarts
[16:13:06.802]                           grepl <- base::grepl
[16:13:06.802]                           restarts <- computeRestarts(cond)
[16:13:06.802]                           for (restart in restarts) {
[16:13:06.802]                             name <- restart$name
[16:13:06.802]                             if (is.null(name)) 
[16:13:06.802]                               next
[16:13:06.802]                             if (!grepl(pattern, name)) 
[16:13:06.802]                               next
[16:13:06.802]                             invokeRestart(restart)
[16:13:06.802]                             muffled <- TRUE
[16:13:06.802]                             break
[16:13:06.802]                           }
[16:13:06.802]                         }
[16:13:06.802]                       }
[16:13:06.802]                       invisible(muffled)
[16:13:06.802]                     }
[16:13:06.802]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.802]                   }
[16:13:06.802]                 }
[16:13:06.802]                 else {
[16:13:06.802]                   if (TRUE) {
[16:13:06.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.802]                     {
[16:13:06.802]                       inherits <- base::inherits
[16:13:06.802]                       invokeRestart <- base::invokeRestart
[16:13:06.802]                       is.null <- base::is.null
[16:13:06.802]                       muffled <- FALSE
[16:13:06.802]                       if (inherits(cond, "message")) {
[16:13:06.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.802]                         if (muffled) 
[16:13:06.802]                           invokeRestart("muffleMessage")
[16:13:06.802]                       }
[16:13:06.802]                       else if (inherits(cond, "warning")) {
[16:13:06.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.802]                         if (muffled) 
[16:13:06.802]                           invokeRestart("muffleWarning")
[16:13:06.802]                       }
[16:13:06.802]                       else if (inherits(cond, "condition")) {
[16:13:06.802]                         if (!is.null(pattern)) {
[16:13:06.802]                           computeRestarts <- base::computeRestarts
[16:13:06.802]                           grepl <- base::grepl
[16:13:06.802]                           restarts <- computeRestarts(cond)
[16:13:06.802]                           for (restart in restarts) {
[16:13:06.802]                             name <- restart$name
[16:13:06.802]                             if (is.null(name)) 
[16:13:06.802]                               next
[16:13:06.802]                             if (!grepl(pattern, name)) 
[16:13:06.802]                               next
[16:13:06.802]                             invokeRestart(restart)
[16:13:06.802]                             muffled <- TRUE
[16:13:06.802]                             break
[16:13:06.802]                           }
[16:13:06.802]                         }
[16:13:06.802]                       }
[16:13:06.802]                       invisible(muffled)
[16:13:06.802]                     }
[16:13:06.802]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.802]                   }
[16:13:06.802]                 }
[16:13:06.802]             }
[16:13:06.802]         }))
[16:13:06.802]     }, error = function(ex) {
[16:13:06.802]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.802]                 ...future.rng), started = ...future.startTime, 
[16:13:06.802]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.802]             version = "1.8"), class = "FutureResult")
[16:13:06.802]     }, finally = {
[16:13:06.802]         if (!identical(...future.workdir, getwd())) 
[16:13:06.802]             setwd(...future.workdir)
[16:13:06.802]         {
[16:13:06.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.802]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.802]             }
[16:13:06.802]             base::options(...future.oldOptions)
[16:13:06.802]             if (.Platform$OS.type == "windows") {
[16:13:06.802]                 old_names <- names(...future.oldEnvVars)
[16:13:06.802]                 envs <- base::Sys.getenv()
[16:13:06.802]                 names <- names(envs)
[16:13:06.802]                 common <- intersect(names, old_names)
[16:13:06.802]                 added <- setdiff(names, old_names)
[16:13:06.802]                 removed <- setdiff(old_names, names)
[16:13:06.802]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.802]                   envs[common]]
[16:13:06.802]                 NAMES <- toupper(changed)
[16:13:06.802]                 args <- list()
[16:13:06.802]                 for (kk in seq_along(NAMES)) {
[16:13:06.802]                   name <- changed[[kk]]
[16:13:06.802]                   NAME <- NAMES[[kk]]
[16:13:06.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.802]                     next
[16:13:06.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.802]                 }
[16:13:06.802]                 NAMES <- toupper(added)
[16:13:06.802]                 for (kk in seq_along(NAMES)) {
[16:13:06.802]                   name <- added[[kk]]
[16:13:06.802]                   NAME <- NAMES[[kk]]
[16:13:06.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.802]                     next
[16:13:06.802]                   args[[name]] <- ""
[16:13:06.802]                 }
[16:13:06.802]                 NAMES <- toupper(removed)
[16:13:06.802]                 for (kk in seq_along(NAMES)) {
[16:13:06.802]                   name <- removed[[kk]]
[16:13:06.802]                   NAME <- NAMES[[kk]]
[16:13:06.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.802]                     next
[16:13:06.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.802]                 }
[16:13:06.802]                 if (length(args) > 0) 
[16:13:06.802]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.802]             }
[16:13:06.802]             else {
[16:13:06.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.802]             }
[16:13:06.802]             {
[16:13:06.802]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.802]                   0L) {
[16:13:06.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.802]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.802]                   base::options(opts)
[16:13:06.802]                 }
[16:13:06.802]                 {
[16:13:06.802]                   {
[16:13:06.802]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.802]                     NULL
[16:13:06.802]                   }
[16:13:06.802]                   options(future.plan = NULL)
[16:13:06.802]                   if (is.na(NA_character_)) 
[16:13:06.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.802]                   future::plan(list(function (..., workers = 2L, 
[16:13:06.802]                     envir = parent.frame()) 
[16:13:06.802]                   strategy(..., workers = workers, envir = envir)), 
[16:13:06.802]                     .cleanup = FALSE, .init = FALSE)
[16:13:06.802]                 }
[16:13:06.802]             }
[16:13:06.802]         }
[16:13:06.802]     })
[16:13:06.802]     if (TRUE) {
[16:13:06.802]         base::sink(type = "output", split = FALSE)
[16:13:06.802]         if (TRUE) {
[16:13:06.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.802]         }
[16:13:06.802]         else {
[16:13:06.802]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.802]         }
[16:13:06.802]         base::close(...future.stdout)
[16:13:06.802]         ...future.stdout <- NULL
[16:13:06.802]     }
[16:13:06.802]     ...future.result$conditions <- ...future.conditions
[16:13:06.802]     ...future.result$finished <- base::Sys.time()
[16:13:06.802]     ...future.result
[16:13:06.802] }
[16:13:06.805] MultisessionFuture started
[16:13:06.805] - Launch lazy future ... done
[16:13:06.805] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[16:13:06.805] result() for ClusterFuture ...
[16:13:06.806] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.806] - Validating connection of MultisessionFuture
[16:13:06.902] - received message: FutureResult
[16:13:06.902] - Received FutureResult
[16:13:06.902] - Erased future from FutureRegistry
[16:13:06.902] result() for ClusterFuture ...
[16:13:06.902] - result already collected: FutureResult
[16:13:06.902] result() for ClusterFuture ... done
[16:13:06.902] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.902] result() for ClusterFuture ... done
[16:13:06.903] result() for ClusterFuture ...
[16:13:06.903] - result already collected: FutureResult
[16:13:06.903] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[16:13:06.903] getGlobalsAndPackages() ...
[16:13:06.903] Searching for globals...
[16:13:06.904] - globals found: [2] ‘{’, ‘gc’
[16:13:06.904] Searching for globals ... DONE
[16:13:06.904] Resolving globals: FALSE
[16:13:06.905] 
[16:13:06.905] 
[16:13:06.905] getGlobalsAndPackages() ... DONE
[16:13:06.905] run() for ‘Future’ ...
[16:13:06.905] - state: ‘created’
[16:13:06.905] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:06.916] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:06.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:06.917]   - Field: ‘node’
[16:13:06.917]   - Field: ‘label’
[16:13:06.917]   - Field: ‘local’
[16:13:06.917]   - Field: ‘owner’
[16:13:06.917]   - Field: ‘envir’
[16:13:06.917]   - Field: ‘workers’
[16:13:06.917]   - Field: ‘packages’
[16:13:06.917]   - Field: ‘gc’
[16:13:06.917]   - Field: ‘conditions’
[16:13:06.918]   - Field: ‘persistent’
[16:13:06.918]   - Field: ‘expr’
[16:13:06.918]   - Field: ‘uuid’
[16:13:06.918]   - Field: ‘seed’
[16:13:06.918]   - Field: ‘version’
[16:13:06.918]   - Field: ‘result’
[16:13:06.918]   - Field: ‘asynchronous’
[16:13:06.918]   - Field: ‘calls’
[16:13:06.918]   - Field: ‘globals’
[16:13:06.918]   - Field: ‘stdout’
[16:13:06.918]   - Field: ‘earlySignal’
[16:13:06.919]   - Field: ‘lazy’
[16:13:06.919]   - Field: ‘state’
[16:13:06.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:06.919] - Launch lazy future ...
[16:13:06.919] Packages needed by the future expression (n = 0): <none>
[16:13:06.919] Packages needed by future strategies (n = 0): <none>
[16:13:06.920] {
[16:13:06.920]     {
[16:13:06.920]         {
[16:13:06.920]             ...future.startTime <- base::Sys.time()
[16:13:06.920]             {
[16:13:06.920]                 {
[16:13:06.920]                   {
[16:13:06.920]                     {
[16:13:06.920]                       base::local({
[16:13:06.920]                         has_future <- base::requireNamespace("future", 
[16:13:06.920]                           quietly = TRUE)
[16:13:06.920]                         if (has_future) {
[16:13:06.920]                           ns <- base::getNamespace("future")
[16:13:06.920]                           version <- ns[[".package"]][["version"]]
[16:13:06.920]                           if (is.null(version)) 
[16:13:06.920]                             version <- utils::packageVersion("future")
[16:13:06.920]                         }
[16:13:06.920]                         else {
[16:13:06.920]                           version <- NULL
[16:13:06.920]                         }
[16:13:06.920]                         if (!has_future || version < "1.8.0") {
[16:13:06.920]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:06.920]                             "", base::R.version$version.string), 
[16:13:06.920]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:06.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:06.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:06.920]                               "release", "version")], collapse = " "), 
[16:13:06.920]                             hostname = base::Sys.info()[["nodename"]])
[16:13:06.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:06.920]                             info)
[16:13:06.920]                           info <- base::paste(info, collapse = "; ")
[16:13:06.920]                           if (!has_future) {
[16:13:06.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:06.920]                               info)
[16:13:06.920]                           }
[16:13:06.920]                           else {
[16:13:06.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:06.920]                               info, version)
[16:13:06.920]                           }
[16:13:06.920]                           base::stop(msg)
[16:13:06.920]                         }
[16:13:06.920]                       })
[16:13:06.920]                     }
[16:13:06.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:06.920]                     base::options(mc.cores = 1L)
[16:13:06.920]                   }
[16:13:06.920]                   options(future.plan = NULL)
[16:13:06.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:06.920]                 }
[16:13:06.920]                 ...future.workdir <- getwd()
[16:13:06.920]             }
[16:13:06.920]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:06.920]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:06.920]         }
[16:13:06.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:06.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:06.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:06.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:06.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:06.920]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:06.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:06.920]             base::names(...future.oldOptions))
[16:13:06.920]     }
[16:13:06.920]     if (FALSE) {
[16:13:06.920]     }
[16:13:06.920]     else {
[16:13:06.920]         if (TRUE) {
[16:13:06.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:06.920]                 open = "w")
[16:13:06.920]         }
[16:13:06.920]         else {
[16:13:06.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:06.920]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:06.920]         }
[16:13:06.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:06.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:06.920]             base::sink(type = "output", split = FALSE)
[16:13:06.920]             base::close(...future.stdout)
[16:13:06.920]         }, add = TRUE)
[16:13:06.920]     }
[16:13:06.920]     ...future.frame <- base::sys.nframe()
[16:13:06.920]     ...future.conditions <- base::list()
[16:13:06.920]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:06.920]     if (FALSE) {
[16:13:06.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:06.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:06.920]     }
[16:13:06.920]     ...future.result <- base::tryCatch({
[16:13:06.920]         base::withCallingHandlers({
[16:13:06.920]             ...future.value <- base::withVisible(base::local({
[16:13:06.920]                 ...future.makeSendCondition <- local({
[16:13:06.920]                   sendCondition <- NULL
[16:13:06.920]                   function(frame = 1L) {
[16:13:06.920]                     if (is.function(sendCondition)) 
[16:13:06.920]                       return(sendCondition)
[16:13:06.920]                     ns <- getNamespace("parallel")
[16:13:06.920]                     if (exists("sendData", mode = "function", 
[16:13:06.920]                       envir = ns)) {
[16:13:06.920]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:06.920]                         envir = ns)
[16:13:06.920]                       envir <- sys.frame(frame)
[16:13:06.920]                       master <- NULL
[16:13:06.920]                       while (!identical(envir, .GlobalEnv) && 
[16:13:06.920]                         !identical(envir, emptyenv())) {
[16:13:06.920]                         if (exists("master", mode = "list", envir = envir, 
[16:13:06.920]                           inherits = FALSE)) {
[16:13:06.920]                           master <- get("master", mode = "list", 
[16:13:06.920]                             envir = envir, inherits = FALSE)
[16:13:06.920]                           if (inherits(master, c("SOCKnode", 
[16:13:06.920]                             "SOCK0node"))) {
[16:13:06.920]                             sendCondition <<- function(cond) {
[16:13:06.920]                               data <- list(type = "VALUE", value = cond, 
[16:13:06.920]                                 success = TRUE)
[16:13:06.920]                               parallel_sendData(master, data)
[16:13:06.920]                             }
[16:13:06.920]                             return(sendCondition)
[16:13:06.920]                           }
[16:13:06.920]                         }
[16:13:06.920]                         frame <- frame + 1L
[16:13:06.920]                         envir <- sys.frame(frame)
[16:13:06.920]                       }
[16:13:06.920]                     }
[16:13:06.920]                     sendCondition <<- function(cond) NULL
[16:13:06.920]                   }
[16:13:06.920]                 })
[16:13:06.920]                 withCallingHandlers({
[16:13:06.920]                   {
[16:13:06.920]                     gc()
[16:13:06.920]                   }
[16:13:06.920]                 }, immediateCondition = function(cond) {
[16:13:06.920]                   sendCondition <- ...future.makeSendCondition()
[16:13:06.920]                   sendCondition(cond)
[16:13:06.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.920]                   {
[16:13:06.920]                     inherits <- base::inherits
[16:13:06.920]                     invokeRestart <- base::invokeRestart
[16:13:06.920]                     is.null <- base::is.null
[16:13:06.920]                     muffled <- FALSE
[16:13:06.920]                     if (inherits(cond, "message")) {
[16:13:06.920]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:06.920]                       if (muffled) 
[16:13:06.920]                         invokeRestart("muffleMessage")
[16:13:06.920]                     }
[16:13:06.920]                     else if (inherits(cond, "warning")) {
[16:13:06.920]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:06.920]                       if (muffled) 
[16:13:06.920]                         invokeRestart("muffleWarning")
[16:13:06.920]                     }
[16:13:06.920]                     else if (inherits(cond, "condition")) {
[16:13:06.920]                       if (!is.null(pattern)) {
[16:13:06.920]                         computeRestarts <- base::computeRestarts
[16:13:06.920]                         grepl <- base::grepl
[16:13:06.920]                         restarts <- computeRestarts(cond)
[16:13:06.920]                         for (restart in restarts) {
[16:13:06.920]                           name <- restart$name
[16:13:06.920]                           if (is.null(name)) 
[16:13:06.920]                             next
[16:13:06.920]                           if (!grepl(pattern, name)) 
[16:13:06.920]                             next
[16:13:06.920]                           invokeRestart(restart)
[16:13:06.920]                           muffled <- TRUE
[16:13:06.920]                           break
[16:13:06.920]                         }
[16:13:06.920]                       }
[16:13:06.920]                     }
[16:13:06.920]                     invisible(muffled)
[16:13:06.920]                   }
[16:13:06.920]                   muffleCondition(cond)
[16:13:06.920]                 })
[16:13:06.920]             }))
[16:13:06.920]             future::FutureResult(value = ...future.value$value, 
[16:13:06.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.920]                   ...future.rng), globalenv = if (FALSE) 
[16:13:06.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:06.920]                     ...future.globalenv.names))
[16:13:06.920]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:06.920]         }, condition = base::local({
[16:13:06.920]             c <- base::c
[16:13:06.920]             inherits <- base::inherits
[16:13:06.920]             invokeRestart <- base::invokeRestart
[16:13:06.920]             length <- base::length
[16:13:06.920]             list <- base::list
[16:13:06.920]             seq.int <- base::seq.int
[16:13:06.920]             signalCondition <- base::signalCondition
[16:13:06.920]             sys.calls <- base::sys.calls
[16:13:06.920]             `[[` <- base::`[[`
[16:13:06.920]             `+` <- base::`+`
[16:13:06.920]             `<<-` <- base::`<<-`
[16:13:06.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:06.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:06.920]                   3L)]
[16:13:06.920]             }
[16:13:06.920]             function(cond) {
[16:13:06.920]                 is_error <- inherits(cond, "error")
[16:13:06.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:06.920]                   NULL)
[16:13:06.920]                 if (is_error) {
[16:13:06.920]                   sessionInformation <- function() {
[16:13:06.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:06.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:06.920]                       search = base::search(), system = base::Sys.info())
[16:13:06.920]                   }
[16:13:06.920]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:06.920]                     cond$call), session = sessionInformation(), 
[16:13:06.920]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:06.920]                   signalCondition(cond)
[16:13:06.920]                 }
[16:13:06.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:06.920]                 "immediateCondition"))) {
[16:13:06.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:06.920]                   ...future.conditions[[length(...future.conditions) + 
[16:13:06.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:06.920]                   if (TRUE && !signal) {
[16:13:06.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.920]                     {
[16:13:06.920]                       inherits <- base::inherits
[16:13:06.920]                       invokeRestart <- base::invokeRestart
[16:13:06.920]                       is.null <- base::is.null
[16:13:06.920]                       muffled <- FALSE
[16:13:06.920]                       if (inherits(cond, "message")) {
[16:13:06.920]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.920]                         if (muffled) 
[16:13:06.920]                           invokeRestart("muffleMessage")
[16:13:06.920]                       }
[16:13:06.920]                       else if (inherits(cond, "warning")) {
[16:13:06.920]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.920]                         if (muffled) 
[16:13:06.920]                           invokeRestart("muffleWarning")
[16:13:06.920]                       }
[16:13:06.920]                       else if (inherits(cond, "condition")) {
[16:13:06.920]                         if (!is.null(pattern)) {
[16:13:06.920]                           computeRestarts <- base::computeRestarts
[16:13:06.920]                           grepl <- base::grepl
[16:13:06.920]                           restarts <- computeRestarts(cond)
[16:13:06.920]                           for (restart in restarts) {
[16:13:06.920]                             name <- restart$name
[16:13:06.920]                             if (is.null(name)) 
[16:13:06.920]                               next
[16:13:06.920]                             if (!grepl(pattern, name)) 
[16:13:06.920]                               next
[16:13:06.920]                             invokeRestart(restart)
[16:13:06.920]                             muffled <- TRUE
[16:13:06.920]                             break
[16:13:06.920]                           }
[16:13:06.920]                         }
[16:13:06.920]                       }
[16:13:06.920]                       invisible(muffled)
[16:13:06.920]                     }
[16:13:06.920]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.920]                   }
[16:13:06.920]                 }
[16:13:06.920]                 else {
[16:13:06.920]                   if (TRUE) {
[16:13:06.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:06.920]                     {
[16:13:06.920]                       inherits <- base::inherits
[16:13:06.920]                       invokeRestart <- base::invokeRestart
[16:13:06.920]                       is.null <- base::is.null
[16:13:06.920]                       muffled <- FALSE
[16:13:06.920]                       if (inherits(cond, "message")) {
[16:13:06.920]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:06.920]                         if (muffled) 
[16:13:06.920]                           invokeRestart("muffleMessage")
[16:13:06.920]                       }
[16:13:06.920]                       else if (inherits(cond, "warning")) {
[16:13:06.920]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:06.920]                         if (muffled) 
[16:13:06.920]                           invokeRestart("muffleWarning")
[16:13:06.920]                       }
[16:13:06.920]                       else if (inherits(cond, "condition")) {
[16:13:06.920]                         if (!is.null(pattern)) {
[16:13:06.920]                           computeRestarts <- base::computeRestarts
[16:13:06.920]                           grepl <- base::grepl
[16:13:06.920]                           restarts <- computeRestarts(cond)
[16:13:06.920]                           for (restart in restarts) {
[16:13:06.920]                             name <- restart$name
[16:13:06.920]                             if (is.null(name)) 
[16:13:06.920]                               next
[16:13:06.920]                             if (!grepl(pattern, name)) 
[16:13:06.920]                               next
[16:13:06.920]                             invokeRestart(restart)
[16:13:06.920]                             muffled <- TRUE
[16:13:06.920]                             break
[16:13:06.920]                           }
[16:13:06.920]                         }
[16:13:06.920]                       }
[16:13:06.920]                       invisible(muffled)
[16:13:06.920]                     }
[16:13:06.920]                     muffleCondition(cond, pattern = "^muffle")
[16:13:06.920]                   }
[16:13:06.920]                 }
[16:13:06.920]             }
[16:13:06.920]         }))
[16:13:06.920]     }, error = function(ex) {
[16:13:06.920]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:06.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:06.920]                 ...future.rng), started = ...future.startTime, 
[16:13:06.920]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:06.920]             version = "1.8"), class = "FutureResult")
[16:13:06.920]     }, finally = {
[16:13:06.920]         if (!identical(...future.workdir, getwd())) 
[16:13:06.920]             setwd(...future.workdir)
[16:13:06.920]         {
[16:13:06.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:06.920]                 ...future.oldOptions$nwarnings <- NULL
[16:13:06.920]             }
[16:13:06.920]             base::options(...future.oldOptions)
[16:13:06.920]             if (.Platform$OS.type == "windows") {
[16:13:06.920]                 old_names <- names(...future.oldEnvVars)
[16:13:06.920]                 envs <- base::Sys.getenv()
[16:13:06.920]                 names <- names(envs)
[16:13:06.920]                 common <- intersect(names, old_names)
[16:13:06.920]                 added <- setdiff(names, old_names)
[16:13:06.920]                 removed <- setdiff(old_names, names)
[16:13:06.920]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:06.920]                   envs[common]]
[16:13:06.920]                 NAMES <- toupper(changed)
[16:13:06.920]                 args <- list()
[16:13:06.920]                 for (kk in seq_along(NAMES)) {
[16:13:06.920]                   name <- changed[[kk]]
[16:13:06.920]                   NAME <- NAMES[[kk]]
[16:13:06.920]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.920]                     next
[16:13:06.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.920]                 }
[16:13:06.920]                 NAMES <- toupper(added)
[16:13:06.920]                 for (kk in seq_along(NAMES)) {
[16:13:06.920]                   name <- added[[kk]]
[16:13:06.920]                   NAME <- NAMES[[kk]]
[16:13:06.920]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.920]                     next
[16:13:06.920]                   args[[name]] <- ""
[16:13:06.920]                 }
[16:13:06.920]                 NAMES <- toupper(removed)
[16:13:06.920]                 for (kk in seq_along(NAMES)) {
[16:13:06.920]                   name <- removed[[kk]]
[16:13:06.920]                   NAME <- NAMES[[kk]]
[16:13:06.920]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:06.920]                     next
[16:13:06.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:06.920]                 }
[16:13:06.920]                 if (length(args) > 0) 
[16:13:06.920]                   base::do.call(base::Sys.setenv, args = args)
[16:13:06.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:06.920]             }
[16:13:06.920]             else {
[16:13:06.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:06.920]             }
[16:13:06.920]             {
[16:13:06.920]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:06.920]                   0L) {
[16:13:06.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:06.920]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:06.920]                   base::options(opts)
[16:13:06.920]                 }
[16:13:06.920]                 {
[16:13:06.920]                   {
[16:13:06.920]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:06.920]                     NULL
[16:13:06.920]                   }
[16:13:06.920]                   options(future.plan = NULL)
[16:13:06.920]                   if (is.na(NA_character_)) 
[16:13:06.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:06.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:06.920]                   future::plan(list(function (..., workers = 2L, 
[16:13:06.920]                     envir = parent.frame()) 
[16:13:06.920]                   strategy(..., workers = workers, envir = envir)), 
[16:13:06.920]                     .cleanup = FALSE, .init = FALSE)
[16:13:06.920]                 }
[16:13:06.920]             }
[16:13:06.920]         }
[16:13:06.920]     })
[16:13:06.920]     if (TRUE) {
[16:13:06.920]         base::sink(type = "output", split = FALSE)
[16:13:06.920]         if (TRUE) {
[16:13:06.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:06.920]         }
[16:13:06.920]         else {
[16:13:06.920]             ...future.result["stdout"] <- base::list(NULL)
[16:13:06.920]         }
[16:13:06.920]         base::close(...future.stdout)
[16:13:06.920]         ...future.stdout <- NULL
[16:13:06.920]     }
[16:13:06.920]     ...future.result$conditions <- ...future.conditions
[16:13:06.920]     ...future.result$finished <- base::Sys.time()
[16:13:06.920]     ...future.result
[16:13:06.920] }
[16:13:06.923] MultisessionFuture started
[16:13:06.923] - Launch lazy future ... done
[16:13:06.923] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[16:13:06.923] result() for ClusterFuture ...
[16:13:06.923] receiveMessageFromWorker() for ClusterFuture ...
[16:13:06.923] - Validating connection of MultisessionFuture
[16:13:06.988] - received message: FutureResult
[16:13:06.989] - Received FutureResult
[16:13:06.989] - Erased future from FutureRegistry
[16:13:06.989] result() for ClusterFuture ...
[16:13:06.989] - result already collected: FutureResult
[16:13:06.989] result() for ClusterFuture ... done
[16:13:06.989] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:06.989] result() for ClusterFuture ... done
[16:13:06.989] result() for ClusterFuture ...
[16:13:06.989] - result already collected: FutureResult
[16:13:06.989] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 395199 21.2     836944 44.7   664120 35.5
Vcells 705000  5.4    8388608 64.0  5728340 43.8
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[16:13:06.990] getGlobalsAndPackages() ...
[16:13:06.990] Searching for globals...
[16:13:06.991] - globals found: [2] ‘{’, ‘integer’
[16:13:06.991] Searching for globals ... DONE
[16:13:06.991] Resolving globals: FALSE
[16:13:06.991] 
[16:13:06.991] 
[16:13:06.991] getGlobalsAndPackages() ... DONE
[16:13:06.992] run() for ‘Future’ ...
[16:13:06.992] - state: ‘created’
[16:13:06.992] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:07.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:07.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:07.003]   - Field: ‘node’
[16:13:07.003]   - Field: ‘label’
[16:13:07.003]   - Field: ‘local’
[16:13:07.003]   - Field: ‘owner’
[16:13:07.004]   - Field: ‘envir’
[16:13:07.004]   - Field: ‘workers’
[16:13:07.004]   - Field: ‘packages’
[16:13:07.004]   - Field: ‘gc’
[16:13:07.004]   - Field: ‘conditions’
[16:13:07.004]   - Field: ‘persistent’
[16:13:07.004]   - Field: ‘expr’
[16:13:07.004]   - Field: ‘uuid’
[16:13:07.004]   - Field: ‘seed’
[16:13:07.004]   - Field: ‘version’
[16:13:07.004]   - Field: ‘result’
[16:13:07.005]   - Field: ‘asynchronous’
[16:13:07.005]   - Field: ‘calls’
[16:13:07.005]   - Field: ‘globals’
[16:13:07.005]   - Field: ‘stdout’
[16:13:07.005]   - Field: ‘earlySignal’
[16:13:07.005]   - Field: ‘lazy’
[16:13:07.005]   - Field: ‘state’
[16:13:07.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:07.005] - Launch lazy future ...
[16:13:07.006] Packages needed by the future expression (n = 0): <none>
[16:13:07.006] Packages needed by future strategies (n = 0): <none>
[16:13:07.006] {
[16:13:07.006]     {
[16:13:07.006]         {
[16:13:07.006]             ...future.startTime <- base::Sys.time()
[16:13:07.006]             {
[16:13:07.006]                 {
[16:13:07.006]                   {
[16:13:07.006]                     {
[16:13:07.006]                       base::local({
[16:13:07.006]                         has_future <- base::requireNamespace("future", 
[16:13:07.006]                           quietly = TRUE)
[16:13:07.006]                         if (has_future) {
[16:13:07.006]                           ns <- base::getNamespace("future")
[16:13:07.006]                           version <- ns[[".package"]][["version"]]
[16:13:07.006]                           if (is.null(version)) 
[16:13:07.006]                             version <- utils::packageVersion("future")
[16:13:07.006]                         }
[16:13:07.006]                         else {
[16:13:07.006]                           version <- NULL
[16:13:07.006]                         }
[16:13:07.006]                         if (!has_future || version < "1.8.0") {
[16:13:07.006]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:07.006]                             "", base::R.version$version.string), 
[16:13:07.006]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:07.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:07.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:07.006]                               "release", "version")], collapse = " "), 
[16:13:07.006]                             hostname = base::Sys.info()[["nodename"]])
[16:13:07.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:07.006]                             info)
[16:13:07.006]                           info <- base::paste(info, collapse = "; ")
[16:13:07.006]                           if (!has_future) {
[16:13:07.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:07.006]                               info)
[16:13:07.006]                           }
[16:13:07.006]                           else {
[16:13:07.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:07.006]                               info, version)
[16:13:07.006]                           }
[16:13:07.006]                           base::stop(msg)
[16:13:07.006]                         }
[16:13:07.006]                       })
[16:13:07.006]                     }
[16:13:07.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:07.006]                     base::options(mc.cores = 1L)
[16:13:07.006]                   }
[16:13:07.006]                   options(future.plan = NULL)
[16:13:07.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:07.006]                 }
[16:13:07.006]                 ...future.workdir <- getwd()
[16:13:07.006]             }
[16:13:07.006]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:07.006]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:07.006]         }
[16:13:07.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:07.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:07.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:07.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:07.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:07.006]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:07.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:07.006]             base::names(...future.oldOptions))
[16:13:07.006]     }
[16:13:07.006]     if (FALSE) {
[16:13:07.006]     }
[16:13:07.006]     else {
[16:13:07.006]         if (TRUE) {
[16:13:07.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:07.006]                 open = "w")
[16:13:07.006]         }
[16:13:07.006]         else {
[16:13:07.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:07.006]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:07.006]         }
[16:13:07.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:07.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:07.006]             base::sink(type = "output", split = FALSE)
[16:13:07.006]             base::close(...future.stdout)
[16:13:07.006]         }, add = TRUE)
[16:13:07.006]     }
[16:13:07.006]     ...future.frame <- base::sys.nframe()
[16:13:07.006]     ...future.conditions <- base::list()
[16:13:07.006]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:07.006]     if (FALSE) {
[16:13:07.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:07.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:07.006]     }
[16:13:07.006]     ...future.result <- base::tryCatch({
[16:13:07.006]         base::withCallingHandlers({
[16:13:07.006]             ...future.value <- base::withVisible(base::local({
[16:13:07.006]                 ...future.makeSendCondition <- local({
[16:13:07.006]                   sendCondition <- NULL
[16:13:07.006]                   function(frame = 1L) {
[16:13:07.006]                     if (is.function(sendCondition)) 
[16:13:07.006]                       return(sendCondition)
[16:13:07.006]                     ns <- getNamespace("parallel")
[16:13:07.006]                     if (exists("sendData", mode = "function", 
[16:13:07.006]                       envir = ns)) {
[16:13:07.006]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:07.006]                         envir = ns)
[16:13:07.006]                       envir <- sys.frame(frame)
[16:13:07.006]                       master <- NULL
[16:13:07.006]                       while (!identical(envir, .GlobalEnv) && 
[16:13:07.006]                         !identical(envir, emptyenv())) {
[16:13:07.006]                         if (exists("master", mode = "list", envir = envir, 
[16:13:07.006]                           inherits = FALSE)) {
[16:13:07.006]                           master <- get("master", mode = "list", 
[16:13:07.006]                             envir = envir, inherits = FALSE)
[16:13:07.006]                           if (inherits(master, c("SOCKnode", 
[16:13:07.006]                             "SOCK0node"))) {
[16:13:07.006]                             sendCondition <<- function(cond) {
[16:13:07.006]                               data <- list(type = "VALUE", value = cond, 
[16:13:07.006]                                 success = TRUE)
[16:13:07.006]                               parallel_sendData(master, data)
[16:13:07.006]                             }
[16:13:07.006]                             return(sendCondition)
[16:13:07.006]                           }
[16:13:07.006]                         }
[16:13:07.006]                         frame <- frame + 1L
[16:13:07.006]                         envir <- sys.frame(frame)
[16:13:07.006]                       }
[16:13:07.006]                     }
[16:13:07.006]                     sendCondition <<- function(cond) NULL
[16:13:07.006]                   }
[16:13:07.006]                 })
[16:13:07.006]                 withCallingHandlers({
[16:13:07.006]                   {
[16:13:07.006]                     integer(1e+07)
[16:13:07.006]                   }
[16:13:07.006]                 }, immediateCondition = function(cond) {
[16:13:07.006]                   sendCondition <- ...future.makeSendCondition()
[16:13:07.006]                   sendCondition(cond)
[16:13:07.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.006]                   {
[16:13:07.006]                     inherits <- base::inherits
[16:13:07.006]                     invokeRestart <- base::invokeRestart
[16:13:07.006]                     is.null <- base::is.null
[16:13:07.006]                     muffled <- FALSE
[16:13:07.006]                     if (inherits(cond, "message")) {
[16:13:07.006]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:07.006]                       if (muffled) 
[16:13:07.006]                         invokeRestart("muffleMessage")
[16:13:07.006]                     }
[16:13:07.006]                     else if (inherits(cond, "warning")) {
[16:13:07.006]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:07.006]                       if (muffled) 
[16:13:07.006]                         invokeRestart("muffleWarning")
[16:13:07.006]                     }
[16:13:07.006]                     else if (inherits(cond, "condition")) {
[16:13:07.006]                       if (!is.null(pattern)) {
[16:13:07.006]                         computeRestarts <- base::computeRestarts
[16:13:07.006]                         grepl <- base::grepl
[16:13:07.006]                         restarts <- computeRestarts(cond)
[16:13:07.006]                         for (restart in restarts) {
[16:13:07.006]                           name <- restart$name
[16:13:07.006]                           if (is.null(name)) 
[16:13:07.006]                             next
[16:13:07.006]                           if (!grepl(pattern, name)) 
[16:13:07.006]                             next
[16:13:07.006]                           invokeRestart(restart)
[16:13:07.006]                           muffled <- TRUE
[16:13:07.006]                           break
[16:13:07.006]                         }
[16:13:07.006]                       }
[16:13:07.006]                     }
[16:13:07.006]                     invisible(muffled)
[16:13:07.006]                   }
[16:13:07.006]                   muffleCondition(cond)
[16:13:07.006]                 })
[16:13:07.006]             }))
[16:13:07.006]             future::FutureResult(value = ...future.value$value, 
[16:13:07.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.006]                   ...future.rng), globalenv = if (FALSE) 
[16:13:07.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:07.006]                     ...future.globalenv.names))
[16:13:07.006]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:07.006]         }, condition = base::local({
[16:13:07.006]             c <- base::c
[16:13:07.006]             inherits <- base::inherits
[16:13:07.006]             invokeRestart <- base::invokeRestart
[16:13:07.006]             length <- base::length
[16:13:07.006]             list <- base::list
[16:13:07.006]             seq.int <- base::seq.int
[16:13:07.006]             signalCondition <- base::signalCondition
[16:13:07.006]             sys.calls <- base::sys.calls
[16:13:07.006]             `[[` <- base::`[[`
[16:13:07.006]             `+` <- base::`+`
[16:13:07.006]             `<<-` <- base::`<<-`
[16:13:07.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:07.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:07.006]                   3L)]
[16:13:07.006]             }
[16:13:07.006]             function(cond) {
[16:13:07.006]                 is_error <- inherits(cond, "error")
[16:13:07.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:07.006]                   NULL)
[16:13:07.006]                 if (is_error) {
[16:13:07.006]                   sessionInformation <- function() {
[16:13:07.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:07.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:07.006]                       search = base::search(), system = base::Sys.info())
[16:13:07.006]                   }
[16:13:07.006]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:07.006]                     cond$call), session = sessionInformation(), 
[16:13:07.006]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:07.006]                   signalCondition(cond)
[16:13:07.006]                 }
[16:13:07.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:07.006]                 "immediateCondition"))) {
[16:13:07.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:07.006]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:07.006]                   if (TRUE && !signal) {
[16:13:07.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.006]                     {
[16:13:07.006]                       inherits <- base::inherits
[16:13:07.006]                       invokeRestart <- base::invokeRestart
[16:13:07.006]                       is.null <- base::is.null
[16:13:07.006]                       muffled <- FALSE
[16:13:07.006]                       if (inherits(cond, "message")) {
[16:13:07.006]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.006]                         if (muffled) 
[16:13:07.006]                           invokeRestart("muffleMessage")
[16:13:07.006]                       }
[16:13:07.006]                       else if (inherits(cond, "warning")) {
[16:13:07.006]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.006]                         if (muffled) 
[16:13:07.006]                           invokeRestart("muffleWarning")
[16:13:07.006]                       }
[16:13:07.006]                       else if (inherits(cond, "condition")) {
[16:13:07.006]                         if (!is.null(pattern)) {
[16:13:07.006]                           computeRestarts <- base::computeRestarts
[16:13:07.006]                           grepl <- base::grepl
[16:13:07.006]                           restarts <- computeRestarts(cond)
[16:13:07.006]                           for (restart in restarts) {
[16:13:07.006]                             name <- restart$name
[16:13:07.006]                             if (is.null(name)) 
[16:13:07.006]                               next
[16:13:07.006]                             if (!grepl(pattern, name)) 
[16:13:07.006]                               next
[16:13:07.006]                             invokeRestart(restart)
[16:13:07.006]                             muffled <- TRUE
[16:13:07.006]                             break
[16:13:07.006]                           }
[16:13:07.006]                         }
[16:13:07.006]                       }
[16:13:07.006]                       invisible(muffled)
[16:13:07.006]                     }
[16:13:07.006]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.006]                   }
[16:13:07.006]                 }
[16:13:07.006]                 else {
[16:13:07.006]                   if (TRUE) {
[16:13:07.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.006]                     {
[16:13:07.006]                       inherits <- base::inherits
[16:13:07.006]                       invokeRestart <- base::invokeRestart
[16:13:07.006]                       is.null <- base::is.null
[16:13:07.006]                       muffled <- FALSE
[16:13:07.006]                       if (inherits(cond, "message")) {
[16:13:07.006]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.006]                         if (muffled) 
[16:13:07.006]                           invokeRestart("muffleMessage")
[16:13:07.006]                       }
[16:13:07.006]                       else if (inherits(cond, "warning")) {
[16:13:07.006]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.006]                         if (muffled) 
[16:13:07.006]                           invokeRestart("muffleWarning")
[16:13:07.006]                       }
[16:13:07.006]                       else if (inherits(cond, "condition")) {
[16:13:07.006]                         if (!is.null(pattern)) {
[16:13:07.006]                           computeRestarts <- base::computeRestarts
[16:13:07.006]                           grepl <- base::grepl
[16:13:07.006]                           restarts <- computeRestarts(cond)
[16:13:07.006]                           for (restart in restarts) {
[16:13:07.006]                             name <- restart$name
[16:13:07.006]                             if (is.null(name)) 
[16:13:07.006]                               next
[16:13:07.006]                             if (!grepl(pattern, name)) 
[16:13:07.006]                               next
[16:13:07.006]                             invokeRestart(restart)
[16:13:07.006]                             muffled <- TRUE
[16:13:07.006]                             break
[16:13:07.006]                           }
[16:13:07.006]                         }
[16:13:07.006]                       }
[16:13:07.006]                       invisible(muffled)
[16:13:07.006]                     }
[16:13:07.006]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.006]                   }
[16:13:07.006]                 }
[16:13:07.006]             }
[16:13:07.006]         }))
[16:13:07.006]     }, error = function(ex) {
[16:13:07.006]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:07.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.006]                 ...future.rng), started = ...future.startTime, 
[16:13:07.006]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:07.006]             version = "1.8"), class = "FutureResult")
[16:13:07.006]     }, finally = {
[16:13:07.006]         if (!identical(...future.workdir, getwd())) 
[16:13:07.006]             setwd(...future.workdir)
[16:13:07.006]         {
[16:13:07.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:07.006]                 ...future.oldOptions$nwarnings <- NULL
[16:13:07.006]             }
[16:13:07.006]             base::options(...future.oldOptions)
[16:13:07.006]             if (.Platform$OS.type == "windows") {
[16:13:07.006]                 old_names <- names(...future.oldEnvVars)
[16:13:07.006]                 envs <- base::Sys.getenv()
[16:13:07.006]                 names <- names(envs)
[16:13:07.006]                 common <- intersect(names, old_names)
[16:13:07.006]                 added <- setdiff(names, old_names)
[16:13:07.006]                 removed <- setdiff(old_names, names)
[16:13:07.006]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:07.006]                   envs[common]]
[16:13:07.006]                 NAMES <- toupper(changed)
[16:13:07.006]                 args <- list()
[16:13:07.006]                 for (kk in seq_along(NAMES)) {
[16:13:07.006]                   name <- changed[[kk]]
[16:13:07.006]                   NAME <- NAMES[[kk]]
[16:13:07.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.006]                     next
[16:13:07.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.006]                 }
[16:13:07.006]                 NAMES <- toupper(added)
[16:13:07.006]                 for (kk in seq_along(NAMES)) {
[16:13:07.006]                   name <- added[[kk]]
[16:13:07.006]                   NAME <- NAMES[[kk]]
[16:13:07.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.006]                     next
[16:13:07.006]                   args[[name]] <- ""
[16:13:07.006]                 }
[16:13:07.006]                 NAMES <- toupper(removed)
[16:13:07.006]                 for (kk in seq_along(NAMES)) {
[16:13:07.006]                   name <- removed[[kk]]
[16:13:07.006]                   NAME <- NAMES[[kk]]
[16:13:07.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.006]                     next
[16:13:07.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.006]                 }
[16:13:07.006]                 if (length(args) > 0) 
[16:13:07.006]                   base::do.call(base::Sys.setenv, args = args)
[16:13:07.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:07.006]             }
[16:13:07.006]             else {
[16:13:07.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:07.006]             }
[16:13:07.006]             {
[16:13:07.006]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:07.006]                   0L) {
[16:13:07.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:07.006]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:07.006]                   base::options(opts)
[16:13:07.006]                 }
[16:13:07.006]                 {
[16:13:07.006]                   {
[16:13:07.006]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:07.006]                     NULL
[16:13:07.006]                   }
[16:13:07.006]                   options(future.plan = NULL)
[16:13:07.006]                   if (is.na(NA_character_)) 
[16:13:07.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:07.006]                   future::plan(list(function (..., workers = 2L, 
[16:13:07.006]                     envir = parent.frame()) 
[16:13:07.006]                   strategy(..., workers = workers, envir = envir)), 
[16:13:07.006]                     .cleanup = FALSE, .init = FALSE)
[16:13:07.006]                 }
[16:13:07.006]             }
[16:13:07.006]         }
[16:13:07.006]     })
[16:13:07.006]     if (TRUE) {
[16:13:07.006]         base::sink(type = "output", split = FALSE)
[16:13:07.006]         if (TRUE) {
[16:13:07.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:07.006]         }
[16:13:07.006]         else {
[16:13:07.006]             ...future.result["stdout"] <- base::list(NULL)
[16:13:07.006]         }
[16:13:07.006]         base::close(...future.stdout)
[16:13:07.006]         ...future.stdout <- NULL
[16:13:07.006]     }
[16:13:07.006]     ...future.result$conditions <- ...future.conditions
[16:13:07.006]     ...future.result$finished <- base::Sys.time()
[16:13:07.006]     ...future.result
[16:13:07.006] }
[16:13:07.009] MultisessionFuture started
[16:13:07.009] - Launch lazy future ... done
[16:13:07.009] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[16:13:07.009] result() for ClusterFuture ...
[16:13:07.010] receiveMessageFromWorker() for ClusterFuture ...
[16:13:07.010] - Validating connection of MultisessionFuture
[16:13:07.108] - received message: FutureResult
[16:13:07.109] - Received FutureResult
[16:13:07.109] - Erased future from FutureRegistry
[16:13:07.109] result() for ClusterFuture ...
[16:13:07.109] - result already collected: FutureResult
[16:13:07.109] result() for ClusterFuture ... done
[16:13:07.109] - Garbage collecting worker ...
[16:13:07.338] - Garbage collecting worker ... done
[16:13:07.338] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:07.339] result() for ClusterFuture ... done
[16:13:07.339] result() for ClusterFuture ...
[16:13:07.339] - result already collected: FutureResult
[16:13:07.339] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[16:13:07.340] getGlobalsAndPackages() ...
[16:13:07.340] Searching for globals...
[16:13:07.340] - globals found: [2] ‘{’, ‘gc’
[16:13:07.341] Searching for globals ... DONE
[16:13:07.341] Resolving globals: FALSE
[16:13:07.341] 
[16:13:07.341] 
[16:13:07.341] getGlobalsAndPackages() ... DONE
[16:13:07.341] run() for ‘Future’ ...
[16:13:07.342] - state: ‘created’
[16:13:07.342] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:07.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:07.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:07.353]   - Field: ‘node’
[16:13:07.353]   - Field: ‘label’
[16:13:07.353]   - Field: ‘local’
[16:13:07.353]   - Field: ‘owner’
[16:13:07.353]   - Field: ‘envir’
[16:13:07.353]   - Field: ‘workers’
[16:13:07.353]   - Field: ‘packages’
[16:13:07.354]   - Field: ‘gc’
[16:13:07.354]   - Field: ‘conditions’
[16:13:07.354]   - Field: ‘persistent’
[16:13:07.354]   - Field: ‘expr’
[16:13:07.354]   - Field: ‘uuid’
[16:13:07.354]   - Field: ‘seed’
[16:13:07.354]   - Field: ‘version’
[16:13:07.354]   - Field: ‘result’
[16:13:07.354]   - Field: ‘asynchronous’
[16:13:07.354]   - Field: ‘calls’
[16:13:07.354]   - Field: ‘globals’
[16:13:07.355]   - Field: ‘stdout’
[16:13:07.355]   - Field: ‘earlySignal’
[16:13:07.355]   - Field: ‘lazy’
[16:13:07.355]   - Field: ‘state’
[16:13:07.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:07.355] - Launch lazy future ...
[16:13:07.355] Packages needed by the future expression (n = 0): <none>
[16:13:07.355] Packages needed by future strategies (n = 0): <none>
[16:13:07.356] {
[16:13:07.356]     {
[16:13:07.356]         {
[16:13:07.356]             ...future.startTime <- base::Sys.time()
[16:13:07.356]             {
[16:13:07.356]                 {
[16:13:07.356]                   {
[16:13:07.356]                     {
[16:13:07.356]                       base::local({
[16:13:07.356]                         has_future <- base::requireNamespace("future", 
[16:13:07.356]                           quietly = TRUE)
[16:13:07.356]                         if (has_future) {
[16:13:07.356]                           ns <- base::getNamespace("future")
[16:13:07.356]                           version <- ns[[".package"]][["version"]]
[16:13:07.356]                           if (is.null(version)) 
[16:13:07.356]                             version <- utils::packageVersion("future")
[16:13:07.356]                         }
[16:13:07.356]                         else {
[16:13:07.356]                           version <- NULL
[16:13:07.356]                         }
[16:13:07.356]                         if (!has_future || version < "1.8.0") {
[16:13:07.356]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:07.356]                             "", base::R.version$version.string), 
[16:13:07.356]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:07.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:07.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:07.356]                               "release", "version")], collapse = " "), 
[16:13:07.356]                             hostname = base::Sys.info()[["nodename"]])
[16:13:07.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:07.356]                             info)
[16:13:07.356]                           info <- base::paste(info, collapse = "; ")
[16:13:07.356]                           if (!has_future) {
[16:13:07.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:07.356]                               info)
[16:13:07.356]                           }
[16:13:07.356]                           else {
[16:13:07.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:07.356]                               info, version)
[16:13:07.356]                           }
[16:13:07.356]                           base::stop(msg)
[16:13:07.356]                         }
[16:13:07.356]                       })
[16:13:07.356]                     }
[16:13:07.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:07.356]                     base::options(mc.cores = 1L)
[16:13:07.356]                   }
[16:13:07.356]                   options(future.plan = NULL)
[16:13:07.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:07.356]                 }
[16:13:07.356]                 ...future.workdir <- getwd()
[16:13:07.356]             }
[16:13:07.356]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:07.356]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:07.356]         }
[16:13:07.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:07.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:07.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:07.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:07.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:07.356]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:07.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:07.356]             base::names(...future.oldOptions))
[16:13:07.356]     }
[16:13:07.356]     if (FALSE) {
[16:13:07.356]     }
[16:13:07.356]     else {
[16:13:07.356]         if (TRUE) {
[16:13:07.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:07.356]                 open = "w")
[16:13:07.356]         }
[16:13:07.356]         else {
[16:13:07.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:07.356]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:07.356]         }
[16:13:07.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:07.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:07.356]             base::sink(type = "output", split = FALSE)
[16:13:07.356]             base::close(...future.stdout)
[16:13:07.356]         }, add = TRUE)
[16:13:07.356]     }
[16:13:07.356]     ...future.frame <- base::sys.nframe()
[16:13:07.356]     ...future.conditions <- base::list()
[16:13:07.356]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:07.356]     if (FALSE) {
[16:13:07.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:07.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:07.356]     }
[16:13:07.356]     ...future.result <- base::tryCatch({
[16:13:07.356]         base::withCallingHandlers({
[16:13:07.356]             ...future.value <- base::withVisible(base::local({
[16:13:07.356]                 ...future.makeSendCondition <- local({
[16:13:07.356]                   sendCondition <- NULL
[16:13:07.356]                   function(frame = 1L) {
[16:13:07.356]                     if (is.function(sendCondition)) 
[16:13:07.356]                       return(sendCondition)
[16:13:07.356]                     ns <- getNamespace("parallel")
[16:13:07.356]                     if (exists("sendData", mode = "function", 
[16:13:07.356]                       envir = ns)) {
[16:13:07.356]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:07.356]                         envir = ns)
[16:13:07.356]                       envir <- sys.frame(frame)
[16:13:07.356]                       master <- NULL
[16:13:07.356]                       while (!identical(envir, .GlobalEnv) && 
[16:13:07.356]                         !identical(envir, emptyenv())) {
[16:13:07.356]                         if (exists("master", mode = "list", envir = envir, 
[16:13:07.356]                           inherits = FALSE)) {
[16:13:07.356]                           master <- get("master", mode = "list", 
[16:13:07.356]                             envir = envir, inherits = FALSE)
[16:13:07.356]                           if (inherits(master, c("SOCKnode", 
[16:13:07.356]                             "SOCK0node"))) {
[16:13:07.356]                             sendCondition <<- function(cond) {
[16:13:07.356]                               data <- list(type = "VALUE", value = cond, 
[16:13:07.356]                                 success = TRUE)
[16:13:07.356]                               parallel_sendData(master, data)
[16:13:07.356]                             }
[16:13:07.356]                             return(sendCondition)
[16:13:07.356]                           }
[16:13:07.356]                         }
[16:13:07.356]                         frame <- frame + 1L
[16:13:07.356]                         envir <- sys.frame(frame)
[16:13:07.356]                       }
[16:13:07.356]                     }
[16:13:07.356]                     sendCondition <<- function(cond) NULL
[16:13:07.356]                   }
[16:13:07.356]                 })
[16:13:07.356]                 withCallingHandlers({
[16:13:07.356]                   {
[16:13:07.356]                     gc()
[16:13:07.356]                   }
[16:13:07.356]                 }, immediateCondition = function(cond) {
[16:13:07.356]                   sendCondition <- ...future.makeSendCondition()
[16:13:07.356]                   sendCondition(cond)
[16:13:07.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.356]                   {
[16:13:07.356]                     inherits <- base::inherits
[16:13:07.356]                     invokeRestart <- base::invokeRestart
[16:13:07.356]                     is.null <- base::is.null
[16:13:07.356]                     muffled <- FALSE
[16:13:07.356]                     if (inherits(cond, "message")) {
[16:13:07.356]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:07.356]                       if (muffled) 
[16:13:07.356]                         invokeRestart("muffleMessage")
[16:13:07.356]                     }
[16:13:07.356]                     else if (inherits(cond, "warning")) {
[16:13:07.356]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:07.356]                       if (muffled) 
[16:13:07.356]                         invokeRestart("muffleWarning")
[16:13:07.356]                     }
[16:13:07.356]                     else if (inherits(cond, "condition")) {
[16:13:07.356]                       if (!is.null(pattern)) {
[16:13:07.356]                         computeRestarts <- base::computeRestarts
[16:13:07.356]                         grepl <- base::grepl
[16:13:07.356]                         restarts <- computeRestarts(cond)
[16:13:07.356]                         for (restart in restarts) {
[16:13:07.356]                           name <- restart$name
[16:13:07.356]                           if (is.null(name)) 
[16:13:07.356]                             next
[16:13:07.356]                           if (!grepl(pattern, name)) 
[16:13:07.356]                             next
[16:13:07.356]                           invokeRestart(restart)
[16:13:07.356]                           muffled <- TRUE
[16:13:07.356]                           break
[16:13:07.356]                         }
[16:13:07.356]                       }
[16:13:07.356]                     }
[16:13:07.356]                     invisible(muffled)
[16:13:07.356]                   }
[16:13:07.356]                   muffleCondition(cond)
[16:13:07.356]                 })
[16:13:07.356]             }))
[16:13:07.356]             future::FutureResult(value = ...future.value$value, 
[16:13:07.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.356]                   ...future.rng), globalenv = if (FALSE) 
[16:13:07.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:07.356]                     ...future.globalenv.names))
[16:13:07.356]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:07.356]         }, condition = base::local({
[16:13:07.356]             c <- base::c
[16:13:07.356]             inherits <- base::inherits
[16:13:07.356]             invokeRestart <- base::invokeRestart
[16:13:07.356]             length <- base::length
[16:13:07.356]             list <- base::list
[16:13:07.356]             seq.int <- base::seq.int
[16:13:07.356]             signalCondition <- base::signalCondition
[16:13:07.356]             sys.calls <- base::sys.calls
[16:13:07.356]             `[[` <- base::`[[`
[16:13:07.356]             `+` <- base::`+`
[16:13:07.356]             `<<-` <- base::`<<-`
[16:13:07.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:07.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:07.356]                   3L)]
[16:13:07.356]             }
[16:13:07.356]             function(cond) {
[16:13:07.356]                 is_error <- inherits(cond, "error")
[16:13:07.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:07.356]                   NULL)
[16:13:07.356]                 if (is_error) {
[16:13:07.356]                   sessionInformation <- function() {
[16:13:07.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:07.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:07.356]                       search = base::search(), system = base::Sys.info())
[16:13:07.356]                   }
[16:13:07.356]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:07.356]                     cond$call), session = sessionInformation(), 
[16:13:07.356]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:07.356]                   signalCondition(cond)
[16:13:07.356]                 }
[16:13:07.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:07.356]                 "immediateCondition"))) {
[16:13:07.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:07.356]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:07.356]                   if (TRUE && !signal) {
[16:13:07.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.356]                     {
[16:13:07.356]                       inherits <- base::inherits
[16:13:07.356]                       invokeRestart <- base::invokeRestart
[16:13:07.356]                       is.null <- base::is.null
[16:13:07.356]                       muffled <- FALSE
[16:13:07.356]                       if (inherits(cond, "message")) {
[16:13:07.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.356]                         if (muffled) 
[16:13:07.356]                           invokeRestart("muffleMessage")
[16:13:07.356]                       }
[16:13:07.356]                       else if (inherits(cond, "warning")) {
[16:13:07.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.356]                         if (muffled) 
[16:13:07.356]                           invokeRestart("muffleWarning")
[16:13:07.356]                       }
[16:13:07.356]                       else if (inherits(cond, "condition")) {
[16:13:07.356]                         if (!is.null(pattern)) {
[16:13:07.356]                           computeRestarts <- base::computeRestarts
[16:13:07.356]                           grepl <- base::grepl
[16:13:07.356]                           restarts <- computeRestarts(cond)
[16:13:07.356]                           for (restart in restarts) {
[16:13:07.356]                             name <- restart$name
[16:13:07.356]                             if (is.null(name)) 
[16:13:07.356]                               next
[16:13:07.356]                             if (!grepl(pattern, name)) 
[16:13:07.356]                               next
[16:13:07.356]                             invokeRestart(restart)
[16:13:07.356]                             muffled <- TRUE
[16:13:07.356]                             break
[16:13:07.356]                           }
[16:13:07.356]                         }
[16:13:07.356]                       }
[16:13:07.356]                       invisible(muffled)
[16:13:07.356]                     }
[16:13:07.356]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.356]                   }
[16:13:07.356]                 }
[16:13:07.356]                 else {
[16:13:07.356]                   if (TRUE) {
[16:13:07.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.356]                     {
[16:13:07.356]                       inherits <- base::inherits
[16:13:07.356]                       invokeRestart <- base::invokeRestart
[16:13:07.356]                       is.null <- base::is.null
[16:13:07.356]                       muffled <- FALSE
[16:13:07.356]                       if (inherits(cond, "message")) {
[16:13:07.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.356]                         if (muffled) 
[16:13:07.356]                           invokeRestart("muffleMessage")
[16:13:07.356]                       }
[16:13:07.356]                       else if (inherits(cond, "warning")) {
[16:13:07.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.356]                         if (muffled) 
[16:13:07.356]                           invokeRestart("muffleWarning")
[16:13:07.356]                       }
[16:13:07.356]                       else if (inherits(cond, "condition")) {
[16:13:07.356]                         if (!is.null(pattern)) {
[16:13:07.356]                           computeRestarts <- base::computeRestarts
[16:13:07.356]                           grepl <- base::grepl
[16:13:07.356]                           restarts <- computeRestarts(cond)
[16:13:07.356]                           for (restart in restarts) {
[16:13:07.356]                             name <- restart$name
[16:13:07.356]                             if (is.null(name)) 
[16:13:07.356]                               next
[16:13:07.356]                             if (!grepl(pattern, name)) 
[16:13:07.356]                               next
[16:13:07.356]                             invokeRestart(restart)
[16:13:07.356]                             muffled <- TRUE
[16:13:07.356]                             break
[16:13:07.356]                           }
[16:13:07.356]                         }
[16:13:07.356]                       }
[16:13:07.356]                       invisible(muffled)
[16:13:07.356]                     }
[16:13:07.356]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.356]                   }
[16:13:07.356]                 }
[16:13:07.356]             }
[16:13:07.356]         }))
[16:13:07.356]     }, error = function(ex) {
[16:13:07.356]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:07.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.356]                 ...future.rng), started = ...future.startTime, 
[16:13:07.356]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:07.356]             version = "1.8"), class = "FutureResult")
[16:13:07.356]     }, finally = {
[16:13:07.356]         if (!identical(...future.workdir, getwd())) 
[16:13:07.356]             setwd(...future.workdir)
[16:13:07.356]         {
[16:13:07.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:07.356]                 ...future.oldOptions$nwarnings <- NULL
[16:13:07.356]             }
[16:13:07.356]             base::options(...future.oldOptions)
[16:13:07.356]             if (.Platform$OS.type == "windows") {
[16:13:07.356]                 old_names <- names(...future.oldEnvVars)
[16:13:07.356]                 envs <- base::Sys.getenv()
[16:13:07.356]                 names <- names(envs)
[16:13:07.356]                 common <- intersect(names, old_names)
[16:13:07.356]                 added <- setdiff(names, old_names)
[16:13:07.356]                 removed <- setdiff(old_names, names)
[16:13:07.356]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:07.356]                   envs[common]]
[16:13:07.356]                 NAMES <- toupper(changed)
[16:13:07.356]                 args <- list()
[16:13:07.356]                 for (kk in seq_along(NAMES)) {
[16:13:07.356]                   name <- changed[[kk]]
[16:13:07.356]                   NAME <- NAMES[[kk]]
[16:13:07.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.356]                     next
[16:13:07.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.356]                 }
[16:13:07.356]                 NAMES <- toupper(added)
[16:13:07.356]                 for (kk in seq_along(NAMES)) {
[16:13:07.356]                   name <- added[[kk]]
[16:13:07.356]                   NAME <- NAMES[[kk]]
[16:13:07.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.356]                     next
[16:13:07.356]                   args[[name]] <- ""
[16:13:07.356]                 }
[16:13:07.356]                 NAMES <- toupper(removed)
[16:13:07.356]                 for (kk in seq_along(NAMES)) {
[16:13:07.356]                   name <- removed[[kk]]
[16:13:07.356]                   NAME <- NAMES[[kk]]
[16:13:07.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.356]                     next
[16:13:07.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.356]                 }
[16:13:07.356]                 if (length(args) > 0) 
[16:13:07.356]                   base::do.call(base::Sys.setenv, args = args)
[16:13:07.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:07.356]             }
[16:13:07.356]             else {
[16:13:07.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:07.356]             }
[16:13:07.356]             {
[16:13:07.356]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:07.356]                   0L) {
[16:13:07.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:07.356]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:07.356]                   base::options(opts)
[16:13:07.356]                 }
[16:13:07.356]                 {
[16:13:07.356]                   {
[16:13:07.356]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:07.356]                     NULL
[16:13:07.356]                   }
[16:13:07.356]                   options(future.plan = NULL)
[16:13:07.356]                   if (is.na(NA_character_)) 
[16:13:07.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:07.356]                   future::plan(list(function (..., workers = 2L, 
[16:13:07.356]                     envir = parent.frame()) 
[16:13:07.356]                   strategy(..., workers = workers, envir = envir)), 
[16:13:07.356]                     .cleanup = FALSE, .init = FALSE)
[16:13:07.356]                 }
[16:13:07.356]             }
[16:13:07.356]         }
[16:13:07.356]     })
[16:13:07.356]     if (TRUE) {
[16:13:07.356]         base::sink(type = "output", split = FALSE)
[16:13:07.356]         if (TRUE) {
[16:13:07.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:07.356]         }
[16:13:07.356]         else {
[16:13:07.356]             ...future.result["stdout"] <- base::list(NULL)
[16:13:07.356]         }
[16:13:07.356]         base::close(...future.stdout)
[16:13:07.356]         ...future.stdout <- NULL
[16:13:07.356]     }
[16:13:07.356]     ...future.result$conditions <- ...future.conditions
[16:13:07.356]     ...future.result$finished <- base::Sys.time()
[16:13:07.356]     ...future.result
[16:13:07.356] }
[16:13:07.359] MultisessionFuture started
[16:13:07.359] - Launch lazy future ... done
[16:13:07.359] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[16:13:07.359] result() for ClusterFuture ...
[16:13:07.359] receiveMessageFromWorker() for ClusterFuture ...
[16:13:07.360] - Validating connection of MultisessionFuture
[16:13:07.424] - received message: FutureResult
[16:13:07.424] - Received FutureResult
[16:13:07.424] - Erased future from FutureRegistry
[16:13:07.424] result() for ClusterFuture ...
[16:13:07.424] - result already collected: FutureResult
[16:13:07.425] result() for ClusterFuture ... done
[16:13:07.425] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:07.425] result() for ClusterFuture ... done
[16:13:07.425] result() for ClusterFuture ...
[16:13:07.425] - result already collected: FutureResult
[16:13:07.425] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 395340 21.2     836944  44.7   664120  35.5
Vcells 705085  5.4   13458040 102.7 15781491 120.5
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[16:13:07.426] plan(): Setting new future strategy stack:
[16:13:07.426] List of future strategies:
[16:13:07.426] 1. multisession:
[16:13:07.426]    - args: function (..., workers = 2L, envir = parent.frame())
[16:13:07.426]    - tweaked: TRUE
[16:13:07.426]    - call: plan(multisession, workers = 2L)
[16:13:07.427] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:13:07.427] multisession:
[16:13:07.427] - args: function (..., workers = 2L, envir = parent.frame())
[16:13:07.427] - tweaked: TRUE
[16:13:07.427] - call: plan(multisession, workers = 2L)
[16:13:07.427] getGlobalsAndPackages() ...
[16:13:07.428] Not searching for globals
[16:13:07.428] - globals: [0] <none>
[16:13:07.428] getGlobalsAndPackages() ... DONE
[16:13:07.429] [local output] makeClusterPSOCK() ...
[16:13:07.429] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:13:07.430] [local output] Base port: 11251
[16:13:07.430] [local output] Getting setup options for 2 cluster nodes ...
[16:13:07.430] [local output]  - Node 1 of 2 ...
[16:13:07.431] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:07.432] [local output] Rscript port: 11251

[16:13:07.432] [local output]  - Node 2 of 2 ...
[16:13:07.433] [local output] localMachine=TRUE => revtunnel=FALSE

[16:13:07.433] [local output] Rscript port: 11251

[16:13:07.434] [local output] Getting setup options for 2 cluster nodes ... done
[16:13:07.434] [local output]  - Parallel setup requested for some PSOCK nodes
[16:13:07.434] [local output] Setting up PSOCK nodes in parallel
[16:13:07.435] List of 36
[16:13:07.435]  $ worker          : chr "localhost"
[16:13:07.435]   ..- attr(*, "localhost")= logi TRUE
[16:13:07.435]  $ master          : chr "localhost"
[16:13:07.435]  $ port            : int 11251
[16:13:07.435]  $ connectTimeout  : num 120
[16:13:07.435]  $ timeout         : num 2592000
[16:13:07.435]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:13:07.435]  $ homogeneous     : logi TRUE
[16:13:07.435]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:13:07.435]  $ rscript_envs    : NULL
[16:13:07.435]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:07.435]  $ rscript_startup : NULL
[16:13:07.435]  $ rscript_sh      : chr "sh"
[16:13:07.435]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:07.435]  $ methods         : logi TRUE
[16:13:07.435]  $ socketOptions   : chr "no-delay"
[16:13:07.435]  $ useXDR          : logi FALSE
[16:13:07.435]  $ outfile         : chr "/dev/null"
[16:13:07.435]  $ renice          : int NA
[16:13:07.435]  $ rshcmd          : NULL
[16:13:07.435]  $ user            : chr(0) 
[16:13:07.435]  $ revtunnel       : logi FALSE
[16:13:07.435]  $ rshlogfile      : NULL
[16:13:07.435]  $ rshopts         : chr(0) 
[16:13:07.435]  $ rank            : int 1
[16:13:07.435]  $ manual          : logi FALSE
[16:13:07.435]  $ dryrun          : logi FALSE
[16:13:07.435]  $ quiet           : logi FALSE
[16:13:07.435]  $ setup_strategy  : chr "parallel"
[16:13:07.435]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:07.435]  $ pidfile         : chr "/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.1548154c6dcb1.pid"
[16:13:07.435]  $ rshcmd_label    : NULL
[16:13:07.435]  $ rsh_call        : NULL
[16:13:07.435]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:13:07.435]  $ localMachine    : logi TRUE
[16:13:07.435]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:13:07.435]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:13:07.435]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:13:07.435]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:13:07.435]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:13:07.435]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:13:07.435]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:13:07.435]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:13:07.435]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:13:07.435]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:13:07.435]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:13:07.435]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:13:07.435]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:13:07.435]  $ arguments       :List of 28
[16:13:07.435]   ..$ worker          : chr "localhost"
[16:13:07.435]   ..$ master          : NULL
[16:13:07.435]   ..$ port            : int 11251
[16:13:07.435]   ..$ connectTimeout  : num 120
[16:13:07.435]   ..$ timeout         : num 2592000
[16:13:07.435]   ..$ rscript         : NULL
[16:13:07.435]   ..$ homogeneous     : NULL
[16:13:07.435]   ..$ rscript_args    : NULL
[16:13:07.435]   ..$ rscript_envs    : NULL
[16:13:07.435]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:13:07.435]   ..$ rscript_startup : NULL
[16:13:07.435]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:13:07.435]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:13:07.435]   ..$ methods         : logi TRUE
[16:13:07.435]   ..$ socketOptions   : chr "no-delay"
[16:13:07.435]   ..$ useXDR          : logi FALSE
[16:13:07.435]   ..$ outfile         : chr "/dev/null"
[16:13:07.435]   ..$ renice          : int NA
[16:13:07.435]   ..$ rshcmd          : NULL
[16:13:07.435]   ..$ user            : NULL
[16:13:07.435]   ..$ revtunnel       : logi NA
[16:13:07.435]   ..$ rshlogfile      : NULL
[16:13:07.435]   ..$ rshopts         : NULL
[16:13:07.435]   ..$ rank            : int 1
[16:13:07.435]   ..$ manual          : logi FALSE
[16:13:07.435]   ..$ dryrun          : logi FALSE
[16:13:07.435]   ..$ quiet           : logi FALSE
[16:13:07.435]   ..$ setup_strategy  : chr "parallel"
[16:13:07.435]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:13:07.456] [local output] System call to launch all workers:
[16:13:07.456] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRABeuA/worker.rank=1.parallelly.parent=87169.1548154c6dcb1.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11251 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:13:07.456] [local output] Starting PSOCK main server
[16:13:07.458] [local output] Workers launched
[16:13:07.458] [local output] Waiting for workers to connect back
[16:13:07.458]  - [local output] 0 workers out of 2 ready
[16:13:07.716]  - [local output] 0 workers out of 2 ready
[16:13:07.717]  - [local output] 1 workers out of 2 ready
[16:13:07.721]  - [local output] 1 workers out of 2 ready
[16:13:07.721]  - [local output] 2 workers out of 2 ready
[16:13:07.721] [local output] Launching of workers completed
[16:13:07.721] [local output] Collecting session information from workers
[16:13:07.722] [local output]  - Worker #1 of 2
[16:13:07.722] [local output]  - Worker #2 of 2
[16:13:07.723] [local output] makeClusterPSOCK() ... done
[16:13:07.734] Packages needed by the future expression (n = 0): <none>
[16:13:07.734] Packages needed by future strategies (n = 0): <none>
[16:13:07.734] {
[16:13:07.734]     {
[16:13:07.734]         {
[16:13:07.734]             ...future.startTime <- base::Sys.time()
[16:13:07.734]             {
[16:13:07.734]                 {
[16:13:07.734]                   {
[16:13:07.734]                     {
[16:13:07.734]                       base::local({
[16:13:07.734]                         has_future <- base::requireNamespace("future", 
[16:13:07.734]                           quietly = TRUE)
[16:13:07.734]                         if (has_future) {
[16:13:07.734]                           ns <- base::getNamespace("future")
[16:13:07.734]                           version <- ns[[".package"]][["version"]]
[16:13:07.734]                           if (is.null(version)) 
[16:13:07.734]                             version <- utils::packageVersion("future")
[16:13:07.734]                         }
[16:13:07.734]                         else {
[16:13:07.734]                           version <- NULL
[16:13:07.734]                         }
[16:13:07.734]                         if (!has_future || version < "1.8.0") {
[16:13:07.734]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:07.734]                             "", base::R.version$version.string), 
[16:13:07.734]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:07.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:07.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:07.734]                               "release", "version")], collapse = " "), 
[16:13:07.734]                             hostname = base::Sys.info()[["nodename"]])
[16:13:07.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:07.734]                             info)
[16:13:07.734]                           info <- base::paste(info, collapse = "; ")
[16:13:07.734]                           if (!has_future) {
[16:13:07.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:07.734]                               info)
[16:13:07.734]                           }
[16:13:07.734]                           else {
[16:13:07.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:07.734]                               info, version)
[16:13:07.734]                           }
[16:13:07.734]                           base::stop(msg)
[16:13:07.734]                         }
[16:13:07.734]                       })
[16:13:07.734]                     }
[16:13:07.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:07.734]                     base::options(mc.cores = 1L)
[16:13:07.734]                   }
[16:13:07.734]                   options(future.plan = NULL)
[16:13:07.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:07.734]                 }
[16:13:07.734]                 ...future.workdir <- getwd()
[16:13:07.734]             }
[16:13:07.734]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:07.734]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:07.734]         }
[16:13:07.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:07.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:07.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:07.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:07.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:07.734]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:07.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:07.734]             base::names(...future.oldOptions))
[16:13:07.734]     }
[16:13:07.734]     if (FALSE) {
[16:13:07.734]     }
[16:13:07.734]     else {
[16:13:07.734]         if (TRUE) {
[16:13:07.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:07.734]                 open = "w")
[16:13:07.734]         }
[16:13:07.734]         else {
[16:13:07.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:07.734]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:07.734]         }
[16:13:07.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:07.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:07.734]             base::sink(type = "output", split = FALSE)
[16:13:07.734]             base::close(...future.stdout)
[16:13:07.734]         }, add = TRUE)
[16:13:07.734]     }
[16:13:07.734]     ...future.frame <- base::sys.nframe()
[16:13:07.734]     ...future.conditions <- base::list()
[16:13:07.734]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:07.734]     if (FALSE) {
[16:13:07.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:07.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:07.734]     }
[16:13:07.734]     ...future.result <- base::tryCatch({
[16:13:07.734]         base::withCallingHandlers({
[16:13:07.734]             ...future.value <- base::withVisible(base::local({
[16:13:07.734]                 ...future.makeSendCondition <- local({
[16:13:07.734]                   sendCondition <- NULL
[16:13:07.734]                   function(frame = 1L) {
[16:13:07.734]                     if (is.function(sendCondition)) 
[16:13:07.734]                       return(sendCondition)
[16:13:07.734]                     ns <- getNamespace("parallel")
[16:13:07.734]                     if (exists("sendData", mode = "function", 
[16:13:07.734]                       envir = ns)) {
[16:13:07.734]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:07.734]                         envir = ns)
[16:13:07.734]                       envir <- sys.frame(frame)
[16:13:07.734]                       master <- NULL
[16:13:07.734]                       while (!identical(envir, .GlobalEnv) && 
[16:13:07.734]                         !identical(envir, emptyenv())) {
[16:13:07.734]                         if (exists("master", mode = "list", envir = envir, 
[16:13:07.734]                           inherits = FALSE)) {
[16:13:07.734]                           master <- get("master", mode = "list", 
[16:13:07.734]                             envir = envir, inherits = FALSE)
[16:13:07.734]                           if (inherits(master, c("SOCKnode", 
[16:13:07.734]                             "SOCK0node"))) {
[16:13:07.734]                             sendCondition <<- function(cond) {
[16:13:07.734]                               data <- list(type = "VALUE", value = cond, 
[16:13:07.734]                                 success = TRUE)
[16:13:07.734]                               parallel_sendData(master, data)
[16:13:07.734]                             }
[16:13:07.734]                             return(sendCondition)
[16:13:07.734]                           }
[16:13:07.734]                         }
[16:13:07.734]                         frame <- frame + 1L
[16:13:07.734]                         envir <- sys.frame(frame)
[16:13:07.734]                       }
[16:13:07.734]                     }
[16:13:07.734]                     sendCondition <<- function(cond) NULL
[16:13:07.734]                   }
[16:13:07.734]                 })
[16:13:07.734]                 withCallingHandlers({
[16:13:07.734]                   NA
[16:13:07.734]                 }, immediateCondition = function(cond) {
[16:13:07.734]                   sendCondition <- ...future.makeSendCondition()
[16:13:07.734]                   sendCondition(cond)
[16:13:07.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.734]                   {
[16:13:07.734]                     inherits <- base::inherits
[16:13:07.734]                     invokeRestart <- base::invokeRestart
[16:13:07.734]                     is.null <- base::is.null
[16:13:07.734]                     muffled <- FALSE
[16:13:07.734]                     if (inherits(cond, "message")) {
[16:13:07.734]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:07.734]                       if (muffled) 
[16:13:07.734]                         invokeRestart("muffleMessage")
[16:13:07.734]                     }
[16:13:07.734]                     else if (inherits(cond, "warning")) {
[16:13:07.734]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:07.734]                       if (muffled) 
[16:13:07.734]                         invokeRestart("muffleWarning")
[16:13:07.734]                     }
[16:13:07.734]                     else if (inherits(cond, "condition")) {
[16:13:07.734]                       if (!is.null(pattern)) {
[16:13:07.734]                         computeRestarts <- base::computeRestarts
[16:13:07.734]                         grepl <- base::grepl
[16:13:07.734]                         restarts <- computeRestarts(cond)
[16:13:07.734]                         for (restart in restarts) {
[16:13:07.734]                           name <- restart$name
[16:13:07.734]                           if (is.null(name)) 
[16:13:07.734]                             next
[16:13:07.734]                           if (!grepl(pattern, name)) 
[16:13:07.734]                             next
[16:13:07.734]                           invokeRestart(restart)
[16:13:07.734]                           muffled <- TRUE
[16:13:07.734]                           break
[16:13:07.734]                         }
[16:13:07.734]                       }
[16:13:07.734]                     }
[16:13:07.734]                     invisible(muffled)
[16:13:07.734]                   }
[16:13:07.734]                   muffleCondition(cond)
[16:13:07.734]                 })
[16:13:07.734]             }))
[16:13:07.734]             future::FutureResult(value = ...future.value$value, 
[16:13:07.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.734]                   ...future.rng), globalenv = if (FALSE) 
[16:13:07.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:07.734]                     ...future.globalenv.names))
[16:13:07.734]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:07.734]         }, condition = base::local({
[16:13:07.734]             c <- base::c
[16:13:07.734]             inherits <- base::inherits
[16:13:07.734]             invokeRestart <- base::invokeRestart
[16:13:07.734]             length <- base::length
[16:13:07.734]             list <- base::list
[16:13:07.734]             seq.int <- base::seq.int
[16:13:07.734]             signalCondition <- base::signalCondition
[16:13:07.734]             sys.calls <- base::sys.calls
[16:13:07.734]             `[[` <- base::`[[`
[16:13:07.734]             `+` <- base::`+`
[16:13:07.734]             `<<-` <- base::`<<-`
[16:13:07.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:07.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:07.734]                   3L)]
[16:13:07.734]             }
[16:13:07.734]             function(cond) {
[16:13:07.734]                 is_error <- inherits(cond, "error")
[16:13:07.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:07.734]                   NULL)
[16:13:07.734]                 if (is_error) {
[16:13:07.734]                   sessionInformation <- function() {
[16:13:07.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:07.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:07.734]                       search = base::search(), system = base::Sys.info())
[16:13:07.734]                   }
[16:13:07.734]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:07.734]                     cond$call), session = sessionInformation(), 
[16:13:07.734]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:07.734]                   signalCondition(cond)
[16:13:07.734]                 }
[16:13:07.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:07.734]                 "immediateCondition"))) {
[16:13:07.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:07.734]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:07.734]                   if (TRUE && !signal) {
[16:13:07.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.734]                     {
[16:13:07.734]                       inherits <- base::inherits
[16:13:07.734]                       invokeRestart <- base::invokeRestart
[16:13:07.734]                       is.null <- base::is.null
[16:13:07.734]                       muffled <- FALSE
[16:13:07.734]                       if (inherits(cond, "message")) {
[16:13:07.734]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.734]                         if (muffled) 
[16:13:07.734]                           invokeRestart("muffleMessage")
[16:13:07.734]                       }
[16:13:07.734]                       else if (inherits(cond, "warning")) {
[16:13:07.734]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.734]                         if (muffled) 
[16:13:07.734]                           invokeRestart("muffleWarning")
[16:13:07.734]                       }
[16:13:07.734]                       else if (inherits(cond, "condition")) {
[16:13:07.734]                         if (!is.null(pattern)) {
[16:13:07.734]                           computeRestarts <- base::computeRestarts
[16:13:07.734]                           grepl <- base::grepl
[16:13:07.734]                           restarts <- computeRestarts(cond)
[16:13:07.734]                           for (restart in restarts) {
[16:13:07.734]                             name <- restart$name
[16:13:07.734]                             if (is.null(name)) 
[16:13:07.734]                               next
[16:13:07.734]                             if (!grepl(pattern, name)) 
[16:13:07.734]                               next
[16:13:07.734]                             invokeRestart(restart)
[16:13:07.734]                             muffled <- TRUE
[16:13:07.734]                             break
[16:13:07.734]                           }
[16:13:07.734]                         }
[16:13:07.734]                       }
[16:13:07.734]                       invisible(muffled)
[16:13:07.734]                     }
[16:13:07.734]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.734]                   }
[16:13:07.734]                 }
[16:13:07.734]                 else {
[16:13:07.734]                   if (TRUE) {
[16:13:07.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.734]                     {
[16:13:07.734]                       inherits <- base::inherits
[16:13:07.734]                       invokeRestart <- base::invokeRestart
[16:13:07.734]                       is.null <- base::is.null
[16:13:07.734]                       muffled <- FALSE
[16:13:07.734]                       if (inherits(cond, "message")) {
[16:13:07.734]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.734]                         if (muffled) 
[16:13:07.734]                           invokeRestart("muffleMessage")
[16:13:07.734]                       }
[16:13:07.734]                       else if (inherits(cond, "warning")) {
[16:13:07.734]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.734]                         if (muffled) 
[16:13:07.734]                           invokeRestart("muffleWarning")
[16:13:07.734]                       }
[16:13:07.734]                       else if (inherits(cond, "condition")) {
[16:13:07.734]                         if (!is.null(pattern)) {
[16:13:07.734]                           computeRestarts <- base::computeRestarts
[16:13:07.734]                           grepl <- base::grepl
[16:13:07.734]                           restarts <- computeRestarts(cond)
[16:13:07.734]                           for (restart in restarts) {
[16:13:07.734]                             name <- restart$name
[16:13:07.734]                             if (is.null(name)) 
[16:13:07.734]                               next
[16:13:07.734]                             if (!grepl(pattern, name)) 
[16:13:07.734]                               next
[16:13:07.734]                             invokeRestart(restart)
[16:13:07.734]                             muffled <- TRUE
[16:13:07.734]                             break
[16:13:07.734]                           }
[16:13:07.734]                         }
[16:13:07.734]                       }
[16:13:07.734]                       invisible(muffled)
[16:13:07.734]                     }
[16:13:07.734]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.734]                   }
[16:13:07.734]                 }
[16:13:07.734]             }
[16:13:07.734]         }))
[16:13:07.734]     }, error = function(ex) {
[16:13:07.734]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:07.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.734]                 ...future.rng), started = ...future.startTime, 
[16:13:07.734]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:07.734]             version = "1.8"), class = "FutureResult")
[16:13:07.734]     }, finally = {
[16:13:07.734]         if (!identical(...future.workdir, getwd())) 
[16:13:07.734]             setwd(...future.workdir)
[16:13:07.734]         {
[16:13:07.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:07.734]                 ...future.oldOptions$nwarnings <- NULL
[16:13:07.734]             }
[16:13:07.734]             base::options(...future.oldOptions)
[16:13:07.734]             if (.Platform$OS.type == "windows") {
[16:13:07.734]                 old_names <- names(...future.oldEnvVars)
[16:13:07.734]                 envs <- base::Sys.getenv()
[16:13:07.734]                 names <- names(envs)
[16:13:07.734]                 common <- intersect(names, old_names)
[16:13:07.734]                 added <- setdiff(names, old_names)
[16:13:07.734]                 removed <- setdiff(old_names, names)
[16:13:07.734]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:07.734]                   envs[common]]
[16:13:07.734]                 NAMES <- toupper(changed)
[16:13:07.734]                 args <- list()
[16:13:07.734]                 for (kk in seq_along(NAMES)) {
[16:13:07.734]                   name <- changed[[kk]]
[16:13:07.734]                   NAME <- NAMES[[kk]]
[16:13:07.734]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.734]                     next
[16:13:07.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.734]                 }
[16:13:07.734]                 NAMES <- toupper(added)
[16:13:07.734]                 for (kk in seq_along(NAMES)) {
[16:13:07.734]                   name <- added[[kk]]
[16:13:07.734]                   NAME <- NAMES[[kk]]
[16:13:07.734]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.734]                     next
[16:13:07.734]                   args[[name]] <- ""
[16:13:07.734]                 }
[16:13:07.734]                 NAMES <- toupper(removed)
[16:13:07.734]                 for (kk in seq_along(NAMES)) {
[16:13:07.734]                   name <- removed[[kk]]
[16:13:07.734]                   NAME <- NAMES[[kk]]
[16:13:07.734]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.734]                     next
[16:13:07.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.734]                 }
[16:13:07.734]                 if (length(args) > 0) 
[16:13:07.734]                   base::do.call(base::Sys.setenv, args = args)
[16:13:07.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:07.734]             }
[16:13:07.734]             else {
[16:13:07.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:07.734]             }
[16:13:07.734]             {
[16:13:07.734]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:07.734]                   0L) {
[16:13:07.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:07.734]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:07.734]                   base::options(opts)
[16:13:07.734]                 }
[16:13:07.734]                 {
[16:13:07.734]                   {
[16:13:07.734]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:07.734]                     NULL
[16:13:07.734]                   }
[16:13:07.734]                   options(future.plan = NULL)
[16:13:07.734]                   if (is.na(NA_character_)) 
[16:13:07.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:07.734]                   future::plan(list(function (..., workers = 2L, 
[16:13:07.734]                     envir = parent.frame()) 
[16:13:07.734]                   strategy(..., workers = workers, envir = envir)), 
[16:13:07.734]                     .cleanup = FALSE, .init = FALSE)
[16:13:07.734]                 }
[16:13:07.734]             }
[16:13:07.734]         }
[16:13:07.734]     })
[16:13:07.734]     if (TRUE) {
[16:13:07.734]         base::sink(type = "output", split = FALSE)
[16:13:07.734]         if (TRUE) {
[16:13:07.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:07.734]         }
[16:13:07.734]         else {
[16:13:07.734]             ...future.result["stdout"] <- base::list(NULL)
[16:13:07.734]         }
[16:13:07.734]         base::close(...future.stdout)
[16:13:07.734]         ...future.stdout <- NULL
[16:13:07.734]     }
[16:13:07.734]     ...future.result$conditions <- ...future.conditions
[16:13:07.734]     ...future.result$finished <- base::Sys.time()
[16:13:07.734]     ...future.result
[16:13:07.734] }
[16:13:07.805] MultisessionFuture started
[16:13:07.805] result() for ClusterFuture ...
[16:13:07.805] receiveMessageFromWorker() for ClusterFuture ...
[16:13:07.806] - Validating connection of MultisessionFuture
[16:13:07.830] - received message: FutureResult
[16:13:07.830] - Received FutureResult
[16:13:07.830] - Erased future from FutureRegistry
[16:13:07.830] result() for ClusterFuture ...
[16:13:07.830] - result already collected: FutureResult
[16:13:07.830] result() for ClusterFuture ... done
[16:13:07.830] receiveMessageFromWorker() for ClusterFuture ... done
[16:13:07.830] result() for ClusterFuture ... done
[16:13:07.831] result() for ClusterFuture ...
[16:13:07.831] - result already collected: FutureResult
[16:13:07.831] result() for ClusterFuture ... done
[16:13:07.831] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:13:07.831] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[16:13:07.831] getGlobalsAndPackages() ...
[16:13:07.831] Searching for globals...
[16:13:07.832] 
[16:13:07.832] Searching for globals ... DONE
[16:13:07.832] - globals: [0] <none>
[16:13:07.832] getGlobalsAndPackages() ... DONE
[16:13:07.832] run() for ‘Future’ ...
[16:13:07.832] - state: ‘created’
[16:13:07.833] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:13:07.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:13:07.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:13:07.844]   - Field: ‘node’
[16:13:07.844]   - Field: ‘label’
[16:13:07.844]   - Field: ‘local’
[16:13:07.844]   - Field: ‘owner’
[16:13:07.844]   - Field: ‘envir’
[16:13:07.844]   - Field: ‘workers’
[16:13:07.844]   - Field: ‘packages’
[16:13:07.844]   - Field: ‘gc’
[16:13:07.845]   - Field: ‘conditions’
[16:13:07.845]   - Field: ‘persistent’
[16:13:07.845]   - Field: ‘expr’
[16:13:07.845]   - Field: ‘uuid’
[16:13:07.845]   - Field: ‘seed’
[16:13:07.845]   - Field: ‘version’
[16:13:07.845]   - Field: ‘result’
[16:13:07.845]   - Field: ‘asynchronous’
[16:13:07.845]   - Field: ‘calls’
[16:13:07.845]   - Field: ‘globals’
[16:13:07.846]   - Field: ‘stdout’
[16:13:07.846]   - Field: ‘earlySignal’
[16:13:07.846]   - Field: ‘lazy’
[16:13:07.846]   - Field: ‘state’
[16:13:07.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:13:07.846] - Launch lazy future ...
[16:13:07.846] Packages needed by the future expression (n = 0): <none>
[16:13:07.846] Packages needed by future strategies (n = 0): <none>
[16:13:07.847] {
[16:13:07.847]     {
[16:13:07.847]         {
[16:13:07.847]             ...future.startTime <- base::Sys.time()
[16:13:07.847]             {
[16:13:07.847]                 {
[16:13:07.847]                   {
[16:13:07.847]                     {
[16:13:07.847]                       base::local({
[16:13:07.847]                         has_future <- base::requireNamespace("future", 
[16:13:07.847]                           quietly = TRUE)
[16:13:07.847]                         if (has_future) {
[16:13:07.847]                           ns <- base::getNamespace("future")
[16:13:07.847]                           version <- ns[[".package"]][["version"]]
[16:13:07.847]                           if (is.null(version)) 
[16:13:07.847]                             version <- utils::packageVersion("future")
[16:13:07.847]                         }
[16:13:07.847]                         else {
[16:13:07.847]                           version <- NULL
[16:13:07.847]                         }
[16:13:07.847]                         if (!has_future || version < "1.8.0") {
[16:13:07.847]                           info <- base::c(r_version = base::gsub("R version ", 
[16:13:07.847]                             "", base::R.version$version.string), 
[16:13:07.847]                             platform = base::sprintf("%s (%s-bit)", 
[16:13:07.847]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:13:07.847]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:13:07.847]                               "release", "version")], collapse = " "), 
[16:13:07.847]                             hostname = base::Sys.info()[["nodename"]])
[16:13:07.847]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:13:07.847]                             info)
[16:13:07.847]                           info <- base::paste(info, collapse = "; ")
[16:13:07.847]                           if (!has_future) {
[16:13:07.847]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:13:07.847]                               info)
[16:13:07.847]                           }
[16:13:07.847]                           else {
[16:13:07.847]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:13:07.847]                               info, version)
[16:13:07.847]                           }
[16:13:07.847]                           base::stop(msg)
[16:13:07.847]                         }
[16:13:07.847]                       })
[16:13:07.847]                     }
[16:13:07.847]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:13:07.847]                     base::options(mc.cores = 1L)
[16:13:07.847]                   }
[16:13:07.847]                   options(future.plan = NULL)
[16:13:07.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:13:07.847]                 }
[16:13:07.847]                 ...future.workdir <- getwd()
[16:13:07.847]             }
[16:13:07.847]             ...future.oldOptions <- base::as.list(base::.Options)
[16:13:07.847]             ...future.oldEnvVars <- base::Sys.getenv()
[16:13:07.847]         }
[16:13:07.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:13:07.847]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:13:07.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:13:07.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:13:07.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:13:07.847]             future.stdout.windows.reencode = NULL, width = 80L)
[16:13:07.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:13:07.847]             base::names(...future.oldOptions))
[16:13:07.847]     }
[16:13:07.847]     if (FALSE) {
[16:13:07.847]     }
[16:13:07.847]     else {
[16:13:07.847]         if (TRUE) {
[16:13:07.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:13:07.847]                 open = "w")
[16:13:07.847]         }
[16:13:07.847]         else {
[16:13:07.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:13:07.847]                 windows = "NUL", "/dev/null"), open = "w")
[16:13:07.847]         }
[16:13:07.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:13:07.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:13:07.847]             base::sink(type = "output", split = FALSE)
[16:13:07.847]             base::close(...future.stdout)
[16:13:07.847]         }, add = TRUE)
[16:13:07.847]     }
[16:13:07.847]     ...future.frame <- base::sys.nframe()
[16:13:07.847]     ...future.conditions <- base::list()
[16:13:07.847]     ...future.rng <- base::globalenv()$.Random.seed
[16:13:07.847]     if (FALSE) {
[16:13:07.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:13:07.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:13:07.847]     }
[16:13:07.847]     ...future.result <- base::tryCatch({
[16:13:07.847]         base::withCallingHandlers({
[16:13:07.847]             ...future.value <- base::withVisible(base::local({
[16:13:07.847]                 ...future.makeSendCondition <- local({
[16:13:07.847]                   sendCondition <- NULL
[16:13:07.847]                   function(frame = 1L) {
[16:13:07.847]                     if (is.function(sendCondition)) 
[16:13:07.847]                       return(sendCondition)
[16:13:07.847]                     ns <- getNamespace("parallel")
[16:13:07.847]                     if (exists("sendData", mode = "function", 
[16:13:07.847]                       envir = ns)) {
[16:13:07.847]                       parallel_sendData <- get("sendData", mode = "function", 
[16:13:07.847]                         envir = ns)
[16:13:07.847]                       envir <- sys.frame(frame)
[16:13:07.847]                       master <- NULL
[16:13:07.847]                       while (!identical(envir, .GlobalEnv) && 
[16:13:07.847]                         !identical(envir, emptyenv())) {
[16:13:07.847]                         if (exists("master", mode = "list", envir = envir, 
[16:13:07.847]                           inherits = FALSE)) {
[16:13:07.847]                           master <- get("master", mode = "list", 
[16:13:07.847]                             envir = envir, inherits = FALSE)
[16:13:07.847]                           if (inherits(master, c("SOCKnode", 
[16:13:07.847]                             "SOCK0node"))) {
[16:13:07.847]                             sendCondition <<- function(cond) {
[16:13:07.847]                               data <- list(type = "VALUE", value = cond, 
[16:13:07.847]                                 success = TRUE)
[16:13:07.847]                               parallel_sendData(master, data)
[16:13:07.847]                             }
[16:13:07.847]                             return(sendCondition)
[16:13:07.847]                           }
[16:13:07.847]                         }
[16:13:07.847]                         frame <- frame + 1L
[16:13:07.847]                         envir <- sys.frame(frame)
[16:13:07.847]                       }
[16:13:07.847]                     }
[16:13:07.847]                     sendCondition <<- function(cond) NULL
[16:13:07.847]                   }
[16:13:07.847]                 })
[16:13:07.847]                 withCallingHandlers({
[16:13:07.847]                   1L
[16:13:07.847]                 }, immediateCondition = function(cond) {
[16:13:07.847]                   sendCondition <- ...future.makeSendCondition()
[16:13:07.847]                   sendCondition(cond)
[16:13:07.847]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.847]                   {
[16:13:07.847]                     inherits <- base::inherits
[16:13:07.847]                     invokeRestart <- base::invokeRestart
[16:13:07.847]                     is.null <- base::is.null
[16:13:07.847]                     muffled <- FALSE
[16:13:07.847]                     if (inherits(cond, "message")) {
[16:13:07.847]                       muffled <- grepl(pattern, "muffleMessage")
[16:13:07.847]                       if (muffled) 
[16:13:07.847]                         invokeRestart("muffleMessage")
[16:13:07.847]                     }
[16:13:07.847]                     else if (inherits(cond, "warning")) {
[16:13:07.847]                       muffled <- grepl(pattern, "muffleWarning")
[16:13:07.847]                       if (muffled) 
[16:13:07.847]                         invokeRestart("muffleWarning")
[16:13:07.847]                     }
[16:13:07.847]                     else if (inherits(cond, "condition")) {
[16:13:07.847]                       if (!is.null(pattern)) {
[16:13:07.847]                         computeRestarts <- base::computeRestarts
[16:13:07.847]                         grepl <- base::grepl
[16:13:07.847]                         restarts <- computeRestarts(cond)
[16:13:07.847]                         for (restart in restarts) {
[16:13:07.847]                           name <- restart$name
[16:13:07.847]                           if (is.null(name)) 
[16:13:07.847]                             next
[16:13:07.847]                           if (!grepl(pattern, name)) 
[16:13:07.847]                             next
[16:13:07.847]                           invokeRestart(restart)
[16:13:07.847]                           muffled <- TRUE
[16:13:07.847]                           break
[16:13:07.847]                         }
[16:13:07.847]                       }
[16:13:07.847]                     }
[16:13:07.847]                     invisible(muffled)
[16:13:07.847]                   }
[16:13:07.847]                   muffleCondition(cond)
[16:13:07.847]                 })
[16:13:07.847]             }))
[16:13:07.847]             future::FutureResult(value = ...future.value$value, 
[16:13:07.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.847]                   ...future.rng), globalenv = if (FALSE) 
[16:13:07.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:13:07.847]                     ...future.globalenv.names))
[16:13:07.847]                 else NULL, started = ...future.startTime, version = "1.8")
[16:13:07.847]         }, condition = base::local({
[16:13:07.847]             c <- base::c
[16:13:07.847]             inherits <- base::inherits
[16:13:07.847]             invokeRestart <- base::invokeRestart
[16:13:07.847]             length <- base::length
[16:13:07.847]             list <- base::list
[16:13:07.847]             seq.int <- base::seq.int
[16:13:07.847]             signalCondition <- base::signalCondition
[16:13:07.847]             sys.calls <- base::sys.calls
[16:13:07.847]             `[[` <- base::`[[`
[16:13:07.847]             `+` <- base::`+`
[16:13:07.847]             `<<-` <- base::`<<-`
[16:13:07.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:13:07.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:13:07.847]                   3L)]
[16:13:07.847]             }
[16:13:07.847]             function(cond) {
[16:13:07.847]                 is_error <- inherits(cond, "error")
[16:13:07.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:13:07.847]                   NULL)
[16:13:07.847]                 if (is_error) {
[16:13:07.847]                   sessionInformation <- function() {
[16:13:07.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:13:07.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:13:07.847]                       search = base::search(), system = base::Sys.info())
[16:13:07.847]                   }
[16:13:07.847]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:13:07.847]                     cond$call), session = sessionInformation(), 
[16:13:07.847]                     timestamp = base::Sys.time(), signaled = 0L)
[16:13:07.847]                   signalCondition(cond)
[16:13:07.847]                 }
[16:13:07.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:13:07.847]                 "immediateCondition"))) {
[16:13:07.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:13:07.847]                   ...future.conditions[[length(...future.conditions) + 
[16:13:07.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:13:07.847]                   if (TRUE && !signal) {
[16:13:07.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.847]                     {
[16:13:07.847]                       inherits <- base::inherits
[16:13:07.847]                       invokeRestart <- base::invokeRestart
[16:13:07.847]                       is.null <- base::is.null
[16:13:07.847]                       muffled <- FALSE
[16:13:07.847]                       if (inherits(cond, "message")) {
[16:13:07.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.847]                         if (muffled) 
[16:13:07.847]                           invokeRestart("muffleMessage")
[16:13:07.847]                       }
[16:13:07.847]                       else if (inherits(cond, "warning")) {
[16:13:07.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.847]                         if (muffled) 
[16:13:07.847]                           invokeRestart("muffleWarning")
[16:13:07.847]                       }
[16:13:07.847]                       else if (inherits(cond, "condition")) {
[16:13:07.847]                         if (!is.null(pattern)) {
[16:13:07.847]                           computeRestarts <- base::computeRestarts
[16:13:07.847]                           grepl <- base::grepl
[16:13:07.847]                           restarts <- computeRestarts(cond)
[16:13:07.847]                           for (restart in restarts) {
[16:13:07.847]                             name <- restart$name
[16:13:07.847]                             if (is.null(name)) 
[16:13:07.847]                               next
[16:13:07.847]                             if (!grepl(pattern, name)) 
[16:13:07.847]                               next
[16:13:07.847]                             invokeRestart(restart)
[16:13:07.847]                             muffled <- TRUE
[16:13:07.847]                             break
[16:13:07.847]                           }
[16:13:07.847]                         }
[16:13:07.847]                       }
[16:13:07.847]                       invisible(muffled)
[16:13:07.847]                     }
[16:13:07.847]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.847]                   }
[16:13:07.847]                 }
[16:13:07.847]                 else {
[16:13:07.847]                   if (TRUE) {
[16:13:07.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:13:07.847]                     {
[16:13:07.847]                       inherits <- base::inherits
[16:13:07.847]                       invokeRestart <- base::invokeRestart
[16:13:07.847]                       is.null <- base::is.null
[16:13:07.847]                       muffled <- FALSE
[16:13:07.847]                       if (inherits(cond, "message")) {
[16:13:07.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:13:07.847]                         if (muffled) 
[16:13:07.847]                           invokeRestart("muffleMessage")
[16:13:07.847]                       }
[16:13:07.847]                       else if (inherits(cond, "warning")) {
[16:13:07.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:13:07.847]                         if (muffled) 
[16:13:07.847]                           invokeRestart("muffleWarning")
[16:13:07.847]                       }
[16:13:07.847]                       else if (inherits(cond, "condition")) {
[16:13:07.847]                         if (!is.null(pattern)) {
[16:13:07.847]                           computeRestarts <- base::computeRestarts
[16:13:07.847]                           grepl <- base::grepl
[16:13:07.847]                           restarts <- computeRestarts(cond)
[16:13:07.847]                           for (restart in restarts) {
[16:13:07.847]                             name <- restart$name
[16:13:07.847]                             if (is.null(name)) 
[16:13:07.847]                               next
[16:13:07.847]                             if (!grepl(pattern, name)) 
[16:13:07.847]                               next
[16:13:07.847]                             invokeRestart(restart)
[16:13:07.847]                             muffled <- TRUE
[16:13:07.847]                             break
[16:13:07.847]                           }
[16:13:07.847]                         }
[16:13:07.847]                       }
[16:13:07.847]                       invisible(muffled)
[16:13:07.847]                     }
[16:13:07.847]                     muffleCondition(cond, pattern = "^muffle")
[16:13:07.847]                   }
[16:13:07.847]                 }
[16:13:07.847]             }
[16:13:07.847]         }))
[16:13:07.847]     }, error = function(ex) {
[16:13:07.847]         base::structure(base::list(value = NULL, visible = NULL, 
[16:13:07.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:13:07.847]                 ...future.rng), started = ...future.startTime, 
[16:13:07.847]             finished = Sys.time(), session_uuid = NA_character_, 
[16:13:07.847]             version = "1.8"), class = "FutureResult")
[16:13:07.847]     }, finally = {
[16:13:07.847]         if (!identical(...future.workdir, getwd())) 
[16:13:07.847]             setwd(...future.workdir)
[16:13:07.847]         {
[16:13:07.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:13:07.847]                 ...future.oldOptions$nwarnings <- NULL
[16:13:07.847]             }
[16:13:07.847]             base::options(...future.oldOptions)
[16:13:07.847]             if (.Platform$OS.type == "windows") {
[16:13:07.847]                 old_names <- names(...future.oldEnvVars)
[16:13:07.847]                 envs <- base::Sys.getenv()
[16:13:07.847]                 names <- names(envs)
[16:13:07.847]                 common <- intersect(names, old_names)
[16:13:07.847]                 added <- setdiff(names, old_names)
[16:13:07.847]                 removed <- setdiff(old_names, names)
[16:13:07.847]                 changed <- common[...future.oldEnvVars[common] != 
[16:13:07.847]                   envs[common]]
[16:13:07.847]                 NAMES <- toupper(changed)
[16:13:07.847]                 args <- list()
[16:13:07.847]                 for (kk in seq_along(NAMES)) {
[16:13:07.847]                   name <- changed[[kk]]
[16:13:07.847]                   NAME <- NAMES[[kk]]
[16:13:07.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.847]                     next
[16:13:07.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.847]                 }
[16:13:07.847]                 NAMES <- toupper(added)
[16:13:07.847]                 for (kk in seq_along(NAMES)) {
[16:13:07.847]                   name <- added[[kk]]
[16:13:07.847]                   NAME <- NAMES[[kk]]
[16:13:07.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.847]                     next
[16:13:07.847]                   args[[name]] <- ""
[16:13:07.847]                 }
[16:13:07.847]                 NAMES <- toupper(removed)
[16:13:07.847]                 for (kk in seq_along(NAMES)) {
[16:13:07.847]                   name <- removed[[kk]]
[16:13:07.847]                   NAME <- NAMES[[kk]]
[16:13:07.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:13:07.847]                     next
[16:13:07.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:13:07.847]                 }
[16:13:07.847]                 if (length(args) > 0) 
[16:13:07.847]                   base::do.call(base::Sys.setenv, args = args)
[16:13:07.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:13:07.847]             }
[16:13:07.847]             else {
[16:13:07.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:13:07.847]             }
[16:13:07.847]             {
[16:13:07.847]                 if (base::length(...future.futureOptionsAdded) > 
[16:13:07.847]                   0L) {
[16:13:07.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:13:07.847]                   base::names(opts) <- ...future.futureOptionsAdded
[16:13:07.847]                   base::options(opts)
[16:13:07.847]                 }
[16:13:07.847]                 {
[16:13:07.847]                   {
[16:13:07.847]                     base::options(mc.cores = ...future.mc.cores.old)
[16:13:07.847]                     NULL
[16:13:07.847]                   }
[16:13:07.847]                   options(future.plan = NULL)
[16:13:07.847]                   if (is.na(NA_character_)) 
[16:13:07.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:13:07.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:13:07.847]                   future::plan(list(function (..., workers = 2L, 
[16:13:07.847]                     envir = parent.frame()) 
[16:13:07.847]                   strategy(..., workers = workers, envir = envir)), 
[16:13:07.847]                     .cleanup = FALSE, .init = FALSE)
[16:13:07.847]                 }
[16:13:07.847]             }
[16:13:07.847]         }
[16:13:07.847]     })
[16:13:07.847]     if (TRUE) {
[16:13:07.847]         base::sink(type = "output", split = FALSE)
[16:13:07.847]         if (TRUE) {
[16:13:07.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:13:07.847]         }
[16:13:07.847]         else {
[16:13:07.847]             ...future.result["stdout"] <- base::list(NULL)
[16:13:07.847]         }
[16:13:07.847]         base::close(...future.stdout)
[16:13:07.847]         ...future.stdout <- NULL
[16:13:07.847]     }
[16:13:07.847]     ...future.result$conditions <- ...future.conditions
[16:13:07.847]     ...future.result$finished <- base::Sys.time()
[16:13:07.847]     ...future.result
[16:13:07.847] }
[16:13:07.850] MultisessionFuture started
[16:13:07.850] - Launch lazy future ... done
[16:13:07.850] run() for ‘MultisessionFuture’ ... done
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[16:13:07.850] plan(): Setting new future strategy stack:
[16:13:07.851] List of future strategies:
[16:13:07.851] 1. sequential:
[16:13:07.851]    - args: function (..., envir = parent.frame())
[16:13:07.851]    - tweaked: FALSE
[16:13:07.851]    - call: plan(sequential)
[16:13:07.851] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[16:13:07.852] plan(): Setting new future strategy stack:
[16:13:07.853] List of future strategies:
[16:13:07.853] 1. FutureStrategy:
[16:13:07.853]    - args: function (..., envir = parent.frame())
[16:13:07.853]    - tweaked: FALSE
[16:13:07.853]    - call: future::plan(oplan)
[16:13:07.853] plan(): nbrOfWorkers() = 1
> 
