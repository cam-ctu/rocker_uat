
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:09:35.727] plan(): Setting new future strategy stack:
[16:09:35.727] List of future strategies:
[16:09:35.727] 1. sequential:
[16:09:35.727]    - args: function (..., envir = parent.frame())
[16:09:35.727]    - tweaked: FALSE
[16:09:35.727]    - call: future::plan("sequential")
[16:09:35.737] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:09:35.761] plan(): Setting new future strategy stack:
[16:09:35.761] List of future strategies:
[16:09:35.761] 1. sequential:
[16:09:35.761]    - args: function (..., envir = parent.frame())
[16:09:35.761]    - tweaked: FALSE
[16:09:35.761]    - call: plan(strategy)
[16:09:35.772] plan(): nbrOfWorkers() = 1
[16:09:35.773] future_lapply() ...
[16:09:35.777] Number of chunks: 1
[16:09:35.778] getGlobalsAndPackagesXApply() ...
[16:09:35.778]  - future.globals: TRUE
[16:09:35.778] getGlobalsAndPackages() ...
[16:09:35.779] Searching for globals...
[16:09:35.781] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.781] Searching for globals ... DONE
[16:09:35.781] Resolving globals: FALSE
[16:09:35.782] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:35.783] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:35.783] - globals: [1] ‘FUN’
[16:09:35.783] 
[16:09:35.783] getGlobalsAndPackages() ... DONE
[16:09:35.783]  - globals found/used: [n=1] ‘FUN’
[16:09:35.783]  - needed namespaces: [n=0] 
[16:09:35.783] Finding globals ... DONE
[16:09:35.783]  - use_args: TRUE
[16:09:35.783]  - Getting '...' globals ...
[16:09:35.784] resolve() on list ...
[16:09:35.784]  recursive: 0
[16:09:35.785]  length: 1
[16:09:35.785]  elements: ‘...’
[16:09:35.785]  length: 0 (resolved future 1)
[16:09:35.785] resolve() on list ... DONE
[16:09:35.785]    - '...' content: [n=0] 
[16:09:35.785] List of 1
[16:09:35.785]  $ ...: list()
[16:09:35.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.785]  - attr(*, "where")=List of 1
[16:09:35.785]   ..$ ...:<environment: 0x55b4b802bfe8> 
[16:09:35.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.785]  - attr(*, "resolved")= logi TRUE
[16:09:35.785]  - attr(*, "total_size")= num NA
[16:09:35.790]  - Getting '...' globals ... DONE
[16:09:35.790] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.791] List of 2
[16:09:35.791]  $ ...future.FUN:function (x, ...)  
[16:09:35.791]  $ ...          : list()
[16:09:35.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.791]  - attr(*, "where")=List of 2
[16:09:35.791]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.791]   ..$ ...          :<environment: 0x55b4b802bfe8> 
[16:09:35.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.791]  - attr(*, "resolved")= logi FALSE
[16:09:35.791]  - attr(*, "total_size")= num 1240
[16:09:35.795] Packages to be attached in all futures: [n=0] 
[16:09:35.796] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.796] Number of futures (= number of chunks): 1
[16:09:35.796] Launching 1 futures (chunks) ...
[16:09:35.796] Chunk #1 of 1 ...
[16:09:35.796]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.797] getGlobalsAndPackages() ...
[16:09:35.797] Searching for globals...
[16:09:35.797] 
[16:09:35.797] Searching for globals ... DONE
[16:09:35.797] - globals: [0] <none>
[16:09:35.797] getGlobalsAndPackages() ... DONE
[16:09:35.797]    + additional globals found: [n=0] 
[16:09:35.797]    + additional namespaces needed: [n=0] 
[16:09:35.798]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.798]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:35.798]  - seeds: <none>
[16:09:35.798] getGlobalsAndPackages() ...
[16:09:35.798] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.798] Resolving globals: FALSE
[16:09:35.798] Tweak future expression to call with '...' arguments ...
[16:09:35.799] {
[16:09:35.799]     do.call(function(...) {
[16:09:35.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.799]             on.exit(options(oopts), add = TRUE)
[16:09:35.799]         }
[16:09:35.799]         {
[16:09:35.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.799]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.799]             })
[16:09:35.799]         }
[16:09:35.799]     }, args = future.call.arguments)
[16:09:35.799] }
[16:09:35.799] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.799] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.799] 
[16:09:35.799] getGlobalsAndPackages() ... DONE
[16:09:35.800] run() for ‘Future’ ...
[16:09:35.800] - state: ‘created’
[16:09:35.801] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:35.801] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.801] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:35.801]   - Field: ‘label’
[16:09:35.801]   - Field: ‘local’
[16:09:35.801]   - Field: ‘owner’
[16:09:35.801]   - Field: ‘envir’
[16:09:35.802]   - Field: ‘packages’
[16:09:35.802]   - Field: ‘gc’
[16:09:35.802]   - Field: ‘conditions’
[16:09:35.802]   - Field: ‘expr’
[16:09:35.802]   - Field: ‘uuid’
[16:09:35.802]   - Field: ‘seed’
[16:09:35.802]   - Field: ‘version’
[16:09:35.802]   - Field: ‘result’
[16:09:35.802]   - Field: ‘asynchronous’
[16:09:35.802]   - Field: ‘calls’
[16:09:35.802]   - Field: ‘globals’
[16:09:35.803]   - Field: ‘stdout’
[16:09:35.803]   - Field: ‘earlySignal’
[16:09:35.803]   - Field: ‘lazy’
[16:09:35.803]   - Field: ‘state’
[16:09:35.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:35.803] - Launch lazy future ...
[16:09:35.804] Packages needed by the future expression (n = 0): <none>
[16:09:35.804] Packages needed by future strategies (n = 0): <none>
[16:09:35.805] {
[16:09:35.805]     {
[16:09:35.805]         {
[16:09:35.805]             ...future.startTime <- base::Sys.time()
[16:09:35.805]             {
[16:09:35.805]                 {
[16:09:35.805]                   {
[16:09:35.805]                     base::local({
[16:09:35.805]                       has_future <- base::requireNamespace("future", 
[16:09:35.805]                         quietly = TRUE)
[16:09:35.805]                       if (has_future) {
[16:09:35.805]                         ns <- base::getNamespace("future")
[16:09:35.805]                         version <- ns[[".package"]][["version"]]
[16:09:35.805]                         if (is.null(version)) 
[16:09:35.805]                           version <- utils::packageVersion("future")
[16:09:35.805]                       }
[16:09:35.805]                       else {
[16:09:35.805]                         version <- NULL
[16:09:35.805]                       }
[16:09:35.805]                       if (!has_future || version < "1.8.0") {
[16:09:35.805]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.805]                           "", base::R.version$version.string), 
[16:09:35.805]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:35.805]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.805]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.805]                             "release", "version")], collapse = " "), 
[16:09:35.805]                           hostname = base::Sys.info()[["nodename"]])
[16:09:35.805]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.805]                           info)
[16:09:35.805]                         info <- base::paste(info, collapse = "; ")
[16:09:35.805]                         if (!has_future) {
[16:09:35.805]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.805]                             info)
[16:09:35.805]                         }
[16:09:35.805]                         else {
[16:09:35.805]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.805]                             info, version)
[16:09:35.805]                         }
[16:09:35.805]                         base::stop(msg)
[16:09:35.805]                       }
[16:09:35.805]                     })
[16:09:35.805]                   }
[16:09:35.805]                   options(future.plan = NULL)
[16:09:35.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.805]                 }
[16:09:35.805]                 ...future.workdir <- getwd()
[16:09:35.805]             }
[16:09:35.805]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.805]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.805]         }
[16:09:35.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.805]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:35.805]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.805]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.805]             base::names(...future.oldOptions))
[16:09:35.805]     }
[16:09:35.805]     if (FALSE) {
[16:09:35.805]     }
[16:09:35.805]     else {
[16:09:35.805]         if (TRUE) {
[16:09:35.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.805]                 open = "w")
[16:09:35.805]         }
[16:09:35.805]         else {
[16:09:35.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.805]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.805]         }
[16:09:35.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.805]             base::sink(type = "output", split = FALSE)
[16:09:35.805]             base::close(...future.stdout)
[16:09:35.805]         }, add = TRUE)
[16:09:35.805]     }
[16:09:35.805]     ...future.frame <- base::sys.nframe()
[16:09:35.805]     ...future.conditions <- base::list()
[16:09:35.805]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.805]     if (FALSE) {
[16:09:35.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.805]     }
[16:09:35.805]     ...future.result <- base::tryCatch({
[16:09:35.805]         base::withCallingHandlers({
[16:09:35.805]             ...future.value <- base::withVisible(base::local({
[16:09:35.805]                 do.call(function(...) {
[16:09:35.805]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.805]                   if (!identical(...future.globals.maxSize.org, 
[16:09:35.805]                     ...future.globals.maxSize)) {
[16:09:35.805]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.805]                     on.exit(options(oopts), add = TRUE)
[16:09:35.805]                   }
[16:09:35.805]                   {
[16:09:35.805]                     lapply(seq_along(...future.elements_ii), 
[16:09:35.805]                       FUN = function(jj) {
[16:09:35.805]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.805]                         ...future.FUN(...future.X_jj, ...)
[16:09:35.805]                       })
[16:09:35.805]                   }
[16:09:35.805]                 }, args = future.call.arguments)
[16:09:35.805]             }))
[16:09:35.805]             future::FutureResult(value = ...future.value$value, 
[16:09:35.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.805]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.805]                     ...future.globalenv.names))
[16:09:35.805]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.805]         }, condition = base::local({
[16:09:35.805]             c <- base::c
[16:09:35.805]             inherits <- base::inherits
[16:09:35.805]             invokeRestart <- base::invokeRestart
[16:09:35.805]             length <- base::length
[16:09:35.805]             list <- base::list
[16:09:35.805]             seq.int <- base::seq.int
[16:09:35.805]             signalCondition <- base::signalCondition
[16:09:35.805]             sys.calls <- base::sys.calls
[16:09:35.805]             `[[` <- base::`[[`
[16:09:35.805]             `+` <- base::`+`
[16:09:35.805]             `<<-` <- base::`<<-`
[16:09:35.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.805]                   3L)]
[16:09:35.805]             }
[16:09:35.805]             function(cond) {
[16:09:35.805]                 is_error <- inherits(cond, "error")
[16:09:35.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.805]                   NULL)
[16:09:35.805]                 if (is_error) {
[16:09:35.805]                   sessionInformation <- function() {
[16:09:35.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.805]                       search = base::search(), system = base::Sys.info())
[16:09:35.805]                   }
[16:09:35.805]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.805]                     cond$call), session = sessionInformation(), 
[16:09:35.805]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.805]                   signalCondition(cond)
[16:09:35.805]                 }
[16:09:35.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.805]                 "immediateCondition"))) {
[16:09:35.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.805]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.805]                   if (TRUE && !signal) {
[16:09:35.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.805]                     {
[16:09:35.805]                       inherits <- base::inherits
[16:09:35.805]                       invokeRestart <- base::invokeRestart
[16:09:35.805]                       is.null <- base::is.null
[16:09:35.805]                       muffled <- FALSE
[16:09:35.805]                       if (inherits(cond, "message")) {
[16:09:35.805]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.805]                         if (muffled) 
[16:09:35.805]                           invokeRestart("muffleMessage")
[16:09:35.805]                       }
[16:09:35.805]                       else if (inherits(cond, "warning")) {
[16:09:35.805]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.805]                         if (muffled) 
[16:09:35.805]                           invokeRestart("muffleWarning")
[16:09:35.805]                       }
[16:09:35.805]                       else if (inherits(cond, "condition")) {
[16:09:35.805]                         if (!is.null(pattern)) {
[16:09:35.805]                           computeRestarts <- base::computeRestarts
[16:09:35.805]                           grepl <- base::grepl
[16:09:35.805]                           restarts <- computeRestarts(cond)
[16:09:35.805]                           for (restart in restarts) {
[16:09:35.805]                             name <- restart$name
[16:09:35.805]                             if (is.null(name)) 
[16:09:35.805]                               next
[16:09:35.805]                             if (!grepl(pattern, name)) 
[16:09:35.805]                               next
[16:09:35.805]                             invokeRestart(restart)
[16:09:35.805]                             muffled <- TRUE
[16:09:35.805]                             break
[16:09:35.805]                           }
[16:09:35.805]                         }
[16:09:35.805]                       }
[16:09:35.805]                       invisible(muffled)
[16:09:35.805]                     }
[16:09:35.805]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.805]                   }
[16:09:35.805]                 }
[16:09:35.805]                 else {
[16:09:35.805]                   if (TRUE) {
[16:09:35.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.805]                     {
[16:09:35.805]                       inherits <- base::inherits
[16:09:35.805]                       invokeRestart <- base::invokeRestart
[16:09:35.805]                       is.null <- base::is.null
[16:09:35.805]                       muffled <- FALSE
[16:09:35.805]                       if (inherits(cond, "message")) {
[16:09:35.805]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.805]                         if (muffled) 
[16:09:35.805]                           invokeRestart("muffleMessage")
[16:09:35.805]                       }
[16:09:35.805]                       else if (inherits(cond, "warning")) {
[16:09:35.805]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.805]                         if (muffled) 
[16:09:35.805]                           invokeRestart("muffleWarning")
[16:09:35.805]                       }
[16:09:35.805]                       else if (inherits(cond, "condition")) {
[16:09:35.805]                         if (!is.null(pattern)) {
[16:09:35.805]                           computeRestarts <- base::computeRestarts
[16:09:35.805]                           grepl <- base::grepl
[16:09:35.805]                           restarts <- computeRestarts(cond)
[16:09:35.805]                           for (restart in restarts) {
[16:09:35.805]                             name <- restart$name
[16:09:35.805]                             if (is.null(name)) 
[16:09:35.805]                               next
[16:09:35.805]                             if (!grepl(pattern, name)) 
[16:09:35.805]                               next
[16:09:35.805]                             invokeRestart(restart)
[16:09:35.805]                             muffled <- TRUE
[16:09:35.805]                             break
[16:09:35.805]                           }
[16:09:35.805]                         }
[16:09:35.805]                       }
[16:09:35.805]                       invisible(muffled)
[16:09:35.805]                     }
[16:09:35.805]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.805]                   }
[16:09:35.805]                 }
[16:09:35.805]             }
[16:09:35.805]         }))
[16:09:35.805]     }, error = function(ex) {
[16:09:35.805]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.805]                 ...future.rng), started = ...future.startTime, 
[16:09:35.805]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.805]             version = "1.8"), class = "FutureResult")
[16:09:35.805]     }, finally = {
[16:09:35.805]         if (!identical(...future.workdir, getwd())) 
[16:09:35.805]             setwd(...future.workdir)
[16:09:35.805]         {
[16:09:35.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.805]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.805]             }
[16:09:35.805]             base::options(...future.oldOptions)
[16:09:35.805]             if (.Platform$OS.type == "windows") {
[16:09:35.805]                 old_names <- names(...future.oldEnvVars)
[16:09:35.805]                 envs <- base::Sys.getenv()
[16:09:35.805]                 names <- names(envs)
[16:09:35.805]                 common <- intersect(names, old_names)
[16:09:35.805]                 added <- setdiff(names, old_names)
[16:09:35.805]                 removed <- setdiff(old_names, names)
[16:09:35.805]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.805]                   envs[common]]
[16:09:35.805]                 NAMES <- toupper(changed)
[16:09:35.805]                 args <- list()
[16:09:35.805]                 for (kk in seq_along(NAMES)) {
[16:09:35.805]                   name <- changed[[kk]]
[16:09:35.805]                   NAME <- NAMES[[kk]]
[16:09:35.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.805]                     next
[16:09:35.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.805]                 }
[16:09:35.805]                 NAMES <- toupper(added)
[16:09:35.805]                 for (kk in seq_along(NAMES)) {
[16:09:35.805]                   name <- added[[kk]]
[16:09:35.805]                   NAME <- NAMES[[kk]]
[16:09:35.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.805]                     next
[16:09:35.805]                   args[[name]] <- ""
[16:09:35.805]                 }
[16:09:35.805]                 NAMES <- toupper(removed)
[16:09:35.805]                 for (kk in seq_along(NAMES)) {
[16:09:35.805]                   name <- removed[[kk]]
[16:09:35.805]                   NAME <- NAMES[[kk]]
[16:09:35.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.805]                     next
[16:09:35.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.805]                 }
[16:09:35.805]                 if (length(args) > 0) 
[16:09:35.805]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.805]             }
[16:09:35.805]             else {
[16:09:35.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.805]             }
[16:09:35.805]             {
[16:09:35.805]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.805]                   0L) {
[16:09:35.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.805]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.805]                   base::options(opts)
[16:09:35.805]                 }
[16:09:35.805]                 {
[16:09:35.805]                   {
[16:09:35.805]                     NULL
[16:09:35.805]                     RNGkind("Mersenne-Twister")
[16:09:35.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:35.805]                       inherits = FALSE)
[16:09:35.805]                   }
[16:09:35.805]                   options(future.plan = NULL)
[16:09:35.805]                   if (is.na(NA_character_)) 
[16:09:35.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.805]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:35.805]                   {
[16:09:35.805]                     future <- SequentialFuture(..., envir = envir)
[16:09:35.805]                     if (!future$lazy) 
[16:09:35.805]                       future <- run(future)
[16:09:35.805]                     invisible(future)
[16:09:35.805]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.805]                 }
[16:09:35.805]             }
[16:09:35.805]         }
[16:09:35.805]     })
[16:09:35.805]     if (TRUE) {
[16:09:35.805]         base::sink(type = "output", split = FALSE)
[16:09:35.805]         if (TRUE) {
[16:09:35.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.805]         }
[16:09:35.805]         else {
[16:09:35.805]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.805]         }
[16:09:35.805]         base::close(...future.stdout)
[16:09:35.805]         ...future.stdout <- NULL
[16:09:35.805]     }
[16:09:35.805]     ...future.result$conditions <- ...future.conditions
[16:09:35.805]     ...future.result$finished <- base::Sys.time()
[16:09:35.805]     ...future.result
[16:09:35.805] }
[16:09:35.807] assign_globals() ...
[16:09:35.807] List of 5
[16:09:35.807]  $ ...future.FUN            :function (x, ...)  
[16:09:35.807]  $ future.call.arguments    : list()
[16:09:35.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.807]  $ ...future.elements_ii    :List of 3
[16:09:35.807]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:09:35.807]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:35.807]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:35.807]  $ ...future.seeds_ii       : NULL
[16:09:35.807]  $ ...future.globals.maxSize: NULL
[16:09:35.807]  - attr(*, "resolved")= logi FALSE
[16:09:35.807]  - attr(*, "total_size")= num 1240
[16:09:35.807]  - attr(*, "where")=List of 5
[16:09:35.807]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:35.807]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:35.807]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:35.807]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:35.807]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:35.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.807]  - attr(*, "already-done")= logi TRUE
[16:09:35.813] - copied ‘...future.FUN’ to environment
[16:09:35.813] - copied ‘future.call.arguments’ to environment
[16:09:35.813] - copied ‘...future.elements_ii’ to environment
[16:09:35.813] - copied ‘...future.seeds_ii’ to environment
[16:09:35.813] - copied ‘...future.globals.maxSize’ to environment
[16:09:35.813] assign_globals() ... done
[16:09:35.814] plan(): Setting new future strategy stack:
[16:09:35.814] List of future strategies:
[16:09:35.814] 1. sequential:
[16:09:35.814]    - args: function (..., envir = parent.frame())
[16:09:35.814]    - tweaked: FALSE
[16:09:35.814]    - call: NULL
[16:09:35.814] plan(): nbrOfWorkers() = 1
[16:09:35.816] plan(): Setting new future strategy stack:
[16:09:35.816] List of future strategies:
[16:09:35.816] 1. sequential:
[16:09:35.816]    - args: function (..., envir = parent.frame())
[16:09:35.816]    - tweaked: FALSE
[16:09:35.816]    - call: plan(strategy)
[16:09:35.816] plan(): nbrOfWorkers() = 1
[16:09:35.816] SequentialFuture started (and completed)
[16:09:35.817] - Launch lazy future ... done
[16:09:35.817] run() for ‘SequentialFuture’ ... done
[16:09:35.817] Created future:
[16:09:35.817] SequentialFuture:
[16:09:35.817] Label: ‘future_eapply-1’
[16:09:35.817] Expression:
[16:09:35.817] {
[16:09:35.817]     do.call(function(...) {
[16:09:35.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.817]             on.exit(options(oopts), add = TRUE)
[16:09:35.817]         }
[16:09:35.817]         {
[16:09:35.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.817]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.817]             })
[16:09:35.817]         }
[16:09:35.817]     }, args = future.call.arguments)
[16:09:35.817] }
[16:09:35.817] Lazy evaluation: FALSE
[16:09:35.817] Asynchronous evaluation: FALSE
[16:09:35.817] Local evaluation: TRUE
[16:09:35.817] Environment: R_GlobalEnv
[16:09:35.817] Capture standard output: TRUE
[16:09:35.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.817] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.817] Packages: <none>
[16:09:35.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.817] Resolved: TRUE
[16:09:35.817] Value: 168 bytes of class ‘list’
[16:09:35.817] Early signaling: FALSE
[16:09:35.817] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:35.817] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.819] Chunk #1 of 1 ... DONE
[16:09:35.819] Launching 1 futures (chunks) ... DONE
[16:09:35.819] Resolving 1 futures (chunks) ...
[16:09:35.819] resolve() on list ...
[16:09:35.819]  recursive: 0
[16:09:35.819]  length: 1
[16:09:35.819] 
[16:09:35.820] resolved() for ‘SequentialFuture’ ...
[16:09:35.820] - state: ‘finished’
[16:09:35.820] - run: TRUE
[16:09:35.820] - result: ‘FutureResult’
[16:09:35.820] resolved() for ‘SequentialFuture’ ... done
[16:09:35.820] Future #1
[16:09:35.820] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:35.821] - nx: 1
[16:09:35.821] - relay: TRUE
[16:09:35.821] - stdout: TRUE
[16:09:35.821] - signal: TRUE
[16:09:35.821] - resignal: FALSE
[16:09:35.821] - force: TRUE
[16:09:35.821] - relayed: [n=1] FALSE
[16:09:35.821] - queued futures: [n=1] FALSE
[16:09:35.821]  - until=1
[16:09:35.821]  - relaying element #1
[16:09:35.822] - relayed: [n=1] TRUE
[16:09:35.822] - queued futures: [n=1] TRUE
[16:09:35.822] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:35.822]  length: 0 (resolved future 1)
[16:09:35.822] Relaying remaining futures
[16:09:35.822] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.822] - nx: 1
[16:09:35.822] - relay: TRUE
[16:09:35.822] - stdout: TRUE
[16:09:35.822] - signal: TRUE
[16:09:35.823] - resignal: FALSE
[16:09:35.823] - force: TRUE
[16:09:35.823] - relayed: [n=1] TRUE
[16:09:35.823] - queued futures: [n=1] TRUE
 - flush all
[16:09:35.823] - relayed: [n=1] TRUE
[16:09:35.823] - queued futures: [n=1] TRUE
[16:09:35.823] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.823] resolve() on list ... DONE
[16:09:35.823]  - Number of value chunks collected: 1
[16:09:35.823] Resolving 1 futures (chunks) ... DONE
[16:09:35.823] Reducing values from 1 chunks ...
[16:09:35.824]  - Number of values collected after concatenation: 3
[16:09:35.824]  - Number of values expected: 3
[16:09:35.824] Reducing values from 1 chunks ... DONE
[16:09:35.824] future_lapply() ... DONE
[16:09:35.828] future_lapply() ...
[16:09:35.829] Number of chunks: 1
[16:09:35.829] getGlobalsAndPackagesXApply() ...
[16:09:35.829]  - future.globals: TRUE
[16:09:35.829] getGlobalsAndPackages() ...
[16:09:35.829] Searching for globals...
[16:09:35.831] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.831] Searching for globals ... DONE
[16:09:35.831] Resolving globals: FALSE
[16:09:35.831] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:35.832] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:35.832] - globals: [1] ‘FUN’
[16:09:35.832] - packages: [1] ‘stats’
[16:09:35.832] getGlobalsAndPackages() ... DONE
[16:09:35.832]  - globals found/used: [n=1] ‘FUN’
[16:09:35.832]  - needed namespaces: [n=1] ‘stats’
[16:09:35.832] Finding globals ... DONE
[16:09:35.832]  - use_args: TRUE
[16:09:35.832]  - Getting '...' globals ...
[16:09:35.833] resolve() on list ...
[16:09:35.833]  recursive: 0
[16:09:35.833]  length: 1
[16:09:35.833]  elements: ‘...’
[16:09:35.833]  length: 0 (resolved future 1)
[16:09:35.833] resolve() on list ... DONE
[16:09:35.833]    - '...' content: [n=1] ‘probs’
[16:09:35.833] List of 1
[16:09:35.833]  $ ...:List of 1
[16:09:35.833]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:35.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.833]  - attr(*, "where")=List of 1
[16:09:35.833]   ..$ ...:<environment: 0x55b4b776a4f0> 
[16:09:35.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.833]  - attr(*, "resolved")= logi TRUE
[16:09:35.833]  - attr(*, "total_size")= num NA
[16:09:35.836]  - Getting '...' globals ... DONE
[16:09:35.837] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.837] List of 2
[16:09:35.837]  $ ...future.FUN:function (x, ...)  
[16:09:35.837]  $ ...          :List of 1
[16:09:35.837]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:35.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.837]  - attr(*, "where")=List of 2
[16:09:35.837]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.837]   ..$ ...          :<environment: 0x55b4b776a4f0> 
[16:09:35.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.837]  - attr(*, "resolved")= logi FALSE
[16:09:35.837]  - attr(*, "total_size")= num 1328
[16:09:35.840] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:35.840] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.840] Number of futures (= number of chunks): 1
[16:09:35.840] Launching 1 futures (chunks) ...
[16:09:35.840] Chunk #1 of 1 ...
[16:09:35.841]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.841] getGlobalsAndPackages() ...
[16:09:35.841] Searching for globals...
[16:09:35.841] 
[16:09:35.841] Searching for globals ... DONE
[16:09:35.841] - globals: [0] <none>
[16:09:35.841] getGlobalsAndPackages() ... DONE
[16:09:35.841]    + additional globals found: [n=0] 
[16:09:35.841]    + additional namespaces needed: [n=0] 
[16:09:35.842]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.842]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:35.842]  - seeds: <none>
[16:09:35.842] getGlobalsAndPackages() ...
[16:09:35.842] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.842] Resolving globals: FALSE
[16:09:35.842] Tweak future expression to call with '...' arguments ...
[16:09:35.842] {
[16:09:35.842]     do.call(function(...) {
[16:09:35.842]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.842]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.842]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.842]             on.exit(options(oopts), add = TRUE)
[16:09:35.842]         }
[16:09:35.842]         {
[16:09:35.842]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.842]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.842]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.842]             })
[16:09:35.842]         }
[16:09:35.842]     }, args = future.call.arguments)
[16:09:35.842] }
[16:09:35.843] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.843] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.843] - packages: [1] ‘stats’
[16:09:35.843] getGlobalsAndPackages() ... DONE
[16:09:35.843] run() for ‘Future’ ...
[16:09:35.844] - state: ‘created’
[16:09:35.844] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:35.844] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:35.844]   - Field: ‘label’
[16:09:35.844]   - Field: ‘local’
[16:09:35.844]   - Field: ‘owner’
[16:09:35.845]   - Field: ‘envir’
[16:09:35.845]   - Field: ‘packages’
[16:09:35.845]   - Field: ‘gc’
[16:09:35.845]   - Field: ‘conditions’
[16:09:35.845]   - Field: ‘expr’
[16:09:35.845]   - Field: ‘uuid’
[16:09:35.845]   - Field: ‘seed’
[16:09:35.845]   - Field: ‘version’
[16:09:35.845]   - Field: ‘result’
[16:09:35.845]   - Field: ‘asynchronous’
[16:09:35.845]   - Field: ‘calls’
[16:09:35.846]   - Field: ‘globals’
[16:09:35.846]   - Field: ‘stdout’
[16:09:35.846]   - Field: ‘earlySignal’
[16:09:35.846]   - Field: ‘lazy’
[16:09:35.846]   - Field: ‘state’
[16:09:35.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:35.846] - Launch lazy future ...
[16:09:35.846] Packages needed by the future expression (n = 1): ‘stats’
[16:09:35.846] Packages needed by future strategies (n = 0): <none>
[16:09:35.847] {
[16:09:35.847]     {
[16:09:35.847]         {
[16:09:35.847]             ...future.startTime <- base::Sys.time()
[16:09:35.847]             {
[16:09:35.847]                 {
[16:09:35.847]                   {
[16:09:35.847]                     {
[16:09:35.847]                       base::local({
[16:09:35.847]                         has_future <- base::requireNamespace("future", 
[16:09:35.847]                           quietly = TRUE)
[16:09:35.847]                         if (has_future) {
[16:09:35.847]                           ns <- base::getNamespace("future")
[16:09:35.847]                           version <- ns[[".package"]][["version"]]
[16:09:35.847]                           if (is.null(version)) 
[16:09:35.847]                             version <- utils::packageVersion("future")
[16:09:35.847]                         }
[16:09:35.847]                         else {
[16:09:35.847]                           version <- NULL
[16:09:35.847]                         }
[16:09:35.847]                         if (!has_future || version < "1.8.0") {
[16:09:35.847]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.847]                             "", base::R.version$version.string), 
[16:09:35.847]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.847]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.847]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.847]                               "release", "version")], collapse = " "), 
[16:09:35.847]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.847]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.847]                             info)
[16:09:35.847]                           info <- base::paste(info, collapse = "; ")
[16:09:35.847]                           if (!has_future) {
[16:09:35.847]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.847]                               info)
[16:09:35.847]                           }
[16:09:35.847]                           else {
[16:09:35.847]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.847]                               info, version)
[16:09:35.847]                           }
[16:09:35.847]                           base::stop(msg)
[16:09:35.847]                         }
[16:09:35.847]                       })
[16:09:35.847]                     }
[16:09:35.847]                     base::local({
[16:09:35.847]                       for (pkg in "stats") {
[16:09:35.847]                         base::loadNamespace(pkg)
[16:09:35.847]                         base::library(pkg, character.only = TRUE)
[16:09:35.847]                       }
[16:09:35.847]                     })
[16:09:35.847]                   }
[16:09:35.847]                   options(future.plan = NULL)
[16:09:35.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.847]                 }
[16:09:35.847]                 ...future.workdir <- getwd()
[16:09:35.847]             }
[16:09:35.847]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.847]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.847]         }
[16:09:35.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.847]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:35.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.847]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.847]             base::names(...future.oldOptions))
[16:09:35.847]     }
[16:09:35.847]     if (FALSE) {
[16:09:35.847]     }
[16:09:35.847]     else {
[16:09:35.847]         if (TRUE) {
[16:09:35.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.847]                 open = "w")
[16:09:35.847]         }
[16:09:35.847]         else {
[16:09:35.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.847]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.847]         }
[16:09:35.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.847]             base::sink(type = "output", split = FALSE)
[16:09:35.847]             base::close(...future.stdout)
[16:09:35.847]         }, add = TRUE)
[16:09:35.847]     }
[16:09:35.847]     ...future.frame <- base::sys.nframe()
[16:09:35.847]     ...future.conditions <- base::list()
[16:09:35.847]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.847]     if (FALSE) {
[16:09:35.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.847]     }
[16:09:35.847]     ...future.result <- base::tryCatch({
[16:09:35.847]         base::withCallingHandlers({
[16:09:35.847]             ...future.value <- base::withVisible(base::local({
[16:09:35.847]                 do.call(function(...) {
[16:09:35.847]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.847]                   if (!identical(...future.globals.maxSize.org, 
[16:09:35.847]                     ...future.globals.maxSize)) {
[16:09:35.847]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.847]                     on.exit(options(oopts), add = TRUE)
[16:09:35.847]                   }
[16:09:35.847]                   {
[16:09:35.847]                     lapply(seq_along(...future.elements_ii), 
[16:09:35.847]                       FUN = function(jj) {
[16:09:35.847]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.847]                         ...future.FUN(...future.X_jj, ...)
[16:09:35.847]                       })
[16:09:35.847]                   }
[16:09:35.847]                 }, args = future.call.arguments)
[16:09:35.847]             }))
[16:09:35.847]             future::FutureResult(value = ...future.value$value, 
[16:09:35.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.847]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.847]                     ...future.globalenv.names))
[16:09:35.847]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.847]         }, condition = base::local({
[16:09:35.847]             c <- base::c
[16:09:35.847]             inherits <- base::inherits
[16:09:35.847]             invokeRestart <- base::invokeRestart
[16:09:35.847]             length <- base::length
[16:09:35.847]             list <- base::list
[16:09:35.847]             seq.int <- base::seq.int
[16:09:35.847]             signalCondition <- base::signalCondition
[16:09:35.847]             sys.calls <- base::sys.calls
[16:09:35.847]             `[[` <- base::`[[`
[16:09:35.847]             `+` <- base::`+`
[16:09:35.847]             `<<-` <- base::`<<-`
[16:09:35.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.847]                   3L)]
[16:09:35.847]             }
[16:09:35.847]             function(cond) {
[16:09:35.847]                 is_error <- inherits(cond, "error")
[16:09:35.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.847]                   NULL)
[16:09:35.847]                 if (is_error) {
[16:09:35.847]                   sessionInformation <- function() {
[16:09:35.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.847]                       search = base::search(), system = base::Sys.info())
[16:09:35.847]                   }
[16:09:35.847]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.847]                     cond$call), session = sessionInformation(), 
[16:09:35.847]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.847]                   signalCondition(cond)
[16:09:35.847]                 }
[16:09:35.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.847]                 "immediateCondition"))) {
[16:09:35.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.847]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.847]                   if (TRUE && !signal) {
[16:09:35.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.847]                     {
[16:09:35.847]                       inherits <- base::inherits
[16:09:35.847]                       invokeRestart <- base::invokeRestart
[16:09:35.847]                       is.null <- base::is.null
[16:09:35.847]                       muffled <- FALSE
[16:09:35.847]                       if (inherits(cond, "message")) {
[16:09:35.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.847]                         if (muffled) 
[16:09:35.847]                           invokeRestart("muffleMessage")
[16:09:35.847]                       }
[16:09:35.847]                       else if (inherits(cond, "warning")) {
[16:09:35.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.847]                         if (muffled) 
[16:09:35.847]                           invokeRestart("muffleWarning")
[16:09:35.847]                       }
[16:09:35.847]                       else if (inherits(cond, "condition")) {
[16:09:35.847]                         if (!is.null(pattern)) {
[16:09:35.847]                           computeRestarts <- base::computeRestarts
[16:09:35.847]                           grepl <- base::grepl
[16:09:35.847]                           restarts <- computeRestarts(cond)
[16:09:35.847]                           for (restart in restarts) {
[16:09:35.847]                             name <- restart$name
[16:09:35.847]                             if (is.null(name)) 
[16:09:35.847]                               next
[16:09:35.847]                             if (!grepl(pattern, name)) 
[16:09:35.847]                               next
[16:09:35.847]                             invokeRestart(restart)
[16:09:35.847]                             muffled <- TRUE
[16:09:35.847]                             break
[16:09:35.847]                           }
[16:09:35.847]                         }
[16:09:35.847]                       }
[16:09:35.847]                       invisible(muffled)
[16:09:35.847]                     }
[16:09:35.847]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.847]                   }
[16:09:35.847]                 }
[16:09:35.847]                 else {
[16:09:35.847]                   if (TRUE) {
[16:09:35.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.847]                     {
[16:09:35.847]                       inherits <- base::inherits
[16:09:35.847]                       invokeRestart <- base::invokeRestart
[16:09:35.847]                       is.null <- base::is.null
[16:09:35.847]                       muffled <- FALSE
[16:09:35.847]                       if (inherits(cond, "message")) {
[16:09:35.847]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.847]                         if (muffled) 
[16:09:35.847]                           invokeRestart("muffleMessage")
[16:09:35.847]                       }
[16:09:35.847]                       else if (inherits(cond, "warning")) {
[16:09:35.847]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.847]                         if (muffled) 
[16:09:35.847]                           invokeRestart("muffleWarning")
[16:09:35.847]                       }
[16:09:35.847]                       else if (inherits(cond, "condition")) {
[16:09:35.847]                         if (!is.null(pattern)) {
[16:09:35.847]                           computeRestarts <- base::computeRestarts
[16:09:35.847]                           grepl <- base::grepl
[16:09:35.847]                           restarts <- computeRestarts(cond)
[16:09:35.847]                           for (restart in restarts) {
[16:09:35.847]                             name <- restart$name
[16:09:35.847]                             if (is.null(name)) 
[16:09:35.847]                               next
[16:09:35.847]                             if (!grepl(pattern, name)) 
[16:09:35.847]                               next
[16:09:35.847]                             invokeRestart(restart)
[16:09:35.847]                             muffled <- TRUE
[16:09:35.847]                             break
[16:09:35.847]                           }
[16:09:35.847]                         }
[16:09:35.847]                       }
[16:09:35.847]                       invisible(muffled)
[16:09:35.847]                     }
[16:09:35.847]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.847]                   }
[16:09:35.847]                 }
[16:09:35.847]             }
[16:09:35.847]         }))
[16:09:35.847]     }, error = function(ex) {
[16:09:35.847]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.847]                 ...future.rng), started = ...future.startTime, 
[16:09:35.847]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.847]             version = "1.8"), class = "FutureResult")
[16:09:35.847]     }, finally = {
[16:09:35.847]         if (!identical(...future.workdir, getwd())) 
[16:09:35.847]             setwd(...future.workdir)
[16:09:35.847]         {
[16:09:35.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.847]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.847]             }
[16:09:35.847]             base::options(...future.oldOptions)
[16:09:35.847]             if (.Platform$OS.type == "windows") {
[16:09:35.847]                 old_names <- names(...future.oldEnvVars)
[16:09:35.847]                 envs <- base::Sys.getenv()
[16:09:35.847]                 names <- names(envs)
[16:09:35.847]                 common <- intersect(names, old_names)
[16:09:35.847]                 added <- setdiff(names, old_names)
[16:09:35.847]                 removed <- setdiff(old_names, names)
[16:09:35.847]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.847]                   envs[common]]
[16:09:35.847]                 NAMES <- toupper(changed)
[16:09:35.847]                 args <- list()
[16:09:35.847]                 for (kk in seq_along(NAMES)) {
[16:09:35.847]                   name <- changed[[kk]]
[16:09:35.847]                   NAME <- NAMES[[kk]]
[16:09:35.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.847]                     next
[16:09:35.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.847]                 }
[16:09:35.847]                 NAMES <- toupper(added)
[16:09:35.847]                 for (kk in seq_along(NAMES)) {
[16:09:35.847]                   name <- added[[kk]]
[16:09:35.847]                   NAME <- NAMES[[kk]]
[16:09:35.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.847]                     next
[16:09:35.847]                   args[[name]] <- ""
[16:09:35.847]                 }
[16:09:35.847]                 NAMES <- toupper(removed)
[16:09:35.847]                 for (kk in seq_along(NAMES)) {
[16:09:35.847]                   name <- removed[[kk]]
[16:09:35.847]                   NAME <- NAMES[[kk]]
[16:09:35.847]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.847]                     next
[16:09:35.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.847]                 }
[16:09:35.847]                 if (length(args) > 0) 
[16:09:35.847]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.847]             }
[16:09:35.847]             else {
[16:09:35.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.847]             }
[16:09:35.847]             {
[16:09:35.847]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.847]                   0L) {
[16:09:35.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.847]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.847]                   base::options(opts)
[16:09:35.847]                 }
[16:09:35.847]                 {
[16:09:35.847]                   {
[16:09:35.847]                     NULL
[16:09:35.847]                     RNGkind("Mersenne-Twister")
[16:09:35.847]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:35.847]                       inherits = FALSE)
[16:09:35.847]                   }
[16:09:35.847]                   options(future.plan = NULL)
[16:09:35.847]                   if (is.na(NA_character_)) 
[16:09:35.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.847]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:35.847]                   {
[16:09:35.847]                     future <- SequentialFuture(..., envir = envir)
[16:09:35.847]                     if (!future$lazy) 
[16:09:35.847]                       future <- run(future)
[16:09:35.847]                     invisible(future)
[16:09:35.847]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.847]                 }
[16:09:35.847]             }
[16:09:35.847]         }
[16:09:35.847]     })
[16:09:35.847]     if (TRUE) {
[16:09:35.847]         base::sink(type = "output", split = FALSE)
[16:09:35.847]         if (TRUE) {
[16:09:35.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.847]         }
[16:09:35.847]         else {
[16:09:35.847]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.847]         }
[16:09:35.847]         base::close(...future.stdout)
[16:09:35.847]         ...future.stdout <- NULL
[16:09:35.847]     }
[16:09:35.847]     ...future.result$conditions <- ...future.conditions
[16:09:35.847]     ...future.result$finished <- base::Sys.time()
[16:09:35.847]     ...future.result
[16:09:35.847] }
[16:09:35.849] assign_globals() ...
[16:09:35.849] List of 5
[16:09:35.849]  $ ...future.FUN            :function (x, ...)  
[16:09:35.849]  $ future.call.arguments    :List of 1
[16:09:35.849]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:35.849]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.849]  $ ...future.elements_ii    :List of 3
[16:09:35.849]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:09:35.849]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:35.849]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:35.849]  $ ...future.seeds_ii       : NULL
[16:09:35.849]  $ ...future.globals.maxSize: NULL
[16:09:35.849]  - attr(*, "resolved")= logi FALSE
[16:09:35.849]  - attr(*, "total_size")= num 1328
[16:09:35.849]  - attr(*, "where")=List of 5
[16:09:35.849]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:35.849]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:35.849]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:35.849]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:35.849]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:35.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.849]  - attr(*, "already-done")= logi TRUE
[16:09:35.856] - copied ‘...future.FUN’ to environment
[16:09:35.856] - copied ‘future.call.arguments’ to environment
[16:09:35.857] - copied ‘...future.elements_ii’ to environment
[16:09:35.857] - copied ‘...future.seeds_ii’ to environment
[16:09:35.857] - copied ‘...future.globals.maxSize’ to environment
[16:09:35.857] assign_globals() ... done
[16:09:35.857] plan(): Setting new future strategy stack:
[16:09:35.857] List of future strategies:
[16:09:35.857] 1. sequential:
[16:09:35.857]    - args: function (..., envir = parent.frame())
[16:09:35.857]    - tweaked: FALSE
[16:09:35.857]    - call: NULL
[16:09:35.858] plan(): nbrOfWorkers() = 1
[16:09:35.859] plan(): Setting new future strategy stack:
[16:09:35.859] List of future strategies:
[16:09:35.859] 1. sequential:
[16:09:35.859]    - args: function (..., envir = parent.frame())
[16:09:35.859]    - tweaked: FALSE
[16:09:35.859]    - call: plan(strategy)
[16:09:35.860] plan(): nbrOfWorkers() = 1
[16:09:35.860] SequentialFuture started (and completed)
[16:09:35.860] - Launch lazy future ... done
[16:09:35.860] run() for ‘SequentialFuture’ ... done
[16:09:35.860] Created future:
[16:09:35.860] SequentialFuture:
[16:09:35.860] Label: ‘future_eapply-1’
[16:09:35.860] Expression:
[16:09:35.860] {
[16:09:35.860]     do.call(function(...) {
[16:09:35.860]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.860]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.860]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.860]             on.exit(options(oopts), add = TRUE)
[16:09:35.860]         }
[16:09:35.860]         {
[16:09:35.860]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.860]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.860]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.860]             })
[16:09:35.860]         }
[16:09:35.860]     }, args = future.call.arguments)
[16:09:35.860] }
[16:09:35.860] Lazy evaluation: FALSE
[16:09:35.860] Asynchronous evaluation: FALSE
[16:09:35.860] Local evaluation: TRUE
[16:09:35.860] Environment: R_GlobalEnv
[16:09:35.860] Capture standard output: TRUE
[16:09:35.860] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.860] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.860] Packages: 1 packages (‘stats’)
[16:09:35.860] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.860] Resolved: TRUE
[16:09:35.860] Value: 1.29 KiB of class ‘list’
[16:09:35.860] Early signaling: FALSE
[16:09:35.860] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:35.860] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.861] Chunk #1 of 1 ... DONE
[16:09:35.861] Launching 1 futures (chunks) ... DONE
[16:09:35.861] Resolving 1 futures (chunks) ...
[16:09:35.861] resolve() on list ...
[16:09:35.862]  recursive: 0
[16:09:35.862]  length: 1
[16:09:35.862] 
[16:09:35.862] resolved() for ‘SequentialFuture’ ...
[16:09:35.862] - state: ‘finished’
[16:09:35.862] - run: TRUE
[16:09:35.862] - result: ‘FutureResult’
[16:09:35.862] resolved() for ‘SequentialFuture’ ... done
[16:09:35.862] Future #1
[16:09:35.863] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:35.863] - nx: 1
[16:09:35.863] - relay: TRUE
[16:09:35.863] - stdout: TRUE
[16:09:35.863] - signal: TRUE
[16:09:35.863] - resignal: FALSE
[16:09:35.863] - force: TRUE
[16:09:35.863] - relayed: [n=1] FALSE
[16:09:35.863] - queued futures: [n=1] FALSE
[16:09:35.863]  - until=1
[16:09:35.863]  - relaying element #1
[16:09:35.864] - relayed: [n=1] TRUE
[16:09:35.864] - queued futures: [n=1] TRUE
[16:09:35.864] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:35.864]  length: 0 (resolved future 1)
[16:09:35.864] Relaying remaining futures
[16:09:35.864] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.864] - nx: 1
[16:09:35.864] - relay: TRUE
[16:09:35.864] - stdout: TRUE
[16:09:35.864] - signal: TRUE
[16:09:35.864] - resignal: FALSE
[16:09:35.865] - force: TRUE
[16:09:35.865] - relayed: [n=1] TRUE
[16:09:35.865] - queued futures: [n=1] TRUE
 - flush all
[16:09:35.865] - relayed: [n=1] TRUE
[16:09:35.865] - queued futures: [n=1] TRUE
[16:09:35.865] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.865] resolve() on list ... DONE
[16:09:35.865]  - Number of value chunks collected: 1
[16:09:35.865] Resolving 1 futures (chunks) ... DONE
[16:09:35.865] Reducing values from 1 chunks ...
[16:09:35.866]  - Number of values collected after concatenation: 3
[16:09:35.866]  - Number of values expected: 3
[16:09:35.866] Reducing values from 1 chunks ... DONE
[16:09:35.866] future_lapply() ... DONE
[16:09:35.867] future_lapply() ...
[16:09:35.868] Number of chunks: 1
[16:09:35.868] getGlobalsAndPackagesXApply() ...
[16:09:35.868]  - future.globals: TRUE
[16:09:35.868] getGlobalsAndPackages() ...
[16:09:35.868] Searching for globals...
[16:09:35.870] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.870] Searching for globals ... DONE
[16:09:35.870] Resolving globals: FALSE
[16:09:35.870] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:35.871] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:35.871] - globals: [1] ‘FUN’
[16:09:35.871] - packages: [1] ‘stats’
[16:09:35.871] getGlobalsAndPackages() ... DONE
[16:09:35.871]  - globals found/used: [n=1] ‘FUN’
[16:09:35.871]  - needed namespaces: [n=1] ‘stats’
[16:09:35.871] Finding globals ... DONE
[16:09:35.871]  - use_args: TRUE
[16:09:35.872]  - Getting '...' globals ...
[16:09:35.872] resolve() on list ...
[16:09:35.872]  recursive: 0
[16:09:35.872]  length: 1
[16:09:35.872]  elements: ‘...’
[16:09:35.872]  length: 0 (resolved future 1)
[16:09:35.872] resolve() on list ... DONE
[16:09:35.872]    - '...' content: [n=0] 
[16:09:35.873] List of 1
[16:09:35.873]  $ ...: list()
[16:09:35.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.873]  - attr(*, "where")=List of 1
[16:09:35.873]   ..$ ...:<environment: 0x55b4b7c99360> 
[16:09:35.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.873]  - attr(*, "resolved")= logi TRUE
[16:09:35.873]  - attr(*, "total_size")= num NA
[16:09:35.875]  - Getting '...' globals ... DONE
[16:09:35.875] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.876] List of 2
[16:09:35.876]  $ ...future.FUN:function (x, ...)  
[16:09:35.876]  $ ...          : list()
[16:09:35.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.876]  - attr(*, "where")=List of 2
[16:09:35.876]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.876]   ..$ ...          :<environment: 0x55b4b7c99360> 
[16:09:35.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.876]  - attr(*, "resolved")= logi FALSE
[16:09:35.876]  - attr(*, "total_size")= num 1248
[16:09:35.878] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:35.879] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.881] Number of futures (= number of chunks): 1
[16:09:35.881] Launching 1 futures (chunks) ...
[16:09:35.881] Chunk #1 of 1 ...
[16:09:35.881]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.881] getGlobalsAndPackages() ...
[16:09:35.881] Searching for globals...
[16:09:35.882] 
[16:09:35.882] Searching for globals ... DONE
[16:09:35.882] - globals: [0] <none>
[16:09:35.882] getGlobalsAndPackages() ... DONE
[16:09:35.882]    + additional globals found: [n=0] 
[16:09:35.882]    + additional namespaces needed: [n=0] 
[16:09:35.882]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.882]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:35.882]  - seeds: <none>
[16:09:35.883] getGlobalsAndPackages() ...
[16:09:35.883] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.883] Resolving globals: FALSE
[16:09:35.883] Tweak future expression to call with '...' arguments ...
[16:09:35.883] {
[16:09:35.883]     do.call(function(...) {
[16:09:35.883]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.883]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.883]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.883]             on.exit(options(oopts), add = TRUE)
[16:09:35.883]         }
[16:09:35.883]         {
[16:09:35.883]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.883]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.883]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.883]             })
[16:09:35.883]         }
[16:09:35.883]     }, args = future.call.arguments)
[16:09:35.883] }
[16:09:35.883] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.884] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.884] - packages: [1] ‘stats’
[16:09:35.884] getGlobalsAndPackages() ... DONE
[16:09:35.884] run() for ‘Future’ ...
[16:09:35.884] - state: ‘created’
[16:09:35.884] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:35.885] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:35.885]   - Field: ‘label’
[16:09:35.885]   - Field: ‘local’
[16:09:35.885]   - Field: ‘owner’
[16:09:35.885]   - Field: ‘envir’
[16:09:35.885]   - Field: ‘packages’
[16:09:35.885]   - Field: ‘gc’
[16:09:35.886]   - Field: ‘conditions’
[16:09:35.886]   - Field: ‘expr’
[16:09:35.886]   - Field: ‘uuid’
[16:09:35.886]   - Field: ‘seed’
[16:09:35.886]   - Field: ‘version’
[16:09:35.886]   - Field: ‘result’
[16:09:35.886]   - Field: ‘asynchronous’
[16:09:35.886]   - Field: ‘calls’
[16:09:35.886]   - Field: ‘globals’
[16:09:35.886]   - Field: ‘stdout’
[16:09:35.886]   - Field: ‘earlySignal’
[16:09:35.887]   - Field: ‘lazy’
[16:09:35.887]   - Field: ‘state’
[16:09:35.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:35.887] - Launch lazy future ...
[16:09:35.887] Packages needed by the future expression (n = 1): ‘stats’
[16:09:35.887] Packages needed by future strategies (n = 0): <none>
[16:09:35.888] {
[16:09:35.888]     {
[16:09:35.888]         {
[16:09:35.888]             ...future.startTime <- base::Sys.time()
[16:09:35.888]             {
[16:09:35.888]                 {
[16:09:35.888]                   {
[16:09:35.888]                     {
[16:09:35.888]                       base::local({
[16:09:35.888]                         has_future <- base::requireNamespace("future", 
[16:09:35.888]                           quietly = TRUE)
[16:09:35.888]                         if (has_future) {
[16:09:35.888]                           ns <- base::getNamespace("future")
[16:09:35.888]                           version <- ns[[".package"]][["version"]]
[16:09:35.888]                           if (is.null(version)) 
[16:09:35.888]                             version <- utils::packageVersion("future")
[16:09:35.888]                         }
[16:09:35.888]                         else {
[16:09:35.888]                           version <- NULL
[16:09:35.888]                         }
[16:09:35.888]                         if (!has_future || version < "1.8.0") {
[16:09:35.888]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.888]                             "", base::R.version$version.string), 
[16:09:35.888]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.888]                               "release", "version")], collapse = " "), 
[16:09:35.888]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.888]                             info)
[16:09:35.888]                           info <- base::paste(info, collapse = "; ")
[16:09:35.888]                           if (!has_future) {
[16:09:35.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.888]                               info)
[16:09:35.888]                           }
[16:09:35.888]                           else {
[16:09:35.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.888]                               info, version)
[16:09:35.888]                           }
[16:09:35.888]                           base::stop(msg)
[16:09:35.888]                         }
[16:09:35.888]                       })
[16:09:35.888]                     }
[16:09:35.888]                     base::local({
[16:09:35.888]                       for (pkg in "stats") {
[16:09:35.888]                         base::loadNamespace(pkg)
[16:09:35.888]                         base::library(pkg, character.only = TRUE)
[16:09:35.888]                       }
[16:09:35.888]                     })
[16:09:35.888]                   }
[16:09:35.888]                   options(future.plan = NULL)
[16:09:35.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.888]                 }
[16:09:35.888]                 ...future.workdir <- getwd()
[16:09:35.888]             }
[16:09:35.888]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.888]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.888]         }
[16:09:35.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.888]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:35.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.888]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.888]             base::names(...future.oldOptions))
[16:09:35.888]     }
[16:09:35.888]     if (FALSE) {
[16:09:35.888]     }
[16:09:35.888]     else {
[16:09:35.888]         if (TRUE) {
[16:09:35.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.888]                 open = "w")
[16:09:35.888]         }
[16:09:35.888]         else {
[16:09:35.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.888]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.888]         }
[16:09:35.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.888]             base::sink(type = "output", split = FALSE)
[16:09:35.888]             base::close(...future.stdout)
[16:09:35.888]         }, add = TRUE)
[16:09:35.888]     }
[16:09:35.888]     ...future.frame <- base::sys.nframe()
[16:09:35.888]     ...future.conditions <- base::list()
[16:09:35.888]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.888]     if (FALSE) {
[16:09:35.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.888]     }
[16:09:35.888]     ...future.result <- base::tryCatch({
[16:09:35.888]         base::withCallingHandlers({
[16:09:35.888]             ...future.value <- base::withVisible(base::local({
[16:09:35.888]                 do.call(function(...) {
[16:09:35.888]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.888]                   if (!identical(...future.globals.maxSize.org, 
[16:09:35.888]                     ...future.globals.maxSize)) {
[16:09:35.888]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.888]                     on.exit(options(oopts), add = TRUE)
[16:09:35.888]                   }
[16:09:35.888]                   {
[16:09:35.888]                     lapply(seq_along(...future.elements_ii), 
[16:09:35.888]                       FUN = function(jj) {
[16:09:35.888]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.888]                         ...future.FUN(...future.X_jj, ...)
[16:09:35.888]                       })
[16:09:35.888]                   }
[16:09:35.888]                 }, args = future.call.arguments)
[16:09:35.888]             }))
[16:09:35.888]             future::FutureResult(value = ...future.value$value, 
[16:09:35.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.888]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.888]                     ...future.globalenv.names))
[16:09:35.888]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.888]         }, condition = base::local({
[16:09:35.888]             c <- base::c
[16:09:35.888]             inherits <- base::inherits
[16:09:35.888]             invokeRestart <- base::invokeRestart
[16:09:35.888]             length <- base::length
[16:09:35.888]             list <- base::list
[16:09:35.888]             seq.int <- base::seq.int
[16:09:35.888]             signalCondition <- base::signalCondition
[16:09:35.888]             sys.calls <- base::sys.calls
[16:09:35.888]             `[[` <- base::`[[`
[16:09:35.888]             `+` <- base::`+`
[16:09:35.888]             `<<-` <- base::`<<-`
[16:09:35.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.888]                   3L)]
[16:09:35.888]             }
[16:09:35.888]             function(cond) {
[16:09:35.888]                 is_error <- inherits(cond, "error")
[16:09:35.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.888]                   NULL)
[16:09:35.888]                 if (is_error) {
[16:09:35.888]                   sessionInformation <- function() {
[16:09:35.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.888]                       search = base::search(), system = base::Sys.info())
[16:09:35.888]                   }
[16:09:35.888]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.888]                     cond$call), session = sessionInformation(), 
[16:09:35.888]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.888]                   signalCondition(cond)
[16:09:35.888]                 }
[16:09:35.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.888]                 "immediateCondition"))) {
[16:09:35.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.888]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.888]                   if (TRUE && !signal) {
[16:09:35.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.888]                     {
[16:09:35.888]                       inherits <- base::inherits
[16:09:35.888]                       invokeRestart <- base::invokeRestart
[16:09:35.888]                       is.null <- base::is.null
[16:09:35.888]                       muffled <- FALSE
[16:09:35.888]                       if (inherits(cond, "message")) {
[16:09:35.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.888]                         if (muffled) 
[16:09:35.888]                           invokeRestart("muffleMessage")
[16:09:35.888]                       }
[16:09:35.888]                       else if (inherits(cond, "warning")) {
[16:09:35.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.888]                         if (muffled) 
[16:09:35.888]                           invokeRestart("muffleWarning")
[16:09:35.888]                       }
[16:09:35.888]                       else if (inherits(cond, "condition")) {
[16:09:35.888]                         if (!is.null(pattern)) {
[16:09:35.888]                           computeRestarts <- base::computeRestarts
[16:09:35.888]                           grepl <- base::grepl
[16:09:35.888]                           restarts <- computeRestarts(cond)
[16:09:35.888]                           for (restart in restarts) {
[16:09:35.888]                             name <- restart$name
[16:09:35.888]                             if (is.null(name)) 
[16:09:35.888]                               next
[16:09:35.888]                             if (!grepl(pattern, name)) 
[16:09:35.888]                               next
[16:09:35.888]                             invokeRestart(restart)
[16:09:35.888]                             muffled <- TRUE
[16:09:35.888]                             break
[16:09:35.888]                           }
[16:09:35.888]                         }
[16:09:35.888]                       }
[16:09:35.888]                       invisible(muffled)
[16:09:35.888]                     }
[16:09:35.888]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.888]                   }
[16:09:35.888]                 }
[16:09:35.888]                 else {
[16:09:35.888]                   if (TRUE) {
[16:09:35.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.888]                     {
[16:09:35.888]                       inherits <- base::inherits
[16:09:35.888]                       invokeRestart <- base::invokeRestart
[16:09:35.888]                       is.null <- base::is.null
[16:09:35.888]                       muffled <- FALSE
[16:09:35.888]                       if (inherits(cond, "message")) {
[16:09:35.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.888]                         if (muffled) 
[16:09:35.888]                           invokeRestart("muffleMessage")
[16:09:35.888]                       }
[16:09:35.888]                       else if (inherits(cond, "warning")) {
[16:09:35.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.888]                         if (muffled) 
[16:09:35.888]                           invokeRestart("muffleWarning")
[16:09:35.888]                       }
[16:09:35.888]                       else if (inherits(cond, "condition")) {
[16:09:35.888]                         if (!is.null(pattern)) {
[16:09:35.888]                           computeRestarts <- base::computeRestarts
[16:09:35.888]                           grepl <- base::grepl
[16:09:35.888]                           restarts <- computeRestarts(cond)
[16:09:35.888]                           for (restart in restarts) {
[16:09:35.888]                             name <- restart$name
[16:09:35.888]                             if (is.null(name)) 
[16:09:35.888]                               next
[16:09:35.888]                             if (!grepl(pattern, name)) 
[16:09:35.888]                               next
[16:09:35.888]                             invokeRestart(restart)
[16:09:35.888]                             muffled <- TRUE
[16:09:35.888]                             break
[16:09:35.888]                           }
[16:09:35.888]                         }
[16:09:35.888]                       }
[16:09:35.888]                       invisible(muffled)
[16:09:35.888]                     }
[16:09:35.888]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.888]                   }
[16:09:35.888]                 }
[16:09:35.888]             }
[16:09:35.888]         }))
[16:09:35.888]     }, error = function(ex) {
[16:09:35.888]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.888]                 ...future.rng), started = ...future.startTime, 
[16:09:35.888]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.888]             version = "1.8"), class = "FutureResult")
[16:09:35.888]     }, finally = {
[16:09:35.888]         if (!identical(...future.workdir, getwd())) 
[16:09:35.888]             setwd(...future.workdir)
[16:09:35.888]         {
[16:09:35.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.888]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.888]             }
[16:09:35.888]             base::options(...future.oldOptions)
[16:09:35.888]             if (.Platform$OS.type == "windows") {
[16:09:35.888]                 old_names <- names(...future.oldEnvVars)
[16:09:35.888]                 envs <- base::Sys.getenv()
[16:09:35.888]                 names <- names(envs)
[16:09:35.888]                 common <- intersect(names, old_names)
[16:09:35.888]                 added <- setdiff(names, old_names)
[16:09:35.888]                 removed <- setdiff(old_names, names)
[16:09:35.888]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.888]                   envs[common]]
[16:09:35.888]                 NAMES <- toupper(changed)
[16:09:35.888]                 args <- list()
[16:09:35.888]                 for (kk in seq_along(NAMES)) {
[16:09:35.888]                   name <- changed[[kk]]
[16:09:35.888]                   NAME <- NAMES[[kk]]
[16:09:35.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.888]                     next
[16:09:35.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.888]                 }
[16:09:35.888]                 NAMES <- toupper(added)
[16:09:35.888]                 for (kk in seq_along(NAMES)) {
[16:09:35.888]                   name <- added[[kk]]
[16:09:35.888]                   NAME <- NAMES[[kk]]
[16:09:35.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.888]                     next
[16:09:35.888]                   args[[name]] <- ""
[16:09:35.888]                 }
[16:09:35.888]                 NAMES <- toupper(removed)
[16:09:35.888]                 for (kk in seq_along(NAMES)) {
[16:09:35.888]                   name <- removed[[kk]]
[16:09:35.888]                   NAME <- NAMES[[kk]]
[16:09:35.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.888]                     next
[16:09:35.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.888]                 }
[16:09:35.888]                 if (length(args) > 0) 
[16:09:35.888]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.888]             }
[16:09:35.888]             else {
[16:09:35.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.888]             }
[16:09:35.888]             {
[16:09:35.888]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.888]                   0L) {
[16:09:35.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.888]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.888]                   base::options(opts)
[16:09:35.888]                 }
[16:09:35.888]                 {
[16:09:35.888]                   {
[16:09:35.888]                     NULL
[16:09:35.888]                     RNGkind("Mersenne-Twister")
[16:09:35.888]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:35.888]                       inherits = FALSE)
[16:09:35.888]                   }
[16:09:35.888]                   options(future.plan = NULL)
[16:09:35.888]                   if (is.na(NA_character_)) 
[16:09:35.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.888]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:35.888]                   {
[16:09:35.888]                     future <- SequentialFuture(..., envir = envir)
[16:09:35.888]                     if (!future$lazy) 
[16:09:35.888]                       future <- run(future)
[16:09:35.888]                     invisible(future)
[16:09:35.888]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.888]                 }
[16:09:35.888]             }
[16:09:35.888]         }
[16:09:35.888]     })
[16:09:35.888]     if (TRUE) {
[16:09:35.888]         base::sink(type = "output", split = FALSE)
[16:09:35.888]         if (TRUE) {
[16:09:35.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.888]         }
[16:09:35.888]         else {
[16:09:35.888]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.888]         }
[16:09:35.888]         base::close(...future.stdout)
[16:09:35.888]         ...future.stdout <- NULL
[16:09:35.888]     }
[16:09:35.888]     ...future.result$conditions <- ...future.conditions
[16:09:35.888]     ...future.result$finished <- base::Sys.time()
[16:09:35.888]     ...future.result
[16:09:35.888] }
[16:09:35.889] assign_globals() ...
[16:09:35.890] List of 5
[16:09:35.890]  $ ...future.FUN            :function (x, ...)  
[16:09:35.890]  $ future.call.arguments    : list()
[16:09:35.890]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.890]  $ ...future.elements_ii    :List of 3
[16:09:35.890]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:09:35.890]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:35.890]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:35.890]  $ ...future.seeds_ii       : NULL
[16:09:35.890]  $ ...future.globals.maxSize: NULL
[16:09:35.890]  - attr(*, "resolved")= logi FALSE
[16:09:35.890]  - attr(*, "total_size")= num 1248
[16:09:35.890]  - attr(*, "where")=List of 5
[16:09:35.890]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:35.890]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:35.890]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:35.890]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:35.890]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:35.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.890]  - attr(*, "already-done")= logi TRUE
[16:09:35.895] - copied ‘...future.FUN’ to environment
[16:09:35.895] - copied ‘future.call.arguments’ to environment
[16:09:35.895] - copied ‘...future.elements_ii’ to environment
[16:09:35.895] - copied ‘...future.seeds_ii’ to environment
[16:09:35.895] - copied ‘...future.globals.maxSize’ to environment
[16:09:35.895] assign_globals() ... done
[16:09:35.896] plan(): Setting new future strategy stack:
[16:09:35.896] List of future strategies:
[16:09:35.896] 1. sequential:
[16:09:35.896]    - args: function (..., envir = parent.frame())
[16:09:35.896]    - tweaked: FALSE
[16:09:35.896]    - call: NULL
[16:09:35.896] plan(): nbrOfWorkers() = 1
[16:09:35.897] plan(): Setting new future strategy stack:
[16:09:35.897] List of future strategies:
[16:09:35.897] 1. sequential:
[16:09:35.897]    - args: function (..., envir = parent.frame())
[16:09:35.897]    - tweaked: FALSE
[16:09:35.897]    - call: plan(strategy)
[16:09:35.898] plan(): nbrOfWorkers() = 1
[16:09:35.898] SequentialFuture started (and completed)
[16:09:35.898] - Launch lazy future ... done
[16:09:35.898] run() for ‘SequentialFuture’ ... done
[16:09:35.898] Created future:
[16:09:35.898] SequentialFuture:
[16:09:35.898] Label: ‘future_eapply-1’
[16:09:35.898] Expression:
[16:09:35.898] {
[16:09:35.898]     do.call(function(...) {
[16:09:35.898]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.898]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.898]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.898]             on.exit(options(oopts), add = TRUE)
[16:09:35.898]         }
[16:09:35.898]         {
[16:09:35.898]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.898]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.898]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.898]             })
[16:09:35.898]         }
[16:09:35.898]     }, args = future.call.arguments)
[16:09:35.898] }
[16:09:35.898] Lazy evaluation: FALSE
[16:09:35.898] Asynchronous evaluation: FALSE
[16:09:35.898] Local evaluation: TRUE
[16:09:35.898] Environment: R_GlobalEnv
[16:09:35.898] Capture standard output: TRUE
[16:09:35.898] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.898] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.898] Packages: 1 packages (‘stats’)
[16:09:35.898] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.898] Resolved: TRUE
[16:09:35.898] Value: 1.71 KiB of class ‘list’
[16:09:35.898] Early signaling: FALSE
[16:09:35.898] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:35.898] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.899] Chunk #1 of 1 ... DONE
[16:09:35.900] Launching 1 futures (chunks) ... DONE
[16:09:35.900] Resolving 1 futures (chunks) ...
[16:09:35.900] resolve() on list ...
[16:09:35.900]  recursive: 0
[16:09:35.900]  length: 1
[16:09:35.900] 
[16:09:35.900] resolved() for ‘SequentialFuture’ ...
[16:09:35.900] - state: ‘finished’
[16:09:35.900] - run: TRUE
[16:09:35.900] - result: ‘FutureResult’
[16:09:35.901] resolved() for ‘SequentialFuture’ ... done
[16:09:35.901] Future #1
[16:09:35.901] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:35.901] - nx: 1
[16:09:35.901] - relay: TRUE
[16:09:35.901] - stdout: TRUE
[16:09:35.901] - signal: TRUE
[16:09:35.901] - resignal: FALSE
[16:09:35.901] - force: TRUE
[16:09:35.901] - relayed: [n=1] FALSE
[16:09:35.901] - queued futures: [n=1] FALSE
[16:09:35.902]  - until=1
[16:09:35.902]  - relaying element #1
[16:09:35.902] - relayed: [n=1] TRUE
[16:09:35.902] - queued futures: [n=1] TRUE
[16:09:35.902] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:35.902]  length: 0 (resolved future 1)
[16:09:35.902] Relaying remaining futures
[16:09:35.902] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.902] - nx: 1
[16:09:35.902] - relay: TRUE
[16:09:35.902] - stdout: TRUE
[16:09:35.903] - signal: TRUE
[16:09:35.903] - resignal: FALSE
[16:09:35.903] - force: TRUE
[16:09:35.903] - relayed: [n=1] TRUE
[16:09:35.903] - queued futures: [n=1] TRUE
 - flush all
[16:09:35.903] - relayed: [n=1] TRUE
[16:09:35.903] - queued futures: [n=1] TRUE
[16:09:35.903] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.903] resolve() on list ... DONE
[16:09:35.903]  - Number of value chunks collected: 1
[16:09:35.904] Resolving 1 futures (chunks) ... DONE
[16:09:35.904] Reducing values from 1 chunks ...
[16:09:35.904]  - Number of values collected after concatenation: 3
[16:09:35.904]  - Number of values expected: 3
[16:09:35.904] Reducing values from 1 chunks ... DONE
[16:09:35.904] future_lapply() ... DONE
[16:09:35.904] future_lapply() ...
[16:09:35.906] Number of chunks: 1
[16:09:35.906] getGlobalsAndPackagesXApply() ...
[16:09:35.906]  - future.globals: TRUE
[16:09:35.906] getGlobalsAndPackages() ...
[16:09:35.907] Searching for globals...
[16:09:35.908] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.908] Searching for globals ... DONE
[16:09:35.908] Resolving globals: FALSE
[16:09:35.908] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:35.908] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:35.909] - globals: [1] ‘FUN’
[16:09:35.909] - packages: [1] ‘stats’
[16:09:35.909] getGlobalsAndPackages() ... DONE
[16:09:35.909]  - globals found/used: [n=1] ‘FUN’
[16:09:35.909]  - needed namespaces: [n=1] ‘stats’
[16:09:35.909] Finding globals ... DONE
[16:09:35.909]  - use_args: TRUE
[16:09:35.909]  - Getting '...' globals ...
[16:09:35.910] resolve() on list ...
[16:09:35.910]  recursive: 0
[16:09:35.910]  length: 1
[16:09:35.910]  elements: ‘...’
[16:09:35.910]  length: 0 (resolved future 1)
[16:09:35.910] resolve() on list ... DONE
[16:09:35.910]    - '...' content: [n=0] 
[16:09:35.910] List of 1
[16:09:35.910]  $ ...: list()
[16:09:35.910]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.910]  - attr(*, "where")=List of 1
[16:09:35.910]   ..$ ...:<environment: 0x55b4b87a1088> 
[16:09:35.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.910]  - attr(*, "resolved")= logi TRUE
[16:09:35.910]  - attr(*, "total_size")= num NA
[16:09:35.913]  - Getting '...' globals ... DONE
[16:09:35.913] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.913] List of 2
[16:09:35.913]  $ ...future.FUN:function (x, ...)  
[16:09:35.913]  $ ...          : list()
[16:09:35.913]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.913]  - attr(*, "where")=List of 2
[16:09:35.913]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.913]   ..$ ...          :<environment: 0x55b4b87a1088> 
[16:09:35.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.913]  - attr(*, "resolved")= logi FALSE
[16:09:35.913]  - attr(*, "total_size")= num 1248
[16:09:35.916] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:35.916] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.916] Number of futures (= number of chunks): 1
[16:09:35.916] Launching 1 futures (chunks) ...
[16:09:35.916] Chunk #1 of 1 ...
[16:09:35.916]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.916] getGlobalsAndPackages() ...
[16:09:35.916] Searching for globals...
[16:09:35.917] 
[16:09:35.917] Searching for globals ... DONE
[16:09:35.917] - globals: [0] <none>
[16:09:35.917] getGlobalsAndPackages() ... DONE
[16:09:35.917]    + additional globals found: [n=0] 
[16:09:35.917]    + additional namespaces needed: [n=0] 
[16:09:35.917]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.917]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:09:35.917]  - seeds: <none>
[16:09:35.917] getGlobalsAndPackages() ...
[16:09:35.917] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.918] Resolving globals: FALSE
[16:09:35.918] Tweak future expression to call with '...' arguments ...
[16:09:35.918] {
[16:09:35.918]     do.call(function(...) {
[16:09:35.918]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.918]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.918]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.918]             on.exit(options(oopts), add = TRUE)
[16:09:35.918]         }
[16:09:35.918]         {
[16:09:35.918]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.918]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.918]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.918]             })
[16:09:35.918]         }
[16:09:35.918]     }, args = future.call.arguments)
[16:09:35.918] }
[16:09:35.918] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.918] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.919] - packages: [1] ‘stats’
[16:09:35.919] getGlobalsAndPackages() ... DONE
[16:09:35.919] run() for ‘Future’ ...
[16:09:35.919] - state: ‘created’
[16:09:35.919] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:35.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:35.920]   - Field: ‘label’
[16:09:35.920]   - Field: ‘local’
[16:09:35.920]   - Field: ‘owner’
[16:09:35.920]   - Field: ‘envir’
[16:09:35.920]   - Field: ‘packages’
[16:09:35.920]   - Field: ‘gc’
[16:09:35.920]   - Field: ‘conditions’
[16:09:35.920]   - Field: ‘expr’
[16:09:35.920]   - Field: ‘uuid’
[16:09:35.921]   - Field: ‘seed’
[16:09:35.921]   - Field: ‘version’
[16:09:35.921]   - Field: ‘result’
[16:09:35.921]   - Field: ‘asynchronous’
[16:09:35.921]   - Field: ‘calls’
[16:09:35.921]   - Field: ‘globals’
[16:09:35.921]   - Field: ‘stdout’
[16:09:35.921]   - Field: ‘earlySignal’
[16:09:35.921]   - Field: ‘lazy’
[16:09:35.921]   - Field: ‘state’
[16:09:35.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:35.922] - Launch lazy future ...
[16:09:35.922] Packages needed by the future expression (n = 1): ‘stats’
[16:09:35.922] Packages needed by future strategies (n = 0): <none>
[16:09:35.922] {
[16:09:35.922]     {
[16:09:35.922]         {
[16:09:35.922]             ...future.startTime <- base::Sys.time()
[16:09:35.922]             {
[16:09:35.922]                 {
[16:09:35.922]                   {
[16:09:35.922]                     {
[16:09:35.922]                       base::local({
[16:09:35.922]                         has_future <- base::requireNamespace("future", 
[16:09:35.922]                           quietly = TRUE)
[16:09:35.922]                         if (has_future) {
[16:09:35.922]                           ns <- base::getNamespace("future")
[16:09:35.922]                           version <- ns[[".package"]][["version"]]
[16:09:35.922]                           if (is.null(version)) 
[16:09:35.922]                             version <- utils::packageVersion("future")
[16:09:35.922]                         }
[16:09:35.922]                         else {
[16:09:35.922]                           version <- NULL
[16:09:35.922]                         }
[16:09:35.922]                         if (!has_future || version < "1.8.0") {
[16:09:35.922]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.922]                             "", base::R.version$version.string), 
[16:09:35.922]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.922]                               "release", "version")], collapse = " "), 
[16:09:35.922]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.922]                             info)
[16:09:35.922]                           info <- base::paste(info, collapse = "; ")
[16:09:35.922]                           if (!has_future) {
[16:09:35.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.922]                               info)
[16:09:35.922]                           }
[16:09:35.922]                           else {
[16:09:35.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.922]                               info, version)
[16:09:35.922]                           }
[16:09:35.922]                           base::stop(msg)
[16:09:35.922]                         }
[16:09:35.922]                       })
[16:09:35.922]                     }
[16:09:35.922]                     base::local({
[16:09:35.922]                       for (pkg in "stats") {
[16:09:35.922]                         base::loadNamespace(pkg)
[16:09:35.922]                         base::library(pkg, character.only = TRUE)
[16:09:35.922]                       }
[16:09:35.922]                     })
[16:09:35.922]                   }
[16:09:35.922]                   options(future.plan = NULL)
[16:09:35.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.922]                 }
[16:09:35.922]                 ...future.workdir <- getwd()
[16:09:35.922]             }
[16:09:35.922]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.922]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.922]         }
[16:09:35.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.922]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:09:35.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.922]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.922]             base::names(...future.oldOptions))
[16:09:35.922]     }
[16:09:35.922]     if (FALSE) {
[16:09:35.922]     }
[16:09:35.922]     else {
[16:09:35.922]         if (TRUE) {
[16:09:35.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.922]                 open = "w")
[16:09:35.922]         }
[16:09:35.922]         else {
[16:09:35.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.922]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.922]         }
[16:09:35.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.922]             base::sink(type = "output", split = FALSE)
[16:09:35.922]             base::close(...future.stdout)
[16:09:35.922]         }, add = TRUE)
[16:09:35.922]     }
[16:09:35.922]     ...future.frame <- base::sys.nframe()
[16:09:35.922]     ...future.conditions <- base::list()
[16:09:35.922]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.922]     if (FALSE) {
[16:09:35.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.922]     }
[16:09:35.922]     ...future.result <- base::tryCatch({
[16:09:35.922]         base::withCallingHandlers({
[16:09:35.922]             ...future.value <- base::withVisible(base::local({
[16:09:35.922]                 do.call(function(...) {
[16:09:35.922]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.922]                   if (!identical(...future.globals.maxSize.org, 
[16:09:35.922]                     ...future.globals.maxSize)) {
[16:09:35.922]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.922]                     on.exit(options(oopts), add = TRUE)
[16:09:35.922]                   }
[16:09:35.922]                   {
[16:09:35.922]                     lapply(seq_along(...future.elements_ii), 
[16:09:35.922]                       FUN = function(jj) {
[16:09:35.922]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.922]                         ...future.FUN(...future.X_jj, ...)
[16:09:35.922]                       })
[16:09:35.922]                   }
[16:09:35.922]                 }, args = future.call.arguments)
[16:09:35.922]             }))
[16:09:35.922]             future::FutureResult(value = ...future.value$value, 
[16:09:35.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.922]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.922]                     ...future.globalenv.names))
[16:09:35.922]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.922]         }, condition = base::local({
[16:09:35.922]             c <- base::c
[16:09:35.922]             inherits <- base::inherits
[16:09:35.922]             invokeRestart <- base::invokeRestart
[16:09:35.922]             length <- base::length
[16:09:35.922]             list <- base::list
[16:09:35.922]             seq.int <- base::seq.int
[16:09:35.922]             signalCondition <- base::signalCondition
[16:09:35.922]             sys.calls <- base::sys.calls
[16:09:35.922]             `[[` <- base::`[[`
[16:09:35.922]             `+` <- base::`+`
[16:09:35.922]             `<<-` <- base::`<<-`
[16:09:35.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.922]                   3L)]
[16:09:35.922]             }
[16:09:35.922]             function(cond) {
[16:09:35.922]                 is_error <- inherits(cond, "error")
[16:09:35.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.922]                   NULL)
[16:09:35.922]                 if (is_error) {
[16:09:35.922]                   sessionInformation <- function() {
[16:09:35.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.922]                       search = base::search(), system = base::Sys.info())
[16:09:35.922]                   }
[16:09:35.922]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.922]                     cond$call), session = sessionInformation(), 
[16:09:35.922]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.922]                   signalCondition(cond)
[16:09:35.922]                 }
[16:09:35.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.922]                 "immediateCondition"))) {
[16:09:35.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.922]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.922]                   if (TRUE && !signal) {
[16:09:35.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.922]                     {
[16:09:35.922]                       inherits <- base::inherits
[16:09:35.922]                       invokeRestart <- base::invokeRestart
[16:09:35.922]                       is.null <- base::is.null
[16:09:35.922]                       muffled <- FALSE
[16:09:35.922]                       if (inherits(cond, "message")) {
[16:09:35.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.922]                         if (muffled) 
[16:09:35.922]                           invokeRestart("muffleMessage")
[16:09:35.922]                       }
[16:09:35.922]                       else if (inherits(cond, "warning")) {
[16:09:35.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.922]                         if (muffled) 
[16:09:35.922]                           invokeRestart("muffleWarning")
[16:09:35.922]                       }
[16:09:35.922]                       else if (inherits(cond, "condition")) {
[16:09:35.922]                         if (!is.null(pattern)) {
[16:09:35.922]                           computeRestarts <- base::computeRestarts
[16:09:35.922]                           grepl <- base::grepl
[16:09:35.922]                           restarts <- computeRestarts(cond)
[16:09:35.922]                           for (restart in restarts) {
[16:09:35.922]                             name <- restart$name
[16:09:35.922]                             if (is.null(name)) 
[16:09:35.922]                               next
[16:09:35.922]                             if (!grepl(pattern, name)) 
[16:09:35.922]                               next
[16:09:35.922]                             invokeRestart(restart)
[16:09:35.922]                             muffled <- TRUE
[16:09:35.922]                             break
[16:09:35.922]                           }
[16:09:35.922]                         }
[16:09:35.922]                       }
[16:09:35.922]                       invisible(muffled)
[16:09:35.922]                     }
[16:09:35.922]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.922]                   }
[16:09:35.922]                 }
[16:09:35.922]                 else {
[16:09:35.922]                   if (TRUE) {
[16:09:35.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.922]                     {
[16:09:35.922]                       inherits <- base::inherits
[16:09:35.922]                       invokeRestart <- base::invokeRestart
[16:09:35.922]                       is.null <- base::is.null
[16:09:35.922]                       muffled <- FALSE
[16:09:35.922]                       if (inherits(cond, "message")) {
[16:09:35.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.922]                         if (muffled) 
[16:09:35.922]                           invokeRestart("muffleMessage")
[16:09:35.922]                       }
[16:09:35.922]                       else if (inherits(cond, "warning")) {
[16:09:35.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.922]                         if (muffled) 
[16:09:35.922]                           invokeRestart("muffleWarning")
[16:09:35.922]                       }
[16:09:35.922]                       else if (inherits(cond, "condition")) {
[16:09:35.922]                         if (!is.null(pattern)) {
[16:09:35.922]                           computeRestarts <- base::computeRestarts
[16:09:35.922]                           grepl <- base::grepl
[16:09:35.922]                           restarts <- computeRestarts(cond)
[16:09:35.922]                           for (restart in restarts) {
[16:09:35.922]                             name <- restart$name
[16:09:35.922]                             if (is.null(name)) 
[16:09:35.922]                               next
[16:09:35.922]                             if (!grepl(pattern, name)) 
[16:09:35.922]                               next
[16:09:35.922]                             invokeRestart(restart)
[16:09:35.922]                             muffled <- TRUE
[16:09:35.922]                             break
[16:09:35.922]                           }
[16:09:35.922]                         }
[16:09:35.922]                       }
[16:09:35.922]                       invisible(muffled)
[16:09:35.922]                     }
[16:09:35.922]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.922]                   }
[16:09:35.922]                 }
[16:09:35.922]             }
[16:09:35.922]         }))
[16:09:35.922]     }, error = function(ex) {
[16:09:35.922]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.922]                 ...future.rng), started = ...future.startTime, 
[16:09:35.922]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.922]             version = "1.8"), class = "FutureResult")
[16:09:35.922]     }, finally = {
[16:09:35.922]         if (!identical(...future.workdir, getwd())) 
[16:09:35.922]             setwd(...future.workdir)
[16:09:35.922]         {
[16:09:35.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.922]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.922]             }
[16:09:35.922]             base::options(...future.oldOptions)
[16:09:35.922]             if (.Platform$OS.type == "windows") {
[16:09:35.922]                 old_names <- names(...future.oldEnvVars)
[16:09:35.922]                 envs <- base::Sys.getenv()
[16:09:35.922]                 names <- names(envs)
[16:09:35.922]                 common <- intersect(names, old_names)
[16:09:35.922]                 added <- setdiff(names, old_names)
[16:09:35.922]                 removed <- setdiff(old_names, names)
[16:09:35.922]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.922]                   envs[common]]
[16:09:35.922]                 NAMES <- toupper(changed)
[16:09:35.922]                 args <- list()
[16:09:35.922]                 for (kk in seq_along(NAMES)) {
[16:09:35.922]                   name <- changed[[kk]]
[16:09:35.922]                   NAME <- NAMES[[kk]]
[16:09:35.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.922]                     next
[16:09:35.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.922]                 }
[16:09:35.922]                 NAMES <- toupper(added)
[16:09:35.922]                 for (kk in seq_along(NAMES)) {
[16:09:35.922]                   name <- added[[kk]]
[16:09:35.922]                   NAME <- NAMES[[kk]]
[16:09:35.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.922]                     next
[16:09:35.922]                   args[[name]] <- ""
[16:09:35.922]                 }
[16:09:35.922]                 NAMES <- toupper(removed)
[16:09:35.922]                 for (kk in seq_along(NAMES)) {
[16:09:35.922]                   name <- removed[[kk]]
[16:09:35.922]                   NAME <- NAMES[[kk]]
[16:09:35.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.922]                     next
[16:09:35.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.922]                 }
[16:09:35.922]                 if (length(args) > 0) 
[16:09:35.922]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.922]             }
[16:09:35.922]             else {
[16:09:35.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.922]             }
[16:09:35.922]             {
[16:09:35.922]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.922]                   0L) {
[16:09:35.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.922]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.922]                   base::options(opts)
[16:09:35.922]                 }
[16:09:35.922]                 {
[16:09:35.922]                   {
[16:09:35.922]                     NULL
[16:09:35.922]                     RNGkind("Mersenne-Twister")
[16:09:35.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:35.922]                       inherits = FALSE)
[16:09:35.922]                   }
[16:09:35.922]                   options(future.plan = NULL)
[16:09:35.922]                   if (is.na(NA_character_)) 
[16:09:35.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.922]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:35.922]                   {
[16:09:35.922]                     future <- SequentialFuture(..., envir = envir)
[16:09:35.922]                     if (!future$lazy) 
[16:09:35.922]                       future <- run(future)
[16:09:35.922]                     invisible(future)
[16:09:35.922]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.922]                 }
[16:09:35.922]             }
[16:09:35.922]         }
[16:09:35.922]     })
[16:09:35.922]     if (TRUE) {
[16:09:35.922]         base::sink(type = "output", split = FALSE)
[16:09:35.922]         if (TRUE) {
[16:09:35.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.922]         }
[16:09:35.922]         else {
[16:09:35.922]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.922]         }
[16:09:35.922]         base::close(...future.stdout)
[16:09:35.922]         ...future.stdout <- NULL
[16:09:35.922]     }
[16:09:35.922]     ...future.result$conditions <- ...future.conditions
[16:09:35.922]     ...future.result$finished <- base::Sys.time()
[16:09:35.922]     ...future.result
[16:09:35.922] }
[16:09:35.924] assign_globals() ...
[16:09:35.924] List of 5
[16:09:35.924]  $ ...future.FUN            :function (x, ...)  
[16:09:35.924]  $ future.call.arguments    : list()
[16:09:35.924]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.924]  $ ...future.elements_ii    :List of 3
[16:09:35.924]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:09:35.924]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:35.924]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:35.924]  $ ...future.seeds_ii       : NULL
[16:09:35.924]  $ ...future.globals.maxSize: NULL
[16:09:35.924]  - attr(*, "resolved")= logi FALSE
[16:09:35.924]  - attr(*, "total_size")= num 1248
[16:09:35.924]  - attr(*, "where")=List of 5
[16:09:35.924]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:35.924]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:35.924]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:35.924]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:35.924]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:35.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.924]  - attr(*, "already-done")= logi TRUE
[16:09:35.931] - copied ‘...future.FUN’ to environment
[16:09:35.931] - copied ‘future.call.arguments’ to environment
[16:09:35.931] - copied ‘...future.elements_ii’ to environment
[16:09:35.931] - copied ‘...future.seeds_ii’ to environment
[16:09:35.931] - copied ‘...future.globals.maxSize’ to environment
[16:09:35.931] assign_globals() ... done
[16:09:35.932] plan(): Setting new future strategy stack:
[16:09:35.932] List of future strategies:
[16:09:35.932] 1. sequential:
[16:09:35.932]    - args: function (..., envir = parent.frame())
[16:09:35.932]    - tweaked: FALSE
[16:09:35.932]    - call: NULL
[16:09:35.932] plan(): nbrOfWorkers() = 1
[16:09:35.933] plan(): Setting new future strategy stack:
[16:09:35.933] List of future strategies:
[16:09:35.933] 1. sequential:
[16:09:35.933]    - args: function (..., envir = parent.frame())
[16:09:35.933]    - tweaked: FALSE
[16:09:35.933]    - call: plan(strategy)
[16:09:35.934] plan(): nbrOfWorkers() = 1
[16:09:35.934] SequentialFuture started (and completed)
[16:09:35.934] - Launch lazy future ... done
[16:09:35.934] run() for ‘SequentialFuture’ ... done
[16:09:35.934] Created future:
[16:09:35.934] SequentialFuture:
[16:09:35.934] Label: ‘future_eapply-1’
[16:09:35.934] Expression:
[16:09:35.934] {
[16:09:35.934]     do.call(function(...) {
[16:09:35.934]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.934]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.934]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.934]             on.exit(options(oopts), add = TRUE)
[16:09:35.934]         }
[16:09:35.934]         {
[16:09:35.934]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.934]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.934]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.934]             })
[16:09:35.934]         }
[16:09:35.934]     }, args = future.call.arguments)
[16:09:35.934] }
[16:09:35.934] Lazy evaluation: FALSE
[16:09:35.934] Asynchronous evaluation: FALSE
[16:09:35.934] Local evaluation: TRUE
[16:09:35.934] Environment: R_GlobalEnv
[16:09:35.934] Capture standard output: TRUE
[16:09:35.934] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.934] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.934] Packages: 1 packages (‘stats’)
[16:09:35.934] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.934] Resolved: TRUE
[16:09:35.934] Value: 1.71 KiB of class ‘list’
[16:09:35.934] Early signaling: FALSE
[16:09:35.934] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:35.934] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:35.935] Chunk #1 of 1 ... DONE
[16:09:35.935] Launching 1 futures (chunks) ... DONE
[16:09:35.935] Resolving 1 futures (chunks) ...
[16:09:35.936] resolve() on list ...
[16:09:35.936]  recursive: 0
[16:09:35.936]  length: 1
[16:09:35.936] 
[16:09:35.936] resolved() for ‘SequentialFuture’ ...
[16:09:35.936] - state: ‘finished’
[16:09:35.936] - run: TRUE
[16:09:35.936] - result: ‘FutureResult’
[16:09:35.936] resolved() for ‘SequentialFuture’ ... done
[16:09:35.936] Future #1
[16:09:35.936] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:35.937] - nx: 1
[16:09:35.937] - relay: TRUE
[16:09:35.937] - stdout: TRUE
[16:09:35.937] - signal: TRUE
[16:09:35.937] - resignal: FALSE
[16:09:35.937] - force: TRUE
[16:09:35.937] - relayed: [n=1] FALSE
[16:09:35.937] - queued futures: [n=1] FALSE
[16:09:35.937]  - until=1
[16:09:35.937]  - relaying element #1
[16:09:35.938] - relayed: [n=1] TRUE
[16:09:35.938] - queued futures: [n=1] TRUE
[16:09:35.938] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:35.938]  length: 0 (resolved future 1)
[16:09:35.938] Relaying remaining futures
[16:09:35.938] signalConditionsASAP(NULL, pos=0) ...
[16:09:35.938] - nx: 1
[16:09:35.938] - relay: TRUE
[16:09:35.938] - stdout: TRUE
[16:09:35.938] - signal: TRUE
[16:09:35.938] - resignal: FALSE
[16:09:35.938] - force: TRUE
[16:09:35.939] - relayed: [n=1] TRUE
[16:09:35.939] - queued futures: [n=1] TRUE
 - flush all
[16:09:35.939] - relayed: [n=1] TRUE
[16:09:35.939] - queued futures: [n=1] TRUE
[16:09:35.939] signalConditionsASAP(NULL, pos=0) ... done
[16:09:35.939] resolve() on list ... DONE
[16:09:35.939]  - Number of value chunks collected: 1
[16:09:35.939] Resolving 1 futures (chunks) ... DONE
[16:09:35.939] Reducing values from 1 chunks ...
[16:09:35.939]  - Number of values collected after concatenation: 3
[16:09:35.939]  - Number of values expected: 3
[16:09:35.940] Reducing values from 1 chunks ... DONE
[16:09:35.940] future_lapply() ... DONE
[16:09:35.940] plan(): Setting new future strategy stack:
[16:09:35.940] List of future strategies:
[16:09:35.940] 1. sequential:
[16:09:35.940]    - args: function (..., envir = parent.frame())
[16:09:35.940]    - tweaked: FALSE
[16:09:35.940]    - call: plan(sequential)
[16:09:35.940] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:09:35.941] plan(): Setting new future strategy stack:
[16:09:35.941] List of future strategies:
[16:09:35.941] 1. multicore:
[16:09:35.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:35.941]    - tweaked: FALSE
[16:09:35.941]    - call: plan(strategy)
[16:09:35.945] plan(): nbrOfWorkers() = 2
[16:09:35.945] future_lapply() ...
[16:09:35.949] Number of chunks: 2
[16:09:35.949] getGlobalsAndPackagesXApply() ...
[16:09:35.949]  - future.globals: TRUE
[16:09:35.949] getGlobalsAndPackages() ...
[16:09:35.950] Searching for globals...
[16:09:35.951] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:35.951] Searching for globals ... DONE
[16:09:35.951] Resolving globals: FALSE
[16:09:35.951] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:35.951] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:35.952] - globals: [1] ‘FUN’
[16:09:35.952] 
[16:09:35.952] getGlobalsAndPackages() ... DONE
[16:09:35.952]  - globals found/used: [n=1] ‘FUN’
[16:09:35.952]  - needed namespaces: [n=0] 
[16:09:35.952] Finding globals ... DONE
[16:09:35.952]  - use_args: TRUE
[16:09:35.952]  - Getting '...' globals ...
[16:09:35.953] resolve() on list ...
[16:09:35.953]  recursive: 0
[16:09:35.953]  length: 1
[16:09:35.953]  elements: ‘...’
[16:09:35.953]  length: 0 (resolved future 1)
[16:09:35.953] resolve() on list ... DONE
[16:09:35.953]    - '...' content: [n=0] 
[16:09:35.953] List of 1
[16:09:35.953]  $ ...: list()
[16:09:35.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.953]  - attr(*, "where")=List of 1
[16:09:35.953]   ..$ ...:<environment: 0x55b4b7eb02b8> 
[16:09:35.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.953]  - attr(*, "resolved")= logi TRUE
[16:09:35.953]  - attr(*, "total_size")= num NA
[16:09:35.956]  - Getting '...' globals ... DONE
[16:09:35.956] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:35.956] List of 2
[16:09:35.956]  $ ...future.FUN:function (x, ...)  
[16:09:35.956]  $ ...          : list()
[16:09:35.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.956]  - attr(*, "where")=List of 2
[16:09:35.956]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:35.956]   ..$ ...          :<environment: 0x55b4b7eb02b8> 
[16:09:35.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.956]  - attr(*, "resolved")= logi FALSE
[16:09:35.956]  - attr(*, "total_size")= num 1240
[16:09:35.960] Packages to be attached in all futures: [n=0] 
[16:09:35.960] getGlobalsAndPackagesXApply() ... DONE
[16:09:35.960] Number of futures (= number of chunks): 2
[16:09:35.960] Launching 2 futures (chunks) ...
[16:09:35.961] Chunk #1 of 2 ...
[16:09:35.961]  - Finding globals in 'X' for chunk #1 ...
[16:09:35.961] getGlobalsAndPackages() ...
[16:09:35.961] Searching for globals...
[16:09:35.961] 
[16:09:35.961] Searching for globals ... DONE
[16:09:35.961] - globals: [0] <none>
[16:09:35.961] getGlobalsAndPackages() ... DONE
[16:09:35.961]    + additional globals found: [n=0] 
[16:09:35.962]    + additional namespaces needed: [n=0] 
[16:09:35.962]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:35.962]  - seeds: <none>
[16:09:35.962] getGlobalsAndPackages() ...
[16:09:35.962] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.962] Resolving globals: FALSE
[16:09:35.962] Tweak future expression to call with '...' arguments ...
[16:09:35.962] {
[16:09:35.962]     do.call(function(...) {
[16:09:35.962]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.962]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.962]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.962]             on.exit(options(oopts), add = TRUE)
[16:09:35.962]         }
[16:09:35.962]         {
[16:09:35.962]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.962]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.962]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.962]             })
[16:09:35.962]         }
[16:09:35.962]     }, args = future.call.arguments)
[16:09:35.962] }
[16:09:35.962] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.963] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.963] 
[16:09:35.963] getGlobalsAndPackages() ... DONE
[16:09:35.963] run() for ‘Future’ ...
[16:09:35.963] - state: ‘created’
[16:09:35.963] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:35.967] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.967] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:35.967]   - Field: ‘label’
[16:09:35.967]   - Field: ‘local’
[16:09:35.967]   - Field: ‘owner’
[16:09:35.967]   - Field: ‘envir’
[16:09:35.968]   - Field: ‘workers’
[16:09:35.968]   - Field: ‘packages’
[16:09:35.968]   - Field: ‘gc’
[16:09:35.968]   - Field: ‘job’
[16:09:35.968]   - Field: ‘conditions’
[16:09:35.968]   - Field: ‘expr’
[16:09:35.968]   - Field: ‘uuid’
[16:09:35.968]   - Field: ‘seed’
[16:09:35.968]   - Field: ‘version’
[16:09:35.968]   - Field: ‘result’
[16:09:35.969]   - Field: ‘asynchronous’
[16:09:35.969]   - Field: ‘calls’
[16:09:35.969]   - Field: ‘globals’
[16:09:35.969]   - Field: ‘stdout’
[16:09:35.969]   - Field: ‘earlySignal’
[16:09:35.969]   - Field: ‘lazy’
[16:09:35.969]   - Field: ‘state’
[16:09:35.969] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:35.969] - Launch lazy future ...
[16:09:35.970] Packages needed by the future expression (n = 0): <none>
[16:09:35.970] Packages needed by future strategies (n = 0): <none>
[16:09:35.971] {
[16:09:35.971]     {
[16:09:35.971]         {
[16:09:35.971]             ...future.startTime <- base::Sys.time()
[16:09:35.971]             {
[16:09:35.971]                 {
[16:09:35.971]                   {
[16:09:35.971]                     {
[16:09:35.971]                       base::local({
[16:09:35.971]                         has_future <- base::requireNamespace("future", 
[16:09:35.971]                           quietly = TRUE)
[16:09:35.971]                         if (has_future) {
[16:09:35.971]                           ns <- base::getNamespace("future")
[16:09:35.971]                           version <- ns[[".package"]][["version"]]
[16:09:35.971]                           if (is.null(version)) 
[16:09:35.971]                             version <- utils::packageVersion("future")
[16:09:35.971]                         }
[16:09:35.971]                         else {
[16:09:35.971]                           version <- NULL
[16:09:35.971]                         }
[16:09:35.971]                         if (!has_future || version < "1.8.0") {
[16:09:35.971]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:35.971]                             "", base::R.version$version.string), 
[16:09:35.971]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:35.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:35.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:35.971]                               "release", "version")], collapse = " "), 
[16:09:35.971]                             hostname = base::Sys.info()[["nodename"]])
[16:09:35.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:35.971]                             info)
[16:09:35.971]                           info <- base::paste(info, collapse = "; ")
[16:09:35.971]                           if (!has_future) {
[16:09:35.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:35.971]                               info)
[16:09:35.971]                           }
[16:09:35.971]                           else {
[16:09:35.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:35.971]                               info, version)
[16:09:35.971]                           }
[16:09:35.971]                           base::stop(msg)
[16:09:35.971]                         }
[16:09:35.971]                       })
[16:09:35.971]                     }
[16:09:35.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:35.971]                     base::options(mc.cores = 1L)
[16:09:35.971]                   }
[16:09:35.971]                   options(future.plan = NULL)
[16:09:35.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:35.971]                 }
[16:09:35.971]                 ...future.workdir <- getwd()
[16:09:35.971]             }
[16:09:35.971]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:35.971]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:35.971]         }
[16:09:35.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:35.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:35.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:35.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:35.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:35.971]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:35.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:35.971]             base::names(...future.oldOptions))
[16:09:35.971]     }
[16:09:35.971]     if (FALSE) {
[16:09:35.971]     }
[16:09:35.971]     else {
[16:09:35.971]         if (TRUE) {
[16:09:35.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:35.971]                 open = "w")
[16:09:35.971]         }
[16:09:35.971]         else {
[16:09:35.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:35.971]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:35.971]         }
[16:09:35.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:35.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:35.971]             base::sink(type = "output", split = FALSE)
[16:09:35.971]             base::close(...future.stdout)
[16:09:35.971]         }, add = TRUE)
[16:09:35.971]     }
[16:09:35.971]     ...future.frame <- base::sys.nframe()
[16:09:35.971]     ...future.conditions <- base::list()
[16:09:35.971]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:35.971]     if (FALSE) {
[16:09:35.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:35.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:35.971]     }
[16:09:35.971]     ...future.result <- base::tryCatch({
[16:09:35.971]         base::withCallingHandlers({
[16:09:35.971]             ...future.value <- base::withVisible(base::local({
[16:09:35.971]                 withCallingHandlers({
[16:09:35.971]                   {
[16:09:35.971]                     do.call(function(...) {
[16:09:35.971]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.971]                       if (!identical(...future.globals.maxSize.org, 
[16:09:35.971]                         ...future.globals.maxSize)) {
[16:09:35.971]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.971]                         on.exit(options(oopts), add = TRUE)
[16:09:35.971]                       }
[16:09:35.971]                       {
[16:09:35.971]                         lapply(seq_along(...future.elements_ii), 
[16:09:35.971]                           FUN = function(jj) {
[16:09:35.971]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.971]                             ...future.FUN(...future.X_jj, ...)
[16:09:35.971]                           })
[16:09:35.971]                       }
[16:09:35.971]                     }, args = future.call.arguments)
[16:09:35.971]                   }
[16:09:35.971]                 }, immediateCondition = function(cond) {
[16:09:35.971]                   save_rds <- function (object, pathname, ...) 
[16:09:35.971]                   {
[16:09:35.971]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:35.971]                     if (file_test("-f", pathname_tmp)) {
[16:09:35.971]                       fi_tmp <- file.info(pathname_tmp)
[16:09:35.971]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:35.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:35.971]                         fi_tmp[["mtime"]])
[16:09:35.971]                     }
[16:09:35.971]                     tryCatch({
[16:09:35.971]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:35.971]                     }, error = function(ex) {
[16:09:35.971]                       msg <- conditionMessage(ex)
[16:09:35.971]                       fi_tmp <- file.info(pathname_tmp)
[16:09:35.971]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:35.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:35.971]                         fi_tmp[["mtime"]], msg)
[16:09:35.971]                       ex$message <- msg
[16:09:35.971]                       stop(ex)
[16:09:35.971]                     })
[16:09:35.971]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:35.971]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:35.971]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:35.971]                       fi_tmp <- file.info(pathname_tmp)
[16:09:35.971]                       fi <- file.info(pathname)
[16:09:35.971]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:35.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:35.971]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:35.971]                         fi[["size"]], fi[["mtime"]])
[16:09:35.971]                       stop(msg)
[16:09:35.971]                     }
[16:09:35.971]                     invisible(pathname)
[16:09:35.971]                   }
[16:09:35.971]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:35.971]                     rootPath = tempdir()) 
[16:09:35.971]                   {
[16:09:35.971]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:35.971]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:35.971]                       tmpdir = path, fileext = ".rds")
[16:09:35.971]                     save_rds(obj, file)
[16:09:35.971]                   }
[16:09:35.971]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:35.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.971]                   {
[16:09:35.971]                     inherits <- base::inherits
[16:09:35.971]                     invokeRestart <- base::invokeRestart
[16:09:35.971]                     is.null <- base::is.null
[16:09:35.971]                     muffled <- FALSE
[16:09:35.971]                     if (inherits(cond, "message")) {
[16:09:35.971]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:35.971]                       if (muffled) 
[16:09:35.971]                         invokeRestart("muffleMessage")
[16:09:35.971]                     }
[16:09:35.971]                     else if (inherits(cond, "warning")) {
[16:09:35.971]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:35.971]                       if (muffled) 
[16:09:35.971]                         invokeRestart("muffleWarning")
[16:09:35.971]                     }
[16:09:35.971]                     else if (inherits(cond, "condition")) {
[16:09:35.971]                       if (!is.null(pattern)) {
[16:09:35.971]                         computeRestarts <- base::computeRestarts
[16:09:35.971]                         grepl <- base::grepl
[16:09:35.971]                         restarts <- computeRestarts(cond)
[16:09:35.971]                         for (restart in restarts) {
[16:09:35.971]                           name <- restart$name
[16:09:35.971]                           if (is.null(name)) 
[16:09:35.971]                             next
[16:09:35.971]                           if (!grepl(pattern, name)) 
[16:09:35.971]                             next
[16:09:35.971]                           invokeRestart(restart)
[16:09:35.971]                           muffled <- TRUE
[16:09:35.971]                           break
[16:09:35.971]                         }
[16:09:35.971]                       }
[16:09:35.971]                     }
[16:09:35.971]                     invisible(muffled)
[16:09:35.971]                   }
[16:09:35.971]                   muffleCondition(cond)
[16:09:35.971]                 })
[16:09:35.971]             }))
[16:09:35.971]             future::FutureResult(value = ...future.value$value, 
[16:09:35.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.971]                   ...future.rng), globalenv = if (FALSE) 
[16:09:35.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:35.971]                     ...future.globalenv.names))
[16:09:35.971]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:35.971]         }, condition = base::local({
[16:09:35.971]             c <- base::c
[16:09:35.971]             inherits <- base::inherits
[16:09:35.971]             invokeRestart <- base::invokeRestart
[16:09:35.971]             length <- base::length
[16:09:35.971]             list <- base::list
[16:09:35.971]             seq.int <- base::seq.int
[16:09:35.971]             signalCondition <- base::signalCondition
[16:09:35.971]             sys.calls <- base::sys.calls
[16:09:35.971]             `[[` <- base::`[[`
[16:09:35.971]             `+` <- base::`+`
[16:09:35.971]             `<<-` <- base::`<<-`
[16:09:35.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:35.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:35.971]                   3L)]
[16:09:35.971]             }
[16:09:35.971]             function(cond) {
[16:09:35.971]                 is_error <- inherits(cond, "error")
[16:09:35.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:35.971]                   NULL)
[16:09:35.971]                 if (is_error) {
[16:09:35.971]                   sessionInformation <- function() {
[16:09:35.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:35.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:35.971]                       search = base::search(), system = base::Sys.info())
[16:09:35.971]                   }
[16:09:35.971]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:35.971]                     cond$call), session = sessionInformation(), 
[16:09:35.971]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:35.971]                   signalCondition(cond)
[16:09:35.971]                 }
[16:09:35.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:35.971]                 "immediateCondition"))) {
[16:09:35.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:35.971]                   ...future.conditions[[length(...future.conditions) + 
[16:09:35.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:35.971]                   if (TRUE && !signal) {
[16:09:35.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.971]                     {
[16:09:35.971]                       inherits <- base::inherits
[16:09:35.971]                       invokeRestart <- base::invokeRestart
[16:09:35.971]                       is.null <- base::is.null
[16:09:35.971]                       muffled <- FALSE
[16:09:35.971]                       if (inherits(cond, "message")) {
[16:09:35.971]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.971]                         if (muffled) 
[16:09:35.971]                           invokeRestart("muffleMessage")
[16:09:35.971]                       }
[16:09:35.971]                       else if (inherits(cond, "warning")) {
[16:09:35.971]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.971]                         if (muffled) 
[16:09:35.971]                           invokeRestart("muffleWarning")
[16:09:35.971]                       }
[16:09:35.971]                       else if (inherits(cond, "condition")) {
[16:09:35.971]                         if (!is.null(pattern)) {
[16:09:35.971]                           computeRestarts <- base::computeRestarts
[16:09:35.971]                           grepl <- base::grepl
[16:09:35.971]                           restarts <- computeRestarts(cond)
[16:09:35.971]                           for (restart in restarts) {
[16:09:35.971]                             name <- restart$name
[16:09:35.971]                             if (is.null(name)) 
[16:09:35.971]                               next
[16:09:35.971]                             if (!grepl(pattern, name)) 
[16:09:35.971]                               next
[16:09:35.971]                             invokeRestart(restart)
[16:09:35.971]                             muffled <- TRUE
[16:09:35.971]                             break
[16:09:35.971]                           }
[16:09:35.971]                         }
[16:09:35.971]                       }
[16:09:35.971]                       invisible(muffled)
[16:09:35.971]                     }
[16:09:35.971]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.971]                   }
[16:09:35.971]                 }
[16:09:35.971]                 else {
[16:09:35.971]                   if (TRUE) {
[16:09:35.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:35.971]                     {
[16:09:35.971]                       inherits <- base::inherits
[16:09:35.971]                       invokeRestart <- base::invokeRestart
[16:09:35.971]                       is.null <- base::is.null
[16:09:35.971]                       muffled <- FALSE
[16:09:35.971]                       if (inherits(cond, "message")) {
[16:09:35.971]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:35.971]                         if (muffled) 
[16:09:35.971]                           invokeRestart("muffleMessage")
[16:09:35.971]                       }
[16:09:35.971]                       else if (inherits(cond, "warning")) {
[16:09:35.971]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:35.971]                         if (muffled) 
[16:09:35.971]                           invokeRestart("muffleWarning")
[16:09:35.971]                       }
[16:09:35.971]                       else if (inherits(cond, "condition")) {
[16:09:35.971]                         if (!is.null(pattern)) {
[16:09:35.971]                           computeRestarts <- base::computeRestarts
[16:09:35.971]                           grepl <- base::grepl
[16:09:35.971]                           restarts <- computeRestarts(cond)
[16:09:35.971]                           for (restart in restarts) {
[16:09:35.971]                             name <- restart$name
[16:09:35.971]                             if (is.null(name)) 
[16:09:35.971]                               next
[16:09:35.971]                             if (!grepl(pattern, name)) 
[16:09:35.971]                               next
[16:09:35.971]                             invokeRestart(restart)
[16:09:35.971]                             muffled <- TRUE
[16:09:35.971]                             break
[16:09:35.971]                           }
[16:09:35.971]                         }
[16:09:35.971]                       }
[16:09:35.971]                       invisible(muffled)
[16:09:35.971]                     }
[16:09:35.971]                     muffleCondition(cond, pattern = "^muffle")
[16:09:35.971]                   }
[16:09:35.971]                 }
[16:09:35.971]             }
[16:09:35.971]         }))
[16:09:35.971]     }, error = function(ex) {
[16:09:35.971]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:35.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:35.971]                 ...future.rng), started = ...future.startTime, 
[16:09:35.971]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:35.971]             version = "1.8"), class = "FutureResult")
[16:09:35.971]     }, finally = {
[16:09:35.971]         if (!identical(...future.workdir, getwd())) 
[16:09:35.971]             setwd(...future.workdir)
[16:09:35.971]         {
[16:09:35.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:35.971]                 ...future.oldOptions$nwarnings <- NULL
[16:09:35.971]             }
[16:09:35.971]             base::options(...future.oldOptions)
[16:09:35.971]             if (.Platform$OS.type == "windows") {
[16:09:35.971]                 old_names <- names(...future.oldEnvVars)
[16:09:35.971]                 envs <- base::Sys.getenv()
[16:09:35.971]                 names <- names(envs)
[16:09:35.971]                 common <- intersect(names, old_names)
[16:09:35.971]                 added <- setdiff(names, old_names)
[16:09:35.971]                 removed <- setdiff(old_names, names)
[16:09:35.971]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:35.971]                   envs[common]]
[16:09:35.971]                 NAMES <- toupper(changed)
[16:09:35.971]                 args <- list()
[16:09:35.971]                 for (kk in seq_along(NAMES)) {
[16:09:35.971]                   name <- changed[[kk]]
[16:09:35.971]                   NAME <- NAMES[[kk]]
[16:09:35.971]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.971]                     next
[16:09:35.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.971]                 }
[16:09:35.971]                 NAMES <- toupper(added)
[16:09:35.971]                 for (kk in seq_along(NAMES)) {
[16:09:35.971]                   name <- added[[kk]]
[16:09:35.971]                   NAME <- NAMES[[kk]]
[16:09:35.971]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.971]                     next
[16:09:35.971]                   args[[name]] <- ""
[16:09:35.971]                 }
[16:09:35.971]                 NAMES <- toupper(removed)
[16:09:35.971]                 for (kk in seq_along(NAMES)) {
[16:09:35.971]                   name <- removed[[kk]]
[16:09:35.971]                   NAME <- NAMES[[kk]]
[16:09:35.971]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:35.971]                     next
[16:09:35.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:35.971]                 }
[16:09:35.971]                 if (length(args) > 0) 
[16:09:35.971]                   base::do.call(base::Sys.setenv, args = args)
[16:09:35.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:35.971]             }
[16:09:35.971]             else {
[16:09:35.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:35.971]             }
[16:09:35.971]             {
[16:09:35.971]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:35.971]                   0L) {
[16:09:35.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:35.971]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:35.971]                   base::options(opts)
[16:09:35.971]                 }
[16:09:35.971]                 {
[16:09:35.971]                   {
[16:09:35.971]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:35.971]                     NULL
[16:09:35.971]                   }
[16:09:35.971]                   options(future.plan = NULL)
[16:09:35.971]                   if (is.na(NA_character_)) 
[16:09:35.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:35.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:35.971]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:35.971]                     envir = parent.frame()) 
[16:09:35.971]                   {
[16:09:35.971]                     default_workers <- missing(workers)
[16:09:35.971]                     if (is.function(workers)) 
[16:09:35.971]                       workers <- workers()
[16:09:35.971]                     workers <- structure(as.integer(workers), 
[16:09:35.971]                       class = class(workers))
[16:09:35.971]                     stop_if_not(is.finite(workers), workers >= 
[16:09:35.971]                       1L)
[16:09:35.971]                     if ((workers == 1L && !inherits(workers, 
[16:09:35.971]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:35.971]                       if (default_workers) 
[16:09:35.971]                         supportsMulticore(warn = TRUE)
[16:09:35.971]                       return(sequential(..., envir = envir))
[16:09:35.971]                     }
[16:09:35.971]                     oopts <- options(mc.cores = workers)
[16:09:35.971]                     on.exit(options(oopts))
[16:09:35.971]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:35.971]                       envir = envir)
[16:09:35.971]                     if (!future$lazy) 
[16:09:35.971]                       future <- run(future)
[16:09:35.971]                     invisible(future)
[16:09:35.971]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:35.971]                 }
[16:09:35.971]             }
[16:09:35.971]         }
[16:09:35.971]     })
[16:09:35.971]     if (TRUE) {
[16:09:35.971]         base::sink(type = "output", split = FALSE)
[16:09:35.971]         if (TRUE) {
[16:09:35.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:35.971]         }
[16:09:35.971]         else {
[16:09:35.971]             ...future.result["stdout"] <- base::list(NULL)
[16:09:35.971]         }
[16:09:35.971]         base::close(...future.stdout)
[16:09:35.971]         ...future.stdout <- NULL
[16:09:35.971]     }
[16:09:35.971]     ...future.result$conditions <- ...future.conditions
[16:09:35.971]     ...future.result$finished <- base::Sys.time()
[16:09:35.971]     ...future.result
[16:09:35.971] }
[16:09:35.973] assign_globals() ...
[16:09:35.973] List of 5
[16:09:35.973]  $ ...future.FUN            :function (x, ...)  
[16:09:35.973]  $ future.call.arguments    : list()
[16:09:35.973]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:35.973]  $ ...future.elements_ii    :List of 1
[16:09:35.973]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:09:35.973]  $ ...future.seeds_ii       : NULL
[16:09:35.973]  $ ...future.globals.maxSize: NULL
[16:09:35.973]  - attr(*, "where")=List of 5
[16:09:35.973]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:35.973]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:35.973]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:35.973]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:35.973]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:35.973]  - attr(*, "resolved")= logi FALSE
[16:09:35.973]  - attr(*, "total_size")= num 1240
[16:09:35.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:35.973]  - attr(*, "already-done")= logi TRUE
[16:09:35.978] - copied ‘...future.FUN’ to environment
[16:09:35.978] - copied ‘future.call.arguments’ to environment
[16:09:35.978] - copied ‘...future.elements_ii’ to environment
[16:09:35.978] - copied ‘...future.seeds_ii’ to environment
[16:09:35.978] - copied ‘...future.globals.maxSize’ to environment
[16:09:35.978] assign_globals() ... done
[16:09:35.979] requestCore(): workers = 2
[16:09:35.982] MulticoreFuture started
[16:09:35.982] - Launch lazy future ... done
[16:09:35.982] plan(): Setting new future strategy stack:
[16:09:35.982] run() for ‘MulticoreFuture’ ... done
[16:09:35.983] Created future:
[16:09:35.983] List of future strategies:
[16:09:35.983] 1. sequential:
[16:09:35.983]    - args: function (..., envir = parent.frame())
[16:09:35.983]    - tweaked: FALSE
[16:09:35.983]    - call: NULL
[16:09:35.983] plan(): nbrOfWorkers() = 1
[16:09:35.985] plan(): Setting new future strategy stack:
[16:09:35.985] List of future strategies:
[16:09:35.985] 1. multicore:
[16:09:35.985]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:35.985]    - tweaked: FALSE
[16:09:35.985]    - call: plan(strategy)
[16:09:35.990] plan(): nbrOfWorkers() = 2
[16:09:35.983] MulticoreFuture:
[16:09:35.983] Label: ‘future_eapply-1’
[16:09:35.983] Expression:
[16:09:35.983] {
[16:09:35.983]     do.call(function(...) {
[16:09:35.983]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.983]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.983]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.983]             on.exit(options(oopts), add = TRUE)
[16:09:35.983]         }
[16:09:35.983]         {
[16:09:35.983]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.983]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.983]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.983]             })
[16:09:35.983]         }
[16:09:35.983]     }, args = future.call.arguments)
[16:09:35.983] }
[16:09:35.983] Lazy evaluation: FALSE
[16:09:35.983] Asynchronous evaluation: TRUE
[16:09:35.983] Local evaluation: TRUE
[16:09:35.983] Environment: R_GlobalEnv
[16:09:35.983] Capture standard output: TRUE
[16:09:35.983] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:35.983] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:35.983] Packages: <none>
[16:09:35.983] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:35.983] Resolved: TRUE
[16:09:35.983] Value: <not collected>
[16:09:35.983] Conditions captured: <none>
[16:09:35.983] Early signaling: FALSE
[16:09:35.983] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:35.983] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:35.991] Chunk #1 of 2 ... DONE
[16:09:35.992] Chunk #2 of 2 ...
[16:09:35.992]  - Finding globals in 'X' for chunk #2 ...
[16:09:35.992] getGlobalsAndPackages() ...
[16:09:35.992] Searching for globals...
[16:09:35.993] 
[16:09:35.993] Searching for globals ... DONE
[16:09:35.993] - globals: [0] <none>
[16:09:35.993] getGlobalsAndPackages() ... DONE
[16:09:35.993]    + additional globals found: [n=0] 
[16:09:35.993]    + additional namespaces needed: [n=0] 
[16:09:35.993]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:35.993]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:35.994]  - seeds: <none>
[16:09:35.994] getGlobalsAndPackages() ...
[16:09:35.994] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.994] Resolving globals: FALSE
[16:09:35.994] Tweak future expression to call with '...' arguments ...
[16:09:35.994] {
[16:09:35.994]     do.call(function(...) {
[16:09:35.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:35.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:35.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:35.994]             on.exit(options(oopts), add = TRUE)
[16:09:35.994]         }
[16:09:35.994]         {
[16:09:35.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:35.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:35.994]                 ...future.FUN(...future.X_jj, ...)
[16:09:35.994]             })
[16:09:35.994]         }
[16:09:35.994]     }, args = future.call.arguments)
[16:09:35.994] }
[16:09:35.995] Tweak future expression to call with '...' arguments ... DONE
[16:09:35.995] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:35.996] 
[16:09:35.996] getGlobalsAndPackages() ... DONE
[16:09:35.996] run() for ‘Future’ ...
[16:09:36.000] - state: ‘created’
[16:09:36.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.006] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.006]   - Field: ‘label’
[16:09:36.006]   - Field: ‘local’
[16:09:36.006]   - Field: ‘owner’
[16:09:36.007]   - Field: ‘envir’
[16:09:36.007]   - Field: ‘workers’
[16:09:36.007]   - Field: ‘packages’
[16:09:36.007]   - Field: ‘gc’
[16:09:36.007]   - Field: ‘job’
[16:09:36.008]   - Field: ‘conditions’
[16:09:36.008]   - Field: ‘expr’
[16:09:36.008]   - Field: ‘uuid’
[16:09:36.008]   - Field: ‘seed’
[16:09:36.008]   - Field: ‘version’
[16:09:36.009]   - Field: ‘result’
[16:09:36.009]   - Field: ‘asynchronous’
[16:09:36.009]   - Field: ‘calls’
[16:09:36.009]   - Field: ‘globals’
[16:09:36.009]   - Field: ‘stdout’
[16:09:36.009]   - Field: ‘earlySignal’
[16:09:36.009]   - Field: ‘lazy’
[16:09:36.010]   - Field: ‘state’
[16:09:36.010] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.010] - Launch lazy future ...
[16:09:36.010] Packages needed by the future expression (n = 0): <none>
[16:09:36.011] Packages needed by future strategies (n = 0): <none>
[16:09:36.011] {
[16:09:36.011]     {
[16:09:36.011]         {
[16:09:36.011]             ...future.startTime <- base::Sys.time()
[16:09:36.011]             {
[16:09:36.011]                 {
[16:09:36.011]                   {
[16:09:36.011]                     {
[16:09:36.011]                       base::local({
[16:09:36.011]                         has_future <- base::requireNamespace("future", 
[16:09:36.011]                           quietly = TRUE)
[16:09:36.011]                         if (has_future) {
[16:09:36.011]                           ns <- base::getNamespace("future")
[16:09:36.011]                           version <- ns[[".package"]][["version"]]
[16:09:36.011]                           if (is.null(version)) 
[16:09:36.011]                             version <- utils::packageVersion("future")
[16:09:36.011]                         }
[16:09:36.011]                         else {
[16:09:36.011]                           version <- NULL
[16:09:36.011]                         }
[16:09:36.011]                         if (!has_future || version < "1.8.0") {
[16:09:36.011]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.011]                             "", base::R.version$version.string), 
[16:09:36.011]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:36.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:36.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.011]                               "release", "version")], collapse = " "), 
[16:09:36.011]                             hostname = base::Sys.info()[["nodename"]])
[16:09:36.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.011]                             info)
[16:09:36.011]                           info <- base::paste(info, collapse = "; ")
[16:09:36.011]                           if (!has_future) {
[16:09:36.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.011]                               info)
[16:09:36.011]                           }
[16:09:36.011]                           else {
[16:09:36.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.011]                               info, version)
[16:09:36.011]                           }
[16:09:36.011]                           base::stop(msg)
[16:09:36.011]                         }
[16:09:36.011]                       })
[16:09:36.011]                     }
[16:09:36.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.011]                     base::options(mc.cores = 1L)
[16:09:36.011]                   }
[16:09:36.011]                   options(future.plan = NULL)
[16:09:36.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.011]                 }
[16:09:36.011]                 ...future.workdir <- getwd()
[16:09:36.011]             }
[16:09:36.011]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.011]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.011]         }
[16:09:36.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.011]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:36.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.011]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.011]             base::names(...future.oldOptions))
[16:09:36.011]     }
[16:09:36.011]     if (FALSE) {
[16:09:36.011]     }
[16:09:36.011]     else {
[16:09:36.011]         if (TRUE) {
[16:09:36.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.011]                 open = "w")
[16:09:36.011]         }
[16:09:36.011]         else {
[16:09:36.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.011]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.011]         }
[16:09:36.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.011]             base::sink(type = "output", split = FALSE)
[16:09:36.011]             base::close(...future.stdout)
[16:09:36.011]         }, add = TRUE)
[16:09:36.011]     }
[16:09:36.011]     ...future.frame <- base::sys.nframe()
[16:09:36.011]     ...future.conditions <- base::list()
[16:09:36.011]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.011]     if (FALSE) {
[16:09:36.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.011]     }
[16:09:36.011]     ...future.result <- base::tryCatch({
[16:09:36.011]         base::withCallingHandlers({
[16:09:36.011]             ...future.value <- base::withVisible(base::local({
[16:09:36.011]                 withCallingHandlers({
[16:09:36.011]                   {
[16:09:36.011]                     do.call(function(...) {
[16:09:36.011]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.011]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.011]                         ...future.globals.maxSize)) {
[16:09:36.011]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.011]                         on.exit(options(oopts), add = TRUE)
[16:09:36.011]                       }
[16:09:36.011]                       {
[16:09:36.011]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.011]                           FUN = function(jj) {
[16:09:36.011]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.011]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.011]                           })
[16:09:36.011]                       }
[16:09:36.011]                     }, args = future.call.arguments)
[16:09:36.011]                   }
[16:09:36.011]                 }, immediateCondition = function(cond) {
[16:09:36.011]                   save_rds <- function (object, pathname, ...) 
[16:09:36.011]                   {
[16:09:36.011]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.011]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.011]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.011]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.011]                         fi_tmp[["mtime"]])
[16:09:36.011]                     }
[16:09:36.011]                     tryCatch({
[16:09:36.011]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.011]                     }, error = function(ex) {
[16:09:36.011]                       msg <- conditionMessage(ex)
[16:09:36.011]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.011]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.011]                         fi_tmp[["mtime"]], msg)
[16:09:36.011]                       ex$message <- msg
[16:09:36.011]                       stop(ex)
[16:09:36.011]                     })
[16:09:36.011]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.011]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.011]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.011]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.011]                       fi <- file.info(pathname)
[16:09:36.011]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.011]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.011]                         fi[["size"]], fi[["mtime"]])
[16:09:36.011]                       stop(msg)
[16:09:36.011]                     }
[16:09:36.011]                     invisible(pathname)
[16:09:36.011]                   }
[16:09:36.011]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.011]                     rootPath = tempdir()) 
[16:09:36.011]                   {
[16:09:36.011]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.011]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.011]                       tmpdir = path, fileext = ".rds")
[16:09:36.011]                     save_rds(obj, file)
[16:09:36.011]                   }
[16:09:36.011]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.011]                   {
[16:09:36.011]                     inherits <- base::inherits
[16:09:36.011]                     invokeRestart <- base::invokeRestart
[16:09:36.011]                     is.null <- base::is.null
[16:09:36.011]                     muffled <- FALSE
[16:09:36.011]                     if (inherits(cond, "message")) {
[16:09:36.011]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.011]                       if (muffled) 
[16:09:36.011]                         invokeRestart("muffleMessage")
[16:09:36.011]                     }
[16:09:36.011]                     else if (inherits(cond, "warning")) {
[16:09:36.011]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.011]                       if (muffled) 
[16:09:36.011]                         invokeRestart("muffleWarning")
[16:09:36.011]                     }
[16:09:36.011]                     else if (inherits(cond, "condition")) {
[16:09:36.011]                       if (!is.null(pattern)) {
[16:09:36.011]                         computeRestarts <- base::computeRestarts
[16:09:36.011]                         grepl <- base::grepl
[16:09:36.011]                         restarts <- computeRestarts(cond)
[16:09:36.011]                         for (restart in restarts) {
[16:09:36.011]                           name <- restart$name
[16:09:36.011]                           if (is.null(name)) 
[16:09:36.011]                             next
[16:09:36.011]                           if (!grepl(pattern, name)) 
[16:09:36.011]                             next
[16:09:36.011]                           invokeRestart(restart)
[16:09:36.011]                           muffled <- TRUE
[16:09:36.011]                           break
[16:09:36.011]                         }
[16:09:36.011]                       }
[16:09:36.011]                     }
[16:09:36.011]                     invisible(muffled)
[16:09:36.011]                   }
[16:09:36.011]                   muffleCondition(cond)
[16:09:36.011]                 })
[16:09:36.011]             }))
[16:09:36.011]             future::FutureResult(value = ...future.value$value, 
[16:09:36.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.011]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.011]                     ...future.globalenv.names))
[16:09:36.011]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.011]         }, condition = base::local({
[16:09:36.011]             c <- base::c
[16:09:36.011]             inherits <- base::inherits
[16:09:36.011]             invokeRestart <- base::invokeRestart
[16:09:36.011]             length <- base::length
[16:09:36.011]             list <- base::list
[16:09:36.011]             seq.int <- base::seq.int
[16:09:36.011]             signalCondition <- base::signalCondition
[16:09:36.011]             sys.calls <- base::sys.calls
[16:09:36.011]             `[[` <- base::`[[`
[16:09:36.011]             `+` <- base::`+`
[16:09:36.011]             `<<-` <- base::`<<-`
[16:09:36.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.011]                   3L)]
[16:09:36.011]             }
[16:09:36.011]             function(cond) {
[16:09:36.011]                 is_error <- inherits(cond, "error")
[16:09:36.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.011]                   NULL)
[16:09:36.011]                 if (is_error) {
[16:09:36.011]                   sessionInformation <- function() {
[16:09:36.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.011]                       search = base::search(), system = base::Sys.info())
[16:09:36.011]                   }
[16:09:36.011]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.011]                     cond$call), session = sessionInformation(), 
[16:09:36.011]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.011]                   signalCondition(cond)
[16:09:36.011]                 }
[16:09:36.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.011]                 "immediateCondition"))) {
[16:09:36.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.011]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.011]                   if (TRUE && !signal) {
[16:09:36.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.011]                     {
[16:09:36.011]                       inherits <- base::inherits
[16:09:36.011]                       invokeRestart <- base::invokeRestart
[16:09:36.011]                       is.null <- base::is.null
[16:09:36.011]                       muffled <- FALSE
[16:09:36.011]                       if (inherits(cond, "message")) {
[16:09:36.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.011]                         if (muffled) 
[16:09:36.011]                           invokeRestart("muffleMessage")
[16:09:36.011]                       }
[16:09:36.011]                       else if (inherits(cond, "warning")) {
[16:09:36.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.011]                         if (muffled) 
[16:09:36.011]                           invokeRestart("muffleWarning")
[16:09:36.011]                       }
[16:09:36.011]                       else if (inherits(cond, "condition")) {
[16:09:36.011]                         if (!is.null(pattern)) {
[16:09:36.011]                           computeRestarts <- base::computeRestarts
[16:09:36.011]                           grepl <- base::grepl
[16:09:36.011]                           restarts <- computeRestarts(cond)
[16:09:36.011]                           for (restart in restarts) {
[16:09:36.011]                             name <- restart$name
[16:09:36.011]                             if (is.null(name)) 
[16:09:36.011]                               next
[16:09:36.011]                             if (!grepl(pattern, name)) 
[16:09:36.011]                               next
[16:09:36.011]                             invokeRestart(restart)
[16:09:36.011]                             muffled <- TRUE
[16:09:36.011]                             break
[16:09:36.011]                           }
[16:09:36.011]                         }
[16:09:36.011]                       }
[16:09:36.011]                       invisible(muffled)
[16:09:36.011]                     }
[16:09:36.011]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.011]                   }
[16:09:36.011]                 }
[16:09:36.011]                 else {
[16:09:36.011]                   if (TRUE) {
[16:09:36.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.011]                     {
[16:09:36.011]                       inherits <- base::inherits
[16:09:36.011]                       invokeRestart <- base::invokeRestart
[16:09:36.011]                       is.null <- base::is.null
[16:09:36.011]                       muffled <- FALSE
[16:09:36.011]                       if (inherits(cond, "message")) {
[16:09:36.011]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.011]                         if (muffled) 
[16:09:36.011]                           invokeRestart("muffleMessage")
[16:09:36.011]                       }
[16:09:36.011]                       else if (inherits(cond, "warning")) {
[16:09:36.011]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.011]                         if (muffled) 
[16:09:36.011]                           invokeRestart("muffleWarning")
[16:09:36.011]                       }
[16:09:36.011]                       else if (inherits(cond, "condition")) {
[16:09:36.011]                         if (!is.null(pattern)) {
[16:09:36.011]                           computeRestarts <- base::computeRestarts
[16:09:36.011]                           grepl <- base::grepl
[16:09:36.011]                           restarts <- computeRestarts(cond)
[16:09:36.011]                           for (restart in restarts) {
[16:09:36.011]                             name <- restart$name
[16:09:36.011]                             if (is.null(name)) 
[16:09:36.011]                               next
[16:09:36.011]                             if (!grepl(pattern, name)) 
[16:09:36.011]                               next
[16:09:36.011]                             invokeRestart(restart)
[16:09:36.011]                             muffled <- TRUE
[16:09:36.011]                             break
[16:09:36.011]                           }
[16:09:36.011]                         }
[16:09:36.011]                       }
[16:09:36.011]                       invisible(muffled)
[16:09:36.011]                     }
[16:09:36.011]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.011]                   }
[16:09:36.011]                 }
[16:09:36.011]             }
[16:09:36.011]         }))
[16:09:36.011]     }, error = function(ex) {
[16:09:36.011]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.011]                 ...future.rng), started = ...future.startTime, 
[16:09:36.011]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.011]             version = "1.8"), class = "FutureResult")
[16:09:36.011]     }, finally = {
[16:09:36.011]         if (!identical(...future.workdir, getwd())) 
[16:09:36.011]             setwd(...future.workdir)
[16:09:36.011]         {
[16:09:36.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.011]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.011]             }
[16:09:36.011]             base::options(...future.oldOptions)
[16:09:36.011]             if (.Platform$OS.type == "windows") {
[16:09:36.011]                 old_names <- names(...future.oldEnvVars)
[16:09:36.011]                 envs <- base::Sys.getenv()
[16:09:36.011]                 names <- names(envs)
[16:09:36.011]                 common <- intersect(names, old_names)
[16:09:36.011]                 added <- setdiff(names, old_names)
[16:09:36.011]                 removed <- setdiff(old_names, names)
[16:09:36.011]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.011]                   envs[common]]
[16:09:36.011]                 NAMES <- toupper(changed)
[16:09:36.011]                 args <- list()
[16:09:36.011]                 for (kk in seq_along(NAMES)) {
[16:09:36.011]                   name <- changed[[kk]]
[16:09:36.011]                   NAME <- NAMES[[kk]]
[16:09:36.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.011]                     next
[16:09:36.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.011]                 }
[16:09:36.011]                 NAMES <- toupper(added)
[16:09:36.011]                 for (kk in seq_along(NAMES)) {
[16:09:36.011]                   name <- added[[kk]]
[16:09:36.011]                   NAME <- NAMES[[kk]]
[16:09:36.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.011]                     next
[16:09:36.011]                   args[[name]] <- ""
[16:09:36.011]                 }
[16:09:36.011]                 NAMES <- toupper(removed)
[16:09:36.011]                 for (kk in seq_along(NAMES)) {
[16:09:36.011]                   name <- removed[[kk]]
[16:09:36.011]                   NAME <- NAMES[[kk]]
[16:09:36.011]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.011]                     next
[16:09:36.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.011]                 }
[16:09:36.011]                 if (length(args) > 0) 
[16:09:36.011]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.011]             }
[16:09:36.011]             else {
[16:09:36.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.011]             }
[16:09:36.011]             {
[16:09:36.011]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.011]                   0L) {
[16:09:36.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.011]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.011]                   base::options(opts)
[16:09:36.011]                 }
[16:09:36.011]                 {
[16:09:36.011]                   {
[16:09:36.011]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.011]                     NULL
[16:09:36.011]                   }
[16:09:36.011]                   options(future.plan = NULL)
[16:09:36.011]                   if (is.na(NA_character_)) 
[16:09:36.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.011]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.011]                     envir = parent.frame()) 
[16:09:36.011]                   {
[16:09:36.011]                     default_workers <- missing(workers)
[16:09:36.011]                     if (is.function(workers)) 
[16:09:36.011]                       workers <- workers()
[16:09:36.011]                     workers <- structure(as.integer(workers), 
[16:09:36.011]                       class = class(workers))
[16:09:36.011]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.011]                       1L)
[16:09:36.011]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.011]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.011]                       if (default_workers) 
[16:09:36.011]                         supportsMulticore(warn = TRUE)
[16:09:36.011]                       return(sequential(..., envir = envir))
[16:09:36.011]                     }
[16:09:36.011]                     oopts <- options(mc.cores = workers)
[16:09:36.011]                     on.exit(options(oopts))
[16:09:36.011]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.011]                       envir = envir)
[16:09:36.011]                     if (!future$lazy) 
[16:09:36.011]                       future <- run(future)
[16:09:36.011]                     invisible(future)
[16:09:36.011]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.011]                 }
[16:09:36.011]             }
[16:09:36.011]         }
[16:09:36.011]     })
[16:09:36.011]     if (TRUE) {
[16:09:36.011]         base::sink(type = "output", split = FALSE)
[16:09:36.011]         if (TRUE) {
[16:09:36.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.011]         }
[16:09:36.011]         else {
[16:09:36.011]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.011]         }
[16:09:36.011]         base::close(...future.stdout)
[16:09:36.011]         ...future.stdout <- NULL
[16:09:36.011]     }
[16:09:36.011]     ...future.result$conditions <- ...future.conditions
[16:09:36.011]     ...future.result$finished <- base::Sys.time()
[16:09:36.011]     ...future.result
[16:09:36.011] }
[16:09:36.014] assign_globals() ...
[16:09:36.014] List of 5
[16:09:36.014]  $ ...future.FUN            :function (x, ...)  
[16:09:36.014]  $ future.call.arguments    : list()
[16:09:36.014]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.014]  $ ...future.elements_ii    :List of 2
[16:09:36.014]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:36.014]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:36.014]  $ ...future.seeds_ii       : NULL
[16:09:36.014]  $ ...future.globals.maxSize: NULL
[16:09:36.014]  - attr(*, "resolved")= logi FALSE
[16:09:36.014]  - attr(*, "total_size")= num 1240
[16:09:36.014]  - attr(*, "where")=List of 5
[16:09:36.014]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.014]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.014]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.014]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.014]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.014]  - attr(*, "already-done")= logi TRUE
[16:09:36.022] - copied ‘...future.FUN’ to environment
[16:09:36.022] - copied ‘future.call.arguments’ to environment
[16:09:36.022] - copied ‘...future.elements_ii’ to environment
[16:09:36.022] - copied ‘...future.seeds_ii’ to environment
[16:09:36.022] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.022] assign_globals() ... done
[16:09:36.022] requestCore(): workers = 2
[16:09:36.028] MulticoreFuture started
[16:09:36.028] - Launch lazy future ... done
[16:09:36.028] run() for ‘MulticoreFuture’ ... done
[16:09:36.029] Created future:
[16:09:36.029] plan(): Setting new future strategy stack:
[16:09:36.029] List of future strategies:
[16:09:36.029] 1. sequential:
[16:09:36.029]    - args: function (..., envir = parent.frame())
[16:09:36.029]    - tweaked: FALSE
[16:09:36.029]    - call: NULL
[16:09:36.030] plan(): nbrOfWorkers() = 1
[16:09:36.032] plan(): Setting new future strategy stack:
[16:09:36.032] List of future strategies:
[16:09:36.032] 1. multicore:
[16:09:36.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.032]    - tweaked: FALSE
[16:09:36.032]    - call: plan(strategy)
[16:09:36.037] plan(): nbrOfWorkers() = 2
[16:09:36.029] MulticoreFuture:
[16:09:36.029] Label: ‘future_eapply-2’
[16:09:36.029] Expression:
[16:09:36.029] {
[16:09:36.029]     do.call(function(...) {
[16:09:36.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.029]             on.exit(options(oopts), add = TRUE)
[16:09:36.029]         }
[16:09:36.029]         {
[16:09:36.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.029]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.029]             })
[16:09:36.029]         }
[16:09:36.029]     }, args = future.call.arguments)
[16:09:36.029] }
[16:09:36.029] Lazy evaluation: FALSE
[16:09:36.029] Asynchronous evaluation: TRUE
[16:09:36.029] Local evaluation: TRUE
[16:09:36.029] Environment: R_GlobalEnv
[16:09:36.029] Capture standard output: TRUE
[16:09:36.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.029] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.029] Packages: <none>
[16:09:36.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.029] Resolved: TRUE
[16:09:36.029] Value: <not collected>
[16:09:36.029] Conditions captured: <none>
[16:09:36.029] Early signaling: FALSE
[16:09:36.029] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.029] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.039] Chunk #2 of 2 ... DONE
[16:09:36.039] Launching 2 futures (chunks) ... DONE
[16:09:36.039] Resolving 2 futures (chunks) ...
[16:09:36.039] resolve() on list ...
[16:09:36.039]  recursive: 0
[16:09:36.039]  length: 2
[16:09:36.039] 
[16:09:36.040] Future #1
[16:09:36.042] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:36.042] - nx: 2
[16:09:36.042] - relay: TRUE
[16:09:36.042] - stdout: TRUE
[16:09:36.043] - signal: TRUE
[16:09:36.043] - resignal: FALSE
[16:09:36.043] - force: TRUE
[16:09:36.043] - relayed: [n=2] FALSE, FALSE
[16:09:36.043] - queued futures: [n=2] FALSE, FALSE
[16:09:36.043]  - until=1
[16:09:36.043]  - relaying element #1
[16:09:36.044] - relayed: [n=2] TRUE, FALSE
[16:09:36.044] - queued futures: [n=2] TRUE, FALSE
[16:09:36.044] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:36.044]  length: 1 (resolved future 1)
[16:09:36.044] Future #2
[16:09:36.045] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:36.045] - nx: 2
[16:09:36.045] - relay: TRUE
[16:09:36.046] - stdout: TRUE
[16:09:36.046] - signal: TRUE
[16:09:36.046] - resignal: FALSE
[16:09:36.046] - force: TRUE
[16:09:36.046] - relayed: [n=2] TRUE, FALSE
[16:09:36.046] - queued futures: [n=2] TRUE, FALSE
[16:09:36.046]  - until=2
[16:09:36.046]  - relaying element #2
[16:09:36.047] - relayed: [n=2] TRUE, TRUE
[16:09:36.047] - queued futures: [n=2] TRUE, TRUE
[16:09:36.047] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:36.047]  length: 0 (resolved future 2)
[16:09:36.047] Relaying remaining futures
[16:09:36.047] signalConditionsASAP(NULL, pos=0) ...
[16:09:36.047] - nx: 2
[16:09:36.047] - relay: TRUE
[16:09:36.048] - stdout: TRUE
[16:09:36.050] - signal: TRUE
[16:09:36.050] - resignal: FALSE
[16:09:36.050] - force: TRUE
[16:09:36.050] - relayed: [n=2] TRUE, TRUE
[16:09:36.050] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:36.051] - relayed: [n=2] TRUE, TRUE
[16:09:36.051] - queued futures: [n=2] TRUE, TRUE
[16:09:36.051] signalConditionsASAP(NULL, pos=0) ... done
[16:09:36.051] resolve() on list ... DONE
[16:09:36.051]  - Number of value chunks collected: 2
[16:09:36.051] Resolving 2 futures (chunks) ... DONE
[16:09:36.052] Reducing values from 2 chunks ...
[16:09:36.052]  - Number of values collected after concatenation: 3
[16:09:36.052]  - Number of values expected: 3
[16:09:36.052] Reducing values from 2 chunks ... DONE
[16:09:36.052] future_lapply() ... DONE
[16:09:36.053] future_lapply() ...
[16:09:36.058] Number of chunks: 2
[16:09:36.058] getGlobalsAndPackagesXApply() ...
[16:09:36.058]  - future.globals: TRUE
[16:09:36.058] getGlobalsAndPackages() ...
[16:09:36.058] Searching for globals...
[16:09:36.060] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:36.060] Searching for globals ... DONE
[16:09:36.060] Resolving globals: FALSE
[16:09:36.060] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:36.061] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:36.061] - globals: [1] ‘FUN’
[16:09:36.061] - packages: [1] ‘stats’
[16:09:36.061] getGlobalsAndPackages() ... DONE
[16:09:36.061]  - globals found/used: [n=1] ‘FUN’
[16:09:36.061]  - needed namespaces: [n=1] ‘stats’
[16:09:36.061] Finding globals ... DONE
[16:09:36.062]  - use_args: TRUE
[16:09:36.062]  - Getting '...' globals ...
[16:09:36.062] resolve() on list ...
[16:09:36.062]  recursive: 0
[16:09:36.062]  length: 1
[16:09:36.062]  elements: ‘...’
[16:09:36.063]  length: 0 (resolved future 1)
[16:09:36.063] resolve() on list ... DONE
[16:09:36.063]    - '...' content: [n=1] ‘probs’
[16:09:36.063] List of 1
[16:09:36.063]  $ ...:List of 1
[16:09:36.063]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:36.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.063]  - attr(*, "where")=List of 1
[16:09:36.063]   ..$ ...:<environment: 0x55b4b6c48e20> 
[16:09:36.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.063]  - attr(*, "resolved")= logi TRUE
[16:09:36.063]  - attr(*, "total_size")= num NA
[16:09:36.067]  - Getting '...' globals ... DONE
[16:09:36.067] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:36.067] List of 2
[16:09:36.067]  $ ...future.FUN:function (x, ...)  
[16:09:36.067]  $ ...          :List of 1
[16:09:36.067]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:36.067]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.067]  - attr(*, "where")=List of 2
[16:09:36.067]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:36.067]   ..$ ...          :<environment: 0x55b4b6c48e20> 
[16:09:36.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.067]  - attr(*, "resolved")= logi FALSE
[16:09:36.067]  - attr(*, "total_size")= num 1328
[16:09:36.070] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:36.070] getGlobalsAndPackagesXApply() ... DONE
[16:09:36.071] Number of futures (= number of chunks): 2
[16:09:36.071] Launching 2 futures (chunks) ...
[16:09:36.071] Chunk #1 of 2 ...
[16:09:36.071]  - Finding globals in 'X' for chunk #1 ...
[16:09:36.071] getGlobalsAndPackages() ...
[16:09:36.071] Searching for globals...
[16:09:36.071] 
[16:09:36.071] Searching for globals ... DONE
[16:09:36.072] - globals: [0] <none>
[16:09:36.072] getGlobalsAndPackages() ... DONE
[16:09:36.072]    + additional globals found: [n=0] 
[16:09:36.072]    + additional namespaces needed: [n=0] 
[16:09:36.072]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:36.072]  - seeds: <none>
[16:09:36.072] getGlobalsAndPackages() ...
[16:09:36.072] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.072] Resolving globals: FALSE
[16:09:36.072] Tweak future expression to call with '...' arguments ...
[16:09:36.073] {
[16:09:36.073]     do.call(function(...) {
[16:09:36.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.073]             on.exit(options(oopts), add = TRUE)
[16:09:36.073]         }
[16:09:36.073]         {
[16:09:36.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.073]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.073]             })
[16:09:36.073]         }
[16:09:36.073]     }, args = future.call.arguments)
[16:09:36.073] }
[16:09:36.073] Tweak future expression to call with '...' arguments ... DONE
[16:09:36.073] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.073] - packages: [1] ‘stats’
[16:09:36.073] getGlobalsAndPackages() ... DONE
[16:09:36.074] run() for ‘Future’ ...
[16:09:36.074] - state: ‘created’
[16:09:36.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.078] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.078]   - Field: ‘label’
[16:09:36.078]   - Field: ‘local’
[16:09:36.078]   - Field: ‘owner’
[16:09:36.078]   - Field: ‘envir’
[16:09:36.078]   - Field: ‘workers’
[16:09:36.078]   - Field: ‘packages’
[16:09:36.078]   - Field: ‘gc’
[16:09:36.078]   - Field: ‘job’
[16:09:36.079]   - Field: ‘conditions’
[16:09:36.079]   - Field: ‘expr’
[16:09:36.080]   - Field: ‘uuid’
[16:09:36.080]   - Field: ‘seed’
[16:09:36.081]   - Field: ‘version’
[16:09:36.081]   - Field: ‘result’
[16:09:36.081]   - Field: ‘asynchronous’
[16:09:36.081]   - Field: ‘calls’
[16:09:36.081]   - Field: ‘globals’
[16:09:36.081]   - Field: ‘stdout’
[16:09:36.081]   - Field: ‘earlySignal’
[16:09:36.081]   - Field: ‘lazy’
[16:09:36.081]   - Field: ‘state’
[16:09:36.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.082] - Launch lazy future ...
[16:09:36.082] Packages needed by the future expression (n = 1): ‘stats’
[16:09:36.082] Packages needed by future strategies (n = 0): <none>
[16:09:36.083] {
[16:09:36.083]     {
[16:09:36.083]         {
[16:09:36.083]             ...future.startTime <- base::Sys.time()
[16:09:36.083]             {
[16:09:36.083]                 {
[16:09:36.083]                   {
[16:09:36.083]                     {
[16:09:36.083]                       {
[16:09:36.083]                         base::local({
[16:09:36.083]                           has_future <- base::requireNamespace("future", 
[16:09:36.083]                             quietly = TRUE)
[16:09:36.083]                           if (has_future) {
[16:09:36.083]                             ns <- base::getNamespace("future")
[16:09:36.083]                             version <- ns[[".package"]][["version"]]
[16:09:36.083]                             if (is.null(version)) 
[16:09:36.083]                               version <- utils::packageVersion("future")
[16:09:36.083]                           }
[16:09:36.083]                           else {
[16:09:36.083]                             version <- NULL
[16:09:36.083]                           }
[16:09:36.083]                           if (!has_future || version < "1.8.0") {
[16:09:36.083]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.083]                               "", base::R.version$version.string), 
[16:09:36.083]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:36.083]                                 base::R.version$platform, 8 * 
[16:09:36.083]                                   base::.Machine$sizeof.pointer), 
[16:09:36.083]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.083]                                 "release", "version")], collapse = " "), 
[16:09:36.083]                               hostname = base::Sys.info()[["nodename"]])
[16:09:36.083]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.083]                               info)
[16:09:36.083]                             info <- base::paste(info, collapse = "; ")
[16:09:36.083]                             if (!has_future) {
[16:09:36.083]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.083]                                 info)
[16:09:36.083]                             }
[16:09:36.083]                             else {
[16:09:36.083]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.083]                                 info, version)
[16:09:36.083]                             }
[16:09:36.083]                             base::stop(msg)
[16:09:36.083]                           }
[16:09:36.083]                         })
[16:09:36.083]                       }
[16:09:36.083]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.083]                       base::options(mc.cores = 1L)
[16:09:36.083]                     }
[16:09:36.083]                     base::local({
[16:09:36.083]                       for (pkg in "stats") {
[16:09:36.083]                         base::loadNamespace(pkg)
[16:09:36.083]                         base::library(pkg, character.only = TRUE)
[16:09:36.083]                       }
[16:09:36.083]                     })
[16:09:36.083]                   }
[16:09:36.083]                   options(future.plan = NULL)
[16:09:36.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.083]                 }
[16:09:36.083]                 ...future.workdir <- getwd()
[16:09:36.083]             }
[16:09:36.083]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.083]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.083]         }
[16:09:36.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:36.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.083]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.083]             base::names(...future.oldOptions))
[16:09:36.083]     }
[16:09:36.083]     if (FALSE) {
[16:09:36.083]     }
[16:09:36.083]     else {
[16:09:36.083]         if (TRUE) {
[16:09:36.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.083]                 open = "w")
[16:09:36.083]         }
[16:09:36.083]         else {
[16:09:36.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.083]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.083]         }
[16:09:36.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.083]             base::sink(type = "output", split = FALSE)
[16:09:36.083]             base::close(...future.stdout)
[16:09:36.083]         }, add = TRUE)
[16:09:36.083]     }
[16:09:36.083]     ...future.frame <- base::sys.nframe()
[16:09:36.083]     ...future.conditions <- base::list()
[16:09:36.083]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.083]     if (FALSE) {
[16:09:36.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.083]     }
[16:09:36.083]     ...future.result <- base::tryCatch({
[16:09:36.083]         base::withCallingHandlers({
[16:09:36.083]             ...future.value <- base::withVisible(base::local({
[16:09:36.083]                 withCallingHandlers({
[16:09:36.083]                   {
[16:09:36.083]                     do.call(function(...) {
[16:09:36.083]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.083]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.083]                         ...future.globals.maxSize)) {
[16:09:36.083]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.083]                         on.exit(options(oopts), add = TRUE)
[16:09:36.083]                       }
[16:09:36.083]                       {
[16:09:36.083]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.083]                           FUN = function(jj) {
[16:09:36.083]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.083]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.083]                           })
[16:09:36.083]                       }
[16:09:36.083]                     }, args = future.call.arguments)
[16:09:36.083]                   }
[16:09:36.083]                 }, immediateCondition = function(cond) {
[16:09:36.083]                   save_rds <- function (object, pathname, ...) 
[16:09:36.083]                   {
[16:09:36.083]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.083]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.083]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.083]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.083]                         fi_tmp[["mtime"]])
[16:09:36.083]                     }
[16:09:36.083]                     tryCatch({
[16:09:36.083]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.083]                     }, error = function(ex) {
[16:09:36.083]                       msg <- conditionMessage(ex)
[16:09:36.083]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.083]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.083]                         fi_tmp[["mtime"]], msg)
[16:09:36.083]                       ex$message <- msg
[16:09:36.083]                       stop(ex)
[16:09:36.083]                     })
[16:09:36.083]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.083]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.083]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.083]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.083]                       fi <- file.info(pathname)
[16:09:36.083]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.083]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.083]                         fi[["size"]], fi[["mtime"]])
[16:09:36.083]                       stop(msg)
[16:09:36.083]                     }
[16:09:36.083]                     invisible(pathname)
[16:09:36.083]                   }
[16:09:36.083]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.083]                     rootPath = tempdir()) 
[16:09:36.083]                   {
[16:09:36.083]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.083]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.083]                       tmpdir = path, fileext = ".rds")
[16:09:36.083]                     save_rds(obj, file)
[16:09:36.083]                   }
[16:09:36.083]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.083]                   {
[16:09:36.083]                     inherits <- base::inherits
[16:09:36.083]                     invokeRestart <- base::invokeRestart
[16:09:36.083]                     is.null <- base::is.null
[16:09:36.083]                     muffled <- FALSE
[16:09:36.083]                     if (inherits(cond, "message")) {
[16:09:36.083]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.083]                       if (muffled) 
[16:09:36.083]                         invokeRestart("muffleMessage")
[16:09:36.083]                     }
[16:09:36.083]                     else if (inherits(cond, "warning")) {
[16:09:36.083]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.083]                       if (muffled) 
[16:09:36.083]                         invokeRestart("muffleWarning")
[16:09:36.083]                     }
[16:09:36.083]                     else if (inherits(cond, "condition")) {
[16:09:36.083]                       if (!is.null(pattern)) {
[16:09:36.083]                         computeRestarts <- base::computeRestarts
[16:09:36.083]                         grepl <- base::grepl
[16:09:36.083]                         restarts <- computeRestarts(cond)
[16:09:36.083]                         for (restart in restarts) {
[16:09:36.083]                           name <- restart$name
[16:09:36.083]                           if (is.null(name)) 
[16:09:36.083]                             next
[16:09:36.083]                           if (!grepl(pattern, name)) 
[16:09:36.083]                             next
[16:09:36.083]                           invokeRestart(restart)
[16:09:36.083]                           muffled <- TRUE
[16:09:36.083]                           break
[16:09:36.083]                         }
[16:09:36.083]                       }
[16:09:36.083]                     }
[16:09:36.083]                     invisible(muffled)
[16:09:36.083]                   }
[16:09:36.083]                   muffleCondition(cond)
[16:09:36.083]                 })
[16:09:36.083]             }))
[16:09:36.083]             future::FutureResult(value = ...future.value$value, 
[16:09:36.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.083]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.083]                     ...future.globalenv.names))
[16:09:36.083]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.083]         }, condition = base::local({
[16:09:36.083]             c <- base::c
[16:09:36.083]             inherits <- base::inherits
[16:09:36.083]             invokeRestart <- base::invokeRestart
[16:09:36.083]             length <- base::length
[16:09:36.083]             list <- base::list
[16:09:36.083]             seq.int <- base::seq.int
[16:09:36.083]             signalCondition <- base::signalCondition
[16:09:36.083]             sys.calls <- base::sys.calls
[16:09:36.083]             `[[` <- base::`[[`
[16:09:36.083]             `+` <- base::`+`
[16:09:36.083]             `<<-` <- base::`<<-`
[16:09:36.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.083]                   3L)]
[16:09:36.083]             }
[16:09:36.083]             function(cond) {
[16:09:36.083]                 is_error <- inherits(cond, "error")
[16:09:36.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.083]                   NULL)
[16:09:36.083]                 if (is_error) {
[16:09:36.083]                   sessionInformation <- function() {
[16:09:36.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.083]                       search = base::search(), system = base::Sys.info())
[16:09:36.083]                   }
[16:09:36.083]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.083]                     cond$call), session = sessionInformation(), 
[16:09:36.083]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.083]                   signalCondition(cond)
[16:09:36.083]                 }
[16:09:36.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.083]                 "immediateCondition"))) {
[16:09:36.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.083]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.083]                   if (TRUE && !signal) {
[16:09:36.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.083]                     {
[16:09:36.083]                       inherits <- base::inherits
[16:09:36.083]                       invokeRestart <- base::invokeRestart
[16:09:36.083]                       is.null <- base::is.null
[16:09:36.083]                       muffled <- FALSE
[16:09:36.083]                       if (inherits(cond, "message")) {
[16:09:36.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.083]                         if (muffled) 
[16:09:36.083]                           invokeRestart("muffleMessage")
[16:09:36.083]                       }
[16:09:36.083]                       else if (inherits(cond, "warning")) {
[16:09:36.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.083]                         if (muffled) 
[16:09:36.083]                           invokeRestart("muffleWarning")
[16:09:36.083]                       }
[16:09:36.083]                       else if (inherits(cond, "condition")) {
[16:09:36.083]                         if (!is.null(pattern)) {
[16:09:36.083]                           computeRestarts <- base::computeRestarts
[16:09:36.083]                           grepl <- base::grepl
[16:09:36.083]                           restarts <- computeRestarts(cond)
[16:09:36.083]                           for (restart in restarts) {
[16:09:36.083]                             name <- restart$name
[16:09:36.083]                             if (is.null(name)) 
[16:09:36.083]                               next
[16:09:36.083]                             if (!grepl(pattern, name)) 
[16:09:36.083]                               next
[16:09:36.083]                             invokeRestart(restart)
[16:09:36.083]                             muffled <- TRUE
[16:09:36.083]                             break
[16:09:36.083]                           }
[16:09:36.083]                         }
[16:09:36.083]                       }
[16:09:36.083]                       invisible(muffled)
[16:09:36.083]                     }
[16:09:36.083]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.083]                   }
[16:09:36.083]                 }
[16:09:36.083]                 else {
[16:09:36.083]                   if (TRUE) {
[16:09:36.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.083]                     {
[16:09:36.083]                       inherits <- base::inherits
[16:09:36.083]                       invokeRestart <- base::invokeRestart
[16:09:36.083]                       is.null <- base::is.null
[16:09:36.083]                       muffled <- FALSE
[16:09:36.083]                       if (inherits(cond, "message")) {
[16:09:36.083]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.083]                         if (muffled) 
[16:09:36.083]                           invokeRestart("muffleMessage")
[16:09:36.083]                       }
[16:09:36.083]                       else if (inherits(cond, "warning")) {
[16:09:36.083]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.083]                         if (muffled) 
[16:09:36.083]                           invokeRestart("muffleWarning")
[16:09:36.083]                       }
[16:09:36.083]                       else if (inherits(cond, "condition")) {
[16:09:36.083]                         if (!is.null(pattern)) {
[16:09:36.083]                           computeRestarts <- base::computeRestarts
[16:09:36.083]                           grepl <- base::grepl
[16:09:36.083]                           restarts <- computeRestarts(cond)
[16:09:36.083]                           for (restart in restarts) {
[16:09:36.083]                             name <- restart$name
[16:09:36.083]                             if (is.null(name)) 
[16:09:36.083]                               next
[16:09:36.083]                             if (!grepl(pattern, name)) 
[16:09:36.083]                               next
[16:09:36.083]                             invokeRestart(restart)
[16:09:36.083]                             muffled <- TRUE
[16:09:36.083]                             break
[16:09:36.083]                           }
[16:09:36.083]                         }
[16:09:36.083]                       }
[16:09:36.083]                       invisible(muffled)
[16:09:36.083]                     }
[16:09:36.083]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.083]                   }
[16:09:36.083]                 }
[16:09:36.083]             }
[16:09:36.083]         }))
[16:09:36.083]     }, error = function(ex) {
[16:09:36.083]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.083]                 ...future.rng), started = ...future.startTime, 
[16:09:36.083]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.083]             version = "1.8"), class = "FutureResult")
[16:09:36.083]     }, finally = {
[16:09:36.083]         if (!identical(...future.workdir, getwd())) 
[16:09:36.083]             setwd(...future.workdir)
[16:09:36.083]         {
[16:09:36.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.083]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.083]             }
[16:09:36.083]             base::options(...future.oldOptions)
[16:09:36.083]             if (.Platform$OS.type == "windows") {
[16:09:36.083]                 old_names <- names(...future.oldEnvVars)
[16:09:36.083]                 envs <- base::Sys.getenv()
[16:09:36.083]                 names <- names(envs)
[16:09:36.083]                 common <- intersect(names, old_names)
[16:09:36.083]                 added <- setdiff(names, old_names)
[16:09:36.083]                 removed <- setdiff(old_names, names)
[16:09:36.083]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.083]                   envs[common]]
[16:09:36.083]                 NAMES <- toupper(changed)
[16:09:36.083]                 args <- list()
[16:09:36.083]                 for (kk in seq_along(NAMES)) {
[16:09:36.083]                   name <- changed[[kk]]
[16:09:36.083]                   NAME <- NAMES[[kk]]
[16:09:36.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.083]                     next
[16:09:36.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.083]                 }
[16:09:36.083]                 NAMES <- toupper(added)
[16:09:36.083]                 for (kk in seq_along(NAMES)) {
[16:09:36.083]                   name <- added[[kk]]
[16:09:36.083]                   NAME <- NAMES[[kk]]
[16:09:36.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.083]                     next
[16:09:36.083]                   args[[name]] <- ""
[16:09:36.083]                 }
[16:09:36.083]                 NAMES <- toupper(removed)
[16:09:36.083]                 for (kk in seq_along(NAMES)) {
[16:09:36.083]                   name <- removed[[kk]]
[16:09:36.083]                   NAME <- NAMES[[kk]]
[16:09:36.083]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.083]                     next
[16:09:36.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.083]                 }
[16:09:36.083]                 if (length(args) > 0) 
[16:09:36.083]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.083]             }
[16:09:36.083]             else {
[16:09:36.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.083]             }
[16:09:36.083]             {
[16:09:36.083]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.083]                   0L) {
[16:09:36.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.083]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.083]                   base::options(opts)
[16:09:36.083]                 }
[16:09:36.083]                 {
[16:09:36.083]                   {
[16:09:36.083]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.083]                     NULL
[16:09:36.083]                   }
[16:09:36.083]                   options(future.plan = NULL)
[16:09:36.083]                   if (is.na(NA_character_)) 
[16:09:36.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.083]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.083]                     envir = parent.frame()) 
[16:09:36.083]                   {
[16:09:36.083]                     default_workers <- missing(workers)
[16:09:36.083]                     if (is.function(workers)) 
[16:09:36.083]                       workers <- workers()
[16:09:36.083]                     workers <- structure(as.integer(workers), 
[16:09:36.083]                       class = class(workers))
[16:09:36.083]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.083]                       1L)
[16:09:36.083]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.083]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.083]                       if (default_workers) 
[16:09:36.083]                         supportsMulticore(warn = TRUE)
[16:09:36.083]                       return(sequential(..., envir = envir))
[16:09:36.083]                     }
[16:09:36.083]                     oopts <- options(mc.cores = workers)
[16:09:36.083]                     on.exit(options(oopts))
[16:09:36.083]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.083]                       envir = envir)
[16:09:36.083]                     if (!future$lazy) 
[16:09:36.083]                       future <- run(future)
[16:09:36.083]                     invisible(future)
[16:09:36.083]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.083]                 }
[16:09:36.083]             }
[16:09:36.083]         }
[16:09:36.083]     })
[16:09:36.083]     if (TRUE) {
[16:09:36.083]         base::sink(type = "output", split = FALSE)
[16:09:36.083]         if (TRUE) {
[16:09:36.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.083]         }
[16:09:36.083]         else {
[16:09:36.083]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.083]         }
[16:09:36.083]         base::close(...future.stdout)
[16:09:36.083]         ...future.stdout <- NULL
[16:09:36.083]     }
[16:09:36.083]     ...future.result$conditions <- ...future.conditions
[16:09:36.083]     ...future.result$finished <- base::Sys.time()
[16:09:36.083]     ...future.result
[16:09:36.083] }
[16:09:36.085] assign_globals() ...
[16:09:36.085] List of 5
[16:09:36.085]  $ ...future.FUN            :function (x, ...)  
[16:09:36.085]  $ future.call.arguments    :List of 1
[16:09:36.085]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:36.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.085]  $ ...future.elements_ii    :List of 1
[16:09:36.085]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:09:36.085]  $ ...future.seeds_ii       : NULL
[16:09:36.085]  $ ...future.globals.maxSize: NULL
[16:09:36.085]  - attr(*, "where")=List of 5
[16:09:36.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.085]  - attr(*, "resolved")= logi FALSE
[16:09:36.085]  - attr(*, "total_size")= num 1328
[16:09:36.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.085]  - attr(*, "already-done")= logi TRUE
[16:09:36.090] - copied ‘...future.FUN’ to environment
[16:09:36.090] - copied ‘future.call.arguments’ to environment
[16:09:36.090] - copied ‘...future.elements_ii’ to environment
[16:09:36.090] - copied ‘...future.seeds_ii’ to environment
[16:09:36.090] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.090] assign_globals() ... done
[16:09:36.091] requestCore(): workers = 2
[16:09:36.092] MulticoreFuture started
[16:09:36.093] - Launch lazy future ... done
[16:09:36.093] run() for ‘MulticoreFuture’ ... done
[16:09:36.093] Created future:
[16:09:36.094] plan(): Setting new future strategy stack:
[16:09:36.094] List of future strategies:
[16:09:36.094] 1. sequential:
[16:09:36.094]    - args: function (..., envir = parent.frame())
[16:09:36.094]    - tweaked: FALSE
[16:09:36.094]    - call: NULL
[16:09:36.095] plan(): nbrOfWorkers() = 1
[16:09:36.097] plan(): Setting new future strategy stack:
[16:09:36.097] List of future strategies:
[16:09:36.097] 1. multicore:
[16:09:36.097]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.097]    - tweaked: FALSE
[16:09:36.097]    - call: plan(strategy)
[16:09:36.103] plan(): nbrOfWorkers() = 2
[16:09:36.093] MulticoreFuture:
[16:09:36.093] Label: ‘future_eapply-1’
[16:09:36.093] Expression:
[16:09:36.093] {
[16:09:36.093]     do.call(function(...) {
[16:09:36.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.093]             on.exit(options(oopts), add = TRUE)
[16:09:36.093]         }
[16:09:36.093]         {
[16:09:36.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.093]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.093]             })
[16:09:36.093]         }
[16:09:36.093]     }, args = future.call.arguments)
[16:09:36.093] }
[16:09:36.093] Lazy evaluation: FALSE
[16:09:36.093] Asynchronous evaluation: TRUE
[16:09:36.093] Local evaluation: TRUE
[16:09:36.093] Environment: R_GlobalEnv
[16:09:36.093] Capture standard output: TRUE
[16:09:36.093] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.093] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.093] Packages: 1 packages (‘stats’)
[16:09:36.093] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.093] Resolved: TRUE
[16:09:36.093] Value: <not collected>
[16:09:36.093] Conditions captured: <none>
[16:09:36.093] Early signaling: FALSE
[16:09:36.093] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.093] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.104] Chunk #1 of 2 ... DONE
[16:09:36.104] Chunk #2 of 2 ...
[16:09:36.104]  - Finding globals in 'X' for chunk #2 ...
[16:09:36.104] getGlobalsAndPackages() ...
[16:09:36.104] Searching for globals...
[16:09:36.105] 
[16:09:36.105] Searching for globals ... DONE
[16:09:36.105] - globals: [0] <none>
[16:09:36.105] getGlobalsAndPackages() ... DONE
[16:09:36.105]    + additional globals found: [n=0] 
[16:09:36.105]    + additional namespaces needed: [n=0] 
[16:09:36.106]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:36.106]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:36.106]  - seeds: <none>
[16:09:36.106] getGlobalsAndPackages() ...
[16:09:36.106] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.106] Resolving globals: FALSE
[16:09:36.107] Tweak future expression to call with '...' arguments ...
[16:09:36.107] {
[16:09:36.107]     do.call(function(...) {
[16:09:36.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.107]             on.exit(options(oopts), add = TRUE)
[16:09:36.107]         }
[16:09:36.107]         {
[16:09:36.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.107]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.107]             })
[16:09:36.107]         }
[16:09:36.107]     }, args = future.call.arguments)
[16:09:36.107] }
[16:09:36.107] Tweak future expression to call with '...' arguments ... DONE
[16:09:36.108] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.108] - packages: [1] ‘stats’
[16:09:36.108] getGlobalsAndPackages() ... DONE
[16:09:36.109] run() for ‘Future’ ...
[16:09:36.109] - state: ‘created’
[16:09:36.109] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.114] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.114]   - Field: ‘label’
[16:09:36.114]   - Field: ‘local’
[16:09:36.114]   - Field: ‘owner’
[16:09:36.115]   - Field: ‘envir’
[16:09:36.115]   - Field: ‘workers’
[16:09:36.115]   - Field: ‘packages’
[16:09:36.115]   - Field: ‘gc’
[16:09:36.115]   - Field: ‘job’
[16:09:36.115]   - Field: ‘conditions’
[16:09:36.115]   - Field: ‘expr’
[16:09:36.116]   - Field: ‘uuid’
[16:09:36.116]   - Field: ‘seed’
[16:09:36.116]   - Field: ‘version’
[16:09:36.116]   - Field: ‘result’
[16:09:36.116]   - Field: ‘asynchronous’
[16:09:36.116]   - Field: ‘calls’
[16:09:36.116]   - Field: ‘globals’
[16:09:36.117]   - Field: ‘stdout’
[16:09:36.117]   - Field: ‘earlySignal’
[16:09:36.117]   - Field: ‘lazy’
[16:09:36.117]   - Field: ‘state’
[16:09:36.117] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.117] - Launch lazy future ...
[16:09:36.118] Packages needed by the future expression (n = 1): ‘stats’
[16:09:36.118] Packages needed by future strategies (n = 0): <none>
[16:09:36.119] {
[16:09:36.119]     {
[16:09:36.119]         {
[16:09:36.119]             ...future.startTime <- base::Sys.time()
[16:09:36.119]             {
[16:09:36.119]                 {
[16:09:36.119]                   {
[16:09:36.119]                     {
[16:09:36.119]                       {
[16:09:36.119]                         base::local({
[16:09:36.119]                           has_future <- base::requireNamespace("future", 
[16:09:36.119]                             quietly = TRUE)
[16:09:36.119]                           if (has_future) {
[16:09:36.119]                             ns <- base::getNamespace("future")
[16:09:36.119]                             version <- ns[[".package"]][["version"]]
[16:09:36.119]                             if (is.null(version)) 
[16:09:36.119]                               version <- utils::packageVersion("future")
[16:09:36.119]                           }
[16:09:36.119]                           else {
[16:09:36.119]                             version <- NULL
[16:09:36.119]                           }
[16:09:36.119]                           if (!has_future || version < "1.8.0") {
[16:09:36.119]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.119]                               "", base::R.version$version.string), 
[16:09:36.119]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:36.119]                                 base::R.version$platform, 8 * 
[16:09:36.119]                                   base::.Machine$sizeof.pointer), 
[16:09:36.119]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.119]                                 "release", "version")], collapse = " "), 
[16:09:36.119]                               hostname = base::Sys.info()[["nodename"]])
[16:09:36.119]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.119]                               info)
[16:09:36.119]                             info <- base::paste(info, collapse = "; ")
[16:09:36.119]                             if (!has_future) {
[16:09:36.119]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.119]                                 info)
[16:09:36.119]                             }
[16:09:36.119]                             else {
[16:09:36.119]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.119]                                 info, version)
[16:09:36.119]                             }
[16:09:36.119]                             base::stop(msg)
[16:09:36.119]                           }
[16:09:36.119]                         })
[16:09:36.119]                       }
[16:09:36.119]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.119]                       base::options(mc.cores = 1L)
[16:09:36.119]                     }
[16:09:36.119]                     base::local({
[16:09:36.119]                       for (pkg in "stats") {
[16:09:36.119]                         base::loadNamespace(pkg)
[16:09:36.119]                         base::library(pkg, character.only = TRUE)
[16:09:36.119]                       }
[16:09:36.119]                     })
[16:09:36.119]                   }
[16:09:36.119]                   options(future.plan = NULL)
[16:09:36.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.119]                 }
[16:09:36.119]                 ...future.workdir <- getwd()
[16:09:36.119]             }
[16:09:36.119]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.119]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.119]         }
[16:09:36.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.119]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:36.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.119]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.119]             base::names(...future.oldOptions))
[16:09:36.119]     }
[16:09:36.119]     if (FALSE) {
[16:09:36.119]     }
[16:09:36.119]     else {
[16:09:36.119]         if (TRUE) {
[16:09:36.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.119]                 open = "w")
[16:09:36.119]         }
[16:09:36.119]         else {
[16:09:36.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.119]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.119]         }
[16:09:36.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.119]             base::sink(type = "output", split = FALSE)
[16:09:36.119]             base::close(...future.stdout)
[16:09:36.119]         }, add = TRUE)
[16:09:36.119]     }
[16:09:36.119]     ...future.frame <- base::sys.nframe()
[16:09:36.119]     ...future.conditions <- base::list()
[16:09:36.119]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.119]     if (FALSE) {
[16:09:36.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.119]     }
[16:09:36.119]     ...future.result <- base::tryCatch({
[16:09:36.119]         base::withCallingHandlers({
[16:09:36.119]             ...future.value <- base::withVisible(base::local({
[16:09:36.119]                 withCallingHandlers({
[16:09:36.119]                   {
[16:09:36.119]                     do.call(function(...) {
[16:09:36.119]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.119]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.119]                         ...future.globals.maxSize)) {
[16:09:36.119]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.119]                         on.exit(options(oopts), add = TRUE)
[16:09:36.119]                       }
[16:09:36.119]                       {
[16:09:36.119]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.119]                           FUN = function(jj) {
[16:09:36.119]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.119]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.119]                           })
[16:09:36.119]                       }
[16:09:36.119]                     }, args = future.call.arguments)
[16:09:36.119]                   }
[16:09:36.119]                 }, immediateCondition = function(cond) {
[16:09:36.119]                   save_rds <- function (object, pathname, ...) 
[16:09:36.119]                   {
[16:09:36.119]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.119]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.119]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.119]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.119]                         fi_tmp[["mtime"]])
[16:09:36.119]                     }
[16:09:36.119]                     tryCatch({
[16:09:36.119]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.119]                     }, error = function(ex) {
[16:09:36.119]                       msg <- conditionMessage(ex)
[16:09:36.119]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.119]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.119]                         fi_tmp[["mtime"]], msg)
[16:09:36.119]                       ex$message <- msg
[16:09:36.119]                       stop(ex)
[16:09:36.119]                     })
[16:09:36.119]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.119]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.119]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.119]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.119]                       fi <- file.info(pathname)
[16:09:36.119]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.119]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.119]                         fi[["size"]], fi[["mtime"]])
[16:09:36.119]                       stop(msg)
[16:09:36.119]                     }
[16:09:36.119]                     invisible(pathname)
[16:09:36.119]                   }
[16:09:36.119]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.119]                     rootPath = tempdir()) 
[16:09:36.119]                   {
[16:09:36.119]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.119]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.119]                       tmpdir = path, fileext = ".rds")
[16:09:36.119]                     save_rds(obj, file)
[16:09:36.119]                   }
[16:09:36.119]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.119]                   {
[16:09:36.119]                     inherits <- base::inherits
[16:09:36.119]                     invokeRestart <- base::invokeRestart
[16:09:36.119]                     is.null <- base::is.null
[16:09:36.119]                     muffled <- FALSE
[16:09:36.119]                     if (inherits(cond, "message")) {
[16:09:36.119]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.119]                       if (muffled) 
[16:09:36.119]                         invokeRestart("muffleMessage")
[16:09:36.119]                     }
[16:09:36.119]                     else if (inherits(cond, "warning")) {
[16:09:36.119]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.119]                       if (muffled) 
[16:09:36.119]                         invokeRestart("muffleWarning")
[16:09:36.119]                     }
[16:09:36.119]                     else if (inherits(cond, "condition")) {
[16:09:36.119]                       if (!is.null(pattern)) {
[16:09:36.119]                         computeRestarts <- base::computeRestarts
[16:09:36.119]                         grepl <- base::grepl
[16:09:36.119]                         restarts <- computeRestarts(cond)
[16:09:36.119]                         for (restart in restarts) {
[16:09:36.119]                           name <- restart$name
[16:09:36.119]                           if (is.null(name)) 
[16:09:36.119]                             next
[16:09:36.119]                           if (!grepl(pattern, name)) 
[16:09:36.119]                             next
[16:09:36.119]                           invokeRestart(restart)
[16:09:36.119]                           muffled <- TRUE
[16:09:36.119]                           break
[16:09:36.119]                         }
[16:09:36.119]                       }
[16:09:36.119]                     }
[16:09:36.119]                     invisible(muffled)
[16:09:36.119]                   }
[16:09:36.119]                   muffleCondition(cond)
[16:09:36.119]                 })
[16:09:36.119]             }))
[16:09:36.119]             future::FutureResult(value = ...future.value$value, 
[16:09:36.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.119]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.119]                     ...future.globalenv.names))
[16:09:36.119]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.119]         }, condition = base::local({
[16:09:36.119]             c <- base::c
[16:09:36.119]             inherits <- base::inherits
[16:09:36.119]             invokeRestart <- base::invokeRestart
[16:09:36.119]             length <- base::length
[16:09:36.119]             list <- base::list
[16:09:36.119]             seq.int <- base::seq.int
[16:09:36.119]             signalCondition <- base::signalCondition
[16:09:36.119]             sys.calls <- base::sys.calls
[16:09:36.119]             `[[` <- base::`[[`
[16:09:36.119]             `+` <- base::`+`
[16:09:36.119]             `<<-` <- base::`<<-`
[16:09:36.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.119]                   3L)]
[16:09:36.119]             }
[16:09:36.119]             function(cond) {
[16:09:36.119]                 is_error <- inherits(cond, "error")
[16:09:36.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.119]                   NULL)
[16:09:36.119]                 if (is_error) {
[16:09:36.119]                   sessionInformation <- function() {
[16:09:36.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.119]                       search = base::search(), system = base::Sys.info())
[16:09:36.119]                   }
[16:09:36.119]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.119]                     cond$call), session = sessionInformation(), 
[16:09:36.119]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.119]                   signalCondition(cond)
[16:09:36.119]                 }
[16:09:36.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.119]                 "immediateCondition"))) {
[16:09:36.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.119]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.119]                   if (TRUE && !signal) {
[16:09:36.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.119]                     {
[16:09:36.119]                       inherits <- base::inherits
[16:09:36.119]                       invokeRestart <- base::invokeRestart
[16:09:36.119]                       is.null <- base::is.null
[16:09:36.119]                       muffled <- FALSE
[16:09:36.119]                       if (inherits(cond, "message")) {
[16:09:36.119]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.119]                         if (muffled) 
[16:09:36.119]                           invokeRestart("muffleMessage")
[16:09:36.119]                       }
[16:09:36.119]                       else if (inherits(cond, "warning")) {
[16:09:36.119]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.119]                         if (muffled) 
[16:09:36.119]                           invokeRestart("muffleWarning")
[16:09:36.119]                       }
[16:09:36.119]                       else if (inherits(cond, "condition")) {
[16:09:36.119]                         if (!is.null(pattern)) {
[16:09:36.119]                           computeRestarts <- base::computeRestarts
[16:09:36.119]                           grepl <- base::grepl
[16:09:36.119]                           restarts <- computeRestarts(cond)
[16:09:36.119]                           for (restart in restarts) {
[16:09:36.119]                             name <- restart$name
[16:09:36.119]                             if (is.null(name)) 
[16:09:36.119]                               next
[16:09:36.119]                             if (!grepl(pattern, name)) 
[16:09:36.119]                               next
[16:09:36.119]                             invokeRestart(restart)
[16:09:36.119]                             muffled <- TRUE
[16:09:36.119]                             break
[16:09:36.119]                           }
[16:09:36.119]                         }
[16:09:36.119]                       }
[16:09:36.119]                       invisible(muffled)
[16:09:36.119]                     }
[16:09:36.119]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.119]                   }
[16:09:36.119]                 }
[16:09:36.119]                 else {
[16:09:36.119]                   if (TRUE) {
[16:09:36.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.119]                     {
[16:09:36.119]                       inherits <- base::inherits
[16:09:36.119]                       invokeRestart <- base::invokeRestart
[16:09:36.119]                       is.null <- base::is.null
[16:09:36.119]                       muffled <- FALSE
[16:09:36.119]                       if (inherits(cond, "message")) {
[16:09:36.119]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.119]                         if (muffled) 
[16:09:36.119]                           invokeRestart("muffleMessage")
[16:09:36.119]                       }
[16:09:36.119]                       else if (inherits(cond, "warning")) {
[16:09:36.119]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.119]                         if (muffled) 
[16:09:36.119]                           invokeRestart("muffleWarning")
[16:09:36.119]                       }
[16:09:36.119]                       else if (inherits(cond, "condition")) {
[16:09:36.119]                         if (!is.null(pattern)) {
[16:09:36.119]                           computeRestarts <- base::computeRestarts
[16:09:36.119]                           grepl <- base::grepl
[16:09:36.119]                           restarts <- computeRestarts(cond)
[16:09:36.119]                           for (restart in restarts) {
[16:09:36.119]                             name <- restart$name
[16:09:36.119]                             if (is.null(name)) 
[16:09:36.119]                               next
[16:09:36.119]                             if (!grepl(pattern, name)) 
[16:09:36.119]                               next
[16:09:36.119]                             invokeRestart(restart)
[16:09:36.119]                             muffled <- TRUE
[16:09:36.119]                             break
[16:09:36.119]                           }
[16:09:36.119]                         }
[16:09:36.119]                       }
[16:09:36.119]                       invisible(muffled)
[16:09:36.119]                     }
[16:09:36.119]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.119]                   }
[16:09:36.119]                 }
[16:09:36.119]             }
[16:09:36.119]         }))
[16:09:36.119]     }, error = function(ex) {
[16:09:36.119]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.119]                 ...future.rng), started = ...future.startTime, 
[16:09:36.119]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.119]             version = "1.8"), class = "FutureResult")
[16:09:36.119]     }, finally = {
[16:09:36.119]         if (!identical(...future.workdir, getwd())) 
[16:09:36.119]             setwd(...future.workdir)
[16:09:36.119]         {
[16:09:36.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.119]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.119]             }
[16:09:36.119]             base::options(...future.oldOptions)
[16:09:36.119]             if (.Platform$OS.type == "windows") {
[16:09:36.119]                 old_names <- names(...future.oldEnvVars)
[16:09:36.119]                 envs <- base::Sys.getenv()
[16:09:36.119]                 names <- names(envs)
[16:09:36.119]                 common <- intersect(names, old_names)
[16:09:36.119]                 added <- setdiff(names, old_names)
[16:09:36.119]                 removed <- setdiff(old_names, names)
[16:09:36.119]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.119]                   envs[common]]
[16:09:36.119]                 NAMES <- toupper(changed)
[16:09:36.119]                 args <- list()
[16:09:36.119]                 for (kk in seq_along(NAMES)) {
[16:09:36.119]                   name <- changed[[kk]]
[16:09:36.119]                   NAME <- NAMES[[kk]]
[16:09:36.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.119]                     next
[16:09:36.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.119]                 }
[16:09:36.119]                 NAMES <- toupper(added)
[16:09:36.119]                 for (kk in seq_along(NAMES)) {
[16:09:36.119]                   name <- added[[kk]]
[16:09:36.119]                   NAME <- NAMES[[kk]]
[16:09:36.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.119]                     next
[16:09:36.119]                   args[[name]] <- ""
[16:09:36.119]                 }
[16:09:36.119]                 NAMES <- toupper(removed)
[16:09:36.119]                 for (kk in seq_along(NAMES)) {
[16:09:36.119]                   name <- removed[[kk]]
[16:09:36.119]                   NAME <- NAMES[[kk]]
[16:09:36.119]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.119]                     next
[16:09:36.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.119]                 }
[16:09:36.119]                 if (length(args) > 0) 
[16:09:36.119]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.119]             }
[16:09:36.119]             else {
[16:09:36.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.119]             }
[16:09:36.119]             {
[16:09:36.119]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.119]                   0L) {
[16:09:36.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.119]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.119]                   base::options(opts)
[16:09:36.119]                 }
[16:09:36.119]                 {
[16:09:36.119]                   {
[16:09:36.119]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.119]                     NULL
[16:09:36.119]                   }
[16:09:36.119]                   options(future.plan = NULL)
[16:09:36.119]                   if (is.na(NA_character_)) 
[16:09:36.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.119]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.119]                     envir = parent.frame()) 
[16:09:36.119]                   {
[16:09:36.119]                     default_workers <- missing(workers)
[16:09:36.119]                     if (is.function(workers)) 
[16:09:36.119]                       workers <- workers()
[16:09:36.119]                     workers <- structure(as.integer(workers), 
[16:09:36.119]                       class = class(workers))
[16:09:36.119]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.119]                       1L)
[16:09:36.119]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.119]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.119]                       if (default_workers) 
[16:09:36.119]                         supportsMulticore(warn = TRUE)
[16:09:36.119]                       return(sequential(..., envir = envir))
[16:09:36.119]                     }
[16:09:36.119]                     oopts <- options(mc.cores = workers)
[16:09:36.119]                     on.exit(options(oopts))
[16:09:36.119]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.119]                       envir = envir)
[16:09:36.119]                     if (!future$lazy) 
[16:09:36.119]                       future <- run(future)
[16:09:36.119]                     invisible(future)
[16:09:36.119]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.119]                 }
[16:09:36.119]             }
[16:09:36.119]         }
[16:09:36.119]     })
[16:09:36.119]     if (TRUE) {
[16:09:36.119]         base::sink(type = "output", split = FALSE)
[16:09:36.119]         if (TRUE) {
[16:09:36.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.119]         }
[16:09:36.119]         else {
[16:09:36.119]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.119]         }
[16:09:36.119]         base::close(...future.stdout)
[16:09:36.119]         ...future.stdout <- NULL
[16:09:36.119]     }
[16:09:36.119]     ...future.result$conditions <- ...future.conditions
[16:09:36.119]     ...future.result$finished <- base::Sys.time()
[16:09:36.119]     ...future.result
[16:09:36.119] }
[16:09:36.122] assign_globals() ...
[16:09:36.122] List of 5
[16:09:36.122]  $ ...future.FUN            :function (x, ...)  
[16:09:36.122]  $ future.call.arguments    :List of 1
[16:09:36.122]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:36.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.122]  $ ...future.elements_ii    :List of 2
[16:09:36.122]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:36.122]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:36.122]  $ ...future.seeds_ii       : NULL
[16:09:36.122]  $ ...future.globals.maxSize: NULL
[16:09:36.122]  - attr(*, "resolved")= logi FALSE
[16:09:36.122]  - attr(*, "total_size")= num 1328
[16:09:36.122]  - attr(*, "where")=List of 5
[16:09:36.122]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.122]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.122]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.122]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.122]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.122]  - attr(*, "already-done")= logi TRUE
[16:09:36.135] - copied ‘...future.FUN’ to environment
[16:09:36.135] - copied ‘future.call.arguments’ to environment
[16:09:36.135] - copied ‘...future.elements_ii’ to environment
[16:09:36.135] - copied ‘...future.seeds_ii’ to environment
[16:09:36.135] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.135] assign_globals() ... done
[16:09:36.136] requestCore(): workers = 2
[16:09:36.138] MulticoreFuture started
[16:09:36.138] - Launch lazy future ... done
[16:09:36.138] run() for ‘MulticoreFuture’ ... done
[16:09:36.139] Created future:
[16:09:36.139] plan(): Setting new future strategy stack:
[16:09:36.139] List of future strategies:
[16:09:36.139] 1. sequential:
[16:09:36.139]    - args: function (..., envir = parent.frame())
[16:09:36.139]    - tweaked: FALSE
[16:09:36.139]    - call: NULL
[16:09:36.140] plan(): nbrOfWorkers() = 1
[16:09:36.143] plan(): Setting new future strategy stack:
[16:09:36.143] List of future strategies:
[16:09:36.143] 1. multicore:
[16:09:36.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.143]    - tweaked: FALSE
[16:09:36.143]    - call: plan(strategy)
[16:09:36.148] plan(): nbrOfWorkers() = 2
[16:09:36.139] MulticoreFuture:
[16:09:36.139] Label: ‘future_eapply-2’
[16:09:36.139] Expression:
[16:09:36.139] {
[16:09:36.139]     do.call(function(...) {
[16:09:36.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.139]             on.exit(options(oopts), add = TRUE)
[16:09:36.139]         }
[16:09:36.139]         {
[16:09:36.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.139]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.139]             })
[16:09:36.139]         }
[16:09:36.139]     }, args = future.call.arguments)
[16:09:36.139] }
[16:09:36.139] Lazy evaluation: FALSE
[16:09:36.139] Asynchronous evaluation: TRUE
[16:09:36.139] Local evaluation: TRUE
[16:09:36.139] Environment: R_GlobalEnv
[16:09:36.139] Capture standard output: TRUE
[16:09:36.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.139] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.139] Packages: 1 packages (‘stats’)
[16:09:36.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.139] Resolved: TRUE
[16:09:36.139] Value: <not collected>
[16:09:36.139] Conditions captured: <none>
[16:09:36.139] Early signaling: FALSE
[16:09:36.139] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.139] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.149] Chunk #2 of 2 ... DONE
[16:09:36.150] Launching 2 futures (chunks) ... DONE
[16:09:36.150] Resolving 2 futures (chunks) ...
[16:09:36.150] resolve() on list ...
[16:09:36.150]  recursive: 0
[16:09:36.150]  length: 2
[16:09:36.150] 
[16:09:36.151] Future #1
[16:09:36.152] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:36.152] - nx: 2
[16:09:36.152] - relay: TRUE
[16:09:36.152] - stdout: TRUE
[16:09:36.152] - signal: TRUE
[16:09:36.152] - resignal: FALSE
[16:09:36.153] - force: TRUE
[16:09:36.153] - relayed: [n=2] FALSE, FALSE
[16:09:36.153] - queued futures: [n=2] FALSE, FALSE
[16:09:36.153]  - until=1
[16:09:36.153]  - relaying element #1
[16:09:36.154] - relayed: [n=2] TRUE, FALSE
[16:09:36.154] - queued futures: [n=2] TRUE, FALSE
[16:09:36.154] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:36.154]  length: 1 (resolved future 1)
[16:09:36.154] Future #2
[16:09:36.155] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:36.155] - nx: 2
[16:09:36.155] - relay: TRUE
[16:09:36.156] - stdout: TRUE
[16:09:36.156] - signal: TRUE
[16:09:36.156] - resignal: FALSE
[16:09:36.156] - force: TRUE
[16:09:36.156] - relayed: [n=2] TRUE, FALSE
[16:09:36.156] - queued futures: [n=2] TRUE, FALSE
[16:09:36.156]  - until=2
[16:09:36.157]  - relaying element #2
[16:09:36.157] - relayed: [n=2] TRUE, TRUE
[16:09:36.157] - queued futures: [n=2] TRUE, TRUE
[16:09:36.157] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:36.157]  length: 0 (resolved future 2)
[16:09:36.157] Relaying remaining futures
[16:09:36.157] signalConditionsASAP(NULL, pos=0) ...
[16:09:36.157] - nx: 2
[16:09:36.158] - relay: TRUE
[16:09:36.158] - stdout: TRUE
[16:09:36.158] - signal: TRUE
[16:09:36.158] - resignal: FALSE
[16:09:36.158] - force: TRUE
[16:09:36.158] - relayed: [n=2] TRUE, TRUE
[16:09:36.158] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:36.158] - relayed: [n=2] TRUE, TRUE
[16:09:36.159] - queued futures: [n=2] TRUE, TRUE
[16:09:36.159] signalConditionsASAP(NULL, pos=0) ... done
[16:09:36.159] resolve() on list ... DONE
[16:09:36.159]  - Number of value chunks collected: 2
[16:09:36.159] Resolving 2 futures (chunks) ... DONE
[16:09:36.159] Reducing values from 2 chunks ...
[16:09:36.159]  - Number of values collected after concatenation: 3
[16:09:36.159]  - Number of values expected: 3
[16:09:36.160] Reducing values from 2 chunks ... DONE
[16:09:36.160] future_lapply() ... DONE
[16:09:36.161] future_lapply() ...
[16:09:36.165] Number of chunks: 2
[16:09:36.166] getGlobalsAndPackagesXApply() ...
[16:09:36.166]  - future.globals: TRUE
[16:09:36.166] getGlobalsAndPackages() ...
[16:09:36.166] Searching for globals...
[16:09:36.167] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:36.167] Searching for globals ... DONE
[16:09:36.168] Resolving globals: FALSE
[16:09:36.168] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:36.168] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:36.169] - globals: [1] ‘FUN’
[16:09:36.169] - packages: [1] ‘stats’
[16:09:36.169] getGlobalsAndPackages() ... DONE
[16:09:36.169]  - globals found/used: [n=1] ‘FUN’
[16:09:36.169]  - needed namespaces: [n=1] ‘stats’
[16:09:36.169] Finding globals ... DONE
[16:09:36.169]  - use_args: TRUE
[16:09:36.169]  - Getting '...' globals ...
[16:09:36.170] resolve() on list ...
[16:09:36.170]  recursive: 0
[16:09:36.170]  length: 1
[16:09:36.170]  elements: ‘...’
[16:09:36.170]  length: 0 (resolved future 1)
[16:09:36.170] resolve() on list ... DONE
[16:09:36.170]    - '...' content: [n=0] 
[16:09:36.171] List of 1
[16:09:36.171]  $ ...: list()
[16:09:36.171]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.171]  - attr(*, "where")=List of 1
[16:09:36.171]   ..$ ...:<environment: 0x55b4b7fd5120> 
[16:09:36.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.171]  - attr(*, "resolved")= logi TRUE
[16:09:36.171]  - attr(*, "total_size")= num NA
[16:09:36.176]  - Getting '...' globals ... DONE
[16:09:36.176] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:36.177] List of 2
[16:09:36.177]  $ ...future.FUN:function (x, ...)  
[16:09:36.177]  $ ...          : list()
[16:09:36.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.177]  - attr(*, "where")=List of 2
[16:09:36.177]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:36.177]   ..$ ...          :<environment: 0x55b4b7fd5120> 
[16:09:36.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.177]  - attr(*, "resolved")= logi FALSE
[16:09:36.177]  - attr(*, "total_size")= num 1248
[16:09:36.180] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:36.180] getGlobalsAndPackagesXApply() ... DONE
[16:09:36.180] Number of futures (= number of chunks): 2
[16:09:36.180] Launching 2 futures (chunks) ...
[16:09:36.181] Chunk #1 of 2 ...
[16:09:36.181]  - Finding globals in 'X' for chunk #1 ...
[16:09:36.181] getGlobalsAndPackages() ...
[16:09:36.181] Searching for globals...
[16:09:36.181] 
[16:09:36.181] Searching for globals ... DONE
[16:09:36.181] - globals: [0] <none>
[16:09:36.181] getGlobalsAndPackages() ... DONE
[16:09:36.181]    + additional globals found: [n=0] 
[16:09:36.182]    + additional namespaces needed: [n=0] 
[16:09:36.182]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:36.182]  - seeds: <none>
[16:09:36.182] getGlobalsAndPackages() ...
[16:09:36.182] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.182] Resolving globals: FALSE
[16:09:36.182] Tweak future expression to call with '...' arguments ...
[16:09:36.182] {
[16:09:36.182]     do.call(function(...) {
[16:09:36.182]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.182]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.182]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.182]             on.exit(options(oopts), add = TRUE)
[16:09:36.182]         }
[16:09:36.182]         {
[16:09:36.182]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.182]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.182]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.182]             })
[16:09:36.182]         }
[16:09:36.182]     }, args = future.call.arguments)
[16:09:36.182] }
[16:09:36.183] Tweak future expression to call with '...' arguments ... DONE
[16:09:36.183] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.183] - packages: [1] ‘stats’
[16:09:36.183] getGlobalsAndPackages() ... DONE
[16:09:36.183] run() for ‘Future’ ...
[16:09:36.184] - state: ‘created’
[16:09:36.184] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.187]   - Field: ‘label’
[16:09:36.188]   - Field: ‘local’
[16:09:36.188]   - Field: ‘owner’
[16:09:36.188]   - Field: ‘envir’
[16:09:36.188]   - Field: ‘workers’
[16:09:36.188]   - Field: ‘packages’
[16:09:36.188]   - Field: ‘gc’
[16:09:36.188]   - Field: ‘job’
[16:09:36.188]   - Field: ‘conditions’
[16:09:36.188]   - Field: ‘expr’
[16:09:36.188]   - Field: ‘uuid’
[16:09:36.189]   - Field: ‘seed’
[16:09:36.189]   - Field: ‘version’
[16:09:36.189]   - Field: ‘result’
[16:09:36.189]   - Field: ‘asynchronous’
[16:09:36.189]   - Field: ‘calls’
[16:09:36.189]   - Field: ‘globals’
[16:09:36.189]   - Field: ‘stdout’
[16:09:36.189]   - Field: ‘earlySignal’
[16:09:36.189]   - Field: ‘lazy’
[16:09:36.189]   - Field: ‘state’
[16:09:36.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.190] - Launch lazy future ...
[16:09:36.190] Packages needed by the future expression (n = 1): ‘stats’
[16:09:36.190] Packages needed by future strategies (n = 0): <none>
[16:09:36.191] {
[16:09:36.191]     {
[16:09:36.191]         {
[16:09:36.191]             ...future.startTime <- base::Sys.time()
[16:09:36.191]             {
[16:09:36.191]                 {
[16:09:36.191]                   {
[16:09:36.191]                     {
[16:09:36.191]                       {
[16:09:36.191]                         base::local({
[16:09:36.191]                           has_future <- base::requireNamespace("future", 
[16:09:36.191]                             quietly = TRUE)
[16:09:36.191]                           if (has_future) {
[16:09:36.191]                             ns <- base::getNamespace("future")
[16:09:36.191]                             version <- ns[[".package"]][["version"]]
[16:09:36.191]                             if (is.null(version)) 
[16:09:36.191]                               version <- utils::packageVersion("future")
[16:09:36.191]                           }
[16:09:36.191]                           else {
[16:09:36.191]                             version <- NULL
[16:09:36.191]                           }
[16:09:36.191]                           if (!has_future || version < "1.8.0") {
[16:09:36.191]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.191]                               "", base::R.version$version.string), 
[16:09:36.191]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:36.191]                                 base::R.version$platform, 8 * 
[16:09:36.191]                                   base::.Machine$sizeof.pointer), 
[16:09:36.191]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.191]                                 "release", "version")], collapse = " "), 
[16:09:36.191]                               hostname = base::Sys.info()[["nodename"]])
[16:09:36.191]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.191]                               info)
[16:09:36.191]                             info <- base::paste(info, collapse = "; ")
[16:09:36.191]                             if (!has_future) {
[16:09:36.191]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.191]                                 info)
[16:09:36.191]                             }
[16:09:36.191]                             else {
[16:09:36.191]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.191]                                 info, version)
[16:09:36.191]                             }
[16:09:36.191]                             base::stop(msg)
[16:09:36.191]                           }
[16:09:36.191]                         })
[16:09:36.191]                       }
[16:09:36.191]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.191]                       base::options(mc.cores = 1L)
[16:09:36.191]                     }
[16:09:36.191]                     base::local({
[16:09:36.191]                       for (pkg in "stats") {
[16:09:36.191]                         base::loadNamespace(pkg)
[16:09:36.191]                         base::library(pkg, character.only = TRUE)
[16:09:36.191]                       }
[16:09:36.191]                     })
[16:09:36.191]                   }
[16:09:36.191]                   options(future.plan = NULL)
[16:09:36.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.191]                 }
[16:09:36.191]                 ...future.workdir <- getwd()
[16:09:36.191]             }
[16:09:36.191]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.191]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.191]         }
[16:09:36.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.191]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:36.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.191]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.191]             base::names(...future.oldOptions))
[16:09:36.191]     }
[16:09:36.191]     if (FALSE) {
[16:09:36.191]     }
[16:09:36.191]     else {
[16:09:36.191]         if (TRUE) {
[16:09:36.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.191]                 open = "w")
[16:09:36.191]         }
[16:09:36.191]         else {
[16:09:36.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.191]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.191]         }
[16:09:36.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.191]             base::sink(type = "output", split = FALSE)
[16:09:36.191]             base::close(...future.stdout)
[16:09:36.191]         }, add = TRUE)
[16:09:36.191]     }
[16:09:36.191]     ...future.frame <- base::sys.nframe()
[16:09:36.191]     ...future.conditions <- base::list()
[16:09:36.191]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.191]     if (FALSE) {
[16:09:36.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.191]     }
[16:09:36.191]     ...future.result <- base::tryCatch({
[16:09:36.191]         base::withCallingHandlers({
[16:09:36.191]             ...future.value <- base::withVisible(base::local({
[16:09:36.191]                 withCallingHandlers({
[16:09:36.191]                   {
[16:09:36.191]                     do.call(function(...) {
[16:09:36.191]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.191]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.191]                         ...future.globals.maxSize)) {
[16:09:36.191]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.191]                         on.exit(options(oopts), add = TRUE)
[16:09:36.191]                       }
[16:09:36.191]                       {
[16:09:36.191]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.191]                           FUN = function(jj) {
[16:09:36.191]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.191]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.191]                           })
[16:09:36.191]                       }
[16:09:36.191]                     }, args = future.call.arguments)
[16:09:36.191]                   }
[16:09:36.191]                 }, immediateCondition = function(cond) {
[16:09:36.191]                   save_rds <- function (object, pathname, ...) 
[16:09:36.191]                   {
[16:09:36.191]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.191]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.191]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.191]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.191]                         fi_tmp[["mtime"]])
[16:09:36.191]                     }
[16:09:36.191]                     tryCatch({
[16:09:36.191]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.191]                     }, error = function(ex) {
[16:09:36.191]                       msg <- conditionMessage(ex)
[16:09:36.191]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.191]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.191]                         fi_tmp[["mtime"]], msg)
[16:09:36.191]                       ex$message <- msg
[16:09:36.191]                       stop(ex)
[16:09:36.191]                     })
[16:09:36.191]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.191]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.191]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.191]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.191]                       fi <- file.info(pathname)
[16:09:36.191]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.191]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.191]                         fi[["size"]], fi[["mtime"]])
[16:09:36.191]                       stop(msg)
[16:09:36.191]                     }
[16:09:36.191]                     invisible(pathname)
[16:09:36.191]                   }
[16:09:36.191]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.191]                     rootPath = tempdir()) 
[16:09:36.191]                   {
[16:09:36.191]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.191]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.191]                       tmpdir = path, fileext = ".rds")
[16:09:36.191]                     save_rds(obj, file)
[16:09:36.191]                   }
[16:09:36.191]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.191]                   {
[16:09:36.191]                     inherits <- base::inherits
[16:09:36.191]                     invokeRestart <- base::invokeRestart
[16:09:36.191]                     is.null <- base::is.null
[16:09:36.191]                     muffled <- FALSE
[16:09:36.191]                     if (inherits(cond, "message")) {
[16:09:36.191]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.191]                       if (muffled) 
[16:09:36.191]                         invokeRestart("muffleMessage")
[16:09:36.191]                     }
[16:09:36.191]                     else if (inherits(cond, "warning")) {
[16:09:36.191]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.191]                       if (muffled) 
[16:09:36.191]                         invokeRestart("muffleWarning")
[16:09:36.191]                     }
[16:09:36.191]                     else if (inherits(cond, "condition")) {
[16:09:36.191]                       if (!is.null(pattern)) {
[16:09:36.191]                         computeRestarts <- base::computeRestarts
[16:09:36.191]                         grepl <- base::grepl
[16:09:36.191]                         restarts <- computeRestarts(cond)
[16:09:36.191]                         for (restart in restarts) {
[16:09:36.191]                           name <- restart$name
[16:09:36.191]                           if (is.null(name)) 
[16:09:36.191]                             next
[16:09:36.191]                           if (!grepl(pattern, name)) 
[16:09:36.191]                             next
[16:09:36.191]                           invokeRestart(restart)
[16:09:36.191]                           muffled <- TRUE
[16:09:36.191]                           break
[16:09:36.191]                         }
[16:09:36.191]                       }
[16:09:36.191]                     }
[16:09:36.191]                     invisible(muffled)
[16:09:36.191]                   }
[16:09:36.191]                   muffleCondition(cond)
[16:09:36.191]                 })
[16:09:36.191]             }))
[16:09:36.191]             future::FutureResult(value = ...future.value$value, 
[16:09:36.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.191]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.191]                     ...future.globalenv.names))
[16:09:36.191]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.191]         }, condition = base::local({
[16:09:36.191]             c <- base::c
[16:09:36.191]             inherits <- base::inherits
[16:09:36.191]             invokeRestart <- base::invokeRestart
[16:09:36.191]             length <- base::length
[16:09:36.191]             list <- base::list
[16:09:36.191]             seq.int <- base::seq.int
[16:09:36.191]             signalCondition <- base::signalCondition
[16:09:36.191]             sys.calls <- base::sys.calls
[16:09:36.191]             `[[` <- base::`[[`
[16:09:36.191]             `+` <- base::`+`
[16:09:36.191]             `<<-` <- base::`<<-`
[16:09:36.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.191]                   3L)]
[16:09:36.191]             }
[16:09:36.191]             function(cond) {
[16:09:36.191]                 is_error <- inherits(cond, "error")
[16:09:36.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.191]                   NULL)
[16:09:36.191]                 if (is_error) {
[16:09:36.191]                   sessionInformation <- function() {
[16:09:36.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.191]                       search = base::search(), system = base::Sys.info())
[16:09:36.191]                   }
[16:09:36.191]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.191]                     cond$call), session = sessionInformation(), 
[16:09:36.191]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.191]                   signalCondition(cond)
[16:09:36.191]                 }
[16:09:36.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.191]                 "immediateCondition"))) {
[16:09:36.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.191]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.191]                   if (TRUE && !signal) {
[16:09:36.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.191]                     {
[16:09:36.191]                       inherits <- base::inherits
[16:09:36.191]                       invokeRestart <- base::invokeRestart
[16:09:36.191]                       is.null <- base::is.null
[16:09:36.191]                       muffled <- FALSE
[16:09:36.191]                       if (inherits(cond, "message")) {
[16:09:36.191]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.191]                         if (muffled) 
[16:09:36.191]                           invokeRestart("muffleMessage")
[16:09:36.191]                       }
[16:09:36.191]                       else if (inherits(cond, "warning")) {
[16:09:36.191]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.191]                         if (muffled) 
[16:09:36.191]                           invokeRestart("muffleWarning")
[16:09:36.191]                       }
[16:09:36.191]                       else if (inherits(cond, "condition")) {
[16:09:36.191]                         if (!is.null(pattern)) {
[16:09:36.191]                           computeRestarts <- base::computeRestarts
[16:09:36.191]                           grepl <- base::grepl
[16:09:36.191]                           restarts <- computeRestarts(cond)
[16:09:36.191]                           for (restart in restarts) {
[16:09:36.191]                             name <- restart$name
[16:09:36.191]                             if (is.null(name)) 
[16:09:36.191]                               next
[16:09:36.191]                             if (!grepl(pattern, name)) 
[16:09:36.191]                               next
[16:09:36.191]                             invokeRestart(restart)
[16:09:36.191]                             muffled <- TRUE
[16:09:36.191]                             break
[16:09:36.191]                           }
[16:09:36.191]                         }
[16:09:36.191]                       }
[16:09:36.191]                       invisible(muffled)
[16:09:36.191]                     }
[16:09:36.191]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.191]                   }
[16:09:36.191]                 }
[16:09:36.191]                 else {
[16:09:36.191]                   if (TRUE) {
[16:09:36.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.191]                     {
[16:09:36.191]                       inherits <- base::inherits
[16:09:36.191]                       invokeRestart <- base::invokeRestart
[16:09:36.191]                       is.null <- base::is.null
[16:09:36.191]                       muffled <- FALSE
[16:09:36.191]                       if (inherits(cond, "message")) {
[16:09:36.191]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.191]                         if (muffled) 
[16:09:36.191]                           invokeRestart("muffleMessage")
[16:09:36.191]                       }
[16:09:36.191]                       else if (inherits(cond, "warning")) {
[16:09:36.191]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.191]                         if (muffled) 
[16:09:36.191]                           invokeRestart("muffleWarning")
[16:09:36.191]                       }
[16:09:36.191]                       else if (inherits(cond, "condition")) {
[16:09:36.191]                         if (!is.null(pattern)) {
[16:09:36.191]                           computeRestarts <- base::computeRestarts
[16:09:36.191]                           grepl <- base::grepl
[16:09:36.191]                           restarts <- computeRestarts(cond)
[16:09:36.191]                           for (restart in restarts) {
[16:09:36.191]                             name <- restart$name
[16:09:36.191]                             if (is.null(name)) 
[16:09:36.191]                               next
[16:09:36.191]                             if (!grepl(pattern, name)) 
[16:09:36.191]                               next
[16:09:36.191]                             invokeRestart(restart)
[16:09:36.191]                             muffled <- TRUE
[16:09:36.191]                             break
[16:09:36.191]                           }
[16:09:36.191]                         }
[16:09:36.191]                       }
[16:09:36.191]                       invisible(muffled)
[16:09:36.191]                     }
[16:09:36.191]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.191]                   }
[16:09:36.191]                 }
[16:09:36.191]             }
[16:09:36.191]         }))
[16:09:36.191]     }, error = function(ex) {
[16:09:36.191]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.191]                 ...future.rng), started = ...future.startTime, 
[16:09:36.191]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.191]             version = "1.8"), class = "FutureResult")
[16:09:36.191]     }, finally = {
[16:09:36.191]         if (!identical(...future.workdir, getwd())) 
[16:09:36.191]             setwd(...future.workdir)
[16:09:36.191]         {
[16:09:36.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.191]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.191]             }
[16:09:36.191]             base::options(...future.oldOptions)
[16:09:36.191]             if (.Platform$OS.type == "windows") {
[16:09:36.191]                 old_names <- names(...future.oldEnvVars)
[16:09:36.191]                 envs <- base::Sys.getenv()
[16:09:36.191]                 names <- names(envs)
[16:09:36.191]                 common <- intersect(names, old_names)
[16:09:36.191]                 added <- setdiff(names, old_names)
[16:09:36.191]                 removed <- setdiff(old_names, names)
[16:09:36.191]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.191]                   envs[common]]
[16:09:36.191]                 NAMES <- toupper(changed)
[16:09:36.191]                 args <- list()
[16:09:36.191]                 for (kk in seq_along(NAMES)) {
[16:09:36.191]                   name <- changed[[kk]]
[16:09:36.191]                   NAME <- NAMES[[kk]]
[16:09:36.191]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.191]                     next
[16:09:36.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.191]                 }
[16:09:36.191]                 NAMES <- toupper(added)
[16:09:36.191]                 for (kk in seq_along(NAMES)) {
[16:09:36.191]                   name <- added[[kk]]
[16:09:36.191]                   NAME <- NAMES[[kk]]
[16:09:36.191]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.191]                     next
[16:09:36.191]                   args[[name]] <- ""
[16:09:36.191]                 }
[16:09:36.191]                 NAMES <- toupper(removed)
[16:09:36.191]                 for (kk in seq_along(NAMES)) {
[16:09:36.191]                   name <- removed[[kk]]
[16:09:36.191]                   NAME <- NAMES[[kk]]
[16:09:36.191]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.191]                     next
[16:09:36.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.191]                 }
[16:09:36.191]                 if (length(args) > 0) 
[16:09:36.191]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.191]             }
[16:09:36.191]             else {
[16:09:36.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.191]             }
[16:09:36.191]             {
[16:09:36.191]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.191]                   0L) {
[16:09:36.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.191]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.191]                   base::options(opts)
[16:09:36.191]                 }
[16:09:36.191]                 {
[16:09:36.191]                   {
[16:09:36.191]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.191]                     NULL
[16:09:36.191]                   }
[16:09:36.191]                   options(future.plan = NULL)
[16:09:36.191]                   if (is.na(NA_character_)) 
[16:09:36.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.191]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.191]                     envir = parent.frame()) 
[16:09:36.191]                   {
[16:09:36.191]                     default_workers <- missing(workers)
[16:09:36.191]                     if (is.function(workers)) 
[16:09:36.191]                       workers <- workers()
[16:09:36.191]                     workers <- structure(as.integer(workers), 
[16:09:36.191]                       class = class(workers))
[16:09:36.191]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.191]                       1L)
[16:09:36.191]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.191]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.191]                       if (default_workers) 
[16:09:36.191]                         supportsMulticore(warn = TRUE)
[16:09:36.191]                       return(sequential(..., envir = envir))
[16:09:36.191]                     }
[16:09:36.191]                     oopts <- options(mc.cores = workers)
[16:09:36.191]                     on.exit(options(oopts))
[16:09:36.191]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.191]                       envir = envir)
[16:09:36.191]                     if (!future$lazy) 
[16:09:36.191]                       future <- run(future)
[16:09:36.191]                     invisible(future)
[16:09:36.191]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.191]                 }
[16:09:36.191]             }
[16:09:36.191]         }
[16:09:36.191]     })
[16:09:36.191]     if (TRUE) {
[16:09:36.191]         base::sink(type = "output", split = FALSE)
[16:09:36.191]         if (TRUE) {
[16:09:36.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.191]         }
[16:09:36.191]         else {
[16:09:36.191]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.191]         }
[16:09:36.191]         base::close(...future.stdout)
[16:09:36.191]         ...future.stdout <- NULL
[16:09:36.191]     }
[16:09:36.191]     ...future.result$conditions <- ...future.conditions
[16:09:36.191]     ...future.result$finished <- base::Sys.time()
[16:09:36.191]     ...future.result
[16:09:36.191] }
[16:09:36.193] assign_globals() ...
[16:09:36.193] List of 5
[16:09:36.193]  $ ...future.FUN            :function (x, ...)  
[16:09:36.193]  $ future.call.arguments    : list()
[16:09:36.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.193]  $ ...future.elements_ii    :List of 1
[16:09:36.193]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:09:36.193]  $ ...future.seeds_ii       : NULL
[16:09:36.193]  $ ...future.globals.maxSize: NULL
[16:09:36.193]  - attr(*, "where")=List of 5
[16:09:36.193]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.193]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.193]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.193]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.193]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.193]  - attr(*, "resolved")= logi FALSE
[16:09:36.193]  - attr(*, "total_size")= num 1248
[16:09:36.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.193]  - attr(*, "already-done")= logi TRUE
[16:09:36.198] - copied ‘...future.FUN’ to environment
[16:09:36.198] - copied ‘future.call.arguments’ to environment
[16:09:36.198] - copied ‘...future.elements_ii’ to environment
[16:09:36.198] - copied ‘...future.seeds_ii’ to environment
[16:09:36.198] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.199] assign_globals() ... done
[16:09:36.199] requestCore(): workers = 2
[16:09:36.201] MulticoreFuture started
[16:09:36.201] - Launch lazy future ... done
[16:09:36.201] run() for ‘MulticoreFuture’ ... done
[16:09:36.201] Created future:
[16:09:36.202] plan(): Setting new future strategy stack:
[16:09:36.202] List of future strategies:
[16:09:36.202] 1. sequential:
[16:09:36.202]    - args: function (..., envir = parent.frame())
[16:09:36.202]    - tweaked: FALSE
[16:09:36.202]    - call: NULL
[16:09:36.207] plan(): nbrOfWorkers() = 1
[16:09:36.209] plan(): Setting new future strategy stack:
[16:09:36.209] List of future strategies:
[16:09:36.209] 1. multicore:
[16:09:36.209]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.209]    - tweaked: FALSE
[16:09:36.209]    - call: plan(strategy)
[16:09:36.215] plan(): nbrOfWorkers() = 2
[16:09:36.202] MulticoreFuture:
[16:09:36.202] Label: ‘future_eapply-1’
[16:09:36.202] Expression:
[16:09:36.202] {
[16:09:36.202]     do.call(function(...) {
[16:09:36.202]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.202]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.202]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.202]             on.exit(options(oopts), add = TRUE)
[16:09:36.202]         }
[16:09:36.202]         {
[16:09:36.202]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.202]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.202]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.202]             })
[16:09:36.202]         }
[16:09:36.202]     }, args = future.call.arguments)
[16:09:36.202] }
[16:09:36.202] Lazy evaluation: FALSE
[16:09:36.202] Asynchronous evaluation: TRUE
[16:09:36.202] Local evaluation: TRUE
[16:09:36.202] Environment: R_GlobalEnv
[16:09:36.202] Capture standard output: TRUE
[16:09:36.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.202] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.202] Packages: 1 packages (‘stats’)
[16:09:36.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.202] Resolved: TRUE
[16:09:36.202] Value: <not collected>
[16:09:36.202] Conditions captured: <none>
[16:09:36.202] Early signaling: FALSE
[16:09:36.202] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.202] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.216] Chunk #1 of 2 ... DONE
[16:09:36.216] Chunk #2 of 2 ...
[16:09:36.217]  - Finding globals in 'X' for chunk #2 ...
[16:09:36.217] getGlobalsAndPackages() ...
[16:09:36.217] Searching for globals...
[16:09:36.218] 
[16:09:36.218] Searching for globals ... DONE
[16:09:36.218] - globals: [0] <none>
[16:09:36.218] getGlobalsAndPackages() ... DONE
[16:09:36.218]    + additional globals found: [n=0] 
[16:09:36.218]    + additional namespaces needed: [n=0] 
[16:09:36.219]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:36.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:36.219]  - seeds: <none>
[16:09:36.219] getGlobalsAndPackages() ...
[16:09:36.219] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.219] Resolving globals: FALSE
[16:09:36.220] Tweak future expression to call with '...' arguments ...
[16:09:36.220] {
[16:09:36.220]     do.call(function(...) {
[16:09:36.220]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.220]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.220]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.220]             on.exit(options(oopts), add = TRUE)
[16:09:36.220]         }
[16:09:36.220]         {
[16:09:36.220]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.220]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.220]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.220]             })
[16:09:36.220]         }
[16:09:36.220]     }, args = future.call.arguments)
[16:09:36.220] }
[16:09:36.220] Tweak future expression to call with '...' arguments ... DONE
[16:09:36.221] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.221] - packages: [1] ‘stats’
[16:09:36.222] getGlobalsAndPackages() ... DONE
[16:09:36.222] run() for ‘Future’ ...
[16:09:36.222] - state: ‘created’
[16:09:36.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.227] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.228]   - Field: ‘label’
[16:09:36.228]   - Field: ‘local’
[16:09:36.228]   - Field: ‘owner’
[16:09:36.228]   - Field: ‘envir’
[16:09:36.228]   - Field: ‘workers’
[16:09:36.228]   - Field: ‘packages’
[16:09:36.228]   - Field: ‘gc’
[16:09:36.229]   - Field: ‘job’
[16:09:36.229]   - Field: ‘conditions’
[16:09:36.229]   - Field: ‘expr’
[16:09:36.229]   - Field: ‘uuid’
[16:09:36.229]   - Field: ‘seed’
[16:09:36.229]   - Field: ‘version’
[16:09:36.229]   - Field: ‘result’
[16:09:36.230]   - Field: ‘asynchronous’
[16:09:36.230]   - Field: ‘calls’
[16:09:36.230]   - Field: ‘globals’
[16:09:36.230]   - Field: ‘stdout’
[16:09:36.230]   - Field: ‘earlySignal’
[16:09:36.230]   - Field: ‘lazy’
[16:09:36.230]   - Field: ‘state’
[16:09:36.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.231] - Launch lazy future ...
[16:09:36.231] Packages needed by the future expression (n = 1): ‘stats’
[16:09:36.231] Packages needed by future strategies (n = 0): <none>
[16:09:36.232] {
[16:09:36.232]     {
[16:09:36.232]         {
[16:09:36.232]             ...future.startTime <- base::Sys.time()
[16:09:36.232]             {
[16:09:36.232]                 {
[16:09:36.232]                   {
[16:09:36.232]                     {
[16:09:36.232]                       {
[16:09:36.232]                         base::local({
[16:09:36.232]                           has_future <- base::requireNamespace("future", 
[16:09:36.232]                             quietly = TRUE)
[16:09:36.232]                           if (has_future) {
[16:09:36.232]                             ns <- base::getNamespace("future")
[16:09:36.232]                             version <- ns[[".package"]][["version"]]
[16:09:36.232]                             if (is.null(version)) 
[16:09:36.232]                               version <- utils::packageVersion("future")
[16:09:36.232]                           }
[16:09:36.232]                           else {
[16:09:36.232]                             version <- NULL
[16:09:36.232]                           }
[16:09:36.232]                           if (!has_future || version < "1.8.0") {
[16:09:36.232]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.232]                               "", base::R.version$version.string), 
[16:09:36.232]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:36.232]                                 base::R.version$platform, 8 * 
[16:09:36.232]                                   base::.Machine$sizeof.pointer), 
[16:09:36.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.232]                                 "release", "version")], collapse = " "), 
[16:09:36.232]                               hostname = base::Sys.info()[["nodename"]])
[16:09:36.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.232]                               info)
[16:09:36.232]                             info <- base::paste(info, collapse = "; ")
[16:09:36.232]                             if (!has_future) {
[16:09:36.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.232]                                 info)
[16:09:36.232]                             }
[16:09:36.232]                             else {
[16:09:36.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.232]                                 info, version)
[16:09:36.232]                             }
[16:09:36.232]                             base::stop(msg)
[16:09:36.232]                           }
[16:09:36.232]                         })
[16:09:36.232]                       }
[16:09:36.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.232]                       base::options(mc.cores = 1L)
[16:09:36.232]                     }
[16:09:36.232]                     base::local({
[16:09:36.232]                       for (pkg in "stats") {
[16:09:36.232]                         base::loadNamespace(pkg)
[16:09:36.232]                         base::library(pkg, character.only = TRUE)
[16:09:36.232]                       }
[16:09:36.232]                     })
[16:09:36.232]                   }
[16:09:36.232]                   options(future.plan = NULL)
[16:09:36.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.232]                 }
[16:09:36.232]                 ...future.workdir <- getwd()
[16:09:36.232]             }
[16:09:36.232]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.232]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.232]         }
[16:09:36.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.232]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:36.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.232]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.232]             base::names(...future.oldOptions))
[16:09:36.232]     }
[16:09:36.232]     if (FALSE) {
[16:09:36.232]     }
[16:09:36.232]     else {
[16:09:36.232]         if (TRUE) {
[16:09:36.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.232]                 open = "w")
[16:09:36.232]         }
[16:09:36.232]         else {
[16:09:36.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.232]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.232]         }
[16:09:36.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.232]             base::sink(type = "output", split = FALSE)
[16:09:36.232]             base::close(...future.stdout)
[16:09:36.232]         }, add = TRUE)
[16:09:36.232]     }
[16:09:36.232]     ...future.frame <- base::sys.nframe()
[16:09:36.232]     ...future.conditions <- base::list()
[16:09:36.232]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.232]     if (FALSE) {
[16:09:36.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.232]     }
[16:09:36.232]     ...future.result <- base::tryCatch({
[16:09:36.232]         base::withCallingHandlers({
[16:09:36.232]             ...future.value <- base::withVisible(base::local({
[16:09:36.232]                 withCallingHandlers({
[16:09:36.232]                   {
[16:09:36.232]                     do.call(function(...) {
[16:09:36.232]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.232]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.232]                         ...future.globals.maxSize)) {
[16:09:36.232]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.232]                         on.exit(options(oopts), add = TRUE)
[16:09:36.232]                       }
[16:09:36.232]                       {
[16:09:36.232]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.232]                           FUN = function(jj) {
[16:09:36.232]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.232]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.232]                           })
[16:09:36.232]                       }
[16:09:36.232]                     }, args = future.call.arguments)
[16:09:36.232]                   }
[16:09:36.232]                 }, immediateCondition = function(cond) {
[16:09:36.232]                   save_rds <- function (object, pathname, ...) 
[16:09:36.232]                   {
[16:09:36.232]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.232]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.232]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.232]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.232]                         fi_tmp[["mtime"]])
[16:09:36.232]                     }
[16:09:36.232]                     tryCatch({
[16:09:36.232]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.232]                     }, error = function(ex) {
[16:09:36.232]                       msg <- conditionMessage(ex)
[16:09:36.232]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.232]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.232]                         fi_tmp[["mtime"]], msg)
[16:09:36.232]                       ex$message <- msg
[16:09:36.232]                       stop(ex)
[16:09:36.232]                     })
[16:09:36.232]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.232]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.232]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.232]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.232]                       fi <- file.info(pathname)
[16:09:36.232]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.232]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.232]                         fi[["size"]], fi[["mtime"]])
[16:09:36.232]                       stop(msg)
[16:09:36.232]                     }
[16:09:36.232]                     invisible(pathname)
[16:09:36.232]                   }
[16:09:36.232]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.232]                     rootPath = tempdir()) 
[16:09:36.232]                   {
[16:09:36.232]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.232]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.232]                       tmpdir = path, fileext = ".rds")
[16:09:36.232]                     save_rds(obj, file)
[16:09:36.232]                   }
[16:09:36.232]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.232]                   {
[16:09:36.232]                     inherits <- base::inherits
[16:09:36.232]                     invokeRestart <- base::invokeRestart
[16:09:36.232]                     is.null <- base::is.null
[16:09:36.232]                     muffled <- FALSE
[16:09:36.232]                     if (inherits(cond, "message")) {
[16:09:36.232]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.232]                       if (muffled) 
[16:09:36.232]                         invokeRestart("muffleMessage")
[16:09:36.232]                     }
[16:09:36.232]                     else if (inherits(cond, "warning")) {
[16:09:36.232]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.232]                       if (muffled) 
[16:09:36.232]                         invokeRestart("muffleWarning")
[16:09:36.232]                     }
[16:09:36.232]                     else if (inherits(cond, "condition")) {
[16:09:36.232]                       if (!is.null(pattern)) {
[16:09:36.232]                         computeRestarts <- base::computeRestarts
[16:09:36.232]                         grepl <- base::grepl
[16:09:36.232]                         restarts <- computeRestarts(cond)
[16:09:36.232]                         for (restart in restarts) {
[16:09:36.232]                           name <- restart$name
[16:09:36.232]                           if (is.null(name)) 
[16:09:36.232]                             next
[16:09:36.232]                           if (!grepl(pattern, name)) 
[16:09:36.232]                             next
[16:09:36.232]                           invokeRestart(restart)
[16:09:36.232]                           muffled <- TRUE
[16:09:36.232]                           break
[16:09:36.232]                         }
[16:09:36.232]                       }
[16:09:36.232]                     }
[16:09:36.232]                     invisible(muffled)
[16:09:36.232]                   }
[16:09:36.232]                   muffleCondition(cond)
[16:09:36.232]                 })
[16:09:36.232]             }))
[16:09:36.232]             future::FutureResult(value = ...future.value$value, 
[16:09:36.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.232]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.232]                     ...future.globalenv.names))
[16:09:36.232]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.232]         }, condition = base::local({
[16:09:36.232]             c <- base::c
[16:09:36.232]             inherits <- base::inherits
[16:09:36.232]             invokeRestart <- base::invokeRestart
[16:09:36.232]             length <- base::length
[16:09:36.232]             list <- base::list
[16:09:36.232]             seq.int <- base::seq.int
[16:09:36.232]             signalCondition <- base::signalCondition
[16:09:36.232]             sys.calls <- base::sys.calls
[16:09:36.232]             `[[` <- base::`[[`
[16:09:36.232]             `+` <- base::`+`
[16:09:36.232]             `<<-` <- base::`<<-`
[16:09:36.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.232]                   3L)]
[16:09:36.232]             }
[16:09:36.232]             function(cond) {
[16:09:36.232]                 is_error <- inherits(cond, "error")
[16:09:36.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.232]                   NULL)
[16:09:36.232]                 if (is_error) {
[16:09:36.232]                   sessionInformation <- function() {
[16:09:36.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.232]                       search = base::search(), system = base::Sys.info())
[16:09:36.232]                   }
[16:09:36.232]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.232]                     cond$call), session = sessionInformation(), 
[16:09:36.232]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.232]                   signalCondition(cond)
[16:09:36.232]                 }
[16:09:36.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.232]                 "immediateCondition"))) {
[16:09:36.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.232]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.232]                   if (TRUE && !signal) {
[16:09:36.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.232]                     {
[16:09:36.232]                       inherits <- base::inherits
[16:09:36.232]                       invokeRestart <- base::invokeRestart
[16:09:36.232]                       is.null <- base::is.null
[16:09:36.232]                       muffled <- FALSE
[16:09:36.232]                       if (inherits(cond, "message")) {
[16:09:36.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.232]                         if (muffled) 
[16:09:36.232]                           invokeRestart("muffleMessage")
[16:09:36.232]                       }
[16:09:36.232]                       else if (inherits(cond, "warning")) {
[16:09:36.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.232]                         if (muffled) 
[16:09:36.232]                           invokeRestart("muffleWarning")
[16:09:36.232]                       }
[16:09:36.232]                       else if (inherits(cond, "condition")) {
[16:09:36.232]                         if (!is.null(pattern)) {
[16:09:36.232]                           computeRestarts <- base::computeRestarts
[16:09:36.232]                           grepl <- base::grepl
[16:09:36.232]                           restarts <- computeRestarts(cond)
[16:09:36.232]                           for (restart in restarts) {
[16:09:36.232]                             name <- restart$name
[16:09:36.232]                             if (is.null(name)) 
[16:09:36.232]                               next
[16:09:36.232]                             if (!grepl(pattern, name)) 
[16:09:36.232]                               next
[16:09:36.232]                             invokeRestart(restart)
[16:09:36.232]                             muffled <- TRUE
[16:09:36.232]                             break
[16:09:36.232]                           }
[16:09:36.232]                         }
[16:09:36.232]                       }
[16:09:36.232]                       invisible(muffled)
[16:09:36.232]                     }
[16:09:36.232]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.232]                   }
[16:09:36.232]                 }
[16:09:36.232]                 else {
[16:09:36.232]                   if (TRUE) {
[16:09:36.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.232]                     {
[16:09:36.232]                       inherits <- base::inherits
[16:09:36.232]                       invokeRestart <- base::invokeRestart
[16:09:36.232]                       is.null <- base::is.null
[16:09:36.232]                       muffled <- FALSE
[16:09:36.232]                       if (inherits(cond, "message")) {
[16:09:36.232]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.232]                         if (muffled) 
[16:09:36.232]                           invokeRestart("muffleMessage")
[16:09:36.232]                       }
[16:09:36.232]                       else if (inherits(cond, "warning")) {
[16:09:36.232]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.232]                         if (muffled) 
[16:09:36.232]                           invokeRestart("muffleWarning")
[16:09:36.232]                       }
[16:09:36.232]                       else if (inherits(cond, "condition")) {
[16:09:36.232]                         if (!is.null(pattern)) {
[16:09:36.232]                           computeRestarts <- base::computeRestarts
[16:09:36.232]                           grepl <- base::grepl
[16:09:36.232]                           restarts <- computeRestarts(cond)
[16:09:36.232]                           for (restart in restarts) {
[16:09:36.232]                             name <- restart$name
[16:09:36.232]                             if (is.null(name)) 
[16:09:36.232]                               next
[16:09:36.232]                             if (!grepl(pattern, name)) 
[16:09:36.232]                               next
[16:09:36.232]                             invokeRestart(restart)
[16:09:36.232]                             muffled <- TRUE
[16:09:36.232]                             break
[16:09:36.232]                           }
[16:09:36.232]                         }
[16:09:36.232]                       }
[16:09:36.232]                       invisible(muffled)
[16:09:36.232]                     }
[16:09:36.232]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.232]                   }
[16:09:36.232]                 }
[16:09:36.232]             }
[16:09:36.232]         }))
[16:09:36.232]     }, error = function(ex) {
[16:09:36.232]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.232]                 ...future.rng), started = ...future.startTime, 
[16:09:36.232]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.232]             version = "1.8"), class = "FutureResult")
[16:09:36.232]     }, finally = {
[16:09:36.232]         if (!identical(...future.workdir, getwd())) 
[16:09:36.232]             setwd(...future.workdir)
[16:09:36.232]         {
[16:09:36.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.232]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.232]             }
[16:09:36.232]             base::options(...future.oldOptions)
[16:09:36.232]             if (.Platform$OS.type == "windows") {
[16:09:36.232]                 old_names <- names(...future.oldEnvVars)
[16:09:36.232]                 envs <- base::Sys.getenv()
[16:09:36.232]                 names <- names(envs)
[16:09:36.232]                 common <- intersect(names, old_names)
[16:09:36.232]                 added <- setdiff(names, old_names)
[16:09:36.232]                 removed <- setdiff(old_names, names)
[16:09:36.232]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.232]                   envs[common]]
[16:09:36.232]                 NAMES <- toupper(changed)
[16:09:36.232]                 args <- list()
[16:09:36.232]                 for (kk in seq_along(NAMES)) {
[16:09:36.232]                   name <- changed[[kk]]
[16:09:36.232]                   NAME <- NAMES[[kk]]
[16:09:36.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.232]                     next
[16:09:36.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.232]                 }
[16:09:36.232]                 NAMES <- toupper(added)
[16:09:36.232]                 for (kk in seq_along(NAMES)) {
[16:09:36.232]                   name <- added[[kk]]
[16:09:36.232]                   NAME <- NAMES[[kk]]
[16:09:36.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.232]                     next
[16:09:36.232]                   args[[name]] <- ""
[16:09:36.232]                 }
[16:09:36.232]                 NAMES <- toupper(removed)
[16:09:36.232]                 for (kk in seq_along(NAMES)) {
[16:09:36.232]                   name <- removed[[kk]]
[16:09:36.232]                   NAME <- NAMES[[kk]]
[16:09:36.232]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.232]                     next
[16:09:36.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.232]                 }
[16:09:36.232]                 if (length(args) > 0) 
[16:09:36.232]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.232]             }
[16:09:36.232]             else {
[16:09:36.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.232]             }
[16:09:36.232]             {
[16:09:36.232]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.232]                   0L) {
[16:09:36.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.232]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.232]                   base::options(opts)
[16:09:36.232]                 }
[16:09:36.232]                 {
[16:09:36.232]                   {
[16:09:36.232]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.232]                     NULL
[16:09:36.232]                   }
[16:09:36.232]                   options(future.plan = NULL)
[16:09:36.232]                   if (is.na(NA_character_)) 
[16:09:36.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.232]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.232]                     envir = parent.frame()) 
[16:09:36.232]                   {
[16:09:36.232]                     default_workers <- missing(workers)
[16:09:36.232]                     if (is.function(workers)) 
[16:09:36.232]                       workers <- workers()
[16:09:36.232]                     workers <- structure(as.integer(workers), 
[16:09:36.232]                       class = class(workers))
[16:09:36.232]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.232]                       1L)
[16:09:36.232]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.232]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.232]                       if (default_workers) 
[16:09:36.232]                         supportsMulticore(warn = TRUE)
[16:09:36.232]                       return(sequential(..., envir = envir))
[16:09:36.232]                     }
[16:09:36.232]                     oopts <- options(mc.cores = workers)
[16:09:36.232]                     on.exit(options(oopts))
[16:09:36.232]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.232]                       envir = envir)
[16:09:36.232]                     if (!future$lazy) 
[16:09:36.232]                       future <- run(future)
[16:09:36.232]                     invisible(future)
[16:09:36.232]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.232]                 }
[16:09:36.232]             }
[16:09:36.232]         }
[16:09:36.232]     })
[16:09:36.232]     if (TRUE) {
[16:09:36.232]         base::sink(type = "output", split = FALSE)
[16:09:36.232]         if (TRUE) {
[16:09:36.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.232]         }
[16:09:36.232]         else {
[16:09:36.232]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.232]         }
[16:09:36.232]         base::close(...future.stdout)
[16:09:36.232]         ...future.stdout <- NULL
[16:09:36.232]     }
[16:09:36.232]     ...future.result$conditions <- ...future.conditions
[16:09:36.232]     ...future.result$finished <- base::Sys.time()
[16:09:36.232]     ...future.result
[16:09:36.232] }
[16:09:36.235] assign_globals() ...
[16:09:36.235] List of 5
[16:09:36.235]  $ ...future.FUN            :function (x, ...)  
[16:09:36.235]  $ future.call.arguments    : list()
[16:09:36.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.235]  $ ...future.elements_ii    :List of 2
[16:09:36.235]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:36.235]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:36.235]  $ ...future.seeds_ii       : NULL
[16:09:36.235]  $ ...future.globals.maxSize: NULL
[16:09:36.235]  - attr(*, "resolved")= logi FALSE
[16:09:36.235]  - attr(*, "total_size")= num 1248
[16:09:36.235]  - attr(*, "where")=List of 5
[16:09:36.235]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.235]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.235]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.235]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.235]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.235]  - attr(*, "already-done")= logi TRUE
[16:09:36.243] - copied ‘...future.FUN’ to environment
[16:09:36.243] - copied ‘future.call.arguments’ to environment
[16:09:36.243] - copied ‘...future.elements_ii’ to environment
[16:09:36.243] - copied ‘...future.seeds_ii’ to environment
[16:09:36.244] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.244] assign_globals() ... done
[16:09:36.244] requestCore(): workers = 2
[16:09:36.246] MulticoreFuture started
[16:09:36.247] - Launch lazy future ... done
[16:09:36.247] run() for ‘MulticoreFuture’ ... done
[16:09:36.247] Created future:
[16:09:36.248] plan(): Setting new future strategy stack:
[16:09:36.248] List of future strategies:
[16:09:36.248] 1. sequential:
[16:09:36.248]    - args: function (..., envir = parent.frame())
[16:09:36.248]    - tweaked: FALSE
[16:09:36.248]    - call: NULL
[16:09:36.249] plan(): nbrOfWorkers() = 1
[16:09:36.252] plan(): Setting new future strategy stack:
[16:09:36.252] List of future strategies:
[16:09:36.252] 1. multicore:
[16:09:36.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.252]    - tweaked: FALSE
[16:09:36.252]    - call: plan(strategy)
[16:09:36.258] plan(): nbrOfWorkers() = 2
[16:09:36.247] MulticoreFuture:
[16:09:36.247] Label: ‘future_eapply-2’
[16:09:36.247] Expression:
[16:09:36.247] {
[16:09:36.247]     do.call(function(...) {
[16:09:36.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.247]             on.exit(options(oopts), add = TRUE)
[16:09:36.247]         }
[16:09:36.247]         {
[16:09:36.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.247]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.247]             })
[16:09:36.247]         }
[16:09:36.247]     }, args = future.call.arguments)
[16:09:36.247] }
[16:09:36.247] Lazy evaluation: FALSE
[16:09:36.247] Asynchronous evaluation: TRUE
[16:09:36.247] Local evaluation: TRUE
[16:09:36.247] Environment: R_GlobalEnv
[16:09:36.247] Capture standard output: TRUE
[16:09:36.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.247] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.247] Packages: 1 packages (‘stats’)
[16:09:36.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.247] Resolved: TRUE
[16:09:36.247] Value: <not collected>
[16:09:36.247] Conditions captured: <none>
[16:09:36.247] Early signaling: FALSE
[16:09:36.247] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.247] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.259] Chunk #2 of 2 ... DONE
[16:09:36.259] Launching 2 futures (chunks) ... DONE
[16:09:36.259] Resolving 2 futures (chunks) ...
[16:09:36.259] resolve() on list ...
[16:09:36.260]  recursive: 0
[16:09:36.260]  length: 2
[16:09:36.260] 
[16:09:36.260] Future #1
[16:09:36.261] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:36.261] - nx: 2
[16:09:36.262] - relay: TRUE
[16:09:36.262] - stdout: TRUE
[16:09:36.262] - signal: TRUE
[16:09:36.262] - resignal: FALSE
[16:09:36.262] - force: TRUE
[16:09:36.262] - relayed: [n=2] FALSE, FALSE
[16:09:36.262] - queued futures: [n=2] FALSE, FALSE
[16:09:36.262]  - until=1
[16:09:36.263]  - relaying element #1
[16:09:36.263] - relayed: [n=2] TRUE, FALSE
[16:09:36.263] - queued futures: [n=2] TRUE, FALSE
[16:09:36.263] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:36.263]  length: 1 (resolved future 1)
[16:09:36.264] Future #2
[16:09:36.265] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:36.265] - nx: 2
[16:09:36.265] - relay: TRUE
[16:09:36.268] - stdout: TRUE
[16:09:36.269] - signal: TRUE
[16:09:36.269] - resignal: FALSE
[16:09:36.269] - force: TRUE
[16:09:36.269] - relayed: [n=2] TRUE, FALSE
[16:09:36.269] - queued futures: [n=2] TRUE, FALSE
[16:09:36.269]  - until=2
[16:09:36.269]  - relaying element #2
[16:09:36.270] - relayed: [n=2] TRUE, TRUE
[16:09:36.270] - queued futures: [n=2] TRUE, TRUE
[16:09:36.270] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:36.270]  length: 0 (resolved future 2)
[16:09:36.270] Relaying remaining futures
[16:09:36.270] signalConditionsASAP(NULL, pos=0) ...
[16:09:36.271] - nx: 2
[16:09:36.271] - relay: TRUE
[16:09:36.271] - stdout: TRUE
[16:09:36.271] - signal: TRUE
[16:09:36.271] - resignal: FALSE
[16:09:36.271] - force: TRUE
[16:09:36.271] - relayed: [n=2] TRUE, TRUE
[16:09:36.271] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:36.271] - relayed: [n=2] TRUE, TRUE
[16:09:36.272] - queued futures: [n=2] TRUE, TRUE
[16:09:36.272] signalConditionsASAP(NULL, pos=0) ... done
[16:09:36.272] resolve() on list ... DONE
[16:09:36.272]  - Number of value chunks collected: 2
[16:09:36.272] Resolving 2 futures (chunks) ... DONE
[16:09:36.272] Reducing values from 2 chunks ...
[16:09:36.273]  - Number of values collected after concatenation: 3
[16:09:36.273]  - Number of values expected: 3
[16:09:36.273] Reducing values from 2 chunks ... DONE
[16:09:36.273] future_lapply() ... DONE
[16:09:36.273] future_lapply() ...
[16:09:36.278] Number of chunks: 2
[16:09:36.278] getGlobalsAndPackagesXApply() ...
[16:09:36.278]  - future.globals: TRUE
[16:09:36.278] getGlobalsAndPackages() ...
[16:09:36.279] Searching for globals...
[16:09:36.280] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:36.280] Searching for globals ... DONE
[16:09:36.280] Resolving globals: FALSE
[16:09:36.281] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:36.281] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:36.281] - globals: [1] ‘FUN’
[16:09:36.281] - packages: [1] ‘stats’
[16:09:36.281] getGlobalsAndPackages() ... DONE
[16:09:36.282]  - globals found/used: [n=1] ‘FUN’
[16:09:36.282]  - needed namespaces: [n=1] ‘stats’
[16:09:36.282] Finding globals ... DONE
[16:09:36.282]  - use_args: TRUE
[16:09:36.282]  - Getting '...' globals ...
[16:09:36.282] resolve() on list ...
[16:09:36.283]  recursive: 0
[16:09:36.283]  length: 1
[16:09:36.283]  elements: ‘...’
[16:09:36.283]  length: 0 (resolved future 1)
[16:09:36.283] resolve() on list ... DONE
[16:09:36.283]    - '...' content: [n=0] 
[16:09:36.283] List of 1
[16:09:36.283]  $ ...: list()
[16:09:36.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.283]  - attr(*, "where")=List of 1
[16:09:36.283]   ..$ ...:<environment: 0x55b4b68e8e08> 
[16:09:36.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.283]  - attr(*, "resolved")= logi TRUE
[16:09:36.283]  - attr(*, "total_size")= num NA
[16:09:36.286]  - Getting '...' globals ... DONE
[16:09:36.287] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:36.287] List of 2
[16:09:36.287]  $ ...future.FUN:function (x, ...)  
[16:09:36.287]  $ ...          : list()
[16:09:36.287]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.287]  - attr(*, "where")=List of 2
[16:09:36.287]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:36.287]   ..$ ...          :<environment: 0x55b4b68e8e08> 
[16:09:36.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.287]  - attr(*, "resolved")= logi FALSE
[16:09:36.287]  - attr(*, "total_size")= num 1248
[16:09:36.290] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:36.290] getGlobalsAndPackagesXApply() ... DONE
[16:09:36.290] Number of futures (= number of chunks): 2
[16:09:36.290] Launching 2 futures (chunks) ...
[16:09:36.290] Chunk #1 of 2 ...
[16:09:36.290]  - Finding globals in 'X' for chunk #1 ...
[16:09:36.291] getGlobalsAndPackages() ...
[16:09:36.291] Searching for globals...
[16:09:36.291] 
[16:09:36.291] Searching for globals ... DONE
[16:09:36.291] - globals: [0] <none>
[16:09:36.291] getGlobalsAndPackages() ... DONE
[16:09:36.291]    + additional globals found: [n=0] 
[16:09:36.291]    + additional namespaces needed: [n=0] 
[16:09:36.291]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:36.292]  - seeds: <none>
[16:09:36.292] getGlobalsAndPackages() ...
[16:09:36.292] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.292] Resolving globals: FALSE
[16:09:36.292] Tweak future expression to call with '...' arguments ...
[16:09:36.292] {
[16:09:36.292]     do.call(function(...) {
[16:09:36.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.292]             on.exit(options(oopts), add = TRUE)
[16:09:36.292]         }
[16:09:36.292]         {
[16:09:36.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.292]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.292]             })
[16:09:36.292]         }
[16:09:36.292]     }, args = future.call.arguments)
[16:09:36.292] }
[16:09:36.292] Tweak future expression to call with '...' arguments ... DONE
[16:09:36.293] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.293] - packages: [1] ‘stats’
[16:09:36.293] getGlobalsAndPackages() ... DONE
[16:09:36.293] run() for ‘Future’ ...
[16:09:36.293] - state: ‘created’
[16:09:36.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.299] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.299]   - Field: ‘label’
[16:09:36.299]   - Field: ‘local’
[16:09:36.299]   - Field: ‘owner’
[16:09:36.300]   - Field: ‘envir’
[16:09:36.300]   - Field: ‘workers’
[16:09:36.300]   - Field: ‘packages’
[16:09:36.300]   - Field: ‘gc’
[16:09:36.300]   - Field: ‘job’
[16:09:36.300]   - Field: ‘conditions’
[16:09:36.300]   - Field: ‘expr’
[16:09:36.300]   - Field: ‘uuid’
[16:09:36.300]   - Field: ‘seed’
[16:09:36.300]   - Field: ‘version’
[16:09:36.301]   - Field: ‘result’
[16:09:36.301]   - Field: ‘asynchronous’
[16:09:36.301]   - Field: ‘calls’
[16:09:36.301]   - Field: ‘globals’
[16:09:36.301]   - Field: ‘stdout’
[16:09:36.301]   - Field: ‘earlySignal’
[16:09:36.301]   - Field: ‘lazy’
[16:09:36.301]   - Field: ‘state’
[16:09:36.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.301] - Launch lazy future ...
[16:09:36.302] Packages needed by the future expression (n = 1): ‘stats’
[16:09:36.302] Packages needed by future strategies (n = 0): <none>
[16:09:36.302] {
[16:09:36.302]     {
[16:09:36.302]         {
[16:09:36.302]             ...future.startTime <- base::Sys.time()
[16:09:36.302]             {
[16:09:36.302]                 {
[16:09:36.302]                   {
[16:09:36.302]                     {
[16:09:36.302]                       {
[16:09:36.302]                         base::local({
[16:09:36.302]                           has_future <- base::requireNamespace("future", 
[16:09:36.302]                             quietly = TRUE)
[16:09:36.302]                           if (has_future) {
[16:09:36.302]                             ns <- base::getNamespace("future")
[16:09:36.302]                             version <- ns[[".package"]][["version"]]
[16:09:36.302]                             if (is.null(version)) 
[16:09:36.302]                               version <- utils::packageVersion("future")
[16:09:36.302]                           }
[16:09:36.302]                           else {
[16:09:36.302]                             version <- NULL
[16:09:36.302]                           }
[16:09:36.302]                           if (!has_future || version < "1.8.0") {
[16:09:36.302]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.302]                               "", base::R.version$version.string), 
[16:09:36.302]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:36.302]                                 base::R.version$platform, 8 * 
[16:09:36.302]                                   base::.Machine$sizeof.pointer), 
[16:09:36.302]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.302]                                 "release", "version")], collapse = " "), 
[16:09:36.302]                               hostname = base::Sys.info()[["nodename"]])
[16:09:36.302]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.302]                               info)
[16:09:36.302]                             info <- base::paste(info, collapse = "; ")
[16:09:36.302]                             if (!has_future) {
[16:09:36.302]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.302]                                 info)
[16:09:36.302]                             }
[16:09:36.302]                             else {
[16:09:36.302]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.302]                                 info, version)
[16:09:36.302]                             }
[16:09:36.302]                             base::stop(msg)
[16:09:36.302]                           }
[16:09:36.302]                         })
[16:09:36.302]                       }
[16:09:36.302]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.302]                       base::options(mc.cores = 1L)
[16:09:36.302]                     }
[16:09:36.302]                     base::local({
[16:09:36.302]                       for (pkg in "stats") {
[16:09:36.302]                         base::loadNamespace(pkg)
[16:09:36.302]                         base::library(pkg, character.only = TRUE)
[16:09:36.302]                       }
[16:09:36.302]                     })
[16:09:36.302]                   }
[16:09:36.302]                   options(future.plan = NULL)
[16:09:36.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.302]                 }
[16:09:36.302]                 ...future.workdir <- getwd()
[16:09:36.302]             }
[16:09:36.302]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.302]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.302]         }
[16:09:36.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:36.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.302]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.302]             base::names(...future.oldOptions))
[16:09:36.302]     }
[16:09:36.302]     if (FALSE) {
[16:09:36.302]     }
[16:09:36.302]     else {
[16:09:36.302]         if (TRUE) {
[16:09:36.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.302]                 open = "w")
[16:09:36.302]         }
[16:09:36.302]         else {
[16:09:36.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.302]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.302]         }
[16:09:36.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.302]             base::sink(type = "output", split = FALSE)
[16:09:36.302]             base::close(...future.stdout)
[16:09:36.302]         }, add = TRUE)
[16:09:36.302]     }
[16:09:36.302]     ...future.frame <- base::sys.nframe()
[16:09:36.302]     ...future.conditions <- base::list()
[16:09:36.302]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.302]     if (FALSE) {
[16:09:36.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.302]     }
[16:09:36.302]     ...future.result <- base::tryCatch({
[16:09:36.302]         base::withCallingHandlers({
[16:09:36.302]             ...future.value <- base::withVisible(base::local({
[16:09:36.302]                 withCallingHandlers({
[16:09:36.302]                   {
[16:09:36.302]                     do.call(function(...) {
[16:09:36.302]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.302]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.302]                         ...future.globals.maxSize)) {
[16:09:36.302]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.302]                         on.exit(options(oopts), add = TRUE)
[16:09:36.302]                       }
[16:09:36.302]                       {
[16:09:36.302]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.302]                           FUN = function(jj) {
[16:09:36.302]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.302]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.302]                           })
[16:09:36.302]                       }
[16:09:36.302]                     }, args = future.call.arguments)
[16:09:36.302]                   }
[16:09:36.302]                 }, immediateCondition = function(cond) {
[16:09:36.302]                   save_rds <- function (object, pathname, ...) 
[16:09:36.302]                   {
[16:09:36.302]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.302]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.302]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.302]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.302]                         fi_tmp[["mtime"]])
[16:09:36.302]                     }
[16:09:36.302]                     tryCatch({
[16:09:36.302]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.302]                     }, error = function(ex) {
[16:09:36.302]                       msg <- conditionMessage(ex)
[16:09:36.302]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.302]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.302]                         fi_tmp[["mtime"]], msg)
[16:09:36.302]                       ex$message <- msg
[16:09:36.302]                       stop(ex)
[16:09:36.302]                     })
[16:09:36.302]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.302]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.302]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.302]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.302]                       fi <- file.info(pathname)
[16:09:36.302]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.302]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.302]                         fi[["size"]], fi[["mtime"]])
[16:09:36.302]                       stop(msg)
[16:09:36.302]                     }
[16:09:36.302]                     invisible(pathname)
[16:09:36.302]                   }
[16:09:36.302]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.302]                     rootPath = tempdir()) 
[16:09:36.302]                   {
[16:09:36.302]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.302]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.302]                       tmpdir = path, fileext = ".rds")
[16:09:36.302]                     save_rds(obj, file)
[16:09:36.302]                   }
[16:09:36.302]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.302]                   {
[16:09:36.302]                     inherits <- base::inherits
[16:09:36.302]                     invokeRestart <- base::invokeRestart
[16:09:36.302]                     is.null <- base::is.null
[16:09:36.302]                     muffled <- FALSE
[16:09:36.302]                     if (inherits(cond, "message")) {
[16:09:36.302]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.302]                       if (muffled) 
[16:09:36.302]                         invokeRestart("muffleMessage")
[16:09:36.302]                     }
[16:09:36.302]                     else if (inherits(cond, "warning")) {
[16:09:36.302]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.302]                       if (muffled) 
[16:09:36.302]                         invokeRestart("muffleWarning")
[16:09:36.302]                     }
[16:09:36.302]                     else if (inherits(cond, "condition")) {
[16:09:36.302]                       if (!is.null(pattern)) {
[16:09:36.302]                         computeRestarts <- base::computeRestarts
[16:09:36.302]                         grepl <- base::grepl
[16:09:36.302]                         restarts <- computeRestarts(cond)
[16:09:36.302]                         for (restart in restarts) {
[16:09:36.302]                           name <- restart$name
[16:09:36.302]                           if (is.null(name)) 
[16:09:36.302]                             next
[16:09:36.302]                           if (!grepl(pattern, name)) 
[16:09:36.302]                             next
[16:09:36.302]                           invokeRestart(restart)
[16:09:36.302]                           muffled <- TRUE
[16:09:36.302]                           break
[16:09:36.302]                         }
[16:09:36.302]                       }
[16:09:36.302]                     }
[16:09:36.302]                     invisible(muffled)
[16:09:36.302]                   }
[16:09:36.302]                   muffleCondition(cond)
[16:09:36.302]                 })
[16:09:36.302]             }))
[16:09:36.302]             future::FutureResult(value = ...future.value$value, 
[16:09:36.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.302]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.302]                     ...future.globalenv.names))
[16:09:36.302]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.302]         }, condition = base::local({
[16:09:36.302]             c <- base::c
[16:09:36.302]             inherits <- base::inherits
[16:09:36.302]             invokeRestart <- base::invokeRestart
[16:09:36.302]             length <- base::length
[16:09:36.302]             list <- base::list
[16:09:36.302]             seq.int <- base::seq.int
[16:09:36.302]             signalCondition <- base::signalCondition
[16:09:36.302]             sys.calls <- base::sys.calls
[16:09:36.302]             `[[` <- base::`[[`
[16:09:36.302]             `+` <- base::`+`
[16:09:36.302]             `<<-` <- base::`<<-`
[16:09:36.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.302]                   3L)]
[16:09:36.302]             }
[16:09:36.302]             function(cond) {
[16:09:36.302]                 is_error <- inherits(cond, "error")
[16:09:36.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.302]                   NULL)
[16:09:36.302]                 if (is_error) {
[16:09:36.302]                   sessionInformation <- function() {
[16:09:36.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.302]                       search = base::search(), system = base::Sys.info())
[16:09:36.302]                   }
[16:09:36.302]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.302]                     cond$call), session = sessionInformation(), 
[16:09:36.302]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.302]                   signalCondition(cond)
[16:09:36.302]                 }
[16:09:36.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.302]                 "immediateCondition"))) {
[16:09:36.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.302]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.302]                   if (TRUE && !signal) {
[16:09:36.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.302]                     {
[16:09:36.302]                       inherits <- base::inherits
[16:09:36.302]                       invokeRestart <- base::invokeRestart
[16:09:36.302]                       is.null <- base::is.null
[16:09:36.302]                       muffled <- FALSE
[16:09:36.302]                       if (inherits(cond, "message")) {
[16:09:36.302]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.302]                         if (muffled) 
[16:09:36.302]                           invokeRestart("muffleMessage")
[16:09:36.302]                       }
[16:09:36.302]                       else if (inherits(cond, "warning")) {
[16:09:36.302]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.302]                         if (muffled) 
[16:09:36.302]                           invokeRestart("muffleWarning")
[16:09:36.302]                       }
[16:09:36.302]                       else if (inherits(cond, "condition")) {
[16:09:36.302]                         if (!is.null(pattern)) {
[16:09:36.302]                           computeRestarts <- base::computeRestarts
[16:09:36.302]                           grepl <- base::grepl
[16:09:36.302]                           restarts <- computeRestarts(cond)
[16:09:36.302]                           for (restart in restarts) {
[16:09:36.302]                             name <- restart$name
[16:09:36.302]                             if (is.null(name)) 
[16:09:36.302]                               next
[16:09:36.302]                             if (!grepl(pattern, name)) 
[16:09:36.302]                               next
[16:09:36.302]                             invokeRestart(restart)
[16:09:36.302]                             muffled <- TRUE
[16:09:36.302]                             break
[16:09:36.302]                           }
[16:09:36.302]                         }
[16:09:36.302]                       }
[16:09:36.302]                       invisible(muffled)
[16:09:36.302]                     }
[16:09:36.302]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.302]                   }
[16:09:36.302]                 }
[16:09:36.302]                 else {
[16:09:36.302]                   if (TRUE) {
[16:09:36.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.302]                     {
[16:09:36.302]                       inherits <- base::inherits
[16:09:36.302]                       invokeRestart <- base::invokeRestart
[16:09:36.302]                       is.null <- base::is.null
[16:09:36.302]                       muffled <- FALSE
[16:09:36.302]                       if (inherits(cond, "message")) {
[16:09:36.302]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.302]                         if (muffled) 
[16:09:36.302]                           invokeRestart("muffleMessage")
[16:09:36.302]                       }
[16:09:36.302]                       else if (inherits(cond, "warning")) {
[16:09:36.302]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.302]                         if (muffled) 
[16:09:36.302]                           invokeRestart("muffleWarning")
[16:09:36.302]                       }
[16:09:36.302]                       else if (inherits(cond, "condition")) {
[16:09:36.302]                         if (!is.null(pattern)) {
[16:09:36.302]                           computeRestarts <- base::computeRestarts
[16:09:36.302]                           grepl <- base::grepl
[16:09:36.302]                           restarts <- computeRestarts(cond)
[16:09:36.302]                           for (restart in restarts) {
[16:09:36.302]                             name <- restart$name
[16:09:36.302]                             if (is.null(name)) 
[16:09:36.302]                               next
[16:09:36.302]                             if (!grepl(pattern, name)) 
[16:09:36.302]                               next
[16:09:36.302]                             invokeRestart(restart)
[16:09:36.302]                             muffled <- TRUE
[16:09:36.302]                             break
[16:09:36.302]                           }
[16:09:36.302]                         }
[16:09:36.302]                       }
[16:09:36.302]                       invisible(muffled)
[16:09:36.302]                     }
[16:09:36.302]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.302]                   }
[16:09:36.302]                 }
[16:09:36.302]             }
[16:09:36.302]         }))
[16:09:36.302]     }, error = function(ex) {
[16:09:36.302]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.302]                 ...future.rng), started = ...future.startTime, 
[16:09:36.302]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.302]             version = "1.8"), class = "FutureResult")
[16:09:36.302]     }, finally = {
[16:09:36.302]         if (!identical(...future.workdir, getwd())) 
[16:09:36.302]             setwd(...future.workdir)
[16:09:36.302]         {
[16:09:36.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.302]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.302]             }
[16:09:36.302]             base::options(...future.oldOptions)
[16:09:36.302]             if (.Platform$OS.type == "windows") {
[16:09:36.302]                 old_names <- names(...future.oldEnvVars)
[16:09:36.302]                 envs <- base::Sys.getenv()
[16:09:36.302]                 names <- names(envs)
[16:09:36.302]                 common <- intersect(names, old_names)
[16:09:36.302]                 added <- setdiff(names, old_names)
[16:09:36.302]                 removed <- setdiff(old_names, names)
[16:09:36.302]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.302]                   envs[common]]
[16:09:36.302]                 NAMES <- toupper(changed)
[16:09:36.302]                 args <- list()
[16:09:36.302]                 for (kk in seq_along(NAMES)) {
[16:09:36.302]                   name <- changed[[kk]]
[16:09:36.302]                   NAME <- NAMES[[kk]]
[16:09:36.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.302]                     next
[16:09:36.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.302]                 }
[16:09:36.302]                 NAMES <- toupper(added)
[16:09:36.302]                 for (kk in seq_along(NAMES)) {
[16:09:36.302]                   name <- added[[kk]]
[16:09:36.302]                   NAME <- NAMES[[kk]]
[16:09:36.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.302]                     next
[16:09:36.302]                   args[[name]] <- ""
[16:09:36.302]                 }
[16:09:36.302]                 NAMES <- toupper(removed)
[16:09:36.302]                 for (kk in seq_along(NAMES)) {
[16:09:36.302]                   name <- removed[[kk]]
[16:09:36.302]                   NAME <- NAMES[[kk]]
[16:09:36.302]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.302]                     next
[16:09:36.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.302]                 }
[16:09:36.302]                 if (length(args) > 0) 
[16:09:36.302]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.302]             }
[16:09:36.302]             else {
[16:09:36.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.302]             }
[16:09:36.302]             {
[16:09:36.302]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.302]                   0L) {
[16:09:36.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.302]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.302]                   base::options(opts)
[16:09:36.302]                 }
[16:09:36.302]                 {
[16:09:36.302]                   {
[16:09:36.302]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.302]                     NULL
[16:09:36.302]                   }
[16:09:36.302]                   options(future.plan = NULL)
[16:09:36.302]                   if (is.na(NA_character_)) 
[16:09:36.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.302]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.302]                     envir = parent.frame()) 
[16:09:36.302]                   {
[16:09:36.302]                     default_workers <- missing(workers)
[16:09:36.302]                     if (is.function(workers)) 
[16:09:36.302]                       workers <- workers()
[16:09:36.302]                     workers <- structure(as.integer(workers), 
[16:09:36.302]                       class = class(workers))
[16:09:36.302]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.302]                       1L)
[16:09:36.302]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.302]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.302]                       if (default_workers) 
[16:09:36.302]                         supportsMulticore(warn = TRUE)
[16:09:36.302]                       return(sequential(..., envir = envir))
[16:09:36.302]                     }
[16:09:36.302]                     oopts <- options(mc.cores = workers)
[16:09:36.302]                     on.exit(options(oopts))
[16:09:36.302]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.302]                       envir = envir)
[16:09:36.302]                     if (!future$lazy) 
[16:09:36.302]                       future <- run(future)
[16:09:36.302]                     invisible(future)
[16:09:36.302]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.302]                 }
[16:09:36.302]             }
[16:09:36.302]         }
[16:09:36.302]     })
[16:09:36.302]     if (TRUE) {
[16:09:36.302]         base::sink(type = "output", split = FALSE)
[16:09:36.302]         if (TRUE) {
[16:09:36.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.302]         }
[16:09:36.302]         else {
[16:09:36.302]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.302]         }
[16:09:36.302]         base::close(...future.stdout)
[16:09:36.302]         ...future.stdout <- NULL
[16:09:36.302]     }
[16:09:36.302]     ...future.result$conditions <- ...future.conditions
[16:09:36.302]     ...future.result$finished <- base::Sys.time()
[16:09:36.302]     ...future.result
[16:09:36.302] }
[16:09:36.305] assign_globals() ...
[16:09:36.305] List of 5
[16:09:36.305]  $ ...future.FUN            :function (x, ...)  
[16:09:36.305]  $ future.call.arguments    : list()
[16:09:36.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.305]  $ ...future.elements_ii    :List of 1
[16:09:36.305]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:09:36.305]  $ ...future.seeds_ii       : NULL
[16:09:36.305]  $ ...future.globals.maxSize: NULL
[16:09:36.305]  - attr(*, "where")=List of 5
[16:09:36.305]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.305]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.305]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.305]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.305]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.305]  - attr(*, "resolved")= logi FALSE
[16:09:36.305]  - attr(*, "total_size")= num 1248
[16:09:36.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.305]  - attr(*, "already-done")= logi TRUE
[16:09:36.309] - copied ‘...future.FUN’ to environment
[16:09:36.310] - copied ‘future.call.arguments’ to environment
[16:09:36.310] - copied ‘...future.elements_ii’ to environment
[16:09:36.310] - copied ‘...future.seeds_ii’ to environment
[16:09:36.310] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.310] assign_globals() ... done
[16:09:36.310] requestCore(): workers = 2
[16:09:36.312] MulticoreFuture started
[16:09:36.312] - Launch lazy future ... done
[16:09:36.312] run() for ‘MulticoreFuture’ ... done
[16:09:36.313] Created future:
[16:09:36.313] plan(): Setting new future strategy stack:
[16:09:36.314] List of future strategies:
[16:09:36.314] 1. sequential:
[16:09:36.314]    - args: function (..., envir = parent.frame())
[16:09:36.314]    - tweaked: FALSE
[16:09:36.314]    - call: NULL
[16:09:36.315] plan(): nbrOfWorkers() = 1
[16:09:36.317] plan(): Setting new future strategy stack:
[16:09:36.317] List of future strategies:
[16:09:36.317] 1. multicore:
[16:09:36.317]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.317]    - tweaked: FALSE
[16:09:36.317]    - call: plan(strategy)
[16:09:36.322] plan(): nbrOfWorkers() = 2
[16:09:36.313] MulticoreFuture:
[16:09:36.313] Label: ‘future_eapply-1’
[16:09:36.313] Expression:
[16:09:36.313] {
[16:09:36.313]     do.call(function(...) {
[16:09:36.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.313]             on.exit(options(oopts), add = TRUE)
[16:09:36.313]         }
[16:09:36.313]         {
[16:09:36.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.313]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.313]             })
[16:09:36.313]         }
[16:09:36.313]     }, args = future.call.arguments)
[16:09:36.313] }
[16:09:36.313] Lazy evaluation: FALSE
[16:09:36.313] Asynchronous evaluation: TRUE
[16:09:36.313] Local evaluation: TRUE
[16:09:36.313] Environment: R_GlobalEnv
[16:09:36.313] Capture standard output: TRUE
[16:09:36.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.313] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.313] Packages: 1 packages (‘stats’)
[16:09:36.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.313] Resolved: TRUE
[16:09:36.313] Value: <not collected>
[16:09:36.313] Conditions captured: <none>
[16:09:36.313] Early signaling: FALSE
[16:09:36.313] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.313] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.324] Chunk #1 of 2 ... DONE
[16:09:36.324] Chunk #2 of 2 ...
[16:09:36.324]  - Finding globals in 'X' for chunk #2 ...
[16:09:36.324] getGlobalsAndPackages() ...
[16:09:36.324] Searching for globals...
[16:09:36.325] 
[16:09:36.325] Searching for globals ... DONE
[16:09:36.325] - globals: [0] <none>
[16:09:36.325] getGlobalsAndPackages() ... DONE
[16:09:36.325]    + additional globals found: [n=0] 
[16:09:36.325]    + additional namespaces needed: [n=0] 
[16:09:36.325]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:36.326]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:36.326]  - seeds: <none>
[16:09:36.326] getGlobalsAndPackages() ...
[16:09:36.326] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.326] Resolving globals: FALSE
[16:09:36.326] Tweak future expression to call with '...' arguments ...
[16:09:36.327] {
[16:09:36.327]     do.call(function(...) {
[16:09:36.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.327]             on.exit(options(oopts), add = TRUE)
[16:09:36.327]         }
[16:09:36.327]         {
[16:09:36.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.327]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.327]             })
[16:09:36.327]         }
[16:09:36.327]     }, args = future.call.arguments)
[16:09:36.327] }
[16:09:36.327] Tweak future expression to call with '...' arguments ... DONE
[16:09:36.328] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:36.328] - packages: [1] ‘stats’
[16:09:36.328] getGlobalsAndPackages() ... DONE
[16:09:36.329] run() for ‘Future’ ...
[16:09:36.329] - state: ‘created’
[16:09:36.329] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:36.334] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.334] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:36.334]   - Field: ‘label’
[16:09:36.334]   - Field: ‘local’
[16:09:36.334]   - Field: ‘owner’
[16:09:36.335]   - Field: ‘envir’
[16:09:36.335]   - Field: ‘workers’
[16:09:36.335]   - Field: ‘packages’
[16:09:36.335]   - Field: ‘gc’
[16:09:36.335]   - Field: ‘job’
[16:09:36.335]   - Field: ‘conditions’
[16:09:36.335]   - Field: ‘expr’
[16:09:36.336]   - Field: ‘uuid’
[16:09:36.336]   - Field: ‘seed’
[16:09:36.336]   - Field: ‘version’
[16:09:36.336]   - Field: ‘result’
[16:09:36.336]   - Field: ‘asynchronous’
[16:09:36.336]   - Field: ‘calls’
[16:09:36.336]   - Field: ‘globals’
[16:09:36.337]   - Field: ‘stdout’
[16:09:36.337]   - Field: ‘earlySignal’
[16:09:36.337]   - Field: ‘lazy’
[16:09:36.337]   - Field: ‘state’
[16:09:36.337] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:36.337] - Launch lazy future ...
[16:09:36.338] Packages needed by the future expression (n = 1): ‘stats’
[16:09:36.338] Packages needed by future strategies (n = 0): <none>
[16:09:36.339] {
[16:09:36.339]     {
[16:09:36.339]         {
[16:09:36.339]             ...future.startTime <- base::Sys.time()
[16:09:36.339]             {
[16:09:36.339]                 {
[16:09:36.339]                   {
[16:09:36.339]                     {
[16:09:36.339]                       {
[16:09:36.339]                         base::local({
[16:09:36.339]                           has_future <- base::requireNamespace("future", 
[16:09:36.339]                             quietly = TRUE)
[16:09:36.339]                           if (has_future) {
[16:09:36.339]                             ns <- base::getNamespace("future")
[16:09:36.339]                             version <- ns[[".package"]][["version"]]
[16:09:36.339]                             if (is.null(version)) 
[16:09:36.339]                               version <- utils::packageVersion("future")
[16:09:36.339]                           }
[16:09:36.339]                           else {
[16:09:36.339]                             version <- NULL
[16:09:36.339]                           }
[16:09:36.339]                           if (!has_future || version < "1.8.0") {
[16:09:36.339]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.339]                               "", base::R.version$version.string), 
[16:09:36.339]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:36.339]                                 base::R.version$platform, 8 * 
[16:09:36.339]                                   base::.Machine$sizeof.pointer), 
[16:09:36.339]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.339]                                 "release", "version")], collapse = " "), 
[16:09:36.339]                               hostname = base::Sys.info()[["nodename"]])
[16:09:36.339]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.339]                               info)
[16:09:36.339]                             info <- base::paste(info, collapse = "; ")
[16:09:36.339]                             if (!has_future) {
[16:09:36.339]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.339]                                 info)
[16:09:36.339]                             }
[16:09:36.339]                             else {
[16:09:36.339]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.339]                                 info, version)
[16:09:36.339]                             }
[16:09:36.339]                             base::stop(msg)
[16:09:36.339]                           }
[16:09:36.339]                         })
[16:09:36.339]                       }
[16:09:36.339]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.339]                       base::options(mc.cores = 1L)
[16:09:36.339]                     }
[16:09:36.339]                     base::local({
[16:09:36.339]                       for (pkg in "stats") {
[16:09:36.339]                         base::loadNamespace(pkg)
[16:09:36.339]                         base::library(pkg, character.only = TRUE)
[16:09:36.339]                       }
[16:09:36.339]                     })
[16:09:36.339]                   }
[16:09:36.339]                   options(future.plan = NULL)
[16:09:36.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.339]                 }
[16:09:36.339]                 ...future.workdir <- getwd()
[16:09:36.339]             }
[16:09:36.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.339]         }
[16:09:36.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.339]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:36.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.339]             base::names(...future.oldOptions))
[16:09:36.339]     }
[16:09:36.339]     if (FALSE) {
[16:09:36.339]     }
[16:09:36.339]     else {
[16:09:36.339]         if (TRUE) {
[16:09:36.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.339]                 open = "w")
[16:09:36.339]         }
[16:09:36.339]         else {
[16:09:36.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.339]         }
[16:09:36.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.339]             base::sink(type = "output", split = FALSE)
[16:09:36.339]             base::close(...future.stdout)
[16:09:36.339]         }, add = TRUE)
[16:09:36.339]     }
[16:09:36.339]     ...future.frame <- base::sys.nframe()
[16:09:36.339]     ...future.conditions <- base::list()
[16:09:36.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.339]     if (FALSE) {
[16:09:36.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.339]     }
[16:09:36.339]     ...future.result <- base::tryCatch({
[16:09:36.339]         base::withCallingHandlers({
[16:09:36.339]             ...future.value <- base::withVisible(base::local({
[16:09:36.339]                 withCallingHandlers({
[16:09:36.339]                   {
[16:09:36.339]                     do.call(function(...) {
[16:09:36.339]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.339]                       if (!identical(...future.globals.maxSize.org, 
[16:09:36.339]                         ...future.globals.maxSize)) {
[16:09:36.339]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.339]                         on.exit(options(oopts), add = TRUE)
[16:09:36.339]                       }
[16:09:36.339]                       {
[16:09:36.339]                         lapply(seq_along(...future.elements_ii), 
[16:09:36.339]                           FUN = function(jj) {
[16:09:36.339]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.339]                             ...future.FUN(...future.X_jj, ...)
[16:09:36.339]                           })
[16:09:36.339]                       }
[16:09:36.339]                     }, args = future.call.arguments)
[16:09:36.339]                   }
[16:09:36.339]                 }, immediateCondition = function(cond) {
[16:09:36.339]                   save_rds <- function (object, pathname, ...) 
[16:09:36.339]                   {
[16:09:36.339]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:36.339]                     if (file_test("-f", pathname_tmp)) {
[16:09:36.339]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.339]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:36.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.339]                         fi_tmp[["mtime"]])
[16:09:36.339]                     }
[16:09:36.339]                     tryCatch({
[16:09:36.339]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:36.339]                     }, error = function(ex) {
[16:09:36.339]                       msg <- conditionMessage(ex)
[16:09:36.339]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.339]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:36.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.339]                         fi_tmp[["mtime"]], msg)
[16:09:36.339]                       ex$message <- msg
[16:09:36.339]                       stop(ex)
[16:09:36.339]                     })
[16:09:36.339]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:36.339]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:36.339]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:36.339]                       fi_tmp <- file.info(pathname_tmp)
[16:09:36.339]                       fi <- file.info(pathname)
[16:09:36.339]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:36.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:36.339]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:36.339]                         fi[["size"]], fi[["mtime"]])
[16:09:36.339]                       stop(msg)
[16:09:36.339]                     }
[16:09:36.339]                     invisible(pathname)
[16:09:36.339]                   }
[16:09:36.339]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:36.339]                     rootPath = tempdir()) 
[16:09:36.339]                   {
[16:09:36.339]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:36.339]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:36.339]                       tmpdir = path, fileext = ".rds")
[16:09:36.339]                     save_rds(obj, file)
[16:09:36.339]                   }
[16:09:36.339]                   saveImmediateCondition(cond, path = "/tmp/RtmpiDM9bq/.future/immediateConditions")
[16:09:36.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.339]                   {
[16:09:36.339]                     inherits <- base::inherits
[16:09:36.339]                     invokeRestart <- base::invokeRestart
[16:09:36.339]                     is.null <- base::is.null
[16:09:36.339]                     muffled <- FALSE
[16:09:36.339]                     if (inherits(cond, "message")) {
[16:09:36.339]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.339]                       if (muffled) 
[16:09:36.339]                         invokeRestart("muffleMessage")
[16:09:36.339]                     }
[16:09:36.339]                     else if (inherits(cond, "warning")) {
[16:09:36.339]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.339]                       if (muffled) 
[16:09:36.339]                         invokeRestart("muffleWarning")
[16:09:36.339]                     }
[16:09:36.339]                     else if (inherits(cond, "condition")) {
[16:09:36.339]                       if (!is.null(pattern)) {
[16:09:36.339]                         computeRestarts <- base::computeRestarts
[16:09:36.339]                         grepl <- base::grepl
[16:09:36.339]                         restarts <- computeRestarts(cond)
[16:09:36.339]                         for (restart in restarts) {
[16:09:36.339]                           name <- restart$name
[16:09:36.339]                           if (is.null(name)) 
[16:09:36.339]                             next
[16:09:36.339]                           if (!grepl(pattern, name)) 
[16:09:36.339]                             next
[16:09:36.339]                           invokeRestart(restart)
[16:09:36.339]                           muffled <- TRUE
[16:09:36.339]                           break
[16:09:36.339]                         }
[16:09:36.339]                       }
[16:09:36.339]                     }
[16:09:36.339]                     invisible(muffled)
[16:09:36.339]                   }
[16:09:36.339]                   muffleCondition(cond)
[16:09:36.339]                 })
[16:09:36.339]             }))
[16:09:36.339]             future::FutureResult(value = ...future.value$value, 
[16:09:36.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.339]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.339]                     ...future.globalenv.names))
[16:09:36.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.339]         }, condition = base::local({
[16:09:36.339]             c <- base::c
[16:09:36.339]             inherits <- base::inherits
[16:09:36.339]             invokeRestart <- base::invokeRestart
[16:09:36.339]             length <- base::length
[16:09:36.339]             list <- base::list
[16:09:36.339]             seq.int <- base::seq.int
[16:09:36.339]             signalCondition <- base::signalCondition
[16:09:36.339]             sys.calls <- base::sys.calls
[16:09:36.339]             `[[` <- base::`[[`
[16:09:36.339]             `+` <- base::`+`
[16:09:36.339]             `<<-` <- base::`<<-`
[16:09:36.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.339]                   3L)]
[16:09:36.339]             }
[16:09:36.339]             function(cond) {
[16:09:36.339]                 is_error <- inherits(cond, "error")
[16:09:36.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.339]                   NULL)
[16:09:36.339]                 if (is_error) {
[16:09:36.339]                   sessionInformation <- function() {
[16:09:36.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.339]                       search = base::search(), system = base::Sys.info())
[16:09:36.339]                   }
[16:09:36.339]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.339]                     cond$call), session = sessionInformation(), 
[16:09:36.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.339]                   signalCondition(cond)
[16:09:36.339]                 }
[16:09:36.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.339]                 "immediateCondition"))) {
[16:09:36.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.339]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.339]                   if (TRUE && !signal) {
[16:09:36.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.339]                     {
[16:09:36.339]                       inherits <- base::inherits
[16:09:36.339]                       invokeRestart <- base::invokeRestart
[16:09:36.339]                       is.null <- base::is.null
[16:09:36.339]                       muffled <- FALSE
[16:09:36.339]                       if (inherits(cond, "message")) {
[16:09:36.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.339]                         if (muffled) 
[16:09:36.339]                           invokeRestart("muffleMessage")
[16:09:36.339]                       }
[16:09:36.339]                       else if (inherits(cond, "warning")) {
[16:09:36.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.339]                         if (muffled) 
[16:09:36.339]                           invokeRestart("muffleWarning")
[16:09:36.339]                       }
[16:09:36.339]                       else if (inherits(cond, "condition")) {
[16:09:36.339]                         if (!is.null(pattern)) {
[16:09:36.339]                           computeRestarts <- base::computeRestarts
[16:09:36.339]                           grepl <- base::grepl
[16:09:36.339]                           restarts <- computeRestarts(cond)
[16:09:36.339]                           for (restart in restarts) {
[16:09:36.339]                             name <- restart$name
[16:09:36.339]                             if (is.null(name)) 
[16:09:36.339]                               next
[16:09:36.339]                             if (!grepl(pattern, name)) 
[16:09:36.339]                               next
[16:09:36.339]                             invokeRestart(restart)
[16:09:36.339]                             muffled <- TRUE
[16:09:36.339]                             break
[16:09:36.339]                           }
[16:09:36.339]                         }
[16:09:36.339]                       }
[16:09:36.339]                       invisible(muffled)
[16:09:36.339]                     }
[16:09:36.339]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.339]                   }
[16:09:36.339]                 }
[16:09:36.339]                 else {
[16:09:36.339]                   if (TRUE) {
[16:09:36.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.339]                     {
[16:09:36.339]                       inherits <- base::inherits
[16:09:36.339]                       invokeRestart <- base::invokeRestart
[16:09:36.339]                       is.null <- base::is.null
[16:09:36.339]                       muffled <- FALSE
[16:09:36.339]                       if (inherits(cond, "message")) {
[16:09:36.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.339]                         if (muffled) 
[16:09:36.339]                           invokeRestart("muffleMessage")
[16:09:36.339]                       }
[16:09:36.339]                       else if (inherits(cond, "warning")) {
[16:09:36.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.339]                         if (muffled) 
[16:09:36.339]                           invokeRestart("muffleWarning")
[16:09:36.339]                       }
[16:09:36.339]                       else if (inherits(cond, "condition")) {
[16:09:36.339]                         if (!is.null(pattern)) {
[16:09:36.339]                           computeRestarts <- base::computeRestarts
[16:09:36.339]                           grepl <- base::grepl
[16:09:36.339]                           restarts <- computeRestarts(cond)
[16:09:36.339]                           for (restart in restarts) {
[16:09:36.339]                             name <- restart$name
[16:09:36.339]                             if (is.null(name)) 
[16:09:36.339]                               next
[16:09:36.339]                             if (!grepl(pattern, name)) 
[16:09:36.339]                               next
[16:09:36.339]                             invokeRestart(restart)
[16:09:36.339]                             muffled <- TRUE
[16:09:36.339]                             break
[16:09:36.339]                           }
[16:09:36.339]                         }
[16:09:36.339]                       }
[16:09:36.339]                       invisible(muffled)
[16:09:36.339]                     }
[16:09:36.339]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.339]                   }
[16:09:36.339]                 }
[16:09:36.339]             }
[16:09:36.339]         }))
[16:09:36.339]     }, error = function(ex) {
[16:09:36.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.339]                 ...future.rng), started = ...future.startTime, 
[16:09:36.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.339]             version = "1.8"), class = "FutureResult")
[16:09:36.339]     }, finally = {
[16:09:36.339]         if (!identical(...future.workdir, getwd())) 
[16:09:36.339]             setwd(...future.workdir)
[16:09:36.339]         {
[16:09:36.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.339]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.339]             }
[16:09:36.339]             base::options(...future.oldOptions)
[16:09:36.339]             if (.Platform$OS.type == "windows") {
[16:09:36.339]                 old_names <- names(...future.oldEnvVars)
[16:09:36.339]                 envs <- base::Sys.getenv()
[16:09:36.339]                 names <- names(envs)
[16:09:36.339]                 common <- intersect(names, old_names)
[16:09:36.339]                 added <- setdiff(names, old_names)
[16:09:36.339]                 removed <- setdiff(old_names, names)
[16:09:36.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.339]                   envs[common]]
[16:09:36.339]                 NAMES <- toupper(changed)
[16:09:36.339]                 args <- list()
[16:09:36.339]                 for (kk in seq_along(NAMES)) {
[16:09:36.339]                   name <- changed[[kk]]
[16:09:36.339]                   NAME <- NAMES[[kk]]
[16:09:36.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.339]                     next
[16:09:36.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.339]                 }
[16:09:36.339]                 NAMES <- toupper(added)
[16:09:36.339]                 for (kk in seq_along(NAMES)) {
[16:09:36.339]                   name <- added[[kk]]
[16:09:36.339]                   NAME <- NAMES[[kk]]
[16:09:36.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.339]                     next
[16:09:36.339]                   args[[name]] <- ""
[16:09:36.339]                 }
[16:09:36.339]                 NAMES <- toupper(removed)
[16:09:36.339]                 for (kk in seq_along(NAMES)) {
[16:09:36.339]                   name <- removed[[kk]]
[16:09:36.339]                   NAME <- NAMES[[kk]]
[16:09:36.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.339]                     next
[16:09:36.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.339]                 }
[16:09:36.339]                 if (length(args) > 0) 
[16:09:36.339]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.339]             }
[16:09:36.339]             else {
[16:09:36.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.339]             }
[16:09:36.339]             {
[16:09:36.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.339]                   0L) {
[16:09:36.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.339]                   base::options(opts)
[16:09:36.339]                 }
[16:09:36.339]                 {
[16:09:36.339]                   {
[16:09:36.339]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.339]                     NULL
[16:09:36.339]                   }
[16:09:36.339]                   options(future.plan = NULL)
[16:09:36.339]                   if (is.na(NA_character_)) 
[16:09:36.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.339]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:36.339]                     envir = parent.frame()) 
[16:09:36.339]                   {
[16:09:36.339]                     default_workers <- missing(workers)
[16:09:36.339]                     if (is.function(workers)) 
[16:09:36.339]                       workers <- workers()
[16:09:36.339]                     workers <- structure(as.integer(workers), 
[16:09:36.339]                       class = class(workers))
[16:09:36.339]                     stop_if_not(is.finite(workers), workers >= 
[16:09:36.339]                       1L)
[16:09:36.339]                     if ((workers == 1L && !inherits(workers, 
[16:09:36.339]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:36.339]                       if (default_workers) 
[16:09:36.339]                         supportsMulticore(warn = TRUE)
[16:09:36.339]                       return(sequential(..., envir = envir))
[16:09:36.339]                     }
[16:09:36.339]                     oopts <- options(mc.cores = workers)
[16:09:36.339]                     on.exit(options(oopts))
[16:09:36.339]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:36.339]                       envir = envir)
[16:09:36.339]                     if (!future$lazy) 
[16:09:36.339]                       future <- run(future)
[16:09:36.339]                     invisible(future)
[16:09:36.339]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.339]                 }
[16:09:36.339]             }
[16:09:36.339]         }
[16:09:36.339]     })
[16:09:36.339]     if (TRUE) {
[16:09:36.339]         base::sink(type = "output", split = FALSE)
[16:09:36.339]         if (TRUE) {
[16:09:36.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.339]         }
[16:09:36.339]         else {
[16:09:36.339]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.339]         }
[16:09:36.339]         base::close(...future.stdout)
[16:09:36.339]         ...future.stdout <- NULL
[16:09:36.339]     }
[16:09:36.339]     ...future.result$conditions <- ...future.conditions
[16:09:36.339]     ...future.result$finished <- base::Sys.time()
[16:09:36.339]     ...future.result
[16:09:36.339] }
[16:09:36.342] assign_globals() ...
[16:09:36.342] List of 5
[16:09:36.342]  $ ...future.FUN            :function (x, ...)  
[16:09:36.342]  $ future.call.arguments    : list()
[16:09:36.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:36.342]  $ ...future.elements_ii    :List of 2
[16:09:36.342]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:09:36.342]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:09:36.342]  $ ...future.seeds_ii       : NULL
[16:09:36.342]  $ ...future.globals.maxSize: NULL
[16:09:36.342]  - attr(*, "resolved")= logi FALSE
[16:09:36.342]  - attr(*, "total_size")= num 1248
[16:09:36.342]  - attr(*, "where")=List of 5
[16:09:36.342]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:36.342]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:36.342]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:36.342]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:36.342]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:36.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:36.342]  - attr(*, "already-done")= logi TRUE
[16:09:36.354] - copied ‘...future.FUN’ to environment
[16:09:36.354] - copied ‘future.call.arguments’ to environment
[16:09:36.354] - copied ‘...future.elements_ii’ to environment
[16:09:36.354] - copied ‘...future.seeds_ii’ to environment
[16:09:36.355] - copied ‘...future.globals.maxSize’ to environment
[16:09:36.355] assign_globals() ... done
[16:09:36.355] requestCore(): workers = 2
[16:09:36.357] MulticoreFuture started
[16:09:36.358] - Launch lazy future ... done
[16:09:36.358] run() for ‘MulticoreFuture’ ... done
[16:09:36.358] Created future:
[16:09:36.359] plan(): Setting new future strategy stack:
[16:09:36.359] List of future strategies:
[16:09:36.359] 1. sequential:
[16:09:36.359]    - args: function (..., envir = parent.frame())
[16:09:36.359]    - tweaked: FALSE
[16:09:36.359]    - call: NULL
[16:09:36.360] plan(): nbrOfWorkers() = 1
[16:09:36.362] plan(): Setting new future strategy stack:
[16:09:36.363] List of future strategies:
[16:09:36.363] 1. multicore:
[16:09:36.363]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:36.363]    - tweaked: FALSE
[16:09:36.363]    - call: plan(strategy)
[16:09:36.368] plan(): nbrOfWorkers() = 2
[16:09:36.358] MulticoreFuture:
[16:09:36.358] Label: ‘future_eapply-2’
[16:09:36.358] Expression:
[16:09:36.358] {
[16:09:36.358]     do.call(function(...) {
[16:09:36.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:36.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:36.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:36.358]             on.exit(options(oopts), add = TRUE)
[16:09:36.358]         }
[16:09:36.358]         {
[16:09:36.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:36.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:36.358]                 ...future.FUN(...future.X_jj, ...)
[16:09:36.358]             })
[16:09:36.358]         }
[16:09:36.358]     }, args = future.call.arguments)
[16:09:36.358] }
[16:09:36.358] Lazy evaluation: FALSE
[16:09:36.358] Asynchronous evaluation: TRUE
[16:09:36.358] Local evaluation: TRUE
[16:09:36.358] Environment: R_GlobalEnv
[16:09:36.358] Capture standard output: TRUE
[16:09:36.358] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:36.358] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:36.358] Packages: 1 packages (‘stats’)
[16:09:36.358] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:36.358] Resolved: TRUE
[16:09:36.358] Value: <not collected>
[16:09:36.358] Conditions captured: <none>
[16:09:36.358] Early signaling: FALSE
[16:09:36.358] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:36.358] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:36.369] Chunk #2 of 2 ... DONE
[16:09:36.369] Launching 2 futures (chunks) ... DONE
[16:09:36.369] Resolving 2 futures (chunks) ...
[16:09:36.369] resolve() on list ...
[16:09:36.369]  recursive: 0
[16:09:36.369]  length: 2
[16:09:36.370] 
[16:09:36.370] Future #1
[16:09:36.371] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:36.371] - nx: 2
[16:09:36.371] - relay: TRUE
[16:09:36.371] - stdout: TRUE
[16:09:36.372] - signal: TRUE
[16:09:36.372] - resignal: FALSE
[16:09:36.372] - force: TRUE
[16:09:36.372] - relayed: [n=2] FALSE, FALSE
[16:09:36.372] - queued futures: [n=2] FALSE, FALSE
[16:09:36.372]  - until=1
[16:09:36.372]  - relaying element #1
[16:09:36.373] - relayed: [n=2] TRUE, FALSE
[16:09:36.373] - queued futures: [n=2] TRUE, FALSE
[16:09:36.373] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:36.373]  length: 1 (resolved future 1)
[16:09:36.374] Future #2
[16:09:36.374] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:36.375] - nx: 2
[16:09:36.375] - relay: TRUE
[16:09:36.375] - stdout: TRUE
[16:09:36.375] - signal: TRUE
[16:09:36.375] - resignal: FALSE
[16:09:36.375] - force: TRUE
[16:09:36.375] - relayed: [n=2] TRUE, FALSE
[16:09:36.375] - queued futures: [n=2] TRUE, FALSE
[16:09:36.375]  - until=2
[16:09:36.376]  - relaying element #2
[16:09:36.376] - relayed: [n=2] TRUE, TRUE
[16:09:36.376] - queued futures: [n=2] TRUE, TRUE
[16:09:36.376] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:36.376]  length: 0 (resolved future 2)
[16:09:36.376] Relaying remaining futures
[16:09:36.377] signalConditionsASAP(NULL, pos=0) ...
[16:09:36.377] - nx: 2
[16:09:36.377] - relay: TRUE
[16:09:36.377] - stdout: TRUE
[16:09:36.377] - signal: TRUE
[16:09:36.377] - resignal: FALSE
[16:09:36.377] - force: TRUE
[16:09:36.377] - relayed: [n=2] TRUE, TRUE
[16:09:36.377] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:36.378] - relayed: [n=2] TRUE, TRUE
[16:09:36.378] - queued futures: [n=2] TRUE, TRUE
[16:09:36.378] signalConditionsASAP(NULL, pos=0) ... done
[16:09:36.378] resolve() on list ... DONE
[16:09:36.378]  - Number of value chunks collected: 2
[16:09:36.378] Resolving 2 futures (chunks) ... DONE
[16:09:36.378] Reducing values from 2 chunks ...
[16:09:36.378]  - Number of values collected after concatenation: 3
[16:09:36.378]  - Number of values expected: 3
[16:09:36.379] Reducing values from 2 chunks ... DONE
[16:09:36.379] future_lapply() ... DONE
[16:09:36.379] plan(): Setting new future strategy stack:
[16:09:36.379] List of future strategies:
[16:09:36.379] 1. sequential:
[16:09:36.379]    - args: function (..., envir = parent.frame())
[16:09:36.379]    - tweaked: FALSE
[16:09:36.379]    - call: plan(sequential)
[16:09:36.380] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:09:36.380] plan(): Setting new future strategy stack:
[16:09:36.381] List of future strategies:
[16:09:36.381] 1. multisession:
[16:09:36.381]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:36.381]    - tweaked: FALSE
[16:09:36.381]    - call: plan(strategy)
[16:09:36.381] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:09:36.381] multisession:
[16:09:36.381] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:36.381] - tweaked: FALSE
[16:09:36.381] - call: plan(strategy)
[16:09:36.388] getGlobalsAndPackages() ...
[16:09:36.388] Not searching for globals
[16:09:36.388] - globals: [0] <none>
[16:09:36.388] getGlobalsAndPackages() ... DONE
[16:09:36.389] [local output] makeClusterPSOCK() ...
[16:09:36.430] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:09:36.436] [local output] Base port: 11910
[16:09:36.436] [local output] Getting setup options for 2 cluster nodes ...
[16:09:36.436] [local output]  - Node 1 of 2 ...
[16:09:36.437] [local output] localMachine=TRUE => revtunnel=FALSE

[16:09:36.437] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpiDM9bq/worker.rank=1.parallelly.parent=69580.10fccb3c4865.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpiDM9bq/worker.rank=1.parallelly.parent=69580.10fccb3c4865.pid")'’
[16:09:36.625] - Possible to infer worker's PID: TRUE
[16:09:36.626] [local output] Rscript port: 11910

[16:09:36.626] [local output]  - Node 2 of 2 ...
[16:09:36.626] [local output] localMachine=TRUE => revtunnel=FALSE

[16:09:36.627] [local output] Rscript port: 11910

[16:09:36.627] [local output] Getting setup options for 2 cluster nodes ... done
[16:09:36.627] [local output]  - Parallel setup requested for some PSOCK nodes
[16:09:36.628] [local output] Setting up PSOCK nodes in parallel
[16:09:36.628] List of 36
[16:09:36.628]  $ worker          : chr "localhost"
[16:09:36.628]   ..- attr(*, "localhost")= logi TRUE
[16:09:36.628]  $ master          : chr "localhost"
[16:09:36.628]  $ port            : int 11910
[16:09:36.628]  $ connectTimeout  : num 120
[16:09:36.628]  $ timeout         : num 2592000
[16:09:36.628]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:09:36.628]  $ homogeneous     : logi TRUE
[16:09:36.628]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:09:36.628]  $ rscript_envs    : NULL
[16:09:36.628]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:09:36.628]  $ rscript_startup : NULL
[16:09:36.628]  $ rscript_sh      : chr "sh"
[16:09:36.628]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:09:36.628]  $ methods         : logi TRUE
[16:09:36.628]  $ socketOptions   : chr "no-delay"
[16:09:36.628]  $ useXDR          : logi FALSE
[16:09:36.628]  $ outfile         : chr "/dev/null"
[16:09:36.628]  $ renice          : int NA
[16:09:36.628]  $ rshcmd          : NULL
[16:09:36.628]  $ user            : chr(0) 
[16:09:36.628]  $ revtunnel       : logi FALSE
[16:09:36.628]  $ rshlogfile      : NULL
[16:09:36.628]  $ rshopts         : chr(0) 
[16:09:36.628]  $ rank            : int 1
[16:09:36.628]  $ manual          : logi FALSE
[16:09:36.628]  $ dryrun          : logi FALSE
[16:09:36.628]  $ quiet           : logi FALSE
[16:09:36.628]  $ setup_strategy  : chr "parallel"
[16:09:36.628]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:09:36.628]  $ pidfile         : chr "/tmp/RtmpiDM9bq/worker.rank=1.parallelly.parent=69580.10fccb3c4865.pid"
[16:09:36.628]  $ rshcmd_label    : NULL
[16:09:36.628]  $ rsh_call        : NULL
[16:09:36.628]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:09:36.628]  $ localMachine    : logi TRUE
[16:09:36.628]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:09:36.628]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:09:36.628]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:09:36.628]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:09:36.628]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:09:36.628]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:09:36.628]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:09:36.628]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:09:36.628]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:09:36.628]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:09:36.628]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:09:36.628]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:09:36.628]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:09:36.628]  $ arguments       :List of 28
[16:09:36.628]   ..$ worker          : chr "localhost"
[16:09:36.628]   ..$ master          : NULL
[16:09:36.628]   ..$ port            : int 11910
[16:09:36.628]   ..$ connectTimeout  : num 120
[16:09:36.628]   ..$ timeout         : num 2592000
[16:09:36.628]   ..$ rscript         : NULL
[16:09:36.628]   ..$ homogeneous     : NULL
[16:09:36.628]   ..$ rscript_args    : NULL
[16:09:36.628]   ..$ rscript_envs    : NULL
[16:09:36.628]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:09:36.628]   ..$ rscript_startup : NULL
[16:09:36.628]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:09:36.628]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:09:36.628]   ..$ methods         : logi TRUE
[16:09:36.628]   ..$ socketOptions   : chr "no-delay"
[16:09:36.628]   ..$ useXDR          : logi FALSE
[16:09:36.628]   ..$ outfile         : chr "/dev/null"
[16:09:36.628]   ..$ renice          : int NA
[16:09:36.628]   ..$ rshcmd          : NULL
[16:09:36.628]   ..$ user            : NULL
[16:09:36.628]   ..$ revtunnel       : logi NA
[16:09:36.628]   ..$ rshlogfile      : NULL
[16:09:36.628]   ..$ rshopts         : NULL
[16:09:36.628]   ..$ rank            : int 1
[16:09:36.628]   ..$ manual          : logi FALSE
[16:09:36.628]   ..$ dryrun          : logi FALSE
[16:09:36.628]   ..$ quiet           : logi FALSE
[16:09:36.628]   ..$ setup_strategy  : chr "parallel"
[16:09:36.628]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:09:36.645] [local output] System call to launch all workers:
[16:09:36.645] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpiDM9bq/worker.rank=1.parallelly.parent=69580.10fccb3c4865.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11910 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:09:36.645] [local output] Starting PSOCK main server
[16:09:36.647] [local output] Workers launched
[16:09:36.647] [local output] Waiting for workers to connect back
[16:09:36.647]  - [local output] 0 workers out of 2 ready
[16:09:36.891]  - [local output] 0 workers out of 2 ready
[16:09:36.891]  - [local output] 1 workers out of 2 ready
[16:09:36.892]  - [local output] 2 workers out of 2 ready
[16:09:36.892] [local output] Launching of workers completed
[16:09:36.892] [local output] Collecting session information from workers
[16:09:36.893] [local output]  - Worker #1 of 2
[16:09:36.893] [local output]  - Worker #2 of 2
[16:09:36.894] [local output] makeClusterPSOCK() ... done
[16:09:36.907] Packages needed by the future expression (n = 0): <none>
[16:09:36.907] Packages needed by future strategies (n = 0): <none>
[16:09:36.907] {
[16:09:36.907]     {
[16:09:36.907]         {
[16:09:36.907]             ...future.startTime <- base::Sys.time()
[16:09:36.907]             {
[16:09:36.907]                 {
[16:09:36.907]                   {
[16:09:36.907]                     {
[16:09:36.907]                       base::local({
[16:09:36.907]                         has_future <- base::requireNamespace("future", 
[16:09:36.907]                           quietly = TRUE)
[16:09:36.907]                         if (has_future) {
[16:09:36.907]                           ns <- base::getNamespace("future")
[16:09:36.907]                           version <- ns[[".package"]][["version"]]
[16:09:36.907]                           if (is.null(version)) 
[16:09:36.907]                             version <- utils::packageVersion("future")
[16:09:36.907]                         }
[16:09:36.907]                         else {
[16:09:36.907]                           version <- NULL
[16:09:36.907]                         }
[16:09:36.907]                         if (!has_future || version < "1.8.0") {
[16:09:36.907]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:36.907]                             "", base::R.version$version.string), 
[16:09:36.907]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:36.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:36.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:36.907]                               "release", "version")], collapse = " "), 
[16:09:36.907]                             hostname = base::Sys.info()[["nodename"]])
[16:09:36.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:36.907]                             info)
[16:09:36.907]                           info <- base::paste(info, collapse = "; ")
[16:09:36.907]                           if (!has_future) {
[16:09:36.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:36.907]                               info)
[16:09:36.907]                           }
[16:09:36.907]                           else {
[16:09:36.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:36.907]                               info, version)
[16:09:36.907]                           }
[16:09:36.907]                           base::stop(msg)
[16:09:36.907]                         }
[16:09:36.907]                       })
[16:09:36.907]                     }
[16:09:36.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:36.907]                     base::options(mc.cores = 1L)
[16:09:36.907]                   }
[16:09:36.907]                   options(future.plan = NULL)
[16:09:36.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:36.907]                 }
[16:09:36.907]                 ...future.workdir <- getwd()
[16:09:36.907]             }
[16:09:36.907]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:36.907]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:36.907]         }
[16:09:36.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:36.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:36.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:36.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:36.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:36.907]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:36.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:36.907]             base::names(...future.oldOptions))
[16:09:36.907]     }
[16:09:36.907]     if (FALSE) {
[16:09:36.907]     }
[16:09:36.907]     else {
[16:09:36.907]         if (TRUE) {
[16:09:36.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:36.907]                 open = "w")
[16:09:36.907]         }
[16:09:36.907]         else {
[16:09:36.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:36.907]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:36.907]         }
[16:09:36.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:36.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:36.907]             base::sink(type = "output", split = FALSE)
[16:09:36.907]             base::close(...future.stdout)
[16:09:36.907]         }, add = TRUE)
[16:09:36.907]     }
[16:09:36.907]     ...future.frame <- base::sys.nframe()
[16:09:36.907]     ...future.conditions <- base::list()
[16:09:36.907]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:36.907]     if (FALSE) {
[16:09:36.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:36.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:36.907]     }
[16:09:36.907]     ...future.result <- base::tryCatch({
[16:09:36.907]         base::withCallingHandlers({
[16:09:36.907]             ...future.value <- base::withVisible(base::local({
[16:09:36.907]                 ...future.makeSendCondition <- local({
[16:09:36.907]                   sendCondition <- NULL
[16:09:36.907]                   function(frame = 1L) {
[16:09:36.907]                     if (is.function(sendCondition)) 
[16:09:36.907]                       return(sendCondition)
[16:09:36.907]                     ns <- getNamespace("parallel")
[16:09:36.907]                     if (exists("sendData", mode = "function", 
[16:09:36.907]                       envir = ns)) {
[16:09:36.907]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:36.907]                         envir = ns)
[16:09:36.907]                       envir <- sys.frame(frame)
[16:09:36.907]                       master <- NULL
[16:09:36.907]                       while (!identical(envir, .GlobalEnv) && 
[16:09:36.907]                         !identical(envir, emptyenv())) {
[16:09:36.907]                         if (exists("master", mode = "list", envir = envir, 
[16:09:36.907]                           inherits = FALSE)) {
[16:09:36.907]                           master <- get("master", mode = "list", 
[16:09:36.907]                             envir = envir, inherits = FALSE)
[16:09:36.907]                           if (inherits(master, c("SOCKnode", 
[16:09:36.907]                             "SOCK0node"))) {
[16:09:36.907]                             sendCondition <<- function(cond) {
[16:09:36.907]                               data <- list(type = "VALUE", value = cond, 
[16:09:36.907]                                 success = TRUE)
[16:09:36.907]                               parallel_sendData(master, data)
[16:09:36.907]                             }
[16:09:36.907]                             return(sendCondition)
[16:09:36.907]                           }
[16:09:36.907]                         }
[16:09:36.907]                         frame <- frame + 1L
[16:09:36.907]                         envir <- sys.frame(frame)
[16:09:36.907]                       }
[16:09:36.907]                     }
[16:09:36.907]                     sendCondition <<- function(cond) NULL
[16:09:36.907]                   }
[16:09:36.907]                 })
[16:09:36.907]                 withCallingHandlers({
[16:09:36.907]                   NA
[16:09:36.907]                 }, immediateCondition = function(cond) {
[16:09:36.907]                   sendCondition <- ...future.makeSendCondition()
[16:09:36.907]                   sendCondition(cond)
[16:09:36.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.907]                   {
[16:09:36.907]                     inherits <- base::inherits
[16:09:36.907]                     invokeRestart <- base::invokeRestart
[16:09:36.907]                     is.null <- base::is.null
[16:09:36.907]                     muffled <- FALSE
[16:09:36.907]                     if (inherits(cond, "message")) {
[16:09:36.907]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:36.907]                       if (muffled) 
[16:09:36.907]                         invokeRestart("muffleMessage")
[16:09:36.907]                     }
[16:09:36.907]                     else if (inherits(cond, "warning")) {
[16:09:36.907]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:36.907]                       if (muffled) 
[16:09:36.907]                         invokeRestart("muffleWarning")
[16:09:36.907]                     }
[16:09:36.907]                     else if (inherits(cond, "condition")) {
[16:09:36.907]                       if (!is.null(pattern)) {
[16:09:36.907]                         computeRestarts <- base::computeRestarts
[16:09:36.907]                         grepl <- base::grepl
[16:09:36.907]                         restarts <- computeRestarts(cond)
[16:09:36.907]                         for (restart in restarts) {
[16:09:36.907]                           name <- restart$name
[16:09:36.907]                           if (is.null(name)) 
[16:09:36.907]                             next
[16:09:36.907]                           if (!grepl(pattern, name)) 
[16:09:36.907]                             next
[16:09:36.907]                           invokeRestart(restart)
[16:09:36.907]                           muffled <- TRUE
[16:09:36.907]                           break
[16:09:36.907]                         }
[16:09:36.907]                       }
[16:09:36.907]                     }
[16:09:36.907]                     invisible(muffled)
[16:09:36.907]                   }
[16:09:36.907]                   muffleCondition(cond)
[16:09:36.907]                 })
[16:09:36.907]             }))
[16:09:36.907]             future::FutureResult(value = ...future.value$value, 
[16:09:36.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.907]                   ...future.rng), globalenv = if (FALSE) 
[16:09:36.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:36.907]                     ...future.globalenv.names))
[16:09:36.907]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:36.907]         }, condition = base::local({
[16:09:36.907]             c <- base::c
[16:09:36.907]             inherits <- base::inherits
[16:09:36.907]             invokeRestart <- base::invokeRestart
[16:09:36.907]             length <- base::length
[16:09:36.907]             list <- base::list
[16:09:36.907]             seq.int <- base::seq.int
[16:09:36.907]             signalCondition <- base::signalCondition
[16:09:36.907]             sys.calls <- base::sys.calls
[16:09:36.907]             `[[` <- base::`[[`
[16:09:36.907]             `+` <- base::`+`
[16:09:36.907]             `<<-` <- base::`<<-`
[16:09:36.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:36.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:36.907]                   3L)]
[16:09:36.907]             }
[16:09:36.907]             function(cond) {
[16:09:36.907]                 is_error <- inherits(cond, "error")
[16:09:36.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:36.907]                   NULL)
[16:09:36.907]                 if (is_error) {
[16:09:36.907]                   sessionInformation <- function() {
[16:09:36.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:36.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:36.907]                       search = base::search(), system = base::Sys.info())
[16:09:36.907]                   }
[16:09:36.907]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:36.907]                     cond$call), session = sessionInformation(), 
[16:09:36.907]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:36.907]                   signalCondition(cond)
[16:09:36.907]                 }
[16:09:36.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:36.907]                 "immediateCondition"))) {
[16:09:36.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:36.907]                   ...future.conditions[[length(...future.conditions) + 
[16:09:36.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:36.907]                   if (TRUE && !signal) {
[16:09:36.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.907]                     {
[16:09:36.907]                       inherits <- base::inherits
[16:09:36.907]                       invokeRestart <- base::invokeRestart
[16:09:36.907]                       is.null <- base::is.null
[16:09:36.907]                       muffled <- FALSE
[16:09:36.907]                       if (inherits(cond, "message")) {
[16:09:36.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.907]                         if (muffled) 
[16:09:36.907]                           invokeRestart("muffleMessage")
[16:09:36.907]                       }
[16:09:36.907]                       else if (inherits(cond, "warning")) {
[16:09:36.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.907]                         if (muffled) 
[16:09:36.907]                           invokeRestart("muffleWarning")
[16:09:36.907]                       }
[16:09:36.907]                       else if (inherits(cond, "condition")) {
[16:09:36.907]                         if (!is.null(pattern)) {
[16:09:36.907]                           computeRestarts <- base::computeRestarts
[16:09:36.907]                           grepl <- base::grepl
[16:09:36.907]                           restarts <- computeRestarts(cond)
[16:09:36.907]                           for (restart in restarts) {
[16:09:36.907]                             name <- restart$name
[16:09:36.907]                             if (is.null(name)) 
[16:09:36.907]                               next
[16:09:36.907]                             if (!grepl(pattern, name)) 
[16:09:36.907]                               next
[16:09:36.907]                             invokeRestart(restart)
[16:09:36.907]                             muffled <- TRUE
[16:09:36.907]                             break
[16:09:36.907]                           }
[16:09:36.907]                         }
[16:09:36.907]                       }
[16:09:36.907]                       invisible(muffled)
[16:09:36.907]                     }
[16:09:36.907]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.907]                   }
[16:09:36.907]                 }
[16:09:36.907]                 else {
[16:09:36.907]                   if (TRUE) {
[16:09:36.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:36.907]                     {
[16:09:36.907]                       inherits <- base::inherits
[16:09:36.907]                       invokeRestart <- base::invokeRestart
[16:09:36.907]                       is.null <- base::is.null
[16:09:36.907]                       muffled <- FALSE
[16:09:36.907]                       if (inherits(cond, "message")) {
[16:09:36.907]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:36.907]                         if (muffled) 
[16:09:36.907]                           invokeRestart("muffleMessage")
[16:09:36.907]                       }
[16:09:36.907]                       else if (inherits(cond, "warning")) {
[16:09:36.907]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:36.907]                         if (muffled) 
[16:09:36.907]                           invokeRestart("muffleWarning")
[16:09:36.907]                       }
[16:09:36.907]                       else if (inherits(cond, "condition")) {
[16:09:36.907]                         if (!is.null(pattern)) {
[16:09:36.907]                           computeRestarts <- base::computeRestarts
[16:09:36.907]                           grepl <- base::grepl
[16:09:36.907]                           restarts <- computeRestarts(cond)
[16:09:36.907]                           for (restart in restarts) {
[16:09:36.907]                             name <- restart$name
[16:09:36.907]                             if (is.null(name)) 
[16:09:36.907]                               next
[16:09:36.907]                             if (!grepl(pattern, name)) 
[16:09:36.907]                               next
[16:09:36.907]                             invokeRestart(restart)
[16:09:36.907]                             muffled <- TRUE
[16:09:36.907]                             break
[16:09:36.907]                           }
[16:09:36.907]                         }
[16:09:36.907]                       }
[16:09:36.907]                       invisible(muffled)
[16:09:36.907]                     }
[16:09:36.907]                     muffleCondition(cond, pattern = "^muffle")
[16:09:36.907]                   }
[16:09:36.907]                 }
[16:09:36.907]             }
[16:09:36.907]         }))
[16:09:36.907]     }, error = function(ex) {
[16:09:36.907]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:36.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:36.907]                 ...future.rng), started = ...future.startTime, 
[16:09:36.907]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:36.907]             version = "1.8"), class = "FutureResult")
[16:09:36.907]     }, finally = {
[16:09:36.907]         if (!identical(...future.workdir, getwd())) 
[16:09:36.907]             setwd(...future.workdir)
[16:09:36.907]         {
[16:09:36.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:36.907]                 ...future.oldOptions$nwarnings <- NULL
[16:09:36.907]             }
[16:09:36.907]             base::options(...future.oldOptions)
[16:09:36.907]             if (.Platform$OS.type == "windows") {
[16:09:36.907]                 old_names <- names(...future.oldEnvVars)
[16:09:36.907]                 envs <- base::Sys.getenv()
[16:09:36.907]                 names <- names(envs)
[16:09:36.907]                 common <- intersect(names, old_names)
[16:09:36.907]                 added <- setdiff(names, old_names)
[16:09:36.907]                 removed <- setdiff(old_names, names)
[16:09:36.907]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:36.907]                   envs[common]]
[16:09:36.907]                 NAMES <- toupper(changed)
[16:09:36.907]                 args <- list()
[16:09:36.907]                 for (kk in seq_along(NAMES)) {
[16:09:36.907]                   name <- changed[[kk]]
[16:09:36.907]                   NAME <- NAMES[[kk]]
[16:09:36.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.907]                     next
[16:09:36.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.907]                 }
[16:09:36.907]                 NAMES <- toupper(added)
[16:09:36.907]                 for (kk in seq_along(NAMES)) {
[16:09:36.907]                   name <- added[[kk]]
[16:09:36.907]                   NAME <- NAMES[[kk]]
[16:09:36.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.907]                     next
[16:09:36.907]                   args[[name]] <- ""
[16:09:36.907]                 }
[16:09:36.907]                 NAMES <- toupper(removed)
[16:09:36.907]                 for (kk in seq_along(NAMES)) {
[16:09:36.907]                   name <- removed[[kk]]
[16:09:36.907]                   NAME <- NAMES[[kk]]
[16:09:36.907]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:36.907]                     next
[16:09:36.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:36.907]                 }
[16:09:36.907]                 if (length(args) > 0) 
[16:09:36.907]                   base::do.call(base::Sys.setenv, args = args)
[16:09:36.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:36.907]             }
[16:09:36.907]             else {
[16:09:36.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:36.907]             }
[16:09:36.907]             {
[16:09:36.907]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:36.907]                   0L) {
[16:09:36.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:36.907]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:36.907]                   base::options(opts)
[16:09:36.907]                 }
[16:09:36.907]                 {
[16:09:36.907]                   {
[16:09:36.907]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:36.907]                     NULL
[16:09:36.907]                   }
[16:09:36.907]                   options(future.plan = NULL)
[16:09:36.907]                   if (is.na(NA_character_)) 
[16:09:36.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:36.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:36.907]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:36.907]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:36.907]                     envir = parent.frame()) 
[16:09:36.907]                   {
[16:09:36.907]                     if (is.function(workers)) 
[16:09:36.907]                       workers <- workers()
[16:09:36.907]                     workers <- structure(as.integer(workers), 
[16:09:36.907]                       class = class(workers))
[16:09:36.907]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:36.907]                       workers >= 1)
[16:09:36.907]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:36.907]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:36.907]                     }
[16:09:36.907]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:36.907]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:36.907]                       envir = envir)
[16:09:36.907]                     if (!future$lazy) 
[16:09:36.907]                       future <- run(future)
[16:09:36.907]                     invisible(future)
[16:09:36.907]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:36.907]                 }
[16:09:36.907]             }
[16:09:36.907]         }
[16:09:36.907]     })
[16:09:36.907]     if (TRUE) {
[16:09:36.907]         base::sink(type = "output", split = FALSE)
[16:09:36.907]         if (TRUE) {
[16:09:36.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:36.907]         }
[16:09:36.907]         else {
[16:09:36.907]             ...future.result["stdout"] <- base::list(NULL)
[16:09:36.907]         }
[16:09:36.907]         base::close(...future.stdout)
[16:09:36.907]         ...future.stdout <- NULL
[16:09:36.907]     }
[16:09:36.907]     ...future.result$conditions <- ...future.conditions
[16:09:36.907]     ...future.result$finished <- base::Sys.time()
[16:09:36.907]     ...future.result
[16:09:36.907] }
[16:09:36.979] MultisessionFuture started
[16:09:36.980] result() for ClusterFuture ...
[16:09:36.980] receiveMessageFromWorker() for ClusterFuture ...
[16:09:36.980] - Validating connection of MultisessionFuture
[16:09:37.011] - received message: FutureResult
[16:09:37.012] - Received FutureResult
[16:09:37.012] - Erased future from FutureRegistry
[16:09:37.012] result() for ClusterFuture ...
[16:09:37.012] - result already collected: FutureResult
[16:09:37.012] result() for ClusterFuture ... done
[16:09:37.012] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.012] result() for ClusterFuture ... done
[16:09:37.013] result() for ClusterFuture ...
[16:09:37.013] - result already collected: FutureResult
[16:09:37.013] result() for ClusterFuture ... done
[16:09:37.013] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:09:37.017] plan(): nbrOfWorkers() = 2
[16:09:37.017] future_lapply() ...
[16:09:37.021] Number of chunks: 2
[16:09:37.021] getGlobalsAndPackagesXApply() ...
[16:09:37.021]  - future.globals: TRUE
[16:09:37.021] getGlobalsAndPackages() ...
[16:09:37.022] Searching for globals...
[16:09:37.023] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:37.023] Searching for globals ... DONE
[16:09:37.023] Resolving globals: FALSE
[16:09:37.024] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:09:37.024] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:09:37.024] - globals: [1] ‘FUN’
[16:09:37.024] 
[16:09:37.024] getGlobalsAndPackages() ... DONE
[16:09:37.025]  - globals found/used: [n=1] ‘FUN’
[16:09:37.025]  - needed namespaces: [n=0] 
[16:09:37.025] Finding globals ... DONE
[16:09:37.025]  - use_args: TRUE
[16:09:37.025]  - Getting '...' globals ...
[16:09:37.025] resolve() on list ...
[16:09:37.025]  recursive: 0
[16:09:37.026]  length: 1
[16:09:37.026]  elements: ‘...’
[16:09:37.026]  length: 0 (resolved future 1)
[16:09:37.026] resolve() on list ... DONE
[16:09:37.026]    - '...' content: [n=0] 
[16:09:37.026] List of 1
[16:09:37.026]  $ ...: list()
[16:09:37.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.026]  - attr(*, "where")=List of 1
[16:09:37.026]   ..$ ...:<environment: 0x55b4b9336938> 
[16:09:37.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.026]  - attr(*, "resolved")= logi TRUE
[16:09:37.026]  - attr(*, "total_size")= num NA
[16:09:37.029]  - Getting '...' globals ... DONE
[16:09:37.030] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:37.030] List of 2
[16:09:37.030]  $ ...future.FUN:function (x, ...)  
[16:09:37.030]  $ ...          : list()
[16:09:37.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.030]  - attr(*, "where")=List of 2
[16:09:37.030]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:37.030]   ..$ ...          :<environment: 0x55b4b9336938> 
[16:09:37.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.030]  - attr(*, "resolved")= logi FALSE
[16:09:37.030]  - attr(*, "total_size")= num 1240
[16:09:37.033] Packages to be attached in all futures: [n=0] 
[16:09:37.033] getGlobalsAndPackagesXApply() ... DONE
[16:09:37.033] Number of futures (= number of chunks): 2
[16:09:37.034] Launching 2 futures (chunks) ...
[16:09:37.034] Chunk #1 of 2 ...
[16:09:37.034]  - Finding globals in 'X' for chunk #1 ...
[16:09:37.034] getGlobalsAndPackages() ...
[16:09:37.034] Searching for globals...
[16:09:37.034] 
[16:09:37.034] Searching for globals ... DONE
[16:09:37.035] - globals: [0] <none>
[16:09:37.035] getGlobalsAndPackages() ... DONE
[16:09:37.035]    + additional globals found: [n=0] 
[16:09:37.035]    + additional namespaces needed: [n=0] 
[16:09:37.035]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:37.035]  - seeds: <none>
[16:09:37.035] getGlobalsAndPackages() ...
[16:09:37.035] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.035] Resolving globals: FALSE
[16:09:37.036] Tweak future expression to call with '...' arguments ...
[16:09:37.036] {
[16:09:37.036]     do.call(function(...) {
[16:09:37.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.036]             on.exit(options(oopts), add = TRUE)
[16:09:37.036]         }
[16:09:37.036]         {
[16:09:37.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.036]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.036]             })
[16:09:37.036]         }
[16:09:37.036]     }, args = future.call.arguments)
[16:09:37.036] }
[16:09:37.036] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.036] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.037] 
[16:09:37.037] getGlobalsAndPackages() ... DONE
[16:09:37.037] run() for ‘Future’ ...
[16:09:37.037] - state: ‘created’
[16:09:37.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.053]   - Field: ‘node’
[16:09:37.053]   - Field: ‘label’
[16:09:37.053]   - Field: ‘local’
[16:09:37.053]   - Field: ‘owner’
[16:09:37.053]   - Field: ‘envir’
[16:09:37.053]   - Field: ‘workers’
[16:09:37.053]   - Field: ‘packages’
[16:09:37.053]   - Field: ‘gc’
[16:09:37.053]   - Field: ‘conditions’
[16:09:37.054]   - Field: ‘persistent’
[16:09:37.054]   - Field: ‘expr’
[16:09:37.054]   - Field: ‘uuid’
[16:09:37.054]   - Field: ‘seed’
[16:09:37.054]   - Field: ‘version’
[16:09:37.054]   - Field: ‘result’
[16:09:37.054]   - Field: ‘asynchronous’
[16:09:37.054]   - Field: ‘calls’
[16:09:37.054]   - Field: ‘globals’
[16:09:37.055]   - Field: ‘stdout’
[16:09:37.055]   - Field: ‘earlySignal’
[16:09:37.055]   - Field: ‘lazy’
[16:09:37.055]   - Field: ‘state’
[16:09:37.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.055] - Launch lazy future ...
[16:09:37.056] Packages needed by the future expression (n = 0): <none>
[16:09:37.056] Packages needed by future strategies (n = 0): <none>
[16:09:37.056] {
[16:09:37.056]     {
[16:09:37.056]         {
[16:09:37.056]             ...future.startTime <- base::Sys.time()
[16:09:37.056]             {
[16:09:37.056]                 {
[16:09:37.056]                   {
[16:09:37.056]                     {
[16:09:37.056]                       base::local({
[16:09:37.056]                         has_future <- base::requireNamespace("future", 
[16:09:37.056]                           quietly = TRUE)
[16:09:37.056]                         if (has_future) {
[16:09:37.056]                           ns <- base::getNamespace("future")
[16:09:37.056]                           version <- ns[[".package"]][["version"]]
[16:09:37.056]                           if (is.null(version)) 
[16:09:37.056]                             version <- utils::packageVersion("future")
[16:09:37.056]                         }
[16:09:37.056]                         else {
[16:09:37.056]                           version <- NULL
[16:09:37.056]                         }
[16:09:37.056]                         if (!has_future || version < "1.8.0") {
[16:09:37.056]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.056]                             "", base::R.version$version.string), 
[16:09:37.056]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:37.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:37.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.056]                               "release", "version")], collapse = " "), 
[16:09:37.056]                             hostname = base::Sys.info()[["nodename"]])
[16:09:37.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.056]                             info)
[16:09:37.056]                           info <- base::paste(info, collapse = "; ")
[16:09:37.056]                           if (!has_future) {
[16:09:37.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.056]                               info)
[16:09:37.056]                           }
[16:09:37.056]                           else {
[16:09:37.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.056]                               info, version)
[16:09:37.056]                           }
[16:09:37.056]                           base::stop(msg)
[16:09:37.056]                         }
[16:09:37.056]                       })
[16:09:37.056]                     }
[16:09:37.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.056]                     base::options(mc.cores = 1L)
[16:09:37.056]                   }
[16:09:37.056]                   options(future.plan = NULL)
[16:09:37.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.056]                 }
[16:09:37.056]                 ...future.workdir <- getwd()
[16:09:37.056]             }
[16:09:37.056]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.056]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.056]         }
[16:09:37.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:37.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.056]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.056]             base::names(...future.oldOptions))
[16:09:37.056]     }
[16:09:37.056]     if (FALSE) {
[16:09:37.056]     }
[16:09:37.056]     else {
[16:09:37.056]         if (TRUE) {
[16:09:37.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.056]                 open = "w")
[16:09:37.056]         }
[16:09:37.056]         else {
[16:09:37.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.056]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.056]         }
[16:09:37.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.056]             base::sink(type = "output", split = FALSE)
[16:09:37.056]             base::close(...future.stdout)
[16:09:37.056]         }, add = TRUE)
[16:09:37.056]     }
[16:09:37.056]     ...future.frame <- base::sys.nframe()
[16:09:37.056]     ...future.conditions <- base::list()
[16:09:37.056]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.056]     if (FALSE) {
[16:09:37.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.056]     }
[16:09:37.056]     ...future.result <- base::tryCatch({
[16:09:37.056]         base::withCallingHandlers({
[16:09:37.056]             ...future.value <- base::withVisible(base::local({
[16:09:37.056]                 ...future.makeSendCondition <- local({
[16:09:37.056]                   sendCondition <- NULL
[16:09:37.056]                   function(frame = 1L) {
[16:09:37.056]                     if (is.function(sendCondition)) 
[16:09:37.056]                       return(sendCondition)
[16:09:37.056]                     ns <- getNamespace("parallel")
[16:09:37.056]                     if (exists("sendData", mode = "function", 
[16:09:37.056]                       envir = ns)) {
[16:09:37.056]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.056]                         envir = ns)
[16:09:37.056]                       envir <- sys.frame(frame)
[16:09:37.056]                       master <- NULL
[16:09:37.056]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.056]                         !identical(envir, emptyenv())) {
[16:09:37.056]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.056]                           inherits = FALSE)) {
[16:09:37.056]                           master <- get("master", mode = "list", 
[16:09:37.056]                             envir = envir, inherits = FALSE)
[16:09:37.056]                           if (inherits(master, c("SOCKnode", 
[16:09:37.056]                             "SOCK0node"))) {
[16:09:37.056]                             sendCondition <<- function(cond) {
[16:09:37.056]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.056]                                 success = TRUE)
[16:09:37.056]                               parallel_sendData(master, data)
[16:09:37.056]                             }
[16:09:37.056]                             return(sendCondition)
[16:09:37.056]                           }
[16:09:37.056]                         }
[16:09:37.056]                         frame <- frame + 1L
[16:09:37.056]                         envir <- sys.frame(frame)
[16:09:37.056]                       }
[16:09:37.056]                     }
[16:09:37.056]                     sendCondition <<- function(cond) NULL
[16:09:37.056]                   }
[16:09:37.056]                 })
[16:09:37.056]                 withCallingHandlers({
[16:09:37.056]                   {
[16:09:37.056]                     do.call(function(...) {
[16:09:37.056]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.056]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.056]                         ...future.globals.maxSize)) {
[16:09:37.056]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.056]                         on.exit(options(oopts), add = TRUE)
[16:09:37.056]                       }
[16:09:37.056]                       {
[16:09:37.056]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.056]                           FUN = function(jj) {
[16:09:37.056]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.056]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.056]                           })
[16:09:37.056]                       }
[16:09:37.056]                     }, args = future.call.arguments)
[16:09:37.056]                   }
[16:09:37.056]                 }, immediateCondition = function(cond) {
[16:09:37.056]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.056]                   sendCondition(cond)
[16:09:37.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.056]                   {
[16:09:37.056]                     inherits <- base::inherits
[16:09:37.056]                     invokeRestart <- base::invokeRestart
[16:09:37.056]                     is.null <- base::is.null
[16:09:37.056]                     muffled <- FALSE
[16:09:37.056]                     if (inherits(cond, "message")) {
[16:09:37.056]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.056]                       if (muffled) 
[16:09:37.056]                         invokeRestart("muffleMessage")
[16:09:37.056]                     }
[16:09:37.056]                     else if (inherits(cond, "warning")) {
[16:09:37.056]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.056]                       if (muffled) 
[16:09:37.056]                         invokeRestart("muffleWarning")
[16:09:37.056]                     }
[16:09:37.056]                     else if (inherits(cond, "condition")) {
[16:09:37.056]                       if (!is.null(pattern)) {
[16:09:37.056]                         computeRestarts <- base::computeRestarts
[16:09:37.056]                         grepl <- base::grepl
[16:09:37.056]                         restarts <- computeRestarts(cond)
[16:09:37.056]                         for (restart in restarts) {
[16:09:37.056]                           name <- restart$name
[16:09:37.056]                           if (is.null(name)) 
[16:09:37.056]                             next
[16:09:37.056]                           if (!grepl(pattern, name)) 
[16:09:37.056]                             next
[16:09:37.056]                           invokeRestart(restart)
[16:09:37.056]                           muffled <- TRUE
[16:09:37.056]                           break
[16:09:37.056]                         }
[16:09:37.056]                       }
[16:09:37.056]                     }
[16:09:37.056]                     invisible(muffled)
[16:09:37.056]                   }
[16:09:37.056]                   muffleCondition(cond)
[16:09:37.056]                 })
[16:09:37.056]             }))
[16:09:37.056]             future::FutureResult(value = ...future.value$value, 
[16:09:37.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.056]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.056]                     ...future.globalenv.names))
[16:09:37.056]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.056]         }, condition = base::local({
[16:09:37.056]             c <- base::c
[16:09:37.056]             inherits <- base::inherits
[16:09:37.056]             invokeRestart <- base::invokeRestart
[16:09:37.056]             length <- base::length
[16:09:37.056]             list <- base::list
[16:09:37.056]             seq.int <- base::seq.int
[16:09:37.056]             signalCondition <- base::signalCondition
[16:09:37.056]             sys.calls <- base::sys.calls
[16:09:37.056]             `[[` <- base::`[[`
[16:09:37.056]             `+` <- base::`+`
[16:09:37.056]             `<<-` <- base::`<<-`
[16:09:37.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.056]                   3L)]
[16:09:37.056]             }
[16:09:37.056]             function(cond) {
[16:09:37.056]                 is_error <- inherits(cond, "error")
[16:09:37.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.056]                   NULL)
[16:09:37.056]                 if (is_error) {
[16:09:37.056]                   sessionInformation <- function() {
[16:09:37.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.056]                       search = base::search(), system = base::Sys.info())
[16:09:37.056]                   }
[16:09:37.056]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.056]                     cond$call), session = sessionInformation(), 
[16:09:37.056]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.056]                   signalCondition(cond)
[16:09:37.056]                 }
[16:09:37.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.056]                 "immediateCondition"))) {
[16:09:37.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.056]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.056]                   if (TRUE && !signal) {
[16:09:37.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.056]                     {
[16:09:37.056]                       inherits <- base::inherits
[16:09:37.056]                       invokeRestart <- base::invokeRestart
[16:09:37.056]                       is.null <- base::is.null
[16:09:37.056]                       muffled <- FALSE
[16:09:37.056]                       if (inherits(cond, "message")) {
[16:09:37.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.056]                         if (muffled) 
[16:09:37.056]                           invokeRestart("muffleMessage")
[16:09:37.056]                       }
[16:09:37.056]                       else if (inherits(cond, "warning")) {
[16:09:37.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.056]                         if (muffled) 
[16:09:37.056]                           invokeRestart("muffleWarning")
[16:09:37.056]                       }
[16:09:37.056]                       else if (inherits(cond, "condition")) {
[16:09:37.056]                         if (!is.null(pattern)) {
[16:09:37.056]                           computeRestarts <- base::computeRestarts
[16:09:37.056]                           grepl <- base::grepl
[16:09:37.056]                           restarts <- computeRestarts(cond)
[16:09:37.056]                           for (restart in restarts) {
[16:09:37.056]                             name <- restart$name
[16:09:37.056]                             if (is.null(name)) 
[16:09:37.056]                               next
[16:09:37.056]                             if (!grepl(pattern, name)) 
[16:09:37.056]                               next
[16:09:37.056]                             invokeRestart(restart)
[16:09:37.056]                             muffled <- TRUE
[16:09:37.056]                             break
[16:09:37.056]                           }
[16:09:37.056]                         }
[16:09:37.056]                       }
[16:09:37.056]                       invisible(muffled)
[16:09:37.056]                     }
[16:09:37.056]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.056]                   }
[16:09:37.056]                 }
[16:09:37.056]                 else {
[16:09:37.056]                   if (TRUE) {
[16:09:37.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.056]                     {
[16:09:37.056]                       inherits <- base::inherits
[16:09:37.056]                       invokeRestart <- base::invokeRestart
[16:09:37.056]                       is.null <- base::is.null
[16:09:37.056]                       muffled <- FALSE
[16:09:37.056]                       if (inherits(cond, "message")) {
[16:09:37.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.056]                         if (muffled) 
[16:09:37.056]                           invokeRestart("muffleMessage")
[16:09:37.056]                       }
[16:09:37.056]                       else if (inherits(cond, "warning")) {
[16:09:37.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.056]                         if (muffled) 
[16:09:37.056]                           invokeRestart("muffleWarning")
[16:09:37.056]                       }
[16:09:37.056]                       else if (inherits(cond, "condition")) {
[16:09:37.056]                         if (!is.null(pattern)) {
[16:09:37.056]                           computeRestarts <- base::computeRestarts
[16:09:37.056]                           grepl <- base::grepl
[16:09:37.056]                           restarts <- computeRestarts(cond)
[16:09:37.056]                           for (restart in restarts) {
[16:09:37.056]                             name <- restart$name
[16:09:37.056]                             if (is.null(name)) 
[16:09:37.056]                               next
[16:09:37.056]                             if (!grepl(pattern, name)) 
[16:09:37.056]                               next
[16:09:37.056]                             invokeRestart(restart)
[16:09:37.056]                             muffled <- TRUE
[16:09:37.056]                             break
[16:09:37.056]                           }
[16:09:37.056]                         }
[16:09:37.056]                       }
[16:09:37.056]                       invisible(muffled)
[16:09:37.056]                     }
[16:09:37.056]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.056]                   }
[16:09:37.056]                 }
[16:09:37.056]             }
[16:09:37.056]         }))
[16:09:37.056]     }, error = function(ex) {
[16:09:37.056]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.056]                 ...future.rng), started = ...future.startTime, 
[16:09:37.056]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.056]             version = "1.8"), class = "FutureResult")
[16:09:37.056]     }, finally = {
[16:09:37.056]         if (!identical(...future.workdir, getwd())) 
[16:09:37.056]             setwd(...future.workdir)
[16:09:37.056]         {
[16:09:37.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.056]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.056]             }
[16:09:37.056]             base::options(...future.oldOptions)
[16:09:37.056]             if (.Platform$OS.type == "windows") {
[16:09:37.056]                 old_names <- names(...future.oldEnvVars)
[16:09:37.056]                 envs <- base::Sys.getenv()
[16:09:37.056]                 names <- names(envs)
[16:09:37.056]                 common <- intersect(names, old_names)
[16:09:37.056]                 added <- setdiff(names, old_names)
[16:09:37.056]                 removed <- setdiff(old_names, names)
[16:09:37.056]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.056]                   envs[common]]
[16:09:37.056]                 NAMES <- toupper(changed)
[16:09:37.056]                 args <- list()
[16:09:37.056]                 for (kk in seq_along(NAMES)) {
[16:09:37.056]                   name <- changed[[kk]]
[16:09:37.056]                   NAME <- NAMES[[kk]]
[16:09:37.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.056]                     next
[16:09:37.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.056]                 }
[16:09:37.056]                 NAMES <- toupper(added)
[16:09:37.056]                 for (kk in seq_along(NAMES)) {
[16:09:37.056]                   name <- added[[kk]]
[16:09:37.056]                   NAME <- NAMES[[kk]]
[16:09:37.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.056]                     next
[16:09:37.056]                   args[[name]] <- ""
[16:09:37.056]                 }
[16:09:37.056]                 NAMES <- toupper(removed)
[16:09:37.056]                 for (kk in seq_along(NAMES)) {
[16:09:37.056]                   name <- removed[[kk]]
[16:09:37.056]                   NAME <- NAMES[[kk]]
[16:09:37.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.056]                     next
[16:09:37.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.056]                 }
[16:09:37.056]                 if (length(args) > 0) 
[16:09:37.056]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.056]             }
[16:09:37.056]             else {
[16:09:37.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.056]             }
[16:09:37.056]             {
[16:09:37.056]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.056]                   0L) {
[16:09:37.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.056]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.056]                   base::options(opts)
[16:09:37.056]                 }
[16:09:37.056]                 {
[16:09:37.056]                   {
[16:09:37.056]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.056]                     NULL
[16:09:37.056]                   }
[16:09:37.056]                   options(future.plan = NULL)
[16:09:37.056]                   if (is.na(NA_character_)) 
[16:09:37.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.056]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.056]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.056]                     envir = parent.frame()) 
[16:09:37.056]                   {
[16:09:37.056]                     if (is.function(workers)) 
[16:09:37.056]                       workers <- workers()
[16:09:37.056]                     workers <- structure(as.integer(workers), 
[16:09:37.056]                       class = class(workers))
[16:09:37.056]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.056]                       workers >= 1)
[16:09:37.056]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.056]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.056]                     }
[16:09:37.056]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.056]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.056]                       envir = envir)
[16:09:37.056]                     if (!future$lazy) 
[16:09:37.056]                       future <- run(future)
[16:09:37.056]                     invisible(future)
[16:09:37.056]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.056]                 }
[16:09:37.056]             }
[16:09:37.056]         }
[16:09:37.056]     })
[16:09:37.056]     if (TRUE) {
[16:09:37.056]         base::sink(type = "output", split = FALSE)
[16:09:37.056]         if (TRUE) {
[16:09:37.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.056]         }
[16:09:37.056]         else {
[16:09:37.056]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.056]         }
[16:09:37.056]         base::close(...future.stdout)
[16:09:37.056]         ...future.stdout <- NULL
[16:09:37.056]     }
[16:09:37.056]     ...future.result$conditions <- ...future.conditions
[16:09:37.056]     ...future.result$finished <- base::Sys.time()
[16:09:37.056]     ...future.result
[16:09:37.056] }
[16:09:37.059] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:09:37.060] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:09:37.060] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:09:37.061] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:37.061] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.061] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:09:37.062] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:09:37.062] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:37.062] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.062] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:37.063] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.063] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:09:37.063] MultisessionFuture started
[16:09:37.064] - Launch lazy future ... done
[16:09:37.064] run() for ‘MultisessionFuture’ ... done
[16:09:37.064] Created future:
[16:09:37.064] MultisessionFuture:
[16:09:37.064] Label: ‘future_eapply-1’
[16:09:37.064] Expression:
[16:09:37.064] {
[16:09:37.064]     do.call(function(...) {
[16:09:37.064]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.064]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.064]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.064]             on.exit(options(oopts), add = TRUE)
[16:09:37.064]         }
[16:09:37.064]         {
[16:09:37.064]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.064]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.064]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.064]             })
[16:09:37.064]         }
[16:09:37.064]     }, args = future.call.arguments)
[16:09:37.064] }
[16:09:37.064] Lazy evaluation: FALSE
[16:09:37.064] Asynchronous evaluation: TRUE
[16:09:37.064] Local evaluation: TRUE
[16:09:37.064] Environment: R_GlobalEnv
[16:09:37.064] Capture standard output: TRUE
[16:09:37.064] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.064] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.064] Packages: <none>
[16:09:37.064] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.064] Resolved: FALSE
[16:09:37.064] Value: <not collected>
[16:09:37.064] Conditions captured: <none>
[16:09:37.064] Early signaling: FALSE
[16:09:37.064] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.064] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.076] Chunk #1 of 2 ... DONE
[16:09:37.076] Chunk #2 of 2 ...
[16:09:37.077]  - Finding globals in 'X' for chunk #2 ...
[16:09:37.077] getGlobalsAndPackages() ...
[16:09:37.077] Searching for globals...
[16:09:37.077] 
[16:09:37.077] Searching for globals ... DONE
[16:09:37.077] - globals: [0] <none>
[16:09:37.077] getGlobalsAndPackages() ... DONE
[16:09:37.078]    + additional globals found: [n=0] 
[16:09:37.078]    + additional namespaces needed: [n=0] 
[16:09:37.078]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:37.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:37.078]  - seeds: <none>
[16:09:37.078] getGlobalsAndPackages() ...
[16:09:37.078] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.078] Resolving globals: FALSE
[16:09:37.079] Tweak future expression to call with '...' arguments ...
[16:09:37.079] {
[16:09:37.079]     do.call(function(...) {
[16:09:37.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.079]             on.exit(options(oopts), add = TRUE)
[16:09:37.079]         }
[16:09:37.079]         {
[16:09:37.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.079]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.079]             })
[16:09:37.079]         }
[16:09:37.079]     }, args = future.call.arguments)
[16:09:37.079] }
[16:09:37.079] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.079] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.080] 
[16:09:37.080] getGlobalsAndPackages() ... DONE
[16:09:37.080] run() for ‘Future’ ...
[16:09:37.080] - state: ‘created’
[16:09:37.080] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.095] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.095]   - Field: ‘node’
[16:09:37.095]   - Field: ‘label’
[16:09:37.096]   - Field: ‘local’
[16:09:37.096]   - Field: ‘owner’
[16:09:37.096]   - Field: ‘envir’
[16:09:37.096]   - Field: ‘workers’
[16:09:37.096]   - Field: ‘packages’
[16:09:37.096]   - Field: ‘gc’
[16:09:37.096]   - Field: ‘conditions’
[16:09:37.096]   - Field: ‘persistent’
[16:09:37.096]   - Field: ‘expr’
[16:09:37.096]   - Field: ‘uuid’
[16:09:37.097]   - Field: ‘seed’
[16:09:37.097]   - Field: ‘version’
[16:09:37.097]   - Field: ‘result’
[16:09:37.097]   - Field: ‘asynchronous’
[16:09:37.097]   - Field: ‘calls’
[16:09:37.097]   - Field: ‘globals’
[16:09:37.097]   - Field: ‘stdout’
[16:09:37.097]   - Field: ‘earlySignal’
[16:09:37.098]   - Field: ‘lazy’
[16:09:37.098]   - Field: ‘state’
[16:09:37.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.098] - Launch lazy future ...
[16:09:37.098] Packages needed by the future expression (n = 0): <none>
[16:09:37.098] Packages needed by future strategies (n = 0): <none>
[16:09:37.099] {
[16:09:37.099]     {
[16:09:37.099]         {
[16:09:37.099]             ...future.startTime <- base::Sys.time()
[16:09:37.099]             {
[16:09:37.099]                 {
[16:09:37.099]                   {
[16:09:37.099]                     {
[16:09:37.099]                       base::local({
[16:09:37.099]                         has_future <- base::requireNamespace("future", 
[16:09:37.099]                           quietly = TRUE)
[16:09:37.099]                         if (has_future) {
[16:09:37.099]                           ns <- base::getNamespace("future")
[16:09:37.099]                           version <- ns[[".package"]][["version"]]
[16:09:37.099]                           if (is.null(version)) 
[16:09:37.099]                             version <- utils::packageVersion("future")
[16:09:37.099]                         }
[16:09:37.099]                         else {
[16:09:37.099]                           version <- NULL
[16:09:37.099]                         }
[16:09:37.099]                         if (!has_future || version < "1.8.0") {
[16:09:37.099]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.099]                             "", base::R.version$version.string), 
[16:09:37.099]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:37.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:37.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.099]                               "release", "version")], collapse = " "), 
[16:09:37.099]                             hostname = base::Sys.info()[["nodename"]])
[16:09:37.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.099]                             info)
[16:09:37.099]                           info <- base::paste(info, collapse = "; ")
[16:09:37.099]                           if (!has_future) {
[16:09:37.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.099]                               info)
[16:09:37.099]                           }
[16:09:37.099]                           else {
[16:09:37.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.099]                               info, version)
[16:09:37.099]                           }
[16:09:37.099]                           base::stop(msg)
[16:09:37.099]                         }
[16:09:37.099]                       })
[16:09:37.099]                     }
[16:09:37.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.099]                     base::options(mc.cores = 1L)
[16:09:37.099]                   }
[16:09:37.099]                   options(future.plan = NULL)
[16:09:37.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.099]                 }
[16:09:37.099]                 ...future.workdir <- getwd()
[16:09:37.099]             }
[16:09:37.099]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.099]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.099]         }
[16:09:37.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.099]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:37.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.099]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.099]             base::names(...future.oldOptions))
[16:09:37.099]     }
[16:09:37.099]     if (FALSE) {
[16:09:37.099]     }
[16:09:37.099]     else {
[16:09:37.099]         if (TRUE) {
[16:09:37.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.099]                 open = "w")
[16:09:37.099]         }
[16:09:37.099]         else {
[16:09:37.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.099]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.099]         }
[16:09:37.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.099]             base::sink(type = "output", split = FALSE)
[16:09:37.099]             base::close(...future.stdout)
[16:09:37.099]         }, add = TRUE)
[16:09:37.099]     }
[16:09:37.099]     ...future.frame <- base::sys.nframe()
[16:09:37.099]     ...future.conditions <- base::list()
[16:09:37.099]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.099]     if (FALSE) {
[16:09:37.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.099]     }
[16:09:37.099]     ...future.result <- base::tryCatch({
[16:09:37.099]         base::withCallingHandlers({
[16:09:37.099]             ...future.value <- base::withVisible(base::local({
[16:09:37.099]                 ...future.makeSendCondition <- local({
[16:09:37.099]                   sendCondition <- NULL
[16:09:37.099]                   function(frame = 1L) {
[16:09:37.099]                     if (is.function(sendCondition)) 
[16:09:37.099]                       return(sendCondition)
[16:09:37.099]                     ns <- getNamespace("parallel")
[16:09:37.099]                     if (exists("sendData", mode = "function", 
[16:09:37.099]                       envir = ns)) {
[16:09:37.099]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.099]                         envir = ns)
[16:09:37.099]                       envir <- sys.frame(frame)
[16:09:37.099]                       master <- NULL
[16:09:37.099]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.099]                         !identical(envir, emptyenv())) {
[16:09:37.099]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.099]                           inherits = FALSE)) {
[16:09:37.099]                           master <- get("master", mode = "list", 
[16:09:37.099]                             envir = envir, inherits = FALSE)
[16:09:37.099]                           if (inherits(master, c("SOCKnode", 
[16:09:37.099]                             "SOCK0node"))) {
[16:09:37.099]                             sendCondition <<- function(cond) {
[16:09:37.099]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.099]                                 success = TRUE)
[16:09:37.099]                               parallel_sendData(master, data)
[16:09:37.099]                             }
[16:09:37.099]                             return(sendCondition)
[16:09:37.099]                           }
[16:09:37.099]                         }
[16:09:37.099]                         frame <- frame + 1L
[16:09:37.099]                         envir <- sys.frame(frame)
[16:09:37.099]                       }
[16:09:37.099]                     }
[16:09:37.099]                     sendCondition <<- function(cond) NULL
[16:09:37.099]                   }
[16:09:37.099]                 })
[16:09:37.099]                 withCallingHandlers({
[16:09:37.099]                   {
[16:09:37.099]                     do.call(function(...) {
[16:09:37.099]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.099]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.099]                         ...future.globals.maxSize)) {
[16:09:37.099]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.099]                         on.exit(options(oopts), add = TRUE)
[16:09:37.099]                       }
[16:09:37.099]                       {
[16:09:37.099]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.099]                           FUN = function(jj) {
[16:09:37.099]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.099]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.099]                           })
[16:09:37.099]                       }
[16:09:37.099]                     }, args = future.call.arguments)
[16:09:37.099]                   }
[16:09:37.099]                 }, immediateCondition = function(cond) {
[16:09:37.099]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.099]                   sendCondition(cond)
[16:09:37.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.099]                   {
[16:09:37.099]                     inherits <- base::inherits
[16:09:37.099]                     invokeRestart <- base::invokeRestart
[16:09:37.099]                     is.null <- base::is.null
[16:09:37.099]                     muffled <- FALSE
[16:09:37.099]                     if (inherits(cond, "message")) {
[16:09:37.099]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.099]                       if (muffled) 
[16:09:37.099]                         invokeRestart("muffleMessage")
[16:09:37.099]                     }
[16:09:37.099]                     else if (inherits(cond, "warning")) {
[16:09:37.099]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.099]                       if (muffled) 
[16:09:37.099]                         invokeRestart("muffleWarning")
[16:09:37.099]                     }
[16:09:37.099]                     else if (inherits(cond, "condition")) {
[16:09:37.099]                       if (!is.null(pattern)) {
[16:09:37.099]                         computeRestarts <- base::computeRestarts
[16:09:37.099]                         grepl <- base::grepl
[16:09:37.099]                         restarts <- computeRestarts(cond)
[16:09:37.099]                         for (restart in restarts) {
[16:09:37.099]                           name <- restart$name
[16:09:37.099]                           if (is.null(name)) 
[16:09:37.099]                             next
[16:09:37.099]                           if (!grepl(pattern, name)) 
[16:09:37.099]                             next
[16:09:37.099]                           invokeRestart(restart)
[16:09:37.099]                           muffled <- TRUE
[16:09:37.099]                           break
[16:09:37.099]                         }
[16:09:37.099]                       }
[16:09:37.099]                     }
[16:09:37.099]                     invisible(muffled)
[16:09:37.099]                   }
[16:09:37.099]                   muffleCondition(cond)
[16:09:37.099]                 })
[16:09:37.099]             }))
[16:09:37.099]             future::FutureResult(value = ...future.value$value, 
[16:09:37.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.099]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.099]                     ...future.globalenv.names))
[16:09:37.099]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.099]         }, condition = base::local({
[16:09:37.099]             c <- base::c
[16:09:37.099]             inherits <- base::inherits
[16:09:37.099]             invokeRestart <- base::invokeRestart
[16:09:37.099]             length <- base::length
[16:09:37.099]             list <- base::list
[16:09:37.099]             seq.int <- base::seq.int
[16:09:37.099]             signalCondition <- base::signalCondition
[16:09:37.099]             sys.calls <- base::sys.calls
[16:09:37.099]             `[[` <- base::`[[`
[16:09:37.099]             `+` <- base::`+`
[16:09:37.099]             `<<-` <- base::`<<-`
[16:09:37.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.099]                   3L)]
[16:09:37.099]             }
[16:09:37.099]             function(cond) {
[16:09:37.099]                 is_error <- inherits(cond, "error")
[16:09:37.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.099]                   NULL)
[16:09:37.099]                 if (is_error) {
[16:09:37.099]                   sessionInformation <- function() {
[16:09:37.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.099]                       search = base::search(), system = base::Sys.info())
[16:09:37.099]                   }
[16:09:37.099]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.099]                     cond$call), session = sessionInformation(), 
[16:09:37.099]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.099]                   signalCondition(cond)
[16:09:37.099]                 }
[16:09:37.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.099]                 "immediateCondition"))) {
[16:09:37.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.099]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.099]                   if (TRUE && !signal) {
[16:09:37.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.099]                     {
[16:09:37.099]                       inherits <- base::inherits
[16:09:37.099]                       invokeRestart <- base::invokeRestart
[16:09:37.099]                       is.null <- base::is.null
[16:09:37.099]                       muffled <- FALSE
[16:09:37.099]                       if (inherits(cond, "message")) {
[16:09:37.099]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.099]                         if (muffled) 
[16:09:37.099]                           invokeRestart("muffleMessage")
[16:09:37.099]                       }
[16:09:37.099]                       else if (inherits(cond, "warning")) {
[16:09:37.099]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.099]                         if (muffled) 
[16:09:37.099]                           invokeRestart("muffleWarning")
[16:09:37.099]                       }
[16:09:37.099]                       else if (inherits(cond, "condition")) {
[16:09:37.099]                         if (!is.null(pattern)) {
[16:09:37.099]                           computeRestarts <- base::computeRestarts
[16:09:37.099]                           grepl <- base::grepl
[16:09:37.099]                           restarts <- computeRestarts(cond)
[16:09:37.099]                           for (restart in restarts) {
[16:09:37.099]                             name <- restart$name
[16:09:37.099]                             if (is.null(name)) 
[16:09:37.099]                               next
[16:09:37.099]                             if (!grepl(pattern, name)) 
[16:09:37.099]                               next
[16:09:37.099]                             invokeRestart(restart)
[16:09:37.099]                             muffled <- TRUE
[16:09:37.099]                             break
[16:09:37.099]                           }
[16:09:37.099]                         }
[16:09:37.099]                       }
[16:09:37.099]                       invisible(muffled)
[16:09:37.099]                     }
[16:09:37.099]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.099]                   }
[16:09:37.099]                 }
[16:09:37.099]                 else {
[16:09:37.099]                   if (TRUE) {
[16:09:37.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.099]                     {
[16:09:37.099]                       inherits <- base::inherits
[16:09:37.099]                       invokeRestart <- base::invokeRestart
[16:09:37.099]                       is.null <- base::is.null
[16:09:37.099]                       muffled <- FALSE
[16:09:37.099]                       if (inherits(cond, "message")) {
[16:09:37.099]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.099]                         if (muffled) 
[16:09:37.099]                           invokeRestart("muffleMessage")
[16:09:37.099]                       }
[16:09:37.099]                       else if (inherits(cond, "warning")) {
[16:09:37.099]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.099]                         if (muffled) 
[16:09:37.099]                           invokeRestart("muffleWarning")
[16:09:37.099]                       }
[16:09:37.099]                       else if (inherits(cond, "condition")) {
[16:09:37.099]                         if (!is.null(pattern)) {
[16:09:37.099]                           computeRestarts <- base::computeRestarts
[16:09:37.099]                           grepl <- base::grepl
[16:09:37.099]                           restarts <- computeRestarts(cond)
[16:09:37.099]                           for (restart in restarts) {
[16:09:37.099]                             name <- restart$name
[16:09:37.099]                             if (is.null(name)) 
[16:09:37.099]                               next
[16:09:37.099]                             if (!grepl(pattern, name)) 
[16:09:37.099]                               next
[16:09:37.099]                             invokeRestart(restart)
[16:09:37.099]                             muffled <- TRUE
[16:09:37.099]                             break
[16:09:37.099]                           }
[16:09:37.099]                         }
[16:09:37.099]                       }
[16:09:37.099]                       invisible(muffled)
[16:09:37.099]                     }
[16:09:37.099]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.099]                   }
[16:09:37.099]                 }
[16:09:37.099]             }
[16:09:37.099]         }))
[16:09:37.099]     }, error = function(ex) {
[16:09:37.099]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.099]                 ...future.rng), started = ...future.startTime, 
[16:09:37.099]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.099]             version = "1.8"), class = "FutureResult")
[16:09:37.099]     }, finally = {
[16:09:37.099]         if (!identical(...future.workdir, getwd())) 
[16:09:37.099]             setwd(...future.workdir)
[16:09:37.099]         {
[16:09:37.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.099]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.099]             }
[16:09:37.099]             base::options(...future.oldOptions)
[16:09:37.099]             if (.Platform$OS.type == "windows") {
[16:09:37.099]                 old_names <- names(...future.oldEnvVars)
[16:09:37.099]                 envs <- base::Sys.getenv()
[16:09:37.099]                 names <- names(envs)
[16:09:37.099]                 common <- intersect(names, old_names)
[16:09:37.099]                 added <- setdiff(names, old_names)
[16:09:37.099]                 removed <- setdiff(old_names, names)
[16:09:37.099]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.099]                   envs[common]]
[16:09:37.099]                 NAMES <- toupper(changed)
[16:09:37.099]                 args <- list()
[16:09:37.099]                 for (kk in seq_along(NAMES)) {
[16:09:37.099]                   name <- changed[[kk]]
[16:09:37.099]                   NAME <- NAMES[[kk]]
[16:09:37.099]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.099]                     next
[16:09:37.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.099]                 }
[16:09:37.099]                 NAMES <- toupper(added)
[16:09:37.099]                 for (kk in seq_along(NAMES)) {
[16:09:37.099]                   name <- added[[kk]]
[16:09:37.099]                   NAME <- NAMES[[kk]]
[16:09:37.099]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.099]                     next
[16:09:37.099]                   args[[name]] <- ""
[16:09:37.099]                 }
[16:09:37.099]                 NAMES <- toupper(removed)
[16:09:37.099]                 for (kk in seq_along(NAMES)) {
[16:09:37.099]                   name <- removed[[kk]]
[16:09:37.099]                   NAME <- NAMES[[kk]]
[16:09:37.099]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.099]                     next
[16:09:37.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.099]                 }
[16:09:37.099]                 if (length(args) > 0) 
[16:09:37.099]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.099]             }
[16:09:37.099]             else {
[16:09:37.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.099]             }
[16:09:37.099]             {
[16:09:37.099]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.099]                   0L) {
[16:09:37.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.099]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.099]                   base::options(opts)
[16:09:37.099]                 }
[16:09:37.099]                 {
[16:09:37.099]                   {
[16:09:37.099]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.099]                     NULL
[16:09:37.099]                   }
[16:09:37.099]                   options(future.plan = NULL)
[16:09:37.099]                   if (is.na(NA_character_)) 
[16:09:37.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.099]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.099]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.099]                     envir = parent.frame()) 
[16:09:37.099]                   {
[16:09:37.099]                     if (is.function(workers)) 
[16:09:37.099]                       workers <- workers()
[16:09:37.099]                     workers <- structure(as.integer(workers), 
[16:09:37.099]                       class = class(workers))
[16:09:37.099]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.099]                       workers >= 1)
[16:09:37.099]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.099]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.099]                     }
[16:09:37.099]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.099]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.099]                       envir = envir)
[16:09:37.099]                     if (!future$lazy) 
[16:09:37.099]                       future <- run(future)
[16:09:37.099]                     invisible(future)
[16:09:37.099]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.099]                 }
[16:09:37.099]             }
[16:09:37.099]         }
[16:09:37.099]     })
[16:09:37.099]     if (TRUE) {
[16:09:37.099]         base::sink(type = "output", split = FALSE)
[16:09:37.099]         if (TRUE) {
[16:09:37.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.099]         }
[16:09:37.099]         else {
[16:09:37.099]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.099]         }
[16:09:37.099]         base::close(...future.stdout)
[16:09:37.099]         ...future.stdout <- NULL
[16:09:37.099]     }
[16:09:37.099]     ...future.result$conditions <- ...future.conditions
[16:09:37.099]     ...future.result$finished <- base::Sys.time()
[16:09:37.099]     ...future.result
[16:09:37.099] }
[16:09:37.170] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:09:37.170] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:09:37.170] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:09:37.171] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:37.171] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.171] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:09:37.172] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:09:37.172] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:37.172] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.172] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:37.173] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.173] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:09:37.174] MultisessionFuture started
[16:09:37.174] - Launch lazy future ... done
[16:09:37.174] run() for ‘MultisessionFuture’ ... done
[16:09:37.174] Created future:
[16:09:37.174] MultisessionFuture:
[16:09:37.174] Label: ‘future_eapply-2’
[16:09:37.174] Expression:
[16:09:37.174] {
[16:09:37.174]     do.call(function(...) {
[16:09:37.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.174]             on.exit(options(oopts), add = TRUE)
[16:09:37.174]         }
[16:09:37.174]         {
[16:09:37.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.174]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.174]             })
[16:09:37.174]         }
[16:09:37.174]     }, args = future.call.arguments)
[16:09:37.174] }
[16:09:37.174] Lazy evaluation: FALSE
[16:09:37.174] Asynchronous evaluation: TRUE
[16:09:37.174] Local evaluation: TRUE
[16:09:37.174] Environment: R_GlobalEnv
[16:09:37.174] Capture standard output: TRUE
[16:09:37.174] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.174] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.174] Packages: <none>
[16:09:37.174] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.174] Resolved: FALSE
[16:09:37.174] Value: <not collected>
[16:09:37.174] Conditions captured: <none>
[16:09:37.174] Early signaling: FALSE
[16:09:37.174] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.174] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.186] Chunk #2 of 2 ... DONE
[16:09:37.186] Launching 2 futures (chunks) ... DONE
[16:09:37.187] Resolving 2 futures (chunks) ...
[16:09:37.187] resolve() on list ...
[16:09:37.187]  recursive: 0
[16:09:37.187]  length: 2
[16:09:37.187] 
[16:09:37.188] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.188] - Validating connection of MultisessionFuture
[16:09:37.188] - received message: FutureResult
[16:09:37.188] - Received FutureResult
[16:09:37.188] - Erased future from FutureRegistry
[16:09:37.188] result() for ClusterFuture ...
[16:09:37.189] - result already collected: FutureResult
[16:09:37.189] result() for ClusterFuture ... done
[16:09:37.189] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.189] Future #1
[16:09:37.189] result() for ClusterFuture ...
[16:09:37.189] - result already collected: FutureResult
[16:09:37.189] result() for ClusterFuture ... done
[16:09:37.189] result() for ClusterFuture ...
[16:09:37.193] - result already collected: FutureResult
[16:09:37.193] result() for ClusterFuture ... done
[16:09:37.193] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:37.194] - nx: 2
[16:09:37.194] - relay: TRUE
[16:09:37.194] - stdout: TRUE
[16:09:37.194] - signal: TRUE
[16:09:37.194] - resignal: FALSE
[16:09:37.194] - force: TRUE
[16:09:37.194] - relayed: [n=2] FALSE, FALSE
[16:09:37.194] - queued futures: [n=2] FALSE, FALSE
[16:09:37.194]  - until=1
[16:09:37.194]  - relaying element #1
[16:09:37.194] result() for ClusterFuture ...
[16:09:37.194] - result already collected: FutureResult
[16:09:37.194] result() for ClusterFuture ... done
[16:09:37.195] result() for ClusterFuture ...
[16:09:37.195] - result already collected: FutureResult
[16:09:37.195] result() for ClusterFuture ... done
[16:09:37.195] result() for ClusterFuture ...
[16:09:37.195] - result already collected: FutureResult
[16:09:37.195] result() for ClusterFuture ... done
[16:09:37.195] result() for ClusterFuture ...
[16:09:37.195] - result already collected: FutureResult
[16:09:37.195] result() for ClusterFuture ... done
[16:09:37.195] - relayed: [n=2] TRUE, FALSE
[16:09:37.195] - queued futures: [n=2] TRUE, FALSE
[16:09:37.196] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:37.196]  length: 1 (resolved future 1)
[16:09:37.259] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.259] - Validating connection of MultisessionFuture
[16:09:37.259] - received message: FutureResult
[16:09:37.259] - Received FutureResult
[16:09:37.260] - Erased future from FutureRegistry
[16:09:37.260] result() for ClusterFuture ...
[16:09:37.260] - result already collected: FutureResult
[16:09:37.260] result() for ClusterFuture ... done
[16:09:37.260] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.260] Future #2
[16:09:37.260] result() for ClusterFuture ...
[16:09:37.260] - result already collected: FutureResult
[16:09:37.260] result() for ClusterFuture ... done
[16:09:37.260] result() for ClusterFuture ...
[16:09:37.261] - result already collected: FutureResult
[16:09:37.261] result() for ClusterFuture ... done
[16:09:37.261] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:37.261] - nx: 2
[16:09:37.261] - relay: TRUE
[16:09:37.261] - stdout: TRUE
[16:09:37.261] - signal: TRUE
[16:09:37.261] - resignal: FALSE
[16:09:37.261] - force: TRUE
[16:09:37.261] - relayed: [n=2] TRUE, FALSE
[16:09:37.261] - queued futures: [n=2] TRUE, FALSE
[16:09:37.261]  - until=2
[16:09:37.262]  - relaying element #2
[16:09:37.262] result() for ClusterFuture ...
[16:09:37.262] - result already collected: FutureResult
[16:09:37.262] result() for ClusterFuture ... done
[16:09:37.262] result() for ClusterFuture ...
[16:09:37.262] - result already collected: FutureResult
[16:09:37.262] result() for ClusterFuture ... done
[16:09:37.262] result() for ClusterFuture ...
[16:09:37.262] - result already collected: FutureResult
[16:09:37.262] result() for ClusterFuture ... done
[16:09:37.262] result() for ClusterFuture ...
[16:09:37.263] - result already collected: FutureResult
[16:09:37.263] result() for ClusterFuture ... done
[16:09:37.263] - relayed: [n=2] TRUE, TRUE
[16:09:37.263] - queued futures: [n=2] TRUE, TRUE
[16:09:37.263] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:37.263]  length: 0 (resolved future 2)
[16:09:37.263] Relaying remaining futures
[16:09:37.263] signalConditionsASAP(NULL, pos=0) ...
[16:09:37.263] - nx: 2
[16:09:37.263] - relay: TRUE
[16:09:37.263] - stdout: TRUE
[16:09:37.264] - signal: TRUE
[16:09:37.264] - resignal: FALSE
[16:09:37.264] - force: TRUE
[16:09:37.264] - relayed: [n=2] TRUE, TRUE
[16:09:37.264] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:37.264] - relayed: [n=2] TRUE, TRUE
[16:09:37.264] - queued futures: [n=2] TRUE, TRUE
[16:09:37.264] signalConditionsASAP(NULL, pos=0) ... done
[16:09:37.264] resolve() on list ... DONE
[16:09:37.264] result() for ClusterFuture ...
[16:09:37.265] - result already collected: FutureResult
[16:09:37.265] result() for ClusterFuture ... done
[16:09:37.265] result() for ClusterFuture ...
[16:09:37.265] - result already collected: FutureResult
[16:09:37.265] result() for ClusterFuture ... done
[16:09:37.265] result() for ClusterFuture ...
[16:09:37.265] - result already collected: FutureResult
[16:09:37.265] result() for ClusterFuture ... done
[16:09:37.265] result() for ClusterFuture ...
[16:09:37.265] - result already collected: FutureResult
[16:09:37.265] result() for ClusterFuture ... done
[16:09:37.266]  - Number of value chunks collected: 2
[16:09:37.266] Resolving 2 futures (chunks) ... DONE
[16:09:37.266] Reducing values from 2 chunks ...
[16:09:37.266]  - Number of values collected after concatenation: 3
[16:09:37.266]  - Number of values expected: 3
[16:09:37.266] Reducing values from 2 chunks ... DONE
[16:09:37.266] future_lapply() ... DONE
[16:09:37.267] future_lapply() ...
[16:09:37.271] Number of chunks: 2
[16:09:37.271] getGlobalsAndPackagesXApply() ...
[16:09:37.271]  - future.globals: TRUE
[16:09:37.271] getGlobalsAndPackages() ...
[16:09:37.271] Searching for globals...
[16:09:37.272] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:37.272] Searching for globals ... DONE
[16:09:37.272] Resolving globals: FALSE
[16:09:37.273] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:37.273] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:37.273] - globals: [1] ‘FUN’
[16:09:37.273] - packages: [1] ‘stats’
[16:09:37.273] getGlobalsAndPackages() ... DONE
[16:09:37.274]  - globals found/used: [n=1] ‘FUN’
[16:09:37.274]  - needed namespaces: [n=1] ‘stats’
[16:09:37.274] Finding globals ... DONE
[16:09:37.274]  - use_args: TRUE
[16:09:37.274]  - Getting '...' globals ...
[16:09:37.274] resolve() on list ...
[16:09:37.274]  recursive: 0
[16:09:37.275]  length: 1
[16:09:37.275]  elements: ‘...’
[16:09:37.275]  length: 0 (resolved future 1)
[16:09:37.275] resolve() on list ... DONE
[16:09:37.275]    - '...' content: [n=1] ‘probs’
[16:09:37.275] List of 1
[16:09:37.275]  $ ...:List of 1
[16:09:37.275]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:37.275]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.275]  - attr(*, "where")=List of 1
[16:09:37.275]   ..$ ...:<environment: 0x55b4b7e62928> 
[16:09:37.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.275]  - attr(*, "resolved")= logi TRUE
[16:09:37.275]  - attr(*, "total_size")= num NA
[16:09:37.278]  - Getting '...' globals ... DONE
[16:09:37.278] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:37.279] List of 2
[16:09:37.279]  $ ...future.FUN:function (x, ...)  
[16:09:37.279]  $ ...          :List of 1
[16:09:37.279]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:09:37.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.279]  - attr(*, "where")=List of 2
[16:09:37.279]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:37.279]   ..$ ...          :<environment: 0x55b4b7e62928> 
[16:09:37.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.279]  - attr(*, "resolved")= logi FALSE
[16:09:37.279]  - attr(*, "total_size")= num 1328
[16:09:37.282] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:37.282] getGlobalsAndPackagesXApply() ... DONE
[16:09:37.282] Number of futures (= number of chunks): 2
[16:09:37.282] Launching 2 futures (chunks) ...
[16:09:37.282] Chunk #1 of 2 ...
[16:09:37.282]  - Finding globals in 'X' for chunk #1 ...
[16:09:37.282] getGlobalsAndPackages() ...
[16:09:37.283] Searching for globals...
[16:09:37.283] 
[16:09:37.283] Searching for globals ... DONE
[16:09:37.283] - globals: [0] <none>
[16:09:37.283] getGlobalsAndPackages() ... DONE
[16:09:37.283]    + additional globals found: [n=0] 
[16:09:37.283]    + additional namespaces needed: [n=0] 
[16:09:37.283]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:37.283]  - seeds: <none>
[16:09:37.283] getGlobalsAndPackages() ...
[16:09:37.284] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.284] Resolving globals: FALSE
[16:09:37.284] Tweak future expression to call with '...' arguments ...
[16:09:37.284] {
[16:09:37.284]     do.call(function(...) {
[16:09:37.284]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.284]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.284]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.284]             on.exit(options(oopts), add = TRUE)
[16:09:37.284]         }
[16:09:37.284]         {
[16:09:37.284]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.284]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.284]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.284]             })
[16:09:37.284]         }
[16:09:37.284]     }, args = future.call.arguments)
[16:09:37.284] }
[16:09:37.284] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.285] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.285] - packages: [1] ‘stats’
[16:09:37.285] getGlobalsAndPackages() ... DONE
[16:09:37.285] run() for ‘Future’ ...
[16:09:37.285] - state: ‘created’
[16:09:37.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.301]   - Field: ‘node’
[16:09:37.301]   - Field: ‘label’
[16:09:37.301]   - Field: ‘local’
[16:09:37.301]   - Field: ‘owner’
[16:09:37.301]   - Field: ‘envir’
[16:09:37.301]   - Field: ‘workers’
[16:09:37.301]   - Field: ‘packages’
[16:09:37.301]   - Field: ‘gc’
[16:09:37.301]   - Field: ‘conditions’
[16:09:37.301]   - Field: ‘persistent’
[16:09:37.302]   - Field: ‘expr’
[16:09:37.302]   - Field: ‘uuid’
[16:09:37.302]   - Field: ‘seed’
[16:09:37.302]   - Field: ‘version’
[16:09:37.302]   - Field: ‘result’
[16:09:37.302]   - Field: ‘asynchronous’
[16:09:37.302]   - Field: ‘calls’
[16:09:37.302]   - Field: ‘globals’
[16:09:37.302]   - Field: ‘stdout’
[16:09:37.302]   - Field: ‘earlySignal’
[16:09:37.302]   - Field: ‘lazy’
[16:09:37.303]   - Field: ‘state’
[16:09:37.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.303] - Launch lazy future ...
[16:09:37.303] Packages needed by the future expression (n = 1): ‘stats’
[16:09:37.303] Packages needed by future strategies (n = 0): <none>
[16:09:37.304] {
[16:09:37.304]     {
[16:09:37.304]         {
[16:09:37.304]             ...future.startTime <- base::Sys.time()
[16:09:37.304]             {
[16:09:37.304]                 {
[16:09:37.304]                   {
[16:09:37.304]                     {
[16:09:37.304]                       {
[16:09:37.304]                         base::local({
[16:09:37.304]                           has_future <- base::requireNamespace("future", 
[16:09:37.304]                             quietly = TRUE)
[16:09:37.304]                           if (has_future) {
[16:09:37.304]                             ns <- base::getNamespace("future")
[16:09:37.304]                             version <- ns[[".package"]][["version"]]
[16:09:37.304]                             if (is.null(version)) 
[16:09:37.304]                               version <- utils::packageVersion("future")
[16:09:37.304]                           }
[16:09:37.304]                           else {
[16:09:37.304]                             version <- NULL
[16:09:37.304]                           }
[16:09:37.304]                           if (!has_future || version < "1.8.0") {
[16:09:37.304]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.304]                               "", base::R.version$version.string), 
[16:09:37.304]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:37.304]                                 base::R.version$platform, 8 * 
[16:09:37.304]                                   base::.Machine$sizeof.pointer), 
[16:09:37.304]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.304]                                 "release", "version")], collapse = " "), 
[16:09:37.304]                               hostname = base::Sys.info()[["nodename"]])
[16:09:37.304]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.304]                               info)
[16:09:37.304]                             info <- base::paste(info, collapse = "; ")
[16:09:37.304]                             if (!has_future) {
[16:09:37.304]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.304]                                 info)
[16:09:37.304]                             }
[16:09:37.304]                             else {
[16:09:37.304]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.304]                                 info, version)
[16:09:37.304]                             }
[16:09:37.304]                             base::stop(msg)
[16:09:37.304]                           }
[16:09:37.304]                         })
[16:09:37.304]                       }
[16:09:37.304]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.304]                       base::options(mc.cores = 1L)
[16:09:37.304]                     }
[16:09:37.304]                     base::local({
[16:09:37.304]                       for (pkg in "stats") {
[16:09:37.304]                         base::loadNamespace(pkg)
[16:09:37.304]                         base::library(pkg, character.only = TRUE)
[16:09:37.304]                       }
[16:09:37.304]                     })
[16:09:37.304]                   }
[16:09:37.304]                   options(future.plan = NULL)
[16:09:37.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.304]                 }
[16:09:37.304]                 ...future.workdir <- getwd()
[16:09:37.304]             }
[16:09:37.304]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.304]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.304]         }
[16:09:37.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.304]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:37.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.304]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.304]             base::names(...future.oldOptions))
[16:09:37.304]     }
[16:09:37.304]     if (FALSE) {
[16:09:37.304]     }
[16:09:37.304]     else {
[16:09:37.304]         if (TRUE) {
[16:09:37.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.304]                 open = "w")
[16:09:37.304]         }
[16:09:37.304]         else {
[16:09:37.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.304]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.304]         }
[16:09:37.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.304]             base::sink(type = "output", split = FALSE)
[16:09:37.304]             base::close(...future.stdout)
[16:09:37.304]         }, add = TRUE)
[16:09:37.304]     }
[16:09:37.304]     ...future.frame <- base::sys.nframe()
[16:09:37.304]     ...future.conditions <- base::list()
[16:09:37.304]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.304]     if (FALSE) {
[16:09:37.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.304]     }
[16:09:37.304]     ...future.result <- base::tryCatch({
[16:09:37.304]         base::withCallingHandlers({
[16:09:37.304]             ...future.value <- base::withVisible(base::local({
[16:09:37.304]                 ...future.makeSendCondition <- local({
[16:09:37.304]                   sendCondition <- NULL
[16:09:37.304]                   function(frame = 1L) {
[16:09:37.304]                     if (is.function(sendCondition)) 
[16:09:37.304]                       return(sendCondition)
[16:09:37.304]                     ns <- getNamespace("parallel")
[16:09:37.304]                     if (exists("sendData", mode = "function", 
[16:09:37.304]                       envir = ns)) {
[16:09:37.304]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.304]                         envir = ns)
[16:09:37.304]                       envir <- sys.frame(frame)
[16:09:37.304]                       master <- NULL
[16:09:37.304]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.304]                         !identical(envir, emptyenv())) {
[16:09:37.304]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.304]                           inherits = FALSE)) {
[16:09:37.304]                           master <- get("master", mode = "list", 
[16:09:37.304]                             envir = envir, inherits = FALSE)
[16:09:37.304]                           if (inherits(master, c("SOCKnode", 
[16:09:37.304]                             "SOCK0node"))) {
[16:09:37.304]                             sendCondition <<- function(cond) {
[16:09:37.304]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.304]                                 success = TRUE)
[16:09:37.304]                               parallel_sendData(master, data)
[16:09:37.304]                             }
[16:09:37.304]                             return(sendCondition)
[16:09:37.304]                           }
[16:09:37.304]                         }
[16:09:37.304]                         frame <- frame + 1L
[16:09:37.304]                         envir <- sys.frame(frame)
[16:09:37.304]                       }
[16:09:37.304]                     }
[16:09:37.304]                     sendCondition <<- function(cond) NULL
[16:09:37.304]                   }
[16:09:37.304]                 })
[16:09:37.304]                 withCallingHandlers({
[16:09:37.304]                   {
[16:09:37.304]                     do.call(function(...) {
[16:09:37.304]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.304]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.304]                         ...future.globals.maxSize)) {
[16:09:37.304]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.304]                         on.exit(options(oopts), add = TRUE)
[16:09:37.304]                       }
[16:09:37.304]                       {
[16:09:37.304]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.304]                           FUN = function(jj) {
[16:09:37.304]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.304]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.304]                           })
[16:09:37.304]                       }
[16:09:37.304]                     }, args = future.call.arguments)
[16:09:37.304]                   }
[16:09:37.304]                 }, immediateCondition = function(cond) {
[16:09:37.304]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.304]                   sendCondition(cond)
[16:09:37.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.304]                   {
[16:09:37.304]                     inherits <- base::inherits
[16:09:37.304]                     invokeRestart <- base::invokeRestart
[16:09:37.304]                     is.null <- base::is.null
[16:09:37.304]                     muffled <- FALSE
[16:09:37.304]                     if (inherits(cond, "message")) {
[16:09:37.304]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.304]                       if (muffled) 
[16:09:37.304]                         invokeRestart("muffleMessage")
[16:09:37.304]                     }
[16:09:37.304]                     else if (inherits(cond, "warning")) {
[16:09:37.304]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.304]                       if (muffled) 
[16:09:37.304]                         invokeRestart("muffleWarning")
[16:09:37.304]                     }
[16:09:37.304]                     else if (inherits(cond, "condition")) {
[16:09:37.304]                       if (!is.null(pattern)) {
[16:09:37.304]                         computeRestarts <- base::computeRestarts
[16:09:37.304]                         grepl <- base::grepl
[16:09:37.304]                         restarts <- computeRestarts(cond)
[16:09:37.304]                         for (restart in restarts) {
[16:09:37.304]                           name <- restart$name
[16:09:37.304]                           if (is.null(name)) 
[16:09:37.304]                             next
[16:09:37.304]                           if (!grepl(pattern, name)) 
[16:09:37.304]                             next
[16:09:37.304]                           invokeRestart(restart)
[16:09:37.304]                           muffled <- TRUE
[16:09:37.304]                           break
[16:09:37.304]                         }
[16:09:37.304]                       }
[16:09:37.304]                     }
[16:09:37.304]                     invisible(muffled)
[16:09:37.304]                   }
[16:09:37.304]                   muffleCondition(cond)
[16:09:37.304]                 })
[16:09:37.304]             }))
[16:09:37.304]             future::FutureResult(value = ...future.value$value, 
[16:09:37.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.304]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.304]                     ...future.globalenv.names))
[16:09:37.304]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.304]         }, condition = base::local({
[16:09:37.304]             c <- base::c
[16:09:37.304]             inherits <- base::inherits
[16:09:37.304]             invokeRestart <- base::invokeRestart
[16:09:37.304]             length <- base::length
[16:09:37.304]             list <- base::list
[16:09:37.304]             seq.int <- base::seq.int
[16:09:37.304]             signalCondition <- base::signalCondition
[16:09:37.304]             sys.calls <- base::sys.calls
[16:09:37.304]             `[[` <- base::`[[`
[16:09:37.304]             `+` <- base::`+`
[16:09:37.304]             `<<-` <- base::`<<-`
[16:09:37.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.304]                   3L)]
[16:09:37.304]             }
[16:09:37.304]             function(cond) {
[16:09:37.304]                 is_error <- inherits(cond, "error")
[16:09:37.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.304]                   NULL)
[16:09:37.304]                 if (is_error) {
[16:09:37.304]                   sessionInformation <- function() {
[16:09:37.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.304]                       search = base::search(), system = base::Sys.info())
[16:09:37.304]                   }
[16:09:37.304]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.304]                     cond$call), session = sessionInformation(), 
[16:09:37.304]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.304]                   signalCondition(cond)
[16:09:37.304]                 }
[16:09:37.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.304]                 "immediateCondition"))) {
[16:09:37.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.304]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.304]                   if (TRUE && !signal) {
[16:09:37.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.304]                     {
[16:09:37.304]                       inherits <- base::inherits
[16:09:37.304]                       invokeRestart <- base::invokeRestart
[16:09:37.304]                       is.null <- base::is.null
[16:09:37.304]                       muffled <- FALSE
[16:09:37.304]                       if (inherits(cond, "message")) {
[16:09:37.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.304]                         if (muffled) 
[16:09:37.304]                           invokeRestart("muffleMessage")
[16:09:37.304]                       }
[16:09:37.304]                       else if (inherits(cond, "warning")) {
[16:09:37.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.304]                         if (muffled) 
[16:09:37.304]                           invokeRestart("muffleWarning")
[16:09:37.304]                       }
[16:09:37.304]                       else if (inherits(cond, "condition")) {
[16:09:37.304]                         if (!is.null(pattern)) {
[16:09:37.304]                           computeRestarts <- base::computeRestarts
[16:09:37.304]                           grepl <- base::grepl
[16:09:37.304]                           restarts <- computeRestarts(cond)
[16:09:37.304]                           for (restart in restarts) {
[16:09:37.304]                             name <- restart$name
[16:09:37.304]                             if (is.null(name)) 
[16:09:37.304]                               next
[16:09:37.304]                             if (!grepl(pattern, name)) 
[16:09:37.304]                               next
[16:09:37.304]                             invokeRestart(restart)
[16:09:37.304]                             muffled <- TRUE
[16:09:37.304]                             break
[16:09:37.304]                           }
[16:09:37.304]                         }
[16:09:37.304]                       }
[16:09:37.304]                       invisible(muffled)
[16:09:37.304]                     }
[16:09:37.304]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.304]                   }
[16:09:37.304]                 }
[16:09:37.304]                 else {
[16:09:37.304]                   if (TRUE) {
[16:09:37.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.304]                     {
[16:09:37.304]                       inherits <- base::inherits
[16:09:37.304]                       invokeRestart <- base::invokeRestart
[16:09:37.304]                       is.null <- base::is.null
[16:09:37.304]                       muffled <- FALSE
[16:09:37.304]                       if (inherits(cond, "message")) {
[16:09:37.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.304]                         if (muffled) 
[16:09:37.304]                           invokeRestart("muffleMessage")
[16:09:37.304]                       }
[16:09:37.304]                       else if (inherits(cond, "warning")) {
[16:09:37.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.304]                         if (muffled) 
[16:09:37.304]                           invokeRestart("muffleWarning")
[16:09:37.304]                       }
[16:09:37.304]                       else if (inherits(cond, "condition")) {
[16:09:37.304]                         if (!is.null(pattern)) {
[16:09:37.304]                           computeRestarts <- base::computeRestarts
[16:09:37.304]                           grepl <- base::grepl
[16:09:37.304]                           restarts <- computeRestarts(cond)
[16:09:37.304]                           for (restart in restarts) {
[16:09:37.304]                             name <- restart$name
[16:09:37.304]                             if (is.null(name)) 
[16:09:37.304]                               next
[16:09:37.304]                             if (!grepl(pattern, name)) 
[16:09:37.304]                               next
[16:09:37.304]                             invokeRestart(restart)
[16:09:37.304]                             muffled <- TRUE
[16:09:37.304]                             break
[16:09:37.304]                           }
[16:09:37.304]                         }
[16:09:37.304]                       }
[16:09:37.304]                       invisible(muffled)
[16:09:37.304]                     }
[16:09:37.304]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.304]                   }
[16:09:37.304]                 }
[16:09:37.304]             }
[16:09:37.304]         }))
[16:09:37.304]     }, error = function(ex) {
[16:09:37.304]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.304]                 ...future.rng), started = ...future.startTime, 
[16:09:37.304]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.304]             version = "1.8"), class = "FutureResult")
[16:09:37.304]     }, finally = {
[16:09:37.304]         if (!identical(...future.workdir, getwd())) 
[16:09:37.304]             setwd(...future.workdir)
[16:09:37.304]         {
[16:09:37.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.304]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.304]             }
[16:09:37.304]             base::options(...future.oldOptions)
[16:09:37.304]             if (.Platform$OS.type == "windows") {
[16:09:37.304]                 old_names <- names(...future.oldEnvVars)
[16:09:37.304]                 envs <- base::Sys.getenv()
[16:09:37.304]                 names <- names(envs)
[16:09:37.304]                 common <- intersect(names, old_names)
[16:09:37.304]                 added <- setdiff(names, old_names)
[16:09:37.304]                 removed <- setdiff(old_names, names)
[16:09:37.304]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.304]                   envs[common]]
[16:09:37.304]                 NAMES <- toupper(changed)
[16:09:37.304]                 args <- list()
[16:09:37.304]                 for (kk in seq_along(NAMES)) {
[16:09:37.304]                   name <- changed[[kk]]
[16:09:37.304]                   NAME <- NAMES[[kk]]
[16:09:37.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.304]                     next
[16:09:37.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.304]                 }
[16:09:37.304]                 NAMES <- toupper(added)
[16:09:37.304]                 for (kk in seq_along(NAMES)) {
[16:09:37.304]                   name <- added[[kk]]
[16:09:37.304]                   NAME <- NAMES[[kk]]
[16:09:37.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.304]                     next
[16:09:37.304]                   args[[name]] <- ""
[16:09:37.304]                 }
[16:09:37.304]                 NAMES <- toupper(removed)
[16:09:37.304]                 for (kk in seq_along(NAMES)) {
[16:09:37.304]                   name <- removed[[kk]]
[16:09:37.304]                   NAME <- NAMES[[kk]]
[16:09:37.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.304]                     next
[16:09:37.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.304]                 }
[16:09:37.304]                 if (length(args) > 0) 
[16:09:37.304]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.304]             }
[16:09:37.304]             else {
[16:09:37.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.304]             }
[16:09:37.304]             {
[16:09:37.304]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.304]                   0L) {
[16:09:37.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.304]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.304]                   base::options(opts)
[16:09:37.304]                 }
[16:09:37.304]                 {
[16:09:37.304]                   {
[16:09:37.304]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.304]                     NULL
[16:09:37.304]                   }
[16:09:37.304]                   options(future.plan = NULL)
[16:09:37.304]                   if (is.na(NA_character_)) 
[16:09:37.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.304]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.304]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.304]                     envir = parent.frame()) 
[16:09:37.304]                   {
[16:09:37.304]                     if (is.function(workers)) 
[16:09:37.304]                       workers <- workers()
[16:09:37.304]                     workers <- structure(as.integer(workers), 
[16:09:37.304]                       class = class(workers))
[16:09:37.304]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.304]                       workers >= 1)
[16:09:37.304]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.304]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.304]                     }
[16:09:37.304]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.304]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.304]                       envir = envir)
[16:09:37.304]                     if (!future$lazy) 
[16:09:37.304]                       future <- run(future)
[16:09:37.304]                     invisible(future)
[16:09:37.304]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.304]                 }
[16:09:37.304]             }
[16:09:37.304]         }
[16:09:37.304]     })
[16:09:37.304]     if (TRUE) {
[16:09:37.304]         base::sink(type = "output", split = FALSE)
[16:09:37.304]         if (TRUE) {
[16:09:37.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.304]         }
[16:09:37.304]         else {
[16:09:37.304]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.304]         }
[16:09:37.304]         base::close(...future.stdout)
[16:09:37.304]         ...future.stdout <- NULL
[16:09:37.304]     }
[16:09:37.304]     ...future.result$conditions <- ...future.conditions
[16:09:37.304]     ...future.result$finished <- base::Sys.time()
[16:09:37.304]     ...future.result
[16:09:37.304] }
[16:09:37.307] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[16:09:37.307] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:09:37.307] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:09:37.308] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[16:09:37.308] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[16:09:37.308] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:09:37.309] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:09:37.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:37.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.309] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:37.310] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.310] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[16:09:37.310] MultisessionFuture started
[16:09:37.311] - Launch lazy future ... done
[16:09:37.311] run() for ‘MultisessionFuture’ ... done
[16:09:37.311] Created future:
[16:09:37.311] MultisessionFuture:
[16:09:37.311] Label: ‘future_eapply-1’
[16:09:37.311] Expression:
[16:09:37.311] {
[16:09:37.311]     do.call(function(...) {
[16:09:37.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.311]             on.exit(options(oopts), add = TRUE)
[16:09:37.311]         }
[16:09:37.311]         {
[16:09:37.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.311]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.311]             })
[16:09:37.311]         }
[16:09:37.311]     }, args = future.call.arguments)
[16:09:37.311] }
[16:09:37.311] Lazy evaluation: FALSE
[16:09:37.311] Asynchronous evaluation: TRUE
[16:09:37.311] Local evaluation: TRUE
[16:09:37.311] Environment: R_GlobalEnv
[16:09:37.311] Capture standard output: TRUE
[16:09:37.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.311] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.311] Packages: 1 packages (‘stats’)
[16:09:37.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.311] Resolved: FALSE
[16:09:37.311] Value: <not collected>
[16:09:37.311] Conditions captured: <none>
[16:09:37.311] Early signaling: FALSE
[16:09:37.311] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.311] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.323] Chunk #1 of 2 ... DONE
[16:09:37.323] Chunk #2 of 2 ...
[16:09:37.323]  - Finding globals in 'X' for chunk #2 ...
[16:09:37.323] getGlobalsAndPackages() ...
[16:09:37.323] Searching for globals...
[16:09:37.323] 
[16:09:37.323] Searching for globals ... DONE
[16:09:37.324] - globals: [0] <none>
[16:09:37.324] getGlobalsAndPackages() ... DONE
[16:09:37.324]    + additional globals found: [n=0] 
[16:09:37.324]    + additional namespaces needed: [n=0] 
[16:09:37.324]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:37.324]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:37.324]  - seeds: <none>
[16:09:37.324] getGlobalsAndPackages() ...
[16:09:37.324] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.324] Resolving globals: FALSE
[16:09:37.325] Tweak future expression to call with '...' arguments ...
[16:09:37.325] {
[16:09:37.325]     do.call(function(...) {
[16:09:37.325]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.325]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.325]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.325]             on.exit(options(oopts), add = TRUE)
[16:09:37.325]         }
[16:09:37.325]         {
[16:09:37.325]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.325]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.325]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.325]             })
[16:09:37.325]         }
[16:09:37.325]     }, args = future.call.arguments)
[16:09:37.325] }
[16:09:37.325] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.325] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.325] - packages: [1] ‘stats’
[16:09:37.326] getGlobalsAndPackages() ... DONE
[16:09:37.326] run() for ‘Future’ ...
[16:09:37.326] - state: ‘created’
[16:09:37.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.341] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.341]   - Field: ‘node’
[16:09:37.342]   - Field: ‘label’
[16:09:37.342]   - Field: ‘local’
[16:09:37.342]   - Field: ‘owner’
[16:09:37.342]   - Field: ‘envir’
[16:09:37.342]   - Field: ‘workers’
[16:09:37.342]   - Field: ‘packages’
[16:09:37.342]   - Field: ‘gc’
[16:09:37.342]   - Field: ‘conditions’
[16:09:37.342]   - Field: ‘persistent’
[16:09:37.342]   - Field: ‘expr’
[16:09:37.343]   - Field: ‘uuid’
[16:09:37.343]   - Field: ‘seed’
[16:09:37.343]   - Field: ‘version’
[16:09:37.343]   - Field: ‘result’
[16:09:37.343]   - Field: ‘asynchronous’
[16:09:37.343]   - Field: ‘calls’
[16:09:37.343]   - Field: ‘globals’
[16:09:37.343]   - Field: ‘stdout’
[16:09:37.343]   - Field: ‘earlySignal’
[16:09:37.343]   - Field: ‘lazy’
[16:09:37.343]   - Field: ‘state’
[16:09:37.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.344] - Launch lazy future ...
[16:09:37.344] Packages needed by the future expression (n = 1): ‘stats’
[16:09:37.344] Packages needed by future strategies (n = 0): <none>
[16:09:37.345] {
[16:09:37.345]     {
[16:09:37.345]         {
[16:09:37.345]             ...future.startTime <- base::Sys.time()
[16:09:37.345]             {
[16:09:37.345]                 {
[16:09:37.345]                   {
[16:09:37.345]                     {
[16:09:37.345]                       {
[16:09:37.345]                         base::local({
[16:09:37.345]                           has_future <- base::requireNamespace("future", 
[16:09:37.345]                             quietly = TRUE)
[16:09:37.345]                           if (has_future) {
[16:09:37.345]                             ns <- base::getNamespace("future")
[16:09:37.345]                             version <- ns[[".package"]][["version"]]
[16:09:37.345]                             if (is.null(version)) 
[16:09:37.345]                               version <- utils::packageVersion("future")
[16:09:37.345]                           }
[16:09:37.345]                           else {
[16:09:37.345]                             version <- NULL
[16:09:37.345]                           }
[16:09:37.345]                           if (!has_future || version < "1.8.0") {
[16:09:37.345]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.345]                               "", base::R.version$version.string), 
[16:09:37.345]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:37.345]                                 base::R.version$platform, 8 * 
[16:09:37.345]                                   base::.Machine$sizeof.pointer), 
[16:09:37.345]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.345]                                 "release", "version")], collapse = " "), 
[16:09:37.345]                               hostname = base::Sys.info()[["nodename"]])
[16:09:37.345]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.345]                               info)
[16:09:37.345]                             info <- base::paste(info, collapse = "; ")
[16:09:37.345]                             if (!has_future) {
[16:09:37.345]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.345]                                 info)
[16:09:37.345]                             }
[16:09:37.345]                             else {
[16:09:37.345]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.345]                                 info, version)
[16:09:37.345]                             }
[16:09:37.345]                             base::stop(msg)
[16:09:37.345]                           }
[16:09:37.345]                         })
[16:09:37.345]                       }
[16:09:37.345]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.345]                       base::options(mc.cores = 1L)
[16:09:37.345]                     }
[16:09:37.345]                     base::local({
[16:09:37.345]                       for (pkg in "stats") {
[16:09:37.345]                         base::loadNamespace(pkg)
[16:09:37.345]                         base::library(pkg, character.only = TRUE)
[16:09:37.345]                       }
[16:09:37.345]                     })
[16:09:37.345]                   }
[16:09:37.345]                   options(future.plan = NULL)
[16:09:37.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.345]                 }
[16:09:37.345]                 ...future.workdir <- getwd()
[16:09:37.345]             }
[16:09:37.345]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.345]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.345]         }
[16:09:37.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.345]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:37.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.345]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.345]             base::names(...future.oldOptions))
[16:09:37.345]     }
[16:09:37.345]     if (FALSE) {
[16:09:37.345]     }
[16:09:37.345]     else {
[16:09:37.345]         if (TRUE) {
[16:09:37.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.345]                 open = "w")
[16:09:37.345]         }
[16:09:37.345]         else {
[16:09:37.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.345]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.345]         }
[16:09:37.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.345]             base::sink(type = "output", split = FALSE)
[16:09:37.345]             base::close(...future.stdout)
[16:09:37.345]         }, add = TRUE)
[16:09:37.345]     }
[16:09:37.345]     ...future.frame <- base::sys.nframe()
[16:09:37.345]     ...future.conditions <- base::list()
[16:09:37.345]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.345]     if (FALSE) {
[16:09:37.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.345]     }
[16:09:37.345]     ...future.result <- base::tryCatch({
[16:09:37.345]         base::withCallingHandlers({
[16:09:37.345]             ...future.value <- base::withVisible(base::local({
[16:09:37.345]                 ...future.makeSendCondition <- local({
[16:09:37.345]                   sendCondition <- NULL
[16:09:37.345]                   function(frame = 1L) {
[16:09:37.345]                     if (is.function(sendCondition)) 
[16:09:37.345]                       return(sendCondition)
[16:09:37.345]                     ns <- getNamespace("parallel")
[16:09:37.345]                     if (exists("sendData", mode = "function", 
[16:09:37.345]                       envir = ns)) {
[16:09:37.345]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.345]                         envir = ns)
[16:09:37.345]                       envir <- sys.frame(frame)
[16:09:37.345]                       master <- NULL
[16:09:37.345]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.345]                         !identical(envir, emptyenv())) {
[16:09:37.345]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.345]                           inherits = FALSE)) {
[16:09:37.345]                           master <- get("master", mode = "list", 
[16:09:37.345]                             envir = envir, inherits = FALSE)
[16:09:37.345]                           if (inherits(master, c("SOCKnode", 
[16:09:37.345]                             "SOCK0node"))) {
[16:09:37.345]                             sendCondition <<- function(cond) {
[16:09:37.345]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.345]                                 success = TRUE)
[16:09:37.345]                               parallel_sendData(master, data)
[16:09:37.345]                             }
[16:09:37.345]                             return(sendCondition)
[16:09:37.345]                           }
[16:09:37.345]                         }
[16:09:37.345]                         frame <- frame + 1L
[16:09:37.345]                         envir <- sys.frame(frame)
[16:09:37.345]                       }
[16:09:37.345]                     }
[16:09:37.345]                     sendCondition <<- function(cond) NULL
[16:09:37.345]                   }
[16:09:37.345]                 })
[16:09:37.345]                 withCallingHandlers({
[16:09:37.345]                   {
[16:09:37.345]                     do.call(function(...) {
[16:09:37.345]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.345]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.345]                         ...future.globals.maxSize)) {
[16:09:37.345]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.345]                         on.exit(options(oopts), add = TRUE)
[16:09:37.345]                       }
[16:09:37.345]                       {
[16:09:37.345]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.345]                           FUN = function(jj) {
[16:09:37.345]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.345]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.345]                           })
[16:09:37.345]                       }
[16:09:37.345]                     }, args = future.call.arguments)
[16:09:37.345]                   }
[16:09:37.345]                 }, immediateCondition = function(cond) {
[16:09:37.345]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.345]                   sendCondition(cond)
[16:09:37.345]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.345]                   {
[16:09:37.345]                     inherits <- base::inherits
[16:09:37.345]                     invokeRestart <- base::invokeRestart
[16:09:37.345]                     is.null <- base::is.null
[16:09:37.345]                     muffled <- FALSE
[16:09:37.345]                     if (inherits(cond, "message")) {
[16:09:37.345]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.345]                       if (muffled) 
[16:09:37.345]                         invokeRestart("muffleMessage")
[16:09:37.345]                     }
[16:09:37.345]                     else if (inherits(cond, "warning")) {
[16:09:37.345]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.345]                       if (muffled) 
[16:09:37.345]                         invokeRestart("muffleWarning")
[16:09:37.345]                     }
[16:09:37.345]                     else if (inherits(cond, "condition")) {
[16:09:37.345]                       if (!is.null(pattern)) {
[16:09:37.345]                         computeRestarts <- base::computeRestarts
[16:09:37.345]                         grepl <- base::grepl
[16:09:37.345]                         restarts <- computeRestarts(cond)
[16:09:37.345]                         for (restart in restarts) {
[16:09:37.345]                           name <- restart$name
[16:09:37.345]                           if (is.null(name)) 
[16:09:37.345]                             next
[16:09:37.345]                           if (!grepl(pattern, name)) 
[16:09:37.345]                             next
[16:09:37.345]                           invokeRestart(restart)
[16:09:37.345]                           muffled <- TRUE
[16:09:37.345]                           break
[16:09:37.345]                         }
[16:09:37.345]                       }
[16:09:37.345]                     }
[16:09:37.345]                     invisible(muffled)
[16:09:37.345]                   }
[16:09:37.345]                   muffleCondition(cond)
[16:09:37.345]                 })
[16:09:37.345]             }))
[16:09:37.345]             future::FutureResult(value = ...future.value$value, 
[16:09:37.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.345]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.345]                     ...future.globalenv.names))
[16:09:37.345]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.345]         }, condition = base::local({
[16:09:37.345]             c <- base::c
[16:09:37.345]             inherits <- base::inherits
[16:09:37.345]             invokeRestart <- base::invokeRestart
[16:09:37.345]             length <- base::length
[16:09:37.345]             list <- base::list
[16:09:37.345]             seq.int <- base::seq.int
[16:09:37.345]             signalCondition <- base::signalCondition
[16:09:37.345]             sys.calls <- base::sys.calls
[16:09:37.345]             `[[` <- base::`[[`
[16:09:37.345]             `+` <- base::`+`
[16:09:37.345]             `<<-` <- base::`<<-`
[16:09:37.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.345]                   3L)]
[16:09:37.345]             }
[16:09:37.345]             function(cond) {
[16:09:37.345]                 is_error <- inherits(cond, "error")
[16:09:37.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.345]                   NULL)
[16:09:37.345]                 if (is_error) {
[16:09:37.345]                   sessionInformation <- function() {
[16:09:37.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.345]                       search = base::search(), system = base::Sys.info())
[16:09:37.345]                   }
[16:09:37.345]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.345]                     cond$call), session = sessionInformation(), 
[16:09:37.345]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.345]                   signalCondition(cond)
[16:09:37.345]                 }
[16:09:37.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.345]                 "immediateCondition"))) {
[16:09:37.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.345]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.345]                   if (TRUE && !signal) {
[16:09:37.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.345]                     {
[16:09:37.345]                       inherits <- base::inherits
[16:09:37.345]                       invokeRestart <- base::invokeRestart
[16:09:37.345]                       is.null <- base::is.null
[16:09:37.345]                       muffled <- FALSE
[16:09:37.345]                       if (inherits(cond, "message")) {
[16:09:37.345]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.345]                         if (muffled) 
[16:09:37.345]                           invokeRestart("muffleMessage")
[16:09:37.345]                       }
[16:09:37.345]                       else if (inherits(cond, "warning")) {
[16:09:37.345]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.345]                         if (muffled) 
[16:09:37.345]                           invokeRestart("muffleWarning")
[16:09:37.345]                       }
[16:09:37.345]                       else if (inherits(cond, "condition")) {
[16:09:37.345]                         if (!is.null(pattern)) {
[16:09:37.345]                           computeRestarts <- base::computeRestarts
[16:09:37.345]                           grepl <- base::grepl
[16:09:37.345]                           restarts <- computeRestarts(cond)
[16:09:37.345]                           for (restart in restarts) {
[16:09:37.345]                             name <- restart$name
[16:09:37.345]                             if (is.null(name)) 
[16:09:37.345]                               next
[16:09:37.345]                             if (!grepl(pattern, name)) 
[16:09:37.345]                               next
[16:09:37.345]                             invokeRestart(restart)
[16:09:37.345]                             muffled <- TRUE
[16:09:37.345]                             break
[16:09:37.345]                           }
[16:09:37.345]                         }
[16:09:37.345]                       }
[16:09:37.345]                       invisible(muffled)
[16:09:37.345]                     }
[16:09:37.345]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.345]                   }
[16:09:37.345]                 }
[16:09:37.345]                 else {
[16:09:37.345]                   if (TRUE) {
[16:09:37.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.345]                     {
[16:09:37.345]                       inherits <- base::inherits
[16:09:37.345]                       invokeRestart <- base::invokeRestart
[16:09:37.345]                       is.null <- base::is.null
[16:09:37.345]                       muffled <- FALSE
[16:09:37.345]                       if (inherits(cond, "message")) {
[16:09:37.345]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.345]                         if (muffled) 
[16:09:37.345]                           invokeRestart("muffleMessage")
[16:09:37.345]                       }
[16:09:37.345]                       else if (inherits(cond, "warning")) {
[16:09:37.345]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.345]                         if (muffled) 
[16:09:37.345]                           invokeRestart("muffleWarning")
[16:09:37.345]                       }
[16:09:37.345]                       else if (inherits(cond, "condition")) {
[16:09:37.345]                         if (!is.null(pattern)) {
[16:09:37.345]                           computeRestarts <- base::computeRestarts
[16:09:37.345]                           grepl <- base::grepl
[16:09:37.345]                           restarts <- computeRestarts(cond)
[16:09:37.345]                           for (restart in restarts) {
[16:09:37.345]                             name <- restart$name
[16:09:37.345]                             if (is.null(name)) 
[16:09:37.345]                               next
[16:09:37.345]                             if (!grepl(pattern, name)) 
[16:09:37.345]                               next
[16:09:37.345]                             invokeRestart(restart)
[16:09:37.345]                             muffled <- TRUE
[16:09:37.345]                             break
[16:09:37.345]                           }
[16:09:37.345]                         }
[16:09:37.345]                       }
[16:09:37.345]                       invisible(muffled)
[16:09:37.345]                     }
[16:09:37.345]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.345]                   }
[16:09:37.345]                 }
[16:09:37.345]             }
[16:09:37.345]         }))
[16:09:37.345]     }, error = function(ex) {
[16:09:37.345]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.345]                 ...future.rng), started = ...future.startTime, 
[16:09:37.345]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.345]             version = "1.8"), class = "FutureResult")
[16:09:37.345]     }, finally = {
[16:09:37.345]         if (!identical(...future.workdir, getwd())) 
[16:09:37.345]             setwd(...future.workdir)
[16:09:37.345]         {
[16:09:37.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.345]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.345]             }
[16:09:37.345]             base::options(...future.oldOptions)
[16:09:37.345]             if (.Platform$OS.type == "windows") {
[16:09:37.345]                 old_names <- names(...future.oldEnvVars)
[16:09:37.345]                 envs <- base::Sys.getenv()
[16:09:37.345]                 names <- names(envs)
[16:09:37.345]                 common <- intersect(names, old_names)
[16:09:37.345]                 added <- setdiff(names, old_names)
[16:09:37.345]                 removed <- setdiff(old_names, names)
[16:09:37.345]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.345]                   envs[common]]
[16:09:37.345]                 NAMES <- toupper(changed)
[16:09:37.345]                 args <- list()
[16:09:37.345]                 for (kk in seq_along(NAMES)) {
[16:09:37.345]                   name <- changed[[kk]]
[16:09:37.345]                   NAME <- NAMES[[kk]]
[16:09:37.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.345]                     next
[16:09:37.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.345]                 }
[16:09:37.345]                 NAMES <- toupper(added)
[16:09:37.345]                 for (kk in seq_along(NAMES)) {
[16:09:37.345]                   name <- added[[kk]]
[16:09:37.345]                   NAME <- NAMES[[kk]]
[16:09:37.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.345]                     next
[16:09:37.345]                   args[[name]] <- ""
[16:09:37.345]                 }
[16:09:37.345]                 NAMES <- toupper(removed)
[16:09:37.345]                 for (kk in seq_along(NAMES)) {
[16:09:37.345]                   name <- removed[[kk]]
[16:09:37.345]                   NAME <- NAMES[[kk]]
[16:09:37.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.345]                     next
[16:09:37.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.345]                 }
[16:09:37.345]                 if (length(args) > 0) 
[16:09:37.345]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.345]             }
[16:09:37.345]             else {
[16:09:37.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.345]             }
[16:09:37.345]             {
[16:09:37.345]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.345]                   0L) {
[16:09:37.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.345]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.345]                   base::options(opts)
[16:09:37.345]                 }
[16:09:37.345]                 {
[16:09:37.345]                   {
[16:09:37.345]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.345]                     NULL
[16:09:37.345]                   }
[16:09:37.345]                   options(future.plan = NULL)
[16:09:37.345]                   if (is.na(NA_character_)) 
[16:09:37.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.345]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.345]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.345]                     envir = parent.frame()) 
[16:09:37.345]                   {
[16:09:37.345]                     if (is.function(workers)) 
[16:09:37.345]                       workers <- workers()
[16:09:37.345]                     workers <- structure(as.integer(workers), 
[16:09:37.345]                       class = class(workers))
[16:09:37.345]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.345]                       workers >= 1)
[16:09:37.345]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.345]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.345]                     }
[16:09:37.345]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.345]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.345]                       envir = envir)
[16:09:37.345]                     if (!future$lazy) 
[16:09:37.345]                       future <- run(future)
[16:09:37.345]                     invisible(future)
[16:09:37.345]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.345]                 }
[16:09:37.345]             }
[16:09:37.345]         }
[16:09:37.345]     })
[16:09:37.345]     if (TRUE) {
[16:09:37.345]         base::sink(type = "output", split = FALSE)
[16:09:37.345]         if (TRUE) {
[16:09:37.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.345]         }
[16:09:37.345]         else {
[16:09:37.345]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.345]         }
[16:09:37.345]         base::close(...future.stdout)
[16:09:37.345]         ...future.stdout <- NULL
[16:09:37.345]     }
[16:09:37.345]     ...future.result$conditions <- ...future.conditions
[16:09:37.345]     ...future.result$finished <- base::Sys.time()
[16:09:37.345]     ...future.result
[16:09:37.345] }
[16:09:37.348] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[16:09:37.348] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:09:37.348] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:09:37.349] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[16:09:37.349] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[16:09:37.349] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:09:37.350] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:09:37.350] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:37.350] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.350] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:37.350] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.351] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[16:09:37.351] MultisessionFuture started
[16:09:37.351] - Launch lazy future ... done
[16:09:37.351] run() for ‘MultisessionFuture’ ... done
[16:09:37.351] Created future:
[16:09:37.351] MultisessionFuture:
[16:09:37.351] Label: ‘future_eapply-2’
[16:09:37.351] Expression:
[16:09:37.351] {
[16:09:37.351]     do.call(function(...) {
[16:09:37.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.351]             on.exit(options(oopts), add = TRUE)
[16:09:37.351]         }
[16:09:37.351]         {
[16:09:37.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.351]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.351]             })
[16:09:37.351]         }
[16:09:37.351]     }, args = future.call.arguments)
[16:09:37.351] }
[16:09:37.351] Lazy evaluation: FALSE
[16:09:37.351] Asynchronous evaluation: TRUE
[16:09:37.351] Local evaluation: TRUE
[16:09:37.351] Environment: R_GlobalEnv
[16:09:37.351] Capture standard output: TRUE
[16:09:37.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.351] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.351] Packages: 1 packages (‘stats’)
[16:09:37.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.351] Resolved: FALSE
[16:09:37.351] Value: <not collected>
[16:09:37.351] Conditions captured: <none>
[16:09:37.351] Early signaling: FALSE
[16:09:37.351] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.351] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.364] Chunk #2 of 2 ... DONE
[16:09:37.364] Launching 2 futures (chunks) ... DONE
[16:09:37.364] Resolving 2 futures (chunks) ...
[16:09:37.364] resolve() on list ...
[16:09:37.364]  recursive: 0
[16:09:37.365]  length: 2
[16:09:37.365] 
[16:09:37.365] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.365] - Validating connection of MultisessionFuture
[16:09:37.366] - received message: FutureResult
[16:09:37.366] - Received FutureResult
[16:09:37.366] - Erased future from FutureRegistry
[16:09:37.366] result() for ClusterFuture ...
[16:09:37.366] - result already collected: FutureResult
[16:09:37.366] result() for ClusterFuture ... done
[16:09:37.366] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.366] Future #1
[16:09:37.366] result() for ClusterFuture ...
[16:09:37.366] - result already collected: FutureResult
[16:09:37.367] result() for ClusterFuture ... done
[16:09:37.367] result() for ClusterFuture ...
[16:09:37.367] - result already collected: FutureResult
[16:09:37.367] result() for ClusterFuture ... done
[16:09:37.367] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:37.367] - nx: 2
[16:09:37.367] - relay: TRUE
[16:09:37.367] - stdout: TRUE
[16:09:37.367] - signal: TRUE
[16:09:37.367] - resignal: FALSE
[16:09:37.367] - force: TRUE
[16:09:37.367] - relayed: [n=2] FALSE, FALSE
[16:09:37.368] - queued futures: [n=2] FALSE, FALSE
[16:09:37.368]  - until=1
[16:09:37.368]  - relaying element #1
[16:09:37.368] result() for ClusterFuture ...
[16:09:37.368] - result already collected: FutureResult
[16:09:37.368] result() for ClusterFuture ... done
[16:09:37.368] result() for ClusterFuture ...
[16:09:37.368] - result already collected: FutureResult
[16:09:37.368] result() for ClusterFuture ... done
[16:09:37.368] result() for ClusterFuture ...
[16:09:37.369] - result already collected: FutureResult
[16:09:37.369] result() for ClusterFuture ... done
[16:09:37.369] result() for ClusterFuture ...
[16:09:37.369] - result already collected: FutureResult
[16:09:37.369] result() for ClusterFuture ... done
[16:09:37.369] - relayed: [n=2] TRUE, FALSE
[16:09:37.369] - queued futures: [n=2] TRUE, FALSE
[16:09:37.369] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:37.369]  length: 1 (resolved future 1)
[16:09:37.399] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.399] - Validating connection of MultisessionFuture
[16:09:37.399] - received message: FutureResult
[16:09:37.399] - Received FutureResult
[16:09:37.399] - Erased future from FutureRegistry
[16:09:37.399] result() for ClusterFuture ...
[16:09:37.400] - result already collected: FutureResult
[16:09:37.400] result() for ClusterFuture ... done
[16:09:37.400] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.400] Future #2
[16:09:37.400] result() for ClusterFuture ...
[16:09:37.400] - result already collected: FutureResult
[16:09:37.400] result() for ClusterFuture ... done
[16:09:37.400] result() for ClusterFuture ...
[16:09:37.400] - result already collected: FutureResult
[16:09:37.400] result() for ClusterFuture ... done
[16:09:37.401] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:37.401] - nx: 2
[16:09:37.401] - relay: TRUE
[16:09:37.401] - stdout: TRUE
[16:09:37.401] - signal: TRUE
[16:09:37.401] - resignal: FALSE
[16:09:37.401] - force: TRUE
[16:09:37.401] - relayed: [n=2] TRUE, FALSE
[16:09:37.401] - queued futures: [n=2] TRUE, FALSE
[16:09:37.401]  - until=2
[16:09:37.401]  - relaying element #2
[16:09:37.402] result() for ClusterFuture ...
[16:09:37.402] - result already collected: FutureResult
[16:09:37.402] result() for ClusterFuture ... done
[16:09:37.402] result() for ClusterFuture ...
[16:09:37.402] - result already collected: FutureResult
[16:09:37.402] result() for ClusterFuture ... done
[16:09:37.402] result() for ClusterFuture ...
[16:09:37.402] - result already collected: FutureResult
[16:09:37.402] result() for ClusterFuture ... done
[16:09:37.402] result() for ClusterFuture ...
[16:09:37.402] - result already collected: FutureResult
[16:09:37.403] result() for ClusterFuture ... done
[16:09:37.403] - relayed: [n=2] TRUE, TRUE
[16:09:37.403] - queued futures: [n=2] TRUE, TRUE
[16:09:37.403] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:37.403]  length: 0 (resolved future 2)
[16:09:37.403] Relaying remaining futures
[16:09:37.403] signalConditionsASAP(NULL, pos=0) ...
[16:09:37.403] - nx: 2
[16:09:37.403] - relay: TRUE
[16:09:37.403] - stdout: TRUE
[16:09:37.403] - signal: TRUE
[16:09:37.403] - resignal: FALSE
[16:09:37.404] - force: TRUE
[16:09:37.404] - relayed: [n=2] TRUE, TRUE
[16:09:37.404] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:37.404] - relayed: [n=2] TRUE, TRUE
[16:09:37.404] - queued futures: [n=2] TRUE, TRUE
[16:09:37.404] signalConditionsASAP(NULL, pos=0) ... done
[16:09:37.404] resolve() on list ... DONE
[16:09:37.404] result() for ClusterFuture ...
[16:09:37.404] - result already collected: FutureResult
[16:09:37.404] result() for ClusterFuture ... done
[16:09:37.405] result() for ClusterFuture ...
[16:09:37.405] - result already collected: FutureResult
[16:09:37.405] result() for ClusterFuture ... done
[16:09:37.405] result() for ClusterFuture ...
[16:09:37.405] - result already collected: FutureResult
[16:09:37.405] result() for ClusterFuture ... done
[16:09:37.405] result() for ClusterFuture ...
[16:09:37.405] - result already collected: FutureResult
[16:09:37.405] result() for ClusterFuture ... done
[16:09:37.405]  - Number of value chunks collected: 2
[16:09:37.406] Resolving 2 futures (chunks) ... DONE
[16:09:37.406] Reducing values from 2 chunks ...
[16:09:37.406]  - Number of values collected after concatenation: 3
[16:09:37.406]  - Number of values expected: 3
[16:09:37.406] Reducing values from 2 chunks ... DONE
[16:09:37.406] future_lapply() ... DONE
[16:09:37.407] future_lapply() ...
[16:09:37.411] Number of chunks: 2
[16:09:37.411] getGlobalsAndPackagesXApply() ...
[16:09:37.411]  - future.globals: TRUE
[16:09:37.411] getGlobalsAndPackages() ...
[16:09:37.411] Searching for globals...
[16:09:37.412] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:37.413] Searching for globals ... DONE
[16:09:37.413] Resolving globals: FALSE
[16:09:37.413] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:37.413] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:37.414] - globals: [1] ‘FUN’
[16:09:37.414] - packages: [1] ‘stats’
[16:09:37.414] getGlobalsAndPackages() ... DONE
[16:09:37.414]  - globals found/used: [n=1] ‘FUN’
[16:09:37.414]  - needed namespaces: [n=1] ‘stats’
[16:09:37.414] Finding globals ... DONE
[16:09:37.414]  - use_args: TRUE
[16:09:37.414]  - Getting '...' globals ...
[16:09:37.415] resolve() on list ...
[16:09:37.415]  recursive: 0
[16:09:37.415]  length: 1
[16:09:37.415]  elements: ‘...’
[16:09:37.415]  length: 0 (resolved future 1)
[16:09:37.415] resolve() on list ... DONE
[16:09:37.415]    - '...' content: [n=0] 
[16:09:37.415] List of 1
[16:09:37.415]  $ ...: list()
[16:09:37.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.415]  - attr(*, "where")=List of 1
[16:09:37.415]   ..$ ...:<environment: 0x55b4ba2c1e98> 
[16:09:37.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.415]  - attr(*, "resolved")= logi TRUE
[16:09:37.415]  - attr(*, "total_size")= num NA
[16:09:37.420]  - Getting '...' globals ... DONE
[16:09:37.420] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:37.420] List of 2
[16:09:37.420]  $ ...future.FUN:function (x, ...)  
[16:09:37.420]  $ ...          : list()
[16:09:37.420]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.420]  - attr(*, "where")=List of 2
[16:09:37.420]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:37.420]   ..$ ...          :<environment: 0x55b4ba2c1e98> 
[16:09:37.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.420]  - attr(*, "resolved")= logi FALSE
[16:09:37.420]  - attr(*, "total_size")= num 1248
[16:09:37.423] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:37.423] getGlobalsAndPackagesXApply() ... DONE
[16:09:37.423] Number of futures (= number of chunks): 2
[16:09:37.423] Launching 2 futures (chunks) ...
[16:09:37.423] Chunk #1 of 2 ...
[16:09:37.423]  - Finding globals in 'X' for chunk #1 ...
[16:09:37.423] getGlobalsAndPackages() ...
[16:09:37.423] Searching for globals...
[16:09:37.424] 
[16:09:37.424] Searching for globals ... DONE
[16:09:37.424] - globals: [0] <none>
[16:09:37.424] getGlobalsAndPackages() ... DONE
[16:09:37.424]    + additional globals found: [n=0] 
[16:09:37.424]    + additional namespaces needed: [n=0] 
[16:09:37.424]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:37.424]  - seeds: <none>
[16:09:37.424] getGlobalsAndPackages() ...
[16:09:37.424] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.425] Resolving globals: FALSE
[16:09:37.425] Tweak future expression to call with '...' arguments ...
[16:09:37.425] {
[16:09:37.425]     do.call(function(...) {
[16:09:37.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.425]             on.exit(options(oopts), add = TRUE)
[16:09:37.425]         }
[16:09:37.425]         {
[16:09:37.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.425]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.425]             })
[16:09:37.425]         }
[16:09:37.425]     }, args = future.call.arguments)
[16:09:37.425] }
[16:09:37.425] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.425] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.425] - packages: [1] ‘stats’
[16:09:37.426] getGlobalsAndPackages() ... DONE
[16:09:37.426] run() for ‘Future’ ...
[16:09:37.426] - state: ‘created’
[16:09:37.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.441] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.441]   - Field: ‘node’
[16:09:37.441]   - Field: ‘label’
[16:09:37.441]   - Field: ‘local’
[16:09:37.441]   - Field: ‘owner’
[16:09:37.441]   - Field: ‘envir’
[16:09:37.442]   - Field: ‘workers’
[16:09:37.442]   - Field: ‘packages’
[16:09:37.442]   - Field: ‘gc’
[16:09:37.442]   - Field: ‘conditions’
[16:09:37.442]   - Field: ‘persistent’
[16:09:37.442]   - Field: ‘expr’
[16:09:37.442]   - Field: ‘uuid’
[16:09:37.442]   - Field: ‘seed’
[16:09:37.442]   - Field: ‘version’
[16:09:37.442]   - Field: ‘result’
[16:09:37.442]   - Field: ‘asynchronous’
[16:09:37.443]   - Field: ‘calls’
[16:09:37.443]   - Field: ‘globals’
[16:09:37.443]   - Field: ‘stdout’
[16:09:37.443]   - Field: ‘earlySignal’
[16:09:37.443]   - Field: ‘lazy’
[16:09:37.443]   - Field: ‘state’
[16:09:37.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.443] - Launch lazy future ...
[16:09:37.443] Packages needed by the future expression (n = 1): ‘stats’
[16:09:37.444] Packages needed by future strategies (n = 0): <none>
[16:09:37.444] {
[16:09:37.444]     {
[16:09:37.444]         {
[16:09:37.444]             ...future.startTime <- base::Sys.time()
[16:09:37.444]             {
[16:09:37.444]                 {
[16:09:37.444]                   {
[16:09:37.444]                     {
[16:09:37.444]                       {
[16:09:37.444]                         base::local({
[16:09:37.444]                           has_future <- base::requireNamespace("future", 
[16:09:37.444]                             quietly = TRUE)
[16:09:37.444]                           if (has_future) {
[16:09:37.444]                             ns <- base::getNamespace("future")
[16:09:37.444]                             version <- ns[[".package"]][["version"]]
[16:09:37.444]                             if (is.null(version)) 
[16:09:37.444]                               version <- utils::packageVersion("future")
[16:09:37.444]                           }
[16:09:37.444]                           else {
[16:09:37.444]                             version <- NULL
[16:09:37.444]                           }
[16:09:37.444]                           if (!has_future || version < "1.8.0") {
[16:09:37.444]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.444]                               "", base::R.version$version.string), 
[16:09:37.444]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:37.444]                                 base::R.version$platform, 8 * 
[16:09:37.444]                                   base::.Machine$sizeof.pointer), 
[16:09:37.444]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.444]                                 "release", "version")], collapse = " "), 
[16:09:37.444]                               hostname = base::Sys.info()[["nodename"]])
[16:09:37.444]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.444]                               info)
[16:09:37.444]                             info <- base::paste(info, collapse = "; ")
[16:09:37.444]                             if (!has_future) {
[16:09:37.444]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.444]                                 info)
[16:09:37.444]                             }
[16:09:37.444]                             else {
[16:09:37.444]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.444]                                 info, version)
[16:09:37.444]                             }
[16:09:37.444]                             base::stop(msg)
[16:09:37.444]                           }
[16:09:37.444]                         })
[16:09:37.444]                       }
[16:09:37.444]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.444]                       base::options(mc.cores = 1L)
[16:09:37.444]                     }
[16:09:37.444]                     base::local({
[16:09:37.444]                       for (pkg in "stats") {
[16:09:37.444]                         base::loadNamespace(pkg)
[16:09:37.444]                         base::library(pkg, character.only = TRUE)
[16:09:37.444]                       }
[16:09:37.444]                     })
[16:09:37.444]                   }
[16:09:37.444]                   options(future.plan = NULL)
[16:09:37.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.444]                 }
[16:09:37.444]                 ...future.workdir <- getwd()
[16:09:37.444]             }
[16:09:37.444]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.444]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.444]         }
[16:09:37.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:37.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.444]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.444]             base::names(...future.oldOptions))
[16:09:37.444]     }
[16:09:37.444]     if (FALSE) {
[16:09:37.444]     }
[16:09:37.444]     else {
[16:09:37.444]         if (TRUE) {
[16:09:37.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.444]                 open = "w")
[16:09:37.444]         }
[16:09:37.444]         else {
[16:09:37.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.444]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.444]         }
[16:09:37.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.444]             base::sink(type = "output", split = FALSE)
[16:09:37.444]             base::close(...future.stdout)
[16:09:37.444]         }, add = TRUE)
[16:09:37.444]     }
[16:09:37.444]     ...future.frame <- base::sys.nframe()
[16:09:37.444]     ...future.conditions <- base::list()
[16:09:37.444]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.444]     if (FALSE) {
[16:09:37.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.444]     }
[16:09:37.444]     ...future.result <- base::tryCatch({
[16:09:37.444]         base::withCallingHandlers({
[16:09:37.444]             ...future.value <- base::withVisible(base::local({
[16:09:37.444]                 ...future.makeSendCondition <- local({
[16:09:37.444]                   sendCondition <- NULL
[16:09:37.444]                   function(frame = 1L) {
[16:09:37.444]                     if (is.function(sendCondition)) 
[16:09:37.444]                       return(sendCondition)
[16:09:37.444]                     ns <- getNamespace("parallel")
[16:09:37.444]                     if (exists("sendData", mode = "function", 
[16:09:37.444]                       envir = ns)) {
[16:09:37.444]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.444]                         envir = ns)
[16:09:37.444]                       envir <- sys.frame(frame)
[16:09:37.444]                       master <- NULL
[16:09:37.444]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.444]                         !identical(envir, emptyenv())) {
[16:09:37.444]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.444]                           inherits = FALSE)) {
[16:09:37.444]                           master <- get("master", mode = "list", 
[16:09:37.444]                             envir = envir, inherits = FALSE)
[16:09:37.444]                           if (inherits(master, c("SOCKnode", 
[16:09:37.444]                             "SOCK0node"))) {
[16:09:37.444]                             sendCondition <<- function(cond) {
[16:09:37.444]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.444]                                 success = TRUE)
[16:09:37.444]                               parallel_sendData(master, data)
[16:09:37.444]                             }
[16:09:37.444]                             return(sendCondition)
[16:09:37.444]                           }
[16:09:37.444]                         }
[16:09:37.444]                         frame <- frame + 1L
[16:09:37.444]                         envir <- sys.frame(frame)
[16:09:37.444]                       }
[16:09:37.444]                     }
[16:09:37.444]                     sendCondition <<- function(cond) NULL
[16:09:37.444]                   }
[16:09:37.444]                 })
[16:09:37.444]                 withCallingHandlers({
[16:09:37.444]                   {
[16:09:37.444]                     do.call(function(...) {
[16:09:37.444]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.444]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.444]                         ...future.globals.maxSize)) {
[16:09:37.444]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.444]                         on.exit(options(oopts), add = TRUE)
[16:09:37.444]                       }
[16:09:37.444]                       {
[16:09:37.444]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.444]                           FUN = function(jj) {
[16:09:37.444]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.444]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.444]                           })
[16:09:37.444]                       }
[16:09:37.444]                     }, args = future.call.arguments)
[16:09:37.444]                   }
[16:09:37.444]                 }, immediateCondition = function(cond) {
[16:09:37.444]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.444]                   sendCondition(cond)
[16:09:37.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.444]                   {
[16:09:37.444]                     inherits <- base::inherits
[16:09:37.444]                     invokeRestart <- base::invokeRestart
[16:09:37.444]                     is.null <- base::is.null
[16:09:37.444]                     muffled <- FALSE
[16:09:37.444]                     if (inherits(cond, "message")) {
[16:09:37.444]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.444]                       if (muffled) 
[16:09:37.444]                         invokeRestart("muffleMessage")
[16:09:37.444]                     }
[16:09:37.444]                     else if (inherits(cond, "warning")) {
[16:09:37.444]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.444]                       if (muffled) 
[16:09:37.444]                         invokeRestart("muffleWarning")
[16:09:37.444]                     }
[16:09:37.444]                     else if (inherits(cond, "condition")) {
[16:09:37.444]                       if (!is.null(pattern)) {
[16:09:37.444]                         computeRestarts <- base::computeRestarts
[16:09:37.444]                         grepl <- base::grepl
[16:09:37.444]                         restarts <- computeRestarts(cond)
[16:09:37.444]                         for (restart in restarts) {
[16:09:37.444]                           name <- restart$name
[16:09:37.444]                           if (is.null(name)) 
[16:09:37.444]                             next
[16:09:37.444]                           if (!grepl(pattern, name)) 
[16:09:37.444]                             next
[16:09:37.444]                           invokeRestart(restart)
[16:09:37.444]                           muffled <- TRUE
[16:09:37.444]                           break
[16:09:37.444]                         }
[16:09:37.444]                       }
[16:09:37.444]                     }
[16:09:37.444]                     invisible(muffled)
[16:09:37.444]                   }
[16:09:37.444]                   muffleCondition(cond)
[16:09:37.444]                 })
[16:09:37.444]             }))
[16:09:37.444]             future::FutureResult(value = ...future.value$value, 
[16:09:37.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.444]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.444]                     ...future.globalenv.names))
[16:09:37.444]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.444]         }, condition = base::local({
[16:09:37.444]             c <- base::c
[16:09:37.444]             inherits <- base::inherits
[16:09:37.444]             invokeRestart <- base::invokeRestart
[16:09:37.444]             length <- base::length
[16:09:37.444]             list <- base::list
[16:09:37.444]             seq.int <- base::seq.int
[16:09:37.444]             signalCondition <- base::signalCondition
[16:09:37.444]             sys.calls <- base::sys.calls
[16:09:37.444]             `[[` <- base::`[[`
[16:09:37.444]             `+` <- base::`+`
[16:09:37.444]             `<<-` <- base::`<<-`
[16:09:37.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.444]                   3L)]
[16:09:37.444]             }
[16:09:37.444]             function(cond) {
[16:09:37.444]                 is_error <- inherits(cond, "error")
[16:09:37.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.444]                   NULL)
[16:09:37.444]                 if (is_error) {
[16:09:37.444]                   sessionInformation <- function() {
[16:09:37.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.444]                       search = base::search(), system = base::Sys.info())
[16:09:37.444]                   }
[16:09:37.444]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.444]                     cond$call), session = sessionInformation(), 
[16:09:37.444]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.444]                   signalCondition(cond)
[16:09:37.444]                 }
[16:09:37.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.444]                 "immediateCondition"))) {
[16:09:37.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.444]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.444]                   if (TRUE && !signal) {
[16:09:37.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.444]                     {
[16:09:37.444]                       inherits <- base::inherits
[16:09:37.444]                       invokeRestart <- base::invokeRestart
[16:09:37.444]                       is.null <- base::is.null
[16:09:37.444]                       muffled <- FALSE
[16:09:37.444]                       if (inherits(cond, "message")) {
[16:09:37.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.444]                         if (muffled) 
[16:09:37.444]                           invokeRestart("muffleMessage")
[16:09:37.444]                       }
[16:09:37.444]                       else if (inherits(cond, "warning")) {
[16:09:37.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.444]                         if (muffled) 
[16:09:37.444]                           invokeRestart("muffleWarning")
[16:09:37.444]                       }
[16:09:37.444]                       else if (inherits(cond, "condition")) {
[16:09:37.444]                         if (!is.null(pattern)) {
[16:09:37.444]                           computeRestarts <- base::computeRestarts
[16:09:37.444]                           grepl <- base::grepl
[16:09:37.444]                           restarts <- computeRestarts(cond)
[16:09:37.444]                           for (restart in restarts) {
[16:09:37.444]                             name <- restart$name
[16:09:37.444]                             if (is.null(name)) 
[16:09:37.444]                               next
[16:09:37.444]                             if (!grepl(pattern, name)) 
[16:09:37.444]                               next
[16:09:37.444]                             invokeRestart(restart)
[16:09:37.444]                             muffled <- TRUE
[16:09:37.444]                             break
[16:09:37.444]                           }
[16:09:37.444]                         }
[16:09:37.444]                       }
[16:09:37.444]                       invisible(muffled)
[16:09:37.444]                     }
[16:09:37.444]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.444]                   }
[16:09:37.444]                 }
[16:09:37.444]                 else {
[16:09:37.444]                   if (TRUE) {
[16:09:37.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.444]                     {
[16:09:37.444]                       inherits <- base::inherits
[16:09:37.444]                       invokeRestart <- base::invokeRestart
[16:09:37.444]                       is.null <- base::is.null
[16:09:37.444]                       muffled <- FALSE
[16:09:37.444]                       if (inherits(cond, "message")) {
[16:09:37.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.444]                         if (muffled) 
[16:09:37.444]                           invokeRestart("muffleMessage")
[16:09:37.444]                       }
[16:09:37.444]                       else if (inherits(cond, "warning")) {
[16:09:37.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.444]                         if (muffled) 
[16:09:37.444]                           invokeRestart("muffleWarning")
[16:09:37.444]                       }
[16:09:37.444]                       else if (inherits(cond, "condition")) {
[16:09:37.444]                         if (!is.null(pattern)) {
[16:09:37.444]                           computeRestarts <- base::computeRestarts
[16:09:37.444]                           grepl <- base::grepl
[16:09:37.444]                           restarts <- computeRestarts(cond)
[16:09:37.444]                           for (restart in restarts) {
[16:09:37.444]                             name <- restart$name
[16:09:37.444]                             if (is.null(name)) 
[16:09:37.444]                               next
[16:09:37.444]                             if (!grepl(pattern, name)) 
[16:09:37.444]                               next
[16:09:37.444]                             invokeRestart(restart)
[16:09:37.444]                             muffled <- TRUE
[16:09:37.444]                             break
[16:09:37.444]                           }
[16:09:37.444]                         }
[16:09:37.444]                       }
[16:09:37.444]                       invisible(muffled)
[16:09:37.444]                     }
[16:09:37.444]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.444]                   }
[16:09:37.444]                 }
[16:09:37.444]             }
[16:09:37.444]         }))
[16:09:37.444]     }, error = function(ex) {
[16:09:37.444]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.444]                 ...future.rng), started = ...future.startTime, 
[16:09:37.444]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.444]             version = "1.8"), class = "FutureResult")
[16:09:37.444]     }, finally = {
[16:09:37.444]         if (!identical(...future.workdir, getwd())) 
[16:09:37.444]             setwd(...future.workdir)
[16:09:37.444]         {
[16:09:37.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.444]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.444]             }
[16:09:37.444]             base::options(...future.oldOptions)
[16:09:37.444]             if (.Platform$OS.type == "windows") {
[16:09:37.444]                 old_names <- names(...future.oldEnvVars)
[16:09:37.444]                 envs <- base::Sys.getenv()
[16:09:37.444]                 names <- names(envs)
[16:09:37.444]                 common <- intersect(names, old_names)
[16:09:37.444]                 added <- setdiff(names, old_names)
[16:09:37.444]                 removed <- setdiff(old_names, names)
[16:09:37.444]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.444]                   envs[common]]
[16:09:37.444]                 NAMES <- toupper(changed)
[16:09:37.444]                 args <- list()
[16:09:37.444]                 for (kk in seq_along(NAMES)) {
[16:09:37.444]                   name <- changed[[kk]]
[16:09:37.444]                   NAME <- NAMES[[kk]]
[16:09:37.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.444]                     next
[16:09:37.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.444]                 }
[16:09:37.444]                 NAMES <- toupper(added)
[16:09:37.444]                 for (kk in seq_along(NAMES)) {
[16:09:37.444]                   name <- added[[kk]]
[16:09:37.444]                   NAME <- NAMES[[kk]]
[16:09:37.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.444]                     next
[16:09:37.444]                   args[[name]] <- ""
[16:09:37.444]                 }
[16:09:37.444]                 NAMES <- toupper(removed)
[16:09:37.444]                 for (kk in seq_along(NAMES)) {
[16:09:37.444]                   name <- removed[[kk]]
[16:09:37.444]                   NAME <- NAMES[[kk]]
[16:09:37.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.444]                     next
[16:09:37.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.444]                 }
[16:09:37.444]                 if (length(args) > 0) 
[16:09:37.444]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.444]             }
[16:09:37.444]             else {
[16:09:37.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.444]             }
[16:09:37.444]             {
[16:09:37.444]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.444]                   0L) {
[16:09:37.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.444]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.444]                   base::options(opts)
[16:09:37.444]                 }
[16:09:37.444]                 {
[16:09:37.444]                   {
[16:09:37.444]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.444]                     NULL
[16:09:37.444]                   }
[16:09:37.444]                   options(future.plan = NULL)
[16:09:37.444]                   if (is.na(NA_character_)) 
[16:09:37.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.444]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.444]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.444]                     envir = parent.frame()) 
[16:09:37.444]                   {
[16:09:37.444]                     if (is.function(workers)) 
[16:09:37.444]                       workers <- workers()
[16:09:37.444]                     workers <- structure(as.integer(workers), 
[16:09:37.444]                       class = class(workers))
[16:09:37.444]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.444]                       workers >= 1)
[16:09:37.444]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.444]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.444]                     }
[16:09:37.444]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.444]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.444]                       envir = envir)
[16:09:37.444]                     if (!future$lazy) 
[16:09:37.444]                       future <- run(future)
[16:09:37.444]                     invisible(future)
[16:09:37.444]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.444]                 }
[16:09:37.444]             }
[16:09:37.444]         }
[16:09:37.444]     })
[16:09:37.444]     if (TRUE) {
[16:09:37.444]         base::sink(type = "output", split = FALSE)
[16:09:37.444]         if (TRUE) {
[16:09:37.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.444]         }
[16:09:37.444]         else {
[16:09:37.444]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.444]         }
[16:09:37.444]         base::close(...future.stdout)
[16:09:37.444]         ...future.stdout <- NULL
[16:09:37.444]     }
[16:09:37.444]     ...future.result$conditions <- ...future.conditions
[16:09:37.444]     ...future.result$finished <- base::Sys.time()
[16:09:37.444]     ...future.result
[16:09:37.444] }
[16:09:37.447] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:09:37.447] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:09:37.447] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:09:37.448] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:37.448] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.448] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:09:37.448] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:09:37.449] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:37.449] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:37.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.449] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:09:37.450] MultisessionFuture started
[16:09:37.450] - Launch lazy future ... done
[16:09:37.450] run() for ‘MultisessionFuture’ ... done
[16:09:37.450] Created future:
[16:09:37.450] MultisessionFuture:
[16:09:37.450] Label: ‘future_eapply-1’
[16:09:37.450] Expression:
[16:09:37.450] {
[16:09:37.450]     do.call(function(...) {
[16:09:37.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.450]             on.exit(options(oopts), add = TRUE)
[16:09:37.450]         }
[16:09:37.450]         {
[16:09:37.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.450]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.450]             })
[16:09:37.450]         }
[16:09:37.450]     }, args = future.call.arguments)
[16:09:37.450] }
[16:09:37.450] Lazy evaluation: FALSE
[16:09:37.450] Asynchronous evaluation: TRUE
[16:09:37.450] Local evaluation: TRUE
[16:09:37.450] Environment: R_GlobalEnv
[16:09:37.450] Capture standard output: TRUE
[16:09:37.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.450] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.450] Packages: 1 packages (‘stats’)
[16:09:37.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.450] Resolved: FALSE
[16:09:37.450] Value: <not collected>
[16:09:37.450] Conditions captured: <none>
[16:09:37.450] Early signaling: FALSE
[16:09:37.450] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.450] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.462] Chunk #1 of 2 ... DONE
[16:09:37.462] Chunk #2 of 2 ...
[16:09:37.462]  - Finding globals in 'X' for chunk #2 ...
[16:09:37.462] getGlobalsAndPackages() ...
[16:09:37.462] Searching for globals...
[16:09:37.463] 
[16:09:37.463] Searching for globals ... DONE
[16:09:37.463] - globals: [0] <none>
[16:09:37.463] getGlobalsAndPackages() ... DONE
[16:09:37.463]    + additional globals found: [n=0] 
[16:09:37.463]    + additional namespaces needed: [n=0] 
[16:09:37.463]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:37.463]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:37.464]  - seeds: <none>
[16:09:37.464] getGlobalsAndPackages() ...
[16:09:37.464] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.464] Resolving globals: FALSE
[16:09:37.464] Tweak future expression to call with '...' arguments ...
[16:09:37.464] {
[16:09:37.464]     do.call(function(...) {
[16:09:37.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.464]             on.exit(options(oopts), add = TRUE)
[16:09:37.464]         }
[16:09:37.464]         {
[16:09:37.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.464]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.464]             })
[16:09:37.464]         }
[16:09:37.464]     }, args = future.call.arguments)
[16:09:37.464] }
[16:09:37.464] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.465] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.465] - packages: [1] ‘stats’
[16:09:37.465] getGlobalsAndPackages() ... DONE
[16:09:37.465] run() for ‘Future’ ...
[16:09:37.466] - state: ‘created’
[16:09:37.466] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.482] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.482]   - Field: ‘node’
[16:09:37.483]   - Field: ‘label’
[16:09:37.483]   - Field: ‘local’
[16:09:37.483]   - Field: ‘owner’
[16:09:37.483]   - Field: ‘envir’
[16:09:37.483]   - Field: ‘workers’
[16:09:37.483]   - Field: ‘packages’
[16:09:37.483]   - Field: ‘gc’
[16:09:37.483]   - Field: ‘conditions’
[16:09:37.483]   - Field: ‘persistent’
[16:09:37.483]   - Field: ‘expr’
[16:09:37.484]   - Field: ‘uuid’
[16:09:37.484]   - Field: ‘seed’
[16:09:37.484]   - Field: ‘version’
[16:09:37.484]   - Field: ‘result’
[16:09:37.484]   - Field: ‘asynchronous’
[16:09:37.484]   - Field: ‘calls’
[16:09:37.484]   - Field: ‘globals’
[16:09:37.484]   - Field: ‘stdout’
[16:09:37.484]   - Field: ‘earlySignal’
[16:09:37.484]   - Field: ‘lazy’
[16:09:37.484]   - Field: ‘state’
[16:09:37.485] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.485] - Launch lazy future ...
[16:09:37.485] Packages needed by the future expression (n = 1): ‘stats’
[16:09:37.485] Packages needed by future strategies (n = 0): <none>
[16:09:37.486] {
[16:09:37.486]     {
[16:09:37.486]         {
[16:09:37.486]             ...future.startTime <- base::Sys.time()
[16:09:37.486]             {
[16:09:37.486]                 {
[16:09:37.486]                   {
[16:09:37.486]                     {
[16:09:37.486]                       {
[16:09:37.486]                         base::local({
[16:09:37.486]                           has_future <- base::requireNamespace("future", 
[16:09:37.486]                             quietly = TRUE)
[16:09:37.486]                           if (has_future) {
[16:09:37.486]                             ns <- base::getNamespace("future")
[16:09:37.486]                             version <- ns[[".package"]][["version"]]
[16:09:37.486]                             if (is.null(version)) 
[16:09:37.486]                               version <- utils::packageVersion("future")
[16:09:37.486]                           }
[16:09:37.486]                           else {
[16:09:37.486]                             version <- NULL
[16:09:37.486]                           }
[16:09:37.486]                           if (!has_future || version < "1.8.0") {
[16:09:37.486]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.486]                               "", base::R.version$version.string), 
[16:09:37.486]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:37.486]                                 base::R.version$platform, 8 * 
[16:09:37.486]                                   base::.Machine$sizeof.pointer), 
[16:09:37.486]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.486]                                 "release", "version")], collapse = " "), 
[16:09:37.486]                               hostname = base::Sys.info()[["nodename"]])
[16:09:37.486]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.486]                               info)
[16:09:37.486]                             info <- base::paste(info, collapse = "; ")
[16:09:37.486]                             if (!has_future) {
[16:09:37.486]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.486]                                 info)
[16:09:37.486]                             }
[16:09:37.486]                             else {
[16:09:37.486]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.486]                                 info, version)
[16:09:37.486]                             }
[16:09:37.486]                             base::stop(msg)
[16:09:37.486]                           }
[16:09:37.486]                         })
[16:09:37.486]                       }
[16:09:37.486]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.486]                       base::options(mc.cores = 1L)
[16:09:37.486]                     }
[16:09:37.486]                     base::local({
[16:09:37.486]                       for (pkg in "stats") {
[16:09:37.486]                         base::loadNamespace(pkg)
[16:09:37.486]                         base::library(pkg, character.only = TRUE)
[16:09:37.486]                       }
[16:09:37.486]                     })
[16:09:37.486]                   }
[16:09:37.486]                   options(future.plan = NULL)
[16:09:37.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.486]                 }
[16:09:37.486]                 ...future.workdir <- getwd()
[16:09:37.486]             }
[16:09:37.486]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.486]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.486]         }
[16:09:37.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.486]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:37.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.486]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.486]             base::names(...future.oldOptions))
[16:09:37.486]     }
[16:09:37.486]     if (FALSE) {
[16:09:37.486]     }
[16:09:37.486]     else {
[16:09:37.486]         if (TRUE) {
[16:09:37.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.486]                 open = "w")
[16:09:37.486]         }
[16:09:37.486]         else {
[16:09:37.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.486]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.486]         }
[16:09:37.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.486]             base::sink(type = "output", split = FALSE)
[16:09:37.486]             base::close(...future.stdout)
[16:09:37.486]         }, add = TRUE)
[16:09:37.486]     }
[16:09:37.486]     ...future.frame <- base::sys.nframe()
[16:09:37.486]     ...future.conditions <- base::list()
[16:09:37.486]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.486]     if (FALSE) {
[16:09:37.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.486]     }
[16:09:37.486]     ...future.result <- base::tryCatch({
[16:09:37.486]         base::withCallingHandlers({
[16:09:37.486]             ...future.value <- base::withVisible(base::local({
[16:09:37.486]                 ...future.makeSendCondition <- local({
[16:09:37.486]                   sendCondition <- NULL
[16:09:37.486]                   function(frame = 1L) {
[16:09:37.486]                     if (is.function(sendCondition)) 
[16:09:37.486]                       return(sendCondition)
[16:09:37.486]                     ns <- getNamespace("parallel")
[16:09:37.486]                     if (exists("sendData", mode = "function", 
[16:09:37.486]                       envir = ns)) {
[16:09:37.486]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.486]                         envir = ns)
[16:09:37.486]                       envir <- sys.frame(frame)
[16:09:37.486]                       master <- NULL
[16:09:37.486]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.486]                         !identical(envir, emptyenv())) {
[16:09:37.486]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.486]                           inherits = FALSE)) {
[16:09:37.486]                           master <- get("master", mode = "list", 
[16:09:37.486]                             envir = envir, inherits = FALSE)
[16:09:37.486]                           if (inherits(master, c("SOCKnode", 
[16:09:37.486]                             "SOCK0node"))) {
[16:09:37.486]                             sendCondition <<- function(cond) {
[16:09:37.486]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.486]                                 success = TRUE)
[16:09:37.486]                               parallel_sendData(master, data)
[16:09:37.486]                             }
[16:09:37.486]                             return(sendCondition)
[16:09:37.486]                           }
[16:09:37.486]                         }
[16:09:37.486]                         frame <- frame + 1L
[16:09:37.486]                         envir <- sys.frame(frame)
[16:09:37.486]                       }
[16:09:37.486]                     }
[16:09:37.486]                     sendCondition <<- function(cond) NULL
[16:09:37.486]                   }
[16:09:37.486]                 })
[16:09:37.486]                 withCallingHandlers({
[16:09:37.486]                   {
[16:09:37.486]                     do.call(function(...) {
[16:09:37.486]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.486]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.486]                         ...future.globals.maxSize)) {
[16:09:37.486]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.486]                         on.exit(options(oopts), add = TRUE)
[16:09:37.486]                       }
[16:09:37.486]                       {
[16:09:37.486]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.486]                           FUN = function(jj) {
[16:09:37.486]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.486]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.486]                           })
[16:09:37.486]                       }
[16:09:37.486]                     }, args = future.call.arguments)
[16:09:37.486]                   }
[16:09:37.486]                 }, immediateCondition = function(cond) {
[16:09:37.486]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.486]                   sendCondition(cond)
[16:09:37.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.486]                   {
[16:09:37.486]                     inherits <- base::inherits
[16:09:37.486]                     invokeRestart <- base::invokeRestart
[16:09:37.486]                     is.null <- base::is.null
[16:09:37.486]                     muffled <- FALSE
[16:09:37.486]                     if (inherits(cond, "message")) {
[16:09:37.486]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.486]                       if (muffled) 
[16:09:37.486]                         invokeRestart("muffleMessage")
[16:09:37.486]                     }
[16:09:37.486]                     else if (inherits(cond, "warning")) {
[16:09:37.486]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.486]                       if (muffled) 
[16:09:37.486]                         invokeRestart("muffleWarning")
[16:09:37.486]                     }
[16:09:37.486]                     else if (inherits(cond, "condition")) {
[16:09:37.486]                       if (!is.null(pattern)) {
[16:09:37.486]                         computeRestarts <- base::computeRestarts
[16:09:37.486]                         grepl <- base::grepl
[16:09:37.486]                         restarts <- computeRestarts(cond)
[16:09:37.486]                         for (restart in restarts) {
[16:09:37.486]                           name <- restart$name
[16:09:37.486]                           if (is.null(name)) 
[16:09:37.486]                             next
[16:09:37.486]                           if (!grepl(pattern, name)) 
[16:09:37.486]                             next
[16:09:37.486]                           invokeRestart(restart)
[16:09:37.486]                           muffled <- TRUE
[16:09:37.486]                           break
[16:09:37.486]                         }
[16:09:37.486]                       }
[16:09:37.486]                     }
[16:09:37.486]                     invisible(muffled)
[16:09:37.486]                   }
[16:09:37.486]                   muffleCondition(cond)
[16:09:37.486]                 })
[16:09:37.486]             }))
[16:09:37.486]             future::FutureResult(value = ...future.value$value, 
[16:09:37.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.486]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.486]                     ...future.globalenv.names))
[16:09:37.486]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.486]         }, condition = base::local({
[16:09:37.486]             c <- base::c
[16:09:37.486]             inherits <- base::inherits
[16:09:37.486]             invokeRestart <- base::invokeRestart
[16:09:37.486]             length <- base::length
[16:09:37.486]             list <- base::list
[16:09:37.486]             seq.int <- base::seq.int
[16:09:37.486]             signalCondition <- base::signalCondition
[16:09:37.486]             sys.calls <- base::sys.calls
[16:09:37.486]             `[[` <- base::`[[`
[16:09:37.486]             `+` <- base::`+`
[16:09:37.486]             `<<-` <- base::`<<-`
[16:09:37.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.486]                   3L)]
[16:09:37.486]             }
[16:09:37.486]             function(cond) {
[16:09:37.486]                 is_error <- inherits(cond, "error")
[16:09:37.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.486]                   NULL)
[16:09:37.486]                 if (is_error) {
[16:09:37.486]                   sessionInformation <- function() {
[16:09:37.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.486]                       search = base::search(), system = base::Sys.info())
[16:09:37.486]                   }
[16:09:37.486]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.486]                     cond$call), session = sessionInformation(), 
[16:09:37.486]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.486]                   signalCondition(cond)
[16:09:37.486]                 }
[16:09:37.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.486]                 "immediateCondition"))) {
[16:09:37.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.486]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.486]                   if (TRUE && !signal) {
[16:09:37.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.486]                     {
[16:09:37.486]                       inherits <- base::inherits
[16:09:37.486]                       invokeRestart <- base::invokeRestart
[16:09:37.486]                       is.null <- base::is.null
[16:09:37.486]                       muffled <- FALSE
[16:09:37.486]                       if (inherits(cond, "message")) {
[16:09:37.486]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.486]                         if (muffled) 
[16:09:37.486]                           invokeRestart("muffleMessage")
[16:09:37.486]                       }
[16:09:37.486]                       else if (inherits(cond, "warning")) {
[16:09:37.486]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.486]                         if (muffled) 
[16:09:37.486]                           invokeRestart("muffleWarning")
[16:09:37.486]                       }
[16:09:37.486]                       else if (inherits(cond, "condition")) {
[16:09:37.486]                         if (!is.null(pattern)) {
[16:09:37.486]                           computeRestarts <- base::computeRestarts
[16:09:37.486]                           grepl <- base::grepl
[16:09:37.486]                           restarts <- computeRestarts(cond)
[16:09:37.486]                           for (restart in restarts) {
[16:09:37.486]                             name <- restart$name
[16:09:37.486]                             if (is.null(name)) 
[16:09:37.486]                               next
[16:09:37.486]                             if (!grepl(pattern, name)) 
[16:09:37.486]                               next
[16:09:37.486]                             invokeRestart(restart)
[16:09:37.486]                             muffled <- TRUE
[16:09:37.486]                             break
[16:09:37.486]                           }
[16:09:37.486]                         }
[16:09:37.486]                       }
[16:09:37.486]                       invisible(muffled)
[16:09:37.486]                     }
[16:09:37.486]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.486]                   }
[16:09:37.486]                 }
[16:09:37.486]                 else {
[16:09:37.486]                   if (TRUE) {
[16:09:37.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.486]                     {
[16:09:37.486]                       inherits <- base::inherits
[16:09:37.486]                       invokeRestart <- base::invokeRestart
[16:09:37.486]                       is.null <- base::is.null
[16:09:37.486]                       muffled <- FALSE
[16:09:37.486]                       if (inherits(cond, "message")) {
[16:09:37.486]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.486]                         if (muffled) 
[16:09:37.486]                           invokeRestart("muffleMessage")
[16:09:37.486]                       }
[16:09:37.486]                       else if (inherits(cond, "warning")) {
[16:09:37.486]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.486]                         if (muffled) 
[16:09:37.486]                           invokeRestart("muffleWarning")
[16:09:37.486]                       }
[16:09:37.486]                       else if (inherits(cond, "condition")) {
[16:09:37.486]                         if (!is.null(pattern)) {
[16:09:37.486]                           computeRestarts <- base::computeRestarts
[16:09:37.486]                           grepl <- base::grepl
[16:09:37.486]                           restarts <- computeRestarts(cond)
[16:09:37.486]                           for (restart in restarts) {
[16:09:37.486]                             name <- restart$name
[16:09:37.486]                             if (is.null(name)) 
[16:09:37.486]                               next
[16:09:37.486]                             if (!grepl(pattern, name)) 
[16:09:37.486]                               next
[16:09:37.486]                             invokeRestart(restart)
[16:09:37.486]                             muffled <- TRUE
[16:09:37.486]                             break
[16:09:37.486]                           }
[16:09:37.486]                         }
[16:09:37.486]                       }
[16:09:37.486]                       invisible(muffled)
[16:09:37.486]                     }
[16:09:37.486]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.486]                   }
[16:09:37.486]                 }
[16:09:37.486]             }
[16:09:37.486]         }))
[16:09:37.486]     }, error = function(ex) {
[16:09:37.486]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.486]                 ...future.rng), started = ...future.startTime, 
[16:09:37.486]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.486]             version = "1.8"), class = "FutureResult")
[16:09:37.486]     }, finally = {
[16:09:37.486]         if (!identical(...future.workdir, getwd())) 
[16:09:37.486]             setwd(...future.workdir)
[16:09:37.486]         {
[16:09:37.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.486]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.486]             }
[16:09:37.486]             base::options(...future.oldOptions)
[16:09:37.486]             if (.Platform$OS.type == "windows") {
[16:09:37.486]                 old_names <- names(...future.oldEnvVars)
[16:09:37.486]                 envs <- base::Sys.getenv()
[16:09:37.486]                 names <- names(envs)
[16:09:37.486]                 common <- intersect(names, old_names)
[16:09:37.486]                 added <- setdiff(names, old_names)
[16:09:37.486]                 removed <- setdiff(old_names, names)
[16:09:37.486]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.486]                   envs[common]]
[16:09:37.486]                 NAMES <- toupper(changed)
[16:09:37.486]                 args <- list()
[16:09:37.486]                 for (kk in seq_along(NAMES)) {
[16:09:37.486]                   name <- changed[[kk]]
[16:09:37.486]                   NAME <- NAMES[[kk]]
[16:09:37.486]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.486]                     next
[16:09:37.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.486]                 }
[16:09:37.486]                 NAMES <- toupper(added)
[16:09:37.486]                 for (kk in seq_along(NAMES)) {
[16:09:37.486]                   name <- added[[kk]]
[16:09:37.486]                   NAME <- NAMES[[kk]]
[16:09:37.486]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.486]                     next
[16:09:37.486]                   args[[name]] <- ""
[16:09:37.486]                 }
[16:09:37.486]                 NAMES <- toupper(removed)
[16:09:37.486]                 for (kk in seq_along(NAMES)) {
[16:09:37.486]                   name <- removed[[kk]]
[16:09:37.486]                   NAME <- NAMES[[kk]]
[16:09:37.486]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.486]                     next
[16:09:37.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.486]                 }
[16:09:37.486]                 if (length(args) > 0) 
[16:09:37.486]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.486]             }
[16:09:37.486]             else {
[16:09:37.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.486]             }
[16:09:37.486]             {
[16:09:37.486]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.486]                   0L) {
[16:09:37.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.486]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.486]                   base::options(opts)
[16:09:37.486]                 }
[16:09:37.486]                 {
[16:09:37.486]                   {
[16:09:37.486]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.486]                     NULL
[16:09:37.486]                   }
[16:09:37.486]                   options(future.plan = NULL)
[16:09:37.486]                   if (is.na(NA_character_)) 
[16:09:37.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.486]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.486]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.486]                     envir = parent.frame()) 
[16:09:37.486]                   {
[16:09:37.486]                     if (is.function(workers)) 
[16:09:37.486]                       workers <- workers()
[16:09:37.486]                     workers <- structure(as.integer(workers), 
[16:09:37.486]                       class = class(workers))
[16:09:37.486]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.486]                       workers >= 1)
[16:09:37.486]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.486]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.486]                     }
[16:09:37.486]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.486]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.486]                       envir = envir)
[16:09:37.486]                     if (!future$lazy) 
[16:09:37.486]                       future <- run(future)
[16:09:37.486]                     invisible(future)
[16:09:37.486]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.486]                 }
[16:09:37.486]             }
[16:09:37.486]         }
[16:09:37.486]     })
[16:09:37.486]     if (TRUE) {
[16:09:37.486]         base::sink(type = "output", split = FALSE)
[16:09:37.486]         if (TRUE) {
[16:09:37.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.486]         }
[16:09:37.486]         else {
[16:09:37.486]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.486]         }
[16:09:37.486]         base::close(...future.stdout)
[16:09:37.486]         ...future.stdout <- NULL
[16:09:37.486]     }
[16:09:37.486]     ...future.result$conditions <- ...future.conditions
[16:09:37.486]     ...future.result$finished <- base::Sys.time()
[16:09:37.486]     ...future.result
[16:09:37.486] }
[16:09:37.489] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:09:37.489] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:09:37.489] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:09:37.489] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:37.490] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.490] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:09:37.490] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:09:37.490] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:37.491] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.491] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:37.491] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.491] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:09:37.492] MultisessionFuture started
[16:09:37.492] - Launch lazy future ... done
[16:09:37.492] run() for ‘MultisessionFuture’ ... done
[16:09:37.492] Created future:
[16:09:37.492] MultisessionFuture:
[16:09:37.492] Label: ‘future_eapply-2’
[16:09:37.492] Expression:
[16:09:37.492] {
[16:09:37.492]     do.call(function(...) {
[16:09:37.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.492]             on.exit(options(oopts), add = TRUE)
[16:09:37.492]         }
[16:09:37.492]         {
[16:09:37.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.492]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.492]             })
[16:09:37.492]         }
[16:09:37.492]     }, args = future.call.arguments)
[16:09:37.492] }
[16:09:37.492] Lazy evaluation: FALSE
[16:09:37.492] Asynchronous evaluation: TRUE
[16:09:37.492] Local evaluation: TRUE
[16:09:37.492] Environment: R_GlobalEnv
[16:09:37.492] Capture standard output: TRUE
[16:09:37.492] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.492] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.492] Packages: 1 packages (‘stats’)
[16:09:37.492] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.492] Resolved: FALSE
[16:09:37.492] Value: <not collected>
[16:09:37.492] Conditions captured: <none>
[16:09:37.492] Early signaling: FALSE
[16:09:37.492] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.492] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.504] Chunk #2 of 2 ... DONE
[16:09:37.504] Launching 2 futures (chunks) ... DONE
[16:09:37.505] Resolving 2 futures (chunks) ...
[16:09:37.505] resolve() on list ...
[16:09:37.505]  recursive: 0
[16:09:37.505]  length: 2
[16:09:37.505] 
[16:09:37.505] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.506] - Validating connection of MultisessionFuture
[16:09:37.506] - received message: FutureResult
[16:09:37.506] - Received FutureResult
[16:09:37.506] - Erased future from FutureRegistry
[16:09:37.506] result() for ClusterFuture ...
[16:09:37.506] - result already collected: FutureResult
[16:09:37.506] result() for ClusterFuture ... done
[16:09:37.506] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.506] Future #1
[16:09:37.507] result() for ClusterFuture ...
[16:09:37.507] - result already collected: FutureResult
[16:09:37.507] result() for ClusterFuture ... done
[16:09:37.507] result() for ClusterFuture ...
[16:09:37.507] - result already collected: FutureResult
[16:09:37.507] result() for ClusterFuture ... done
[16:09:37.507] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:37.507] - nx: 2
[16:09:37.507] - relay: TRUE
[16:09:37.507] - stdout: TRUE
[16:09:37.507] - signal: TRUE
[16:09:37.507] - resignal: FALSE
[16:09:37.508] - force: TRUE
[16:09:37.508] - relayed: [n=2] FALSE, FALSE
[16:09:37.508] - queued futures: [n=2] FALSE, FALSE
[16:09:37.508]  - until=1
[16:09:37.508]  - relaying element #1
[16:09:37.508] result() for ClusterFuture ...
[16:09:37.508] - result already collected: FutureResult
[16:09:37.508] result() for ClusterFuture ... done
[16:09:37.508] result() for ClusterFuture ...
[16:09:37.508] - result already collected: FutureResult
[16:09:37.508] result() for ClusterFuture ... done
[16:09:37.509] result() for ClusterFuture ...
[16:09:37.509] - result already collected: FutureResult
[16:09:37.509] result() for ClusterFuture ... done
[16:09:37.509] result() for ClusterFuture ...
[16:09:37.509] - result already collected: FutureResult
[16:09:37.509] result() for ClusterFuture ... done
[16:09:37.509] - relayed: [n=2] TRUE, FALSE
[16:09:37.509] - queued futures: [n=2] TRUE, FALSE
[16:09:37.509] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:37.509]  length: 1 (resolved future 1)
[16:09:37.538] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.538] - Validating connection of MultisessionFuture
[16:09:37.538] - received message: FutureResult
[16:09:37.538] - Received FutureResult
[16:09:37.538] - Erased future from FutureRegistry
[16:09:37.539] result() for ClusterFuture ...
[16:09:37.539] - result already collected: FutureResult
[16:09:37.539] result() for ClusterFuture ... done
[16:09:37.539] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.539] Future #2
[16:09:37.539] result() for ClusterFuture ...
[16:09:37.539] - result already collected: FutureResult
[16:09:37.539] result() for ClusterFuture ... done
[16:09:37.540] result() for ClusterFuture ...
[16:09:37.540] - result already collected: FutureResult
[16:09:37.540] result() for ClusterFuture ... done
[16:09:37.540] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:37.540] - nx: 2
[16:09:37.540] - relay: TRUE
[16:09:37.540] - stdout: TRUE
[16:09:37.540] - signal: TRUE
[16:09:37.540] - resignal: FALSE
[16:09:37.540] - force: TRUE
[16:09:37.540] - relayed: [n=2] TRUE, FALSE
[16:09:37.541] - queued futures: [n=2] TRUE, FALSE
[16:09:37.541]  - until=2
[16:09:37.541]  - relaying element #2
[16:09:37.541] result() for ClusterFuture ...
[16:09:37.541] - result already collected: FutureResult
[16:09:37.541] result() for ClusterFuture ... done
[16:09:37.541] result() for ClusterFuture ...
[16:09:37.541] - result already collected: FutureResult
[16:09:37.541] result() for ClusterFuture ... done
[16:09:37.541] result() for ClusterFuture ...
[16:09:37.542] - result already collected: FutureResult
[16:09:37.542] result() for ClusterFuture ... done
[16:09:37.542] result() for ClusterFuture ...
[16:09:37.542] - result already collected: FutureResult
[16:09:37.542] result() for ClusterFuture ... done
[16:09:37.542] - relayed: [n=2] TRUE, TRUE
[16:09:37.542] - queued futures: [n=2] TRUE, TRUE
[16:09:37.542] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:37.542]  length: 0 (resolved future 2)
[16:09:37.542] Relaying remaining futures
[16:09:37.542] signalConditionsASAP(NULL, pos=0) ...
[16:09:37.543] - nx: 2
[16:09:37.543] - relay: TRUE
[16:09:37.543] - stdout: TRUE
[16:09:37.543] - signal: TRUE
[16:09:37.543] - resignal: FALSE
[16:09:37.543] - force: TRUE
[16:09:37.543] - relayed: [n=2] TRUE, TRUE
[16:09:37.543] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:37.543] - relayed: [n=2] TRUE, TRUE
[16:09:37.543] - queued futures: [n=2] TRUE, TRUE
[16:09:37.543] signalConditionsASAP(NULL, pos=0) ... done
[16:09:37.543] resolve() on list ... DONE
[16:09:37.544] result() for ClusterFuture ...
[16:09:37.544] - result already collected: FutureResult
[16:09:37.544] result() for ClusterFuture ... done
[16:09:37.544] result() for ClusterFuture ...
[16:09:37.544] - result already collected: FutureResult
[16:09:37.544] result() for ClusterFuture ... done
[16:09:37.544] result() for ClusterFuture ...
[16:09:37.544] - result already collected: FutureResult
[16:09:37.544] result() for ClusterFuture ... done
[16:09:37.544] result() for ClusterFuture ...
[16:09:37.544] - result already collected: FutureResult
[16:09:37.545] result() for ClusterFuture ... done
[16:09:37.545]  - Number of value chunks collected: 2
[16:09:37.545] Resolving 2 futures (chunks) ... DONE
[16:09:37.545] Reducing values from 2 chunks ...
[16:09:37.545]  - Number of values collected after concatenation: 3
[16:09:37.545]  - Number of values expected: 3
[16:09:37.545] Reducing values from 2 chunks ... DONE
[16:09:37.545] future_lapply() ... DONE
[16:09:37.546] future_lapply() ...
[16:09:37.550] Number of chunks: 2
[16:09:37.550] getGlobalsAndPackagesXApply() ...
[16:09:37.550]  - future.globals: TRUE
[16:09:37.550] getGlobalsAndPackages() ...
[16:09:37.550] Searching for globals...
[16:09:37.551] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:37.551] Searching for globals ... DONE
[16:09:37.551] Resolving globals: FALSE
[16:09:37.552] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:37.552] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:37.552] - globals: [1] ‘FUN’
[16:09:37.552] - packages: [1] ‘stats’
[16:09:37.552] getGlobalsAndPackages() ... DONE
[16:09:37.553]  - globals found/used: [n=1] ‘FUN’
[16:09:37.553]  - needed namespaces: [n=1] ‘stats’
[16:09:37.553] Finding globals ... DONE
[16:09:37.553]  - use_args: TRUE
[16:09:37.553]  - Getting '...' globals ...
[16:09:37.553] resolve() on list ...
[16:09:37.553]  recursive: 0
[16:09:37.553]  length: 1
[16:09:37.554]  elements: ‘...’
[16:09:37.554]  length: 0 (resolved future 1)
[16:09:37.554] resolve() on list ... DONE
[16:09:37.554]    - '...' content: [n=0] 
[16:09:37.554] List of 1
[16:09:37.554]  $ ...: list()
[16:09:37.554]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.554]  - attr(*, "where")=List of 1
[16:09:37.554]   ..$ ...:<environment: 0x55b4b9557180> 
[16:09:37.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.554]  - attr(*, "resolved")= logi TRUE
[16:09:37.554]  - attr(*, "total_size")= num NA
[16:09:37.557]  - Getting '...' globals ... DONE
[16:09:37.557] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:37.557] List of 2
[16:09:37.557]  $ ...future.FUN:function (x, ...)  
[16:09:37.557]  $ ...          : list()
[16:09:37.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:37.557]  - attr(*, "where")=List of 2
[16:09:37.557]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:37.557]   ..$ ...          :<environment: 0x55b4b9557180> 
[16:09:37.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:37.557]  - attr(*, "resolved")= logi FALSE
[16:09:37.557]  - attr(*, "total_size")= num 1248
[16:09:37.559] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:37.559] getGlobalsAndPackagesXApply() ... DONE
[16:09:37.560] Number of futures (= number of chunks): 2
[16:09:37.560] Launching 2 futures (chunks) ...
[16:09:37.560] Chunk #1 of 2 ...
[16:09:37.560]  - Finding globals in 'X' for chunk #1 ...
[16:09:37.560] getGlobalsAndPackages() ...
[16:09:37.560] Searching for globals...
[16:09:37.560] 
[16:09:37.561] Searching for globals ... DONE
[16:09:37.561] - globals: [0] <none>
[16:09:37.561] getGlobalsAndPackages() ... DONE
[16:09:37.561]    + additional globals found: [n=0] 
[16:09:37.561]    + additional namespaces needed: [n=0] 
[16:09:37.561]  - Finding globals in 'X' for chunk #1 ... DONE
[16:09:37.561]  - seeds: <none>
[16:09:37.561] getGlobalsAndPackages() ...
[16:09:37.561] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.561] Resolving globals: FALSE
[16:09:37.561] Tweak future expression to call with '...' arguments ...
[16:09:37.562] {
[16:09:37.562]     do.call(function(...) {
[16:09:37.562]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.562]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.562]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.562]             on.exit(options(oopts), add = TRUE)
[16:09:37.562]         }
[16:09:37.562]         {
[16:09:37.562]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.562]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.562]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.562]             })
[16:09:37.562]         }
[16:09:37.562]     }, args = future.call.arguments)
[16:09:37.562] }
[16:09:37.562] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.562] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.562] - packages: [1] ‘stats’
[16:09:37.562] getGlobalsAndPackages() ... DONE
[16:09:37.563] run() for ‘Future’ ...
[16:09:37.563] - state: ‘created’
[16:09:37.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.578]   - Field: ‘node’
[16:09:37.578]   - Field: ‘label’
[16:09:37.578]   - Field: ‘local’
[16:09:37.578]   - Field: ‘owner’
[16:09:37.578]   - Field: ‘envir’
[16:09:37.578]   - Field: ‘workers’
[16:09:37.579]   - Field: ‘packages’
[16:09:37.579]   - Field: ‘gc’
[16:09:37.579]   - Field: ‘conditions’
[16:09:37.579]   - Field: ‘persistent’
[16:09:37.579]   - Field: ‘expr’
[16:09:37.579]   - Field: ‘uuid’
[16:09:37.579]   - Field: ‘seed’
[16:09:37.579]   - Field: ‘version’
[16:09:37.579]   - Field: ‘result’
[16:09:37.579]   - Field: ‘asynchronous’
[16:09:37.579]   - Field: ‘calls’
[16:09:37.580]   - Field: ‘globals’
[16:09:37.580]   - Field: ‘stdout’
[16:09:37.580]   - Field: ‘earlySignal’
[16:09:37.580]   - Field: ‘lazy’
[16:09:37.580]   - Field: ‘state’
[16:09:37.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.580] - Launch lazy future ...
[16:09:37.580] Packages needed by the future expression (n = 1): ‘stats’
[16:09:37.581] Packages needed by future strategies (n = 0): <none>
[16:09:37.581] {
[16:09:37.581]     {
[16:09:37.581]         {
[16:09:37.581]             ...future.startTime <- base::Sys.time()
[16:09:37.581]             {
[16:09:37.581]                 {
[16:09:37.581]                   {
[16:09:37.581]                     {
[16:09:37.581]                       {
[16:09:37.581]                         base::local({
[16:09:37.581]                           has_future <- base::requireNamespace("future", 
[16:09:37.581]                             quietly = TRUE)
[16:09:37.581]                           if (has_future) {
[16:09:37.581]                             ns <- base::getNamespace("future")
[16:09:37.581]                             version <- ns[[".package"]][["version"]]
[16:09:37.581]                             if (is.null(version)) 
[16:09:37.581]                               version <- utils::packageVersion("future")
[16:09:37.581]                           }
[16:09:37.581]                           else {
[16:09:37.581]                             version <- NULL
[16:09:37.581]                           }
[16:09:37.581]                           if (!has_future || version < "1.8.0") {
[16:09:37.581]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.581]                               "", base::R.version$version.string), 
[16:09:37.581]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:37.581]                                 base::R.version$platform, 8 * 
[16:09:37.581]                                   base::.Machine$sizeof.pointer), 
[16:09:37.581]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.581]                                 "release", "version")], collapse = " "), 
[16:09:37.581]                               hostname = base::Sys.info()[["nodename"]])
[16:09:37.581]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.581]                               info)
[16:09:37.581]                             info <- base::paste(info, collapse = "; ")
[16:09:37.581]                             if (!has_future) {
[16:09:37.581]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.581]                                 info)
[16:09:37.581]                             }
[16:09:37.581]                             else {
[16:09:37.581]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.581]                                 info, version)
[16:09:37.581]                             }
[16:09:37.581]                             base::stop(msg)
[16:09:37.581]                           }
[16:09:37.581]                         })
[16:09:37.581]                       }
[16:09:37.581]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.581]                       base::options(mc.cores = 1L)
[16:09:37.581]                     }
[16:09:37.581]                     base::local({
[16:09:37.581]                       for (pkg in "stats") {
[16:09:37.581]                         base::loadNamespace(pkg)
[16:09:37.581]                         base::library(pkg, character.only = TRUE)
[16:09:37.581]                       }
[16:09:37.581]                     })
[16:09:37.581]                   }
[16:09:37.581]                   options(future.plan = NULL)
[16:09:37.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.581]                 }
[16:09:37.581]                 ...future.workdir <- getwd()
[16:09:37.581]             }
[16:09:37.581]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.581]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.581]         }
[16:09:37.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:37.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.581]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.581]             base::names(...future.oldOptions))
[16:09:37.581]     }
[16:09:37.581]     if (FALSE) {
[16:09:37.581]     }
[16:09:37.581]     else {
[16:09:37.581]         if (TRUE) {
[16:09:37.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.581]                 open = "w")
[16:09:37.581]         }
[16:09:37.581]         else {
[16:09:37.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.581]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.581]         }
[16:09:37.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.581]             base::sink(type = "output", split = FALSE)
[16:09:37.581]             base::close(...future.stdout)
[16:09:37.581]         }, add = TRUE)
[16:09:37.581]     }
[16:09:37.581]     ...future.frame <- base::sys.nframe()
[16:09:37.581]     ...future.conditions <- base::list()
[16:09:37.581]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.581]     if (FALSE) {
[16:09:37.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.581]     }
[16:09:37.581]     ...future.result <- base::tryCatch({
[16:09:37.581]         base::withCallingHandlers({
[16:09:37.581]             ...future.value <- base::withVisible(base::local({
[16:09:37.581]                 ...future.makeSendCondition <- local({
[16:09:37.581]                   sendCondition <- NULL
[16:09:37.581]                   function(frame = 1L) {
[16:09:37.581]                     if (is.function(sendCondition)) 
[16:09:37.581]                       return(sendCondition)
[16:09:37.581]                     ns <- getNamespace("parallel")
[16:09:37.581]                     if (exists("sendData", mode = "function", 
[16:09:37.581]                       envir = ns)) {
[16:09:37.581]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.581]                         envir = ns)
[16:09:37.581]                       envir <- sys.frame(frame)
[16:09:37.581]                       master <- NULL
[16:09:37.581]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.581]                         !identical(envir, emptyenv())) {
[16:09:37.581]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.581]                           inherits = FALSE)) {
[16:09:37.581]                           master <- get("master", mode = "list", 
[16:09:37.581]                             envir = envir, inherits = FALSE)
[16:09:37.581]                           if (inherits(master, c("SOCKnode", 
[16:09:37.581]                             "SOCK0node"))) {
[16:09:37.581]                             sendCondition <<- function(cond) {
[16:09:37.581]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.581]                                 success = TRUE)
[16:09:37.581]                               parallel_sendData(master, data)
[16:09:37.581]                             }
[16:09:37.581]                             return(sendCondition)
[16:09:37.581]                           }
[16:09:37.581]                         }
[16:09:37.581]                         frame <- frame + 1L
[16:09:37.581]                         envir <- sys.frame(frame)
[16:09:37.581]                       }
[16:09:37.581]                     }
[16:09:37.581]                     sendCondition <<- function(cond) NULL
[16:09:37.581]                   }
[16:09:37.581]                 })
[16:09:37.581]                 withCallingHandlers({
[16:09:37.581]                   {
[16:09:37.581]                     do.call(function(...) {
[16:09:37.581]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.581]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.581]                         ...future.globals.maxSize)) {
[16:09:37.581]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.581]                         on.exit(options(oopts), add = TRUE)
[16:09:37.581]                       }
[16:09:37.581]                       {
[16:09:37.581]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.581]                           FUN = function(jj) {
[16:09:37.581]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.581]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.581]                           })
[16:09:37.581]                       }
[16:09:37.581]                     }, args = future.call.arguments)
[16:09:37.581]                   }
[16:09:37.581]                 }, immediateCondition = function(cond) {
[16:09:37.581]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.581]                   sendCondition(cond)
[16:09:37.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.581]                   {
[16:09:37.581]                     inherits <- base::inherits
[16:09:37.581]                     invokeRestart <- base::invokeRestart
[16:09:37.581]                     is.null <- base::is.null
[16:09:37.581]                     muffled <- FALSE
[16:09:37.581]                     if (inherits(cond, "message")) {
[16:09:37.581]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.581]                       if (muffled) 
[16:09:37.581]                         invokeRestart("muffleMessage")
[16:09:37.581]                     }
[16:09:37.581]                     else if (inherits(cond, "warning")) {
[16:09:37.581]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.581]                       if (muffled) 
[16:09:37.581]                         invokeRestart("muffleWarning")
[16:09:37.581]                     }
[16:09:37.581]                     else if (inherits(cond, "condition")) {
[16:09:37.581]                       if (!is.null(pattern)) {
[16:09:37.581]                         computeRestarts <- base::computeRestarts
[16:09:37.581]                         grepl <- base::grepl
[16:09:37.581]                         restarts <- computeRestarts(cond)
[16:09:37.581]                         for (restart in restarts) {
[16:09:37.581]                           name <- restart$name
[16:09:37.581]                           if (is.null(name)) 
[16:09:37.581]                             next
[16:09:37.581]                           if (!grepl(pattern, name)) 
[16:09:37.581]                             next
[16:09:37.581]                           invokeRestart(restart)
[16:09:37.581]                           muffled <- TRUE
[16:09:37.581]                           break
[16:09:37.581]                         }
[16:09:37.581]                       }
[16:09:37.581]                     }
[16:09:37.581]                     invisible(muffled)
[16:09:37.581]                   }
[16:09:37.581]                   muffleCondition(cond)
[16:09:37.581]                 })
[16:09:37.581]             }))
[16:09:37.581]             future::FutureResult(value = ...future.value$value, 
[16:09:37.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.581]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.581]                     ...future.globalenv.names))
[16:09:37.581]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.581]         }, condition = base::local({
[16:09:37.581]             c <- base::c
[16:09:37.581]             inherits <- base::inherits
[16:09:37.581]             invokeRestart <- base::invokeRestart
[16:09:37.581]             length <- base::length
[16:09:37.581]             list <- base::list
[16:09:37.581]             seq.int <- base::seq.int
[16:09:37.581]             signalCondition <- base::signalCondition
[16:09:37.581]             sys.calls <- base::sys.calls
[16:09:37.581]             `[[` <- base::`[[`
[16:09:37.581]             `+` <- base::`+`
[16:09:37.581]             `<<-` <- base::`<<-`
[16:09:37.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.581]                   3L)]
[16:09:37.581]             }
[16:09:37.581]             function(cond) {
[16:09:37.581]                 is_error <- inherits(cond, "error")
[16:09:37.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.581]                   NULL)
[16:09:37.581]                 if (is_error) {
[16:09:37.581]                   sessionInformation <- function() {
[16:09:37.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.581]                       search = base::search(), system = base::Sys.info())
[16:09:37.581]                   }
[16:09:37.581]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.581]                     cond$call), session = sessionInformation(), 
[16:09:37.581]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.581]                   signalCondition(cond)
[16:09:37.581]                 }
[16:09:37.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.581]                 "immediateCondition"))) {
[16:09:37.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.581]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.581]                   if (TRUE && !signal) {
[16:09:37.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.581]                     {
[16:09:37.581]                       inherits <- base::inherits
[16:09:37.581]                       invokeRestart <- base::invokeRestart
[16:09:37.581]                       is.null <- base::is.null
[16:09:37.581]                       muffled <- FALSE
[16:09:37.581]                       if (inherits(cond, "message")) {
[16:09:37.581]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.581]                         if (muffled) 
[16:09:37.581]                           invokeRestart("muffleMessage")
[16:09:37.581]                       }
[16:09:37.581]                       else if (inherits(cond, "warning")) {
[16:09:37.581]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.581]                         if (muffled) 
[16:09:37.581]                           invokeRestart("muffleWarning")
[16:09:37.581]                       }
[16:09:37.581]                       else if (inherits(cond, "condition")) {
[16:09:37.581]                         if (!is.null(pattern)) {
[16:09:37.581]                           computeRestarts <- base::computeRestarts
[16:09:37.581]                           grepl <- base::grepl
[16:09:37.581]                           restarts <- computeRestarts(cond)
[16:09:37.581]                           for (restart in restarts) {
[16:09:37.581]                             name <- restart$name
[16:09:37.581]                             if (is.null(name)) 
[16:09:37.581]                               next
[16:09:37.581]                             if (!grepl(pattern, name)) 
[16:09:37.581]                               next
[16:09:37.581]                             invokeRestart(restart)
[16:09:37.581]                             muffled <- TRUE
[16:09:37.581]                             break
[16:09:37.581]                           }
[16:09:37.581]                         }
[16:09:37.581]                       }
[16:09:37.581]                       invisible(muffled)
[16:09:37.581]                     }
[16:09:37.581]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.581]                   }
[16:09:37.581]                 }
[16:09:37.581]                 else {
[16:09:37.581]                   if (TRUE) {
[16:09:37.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.581]                     {
[16:09:37.581]                       inherits <- base::inherits
[16:09:37.581]                       invokeRestart <- base::invokeRestart
[16:09:37.581]                       is.null <- base::is.null
[16:09:37.581]                       muffled <- FALSE
[16:09:37.581]                       if (inherits(cond, "message")) {
[16:09:37.581]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.581]                         if (muffled) 
[16:09:37.581]                           invokeRestart("muffleMessage")
[16:09:37.581]                       }
[16:09:37.581]                       else if (inherits(cond, "warning")) {
[16:09:37.581]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.581]                         if (muffled) 
[16:09:37.581]                           invokeRestart("muffleWarning")
[16:09:37.581]                       }
[16:09:37.581]                       else if (inherits(cond, "condition")) {
[16:09:37.581]                         if (!is.null(pattern)) {
[16:09:37.581]                           computeRestarts <- base::computeRestarts
[16:09:37.581]                           grepl <- base::grepl
[16:09:37.581]                           restarts <- computeRestarts(cond)
[16:09:37.581]                           for (restart in restarts) {
[16:09:37.581]                             name <- restart$name
[16:09:37.581]                             if (is.null(name)) 
[16:09:37.581]                               next
[16:09:37.581]                             if (!grepl(pattern, name)) 
[16:09:37.581]                               next
[16:09:37.581]                             invokeRestart(restart)
[16:09:37.581]                             muffled <- TRUE
[16:09:37.581]                             break
[16:09:37.581]                           }
[16:09:37.581]                         }
[16:09:37.581]                       }
[16:09:37.581]                       invisible(muffled)
[16:09:37.581]                     }
[16:09:37.581]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.581]                   }
[16:09:37.581]                 }
[16:09:37.581]             }
[16:09:37.581]         }))
[16:09:37.581]     }, error = function(ex) {
[16:09:37.581]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.581]                 ...future.rng), started = ...future.startTime, 
[16:09:37.581]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.581]             version = "1.8"), class = "FutureResult")
[16:09:37.581]     }, finally = {
[16:09:37.581]         if (!identical(...future.workdir, getwd())) 
[16:09:37.581]             setwd(...future.workdir)
[16:09:37.581]         {
[16:09:37.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.581]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.581]             }
[16:09:37.581]             base::options(...future.oldOptions)
[16:09:37.581]             if (.Platform$OS.type == "windows") {
[16:09:37.581]                 old_names <- names(...future.oldEnvVars)
[16:09:37.581]                 envs <- base::Sys.getenv()
[16:09:37.581]                 names <- names(envs)
[16:09:37.581]                 common <- intersect(names, old_names)
[16:09:37.581]                 added <- setdiff(names, old_names)
[16:09:37.581]                 removed <- setdiff(old_names, names)
[16:09:37.581]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.581]                   envs[common]]
[16:09:37.581]                 NAMES <- toupper(changed)
[16:09:37.581]                 args <- list()
[16:09:37.581]                 for (kk in seq_along(NAMES)) {
[16:09:37.581]                   name <- changed[[kk]]
[16:09:37.581]                   NAME <- NAMES[[kk]]
[16:09:37.581]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.581]                     next
[16:09:37.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.581]                 }
[16:09:37.581]                 NAMES <- toupper(added)
[16:09:37.581]                 for (kk in seq_along(NAMES)) {
[16:09:37.581]                   name <- added[[kk]]
[16:09:37.581]                   NAME <- NAMES[[kk]]
[16:09:37.581]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.581]                     next
[16:09:37.581]                   args[[name]] <- ""
[16:09:37.581]                 }
[16:09:37.581]                 NAMES <- toupper(removed)
[16:09:37.581]                 for (kk in seq_along(NAMES)) {
[16:09:37.581]                   name <- removed[[kk]]
[16:09:37.581]                   NAME <- NAMES[[kk]]
[16:09:37.581]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.581]                     next
[16:09:37.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.581]                 }
[16:09:37.581]                 if (length(args) > 0) 
[16:09:37.581]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.581]             }
[16:09:37.581]             else {
[16:09:37.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.581]             }
[16:09:37.581]             {
[16:09:37.581]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.581]                   0L) {
[16:09:37.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.581]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.581]                   base::options(opts)
[16:09:37.581]                 }
[16:09:37.581]                 {
[16:09:37.581]                   {
[16:09:37.581]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.581]                     NULL
[16:09:37.581]                   }
[16:09:37.581]                   options(future.plan = NULL)
[16:09:37.581]                   if (is.na(NA_character_)) 
[16:09:37.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.581]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.581]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.581]                     envir = parent.frame()) 
[16:09:37.581]                   {
[16:09:37.581]                     if (is.function(workers)) 
[16:09:37.581]                       workers <- workers()
[16:09:37.581]                     workers <- structure(as.integer(workers), 
[16:09:37.581]                       class = class(workers))
[16:09:37.581]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.581]                       workers >= 1)
[16:09:37.581]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.581]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.581]                     }
[16:09:37.581]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.581]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.581]                       envir = envir)
[16:09:37.581]                     if (!future$lazy) 
[16:09:37.581]                       future <- run(future)
[16:09:37.581]                     invisible(future)
[16:09:37.581]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.581]                 }
[16:09:37.581]             }
[16:09:37.581]         }
[16:09:37.581]     })
[16:09:37.581]     if (TRUE) {
[16:09:37.581]         base::sink(type = "output", split = FALSE)
[16:09:37.581]         if (TRUE) {
[16:09:37.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.581]         }
[16:09:37.581]         else {
[16:09:37.581]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.581]         }
[16:09:37.581]         base::close(...future.stdout)
[16:09:37.581]         ...future.stdout <- NULL
[16:09:37.581]     }
[16:09:37.581]     ...future.result$conditions <- ...future.conditions
[16:09:37.581]     ...future.result$finished <- base::Sys.time()
[16:09:37.581]     ...future.result
[16:09:37.581] }
[16:09:37.584] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:09:37.584] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:09:37.584] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:09:37.585] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:37.585] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.585] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:09:37.586] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:09:37.586] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:37.586] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.586] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:37.587] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:37.587] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:09:37.587] MultisessionFuture started
[16:09:37.587] - Launch lazy future ... done
[16:09:37.588] run() for ‘MultisessionFuture’ ... done
[16:09:37.588] Created future:
[16:09:37.588] MultisessionFuture:
[16:09:37.588] Label: ‘future_eapply-1’
[16:09:37.588] Expression:
[16:09:37.588] {
[16:09:37.588]     do.call(function(...) {
[16:09:37.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.588]             on.exit(options(oopts), add = TRUE)
[16:09:37.588]         }
[16:09:37.588]         {
[16:09:37.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.588]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.588]             })
[16:09:37.588]         }
[16:09:37.588]     }, args = future.call.arguments)
[16:09:37.588] }
[16:09:37.588] Lazy evaluation: FALSE
[16:09:37.588] Asynchronous evaluation: TRUE
[16:09:37.588] Local evaluation: TRUE
[16:09:37.588] Environment: R_GlobalEnv
[16:09:37.588] Capture standard output: TRUE
[16:09:37.588] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.588] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.588] Packages: 1 packages (‘stats’)
[16:09:37.588] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.588] Resolved: FALSE
[16:09:37.588] Value: <not collected>
[16:09:37.588] Conditions captured: <none>
[16:09:37.588] Early signaling: FALSE
[16:09:37.588] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.588] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.599] Chunk #1 of 2 ... DONE
[16:09:37.599] Chunk #2 of 2 ...
[16:09:37.600]  - Finding globals in 'X' for chunk #2 ...
[16:09:37.600] getGlobalsAndPackages() ...
[16:09:37.600] Searching for globals...
[16:09:37.600] 
[16:09:37.600] Searching for globals ... DONE
[16:09:37.600] - globals: [0] <none>
[16:09:37.600] getGlobalsAndPackages() ... DONE
[16:09:37.601]    + additional globals found: [n=0] 
[16:09:37.601]    + additional namespaces needed: [n=0] 
[16:09:37.601]  - Finding globals in 'X' for chunk #2 ... DONE
[16:09:37.601]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:09:37.601]  - seeds: <none>
[16:09:37.601] getGlobalsAndPackages() ...
[16:09:37.601] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.601] Resolving globals: FALSE
[16:09:37.601] Tweak future expression to call with '...' arguments ...
[16:09:37.601] {
[16:09:37.601]     do.call(function(...) {
[16:09:37.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.601]             on.exit(options(oopts), add = TRUE)
[16:09:37.601]         }
[16:09:37.601]         {
[16:09:37.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.601]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.601]             })
[16:09:37.601]         }
[16:09:37.601]     }, args = future.call.arguments)
[16:09:37.601] }
[16:09:37.602] Tweak future expression to call with '...' arguments ... DONE
[16:09:37.602] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:37.602] - packages: [1] ‘stats’
[16:09:37.602] getGlobalsAndPackages() ... DONE
[16:09:37.603] run() for ‘Future’ ...
[16:09:37.603] - state: ‘created’
[16:09:37.603] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:37.619] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:37.619]   - Field: ‘node’
[16:09:37.619]   - Field: ‘label’
[16:09:37.619]   - Field: ‘local’
[16:09:37.619]   - Field: ‘owner’
[16:09:37.620]   - Field: ‘envir’
[16:09:37.620]   - Field: ‘workers’
[16:09:37.620]   - Field: ‘packages’
[16:09:37.620]   - Field: ‘gc’
[16:09:37.620]   - Field: ‘conditions’
[16:09:37.620]   - Field: ‘persistent’
[16:09:37.620]   - Field: ‘expr’
[16:09:37.620]   - Field: ‘uuid’
[16:09:37.620]   - Field: ‘seed’
[16:09:37.620]   - Field: ‘version’
[16:09:37.621]   - Field: ‘result’
[16:09:37.621]   - Field: ‘asynchronous’
[16:09:37.621]   - Field: ‘calls’
[16:09:37.621]   - Field: ‘globals’
[16:09:37.621]   - Field: ‘stdout’
[16:09:37.621]   - Field: ‘earlySignal’
[16:09:37.621]   - Field: ‘lazy’
[16:09:37.621]   - Field: ‘state’
[16:09:37.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:37.621] - Launch lazy future ...
[16:09:37.622] Packages needed by the future expression (n = 1): ‘stats’
[16:09:37.622] Packages needed by future strategies (n = 0): <none>
[16:09:37.622] {
[16:09:37.622]     {
[16:09:37.622]         {
[16:09:37.622]             ...future.startTime <- base::Sys.time()
[16:09:37.622]             {
[16:09:37.622]                 {
[16:09:37.622]                   {
[16:09:37.622]                     {
[16:09:37.622]                       {
[16:09:37.622]                         base::local({
[16:09:37.622]                           has_future <- base::requireNamespace("future", 
[16:09:37.622]                             quietly = TRUE)
[16:09:37.622]                           if (has_future) {
[16:09:37.622]                             ns <- base::getNamespace("future")
[16:09:37.622]                             version <- ns[[".package"]][["version"]]
[16:09:37.622]                             if (is.null(version)) 
[16:09:37.622]                               version <- utils::packageVersion("future")
[16:09:37.622]                           }
[16:09:37.622]                           else {
[16:09:37.622]                             version <- NULL
[16:09:37.622]                           }
[16:09:37.622]                           if (!has_future || version < "1.8.0") {
[16:09:37.622]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:37.622]                               "", base::R.version$version.string), 
[16:09:37.622]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:37.622]                                 base::R.version$platform, 8 * 
[16:09:37.622]                                   base::.Machine$sizeof.pointer), 
[16:09:37.622]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:37.622]                                 "release", "version")], collapse = " "), 
[16:09:37.622]                               hostname = base::Sys.info()[["nodename"]])
[16:09:37.622]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:37.622]                               info)
[16:09:37.622]                             info <- base::paste(info, collapse = "; ")
[16:09:37.622]                             if (!has_future) {
[16:09:37.622]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:37.622]                                 info)
[16:09:37.622]                             }
[16:09:37.622]                             else {
[16:09:37.622]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:37.622]                                 info, version)
[16:09:37.622]                             }
[16:09:37.622]                             base::stop(msg)
[16:09:37.622]                           }
[16:09:37.622]                         })
[16:09:37.622]                       }
[16:09:37.622]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:37.622]                       base::options(mc.cores = 1L)
[16:09:37.622]                     }
[16:09:37.622]                     base::local({
[16:09:37.622]                       for (pkg in "stats") {
[16:09:37.622]                         base::loadNamespace(pkg)
[16:09:37.622]                         base::library(pkg, character.only = TRUE)
[16:09:37.622]                       }
[16:09:37.622]                     })
[16:09:37.622]                   }
[16:09:37.622]                   options(future.plan = NULL)
[16:09:37.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:37.622]                 }
[16:09:37.622]                 ...future.workdir <- getwd()
[16:09:37.622]             }
[16:09:37.622]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:37.622]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:37.622]         }
[16:09:37.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:37.622]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:09:37.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:37.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:37.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:37.622]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:37.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:37.622]             base::names(...future.oldOptions))
[16:09:37.622]     }
[16:09:37.622]     if (FALSE) {
[16:09:37.622]     }
[16:09:37.622]     else {
[16:09:37.622]         if (TRUE) {
[16:09:37.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:37.622]                 open = "w")
[16:09:37.622]         }
[16:09:37.622]         else {
[16:09:37.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:37.622]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:37.622]         }
[16:09:37.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:37.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:37.622]             base::sink(type = "output", split = FALSE)
[16:09:37.622]             base::close(...future.stdout)
[16:09:37.622]         }, add = TRUE)
[16:09:37.622]     }
[16:09:37.622]     ...future.frame <- base::sys.nframe()
[16:09:37.622]     ...future.conditions <- base::list()
[16:09:37.622]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:37.622]     if (FALSE) {
[16:09:37.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:37.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:37.622]     }
[16:09:37.622]     ...future.result <- base::tryCatch({
[16:09:37.622]         base::withCallingHandlers({
[16:09:37.622]             ...future.value <- base::withVisible(base::local({
[16:09:37.622]                 ...future.makeSendCondition <- local({
[16:09:37.622]                   sendCondition <- NULL
[16:09:37.622]                   function(frame = 1L) {
[16:09:37.622]                     if (is.function(sendCondition)) 
[16:09:37.622]                       return(sendCondition)
[16:09:37.622]                     ns <- getNamespace("parallel")
[16:09:37.622]                     if (exists("sendData", mode = "function", 
[16:09:37.622]                       envir = ns)) {
[16:09:37.622]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:37.622]                         envir = ns)
[16:09:37.622]                       envir <- sys.frame(frame)
[16:09:37.622]                       master <- NULL
[16:09:37.622]                       while (!identical(envir, .GlobalEnv) && 
[16:09:37.622]                         !identical(envir, emptyenv())) {
[16:09:37.622]                         if (exists("master", mode = "list", envir = envir, 
[16:09:37.622]                           inherits = FALSE)) {
[16:09:37.622]                           master <- get("master", mode = "list", 
[16:09:37.622]                             envir = envir, inherits = FALSE)
[16:09:37.622]                           if (inherits(master, c("SOCKnode", 
[16:09:37.622]                             "SOCK0node"))) {
[16:09:37.622]                             sendCondition <<- function(cond) {
[16:09:37.622]                               data <- list(type = "VALUE", value = cond, 
[16:09:37.622]                                 success = TRUE)
[16:09:37.622]                               parallel_sendData(master, data)
[16:09:37.622]                             }
[16:09:37.622]                             return(sendCondition)
[16:09:37.622]                           }
[16:09:37.622]                         }
[16:09:37.622]                         frame <- frame + 1L
[16:09:37.622]                         envir <- sys.frame(frame)
[16:09:37.622]                       }
[16:09:37.622]                     }
[16:09:37.622]                     sendCondition <<- function(cond) NULL
[16:09:37.622]                   }
[16:09:37.622]                 })
[16:09:37.622]                 withCallingHandlers({
[16:09:37.622]                   {
[16:09:37.622]                     do.call(function(...) {
[16:09:37.622]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.622]                       if (!identical(...future.globals.maxSize.org, 
[16:09:37.622]                         ...future.globals.maxSize)) {
[16:09:37.622]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.622]                         on.exit(options(oopts), add = TRUE)
[16:09:37.622]                       }
[16:09:37.622]                       {
[16:09:37.622]                         lapply(seq_along(...future.elements_ii), 
[16:09:37.622]                           FUN = function(jj) {
[16:09:37.622]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.622]                             ...future.FUN(...future.X_jj, ...)
[16:09:37.622]                           })
[16:09:37.622]                       }
[16:09:37.622]                     }, args = future.call.arguments)
[16:09:37.622]                   }
[16:09:37.622]                 }, immediateCondition = function(cond) {
[16:09:37.622]                   sendCondition <- ...future.makeSendCondition()
[16:09:37.622]                   sendCondition(cond)
[16:09:37.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.622]                   {
[16:09:37.622]                     inherits <- base::inherits
[16:09:37.622]                     invokeRestart <- base::invokeRestart
[16:09:37.622]                     is.null <- base::is.null
[16:09:37.622]                     muffled <- FALSE
[16:09:37.622]                     if (inherits(cond, "message")) {
[16:09:37.622]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:37.622]                       if (muffled) 
[16:09:37.622]                         invokeRestart("muffleMessage")
[16:09:37.622]                     }
[16:09:37.622]                     else if (inherits(cond, "warning")) {
[16:09:37.622]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:37.622]                       if (muffled) 
[16:09:37.622]                         invokeRestart("muffleWarning")
[16:09:37.622]                     }
[16:09:37.622]                     else if (inherits(cond, "condition")) {
[16:09:37.622]                       if (!is.null(pattern)) {
[16:09:37.622]                         computeRestarts <- base::computeRestarts
[16:09:37.622]                         grepl <- base::grepl
[16:09:37.622]                         restarts <- computeRestarts(cond)
[16:09:37.622]                         for (restart in restarts) {
[16:09:37.622]                           name <- restart$name
[16:09:37.622]                           if (is.null(name)) 
[16:09:37.622]                             next
[16:09:37.622]                           if (!grepl(pattern, name)) 
[16:09:37.622]                             next
[16:09:37.622]                           invokeRestart(restart)
[16:09:37.622]                           muffled <- TRUE
[16:09:37.622]                           break
[16:09:37.622]                         }
[16:09:37.622]                       }
[16:09:37.622]                     }
[16:09:37.622]                     invisible(muffled)
[16:09:37.622]                   }
[16:09:37.622]                   muffleCondition(cond)
[16:09:37.622]                 })
[16:09:37.622]             }))
[16:09:37.622]             future::FutureResult(value = ...future.value$value, 
[16:09:37.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.622]                   ...future.rng), globalenv = if (FALSE) 
[16:09:37.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:37.622]                     ...future.globalenv.names))
[16:09:37.622]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:37.622]         }, condition = base::local({
[16:09:37.622]             c <- base::c
[16:09:37.622]             inherits <- base::inherits
[16:09:37.622]             invokeRestart <- base::invokeRestart
[16:09:37.622]             length <- base::length
[16:09:37.622]             list <- base::list
[16:09:37.622]             seq.int <- base::seq.int
[16:09:37.622]             signalCondition <- base::signalCondition
[16:09:37.622]             sys.calls <- base::sys.calls
[16:09:37.622]             `[[` <- base::`[[`
[16:09:37.622]             `+` <- base::`+`
[16:09:37.622]             `<<-` <- base::`<<-`
[16:09:37.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:37.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:37.622]                   3L)]
[16:09:37.622]             }
[16:09:37.622]             function(cond) {
[16:09:37.622]                 is_error <- inherits(cond, "error")
[16:09:37.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:37.622]                   NULL)
[16:09:37.622]                 if (is_error) {
[16:09:37.622]                   sessionInformation <- function() {
[16:09:37.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:37.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:37.622]                       search = base::search(), system = base::Sys.info())
[16:09:37.622]                   }
[16:09:37.622]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:37.622]                     cond$call), session = sessionInformation(), 
[16:09:37.622]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:37.622]                   signalCondition(cond)
[16:09:37.622]                 }
[16:09:37.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:37.622]                 "immediateCondition"))) {
[16:09:37.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:37.622]                   ...future.conditions[[length(...future.conditions) + 
[16:09:37.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:37.622]                   if (TRUE && !signal) {
[16:09:37.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.622]                     {
[16:09:37.622]                       inherits <- base::inherits
[16:09:37.622]                       invokeRestart <- base::invokeRestart
[16:09:37.622]                       is.null <- base::is.null
[16:09:37.622]                       muffled <- FALSE
[16:09:37.622]                       if (inherits(cond, "message")) {
[16:09:37.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.622]                         if (muffled) 
[16:09:37.622]                           invokeRestart("muffleMessage")
[16:09:37.622]                       }
[16:09:37.622]                       else if (inherits(cond, "warning")) {
[16:09:37.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.622]                         if (muffled) 
[16:09:37.622]                           invokeRestart("muffleWarning")
[16:09:37.622]                       }
[16:09:37.622]                       else if (inherits(cond, "condition")) {
[16:09:37.622]                         if (!is.null(pattern)) {
[16:09:37.622]                           computeRestarts <- base::computeRestarts
[16:09:37.622]                           grepl <- base::grepl
[16:09:37.622]                           restarts <- computeRestarts(cond)
[16:09:37.622]                           for (restart in restarts) {
[16:09:37.622]                             name <- restart$name
[16:09:37.622]                             if (is.null(name)) 
[16:09:37.622]                               next
[16:09:37.622]                             if (!grepl(pattern, name)) 
[16:09:37.622]                               next
[16:09:37.622]                             invokeRestart(restart)
[16:09:37.622]                             muffled <- TRUE
[16:09:37.622]                             break
[16:09:37.622]                           }
[16:09:37.622]                         }
[16:09:37.622]                       }
[16:09:37.622]                       invisible(muffled)
[16:09:37.622]                     }
[16:09:37.622]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.622]                   }
[16:09:37.622]                 }
[16:09:37.622]                 else {
[16:09:37.622]                   if (TRUE) {
[16:09:37.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:37.622]                     {
[16:09:37.622]                       inherits <- base::inherits
[16:09:37.622]                       invokeRestart <- base::invokeRestart
[16:09:37.622]                       is.null <- base::is.null
[16:09:37.622]                       muffled <- FALSE
[16:09:37.622]                       if (inherits(cond, "message")) {
[16:09:37.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:37.622]                         if (muffled) 
[16:09:37.622]                           invokeRestart("muffleMessage")
[16:09:37.622]                       }
[16:09:37.622]                       else if (inherits(cond, "warning")) {
[16:09:37.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:37.622]                         if (muffled) 
[16:09:37.622]                           invokeRestart("muffleWarning")
[16:09:37.622]                       }
[16:09:37.622]                       else if (inherits(cond, "condition")) {
[16:09:37.622]                         if (!is.null(pattern)) {
[16:09:37.622]                           computeRestarts <- base::computeRestarts
[16:09:37.622]                           grepl <- base::grepl
[16:09:37.622]                           restarts <- computeRestarts(cond)
[16:09:37.622]                           for (restart in restarts) {
[16:09:37.622]                             name <- restart$name
[16:09:37.622]                             if (is.null(name)) 
[16:09:37.622]                               next
[16:09:37.622]                             if (!grepl(pattern, name)) 
[16:09:37.622]                               next
[16:09:37.622]                             invokeRestart(restart)
[16:09:37.622]                             muffled <- TRUE
[16:09:37.622]                             break
[16:09:37.622]                           }
[16:09:37.622]                         }
[16:09:37.622]                       }
[16:09:37.622]                       invisible(muffled)
[16:09:37.622]                     }
[16:09:37.622]                     muffleCondition(cond, pattern = "^muffle")
[16:09:37.622]                   }
[16:09:37.622]                 }
[16:09:37.622]             }
[16:09:37.622]         }))
[16:09:37.622]     }, error = function(ex) {
[16:09:37.622]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:37.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:37.622]                 ...future.rng), started = ...future.startTime, 
[16:09:37.622]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:37.622]             version = "1.8"), class = "FutureResult")
[16:09:37.622]     }, finally = {
[16:09:37.622]         if (!identical(...future.workdir, getwd())) 
[16:09:37.622]             setwd(...future.workdir)
[16:09:37.622]         {
[16:09:37.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:37.622]                 ...future.oldOptions$nwarnings <- NULL
[16:09:37.622]             }
[16:09:37.622]             base::options(...future.oldOptions)
[16:09:37.622]             if (.Platform$OS.type == "windows") {
[16:09:37.622]                 old_names <- names(...future.oldEnvVars)
[16:09:37.622]                 envs <- base::Sys.getenv()
[16:09:37.622]                 names <- names(envs)
[16:09:37.622]                 common <- intersect(names, old_names)
[16:09:37.622]                 added <- setdiff(names, old_names)
[16:09:37.622]                 removed <- setdiff(old_names, names)
[16:09:37.622]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:37.622]                   envs[common]]
[16:09:37.622]                 NAMES <- toupper(changed)
[16:09:37.622]                 args <- list()
[16:09:37.622]                 for (kk in seq_along(NAMES)) {
[16:09:37.622]                   name <- changed[[kk]]
[16:09:37.622]                   NAME <- NAMES[[kk]]
[16:09:37.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.622]                     next
[16:09:37.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.622]                 }
[16:09:37.622]                 NAMES <- toupper(added)
[16:09:37.622]                 for (kk in seq_along(NAMES)) {
[16:09:37.622]                   name <- added[[kk]]
[16:09:37.622]                   NAME <- NAMES[[kk]]
[16:09:37.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.622]                     next
[16:09:37.622]                   args[[name]] <- ""
[16:09:37.622]                 }
[16:09:37.622]                 NAMES <- toupper(removed)
[16:09:37.622]                 for (kk in seq_along(NAMES)) {
[16:09:37.622]                   name <- removed[[kk]]
[16:09:37.622]                   NAME <- NAMES[[kk]]
[16:09:37.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:37.622]                     next
[16:09:37.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:37.622]                 }
[16:09:37.622]                 if (length(args) > 0) 
[16:09:37.622]                   base::do.call(base::Sys.setenv, args = args)
[16:09:37.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:37.622]             }
[16:09:37.622]             else {
[16:09:37.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:37.622]             }
[16:09:37.622]             {
[16:09:37.622]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:37.622]                   0L) {
[16:09:37.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:37.622]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:37.622]                   base::options(opts)
[16:09:37.622]                 }
[16:09:37.622]                 {
[16:09:37.622]                   {
[16:09:37.622]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:37.622]                     NULL
[16:09:37.622]                   }
[16:09:37.622]                   options(future.plan = NULL)
[16:09:37.622]                   if (is.na(NA_character_)) 
[16:09:37.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:37.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:37.622]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:37.622]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:37.622]                     envir = parent.frame()) 
[16:09:37.622]                   {
[16:09:37.622]                     if (is.function(workers)) 
[16:09:37.622]                       workers <- workers()
[16:09:37.622]                     workers <- structure(as.integer(workers), 
[16:09:37.622]                       class = class(workers))
[16:09:37.622]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:37.622]                       workers >= 1)
[16:09:37.622]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:37.622]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:37.622]                     }
[16:09:37.622]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:37.622]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:37.622]                       envir = envir)
[16:09:37.622]                     if (!future$lazy) 
[16:09:37.622]                       future <- run(future)
[16:09:37.622]                     invisible(future)
[16:09:37.622]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:37.622]                 }
[16:09:37.622]             }
[16:09:37.622]         }
[16:09:37.622]     })
[16:09:37.622]     if (TRUE) {
[16:09:37.622]         base::sink(type = "output", split = FALSE)
[16:09:37.622]         if (TRUE) {
[16:09:37.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:37.622]         }
[16:09:37.622]         else {
[16:09:37.622]             ...future.result["stdout"] <- base::list(NULL)
[16:09:37.622]         }
[16:09:37.622]         base::close(...future.stdout)
[16:09:37.622]         ...future.stdout <- NULL
[16:09:37.622]     }
[16:09:37.622]     ...future.result$conditions <- ...future.conditions
[16:09:37.622]     ...future.result$finished <- base::Sys.time()
[16:09:37.622]     ...future.result
[16:09:37.622] }
[16:09:37.625] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:09:37.625] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:09:37.626] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:09:37.626] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:37.626] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.626] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:09:37.627] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:09:37.627] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:37.627] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.627] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:37.628] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:37.628] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:09:37.628] MultisessionFuture started
[16:09:37.629] - Launch lazy future ... done
[16:09:37.629] run() for ‘MultisessionFuture’ ... done
[16:09:37.629] Created future:
[16:09:37.629] MultisessionFuture:
[16:09:37.629] Label: ‘future_eapply-2’
[16:09:37.629] Expression:
[16:09:37.629] {
[16:09:37.629]     do.call(function(...) {
[16:09:37.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:37.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:37.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:37.629]             on.exit(options(oopts), add = TRUE)
[16:09:37.629]         }
[16:09:37.629]         {
[16:09:37.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:37.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:37.629]                 ...future.FUN(...future.X_jj, ...)
[16:09:37.629]             })
[16:09:37.629]         }
[16:09:37.629]     }, args = future.call.arguments)
[16:09:37.629] }
[16:09:37.629] Lazy evaluation: FALSE
[16:09:37.629] Asynchronous evaluation: TRUE
[16:09:37.629] Local evaluation: TRUE
[16:09:37.629] Environment: R_GlobalEnv
[16:09:37.629] Capture standard output: TRUE
[16:09:37.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:37.629] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:37.629] Packages: 1 packages (‘stats’)
[16:09:37.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:37.629] Resolved: FALSE
[16:09:37.629] Value: <not collected>
[16:09:37.629] Conditions captured: <none>
[16:09:37.629] Early signaling: FALSE
[16:09:37.629] Owner process: 16886279-0eca-0b89-568b-754e9085561b
[16:09:37.629] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:37.641] Chunk #2 of 2 ... DONE
[16:09:37.641] Launching 2 futures (chunks) ... DONE
[16:09:37.641] Resolving 2 futures (chunks) ...
[16:09:37.641] resolve() on list ...
[16:09:37.641]  recursive: 0
[16:09:37.641]  length: 2
[16:09:37.641] 
[16:09:37.642] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.642] - Validating connection of MultisessionFuture
[16:09:37.642] - received message: FutureResult
[16:09:37.642] - Received FutureResult
[16:09:37.642] - Erased future from FutureRegistry
[16:09:37.642] result() for ClusterFuture ...
[16:09:37.642] - result already collected: FutureResult
[16:09:37.642] result() for ClusterFuture ... done
[16:09:37.643] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.643] Future #1
[16:09:37.643] result() for ClusterFuture ...
[16:09:37.643] - result already collected: FutureResult
[16:09:37.643] result() for ClusterFuture ... done
[16:09:37.643] result() for ClusterFuture ...
[16:09:37.643] - result already collected: FutureResult
[16:09:37.643] result() for ClusterFuture ... done
[16:09:37.643] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:37.643] - nx: 2
[16:09:37.643] - relay: TRUE
[16:09:37.643] - stdout: TRUE
[16:09:37.644] - signal: TRUE
[16:09:37.644] - resignal: FALSE
[16:09:37.644] - force: TRUE
[16:09:37.644] - relayed: [n=2] FALSE, FALSE
[16:09:37.644] - queued futures: [n=2] FALSE, FALSE
[16:09:37.644]  - until=1
[16:09:37.644]  - relaying element #1
[16:09:37.644] result() for ClusterFuture ...
[16:09:37.644] - result already collected: FutureResult
[16:09:37.644] result() for ClusterFuture ... done
[16:09:37.644] result() for ClusterFuture ...
[16:09:37.645] - result already collected: FutureResult
[16:09:37.645] result() for ClusterFuture ... done
[16:09:37.645] result() for ClusterFuture ...
[16:09:37.645] - result already collected: FutureResult
[16:09:37.645] result() for ClusterFuture ... done
[16:09:37.645] result() for ClusterFuture ...
[16:09:37.645] - result already collected: FutureResult
[16:09:37.645] result() for ClusterFuture ... done
[16:09:37.645] - relayed: [n=2] TRUE, FALSE
[16:09:37.645] - queued futures: [n=2] TRUE, FALSE
[16:09:37.645] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:37.646]  length: 1 (resolved future 1)
[16:09:37.687] receiveMessageFromWorker() for ClusterFuture ...
[16:09:37.687] - Validating connection of MultisessionFuture
[16:09:37.688] - received message: FutureResult
[16:09:37.688] - Received FutureResult
[16:09:37.688] - Erased future from FutureRegistry
[16:09:37.688] result() for ClusterFuture ...
[16:09:37.688] - result already collected: FutureResult
[16:09:37.688] result() for ClusterFuture ... done
[16:09:37.688] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:37.688] Future #2
[16:09:37.689] result() for ClusterFuture ...
[16:09:37.689] - result already collected: FutureResult
[16:09:37.689] result() for ClusterFuture ... done
[16:09:37.689] result() for ClusterFuture ...
[16:09:37.689] - result already collected: FutureResult
[16:09:37.689] result() for ClusterFuture ... done
[16:09:37.689] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:37.689] - nx: 2
[16:09:37.689] - relay: TRUE
[16:09:37.689] - stdout: TRUE
[16:09:37.689] - signal: TRUE
[16:09:37.689] - resignal: FALSE
[16:09:37.690] - force: TRUE
[16:09:37.690] - relayed: [n=2] TRUE, FALSE
[16:09:37.690] - queued futures: [n=2] TRUE, FALSE
[16:09:37.690]  - until=2
[16:09:37.690]  - relaying element #2
[16:09:37.690] result() for ClusterFuture ...
[16:09:37.690] - result already collected: FutureResult
[16:09:37.690] result() for ClusterFuture ... done
[16:09:37.690] result() for ClusterFuture ...
[16:09:37.690] - result already collected: FutureResult
[16:09:37.690] result() for ClusterFuture ... done
[16:09:37.691] result() for ClusterFuture ...
[16:09:37.691] - result already collected: FutureResult
[16:09:37.691] result() for ClusterFuture ... done
[16:09:37.691] result() for ClusterFuture ...
[16:09:37.691] - result already collected: FutureResult
[16:09:37.691] result() for ClusterFuture ... done
[16:09:37.691] - relayed: [n=2] TRUE, TRUE
[16:09:37.691] - queued futures: [n=2] TRUE, TRUE
[16:09:37.691] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:37.691]  length: 0 (resolved future 2)
[16:09:37.691] Relaying remaining futures
[16:09:37.692] signalConditionsASAP(NULL, pos=0) ...
[16:09:37.692] - nx: 2
[16:09:37.692] - relay: TRUE
[16:09:37.692] - stdout: TRUE
[16:09:37.692] - signal: TRUE
[16:09:37.692] - resignal: FALSE
[16:09:37.692] - force: TRUE
[16:09:37.692] - relayed: [n=2] TRUE, TRUE
[16:09:37.692] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:37.692] - relayed: [n=2] TRUE, TRUE
[16:09:37.693] - queued futures: [n=2] TRUE, TRUE
[16:09:37.693] signalConditionsASAP(NULL, pos=0) ... done
[16:09:37.693] resolve() on list ... DONE
[16:09:37.693] result() for ClusterFuture ...
[16:09:37.693] - result already collected: FutureResult
[16:09:37.693] result() for ClusterFuture ... done
[16:09:37.693] result() for ClusterFuture ...
[16:09:37.693] - result already collected: FutureResult
[16:09:37.693] result() for ClusterFuture ... done
[16:09:37.693] result() for ClusterFuture ...
[16:09:37.693] - result already collected: FutureResult
[16:09:37.694] result() for ClusterFuture ... done
[16:09:37.694] result() for ClusterFuture ...
[16:09:37.694] - result already collected: FutureResult
[16:09:37.694] result() for ClusterFuture ... done
[16:09:37.694]  - Number of value chunks collected: 2
[16:09:37.694] Resolving 2 futures (chunks) ... DONE
[16:09:37.694] Reducing values from 2 chunks ...
[16:09:37.694]  - Number of values collected after concatenation: 3
[16:09:37.694]  - Number of values expected: 3
[16:09:37.694] Reducing values from 2 chunks ... DONE
[16:09:37.694] future_lapply() ... DONE
[16:09:37.695] plan(): Setting new future strategy stack:
[16:09:37.695] List of future strategies:
[16:09:37.695] 1. sequential:
[16:09:37.695]    - args: function (..., envir = parent.frame())
[16:09:37.695]    - tweaked: FALSE
[16:09:37.695]    - call: plan(sequential)
[16:09:37.696] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[16:09:37.697] plan(): Setting new future strategy stack:
[16:09:37.697] List of future strategies:
[16:09:37.697] 1. FutureStrategy:
[16:09:37.697]    - args: function (..., envir = parent.frame())
[16:09:37.697]    - tweaked: FALSE
[16:09:37.697]    - call: future::plan(oplan)
[16:09:37.697] plan(): nbrOfWorkers() = 1
> 
