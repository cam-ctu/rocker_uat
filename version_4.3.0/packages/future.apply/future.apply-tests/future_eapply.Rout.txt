
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:39:28.706] plan(): Setting new future strategy stack:
[17:39:28.707] List of future strategies:
[17:39:28.707] 1. sequential:
[17:39:28.707]    - args: function (..., envir = parent.frame())
[17:39:28.707]    - tweaked: FALSE
[17:39:28.707]    - call: future::plan("sequential")
[17:39:28.717] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:39:28.742] plan(): Setting new future strategy stack:
[17:39:28.742] List of future strategies:
[17:39:28.742] 1. sequential:
[17:39:28.742]    - args: function (..., envir = parent.frame())
[17:39:28.742]    - tweaked: FALSE
[17:39:28.742]    - call: plan(strategy)
[17:39:28.753] plan(): nbrOfWorkers() = 1
[17:39:28.753] future_lapply() ...
[17:39:28.758] Number of chunks: 1
[17:39:28.758] getGlobalsAndPackagesXApply() ...
[17:39:28.758]  - future.globals: TRUE
[17:39:28.759] getGlobalsAndPackages() ...
[17:39:28.759] Searching for globals...
[17:39:28.761] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.762] Searching for globals ... DONE
[17:39:28.762] Resolving globals: FALSE
[17:39:28.763] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:28.763] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:28.763] - globals: [1] ‘FUN’
[17:39:28.763] 
[17:39:28.764] getGlobalsAndPackages() ... DONE
[17:39:28.764]  - globals found/used: [n=1] ‘FUN’
[17:39:28.764]  - needed namespaces: [n=0] 
[17:39:28.764] Finding globals ... DONE
[17:39:28.764]  - use_args: TRUE
[17:39:28.764]  - Getting '...' globals ...
[17:39:28.765] resolve() on list ...
[17:39:28.765]  recursive: 0
[17:39:28.765]  length: 1
[17:39:28.765]  elements: ‘...’
[17:39:28.765]  length: 0 (resolved future 1)
[17:39:28.766] resolve() on list ... DONE
[17:39:28.766]    - '...' content: [n=0] 
[17:39:28.766] List of 1
[17:39:28.766]  $ ...: list()
[17:39:28.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.766]  - attr(*, "where")=List of 1
[17:39:28.766]   ..$ ...:<environment: 0x555b659c46e8> 
[17:39:28.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.766]  - attr(*, "resolved")= logi TRUE
[17:39:28.766]  - attr(*, "total_size")= num NA
[17:39:28.771]  - Getting '...' globals ... DONE
[17:39:28.771] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.771] List of 2
[17:39:28.771]  $ ...future.FUN:function (x, ...)  
[17:39:28.771]  $ ...          : list()
[17:39:28.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.771]  - attr(*, "where")=List of 2
[17:39:28.771]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.771]   ..$ ...          :<environment: 0x555b659c46e8> 
[17:39:28.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.771]  - attr(*, "resolved")= logi FALSE
[17:39:28.771]  - attr(*, "total_size")= num 1240
[17:39:28.777] Packages to be attached in all futures: [n=0] 
[17:39:28.777] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.777] Number of futures (= number of chunks): 1
[17:39:28.777] Launching 1 futures (chunks) ...
[17:39:28.777] Chunk #1 of 1 ...
[17:39:28.778]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.778] getGlobalsAndPackages() ...
[17:39:28.778] Searching for globals...
[17:39:28.778] 
[17:39:28.778] Searching for globals ... DONE
[17:39:28.778] - globals: [0] <none>
[17:39:28.778] getGlobalsAndPackages() ... DONE
[17:39:28.779]    + additional globals found: [n=0] 
[17:39:28.779]    + additional namespaces needed: [n=0] 
[17:39:28.779]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.779]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:28.779]  - seeds: <none>
[17:39:28.779] getGlobalsAndPackages() ...
[17:39:28.779] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.780] Resolving globals: FALSE
[17:39:28.780] Tweak future expression to call with '...' arguments ...
[17:39:28.780] {
[17:39:28.780]     do.call(function(...) {
[17:39:28.780]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.780]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.780]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.780]             on.exit(options(oopts), add = TRUE)
[17:39:28.780]         }
[17:39:28.780]         {
[17:39:28.780]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.780]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.780]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.780]             })
[17:39:28.780]         }
[17:39:28.780]     }, args = future.call.arguments)
[17:39:28.780] }
[17:39:28.780] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.780] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.781] 
[17:39:28.781] getGlobalsAndPackages() ... DONE
[17:39:28.781] run() for ‘Future’ ...
[17:39:28.782] - state: ‘created’
[17:39:28.782] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:28.782] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.782] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:28.782]   - Field: ‘label’
[17:39:28.783]   - Field: ‘local’
[17:39:28.783]   - Field: ‘owner’
[17:39:28.783]   - Field: ‘envir’
[17:39:28.783]   - Field: ‘packages’
[17:39:28.783]   - Field: ‘gc’
[17:39:28.783]   - Field: ‘conditions’
[17:39:28.783]   - Field: ‘expr’
[17:39:28.783]   - Field: ‘uuid’
[17:39:28.783]   - Field: ‘seed’
[17:39:28.783]   - Field: ‘version’
[17:39:28.784]   - Field: ‘result’
[17:39:28.784]   - Field: ‘asynchronous’
[17:39:28.784]   - Field: ‘calls’
[17:39:28.784]   - Field: ‘globals’
[17:39:28.784]   - Field: ‘stdout’
[17:39:28.784]   - Field: ‘earlySignal’
[17:39:28.784]   - Field: ‘lazy’
[17:39:28.784]   - Field: ‘state’
[17:39:28.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:28.784] - Launch lazy future ...
[17:39:28.785] Packages needed by the future expression (n = 0): <none>
[17:39:28.785] Packages needed by future strategies (n = 0): <none>
[17:39:28.786] {
[17:39:28.786]     {
[17:39:28.786]         {
[17:39:28.786]             ...future.startTime <- base::Sys.time()
[17:39:28.786]             {
[17:39:28.786]                 {
[17:39:28.786]                   {
[17:39:28.786]                     base::local({
[17:39:28.786]                       has_future <- base::requireNamespace("future", 
[17:39:28.786]                         quietly = TRUE)
[17:39:28.786]                       if (has_future) {
[17:39:28.786]                         ns <- base::getNamespace("future")
[17:39:28.786]                         version <- ns[[".package"]][["version"]]
[17:39:28.786]                         if (is.null(version)) 
[17:39:28.786]                           version <- utils::packageVersion("future")
[17:39:28.786]                       }
[17:39:28.786]                       else {
[17:39:28.786]                         version <- NULL
[17:39:28.786]                       }
[17:39:28.786]                       if (!has_future || version < "1.8.0") {
[17:39:28.786]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.786]                           "", base::R.version$version.string), 
[17:39:28.786]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:28.786]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.786]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.786]                             "release", "version")], collapse = " "), 
[17:39:28.786]                           hostname = base::Sys.info()[["nodename"]])
[17:39:28.786]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.786]                           info)
[17:39:28.786]                         info <- base::paste(info, collapse = "; ")
[17:39:28.786]                         if (!has_future) {
[17:39:28.786]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.786]                             info)
[17:39:28.786]                         }
[17:39:28.786]                         else {
[17:39:28.786]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.786]                             info, version)
[17:39:28.786]                         }
[17:39:28.786]                         base::stop(msg)
[17:39:28.786]                       }
[17:39:28.786]                     })
[17:39:28.786]                   }
[17:39:28.786]                   options(future.plan = NULL)
[17:39:28.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.786]                 }
[17:39:28.786]                 ...future.workdir <- getwd()
[17:39:28.786]             }
[17:39:28.786]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.786]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.786]         }
[17:39:28.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.786]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:28.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.786]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.786]             base::names(...future.oldOptions))
[17:39:28.786]     }
[17:39:28.786]     if (FALSE) {
[17:39:28.786]     }
[17:39:28.786]     else {
[17:39:28.786]         if (TRUE) {
[17:39:28.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.786]                 open = "w")
[17:39:28.786]         }
[17:39:28.786]         else {
[17:39:28.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.786]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.786]         }
[17:39:28.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.786]             base::sink(type = "output", split = FALSE)
[17:39:28.786]             base::close(...future.stdout)
[17:39:28.786]         }, add = TRUE)
[17:39:28.786]     }
[17:39:28.786]     ...future.frame <- base::sys.nframe()
[17:39:28.786]     ...future.conditions <- base::list()
[17:39:28.786]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.786]     if (FALSE) {
[17:39:28.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.786]     }
[17:39:28.786]     ...future.result <- base::tryCatch({
[17:39:28.786]         base::withCallingHandlers({
[17:39:28.786]             ...future.value <- base::withVisible(base::local({
[17:39:28.786]                 do.call(function(...) {
[17:39:28.786]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.786]                   if (!identical(...future.globals.maxSize.org, 
[17:39:28.786]                     ...future.globals.maxSize)) {
[17:39:28.786]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.786]                     on.exit(options(oopts), add = TRUE)
[17:39:28.786]                   }
[17:39:28.786]                   {
[17:39:28.786]                     lapply(seq_along(...future.elements_ii), 
[17:39:28.786]                       FUN = function(jj) {
[17:39:28.786]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.786]                         ...future.FUN(...future.X_jj, ...)
[17:39:28.786]                       })
[17:39:28.786]                   }
[17:39:28.786]                 }, args = future.call.arguments)
[17:39:28.786]             }))
[17:39:28.786]             future::FutureResult(value = ...future.value$value, 
[17:39:28.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.786]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.786]                     ...future.globalenv.names))
[17:39:28.786]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.786]         }, condition = base::local({
[17:39:28.786]             c <- base::c
[17:39:28.786]             inherits <- base::inherits
[17:39:28.786]             invokeRestart <- base::invokeRestart
[17:39:28.786]             length <- base::length
[17:39:28.786]             list <- base::list
[17:39:28.786]             seq.int <- base::seq.int
[17:39:28.786]             signalCondition <- base::signalCondition
[17:39:28.786]             sys.calls <- base::sys.calls
[17:39:28.786]             `[[` <- base::`[[`
[17:39:28.786]             `+` <- base::`+`
[17:39:28.786]             `<<-` <- base::`<<-`
[17:39:28.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.786]                   3L)]
[17:39:28.786]             }
[17:39:28.786]             function(cond) {
[17:39:28.786]                 is_error <- inherits(cond, "error")
[17:39:28.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.786]                   NULL)
[17:39:28.786]                 if (is_error) {
[17:39:28.786]                   sessionInformation <- function() {
[17:39:28.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.786]                       search = base::search(), system = base::Sys.info())
[17:39:28.786]                   }
[17:39:28.786]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.786]                     cond$call), session = sessionInformation(), 
[17:39:28.786]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.786]                   signalCondition(cond)
[17:39:28.786]                 }
[17:39:28.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.786]                 "immediateCondition"))) {
[17:39:28.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.786]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.786]                   if (TRUE && !signal) {
[17:39:28.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.786]                     {
[17:39:28.786]                       inherits <- base::inherits
[17:39:28.786]                       invokeRestart <- base::invokeRestart
[17:39:28.786]                       is.null <- base::is.null
[17:39:28.786]                       muffled <- FALSE
[17:39:28.786]                       if (inherits(cond, "message")) {
[17:39:28.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.786]                         if (muffled) 
[17:39:28.786]                           invokeRestart("muffleMessage")
[17:39:28.786]                       }
[17:39:28.786]                       else if (inherits(cond, "warning")) {
[17:39:28.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.786]                         if (muffled) 
[17:39:28.786]                           invokeRestart("muffleWarning")
[17:39:28.786]                       }
[17:39:28.786]                       else if (inherits(cond, "condition")) {
[17:39:28.786]                         if (!is.null(pattern)) {
[17:39:28.786]                           computeRestarts <- base::computeRestarts
[17:39:28.786]                           grepl <- base::grepl
[17:39:28.786]                           restarts <- computeRestarts(cond)
[17:39:28.786]                           for (restart in restarts) {
[17:39:28.786]                             name <- restart$name
[17:39:28.786]                             if (is.null(name)) 
[17:39:28.786]                               next
[17:39:28.786]                             if (!grepl(pattern, name)) 
[17:39:28.786]                               next
[17:39:28.786]                             invokeRestart(restart)
[17:39:28.786]                             muffled <- TRUE
[17:39:28.786]                             break
[17:39:28.786]                           }
[17:39:28.786]                         }
[17:39:28.786]                       }
[17:39:28.786]                       invisible(muffled)
[17:39:28.786]                     }
[17:39:28.786]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.786]                   }
[17:39:28.786]                 }
[17:39:28.786]                 else {
[17:39:28.786]                   if (TRUE) {
[17:39:28.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.786]                     {
[17:39:28.786]                       inherits <- base::inherits
[17:39:28.786]                       invokeRestart <- base::invokeRestart
[17:39:28.786]                       is.null <- base::is.null
[17:39:28.786]                       muffled <- FALSE
[17:39:28.786]                       if (inherits(cond, "message")) {
[17:39:28.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.786]                         if (muffled) 
[17:39:28.786]                           invokeRestart("muffleMessage")
[17:39:28.786]                       }
[17:39:28.786]                       else if (inherits(cond, "warning")) {
[17:39:28.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.786]                         if (muffled) 
[17:39:28.786]                           invokeRestart("muffleWarning")
[17:39:28.786]                       }
[17:39:28.786]                       else if (inherits(cond, "condition")) {
[17:39:28.786]                         if (!is.null(pattern)) {
[17:39:28.786]                           computeRestarts <- base::computeRestarts
[17:39:28.786]                           grepl <- base::grepl
[17:39:28.786]                           restarts <- computeRestarts(cond)
[17:39:28.786]                           for (restart in restarts) {
[17:39:28.786]                             name <- restart$name
[17:39:28.786]                             if (is.null(name)) 
[17:39:28.786]                               next
[17:39:28.786]                             if (!grepl(pattern, name)) 
[17:39:28.786]                               next
[17:39:28.786]                             invokeRestart(restart)
[17:39:28.786]                             muffled <- TRUE
[17:39:28.786]                             break
[17:39:28.786]                           }
[17:39:28.786]                         }
[17:39:28.786]                       }
[17:39:28.786]                       invisible(muffled)
[17:39:28.786]                     }
[17:39:28.786]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.786]                   }
[17:39:28.786]                 }
[17:39:28.786]             }
[17:39:28.786]         }))
[17:39:28.786]     }, error = function(ex) {
[17:39:28.786]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.786]                 ...future.rng), started = ...future.startTime, 
[17:39:28.786]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.786]             version = "1.8"), class = "FutureResult")
[17:39:28.786]     }, finally = {
[17:39:28.786]         if (!identical(...future.workdir, getwd())) 
[17:39:28.786]             setwd(...future.workdir)
[17:39:28.786]         {
[17:39:28.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.786]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.786]             }
[17:39:28.786]             base::options(...future.oldOptions)
[17:39:28.786]             if (.Platform$OS.type == "windows") {
[17:39:28.786]                 old_names <- names(...future.oldEnvVars)
[17:39:28.786]                 envs <- base::Sys.getenv()
[17:39:28.786]                 names <- names(envs)
[17:39:28.786]                 common <- intersect(names, old_names)
[17:39:28.786]                 added <- setdiff(names, old_names)
[17:39:28.786]                 removed <- setdiff(old_names, names)
[17:39:28.786]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.786]                   envs[common]]
[17:39:28.786]                 NAMES <- toupper(changed)
[17:39:28.786]                 args <- list()
[17:39:28.786]                 for (kk in seq_along(NAMES)) {
[17:39:28.786]                   name <- changed[[kk]]
[17:39:28.786]                   NAME <- NAMES[[kk]]
[17:39:28.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.786]                     next
[17:39:28.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.786]                 }
[17:39:28.786]                 NAMES <- toupper(added)
[17:39:28.786]                 for (kk in seq_along(NAMES)) {
[17:39:28.786]                   name <- added[[kk]]
[17:39:28.786]                   NAME <- NAMES[[kk]]
[17:39:28.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.786]                     next
[17:39:28.786]                   args[[name]] <- ""
[17:39:28.786]                 }
[17:39:28.786]                 NAMES <- toupper(removed)
[17:39:28.786]                 for (kk in seq_along(NAMES)) {
[17:39:28.786]                   name <- removed[[kk]]
[17:39:28.786]                   NAME <- NAMES[[kk]]
[17:39:28.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.786]                     next
[17:39:28.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.786]                 }
[17:39:28.786]                 if (length(args) > 0) 
[17:39:28.786]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.786]             }
[17:39:28.786]             else {
[17:39:28.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.786]             }
[17:39:28.786]             {
[17:39:28.786]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.786]                   0L) {
[17:39:28.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.786]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.786]                   base::options(opts)
[17:39:28.786]                 }
[17:39:28.786]                 {
[17:39:28.786]                   {
[17:39:28.786]                     NULL
[17:39:28.786]                     RNGkind("Mersenne-Twister")
[17:39:28.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:28.786]                       inherits = FALSE)
[17:39:28.786]                   }
[17:39:28.786]                   options(future.plan = NULL)
[17:39:28.786]                   if (is.na(NA_character_)) 
[17:39:28.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.786]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:28.786]                   {
[17:39:28.786]                     future <- SequentialFuture(..., envir = envir)
[17:39:28.786]                     if (!future$lazy) 
[17:39:28.786]                       future <- run(future)
[17:39:28.786]                     invisible(future)
[17:39:28.786]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.786]                 }
[17:39:28.786]             }
[17:39:28.786]         }
[17:39:28.786]     })
[17:39:28.786]     if (TRUE) {
[17:39:28.786]         base::sink(type = "output", split = FALSE)
[17:39:28.786]         if (TRUE) {
[17:39:28.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.786]         }
[17:39:28.786]         else {
[17:39:28.786]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.786]         }
[17:39:28.786]         base::close(...future.stdout)
[17:39:28.786]         ...future.stdout <- NULL
[17:39:28.786]     }
[17:39:28.786]     ...future.result$conditions <- ...future.conditions
[17:39:28.786]     ...future.result$finished <- base::Sys.time()
[17:39:28.786]     ...future.result
[17:39:28.786] }
[17:39:28.788] assign_globals() ...
[17:39:28.788] List of 5
[17:39:28.788]  $ ...future.FUN            :function (x, ...)  
[17:39:28.788]  $ future.call.arguments    : list()
[17:39:28.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.788]  $ ...future.elements_ii    :List of 3
[17:39:28.788]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:39:28.788]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:28.788]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:28.788]  $ ...future.seeds_ii       : NULL
[17:39:28.788]  $ ...future.globals.maxSize: NULL
[17:39:28.788]  - attr(*, "resolved")= logi FALSE
[17:39:28.788]  - attr(*, "total_size")= num 1240
[17:39:28.788]  - attr(*, "where")=List of 5
[17:39:28.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:28.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:28.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:28.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:28.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:28.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.788]  - attr(*, "already-done")= logi TRUE
[17:39:28.794] - copied ‘...future.FUN’ to environment
[17:39:28.794] - copied ‘future.call.arguments’ to environment
[17:39:28.794] - copied ‘...future.elements_ii’ to environment
[17:39:28.794] - copied ‘...future.seeds_ii’ to environment
[17:39:28.794] - copied ‘...future.globals.maxSize’ to environment
[17:39:28.795] assign_globals() ... done
[17:39:28.795] plan(): Setting new future strategy stack:
[17:39:28.795] List of future strategies:
[17:39:28.795] 1. sequential:
[17:39:28.795]    - args: function (..., envir = parent.frame())
[17:39:28.795]    - tweaked: FALSE
[17:39:28.795]    - call: NULL
[17:39:28.795] plan(): nbrOfWorkers() = 1
[17:39:28.797] plan(): Setting new future strategy stack:
[17:39:28.797] List of future strategies:
[17:39:28.797] 1. sequential:
[17:39:28.797]    - args: function (..., envir = parent.frame())
[17:39:28.797]    - tweaked: FALSE
[17:39:28.797]    - call: plan(strategy)
[17:39:28.797] plan(): nbrOfWorkers() = 1
[17:39:28.798] SequentialFuture started (and completed)
[17:39:28.798] - Launch lazy future ... done
[17:39:28.798] run() for ‘SequentialFuture’ ... done
[17:39:28.798] Created future:
[17:39:28.798] SequentialFuture:
[17:39:28.798] Label: ‘future_eapply-1’
[17:39:28.798] Expression:
[17:39:28.798] {
[17:39:28.798]     do.call(function(...) {
[17:39:28.798]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.798]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.798]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.798]             on.exit(options(oopts), add = TRUE)
[17:39:28.798]         }
[17:39:28.798]         {
[17:39:28.798]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.798]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.798]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.798]             })
[17:39:28.798]         }
[17:39:28.798]     }, args = future.call.arguments)
[17:39:28.798] }
[17:39:28.798] Lazy evaluation: FALSE
[17:39:28.798] Asynchronous evaluation: FALSE
[17:39:28.798] Local evaluation: TRUE
[17:39:28.798] Environment: R_GlobalEnv
[17:39:28.798] Capture standard output: TRUE
[17:39:28.798] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.798] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.798] Packages: <none>
[17:39:28.798] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.798] Resolved: TRUE
[17:39:28.798] Value: 168 bytes of class ‘list’
[17:39:28.798] Early signaling: FALSE
[17:39:28.798] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:28.798] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.800] Chunk #1 of 1 ... DONE
[17:39:28.800] Launching 1 futures (chunks) ... DONE
[17:39:28.800] Resolving 1 futures (chunks) ...
[17:39:28.801] resolve() on list ...
[17:39:28.801]  recursive: 0
[17:39:28.801]  length: 1
[17:39:28.801] 
[17:39:28.801] resolved() for ‘SequentialFuture’ ...
[17:39:28.801] - state: ‘finished’
[17:39:28.801] - run: TRUE
[17:39:28.801] - result: ‘FutureResult’
[17:39:28.801] resolved() for ‘SequentialFuture’ ... done
[17:39:28.802] Future #1
[17:39:28.802] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:28.802] - nx: 1
[17:39:28.802] - relay: TRUE
[17:39:28.802] - stdout: TRUE
[17:39:28.802] - signal: TRUE
[17:39:28.802] - resignal: FALSE
[17:39:28.803] - force: TRUE
[17:39:28.803] - relayed: [n=1] FALSE
[17:39:28.803] - queued futures: [n=1] FALSE
[17:39:28.803]  - until=1
[17:39:28.803]  - relaying element #1
[17:39:28.803] - relayed: [n=1] TRUE
[17:39:28.803] - queued futures: [n=1] TRUE
[17:39:28.803] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:28.804]  length: 0 (resolved future 1)
[17:39:28.804] Relaying remaining futures
[17:39:28.804] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.804] - nx: 1
[17:39:28.804] - relay: TRUE
[17:39:28.804] - stdout: TRUE
[17:39:28.804] - signal: TRUE
[17:39:28.804] - resignal: FALSE
[17:39:28.804] - force: TRUE
[17:39:28.804] - relayed: [n=1] TRUE
[17:39:28.804] - queued futures: [n=1] TRUE
 - flush all
[17:39:28.805] - relayed: [n=1] TRUE
[17:39:28.805] - queued futures: [n=1] TRUE
[17:39:28.805] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.805] resolve() on list ... DONE
[17:39:28.805]  - Number of value chunks collected: 1
[17:39:28.805] Resolving 1 futures (chunks) ... DONE
[17:39:28.805] Reducing values from 1 chunks ...
[17:39:28.805]  - Number of values collected after concatenation: 3
[17:39:28.805]  - Number of values expected: 3
[17:39:28.806] Reducing values from 1 chunks ... DONE
[17:39:28.806] future_lapply() ... DONE
[17:39:28.810] future_lapply() ...
[17:39:28.811] Number of chunks: 1
[17:39:28.811] getGlobalsAndPackagesXApply() ...
[17:39:28.811]  - future.globals: TRUE
[17:39:28.811] getGlobalsAndPackages() ...
[17:39:28.811] Searching for globals...
[17:39:28.813] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.813] Searching for globals ... DONE
[17:39:28.813] Resolving globals: FALSE
[17:39:28.813] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:28.814] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:28.814] - globals: [1] ‘FUN’
[17:39:28.814] - packages: [1] ‘stats’
[17:39:28.814] getGlobalsAndPackages() ... DONE
[17:39:28.814]  - globals found/used: [n=1] ‘FUN’
[17:39:28.814]  - needed namespaces: [n=1] ‘stats’
[17:39:28.814] Finding globals ... DONE
[17:39:28.815]  - use_args: TRUE
[17:39:28.815]  - Getting '...' globals ...
[17:39:28.815] resolve() on list ...
[17:39:28.815]  recursive: 0
[17:39:28.815]  length: 1
[17:39:28.815]  elements: ‘...’
[17:39:28.815]  length: 0 (resolved future 1)
[17:39:28.816] resolve() on list ... DONE
[17:39:28.816]    - '...' content: [n=1] ‘probs’
[17:39:28.816] List of 1
[17:39:28.816]  $ ...:List of 1
[17:39:28.816]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:28.816]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.816]  - attr(*, "where")=List of 1
[17:39:28.816]   ..$ ...:<environment: 0x555b651073a0> 
[17:39:28.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.816]  - attr(*, "resolved")= logi TRUE
[17:39:28.816]  - attr(*, "total_size")= num NA
[17:39:28.819]  - Getting '...' globals ... DONE
[17:39:28.819] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.820] List of 2
[17:39:28.820]  $ ...future.FUN:function (x, ...)  
[17:39:28.820]  $ ...          :List of 1
[17:39:28.820]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:28.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.820]  - attr(*, "where")=List of 2
[17:39:28.820]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.820]   ..$ ...          :<environment: 0x555b651073a0> 
[17:39:28.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.820]  - attr(*, "resolved")= logi FALSE
[17:39:28.820]  - attr(*, "total_size")= num 1328
[17:39:28.823] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:28.823] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.823] Number of futures (= number of chunks): 1
[17:39:28.823] Launching 1 futures (chunks) ...
[17:39:28.823] Chunk #1 of 1 ...
[17:39:28.824]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.824] getGlobalsAndPackages() ...
[17:39:28.824] Searching for globals...
[17:39:28.824] 
[17:39:28.824] Searching for globals ... DONE
[17:39:28.824] - globals: [0] <none>
[17:39:28.824] getGlobalsAndPackages() ... DONE
[17:39:28.825]    + additional globals found: [n=0] 
[17:39:28.825]    + additional namespaces needed: [n=0] 
[17:39:28.825]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.825]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:28.825]  - seeds: <none>
[17:39:28.825] getGlobalsAndPackages() ...
[17:39:28.825] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.825] Resolving globals: FALSE
[17:39:28.825] Tweak future expression to call with '...' arguments ...
[17:39:28.826] {
[17:39:28.826]     do.call(function(...) {
[17:39:28.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.826]             on.exit(options(oopts), add = TRUE)
[17:39:28.826]         }
[17:39:28.826]         {
[17:39:28.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.826]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.826]             })
[17:39:28.826]         }
[17:39:28.826]     }, args = future.call.arguments)
[17:39:28.826] }
[17:39:28.826] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.826] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.826] - packages: [1] ‘stats’
[17:39:28.827] getGlobalsAndPackages() ... DONE
[17:39:28.827] run() for ‘Future’ ...
[17:39:28.827] - state: ‘created’
[17:39:28.827] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:28.828] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:28.828]   - Field: ‘label’
[17:39:28.828]   - Field: ‘local’
[17:39:28.828]   - Field: ‘owner’
[17:39:28.828]   - Field: ‘envir’
[17:39:28.828]   - Field: ‘packages’
[17:39:28.828]   - Field: ‘gc’
[17:39:28.829]   - Field: ‘conditions’
[17:39:28.829]   - Field: ‘expr’
[17:39:28.829]   - Field: ‘uuid’
[17:39:28.829]   - Field: ‘seed’
[17:39:28.829]   - Field: ‘version’
[17:39:28.829]   - Field: ‘result’
[17:39:28.829]   - Field: ‘asynchronous’
[17:39:28.829]   - Field: ‘calls’
[17:39:28.829]   - Field: ‘globals’
[17:39:28.829]   - Field: ‘stdout’
[17:39:28.829]   - Field: ‘earlySignal’
[17:39:28.830]   - Field: ‘lazy’
[17:39:28.830]   - Field: ‘state’
[17:39:28.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:28.830] - Launch lazy future ...
[17:39:28.830] Packages needed by the future expression (n = 1): ‘stats’
[17:39:28.830] Packages needed by future strategies (n = 0): <none>
[17:39:28.831] {
[17:39:28.831]     {
[17:39:28.831]         {
[17:39:28.831]             ...future.startTime <- base::Sys.time()
[17:39:28.831]             {
[17:39:28.831]                 {
[17:39:28.831]                   {
[17:39:28.831]                     {
[17:39:28.831]                       base::local({
[17:39:28.831]                         has_future <- base::requireNamespace("future", 
[17:39:28.831]                           quietly = TRUE)
[17:39:28.831]                         if (has_future) {
[17:39:28.831]                           ns <- base::getNamespace("future")
[17:39:28.831]                           version <- ns[[".package"]][["version"]]
[17:39:28.831]                           if (is.null(version)) 
[17:39:28.831]                             version <- utils::packageVersion("future")
[17:39:28.831]                         }
[17:39:28.831]                         else {
[17:39:28.831]                           version <- NULL
[17:39:28.831]                         }
[17:39:28.831]                         if (!has_future || version < "1.8.0") {
[17:39:28.831]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.831]                             "", base::R.version$version.string), 
[17:39:28.831]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.831]                               "release", "version")], collapse = " "), 
[17:39:28.831]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.831]                             info)
[17:39:28.831]                           info <- base::paste(info, collapse = "; ")
[17:39:28.831]                           if (!has_future) {
[17:39:28.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.831]                               info)
[17:39:28.831]                           }
[17:39:28.831]                           else {
[17:39:28.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.831]                               info, version)
[17:39:28.831]                           }
[17:39:28.831]                           base::stop(msg)
[17:39:28.831]                         }
[17:39:28.831]                       })
[17:39:28.831]                     }
[17:39:28.831]                     base::local({
[17:39:28.831]                       for (pkg in "stats") {
[17:39:28.831]                         base::loadNamespace(pkg)
[17:39:28.831]                         base::library(pkg, character.only = TRUE)
[17:39:28.831]                       }
[17:39:28.831]                     })
[17:39:28.831]                   }
[17:39:28.831]                   options(future.plan = NULL)
[17:39:28.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.831]                 }
[17:39:28.831]                 ...future.workdir <- getwd()
[17:39:28.831]             }
[17:39:28.831]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.831]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.831]         }
[17:39:28.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.831]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:28.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.831]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.831]             base::names(...future.oldOptions))
[17:39:28.831]     }
[17:39:28.831]     if (FALSE) {
[17:39:28.831]     }
[17:39:28.831]     else {
[17:39:28.831]         if (TRUE) {
[17:39:28.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.831]                 open = "w")
[17:39:28.831]         }
[17:39:28.831]         else {
[17:39:28.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.831]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.831]         }
[17:39:28.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.831]             base::sink(type = "output", split = FALSE)
[17:39:28.831]             base::close(...future.stdout)
[17:39:28.831]         }, add = TRUE)
[17:39:28.831]     }
[17:39:28.831]     ...future.frame <- base::sys.nframe()
[17:39:28.831]     ...future.conditions <- base::list()
[17:39:28.831]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.831]     if (FALSE) {
[17:39:28.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.831]     }
[17:39:28.831]     ...future.result <- base::tryCatch({
[17:39:28.831]         base::withCallingHandlers({
[17:39:28.831]             ...future.value <- base::withVisible(base::local({
[17:39:28.831]                 do.call(function(...) {
[17:39:28.831]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.831]                   if (!identical(...future.globals.maxSize.org, 
[17:39:28.831]                     ...future.globals.maxSize)) {
[17:39:28.831]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.831]                     on.exit(options(oopts), add = TRUE)
[17:39:28.831]                   }
[17:39:28.831]                   {
[17:39:28.831]                     lapply(seq_along(...future.elements_ii), 
[17:39:28.831]                       FUN = function(jj) {
[17:39:28.831]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.831]                         ...future.FUN(...future.X_jj, ...)
[17:39:28.831]                       })
[17:39:28.831]                   }
[17:39:28.831]                 }, args = future.call.arguments)
[17:39:28.831]             }))
[17:39:28.831]             future::FutureResult(value = ...future.value$value, 
[17:39:28.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.831]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.831]                     ...future.globalenv.names))
[17:39:28.831]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.831]         }, condition = base::local({
[17:39:28.831]             c <- base::c
[17:39:28.831]             inherits <- base::inherits
[17:39:28.831]             invokeRestart <- base::invokeRestart
[17:39:28.831]             length <- base::length
[17:39:28.831]             list <- base::list
[17:39:28.831]             seq.int <- base::seq.int
[17:39:28.831]             signalCondition <- base::signalCondition
[17:39:28.831]             sys.calls <- base::sys.calls
[17:39:28.831]             `[[` <- base::`[[`
[17:39:28.831]             `+` <- base::`+`
[17:39:28.831]             `<<-` <- base::`<<-`
[17:39:28.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.831]                   3L)]
[17:39:28.831]             }
[17:39:28.831]             function(cond) {
[17:39:28.831]                 is_error <- inherits(cond, "error")
[17:39:28.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.831]                   NULL)
[17:39:28.831]                 if (is_error) {
[17:39:28.831]                   sessionInformation <- function() {
[17:39:28.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.831]                       search = base::search(), system = base::Sys.info())
[17:39:28.831]                   }
[17:39:28.831]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.831]                     cond$call), session = sessionInformation(), 
[17:39:28.831]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.831]                   signalCondition(cond)
[17:39:28.831]                 }
[17:39:28.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.831]                 "immediateCondition"))) {
[17:39:28.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.831]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.831]                   if (TRUE && !signal) {
[17:39:28.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.831]                     {
[17:39:28.831]                       inherits <- base::inherits
[17:39:28.831]                       invokeRestart <- base::invokeRestart
[17:39:28.831]                       is.null <- base::is.null
[17:39:28.831]                       muffled <- FALSE
[17:39:28.831]                       if (inherits(cond, "message")) {
[17:39:28.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.831]                         if (muffled) 
[17:39:28.831]                           invokeRestart("muffleMessage")
[17:39:28.831]                       }
[17:39:28.831]                       else if (inherits(cond, "warning")) {
[17:39:28.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.831]                         if (muffled) 
[17:39:28.831]                           invokeRestart("muffleWarning")
[17:39:28.831]                       }
[17:39:28.831]                       else if (inherits(cond, "condition")) {
[17:39:28.831]                         if (!is.null(pattern)) {
[17:39:28.831]                           computeRestarts <- base::computeRestarts
[17:39:28.831]                           grepl <- base::grepl
[17:39:28.831]                           restarts <- computeRestarts(cond)
[17:39:28.831]                           for (restart in restarts) {
[17:39:28.831]                             name <- restart$name
[17:39:28.831]                             if (is.null(name)) 
[17:39:28.831]                               next
[17:39:28.831]                             if (!grepl(pattern, name)) 
[17:39:28.831]                               next
[17:39:28.831]                             invokeRestart(restart)
[17:39:28.831]                             muffled <- TRUE
[17:39:28.831]                             break
[17:39:28.831]                           }
[17:39:28.831]                         }
[17:39:28.831]                       }
[17:39:28.831]                       invisible(muffled)
[17:39:28.831]                     }
[17:39:28.831]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.831]                   }
[17:39:28.831]                 }
[17:39:28.831]                 else {
[17:39:28.831]                   if (TRUE) {
[17:39:28.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.831]                     {
[17:39:28.831]                       inherits <- base::inherits
[17:39:28.831]                       invokeRestart <- base::invokeRestart
[17:39:28.831]                       is.null <- base::is.null
[17:39:28.831]                       muffled <- FALSE
[17:39:28.831]                       if (inherits(cond, "message")) {
[17:39:28.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.831]                         if (muffled) 
[17:39:28.831]                           invokeRestart("muffleMessage")
[17:39:28.831]                       }
[17:39:28.831]                       else if (inherits(cond, "warning")) {
[17:39:28.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.831]                         if (muffled) 
[17:39:28.831]                           invokeRestart("muffleWarning")
[17:39:28.831]                       }
[17:39:28.831]                       else if (inherits(cond, "condition")) {
[17:39:28.831]                         if (!is.null(pattern)) {
[17:39:28.831]                           computeRestarts <- base::computeRestarts
[17:39:28.831]                           grepl <- base::grepl
[17:39:28.831]                           restarts <- computeRestarts(cond)
[17:39:28.831]                           for (restart in restarts) {
[17:39:28.831]                             name <- restart$name
[17:39:28.831]                             if (is.null(name)) 
[17:39:28.831]                               next
[17:39:28.831]                             if (!grepl(pattern, name)) 
[17:39:28.831]                               next
[17:39:28.831]                             invokeRestart(restart)
[17:39:28.831]                             muffled <- TRUE
[17:39:28.831]                             break
[17:39:28.831]                           }
[17:39:28.831]                         }
[17:39:28.831]                       }
[17:39:28.831]                       invisible(muffled)
[17:39:28.831]                     }
[17:39:28.831]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.831]                   }
[17:39:28.831]                 }
[17:39:28.831]             }
[17:39:28.831]         }))
[17:39:28.831]     }, error = function(ex) {
[17:39:28.831]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.831]                 ...future.rng), started = ...future.startTime, 
[17:39:28.831]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.831]             version = "1.8"), class = "FutureResult")
[17:39:28.831]     }, finally = {
[17:39:28.831]         if (!identical(...future.workdir, getwd())) 
[17:39:28.831]             setwd(...future.workdir)
[17:39:28.831]         {
[17:39:28.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.831]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.831]             }
[17:39:28.831]             base::options(...future.oldOptions)
[17:39:28.831]             if (.Platform$OS.type == "windows") {
[17:39:28.831]                 old_names <- names(...future.oldEnvVars)
[17:39:28.831]                 envs <- base::Sys.getenv()
[17:39:28.831]                 names <- names(envs)
[17:39:28.831]                 common <- intersect(names, old_names)
[17:39:28.831]                 added <- setdiff(names, old_names)
[17:39:28.831]                 removed <- setdiff(old_names, names)
[17:39:28.831]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.831]                   envs[common]]
[17:39:28.831]                 NAMES <- toupper(changed)
[17:39:28.831]                 args <- list()
[17:39:28.831]                 for (kk in seq_along(NAMES)) {
[17:39:28.831]                   name <- changed[[kk]]
[17:39:28.831]                   NAME <- NAMES[[kk]]
[17:39:28.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.831]                     next
[17:39:28.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.831]                 }
[17:39:28.831]                 NAMES <- toupper(added)
[17:39:28.831]                 for (kk in seq_along(NAMES)) {
[17:39:28.831]                   name <- added[[kk]]
[17:39:28.831]                   NAME <- NAMES[[kk]]
[17:39:28.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.831]                     next
[17:39:28.831]                   args[[name]] <- ""
[17:39:28.831]                 }
[17:39:28.831]                 NAMES <- toupper(removed)
[17:39:28.831]                 for (kk in seq_along(NAMES)) {
[17:39:28.831]                   name <- removed[[kk]]
[17:39:28.831]                   NAME <- NAMES[[kk]]
[17:39:28.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.831]                     next
[17:39:28.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.831]                 }
[17:39:28.831]                 if (length(args) > 0) 
[17:39:28.831]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.831]             }
[17:39:28.831]             else {
[17:39:28.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.831]             }
[17:39:28.831]             {
[17:39:28.831]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.831]                   0L) {
[17:39:28.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.831]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.831]                   base::options(opts)
[17:39:28.831]                 }
[17:39:28.831]                 {
[17:39:28.831]                   {
[17:39:28.831]                     NULL
[17:39:28.831]                     RNGkind("Mersenne-Twister")
[17:39:28.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:28.831]                       inherits = FALSE)
[17:39:28.831]                   }
[17:39:28.831]                   options(future.plan = NULL)
[17:39:28.831]                   if (is.na(NA_character_)) 
[17:39:28.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.831]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:28.831]                   {
[17:39:28.831]                     future <- SequentialFuture(..., envir = envir)
[17:39:28.831]                     if (!future$lazy) 
[17:39:28.831]                       future <- run(future)
[17:39:28.831]                     invisible(future)
[17:39:28.831]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.831]                 }
[17:39:28.831]             }
[17:39:28.831]         }
[17:39:28.831]     })
[17:39:28.831]     if (TRUE) {
[17:39:28.831]         base::sink(type = "output", split = FALSE)
[17:39:28.831]         if (TRUE) {
[17:39:28.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.831]         }
[17:39:28.831]         else {
[17:39:28.831]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.831]         }
[17:39:28.831]         base::close(...future.stdout)
[17:39:28.831]         ...future.stdout <- NULL
[17:39:28.831]     }
[17:39:28.831]     ...future.result$conditions <- ...future.conditions
[17:39:28.831]     ...future.result$finished <- base::Sys.time()
[17:39:28.831]     ...future.result
[17:39:28.831] }
[17:39:28.833] assign_globals() ...
[17:39:28.833] List of 5
[17:39:28.833]  $ ...future.FUN            :function (x, ...)  
[17:39:28.833]  $ future.call.arguments    :List of 1
[17:39:28.833]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:28.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.833]  $ ...future.elements_ii    :List of 3
[17:39:28.833]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:39:28.833]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:28.833]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:28.833]  $ ...future.seeds_ii       : NULL
[17:39:28.833]  $ ...future.globals.maxSize: NULL
[17:39:28.833]  - attr(*, "resolved")= logi FALSE
[17:39:28.833]  - attr(*, "total_size")= num 1328
[17:39:28.833]  - attr(*, "where")=List of 5
[17:39:28.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:28.833]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:28.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:28.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:28.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:28.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.833]  - attr(*, "already-done")= logi TRUE
[17:39:28.842] - copied ‘...future.FUN’ to environment
[17:39:28.842] - copied ‘future.call.arguments’ to environment
[17:39:28.842] - copied ‘...future.elements_ii’ to environment
[17:39:28.842] - copied ‘...future.seeds_ii’ to environment
[17:39:28.842] - copied ‘...future.globals.maxSize’ to environment
[17:39:28.842] assign_globals() ... done
[17:39:28.843] plan(): Setting new future strategy stack:
[17:39:28.843] List of future strategies:
[17:39:28.843] 1. sequential:
[17:39:28.843]    - args: function (..., envir = parent.frame())
[17:39:28.843]    - tweaked: FALSE
[17:39:28.843]    - call: NULL
[17:39:28.843] plan(): nbrOfWorkers() = 1
[17:39:28.845] plan(): Setting new future strategy stack:
[17:39:28.845] List of future strategies:
[17:39:28.845] 1. sequential:
[17:39:28.845]    - args: function (..., envir = parent.frame())
[17:39:28.845]    - tweaked: FALSE
[17:39:28.845]    - call: plan(strategy)
[17:39:28.845] plan(): nbrOfWorkers() = 1
[17:39:28.845] SequentialFuture started (and completed)
[17:39:28.845] - Launch lazy future ... done
[17:39:28.846] run() for ‘SequentialFuture’ ... done
[17:39:28.846] Created future:
[17:39:28.846] SequentialFuture:
[17:39:28.846] Label: ‘future_eapply-1’
[17:39:28.846] Expression:
[17:39:28.846] {
[17:39:28.846]     do.call(function(...) {
[17:39:28.846]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.846]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.846]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.846]             on.exit(options(oopts), add = TRUE)
[17:39:28.846]         }
[17:39:28.846]         {
[17:39:28.846]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.846]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.846]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.846]             })
[17:39:28.846]         }
[17:39:28.846]     }, args = future.call.arguments)
[17:39:28.846] }
[17:39:28.846] Lazy evaluation: FALSE
[17:39:28.846] Asynchronous evaluation: FALSE
[17:39:28.846] Local evaluation: TRUE
[17:39:28.846] Environment: R_GlobalEnv
[17:39:28.846] Capture standard output: TRUE
[17:39:28.846] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.846] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.846] Packages: 1 packages (‘stats’)
[17:39:28.846] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.846] Resolved: TRUE
[17:39:28.846] Value: 1.29 KiB of class ‘list’
[17:39:28.846] Early signaling: FALSE
[17:39:28.846] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:28.846] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.847] Chunk #1 of 1 ... DONE
[17:39:28.847] Launching 1 futures (chunks) ... DONE
[17:39:28.847] Resolving 1 futures (chunks) ...
[17:39:28.847] resolve() on list ...
[17:39:28.847]  recursive: 0
[17:39:28.848]  length: 1
[17:39:28.848] 
[17:39:28.848] resolved() for ‘SequentialFuture’ ...
[17:39:28.848] - state: ‘finished’
[17:39:28.848] - run: TRUE
[17:39:28.848] - result: ‘FutureResult’
[17:39:28.848] resolved() for ‘SequentialFuture’ ... done
[17:39:28.848] Future #1
[17:39:28.848] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:28.848] - nx: 1
[17:39:28.849] - relay: TRUE
[17:39:28.849] - stdout: TRUE
[17:39:28.849] - signal: TRUE
[17:39:28.849] - resignal: FALSE
[17:39:28.849] - force: TRUE
[17:39:28.849] - relayed: [n=1] FALSE
[17:39:28.849] - queued futures: [n=1] FALSE
[17:39:28.849]  - until=1
[17:39:28.849]  - relaying element #1
[17:39:28.850] - relayed: [n=1] TRUE
[17:39:28.850] - queued futures: [n=1] TRUE
[17:39:28.850] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:28.850]  length: 0 (resolved future 1)
[17:39:28.850] Relaying remaining futures
[17:39:28.850] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.850] - nx: 1
[17:39:28.850] - relay: TRUE
[17:39:28.850] - stdout: TRUE
[17:39:28.850] - signal: TRUE
[17:39:28.850] - resignal: FALSE
[17:39:28.851] - force: TRUE
[17:39:28.851] - relayed: [n=1] TRUE
[17:39:28.851] - queued futures: [n=1] TRUE
 - flush all
[17:39:28.851] - relayed: [n=1] TRUE
[17:39:28.851] - queued futures: [n=1] TRUE
[17:39:28.851] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.851] resolve() on list ... DONE
[17:39:28.851]  - Number of value chunks collected: 1
[17:39:28.851] Resolving 1 futures (chunks) ... DONE
[17:39:28.852] Reducing values from 1 chunks ...
[17:39:28.852]  - Number of values collected after concatenation: 3
[17:39:28.852]  - Number of values expected: 3
[17:39:28.852] Reducing values from 1 chunks ... DONE
[17:39:28.852] future_lapply() ... DONE
[17:39:28.853] future_lapply() ...
[17:39:28.854] Number of chunks: 1
[17:39:28.854] getGlobalsAndPackagesXApply() ...
[17:39:28.854]  - future.globals: TRUE
[17:39:28.854] getGlobalsAndPackages() ...
[17:39:28.854] Searching for globals...
[17:39:28.856] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.856] Searching for globals ... DONE
[17:39:28.856] Resolving globals: FALSE
[17:39:28.856] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:28.857] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:28.857] - globals: [1] ‘FUN’
[17:39:28.857] - packages: [1] ‘stats’
[17:39:28.857] getGlobalsAndPackages() ... DONE
[17:39:28.857]  - globals found/used: [n=1] ‘FUN’
[17:39:28.857]  - needed namespaces: [n=1] ‘stats’
[17:39:28.857] Finding globals ... DONE
[17:39:28.857]  - use_args: TRUE
[17:39:28.857]  - Getting '...' globals ...
[17:39:28.858] resolve() on list ...
[17:39:28.858]  recursive: 0
[17:39:28.858]  length: 1
[17:39:28.858]  elements: ‘...’
[17:39:28.858]  length: 0 (resolved future 1)
[17:39:28.858] resolve() on list ... DONE
[17:39:28.858]    - '...' content: [n=0] 
[17:39:28.858] List of 1
[17:39:28.858]  $ ...: list()
[17:39:28.858]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.858]  - attr(*, "where")=List of 1
[17:39:28.858]   ..$ ...:<environment: 0x555b6562f768> 
[17:39:28.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.858]  - attr(*, "resolved")= logi TRUE
[17:39:28.858]  - attr(*, "total_size")= num NA
[17:39:28.861]  - Getting '...' globals ... DONE
[17:39:28.861] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.862] List of 2
[17:39:28.862]  $ ...future.FUN:function (x, ...)  
[17:39:28.862]  $ ...          : list()
[17:39:28.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.862]  - attr(*, "where")=List of 2
[17:39:28.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.862]   ..$ ...          :<environment: 0x555b6562f768> 
[17:39:28.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.862]  - attr(*, "resolved")= logi FALSE
[17:39:28.862]  - attr(*, "total_size")= num 1248
[17:39:28.864] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:28.864] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.866] Number of futures (= number of chunks): 1
[17:39:28.867] Launching 1 futures (chunks) ...
[17:39:28.867] Chunk #1 of 1 ...
[17:39:28.867]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.867] getGlobalsAndPackages() ...
[17:39:28.867] Searching for globals...
[17:39:28.867] 
[17:39:28.867] Searching for globals ... DONE
[17:39:28.868] - globals: [0] <none>
[17:39:28.868] getGlobalsAndPackages() ... DONE
[17:39:28.868]    + additional globals found: [n=0] 
[17:39:28.868]    + additional namespaces needed: [n=0] 
[17:39:28.868]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.868]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:28.868]  - seeds: <none>
[17:39:28.868] getGlobalsAndPackages() ...
[17:39:28.868] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.869] Resolving globals: FALSE
[17:39:28.869] Tweak future expression to call with '...' arguments ...
[17:39:28.869] {
[17:39:28.869]     do.call(function(...) {
[17:39:28.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.869]             on.exit(options(oopts), add = TRUE)
[17:39:28.869]         }
[17:39:28.869]         {
[17:39:28.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.869]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.869]             })
[17:39:28.869]         }
[17:39:28.869]     }, args = future.call.arguments)
[17:39:28.869] }
[17:39:28.869] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.869] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.870] - packages: [1] ‘stats’
[17:39:28.870] getGlobalsAndPackages() ... DONE
[17:39:28.870] run() for ‘Future’ ...
[17:39:28.870] - state: ‘created’
[17:39:28.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:28.871] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:28.871]   - Field: ‘label’
[17:39:28.871]   - Field: ‘local’
[17:39:28.871]   - Field: ‘owner’
[17:39:28.871]   - Field: ‘envir’
[17:39:28.871]   - Field: ‘packages’
[17:39:28.871]   - Field: ‘gc’
[17:39:28.872]   - Field: ‘conditions’
[17:39:28.872]   - Field: ‘expr’
[17:39:28.872]   - Field: ‘uuid’
[17:39:28.872]   - Field: ‘seed’
[17:39:28.872]   - Field: ‘version’
[17:39:28.872]   - Field: ‘result’
[17:39:28.872]   - Field: ‘asynchronous’
[17:39:28.872]   - Field: ‘calls’
[17:39:28.872]   - Field: ‘globals’
[17:39:28.872]   - Field: ‘stdout’
[17:39:28.872]   - Field: ‘earlySignal’
[17:39:28.873]   - Field: ‘lazy’
[17:39:28.873]   - Field: ‘state’
[17:39:28.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:28.873] - Launch lazy future ...
[17:39:28.873] Packages needed by the future expression (n = 1): ‘stats’
[17:39:28.873] Packages needed by future strategies (n = 0): <none>
[17:39:28.874] {
[17:39:28.874]     {
[17:39:28.874]         {
[17:39:28.874]             ...future.startTime <- base::Sys.time()
[17:39:28.874]             {
[17:39:28.874]                 {
[17:39:28.874]                   {
[17:39:28.874]                     {
[17:39:28.874]                       base::local({
[17:39:28.874]                         has_future <- base::requireNamespace("future", 
[17:39:28.874]                           quietly = TRUE)
[17:39:28.874]                         if (has_future) {
[17:39:28.874]                           ns <- base::getNamespace("future")
[17:39:28.874]                           version <- ns[[".package"]][["version"]]
[17:39:28.874]                           if (is.null(version)) 
[17:39:28.874]                             version <- utils::packageVersion("future")
[17:39:28.874]                         }
[17:39:28.874]                         else {
[17:39:28.874]                           version <- NULL
[17:39:28.874]                         }
[17:39:28.874]                         if (!has_future || version < "1.8.0") {
[17:39:28.874]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.874]                             "", base::R.version$version.string), 
[17:39:28.874]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.874]                               "release", "version")], collapse = " "), 
[17:39:28.874]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.874]                             info)
[17:39:28.874]                           info <- base::paste(info, collapse = "; ")
[17:39:28.874]                           if (!has_future) {
[17:39:28.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.874]                               info)
[17:39:28.874]                           }
[17:39:28.874]                           else {
[17:39:28.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.874]                               info, version)
[17:39:28.874]                           }
[17:39:28.874]                           base::stop(msg)
[17:39:28.874]                         }
[17:39:28.874]                       })
[17:39:28.874]                     }
[17:39:28.874]                     base::local({
[17:39:28.874]                       for (pkg in "stats") {
[17:39:28.874]                         base::loadNamespace(pkg)
[17:39:28.874]                         base::library(pkg, character.only = TRUE)
[17:39:28.874]                       }
[17:39:28.874]                     })
[17:39:28.874]                   }
[17:39:28.874]                   options(future.plan = NULL)
[17:39:28.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.874]                 }
[17:39:28.874]                 ...future.workdir <- getwd()
[17:39:28.874]             }
[17:39:28.874]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.874]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.874]         }
[17:39:28.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.874]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:28.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.874]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.874]             base::names(...future.oldOptions))
[17:39:28.874]     }
[17:39:28.874]     if (FALSE) {
[17:39:28.874]     }
[17:39:28.874]     else {
[17:39:28.874]         if (TRUE) {
[17:39:28.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.874]                 open = "w")
[17:39:28.874]         }
[17:39:28.874]         else {
[17:39:28.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.874]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.874]         }
[17:39:28.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.874]             base::sink(type = "output", split = FALSE)
[17:39:28.874]             base::close(...future.stdout)
[17:39:28.874]         }, add = TRUE)
[17:39:28.874]     }
[17:39:28.874]     ...future.frame <- base::sys.nframe()
[17:39:28.874]     ...future.conditions <- base::list()
[17:39:28.874]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.874]     if (FALSE) {
[17:39:28.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.874]     }
[17:39:28.874]     ...future.result <- base::tryCatch({
[17:39:28.874]         base::withCallingHandlers({
[17:39:28.874]             ...future.value <- base::withVisible(base::local({
[17:39:28.874]                 do.call(function(...) {
[17:39:28.874]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.874]                   if (!identical(...future.globals.maxSize.org, 
[17:39:28.874]                     ...future.globals.maxSize)) {
[17:39:28.874]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.874]                     on.exit(options(oopts), add = TRUE)
[17:39:28.874]                   }
[17:39:28.874]                   {
[17:39:28.874]                     lapply(seq_along(...future.elements_ii), 
[17:39:28.874]                       FUN = function(jj) {
[17:39:28.874]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.874]                         ...future.FUN(...future.X_jj, ...)
[17:39:28.874]                       })
[17:39:28.874]                   }
[17:39:28.874]                 }, args = future.call.arguments)
[17:39:28.874]             }))
[17:39:28.874]             future::FutureResult(value = ...future.value$value, 
[17:39:28.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.874]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.874]                     ...future.globalenv.names))
[17:39:28.874]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.874]         }, condition = base::local({
[17:39:28.874]             c <- base::c
[17:39:28.874]             inherits <- base::inherits
[17:39:28.874]             invokeRestart <- base::invokeRestart
[17:39:28.874]             length <- base::length
[17:39:28.874]             list <- base::list
[17:39:28.874]             seq.int <- base::seq.int
[17:39:28.874]             signalCondition <- base::signalCondition
[17:39:28.874]             sys.calls <- base::sys.calls
[17:39:28.874]             `[[` <- base::`[[`
[17:39:28.874]             `+` <- base::`+`
[17:39:28.874]             `<<-` <- base::`<<-`
[17:39:28.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.874]                   3L)]
[17:39:28.874]             }
[17:39:28.874]             function(cond) {
[17:39:28.874]                 is_error <- inherits(cond, "error")
[17:39:28.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.874]                   NULL)
[17:39:28.874]                 if (is_error) {
[17:39:28.874]                   sessionInformation <- function() {
[17:39:28.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.874]                       search = base::search(), system = base::Sys.info())
[17:39:28.874]                   }
[17:39:28.874]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.874]                     cond$call), session = sessionInformation(), 
[17:39:28.874]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.874]                   signalCondition(cond)
[17:39:28.874]                 }
[17:39:28.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.874]                 "immediateCondition"))) {
[17:39:28.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.874]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.874]                   if (TRUE && !signal) {
[17:39:28.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.874]                     {
[17:39:28.874]                       inherits <- base::inherits
[17:39:28.874]                       invokeRestart <- base::invokeRestart
[17:39:28.874]                       is.null <- base::is.null
[17:39:28.874]                       muffled <- FALSE
[17:39:28.874]                       if (inherits(cond, "message")) {
[17:39:28.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.874]                         if (muffled) 
[17:39:28.874]                           invokeRestart("muffleMessage")
[17:39:28.874]                       }
[17:39:28.874]                       else if (inherits(cond, "warning")) {
[17:39:28.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.874]                         if (muffled) 
[17:39:28.874]                           invokeRestart("muffleWarning")
[17:39:28.874]                       }
[17:39:28.874]                       else if (inherits(cond, "condition")) {
[17:39:28.874]                         if (!is.null(pattern)) {
[17:39:28.874]                           computeRestarts <- base::computeRestarts
[17:39:28.874]                           grepl <- base::grepl
[17:39:28.874]                           restarts <- computeRestarts(cond)
[17:39:28.874]                           for (restart in restarts) {
[17:39:28.874]                             name <- restart$name
[17:39:28.874]                             if (is.null(name)) 
[17:39:28.874]                               next
[17:39:28.874]                             if (!grepl(pattern, name)) 
[17:39:28.874]                               next
[17:39:28.874]                             invokeRestart(restart)
[17:39:28.874]                             muffled <- TRUE
[17:39:28.874]                             break
[17:39:28.874]                           }
[17:39:28.874]                         }
[17:39:28.874]                       }
[17:39:28.874]                       invisible(muffled)
[17:39:28.874]                     }
[17:39:28.874]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.874]                   }
[17:39:28.874]                 }
[17:39:28.874]                 else {
[17:39:28.874]                   if (TRUE) {
[17:39:28.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.874]                     {
[17:39:28.874]                       inherits <- base::inherits
[17:39:28.874]                       invokeRestart <- base::invokeRestart
[17:39:28.874]                       is.null <- base::is.null
[17:39:28.874]                       muffled <- FALSE
[17:39:28.874]                       if (inherits(cond, "message")) {
[17:39:28.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.874]                         if (muffled) 
[17:39:28.874]                           invokeRestart("muffleMessage")
[17:39:28.874]                       }
[17:39:28.874]                       else if (inherits(cond, "warning")) {
[17:39:28.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.874]                         if (muffled) 
[17:39:28.874]                           invokeRestart("muffleWarning")
[17:39:28.874]                       }
[17:39:28.874]                       else if (inherits(cond, "condition")) {
[17:39:28.874]                         if (!is.null(pattern)) {
[17:39:28.874]                           computeRestarts <- base::computeRestarts
[17:39:28.874]                           grepl <- base::grepl
[17:39:28.874]                           restarts <- computeRestarts(cond)
[17:39:28.874]                           for (restart in restarts) {
[17:39:28.874]                             name <- restart$name
[17:39:28.874]                             if (is.null(name)) 
[17:39:28.874]                               next
[17:39:28.874]                             if (!grepl(pattern, name)) 
[17:39:28.874]                               next
[17:39:28.874]                             invokeRestart(restart)
[17:39:28.874]                             muffled <- TRUE
[17:39:28.874]                             break
[17:39:28.874]                           }
[17:39:28.874]                         }
[17:39:28.874]                       }
[17:39:28.874]                       invisible(muffled)
[17:39:28.874]                     }
[17:39:28.874]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.874]                   }
[17:39:28.874]                 }
[17:39:28.874]             }
[17:39:28.874]         }))
[17:39:28.874]     }, error = function(ex) {
[17:39:28.874]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.874]                 ...future.rng), started = ...future.startTime, 
[17:39:28.874]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.874]             version = "1.8"), class = "FutureResult")
[17:39:28.874]     }, finally = {
[17:39:28.874]         if (!identical(...future.workdir, getwd())) 
[17:39:28.874]             setwd(...future.workdir)
[17:39:28.874]         {
[17:39:28.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.874]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.874]             }
[17:39:28.874]             base::options(...future.oldOptions)
[17:39:28.874]             if (.Platform$OS.type == "windows") {
[17:39:28.874]                 old_names <- names(...future.oldEnvVars)
[17:39:28.874]                 envs <- base::Sys.getenv()
[17:39:28.874]                 names <- names(envs)
[17:39:28.874]                 common <- intersect(names, old_names)
[17:39:28.874]                 added <- setdiff(names, old_names)
[17:39:28.874]                 removed <- setdiff(old_names, names)
[17:39:28.874]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.874]                   envs[common]]
[17:39:28.874]                 NAMES <- toupper(changed)
[17:39:28.874]                 args <- list()
[17:39:28.874]                 for (kk in seq_along(NAMES)) {
[17:39:28.874]                   name <- changed[[kk]]
[17:39:28.874]                   NAME <- NAMES[[kk]]
[17:39:28.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.874]                     next
[17:39:28.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.874]                 }
[17:39:28.874]                 NAMES <- toupper(added)
[17:39:28.874]                 for (kk in seq_along(NAMES)) {
[17:39:28.874]                   name <- added[[kk]]
[17:39:28.874]                   NAME <- NAMES[[kk]]
[17:39:28.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.874]                     next
[17:39:28.874]                   args[[name]] <- ""
[17:39:28.874]                 }
[17:39:28.874]                 NAMES <- toupper(removed)
[17:39:28.874]                 for (kk in seq_along(NAMES)) {
[17:39:28.874]                   name <- removed[[kk]]
[17:39:28.874]                   NAME <- NAMES[[kk]]
[17:39:28.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.874]                     next
[17:39:28.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.874]                 }
[17:39:28.874]                 if (length(args) > 0) 
[17:39:28.874]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.874]             }
[17:39:28.874]             else {
[17:39:28.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.874]             }
[17:39:28.874]             {
[17:39:28.874]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.874]                   0L) {
[17:39:28.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.874]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.874]                   base::options(opts)
[17:39:28.874]                 }
[17:39:28.874]                 {
[17:39:28.874]                   {
[17:39:28.874]                     NULL
[17:39:28.874]                     RNGkind("Mersenne-Twister")
[17:39:28.874]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:28.874]                       inherits = FALSE)
[17:39:28.874]                   }
[17:39:28.874]                   options(future.plan = NULL)
[17:39:28.874]                   if (is.na(NA_character_)) 
[17:39:28.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.874]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:28.874]                   {
[17:39:28.874]                     future <- SequentialFuture(..., envir = envir)
[17:39:28.874]                     if (!future$lazy) 
[17:39:28.874]                       future <- run(future)
[17:39:28.874]                     invisible(future)
[17:39:28.874]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.874]                 }
[17:39:28.874]             }
[17:39:28.874]         }
[17:39:28.874]     })
[17:39:28.874]     if (TRUE) {
[17:39:28.874]         base::sink(type = "output", split = FALSE)
[17:39:28.874]         if (TRUE) {
[17:39:28.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.874]         }
[17:39:28.874]         else {
[17:39:28.874]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.874]         }
[17:39:28.874]         base::close(...future.stdout)
[17:39:28.874]         ...future.stdout <- NULL
[17:39:28.874]     }
[17:39:28.874]     ...future.result$conditions <- ...future.conditions
[17:39:28.874]     ...future.result$finished <- base::Sys.time()
[17:39:28.874]     ...future.result
[17:39:28.874] }
[17:39:28.876] assign_globals() ...
[17:39:28.876] List of 5
[17:39:28.876]  $ ...future.FUN            :function (x, ...)  
[17:39:28.876]  $ future.call.arguments    : list()
[17:39:28.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.876]  $ ...future.elements_ii    :List of 3
[17:39:28.876]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:39:28.876]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:28.876]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:28.876]  $ ...future.seeds_ii       : NULL
[17:39:28.876]  $ ...future.globals.maxSize: NULL
[17:39:28.876]  - attr(*, "resolved")= logi FALSE
[17:39:28.876]  - attr(*, "total_size")= num 1248
[17:39:28.876]  - attr(*, "where")=List of 5
[17:39:28.876]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:28.876]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:28.876]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:28.876]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:28.876]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:28.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.876]  - attr(*, "already-done")= logi TRUE
[17:39:28.881] - copied ‘...future.FUN’ to environment
[17:39:28.881] - copied ‘future.call.arguments’ to environment
[17:39:28.881] - copied ‘...future.elements_ii’ to environment
[17:39:28.882] - copied ‘...future.seeds_ii’ to environment
[17:39:28.882] - copied ‘...future.globals.maxSize’ to environment
[17:39:28.882] assign_globals() ... done
[17:39:28.882] plan(): Setting new future strategy stack:
[17:39:28.882] List of future strategies:
[17:39:28.882] 1. sequential:
[17:39:28.882]    - args: function (..., envir = parent.frame())
[17:39:28.882]    - tweaked: FALSE
[17:39:28.882]    - call: NULL
[17:39:28.883] plan(): nbrOfWorkers() = 1
[17:39:28.884] plan(): Setting new future strategy stack:
[17:39:28.884] List of future strategies:
[17:39:28.884] 1. sequential:
[17:39:28.884]    - args: function (..., envir = parent.frame())
[17:39:28.884]    - tweaked: FALSE
[17:39:28.884]    - call: plan(strategy)
[17:39:28.885] plan(): nbrOfWorkers() = 1
[17:39:28.885] SequentialFuture started (and completed)
[17:39:28.885] - Launch lazy future ... done
[17:39:28.885] run() for ‘SequentialFuture’ ... done
[17:39:28.885] Created future:
[17:39:28.885] SequentialFuture:
[17:39:28.885] Label: ‘future_eapply-1’
[17:39:28.885] Expression:
[17:39:28.885] {
[17:39:28.885]     do.call(function(...) {
[17:39:28.885]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.885]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.885]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.885]             on.exit(options(oopts), add = TRUE)
[17:39:28.885]         }
[17:39:28.885]         {
[17:39:28.885]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.885]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.885]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.885]             })
[17:39:28.885]         }
[17:39:28.885]     }, args = future.call.arguments)
[17:39:28.885] }
[17:39:28.885] Lazy evaluation: FALSE
[17:39:28.885] Asynchronous evaluation: FALSE
[17:39:28.885] Local evaluation: TRUE
[17:39:28.885] Environment: R_GlobalEnv
[17:39:28.885] Capture standard output: TRUE
[17:39:28.885] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.885] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.885] Packages: 1 packages (‘stats’)
[17:39:28.885] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.885] Resolved: TRUE
[17:39:28.885] Value: 1.71 KiB of class ‘list’
[17:39:28.885] Early signaling: FALSE
[17:39:28.885] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:28.885] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.886] Chunk #1 of 1 ... DONE
[17:39:28.886] Launching 1 futures (chunks) ... DONE
[17:39:28.887] Resolving 1 futures (chunks) ...
[17:39:28.887] resolve() on list ...
[17:39:28.887]  recursive: 0
[17:39:28.887]  length: 1
[17:39:28.887] 
[17:39:28.887] resolved() for ‘SequentialFuture’ ...
[17:39:28.887] - state: ‘finished’
[17:39:28.887] - run: TRUE
[17:39:28.887] - result: ‘FutureResult’
[17:39:28.887] resolved() for ‘SequentialFuture’ ... done
[17:39:28.888] Future #1
[17:39:28.888] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:28.888] - nx: 1
[17:39:28.888] - relay: TRUE
[17:39:28.888] - stdout: TRUE
[17:39:28.888] - signal: TRUE
[17:39:28.888] - resignal: FALSE
[17:39:28.888] - force: TRUE
[17:39:28.888] - relayed: [n=1] FALSE
[17:39:28.888] - queued futures: [n=1] FALSE
[17:39:28.889]  - until=1
[17:39:28.889]  - relaying element #1
[17:39:28.889] - relayed: [n=1] TRUE
[17:39:28.889] - queued futures: [n=1] TRUE
[17:39:28.889] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:28.889]  length: 0 (resolved future 1)
[17:39:28.889] Relaying remaining futures
[17:39:28.889] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.889] - nx: 1
[17:39:28.889] - relay: TRUE
[17:39:28.890] - stdout: TRUE
[17:39:28.890] - signal: TRUE
[17:39:28.890] - resignal: FALSE
[17:39:28.890] - force: TRUE
[17:39:28.890] - relayed: [n=1] TRUE
[17:39:28.890] - queued futures: [n=1] TRUE
 - flush all
[17:39:28.890] - relayed: [n=1] TRUE
[17:39:28.890] - queued futures: [n=1] TRUE
[17:39:28.890] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.890] resolve() on list ... DONE
[17:39:28.891]  - Number of value chunks collected: 1
[17:39:28.891] Resolving 1 futures (chunks) ... DONE
[17:39:28.891] Reducing values from 1 chunks ...
[17:39:28.891]  - Number of values collected after concatenation: 3
[17:39:28.891]  - Number of values expected: 3
[17:39:28.891] Reducing values from 1 chunks ... DONE
[17:39:28.891] future_lapply() ... DONE
[17:39:28.891] future_lapply() ...
[17:39:28.894] Number of chunks: 1
[17:39:28.894] getGlobalsAndPackagesXApply() ...
[17:39:28.894]  - future.globals: TRUE
[17:39:28.894] getGlobalsAndPackages() ...
[17:39:28.894] Searching for globals...
[17:39:28.896] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.896] Searching for globals ... DONE
[17:39:28.896] Resolving globals: FALSE
[17:39:28.896] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:28.897] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:28.897] - globals: [1] ‘FUN’
[17:39:28.897] - packages: [1] ‘stats’
[17:39:28.897] getGlobalsAndPackages() ... DONE
[17:39:28.897]  - globals found/used: [n=1] ‘FUN’
[17:39:28.897]  - needed namespaces: [n=1] ‘stats’
[17:39:28.897] Finding globals ... DONE
[17:39:28.897]  - use_args: TRUE
[17:39:28.897]  - Getting '...' globals ...
[17:39:28.898] resolve() on list ...
[17:39:28.898]  recursive: 0
[17:39:28.898]  length: 1
[17:39:28.898]  elements: ‘...’
[17:39:28.898]  length: 0 (resolved future 1)
[17:39:28.898] resolve() on list ... DONE
[17:39:28.898]    - '...' content: [n=0] 
[17:39:28.898] List of 1
[17:39:28.898]  $ ...: list()
[17:39:28.898]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.898]  - attr(*, "where")=List of 1
[17:39:28.898]   ..$ ...:<environment: 0x555b661375e8> 
[17:39:28.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.898]  - attr(*, "resolved")= logi TRUE
[17:39:28.898]  - attr(*, "total_size")= num NA
[17:39:28.901]  - Getting '...' globals ... DONE
[17:39:28.901] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.902] List of 2
[17:39:28.902]  $ ...future.FUN:function (x, ...)  
[17:39:28.902]  $ ...          : list()
[17:39:28.902]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.902]  - attr(*, "where")=List of 2
[17:39:28.902]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.902]   ..$ ...          :<environment: 0x555b661375e8> 
[17:39:28.902]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.902]  - attr(*, "resolved")= logi FALSE
[17:39:28.902]  - attr(*, "total_size")= num 1248
[17:39:28.904] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:28.904] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.905] Number of futures (= number of chunks): 1
[17:39:28.905] Launching 1 futures (chunks) ...
[17:39:28.905] Chunk #1 of 1 ...
[17:39:28.905]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.905] getGlobalsAndPackages() ...
[17:39:28.905] Searching for globals...
[17:39:28.905] 
[17:39:28.906] Searching for globals ... DONE
[17:39:28.906] - globals: [0] <none>
[17:39:28.906] getGlobalsAndPackages() ... DONE
[17:39:28.906]    + additional globals found: [n=0] 
[17:39:28.906]    + additional namespaces needed: [n=0] 
[17:39:28.906]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.906]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:28.906]  - seeds: <none>
[17:39:28.906] getGlobalsAndPackages() ...
[17:39:28.906] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.907] Resolving globals: FALSE
[17:39:28.907] Tweak future expression to call with '...' arguments ...
[17:39:28.907] {
[17:39:28.907]     do.call(function(...) {
[17:39:28.907]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.907]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.907]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.907]             on.exit(options(oopts), add = TRUE)
[17:39:28.907]         }
[17:39:28.907]         {
[17:39:28.907]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.907]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.907]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.907]             })
[17:39:28.907]         }
[17:39:28.907]     }, args = future.call.arguments)
[17:39:28.907] }
[17:39:28.907] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.908] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.908] - packages: [1] ‘stats’
[17:39:28.908] getGlobalsAndPackages() ... DONE
[17:39:28.908] run() for ‘Future’ ...
[17:39:28.908] - state: ‘created’
[17:39:28.908] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:28.909] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:28.909]   - Field: ‘label’
[17:39:28.909]   - Field: ‘local’
[17:39:28.909]   - Field: ‘owner’
[17:39:28.909]   - Field: ‘envir’
[17:39:28.909]   - Field: ‘packages’
[17:39:28.909]   - Field: ‘gc’
[17:39:28.909]   - Field: ‘conditions’
[17:39:28.910]   - Field: ‘expr’
[17:39:28.910]   - Field: ‘uuid’
[17:39:28.910]   - Field: ‘seed’
[17:39:28.910]   - Field: ‘version’
[17:39:28.910]   - Field: ‘result’
[17:39:28.910]   - Field: ‘asynchronous’
[17:39:28.910]   - Field: ‘calls’
[17:39:28.910]   - Field: ‘globals’
[17:39:28.910]   - Field: ‘stdout’
[17:39:28.910]   - Field: ‘earlySignal’
[17:39:28.911]   - Field: ‘lazy’
[17:39:28.911]   - Field: ‘state’
[17:39:28.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:28.911] - Launch lazy future ...
[17:39:28.911] Packages needed by the future expression (n = 1): ‘stats’
[17:39:28.911] Packages needed by future strategies (n = 0): <none>
[17:39:28.912] {
[17:39:28.912]     {
[17:39:28.912]         {
[17:39:28.912]             ...future.startTime <- base::Sys.time()
[17:39:28.912]             {
[17:39:28.912]                 {
[17:39:28.912]                   {
[17:39:28.912]                     {
[17:39:28.912]                       base::local({
[17:39:28.912]                         has_future <- base::requireNamespace("future", 
[17:39:28.912]                           quietly = TRUE)
[17:39:28.912]                         if (has_future) {
[17:39:28.912]                           ns <- base::getNamespace("future")
[17:39:28.912]                           version <- ns[[".package"]][["version"]]
[17:39:28.912]                           if (is.null(version)) 
[17:39:28.912]                             version <- utils::packageVersion("future")
[17:39:28.912]                         }
[17:39:28.912]                         else {
[17:39:28.912]                           version <- NULL
[17:39:28.912]                         }
[17:39:28.912]                         if (!has_future || version < "1.8.0") {
[17:39:28.912]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.912]                             "", base::R.version$version.string), 
[17:39:28.912]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.912]                               "release", "version")], collapse = " "), 
[17:39:28.912]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.912]                             info)
[17:39:28.912]                           info <- base::paste(info, collapse = "; ")
[17:39:28.912]                           if (!has_future) {
[17:39:28.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.912]                               info)
[17:39:28.912]                           }
[17:39:28.912]                           else {
[17:39:28.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.912]                               info, version)
[17:39:28.912]                           }
[17:39:28.912]                           base::stop(msg)
[17:39:28.912]                         }
[17:39:28.912]                       })
[17:39:28.912]                     }
[17:39:28.912]                     base::local({
[17:39:28.912]                       for (pkg in "stats") {
[17:39:28.912]                         base::loadNamespace(pkg)
[17:39:28.912]                         base::library(pkg, character.only = TRUE)
[17:39:28.912]                       }
[17:39:28.912]                     })
[17:39:28.912]                   }
[17:39:28.912]                   options(future.plan = NULL)
[17:39:28.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.912]                 }
[17:39:28.912]                 ...future.workdir <- getwd()
[17:39:28.912]             }
[17:39:28.912]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.912]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.912]         }
[17:39:28.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.912]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:28.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.912]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.912]             base::names(...future.oldOptions))
[17:39:28.912]     }
[17:39:28.912]     if (FALSE) {
[17:39:28.912]     }
[17:39:28.912]     else {
[17:39:28.912]         if (TRUE) {
[17:39:28.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.912]                 open = "w")
[17:39:28.912]         }
[17:39:28.912]         else {
[17:39:28.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.912]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.912]         }
[17:39:28.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.912]             base::sink(type = "output", split = FALSE)
[17:39:28.912]             base::close(...future.stdout)
[17:39:28.912]         }, add = TRUE)
[17:39:28.912]     }
[17:39:28.912]     ...future.frame <- base::sys.nframe()
[17:39:28.912]     ...future.conditions <- base::list()
[17:39:28.912]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.912]     if (FALSE) {
[17:39:28.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.912]     }
[17:39:28.912]     ...future.result <- base::tryCatch({
[17:39:28.912]         base::withCallingHandlers({
[17:39:28.912]             ...future.value <- base::withVisible(base::local({
[17:39:28.912]                 do.call(function(...) {
[17:39:28.912]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.912]                   if (!identical(...future.globals.maxSize.org, 
[17:39:28.912]                     ...future.globals.maxSize)) {
[17:39:28.912]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.912]                     on.exit(options(oopts), add = TRUE)
[17:39:28.912]                   }
[17:39:28.912]                   {
[17:39:28.912]                     lapply(seq_along(...future.elements_ii), 
[17:39:28.912]                       FUN = function(jj) {
[17:39:28.912]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.912]                         ...future.FUN(...future.X_jj, ...)
[17:39:28.912]                       })
[17:39:28.912]                   }
[17:39:28.912]                 }, args = future.call.arguments)
[17:39:28.912]             }))
[17:39:28.912]             future::FutureResult(value = ...future.value$value, 
[17:39:28.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.912]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.912]                     ...future.globalenv.names))
[17:39:28.912]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.912]         }, condition = base::local({
[17:39:28.912]             c <- base::c
[17:39:28.912]             inherits <- base::inherits
[17:39:28.912]             invokeRestart <- base::invokeRestart
[17:39:28.912]             length <- base::length
[17:39:28.912]             list <- base::list
[17:39:28.912]             seq.int <- base::seq.int
[17:39:28.912]             signalCondition <- base::signalCondition
[17:39:28.912]             sys.calls <- base::sys.calls
[17:39:28.912]             `[[` <- base::`[[`
[17:39:28.912]             `+` <- base::`+`
[17:39:28.912]             `<<-` <- base::`<<-`
[17:39:28.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.912]                   3L)]
[17:39:28.912]             }
[17:39:28.912]             function(cond) {
[17:39:28.912]                 is_error <- inherits(cond, "error")
[17:39:28.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.912]                   NULL)
[17:39:28.912]                 if (is_error) {
[17:39:28.912]                   sessionInformation <- function() {
[17:39:28.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.912]                       search = base::search(), system = base::Sys.info())
[17:39:28.912]                   }
[17:39:28.912]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.912]                     cond$call), session = sessionInformation(), 
[17:39:28.912]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.912]                   signalCondition(cond)
[17:39:28.912]                 }
[17:39:28.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.912]                 "immediateCondition"))) {
[17:39:28.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.912]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.912]                   if (TRUE && !signal) {
[17:39:28.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.912]                     {
[17:39:28.912]                       inherits <- base::inherits
[17:39:28.912]                       invokeRestart <- base::invokeRestart
[17:39:28.912]                       is.null <- base::is.null
[17:39:28.912]                       muffled <- FALSE
[17:39:28.912]                       if (inherits(cond, "message")) {
[17:39:28.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.912]                         if (muffled) 
[17:39:28.912]                           invokeRestart("muffleMessage")
[17:39:28.912]                       }
[17:39:28.912]                       else if (inherits(cond, "warning")) {
[17:39:28.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.912]                         if (muffled) 
[17:39:28.912]                           invokeRestart("muffleWarning")
[17:39:28.912]                       }
[17:39:28.912]                       else if (inherits(cond, "condition")) {
[17:39:28.912]                         if (!is.null(pattern)) {
[17:39:28.912]                           computeRestarts <- base::computeRestarts
[17:39:28.912]                           grepl <- base::grepl
[17:39:28.912]                           restarts <- computeRestarts(cond)
[17:39:28.912]                           for (restart in restarts) {
[17:39:28.912]                             name <- restart$name
[17:39:28.912]                             if (is.null(name)) 
[17:39:28.912]                               next
[17:39:28.912]                             if (!grepl(pattern, name)) 
[17:39:28.912]                               next
[17:39:28.912]                             invokeRestart(restart)
[17:39:28.912]                             muffled <- TRUE
[17:39:28.912]                             break
[17:39:28.912]                           }
[17:39:28.912]                         }
[17:39:28.912]                       }
[17:39:28.912]                       invisible(muffled)
[17:39:28.912]                     }
[17:39:28.912]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.912]                   }
[17:39:28.912]                 }
[17:39:28.912]                 else {
[17:39:28.912]                   if (TRUE) {
[17:39:28.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.912]                     {
[17:39:28.912]                       inherits <- base::inherits
[17:39:28.912]                       invokeRestart <- base::invokeRestart
[17:39:28.912]                       is.null <- base::is.null
[17:39:28.912]                       muffled <- FALSE
[17:39:28.912]                       if (inherits(cond, "message")) {
[17:39:28.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.912]                         if (muffled) 
[17:39:28.912]                           invokeRestart("muffleMessage")
[17:39:28.912]                       }
[17:39:28.912]                       else if (inherits(cond, "warning")) {
[17:39:28.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.912]                         if (muffled) 
[17:39:28.912]                           invokeRestart("muffleWarning")
[17:39:28.912]                       }
[17:39:28.912]                       else if (inherits(cond, "condition")) {
[17:39:28.912]                         if (!is.null(pattern)) {
[17:39:28.912]                           computeRestarts <- base::computeRestarts
[17:39:28.912]                           grepl <- base::grepl
[17:39:28.912]                           restarts <- computeRestarts(cond)
[17:39:28.912]                           for (restart in restarts) {
[17:39:28.912]                             name <- restart$name
[17:39:28.912]                             if (is.null(name)) 
[17:39:28.912]                               next
[17:39:28.912]                             if (!grepl(pattern, name)) 
[17:39:28.912]                               next
[17:39:28.912]                             invokeRestart(restart)
[17:39:28.912]                             muffled <- TRUE
[17:39:28.912]                             break
[17:39:28.912]                           }
[17:39:28.912]                         }
[17:39:28.912]                       }
[17:39:28.912]                       invisible(muffled)
[17:39:28.912]                     }
[17:39:28.912]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.912]                   }
[17:39:28.912]                 }
[17:39:28.912]             }
[17:39:28.912]         }))
[17:39:28.912]     }, error = function(ex) {
[17:39:28.912]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.912]                 ...future.rng), started = ...future.startTime, 
[17:39:28.912]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.912]             version = "1.8"), class = "FutureResult")
[17:39:28.912]     }, finally = {
[17:39:28.912]         if (!identical(...future.workdir, getwd())) 
[17:39:28.912]             setwd(...future.workdir)
[17:39:28.912]         {
[17:39:28.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.912]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.912]             }
[17:39:28.912]             base::options(...future.oldOptions)
[17:39:28.912]             if (.Platform$OS.type == "windows") {
[17:39:28.912]                 old_names <- names(...future.oldEnvVars)
[17:39:28.912]                 envs <- base::Sys.getenv()
[17:39:28.912]                 names <- names(envs)
[17:39:28.912]                 common <- intersect(names, old_names)
[17:39:28.912]                 added <- setdiff(names, old_names)
[17:39:28.912]                 removed <- setdiff(old_names, names)
[17:39:28.912]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.912]                   envs[common]]
[17:39:28.912]                 NAMES <- toupper(changed)
[17:39:28.912]                 args <- list()
[17:39:28.912]                 for (kk in seq_along(NAMES)) {
[17:39:28.912]                   name <- changed[[kk]]
[17:39:28.912]                   NAME <- NAMES[[kk]]
[17:39:28.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.912]                     next
[17:39:28.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.912]                 }
[17:39:28.912]                 NAMES <- toupper(added)
[17:39:28.912]                 for (kk in seq_along(NAMES)) {
[17:39:28.912]                   name <- added[[kk]]
[17:39:28.912]                   NAME <- NAMES[[kk]]
[17:39:28.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.912]                     next
[17:39:28.912]                   args[[name]] <- ""
[17:39:28.912]                 }
[17:39:28.912]                 NAMES <- toupper(removed)
[17:39:28.912]                 for (kk in seq_along(NAMES)) {
[17:39:28.912]                   name <- removed[[kk]]
[17:39:28.912]                   NAME <- NAMES[[kk]]
[17:39:28.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.912]                     next
[17:39:28.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.912]                 }
[17:39:28.912]                 if (length(args) > 0) 
[17:39:28.912]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.912]             }
[17:39:28.912]             else {
[17:39:28.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.912]             }
[17:39:28.912]             {
[17:39:28.912]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.912]                   0L) {
[17:39:28.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.912]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.912]                   base::options(opts)
[17:39:28.912]                 }
[17:39:28.912]                 {
[17:39:28.912]                   {
[17:39:28.912]                     NULL
[17:39:28.912]                     RNGkind("Mersenne-Twister")
[17:39:28.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:28.912]                       inherits = FALSE)
[17:39:28.912]                   }
[17:39:28.912]                   options(future.plan = NULL)
[17:39:28.912]                   if (is.na(NA_character_)) 
[17:39:28.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.912]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:28.912]                   {
[17:39:28.912]                     future <- SequentialFuture(..., envir = envir)
[17:39:28.912]                     if (!future$lazy) 
[17:39:28.912]                       future <- run(future)
[17:39:28.912]                     invisible(future)
[17:39:28.912]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.912]                 }
[17:39:28.912]             }
[17:39:28.912]         }
[17:39:28.912]     })
[17:39:28.912]     if (TRUE) {
[17:39:28.912]         base::sink(type = "output", split = FALSE)
[17:39:28.912]         if (TRUE) {
[17:39:28.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.912]         }
[17:39:28.912]         else {
[17:39:28.912]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.912]         }
[17:39:28.912]         base::close(...future.stdout)
[17:39:28.912]         ...future.stdout <- NULL
[17:39:28.912]     }
[17:39:28.912]     ...future.result$conditions <- ...future.conditions
[17:39:28.912]     ...future.result$finished <- base::Sys.time()
[17:39:28.912]     ...future.result
[17:39:28.912] }
[17:39:28.914] assign_globals() ...
[17:39:28.914] List of 5
[17:39:28.914]  $ ...future.FUN            :function (x, ...)  
[17:39:28.914]  $ future.call.arguments    : list()
[17:39:28.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.914]  $ ...future.elements_ii    :List of 3
[17:39:28.914]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:39:28.914]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:28.914]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:28.914]  $ ...future.seeds_ii       : NULL
[17:39:28.914]  $ ...future.globals.maxSize: NULL
[17:39:28.914]  - attr(*, "resolved")= logi FALSE
[17:39:28.914]  - attr(*, "total_size")= num 1248
[17:39:28.914]  - attr(*, "where")=List of 5
[17:39:28.914]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:28.914]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:28.914]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:28.914]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:28.914]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:28.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.914]  - attr(*, "already-done")= logi TRUE
[17:39:28.921] - copied ‘...future.FUN’ to environment
[17:39:28.921] - copied ‘future.call.arguments’ to environment
[17:39:28.921] - copied ‘...future.elements_ii’ to environment
[17:39:28.922] - copied ‘...future.seeds_ii’ to environment
[17:39:28.922] - copied ‘...future.globals.maxSize’ to environment
[17:39:28.922] assign_globals() ... done
[17:39:28.922] plan(): Setting new future strategy stack:
[17:39:28.922] List of future strategies:
[17:39:28.922] 1. sequential:
[17:39:28.922]    - args: function (..., envir = parent.frame())
[17:39:28.922]    - tweaked: FALSE
[17:39:28.922]    - call: NULL
[17:39:28.923] plan(): nbrOfWorkers() = 1
[17:39:28.924] plan(): Setting new future strategy stack:
[17:39:28.924] List of future strategies:
[17:39:28.924] 1. sequential:
[17:39:28.924]    - args: function (..., envir = parent.frame())
[17:39:28.924]    - tweaked: FALSE
[17:39:28.924]    - call: plan(strategy)
[17:39:28.925] plan(): nbrOfWorkers() = 1
[17:39:28.925] SequentialFuture started (and completed)
[17:39:28.925] - Launch lazy future ... done
[17:39:28.925] run() for ‘SequentialFuture’ ... done
[17:39:28.925] Created future:
[17:39:28.925] SequentialFuture:
[17:39:28.925] Label: ‘future_eapply-1’
[17:39:28.925] Expression:
[17:39:28.925] {
[17:39:28.925]     do.call(function(...) {
[17:39:28.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.925]             on.exit(options(oopts), add = TRUE)
[17:39:28.925]         }
[17:39:28.925]         {
[17:39:28.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.925]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.925]             })
[17:39:28.925]         }
[17:39:28.925]     }, args = future.call.arguments)
[17:39:28.925] }
[17:39:28.925] Lazy evaluation: FALSE
[17:39:28.925] Asynchronous evaluation: FALSE
[17:39:28.925] Local evaluation: TRUE
[17:39:28.925] Environment: R_GlobalEnv
[17:39:28.925] Capture standard output: TRUE
[17:39:28.925] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.925] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.925] Packages: 1 packages (‘stats’)
[17:39:28.925] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.925] Resolved: TRUE
[17:39:28.925] Value: 1.71 KiB of class ‘list’
[17:39:28.925] Early signaling: FALSE
[17:39:28.925] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:28.925] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:28.926] Chunk #1 of 1 ... DONE
[17:39:28.926] Launching 1 futures (chunks) ... DONE
[17:39:28.926] Resolving 1 futures (chunks) ...
[17:39:28.927] resolve() on list ...
[17:39:28.927]  recursive: 0
[17:39:28.927]  length: 1
[17:39:28.927] 
[17:39:28.927] resolved() for ‘SequentialFuture’ ...
[17:39:28.927] - state: ‘finished’
[17:39:28.927] - run: TRUE
[17:39:28.927] - result: ‘FutureResult’
[17:39:28.927] resolved() for ‘SequentialFuture’ ... done
[17:39:28.927] Future #1
[17:39:28.928] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:28.928] - nx: 1
[17:39:28.928] - relay: TRUE
[17:39:28.928] - stdout: TRUE
[17:39:28.928] - signal: TRUE
[17:39:28.928] - resignal: FALSE
[17:39:28.928] - force: TRUE
[17:39:28.928] - relayed: [n=1] FALSE
[17:39:28.928] - queued futures: [n=1] FALSE
[17:39:28.928]  - until=1
[17:39:28.929]  - relaying element #1
[17:39:28.929] - relayed: [n=1] TRUE
[17:39:28.929] - queued futures: [n=1] TRUE
[17:39:28.929] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:28.929]  length: 0 (resolved future 1)
[17:39:28.929] Relaying remaining futures
[17:39:28.929] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.929] - nx: 1
[17:39:28.929] - relay: TRUE
[17:39:28.929] - stdout: TRUE
[17:39:28.930] - signal: TRUE
[17:39:28.930] - resignal: FALSE
[17:39:28.930] - force: TRUE
[17:39:28.930] - relayed: [n=1] TRUE
[17:39:28.930] - queued futures: [n=1] TRUE
 - flush all
[17:39:28.930] - relayed: [n=1] TRUE
[17:39:28.930] - queued futures: [n=1] TRUE
[17:39:28.930] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.930] resolve() on list ... DONE
[17:39:28.930]  - Number of value chunks collected: 1
[17:39:28.931] Resolving 1 futures (chunks) ... DONE
[17:39:28.931] Reducing values from 1 chunks ...
[17:39:28.931]  - Number of values collected after concatenation: 3
[17:39:28.931]  - Number of values expected: 3
[17:39:28.931] Reducing values from 1 chunks ... DONE
[17:39:28.931] future_lapply() ... DONE
[17:39:28.931] plan(): Setting new future strategy stack:
[17:39:28.931] List of future strategies:
[17:39:28.931] 1. sequential:
[17:39:28.931]    - args: function (..., envir = parent.frame())
[17:39:28.931]    - tweaked: FALSE
[17:39:28.931]    - call: plan(sequential)
[17:39:28.932] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:39:28.932] plan(): Setting new future strategy stack:
[17:39:28.932] List of future strategies:
[17:39:28.932] 1. multicore:
[17:39:28.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:28.932]    - tweaked: FALSE
[17:39:28.932]    - call: plan(strategy)
[17:39:28.936] plan(): nbrOfWorkers() = 2
[17:39:28.937] future_lapply() ...
[17:39:28.941] Number of chunks: 2
[17:39:28.942] getGlobalsAndPackagesXApply() ...
[17:39:28.942]  - future.globals: TRUE
[17:39:28.942] getGlobalsAndPackages() ...
[17:39:28.942] Searching for globals...
[17:39:28.943] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.943] Searching for globals ... DONE
[17:39:28.943] Resolving globals: FALSE
[17:39:28.944] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:28.944] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:28.944] - globals: [1] ‘FUN’
[17:39:28.944] 
[17:39:28.944] getGlobalsAndPackages() ... DONE
[17:39:28.944]  - globals found/used: [n=1] ‘FUN’
[17:39:28.945]  - needed namespaces: [n=0] 
[17:39:28.945] Finding globals ... DONE
[17:39:28.945]  - use_args: TRUE
[17:39:28.945]  - Getting '...' globals ...
[17:39:28.945] resolve() on list ...
[17:39:28.945]  recursive: 0
[17:39:28.945]  length: 1
[17:39:28.945]  elements: ‘...’
[17:39:28.946]  length: 0 (resolved future 1)
[17:39:28.946] resolve() on list ... DONE
[17:39:28.946]    - '...' content: [n=0] 
[17:39:28.946] List of 1
[17:39:28.946]  $ ...: list()
[17:39:28.946]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.946]  - attr(*, "where")=List of 1
[17:39:28.946]   ..$ ...:<environment: 0x555b65839738> 
[17:39:28.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.946]  - attr(*, "resolved")= logi TRUE
[17:39:28.946]  - attr(*, "total_size")= num NA
[17:39:28.949]  - Getting '...' globals ... DONE
[17:39:28.949] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.949] List of 2
[17:39:28.949]  $ ...future.FUN:function (x, ...)  
[17:39:28.949]  $ ...          : list()
[17:39:28.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.949]  - attr(*, "where")=List of 2
[17:39:28.949]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.949]   ..$ ...          :<environment: 0x555b65839738> 
[17:39:28.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.949]  - attr(*, "resolved")= logi FALSE
[17:39:28.949]  - attr(*, "total_size")= num 1240
[17:39:28.954] Packages to be attached in all futures: [n=0] 
[17:39:28.954] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.954] Number of futures (= number of chunks): 2
[17:39:28.954] Launching 2 futures (chunks) ...
[17:39:28.954] Chunk #1 of 2 ...
[17:39:28.955]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.955] getGlobalsAndPackages() ...
[17:39:28.955] Searching for globals...
[17:39:28.955] 
[17:39:28.955] Searching for globals ... DONE
[17:39:28.955] - globals: [0] <none>
[17:39:28.955] getGlobalsAndPackages() ... DONE
[17:39:28.956]    + additional globals found: [n=0] 
[17:39:28.956]    + additional namespaces needed: [n=0] 
[17:39:28.956]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.956]  - seeds: <none>
[17:39:28.956] getGlobalsAndPackages() ...
[17:39:28.956] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.956] Resolving globals: FALSE
[17:39:28.956] Tweak future expression to call with '...' arguments ...
[17:39:28.956] {
[17:39:28.956]     do.call(function(...) {
[17:39:28.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.956]             on.exit(options(oopts), add = TRUE)
[17:39:28.956]         }
[17:39:28.956]         {
[17:39:28.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.956]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.956]             })
[17:39:28.956]         }
[17:39:28.956]     }, args = future.call.arguments)
[17:39:28.956] }
[17:39:28.957] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.957] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.957] 
[17:39:28.957] getGlobalsAndPackages() ... DONE
[17:39:28.958] run() for ‘Future’ ...
[17:39:28.958] - state: ‘created’
[17:39:28.958] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:28.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:28.962]   - Field: ‘label’
[17:39:28.962]   - Field: ‘local’
[17:39:28.962]   - Field: ‘owner’
[17:39:28.962]   - Field: ‘envir’
[17:39:28.963]   - Field: ‘workers’
[17:39:28.963]   - Field: ‘packages’
[17:39:28.963]   - Field: ‘gc’
[17:39:28.963]   - Field: ‘job’
[17:39:28.963]   - Field: ‘conditions’
[17:39:28.963]   - Field: ‘expr’
[17:39:28.963]   - Field: ‘uuid’
[17:39:28.963]   - Field: ‘seed’
[17:39:28.963]   - Field: ‘version’
[17:39:28.963]   - Field: ‘result’
[17:39:28.964]   - Field: ‘asynchronous’
[17:39:28.964]   - Field: ‘calls’
[17:39:28.964]   - Field: ‘globals’
[17:39:28.964]   - Field: ‘stdout’
[17:39:28.964]   - Field: ‘earlySignal’
[17:39:28.964]   - Field: ‘lazy’
[17:39:28.964]   - Field: ‘state’
[17:39:28.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:28.964] - Launch lazy future ...
[17:39:28.965] Packages needed by the future expression (n = 0): <none>
[17:39:28.966] Packages needed by future strategies (n = 0): <none>
[17:39:28.966] {
[17:39:28.966]     {
[17:39:28.966]         {
[17:39:28.966]             ...future.startTime <- base::Sys.time()
[17:39:28.966]             {
[17:39:28.966]                 {
[17:39:28.966]                   {
[17:39:28.966]                     {
[17:39:28.966]                       base::local({
[17:39:28.966]                         has_future <- base::requireNamespace("future", 
[17:39:28.966]                           quietly = TRUE)
[17:39:28.966]                         if (has_future) {
[17:39:28.966]                           ns <- base::getNamespace("future")
[17:39:28.966]                           version <- ns[[".package"]][["version"]]
[17:39:28.966]                           if (is.null(version)) 
[17:39:28.966]                             version <- utils::packageVersion("future")
[17:39:28.966]                         }
[17:39:28.966]                         else {
[17:39:28.966]                           version <- NULL
[17:39:28.966]                         }
[17:39:28.966]                         if (!has_future || version < "1.8.0") {
[17:39:28.966]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.966]                             "", base::R.version$version.string), 
[17:39:28.966]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.966]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.966]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.966]                               "release", "version")], collapse = " "), 
[17:39:28.966]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.966]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.966]                             info)
[17:39:28.966]                           info <- base::paste(info, collapse = "; ")
[17:39:28.966]                           if (!has_future) {
[17:39:28.966]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.966]                               info)
[17:39:28.966]                           }
[17:39:28.966]                           else {
[17:39:28.966]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.966]                               info, version)
[17:39:28.966]                           }
[17:39:28.966]                           base::stop(msg)
[17:39:28.966]                         }
[17:39:28.966]                       })
[17:39:28.966]                     }
[17:39:28.966]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.966]                     base::options(mc.cores = 1L)
[17:39:28.966]                   }
[17:39:28.966]                   options(future.plan = NULL)
[17:39:28.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.966]                 }
[17:39:28.966]                 ...future.workdir <- getwd()
[17:39:28.966]             }
[17:39:28.966]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.966]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.966]         }
[17:39:28.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:28.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.966]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.966]             base::names(...future.oldOptions))
[17:39:28.966]     }
[17:39:28.966]     if (FALSE) {
[17:39:28.966]     }
[17:39:28.966]     else {
[17:39:28.966]         if (TRUE) {
[17:39:28.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.966]                 open = "w")
[17:39:28.966]         }
[17:39:28.966]         else {
[17:39:28.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.966]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.966]         }
[17:39:28.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.966]             base::sink(type = "output", split = FALSE)
[17:39:28.966]             base::close(...future.stdout)
[17:39:28.966]         }, add = TRUE)
[17:39:28.966]     }
[17:39:28.966]     ...future.frame <- base::sys.nframe()
[17:39:28.966]     ...future.conditions <- base::list()
[17:39:28.966]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.966]     if (FALSE) {
[17:39:28.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.966]     }
[17:39:28.966]     ...future.result <- base::tryCatch({
[17:39:28.966]         base::withCallingHandlers({
[17:39:28.966]             ...future.value <- base::withVisible(base::local({
[17:39:28.966]                 withCallingHandlers({
[17:39:28.966]                   {
[17:39:28.966]                     do.call(function(...) {
[17:39:28.966]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.966]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.966]                         ...future.globals.maxSize)) {
[17:39:28.966]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.966]                         on.exit(options(oopts), add = TRUE)
[17:39:28.966]                       }
[17:39:28.966]                       {
[17:39:28.966]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.966]                           FUN = function(jj) {
[17:39:28.966]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.966]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.966]                           })
[17:39:28.966]                       }
[17:39:28.966]                     }, args = future.call.arguments)
[17:39:28.966]                   }
[17:39:28.966]                 }, immediateCondition = function(cond) {
[17:39:28.966]                   save_rds <- function (object, pathname, ...) 
[17:39:28.966]                   {
[17:39:28.966]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:28.966]                     if (file_test("-f", pathname_tmp)) {
[17:39:28.966]                       fi_tmp <- file.info(pathname_tmp)
[17:39:28.966]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:28.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:28.966]                         fi_tmp[["mtime"]])
[17:39:28.966]                     }
[17:39:28.966]                     tryCatch({
[17:39:28.966]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:28.966]                     }, error = function(ex) {
[17:39:28.966]                       msg <- conditionMessage(ex)
[17:39:28.966]                       fi_tmp <- file.info(pathname_tmp)
[17:39:28.966]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:28.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:28.966]                         fi_tmp[["mtime"]], msg)
[17:39:28.966]                       ex$message <- msg
[17:39:28.966]                       stop(ex)
[17:39:28.966]                     })
[17:39:28.966]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:28.966]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:28.966]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:28.966]                       fi_tmp <- file.info(pathname_tmp)
[17:39:28.966]                       fi <- file.info(pathname)
[17:39:28.966]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:28.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:28.966]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:28.966]                         fi[["size"]], fi[["mtime"]])
[17:39:28.966]                       stop(msg)
[17:39:28.966]                     }
[17:39:28.966]                     invisible(pathname)
[17:39:28.966]                   }
[17:39:28.966]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:28.966]                     rootPath = tempdir()) 
[17:39:28.966]                   {
[17:39:28.966]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:28.966]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:28.966]                       tmpdir = path, fileext = ".rds")
[17:39:28.966]                     save_rds(obj, file)
[17:39:28.966]                   }
[17:39:28.966]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:28.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.966]                   {
[17:39:28.966]                     inherits <- base::inherits
[17:39:28.966]                     invokeRestart <- base::invokeRestart
[17:39:28.966]                     is.null <- base::is.null
[17:39:28.966]                     muffled <- FALSE
[17:39:28.966]                     if (inherits(cond, "message")) {
[17:39:28.966]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.966]                       if (muffled) 
[17:39:28.966]                         invokeRestart("muffleMessage")
[17:39:28.966]                     }
[17:39:28.966]                     else if (inherits(cond, "warning")) {
[17:39:28.966]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.966]                       if (muffled) 
[17:39:28.966]                         invokeRestart("muffleWarning")
[17:39:28.966]                     }
[17:39:28.966]                     else if (inherits(cond, "condition")) {
[17:39:28.966]                       if (!is.null(pattern)) {
[17:39:28.966]                         computeRestarts <- base::computeRestarts
[17:39:28.966]                         grepl <- base::grepl
[17:39:28.966]                         restarts <- computeRestarts(cond)
[17:39:28.966]                         for (restart in restarts) {
[17:39:28.966]                           name <- restart$name
[17:39:28.966]                           if (is.null(name)) 
[17:39:28.966]                             next
[17:39:28.966]                           if (!grepl(pattern, name)) 
[17:39:28.966]                             next
[17:39:28.966]                           invokeRestart(restart)
[17:39:28.966]                           muffled <- TRUE
[17:39:28.966]                           break
[17:39:28.966]                         }
[17:39:28.966]                       }
[17:39:28.966]                     }
[17:39:28.966]                     invisible(muffled)
[17:39:28.966]                   }
[17:39:28.966]                   muffleCondition(cond)
[17:39:28.966]                 })
[17:39:28.966]             }))
[17:39:28.966]             future::FutureResult(value = ...future.value$value, 
[17:39:28.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.966]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.966]                     ...future.globalenv.names))
[17:39:28.966]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.966]         }, condition = base::local({
[17:39:28.966]             c <- base::c
[17:39:28.966]             inherits <- base::inherits
[17:39:28.966]             invokeRestart <- base::invokeRestart
[17:39:28.966]             length <- base::length
[17:39:28.966]             list <- base::list
[17:39:28.966]             seq.int <- base::seq.int
[17:39:28.966]             signalCondition <- base::signalCondition
[17:39:28.966]             sys.calls <- base::sys.calls
[17:39:28.966]             `[[` <- base::`[[`
[17:39:28.966]             `+` <- base::`+`
[17:39:28.966]             `<<-` <- base::`<<-`
[17:39:28.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.966]                   3L)]
[17:39:28.966]             }
[17:39:28.966]             function(cond) {
[17:39:28.966]                 is_error <- inherits(cond, "error")
[17:39:28.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.966]                   NULL)
[17:39:28.966]                 if (is_error) {
[17:39:28.966]                   sessionInformation <- function() {
[17:39:28.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.966]                       search = base::search(), system = base::Sys.info())
[17:39:28.966]                   }
[17:39:28.966]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.966]                     cond$call), session = sessionInformation(), 
[17:39:28.966]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.966]                   signalCondition(cond)
[17:39:28.966]                 }
[17:39:28.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.966]                 "immediateCondition"))) {
[17:39:28.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.966]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.966]                   if (TRUE && !signal) {
[17:39:28.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.966]                     {
[17:39:28.966]                       inherits <- base::inherits
[17:39:28.966]                       invokeRestart <- base::invokeRestart
[17:39:28.966]                       is.null <- base::is.null
[17:39:28.966]                       muffled <- FALSE
[17:39:28.966]                       if (inherits(cond, "message")) {
[17:39:28.966]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.966]                         if (muffled) 
[17:39:28.966]                           invokeRestart("muffleMessage")
[17:39:28.966]                       }
[17:39:28.966]                       else if (inherits(cond, "warning")) {
[17:39:28.966]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.966]                         if (muffled) 
[17:39:28.966]                           invokeRestart("muffleWarning")
[17:39:28.966]                       }
[17:39:28.966]                       else if (inherits(cond, "condition")) {
[17:39:28.966]                         if (!is.null(pattern)) {
[17:39:28.966]                           computeRestarts <- base::computeRestarts
[17:39:28.966]                           grepl <- base::grepl
[17:39:28.966]                           restarts <- computeRestarts(cond)
[17:39:28.966]                           for (restart in restarts) {
[17:39:28.966]                             name <- restart$name
[17:39:28.966]                             if (is.null(name)) 
[17:39:28.966]                               next
[17:39:28.966]                             if (!grepl(pattern, name)) 
[17:39:28.966]                               next
[17:39:28.966]                             invokeRestart(restart)
[17:39:28.966]                             muffled <- TRUE
[17:39:28.966]                             break
[17:39:28.966]                           }
[17:39:28.966]                         }
[17:39:28.966]                       }
[17:39:28.966]                       invisible(muffled)
[17:39:28.966]                     }
[17:39:28.966]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.966]                   }
[17:39:28.966]                 }
[17:39:28.966]                 else {
[17:39:28.966]                   if (TRUE) {
[17:39:28.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.966]                     {
[17:39:28.966]                       inherits <- base::inherits
[17:39:28.966]                       invokeRestart <- base::invokeRestart
[17:39:28.966]                       is.null <- base::is.null
[17:39:28.966]                       muffled <- FALSE
[17:39:28.966]                       if (inherits(cond, "message")) {
[17:39:28.966]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.966]                         if (muffled) 
[17:39:28.966]                           invokeRestart("muffleMessage")
[17:39:28.966]                       }
[17:39:28.966]                       else if (inherits(cond, "warning")) {
[17:39:28.966]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.966]                         if (muffled) 
[17:39:28.966]                           invokeRestart("muffleWarning")
[17:39:28.966]                       }
[17:39:28.966]                       else if (inherits(cond, "condition")) {
[17:39:28.966]                         if (!is.null(pattern)) {
[17:39:28.966]                           computeRestarts <- base::computeRestarts
[17:39:28.966]                           grepl <- base::grepl
[17:39:28.966]                           restarts <- computeRestarts(cond)
[17:39:28.966]                           for (restart in restarts) {
[17:39:28.966]                             name <- restart$name
[17:39:28.966]                             if (is.null(name)) 
[17:39:28.966]                               next
[17:39:28.966]                             if (!grepl(pattern, name)) 
[17:39:28.966]                               next
[17:39:28.966]                             invokeRestart(restart)
[17:39:28.966]                             muffled <- TRUE
[17:39:28.966]                             break
[17:39:28.966]                           }
[17:39:28.966]                         }
[17:39:28.966]                       }
[17:39:28.966]                       invisible(muffled)
[17:39:28.966]                     }
[17:39:28.966]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.966]                   }
[17:39:28.966]                 }
[17:39:28.966]             }
[17:39:28.966]         }))
[17:39:28.966]     }, error = function(ex) {
[17:39:28.966]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.966]                 ...future.rng), started = ...future.startTime, 
[17:39:28.966]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.966]             version = "1.8"), class = "FutureResult")
[17:39:28.966]     }, finally = {
[17:39:28.966]         if (!identical(...future.workdir, getwd())) 
[17:39:28.966]             setwd(...future.workdir)
[17:39:28.966]         {
[17:39:28.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.966]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.966]             }
[17:39:28.966]             base::options(...future.oldOptions)
[17:39:28.966]             if (.Platform$OS.type == "windows") {
[17:39:28.966]                 old_names <- names(...future.oldEnvVars)
[17:39:28.966]                 envs <- base::Sys.getenv()
[17:39:28.966]                 names <- names(envs)
[17:39:28.966]                 common <- intersect(names, old_names)
[17:39:28.966]                 added <- setdiff(names, old_names)
[17:39:28.966]                 removed <- setdiff(old_names, names)
[17:39:28.966]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.966]                   envs[common]]
[17:39:28.966]                 NAMES <- toupper(changed)
[17:39:28.966]                 args <- list()
[17:39:28.966]                 for (kk in seq_along(NAMES)) {
[17:39:28.966]                   name <- changed[[kk]]
[17:39:28.966]                   NAME <- NAMES[[kk]]
[17:39:28.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.966]                     next
[17:39:28.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.966]                 }
[17:39:28.966]                 NAMES <- toupper(added)
[17:39:28.966]                 for (kk in seq_along(NAMES)) {
[17:39:28.966]                   name <- added[[kk]]
[17:39:28.966]                   NAME <- NAMES[[kk]]
[17:39:28.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.966]                     next
[17:39:28.966]                   args[[name]] <- ""
[17:39:28.966]                 }
[17:39:28.966]                 NAMES <- toupper(removed)
[17:39:28.966]                 for (kk in seq_along(NAMES)) {
[17:39:28.966]                   name <- removed[[kk]]
[17:39:28.966]                   NAME <- NAMES[[kk]]
[17:39:28.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.966]                     next
[17:39:28.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.966]                 }
[17:39:28.966]                 if (length(args) > 0) 
[17:39:28.966]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.966]             }
[17:39:28.966]             else {
[17:39:28.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.966]             }
[17:39:28.966]             {
[17:39:28.966]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.966]                   0L) {
[17:39:28.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.966]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.966]                   base::options(opts)
[17:39:28.966]                 }
[17:39:28.966]                 {
[17:39:28.966]                   {
[17:39:28.966]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.966]                     NULL
[17:39:28.966]                   }
[17:39:28.966]                   options(future.plan = NULL)
[17:39:28.966]                   if (is.na(NA_character_)) 
[17:39:28.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.966]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:28.966]                     envir = parent.frame()) 
[17:39:28.966]                   {
[17:39:28.966]                     default_workers <- missing(workers)
[17:39:28.966]                     if (is.function(workers)) 
[17:39:28.966]                       workers <- workers()
[17:39:28.966]                     workers <- structure(as.integer(workers), 
[17:39:28.966]                       class = class(workers))
[17:39:28.966]                     stop_if_not(is.finite(workers), workers >= 
[17:39:28.966]                       1L)
[17:39:28.966]                     if ((workers == 1L && !inherits(workers, 
[17:39:28.966]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:28.966]                       if (default_workers) 
[17:39:28.966]                         supportsMulticore(warn = TRUE)
[17:39:28.966]                       return(sequential(..., envir = envir))
[17:39:28.966]                     }
[17:39:28.966]                     oopts <- options(mc.cores = workers)
[17:39:28.966]                     on.exit(options(oopts))
[17:39:28.966]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:28.966]                       envir = envir)
[17:39:28.966]                     if (!future$lazy) 
[17:39:28.966]                       future <- run(future)
[17:39:28.966]                     invisible(future)
[17:39:28.966]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.966]                 }
[17:39:28.966]             }
[17:39:28.966]         }
[17:39:28.966]     })
[17:39:28.966]     if (TRUE) {
[17:39:28.966]         base::sink(type = "output", split = FALSE)
[17:39:28.966]         if (TRUE) {
[17:39:28.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.966]         }
[17:39:28.966]         else {
[17:39:28.966]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.966]         }
[17:39:28.966]         base::close(...future.stdout)
[17:39:28.966]         ...future.stdout <- NULL
[17:39:28.966]     }
[17:39:28.966]     ...future.result$conditions <- ...future.conditions
[17:39:28.966]     ...future.result$finished <- base::Sys.time()
[17:39:28.966]     ...future.result
[17:39:28.966] }
[17:39:28.969] assign_globals() ...
[17:39:28.969] List of 5
[17:39:28.969]  $ ...future.FUN            :function (x, ...)  
[17:39:28.969]  $ future.call.arguments    : list()
[17:39:28.969]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.969]  $ ...future.elements_ii    :List of 1
[17:39:28.969]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:39:28.969]  $ ...future.seeds_ii       : NULL
[17:39:28.969]  $ ...future.globals.maxSize: NULL
[17:39:28.969]  - attr(*, "where")=List of 5
[17:39:28.969]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:28.969]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:28.969]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:28.969]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:28.969]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:28.969]  - attr(*, "resolved")= logi FALSE
[17:39:28.969]  - attr(*, "total_size")= num 1240
[17:39:28.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.969]  - attr(*, "already-done")= logi TRUE
[17:39:28.973] - copied ‘...future.FUN’ to environment
[17:39:28.974] - copied ‘future.call.arguments’ to environment
[17:39:28.974] - copied ‘...future.elements_ii’ to environment
[17:39:28.974] - copied ‘...future.seeds_ii’ to environment
[17:39:28.974] - copied ‘...future.globals.maxSize’ to environment
[17:39:28.974] assign_globals() ... done
[17:39:28.974] requestCore(): workers = 2
[17:39:28.977] MulticoreFuture started
[17:39:28.978] - Launch lazy future ... done
[17:39:28.978] run() for ‘MulticoreFuture’ ... done
[17:39:28.978] plan(): Setting new future strategy stack:
[17:39:28.978] Created future:
[17:39:28.978] List of future strategies:
[17:39:28.978] 1. sequential:
[17:39:28.978]    - args: function (..., envir = parent.frame())
[17:39:28.978]    - tweaked: FALSE
[17:39:28.978]    - call: NULL
[17:39:28.979] plan(): nbrOfWorkers() = 1
[17:39:28.981] plan(): Setting new future strategy stack:
[17:39:28.981] List of future strategies:
[17:39:28.981] 1. multicore:
[17:39:28.981]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:28.981]    - tweaked: FALSE
[17:39:28.981]    - call: plan(strategy)
[17:39:28.987] plan(): nbrOfWorkers() = 2
[17:39:28.979] MulticoreFuture:
[17:39:28.979] Label: ‘future_eapply-1’
[17:39:28.979] Expression:
[17:39:28.979] {
[17:39:28.979]     do.call(function(...) {
[17:39:28.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.979]             on.exit(options(oopts), add = TRUE)
[17:39:28.979]         }
[17:39:28.979]         {
[17:39:28.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.979]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.979]             })
[17:39:28.979]         }
[17:39:28.979]     }, args = future.call.arguments)
[17:39:28.979] }
[17:39:28.979] Lazy evaluation: FALSE
[17:39:28.979] Asynchronous evaluation: TRUE
[17:39:28.979] Local evaluation: TRUE
[17:39:28.979] Environment: R_GlobalEnv
[17:39:28.979] Capture standard output: TRUE
[17:39:28.979] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.979] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.979] Packages: <none>
[17:39:28.979] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.979] Resolved: TRUE
[17:39:28.979] Value: <not collected>
[17:39:28.979] Conditions captured: <none>
[17:39:28.979] Early signaling: FALSE
[17:39:28.979] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:28.979] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.988] Chunk #1 of 2 ... DONE
[17:39:28.988] Chunk #2 of 2 ...
[17:39:28.988]  - Finding globals in 'X' for chunk #2 ...
[17:39:28.989] getGlobalsAndPackages() ...
[17:39:28.989] Searching for globals...
[17:39:28.989] 
[17:39:28.989] Searching for globals ... DONE
[17:39:28.989] - globals: [0] <none>
[17:39:28.990] getGlobalsAndPackages() ... DONE
[17:39:28.990]    + additional globals found: [n=0] 
[17:39:28.990]    + additional namespaces needed: [n=0] 
[17:39:28.990]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:28.990]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:28.990]  - seeds: <none>
[17:39:28.990] getGlobalsAndPackages() ...
[17:39:28.991] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.991] Resolving globals: FALSE
[17:39:28.991] Tweak future expression to call with '...' arguments ...
[17:39:28.991] {
[17:39:28.991]     do.call(function(...) {
[17:39:28.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.991]             on.exit(options(oopts), add = TRUE)
[17:39:28.991]         }
[17:39:28.991]         {
[17:39:28.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.991]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.991]             })
[17:39:28.991]         }
[17:39:28.991]     }, args = future.call.arguments)
[17:39:28.991] }
[17:39:28.992] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.992] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.992] 
[17:39:28.993] getGlobalsAndPackages() ... DONE
[17:39:28.993] run() for ‘Future’ ...
[17:39:28.997] - state: ‘created’
[17:39:28.998] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.004]   - Field: ‘label’
[17:39:29.004]   - Field: ‘local’
[17:39:29.004]   - Field: ‘owner’
[17:39:29.004]   - Field: ‘envir’
[17:39:29.005]   - Field: ‘workers’
[17:39:29.005]   - Field: ‘packages’
[17:39:29.005]   - Field: ‘gc’
[17:39:29.005]   - Field: ‘job’
[17:39:29.005]   - Field: ‘conditions’
[17:39:29.005]   - Field: ‘expr’
[17:39:29.006]   - Field: ‘uuid’
[17:39:29.006]   - Field: ‘seed’
[17:39:29.006]   - Field: ‘version’
[17:39:29.006]   - Field: ‘result’
[17:39:29.006]   - Field: ‘asynchronous’
[17:39:29.006]   - Field: ‘calls’
[17:39:29.007]   - Field: ‘globals’
[17:39:29.007]   - Field: ‘stdout’
[17:39:29.007]   - Field: ‘earlySignal’
[17:39:29.007]   - Field: ‘lazy’
[17:39:29.007]   - Field: ‘state’
[17:39:29.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.008] - Launch lazy future ...
[17:39:29.008] Packages needed by the future expression (n = 0): <none>
[17:39:29.008] Packages needed by future strategies (n = 0): <none>
[17:39:29.009] {
[17:39:29.009]     {
[17:39:29.009]         {
[17:39:29.009]             ...future.startTime <- base::Sys.time()
[17:39:29.009]             {
[17:39:29.009]                 {
[17:39:29.009]                   {
[17:39:29.009]                     {
[17:39:29.009]                       base::local({
[17:39:29.009]                         has_future <- base::requireNamespace("future", 
[17:39:29.009]                           quietly = TRUE)
[17:39:29.009]                         if (has_future) {
[17:39:29.009]                           ns <- base::getNamespace("future")
[17:39:29.009]                           version <- ns[[".package"]][["version"]]
[17:39:29.009]                           if (is.null(version)) 
[17:39:29.009]                             version <- utils::packageVersion("future")
[17:39:29.009]                         }
[17:39:29.009]                         else {
[17:39:29.009]                           version <- NULL
[17:39:29.009]                         }
[17:39:29.009]                         if (!has_future || version < "1.8.0") {
[17:39:29.009]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.009]                             "", base::R.version$version.string), 
[17:39:29.009]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:29.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:29.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.009]                               "release", "version")], collapse = " "), 
[17:39:29.009]                             hostname = base::Sys.info()[["nodename"]])
[17:39:29.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.009]                             info)
[17:39:29.009]                           info <- base::paste(info, collapse = "; ")
[17:39:29.009]                           if (!has_future) {
[17:39:29.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.009]                               info)
[17:39:29.009]                           }
[17:39:29.009]                           else {
[17:39:29.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.009]                               info, version)
[17:39:29.009]                           }
[17:39:29.009]                           base::stop(msg)
[17:39:29.009]                         }
[17:39:29.009]                       })
[17:39:29.009]                     }
[17:39:29.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.009]                     base::options(mc.cores = 1L)
[17:39:29.009]                   }
[17:39:29.009]                   options(future.plan = NULL)
[17:39:29.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.009]                 }
[17:39:29.009]                 ...future.workdir <- getwd()
[17:39:29.009]             }
[17:39:29.009]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.009]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.009]         }
[17:39:29.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.009]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:29.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.009]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.009]             base::names(...future.oldOptions))
[17:39:29.009]     }
[17:39:29.009]     if (FALSE) {
[17:39:29.009]     }
[17:39:29.009]     else {
[17:39:29.009]         if (TRUE) {
[17:39:29.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.009]                 open = "w")
[17:39:29.009]         }
[17:39:29.009]         else {
[17:39:29.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.009]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.009]         }
[17:39:29.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.009]             base::sink(type = "output", split = FALSE)
[17:39:29.009]             base::close(...future.stdout)
[17:39:29.009]         }, add = TRUE)
[17:39:29.009]     }
[17:39:29.009]     ...future.frame <- base::sys.nframe()
[17:39:29.009]     ...future.conditions <- base::list()
[17:39:29.009]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.009]     if (FALSE) {
[17:39:29.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.009]     }
[17:39:29.009]     ...future.result <- base::tryCatch({
[17:39:29.009]         base::withCallingHandlers({
[17:39:29.009]             ...future.value <- base::withVisible(base::local({
[17:39:29.009]                 withCallingHandlers({
[17:39:29.009]                   {
[17:39:29.009]                     do.call(function(...) {
[17:39:29.009]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.009]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.009]                         ...future.globals.maxSize)) {
[17:39:29.009]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.009]                         on.exit(options(oopts), add = TRUE)
[17:39:29.009]                       }
[17:39:29.009]                       {
[17:39:29.009]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.009]                           FUN = function(jj) {
[17:39:29.009]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.009]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.009]                           })
[17:39:29.009]                       }
[17:39:29.009]                     }, args = future.call.arguments)
[17:39:29.009]                   }
[17:39:29.009]                 }, immediateCondition = function(cond) {
[17:39:29.009]                   save_rds <- function (object, pathname, ...) 
[17:39:29.009]                   {
[17:39:29.009]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.009]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.009]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.009]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.009]                         fi_tmp[["mtime"]])
[17:39:29.009]                     }
[17:39:29.009]                     tryCatch({
[17:39:29.009]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.009]                     }, error = function(ex) {
[17:39:29.009]                       msg <- conditionMessage(ex)
[17:39:29.009]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.009]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.009]                         fi_tmp[["mtime"]], msg)
[17:39:29.009]                       ex$message <- msg
[17:39:29.009]                       stop(ex)
[17:39:29.009]                     })
[17:39:29.009]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.009]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.009]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.009]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.009]                       fi <- file.info(pathname)
[17:39:29.009]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.009]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.009]                         fi[["size"]], fi[["mtime"]])
[17:39:29.009]                       stop(msg)
[17:39:29.009]                     }
[17:39:29.009]                     invisible(pathname)
[17:39:29.009]                   }
[17:39:29.009]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.009]                     rootPath = tempdir()) 
[17:39:29.009]                   {
[17:39:29.009]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.009]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.009]                       tmpdir = path, fileext = ".rds")
[17:39:29.009]                     save_rds(obj, file)
[17:39:29.009]                   }
[17:39:29.009]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.009]                   {
[17:39:29.009]                     inherits <- base::inherits
[17:39:29.009]                     invokeRestart <- base::invokeRestart
[17:39:29.009]                     is.null <- base::is.null
[17:39:29.009]                     muffled <- FALSE
[17:39:29.009]                     if (inherits(cond, "message")) {
[17:39:29.009]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.009]                       if (muffled) 
[17:39:29.009]                         invokeRestart("muffleMessage")
[17:39:29.009]                     }
[17:39:29.009]                     else if (inherits(cond, "warning")) {
[17:39:29.009]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.009]                       if (muffled) 
[17:39:29.009]                         invokeRestart("muffleWarning")
[17:39:29.009]                     }
[17:39:29.009]                     else if (inherits(cond, "condition")) {
[17:39:29.009]                       if (!is.null(pattern)) {
[17:39:29.009]                         computeRestarts <- base::computeRestarts
[17:39:29.009]                         grepl <- base::grepl
[17:39:29.009]                         restarts <- computeRestarts(cond)
[17:39:29.009]                         for (restart in restarts) {
[17:39:29.009]                           name <- restart$name
[17:39:29.009]                           if (is.null(name)) 
[17:39:29.009]                             next
[17:39:29.009]                           if (!grepl(pattern, name)) 
[17:39:29.009]                             next
[17:39:29.009]                           invokeRestart(restart)
[17:39:29.009]                           muffled <- TRUE
[17:39:29.009]                           break
[17:39:29.009]                         }
[17:39:29.009]                       }
[17:39:29.009]                     }
[17:39:29.009]                     invisible(muffled)
[17:39:29.009]                   }
[17:39:29.009]                   muffleCondition(cond)
[17:39:29.009]                 })
[17:39:29.009]             }))
[17:39:29.009]             future::FutureResult(value = ...future.value$value, 
[17:39:29.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.009]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.009]                     ...future.globalenv.names))
[17:39:29.009]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.009]         }, condition = base::local({
[17:39:29.009]             c <- base::c
[17:39:29.009]             inherits <- base::inherits
[17:39:29.009]             invokeRestart <- base::invokeRestart
[17:39:29.009]             length <- base::length
[17:39:29.009]             list <- base::list
[17:39:29.009]             seq.int <- base::seq.int
[17:39:29.009]             signalCondition <- base::signalCondition
[17:39:29.009]             sys.calls <- base::sys.calls
[17:39:29.009]             `[[` <- base::`[[`
[17:39:29.009]             `+` <- base::`+`
[17:39:29.009]             `<<-` <- base::`<<-`
[17:39:29.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.009]                   3L)]
[17:39:29.009]             }
[17:39:29.009]             function(cond) {
[17:39:29.009]                 is_error <- inherits(cond, "error")
[17:39:29.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.009]                   NULL)
[17:39:29.009]                 if (is_error) {
[17:39:29.009]                   sessionInformation <- function() {
[17:39:29.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.009]                       search = base::search(), system = base::Sys.info())
[17:39:29.009]                   }
[17:39:29.009]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.009]                     cond$call), session = sessionInformation(), 
[17:39:29.009]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.009]                   signalCondition(cond)
[17:39:29.009]                 }
[17:39:29.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.009]                 "immediateCondition"))) {
[17:39:29.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.009]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.009]                   if (TRUE && !signal) {
[17:39:29.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.009]                     {
[17:39:29.009]                       inherits <- base::inherits
[17:39:29.009]                       invokeRestart <- base::invokeRestart
[17:39:29.009]                       is.null <- base::is.null
[17:39:29.009]                       muffled <- FALSE
[17:39:29.009]                       if (inherits(cond, "message")) {
[17:39:29.009]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.009]                         if (muffled) 
[17:39:29.009]                           invokeRestart("muffleMessage")
[17:39:29.009]                       }
[17:39:29.009]                       else if (inherits(cond, "warning")) {
[17:39:29.009]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.009]                         if (muffled) 
[17:39:29.009]                           invokeRestart("muffleWarning")
[17:39:29.009]                       }
[17:39:29.009]                       else if (inherits(cond, "condition")) {
[17:39:29.009]                         if (!is.null(pattern)) {
[17:39:29.009]                           computeRestarts <- base::computeRestarts
[17:39:29.009]                           grepl <- base::grepl
[17:39:29.009]                           restarts <- computeRestarts(cond)
[17:39:29.009]                           for (restart in restarts) {
[17:39:29.009]                             name <- restart$name
[17:39:29.009]                             if (is.null(name)) 
[17:39:29.009]                               next
[17:39:29.009]                             if (!grepl(pattern, name)) 
[17:39:29.009]                               next
[17:39:29.009]                             invokeRestart(restart)
[17:39:29.009]                             muffled <- TRUE
[17:39:29.009]                             break
[17:39:29.009]                           }
[17:39:29.009]                         }
[17:39:29.009]                       }
[17:39:29.009]                       invisible(muffled)
[17:39:29.009]                     }
[17:39:29.009]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.009]                   }
[17:39:29.009]                 }
[17:39:29.009]                 else {
[17:39:29.009]                   if (TRUE) {
[17:39:29.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.009]                     {
[17:39:29.009]                       inherits <- base::inherits
[17:39:29.009]                       invokeRestart <- base::invokeRestart
[17:39:29.009]                       is.null <- base::is.null
[17:39:29.009]                       muffled <- FALSE
[17:39:29.009]                       if (inherits(cond, "message")) {
[17:39:29.009]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.009]                         if (muffled) 
[17:39:29.009]                           invokeRestart("muffleMessage")
[17:39:29.009]                       }
[17:39:29.009]                       else if (inherits(cond, "warning")) {
[17:39:29.009]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.009]                         if (muffled) 
[17:39:29.009]                           invokeRestart("muffleWarning")
[17:39:29.009]                       }
[17:39:29.009]                       else if (inherits(cond, "condition")) {
[17:39:29.009]                         if (!is.null(pattern)) {
[17:39:29.009]                           computeRestarts <- base::computeRestarts
[17:39:29.009]                           grepl <- base::grepl
[17:39:29.009]                           restarts <- computeRestarts(cond)
[17:39:29.009]                           for (restart in restarts) {
[17:39:29.009]                             name <- restart$name
[17:39:29.009]                             if (is.null(name)) 
[17:39:29.009]                               next
[17:39:29.009]                             if (!grepl(pattern, name)) 
[17:39:29.009]                               next
[17:39:29.009]                             invokeRestart(restart)
[17:39:29.009]                             muffled <- TRUE
[17:39:29.009]                             break
[17:39:29.009]                           }
[17:39:29.009]                         }
[17:39:29.009]                       }
[17:39:29.009]                       invisible(muffled)
[17:39:29.009]                     }
[17:39:29.009]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.009]                   }
[17:39:29.009]                 }
[17:39:29.009]             }
[17:39:29.009]         }))
[17:39:29.009]     }, error = function(ex) {
[17:39:29.009]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.009]                 ...future.rng), started = ...future.startTime, 
[17:39:29.009]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.009]             version = "1.8"), class = "FutureResult")
[17:39:29.009]     }, finally = {
[17:39:29.009]         if (!identical(...future.workdir, getwd())) 
[17:39:29.009]             setwd(...future.workdir)
[17:39:29.009]         {
[17:39:29.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.009]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.009]             }
[17:39:29.009]             base::options(...future.oldOptions)
[17:39:29.009]             if (.Platform$OS.type == "windows") {
[17:39:29.009]                 old_names <- names(...future.oldEnvVars)
[17:39:29.009]                 envs <- base::Sys.getenv()
[17:39:29.009]                 names <- names(envs)
[17:39:29.009]                 common <- intersect(names, old_names)
[17:39:29.009]                 added <- setdiff(names, old_names)
[17:39:29.009]                 removed <- setdiff(old_names, names)
[17:39:29.009]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.009]                   envs[common]]
[17:39:29.009]                 NAMES <- toupper(changed)
[17:39:29.009]                 args <- list()
[17:39:29.009]                 for (kk in seq_along(NAMES)) {
[17:39:29.009]                   name <- changed[[kk]]
[17:39:29.009]                   NAME <- NAMES[[kk]]
[17:39:29.009]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.009]                     next
[17:39:29.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.009]                 }
[17:39:29.009]                 NAMES <- toupper(added)
[17:39:29.009]                 for (kk in seq_along(NAMES)) {
[17:39:29.009]                   name <- added[[kk]]
[17:39:29.009]                   NAME <- NAMES[[kk]]
[17:39:29.009]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.009]                     next
[17:39:29.009]                   args[[name]] <- ""
[17:39:29.009]                 }
[17:39:29.009]                 NAMES <- toupper(removed)
[17:39:29.009]                 for (kk in seq_along(NAMES)) {
[17:39:29.009]                   name <- removed[[kk]]
[17:39:29.009]                   NAME <- NAMES[[kk]]
[17:39:29.009]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.009]                     next
[17:39:29.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.009]                 }
[17:39:29.009]                 if (length(args) > 0) 
[17:39:29.009]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.009]             }
[17:39:29.009]             else {
[17:39:29.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.009]             }
[17:39:29.009]             {
[17:39:29.009]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.009]                   0L) {
[17:39:29.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.009]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.009]                   base::options(opts)
[17:39:29.009]                 }
[17:39:29.009]                 {
[17:39:29.009]                   {
[17:39:29.009]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.009]                     NULL
[17:39:29.009]                   }
[17:39:29.009]                   options(future.plan = NULL)
[17:39:29.009]                   if (is.na(NA_character_)) 
[17:39:29.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.009]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.009]                     envir = parent.frame()) 
[17:39:29.009]                   {
[17:39:29.009]                     default_workers <- missing(workers)
[17:39:29.009]                     if (is.function(workers)) 
[17:39:29.009]                       workers <- workers()
[17:39:29.009]                     workers <- structure(as.integer(workers), 
[17:39:29.009]                       class = class(workers))
[17:39:29.009]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.009]                       1L)
[17:39:29.009]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.009]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.009]                       if (default_workers) 
[17:39:29.009]                         supportsMulticore(warn = TRUE)
[17:39:29.009]                       return(sequential(..., envir = envir))
[17:39:29.009]                     }
[17:39:29.009]                     oopts <- options(mc.cores = workers)
[17:39:29.009]                     on.exit(options(oopts))
[17:39:29.009]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.009]                       envir = envir)
[17:39:29.009]                     if (!future$lazy) 
[17:39:29.009]                       future <- run(future)
[17:39:29.009]                     invisible(future)
[17:39:29.009]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.009]                 }
[17:39:29.009]             }
[17:39:29.009]         }
[17:39:29.009]     })
[17:39:29.009]     if (TRUE) {
[17:39:29.009]         base::sink(type = "output", split = FALSE)
[17:39:29.009]         if (TRUE) {
[17:39:29.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.009]         }
[17:39:29.009]         else {
[17:39:29.009]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.009]         }
[17:39:29.009]         base::close(...future.stdout)
[17:39:29.009]         ...future.stdout <- NULL
[17:39:29.009]     }
[17:39:29.009]     ...future.result$conditions <- ...future.conditions
[17:39:29.009]     ...future.result$finished <- base::Sys.time()
[17:39:29.009]     ...future.result
[17:39:29.009] }
[17:39:29.012] assign_globals() ...
[17:39:29.012] List of 5
[17:39:29.012]  $ ...future.FUN            :function (x, ...)  
[17:39:29.012]  $ future.call.arguments    : list()
[17:39:29.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.012]  $ ...future.elements_ii    :List of 2
[17:39:29.012]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:29.012]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:29.012]  $ ...future.seeds_ii       : NULL
[17:39:29.012]  $ ...future.globals.maxSize: NULL
[17:39:29.012]  - attr(*, "resolved")= logi FALSE
[17:39:29.012]  - attr(*, "total_size")= num 1240
[17:39:29.012]  - attr(*, "where")=List of 5
[17:39:29.012]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.012]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.012]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.012]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.012]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.012]  - attr(*, "already-done")= logi TRUE
[17:39:29.020] - copied ‘...future.FUN’ to environment
[17:39:29.020] - copied ‘future.call.arguments’ to environment
[17:39:29.020] - copied ‘...future.elements_ii’ to environment
[17:39:29.020] - copied ‘...future.seeds_ii’ to environment
[17:39:29.020] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.020] assign_globals() ... done
[17:39:29.021] requestCore(): workers = 2
[17:39:29.026] MulticoreFuture started
[17:39:29.027] - Launch lazy future ... done
[17:39:29.027] run() for ‘MulticoreFuture’ ... done
[17:39:29.027] Created future:
[17:39:29.028] plan(): Setting new future strategy stack:
[17:39:29.028] List of future strategies:
[17:39:29.028] 1. sequential:
[17:39:29.028]    - args: function (..., envir = parent.frame())
[17:39:29.028]    - tweaked: FALSE
[17:39:29.028]    - call: NULL
[17:39:29.029] plan(): nbrOfWorkers() = 1
[17:39:29.031] plan(): Setting new future strategy stack:
[17:39:29.031] List of future strategies:
[17:39:29.031] 1. multicore:
[17:39:29.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.031]    - tweaked: FALSE
[17:39:29.031]    - call: plan(strategy)
[17:39:29.037] plan(): nbrOfWorkers() = 2
[17:39:29.027] MulticoreFuture:
[17:39:29.027] Label: ‘future_eapply-2’
[17:39:29.027] Expression:
[17:39:29.027] {
[17:39:29.027]     do.call(function(...) {
[17:39:29.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.027]             on.exit(options(oopts), add = TRUE)
[17:39:29.027]         }
[17:39:29.027]         {
[17:39:29.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.027]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.027]             })
[17:39:29.027]         }
[17:39:29.027]     }, args = future.call.arguments)
[17:39:29.027] }
[17:39:29.027] Lazy evaluation: FALSE
[17:39:29.027] Asynchronous evaluation: TRUE
[17:39:29.027] Local evaluation: TRUE
[17:39:29.027] Environment: R_GlobalEnv
[17:39:29.027] Capture standard output: TRUE
[17:39:29.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.027] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.027] Packages: <none>
[17:39:29.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.027] Resolved: TRUE
[17:39:29.027] Value: <not collected>
[17:39:29.027] Conditions captured: <none>
[17:39:29.027] Early signaling: FALSE
[17:39:29.027] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.027] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.038] Chunk #2 of 2 ... DONE
[17:39:29.038] Launching 2 futures (chunks) ... DONE
[17:39:29.038] Resolving 2 futures (chunks) ...
[17:39:29.038] resolve() on list ...
[17:39:29.039]  recursive: 0
[17:39:29.039]  length: 2
[17:39:29.039] 
[17:39:29.039] Future #1
[17:39:29.042] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:29.042] - nx: 2
[17:39:29.042] - relay: TRUE
[17:39:29.042] - stdout: TRUE
[17:39:29.042] - signal: TRUE
[17:39:29.042] - resignal: FALSE
[17:39:29.042] - force: TRUE
[17:39:29.043] - relayed: [n=2] FALSE, FALSE
[17:39:29.043] - queued futures: [n=2] FALSE, FALSE
[17:39:29.043]  - until=1
[17:39:29.043]  - relaying element #1
[17:39:29.043] - relayed: [n=2] TRUE, FALSE
[17:39:29.043] - queued futures: [n=2] TRUE, FALSE
[17:39:29.044] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:29.044]  length: 1 (resolved future 1)
[17:39:29.044] Future #2
[17:39:29.045] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:29.045] - nx: 2
[17:39:29.045] - relay: TRUE
[17:39:29.045] - stdout: TRUE
[17:39:29.045] - signal: TRUE
[17:39:29.046] - resignal: FALSE
[17:39:29.046] - force: TRUE
[17:39:29.046] - relayed: [n=2] TRUE, FALSE
[17:39:29.046] - queued futures: [n=2] TRUE, FALSE
[17:39:29.046]  - until=2
[17:39:29.046]  - relaying element #2
[17:39:29.047] - relayed: [n=2] TRUE, TRUE
[17:39:29.047] - queued futures: [n=2] TRUE, TRUE
[17:39:29.047] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:29.047]  length: 0 (resolved future 2)
[17:39:29.047] Relaying remaining futures
[17:39:29.047] signalConditionsASAP(NULL, pos=0) ...
[17:39:29.047] - nx: 2
[17:39:29.047] - relay: TRUE
[17:39:29.048] - stdout: TRUE
[17:39:29.050] - signal: TRUE
[17:39:29.050] - resignal: FALSE
[17:39:29.051] - force: TRUE
[17:39:29.051] - relayed: [n=2] TRUE, TRUE
[17:39:29.051] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:29.051] - relayed: [n=2] TRUE, TRUE
[17:39:29.051] - queued futures: [n=2] TRUE, TRUE
[17:39:29.051] signalConditionsASAP(NULL, pos=0) ... done
[17:39:29.051] resolve() on list ... DONE
[17:39:29.052]  - Number of value chunks collected: 2
[17:39:29.052] Resolving 2 futures (chunks) ... DONE
[17:39:29.052] Reducing values from 2 chunks ...
[17:39:29.052]  - Number of values collected after concatenation: 3
[17:39:29.052]  - Number of values expected: 3
[17:39:29.053] Reducing values from 2 chunks ... DONE
[17:39:29.053] future_lapply() ... DONE
[17:39:29.054] future_lapply() ...
[17:39:29.059] Number of chunks: 2
[17:39:29.059] getGlobalsAndPackagesXApply() ...
[17:39:29.059]  - future.globals: TRUE
[17:39:29.059] getGlobalsAndPackages() ...
[17:39:29.059] Searching for globals...
[17:39:29.061] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:29.061] Searching for globals ... DONE
[17:39:29.061] Resolving globals: FALSE
[17:39:29.061] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:29.062] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:29.062] - globals: [1] ‘FUN’
[17:39:29.062] - packages: [1] ‘stats’
[17:39:29.062] getGlobalsAndPackages() ... DONE
[17:39:29.062]  - globals found/used: [n=1] ‘FUN’
[17:39:29.063]  - needed namespaces: [n=1] ‘stats’
[17:39:29.063] Finding globals ... DONE
[17:39:29.063]  - use_args: TRUE
[17:39:29.063]  - Getting '...' globals ...
[17:39:29.063] resolve() on list ...
[17:39:29.064]  recursive: 0
[17:39:29.064]  length: 1
[17:39:29.064]  elements: ‘...’
[17:39:29.064]  length: 0 (resolved future 1)
[17:39:29.064] resolve() on list ... DONE
[17:39:29.064]    - '...' content: [n=1] ‘probs’
[17:39:29.064] List of 1
[17:39:29.064]  $ ...:List of 1
[17:39:29.064]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:29.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.064]  - attr(*, "where")=List of 1
[17:39:29.064]   ..$ ...:<environment: 0x555b645ead58> 
[17:39:29.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.064]  - attr(*, "resolved")= logi TRUE
[17:39:29.064]  - attr(*, "total_size")= num NA
[17:39:29.068]  - Getting '...' globals ... DONE
[17:39:29.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:29.068] List of 2
[17:39:29.068]  $ ...future.FUN:function (x, ...)  
[17:39:29.068]  $ ...          :List of 1
[17:39:29.068]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:29.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.068]  - attr(*, "where")=List of 2
[17:39:29.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:29.068]   ..$ ...          :<environment: 0x555b645ead58> 
[17:39:29.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.068]  - attr(*, "resolved")= logi FALSE
[17:39:29.068]  - attr(*, "total_size")= num 1328
[17:39:29.072] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:29.072] getGlobalsAndPackagesXApply() ... DONE
[17:39:29.072] Number of futures (= number of chunks): 2
[17:39:29.072] Launching 2 futures (chunks) ...
[17:39:29.073] Chunk #1 of 2 ...
[17:39:29.073]  - Finding globals in 'X' for chunk #1 ...
[17:39:29.073] getGlobalsAndPackages() ...
[17:39:29.073] Searching for globals...
[17:39:29.073] 
[17:39:29.073] Searching for globals ... DONE
[17:39:29.073] - globals: [0] <none>
[17:39:29.073] getGlobalsAndPackages() ... DONE
[17:39:29.074]    + additional globals found: [n=0] 
[17:39:29.074]    + additional namespaces needed: [n=0] 
[17:39:29.074]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:29.074]  - seeds: <none>
[17:39:29.074] getGlobalsAndPackages() ...
[17:39:29.074] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.074] Resolving globals: FALSE
[17:39:29.074] Tweak future expression to call with '...' arguments ...
[17:39:29.074] {
[17:39:29.074]     do.call(function(...) {
[17:39:29.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.074]             on.exit(options(oopts), add = TRUE)
[17:39:29.074]         }
[17:39:29.074]         {
[17:39:29.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.074]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.074]             })
[17:39:29.074]         }
[17:39:29.074]     }, args = future.call.arguments)
[17:39:29.074] }
[17:39:29.075] Tweak future expression to call with '...' arguments ... DONE
[17:39:29.075] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.075] - packages: [1] ‘stats’
[17:39:29.075] getGlobalsAndPackages() ... DONE
[17:39:29.076] run() for ‘Future’ ...
[17:39:29.076] - state: ‘created’
[17:39:29.076] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.080] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.080]   - Field: ‘label’
[17:39:29.080]   - Field: ‘local’
[17:39:29.080]   - Field: ‘owner’
[17:39:29.081]   - Field: ‘envir’
[17:39:29.081]   - Field: ‘workers’
[17:39:29.081]   - Field: ‘packages’
[17:39:29.081]   - Field: ‘gc’
[17:39:29.081]   - Field: ‘job’
[17:39:29.081]   - Field: ‘conditions’
[17:39:29.081]   - Field: ‘expr’
[17:39:29.081]   - Field: ‘uuid’
[17:39:29.083]   - Field: ‘seed’
[17:39:29.083]   - Field: ‘version’
[17:39:29.084]   - Field: ‘result’
[17:39:29.084]   - Field: ‘asynchronous’
[17:39:29.084]   - Field: ‘calls’
[17:39:29.084]   - Field: ‘globals’
[17:39:29.084]   - Field: ‘stdout’
[17:39:29.084]   - Field: ‘earlySignal’
[17:39:29.084]   - Field: ‘lazy’
[17:39:29.084]   - Field: ‘state’
[17:39:29.084] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.084] - Launch lazy future ...
[17:39:29.085] Packages needed by the future expression (n = 1): ‘stats’
[17:39:29.085] Packages needed by future strategies (n = 0): <none>
[17:39:29.085] {
[17:39:29.085]     {
[17:39:29.085]         {
[17:39:29.085]             ...future.startTime <- base::Sys.time()
[17:39:29.085]             {
[17:39:29.085]                 {
[17:39:29.085]                   {
[17:39:29.085]                     {
[17:39:29.085]                       {
[17:39:29.085]                         base::local({
[17:39:29.085]                           has_future <- base::requireNamespace("future", 
[17:39:29.085]                             quietly = TRUE)
[17:39:29.085]                           if (has_future) {
[17:39:29.085]                             ns <- base::getNamespace("future")
[17:39:29.085]                             version <- ns[[".package"]][["version"]]
[17:39:29.085]                             if (is.null(version)) 
[17:39:29.085]                               version <- utils::packageVersion("future")
[17:39:29.085]                           }
[17:39:29.085]                           else {
[17:39:29.085]                             version <- NULL
[17:39:29.085]                           }
[17:39:29.085]                           if (!has_future || version < "1.8.0") {
[17:39:29.085]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.085]                               "", base::R.version$version.string), 
[17:39:29.085]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:29.085]                                 base::R.version$platform, 8 * 
[17:39:29.085]                                   base::.Machine$sizeof.pointer), 
[17:39:29.085]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.085]                                 "release", "version")], collapse = " "), 
[17:39:29.085]                               hostname = base::Sys.info()[["nodename"]])
[17:39:29.085]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.085]                               info)
[17:39:29.085]                             info <- base::paste(info, collapse = "; ")
[17:39:29.085]                             if (!has_future) {
[17:39:29.085]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.085]                                 info)
[17:39:29.085]                             }
[17:39:29.085]                             else {
[17:39:29.085]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.085]                                 info, version)
[17:39:29.085]                             }
[17:39:29.085]                             base::stop(msg)
[17:39:29.085]                           }
[17:39:29.085]                         })
[17:39:29.085]                       }
[17:39:29.085]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.085]                       base::options(mc.cores = 1L)
[17:39:29.085]                     }
[17:39:29.085]                     base::local({
[17:39:29.085]                       for (pkg in "stats") {
[17:39:29.085]                         base::loadNamespace(pkg)
[17:39:29.085]                         base::library(pkg, character.only = TRUE)
[17:39:29.085]                       }
[17:39:29.085]                     })
[17:39:29.085]                   }
[17:39:29.085]                   options(future.plan = NULL)
[17:39:29.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.085]                 }
[17:39:29.085]                 ...future.workdir <- getwd()
[17:39:29.085]             }
[17:39:29.085]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.085]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.085]         }
[17:39:29.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:29.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.085]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.085]             base::names(...future.oldOptions))
[17:39:29.085]     }
[17:39:29.085]     if (FALSE) {
[17:39:29.085]     }
[17:39:29.085]     else {
[17:39:29.085]         if (TRUE) {
[17:39:29.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.085]                 open = "w")
[17:39:29.085]         }
[17:39:29.085]         else {
[17:39:29.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.085]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.085]         }
[17:39:29.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.085]             base::sink(type = "output", split = FALSE)
[17:39:29.085]             base::close(...future.stdout)
[17:39:29.085]         }, add = TRUE)
[17:39:29.085]     }
[17:39:29.085]     ...future.frame <- base::sys.nframe()
[17:39:29.085]     ...future.conditions <- base::list()
[17:39:29.085]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.085]     if (FALSE) {
[17:39:29.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.085]     }
[17:39:29.085]     ...future.result <- base::tryCatch({
[17:39:29.085]         base::withCallingHandlers({
[17:39:29.085]             ...future.value <- base::withVisible(base::local({
[17:39:29.085]                 withCallingHandlers({
[17:39:29.085]                   {
[17:39:29.085]                     do.call(function(...) {
[17:39:29.085]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.085]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.085]                         ...future.globals.maxSize)) {
[17:39:29.085]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.085]                         on.exit(options(oopts), add = TRUE)
[17:39:29.085]                       }
[17:39:29.085]                       {
[17:39:29.085]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.085]                           FUN = function(jj) {
[17:39:29.085]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.085]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.085]                           })
[17:39:29.085]                       }
[17:39:29.085]                     }, args = future.call.arguments)
[17:39:29.085]                   }
[17:39:29.085]                 }, immediateCondition = function(cond) {
[17:39:29.085]                   save_rds <- function (object, pathname, ...) 
[17:39:29.085]                   {
[17:39:29.085]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.085]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.085]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.085]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.085]                         fi_tmp[["mtime"]])
[17:39:29.085]                     }
[17:39:29.085]                     tryCatch({
[17:39:29.085]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.085]                     }, error = function(ex) {
[17:39:29.085]                       msg <- conditionMessage(ex)
[17:39:29.085]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.085]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.085]                         fi_tmp[["mtime"]], msg)
[17:39:29.085]                       ex$message <- msg
[17:39:29.085]                       stop(ex)
[17:39:29.085]                     })
[17:39:29.085]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.085]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.085]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.085]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.085]                       fi <- file.info(pathname)
[17:39:29.085]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.085]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.085]                         fi[["size"]], fi[["mtime"]])
[17:39:29.085]                       stop(msg)
[17:39:29.085]                     }
[17:39:29.085]                     invisible(pathname)
[17:39:29.085]                   }
[17:39:29.085]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.085]                     rootPath = tempdir()) 
[17:39:29.085]                   {
[17:39:29.085]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.085]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.085]                       tmpdir = path, fileext = ".rds")
[17:39:29.085]                     save_rds(obj, file)
[17:39:29.085]                   }
[17:39:29.085]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.085]                   {
[17:39:29.085]                     inherits <- base::inherits
[17:39:29.085]                     invokeRestart <- base::invokeRestart
[17:39:29.085]                     is.null <- base::is.null
[17:39:29.085]                     muffled <- FALSE
[17:39:29.085]                     if (inherits(cond, "message")) {
[17:39:29.085]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.085]                       if (muffled) 
[17:39:29.085]                         invokeRestart("muffleMessage")
[17:39:29.085]                     }
[17:39:29.085]                     else if (inherits(cond, "warning")) {
[17:39:29.085]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.085]                       if (muffled) 
[17:39:29.085]                         invokeRestart("muffleWarning")
[17:39:29.085]                     }
[17:39:29.085]                     else if (inherits(cond, "condition")) {
[17:39:29.085]                       if (!is.null(pattern)) {
[17:39:29.085]                         computeRestarts <- base::computeRestarts
[17:39:29.085]                         grepl <- base::grepl
[17:39:29.085]                         restarts <- computeRestarts(cond)
[17:39:29.085]                         for (restart in restarts) {
[17:39:29.085]                           name <- restart$name
[17:39:29.085]                           if (is.null(name)) 
[17:39:29.085]                             next
[17:39:29.085]                           if (!grepl(pattern, name)) 
[17:39:29.085]                             next
[17:39:29.085]                           invokeRestart(restart)
[17:39:29.085]                           muffled <- TRUE
[17:39:29.085]                           break
[17:39:29.085]                         }
[17:39:29.085]                       }
[17:39:29.085]                     }
[17:39:29.085]                     invisible(muffled)
[17:39:29.085]                   }
[17:39:29.085]                   muffleCondition(cond)
[17:39:29.085]                 })
[17:39:29.085]             }))
[17:39:29.085]             future::FutureResult(value = ...future.value$value, 
[17:39:29.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.085]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.085]                     ...future.globalenv.names))
[17:39:29.085]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.085]         }, condition = base::local({
[17:39:29.085]             c <- base::c
[17:39:29.085]             inherits <- base::inherits
[17:39:29.085]             invokeRestart <- base::invokeRestart
[17:39:29.085]             length <- base::length
[17:39:29.085]             list <- base::list
[17:39:29.085]             seq.int <- base::seq.int
[17:39:29.085]             signalCondition <- base::signalCondition
[17:39:29.085]             sys.calls <- base::sys.calls
[17:39:29.085]             `[[` <- base::`[[`
[17:39:29.085]             `+` <- base::`+`
[17:39:29.085]             `<<-` <- base::`<<-`
[17:39:29.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.085]                   3L)]
[17:39:29.085]             }
[17:39:29.085]             function(cond) {
[17:39:29.085]                 is_error <- inherits(cond, "error")
[17:39:29.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.085]                   NULL)
[17:39:29.085]                 if (is_error) {
[17:39:29.085]                   sessionInformation <- function() {
[17:39:29.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.085]                       search = base::search(), system = base::Sys.info())
[17:39:29.085]                   }
[17:39:29.085]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.085]                     cond$call), session = sessionInformation(), 
[17:39:29.085]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.085]                   signalCondition(cond)
[17:39:29.085]                 }
[17:39:29.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.085]                 "immediateCondition"))) {
[17:39:29.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.085]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.085]                   if (TRUE && !signal) {
[17:39:29.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.085]                     {
[17:39:29.085]                       inherits <- base::inherits
[17:39:29.085]                       invokeRestart <- base::invokeRestart
[17:39:29.085]                       is.null <- base::is.null
[17:39:29.085]                       muffled <- FALSE
[17:39:29.085]                       if (inherits(cond, "message")) {
[17:39:29.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.085]                         if (muffled) 
[17:39:29.085]                           invokeRestart("muffleMessage")
[17:39:29.085]                       }
[17:39:29.085]                       else if (inherits(cond, "warning")) {
[17:39:29.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.085]                         if (muffled) 
[17:39:29.085]                           invokeRestart("muffleWarning")
[17:39:29.085]                       }
[17:39:29.085]                       else if (inherits(cond, "condition")) {
[17:39:29.085]                         if (!is.null(pattern)) {
[17:39:29.085]                           computeRestarts <- base::computeRestarts
[17:39:29.085]                           grepl <- base::grepl
[17:39:29.085]                           restarts <- computeRestarts(cond)
[17:39:29.085]                           for (restart in restarts) {
[17:39:29.085]                             name <- restart$name
[17:39:29.085]                             if (is.null(name)) 
[17:39:29.085]                               next
[17:39:29.085]                             if (!grepl(pattern, name)) 
[17:39:29.085]                               next
[17:39:29.085]                             invokeRestart(restart)
[17:39:29.085]                             muffled <- TRUE
[17:39:29.085]                             break
[17:39:29.085]                           }
[17:39:29.085]                         }
[17:39:29.085]                       }
[17:39:29.085]                       invisible(muffled)
[17:39:29.085]                     }
[17:39:29.085]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.085]                   }
[17:39:29.085]                 }
[17:39:29.085]                 else {
[17:39:29.085]                   if (TRUE) {
[17:39:29.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.085]                     {
[17:39:29.085]                       inherits <- base::inherits
[17:39:29.085]                       invokeRestart <- base::invokeRestart
[17:39:29.085]                       is.null <- base::is.null
[17:39:29.085]                       muffled <- FALSE
[17:39:29.085]                       if (inherits(cond, "message")) {
[17:39:29.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.085]                         if (muffled) 
[17:39:29.085]                           invokeRestart("muffleMessage")
[17:39:29.085]                       }
[17:39:29.085]                       else if (inherits(cond, "warning")) {
[17:39:29.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.085]                         if (muffled) 
[17:39:29.085]                           invokeRestart("muffleWarning")
[17:39:29.085]                       }
[17:39:29.085]                       else if (inherits(cond, "condition")) {
[17:39:29.085]                         if (!is.null(pattern)) {
[17:39:29.085]                           computeRestarts <- base::computeRestarts
[17:39:29.085]                           grepl <- base::grepl
[17:39:29.085]                           restarts <- computeRestarts(cond)
[17:39:29.085]                           for (restart in restarts) {
[17:39:29.085]                             name <- restart$name
[17:39:29.085]                             if (is.null(name)) 
[17:39:29.085]                               next
[17:39:29.085]                             if (!grepl(pattern, name)) 
[17:39:29.085]                               next
[17:39:29.085]                             invokeRestart(restart)
[17:39:29.085]                             muffled <- TRUE
[17:39:29.085]                             break
[17:39:29.085]                           }
[17:39:29.085]                         }
[17:39:29.085]                       }
[17:39:29.085]                       invisible(muffled)
[17:39:29.085]                     }
[17:39:29.085]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.085]                   }
[17:39:29.085]                 }
[17:39:29.085]             }
[17:39:29.085]         }))
[17:39:29.085]     }, error = function(ex) {
[17:39:29.085]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.085]                 ...future.rng), started = ...future.startTime, 
[17:39:29.085]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.085]             version = "1.8"), class = "FutureResult")
[17:39:29.085]     }, finally = {
[17:39:29.085]         if (!identical(...future.workdir, getwd())) 
[17:39:29.085]             setwd(...future.workdir)
[17:39:29.085]         {
[17:39:29.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.085]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.085]             }
[17:39:29.085]             base::options(...future.oldOptions)
[17:39:29.085]             if (.Platform$OS.type == "windows") {
[17:39:29.085]                 old_names <- names(...future.oldEnvVars)
[17:39:29.085]                 envs <- base::Sys.getenv()
[17:39:29.085]                 names <- names(envs)
[17:39:29.085]                 common <- intersect(names, old_names)
[17:39:29.085]                 added <- setdiff(names, old_names)
[17:39:29.085]                 removed <- setdiff(old_names, names)
[17:39:29.085]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.085]                   envs[common]]
[17:39:29.085]                 NAMES <- toupper(changed)
[17:39:29.085]                 args <- list()
[17:39:29.085]                 for (kk in seq_along(NAMES)) {
[17:39:29.085]                   name <- changed[[kk]]
[17:39:29.085]                   NAME <- NAMES[[kk]]
[17:39:29.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.085]                     next
[17:39:29.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.085]                 }
[17:39:29.085]                 NAMES <- toupper(added)
[17:39:29.085]                 for (kk in seq_along(NAMES)) {
[17:39:29.085]                   name <- added[[kk]]
[17:39:29.085]                   NAME <- NAMES[[kk]]
[17:39:29.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.085]                     next
[17:39:29.085]                   args[[name]] <- ""
[17:39:29.085]                 }
[17:39:29.085]                 NAMES <- toupper(removed)
[17:39:29.085]                 for (kk in seq_along(NAMES)) {
[17:39:29.085]                   name <- removed[[kk]]
[17:39:29.085]                   NAME <- NAMES[[kk]]
[17:39:29.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.085]                     next
[17:39:29.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.085]                 }
[17:39:29.085]                 if (length(args) > 0) 
[17:39:29.085]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.085]             }
[17:39:29.085]             else {
[17:39:29.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.085]             }
[17:39:29.085]             {
[17:39:29.085]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.085]                   0L) {
[17:39:29.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.085]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.085]                   base::options(opts)
[17:39:29.085]                 }
[17:39:29.085]                 {
[17:39:29.085]                   {
[17:39:29.085]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.085]                     NULL
[17:39:29.085]                   }
[17:39:29.085]                   options(future.plan = NULL)
[17:39:29.085]                   if (is.na(NA_character_)) 
[17:39:29.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.085]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.085]                     envir = parent.frame()) 
[17:39:29.085]                   {
[17:39:29.085]                     default_workers <- missing(workers)
[17:39:29.085]                     if (is.function(workers)) 
[17:39:29.085]                       workers <- workers()
[17:39:29.085]                     workers <- structure(as.integer(workers), 
[17:39:29.085]                       class = class(workers))
[17:39:29.085]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.085]                       1L)
[17:39:29.085]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.085]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.085]                       if (default_workers) 
[17:39:29.085]                         supportsMulticore(warn = TRUE)
[17:39:29.085]                       return(sequential(..., envir = envir))
[17:39:29.085]                     }
[17:39:29.085]                     oopts <- options(mc.cores = workers)
[17:39:29.085]                     on.exit(options(oopts))
[17:39:29.085]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.085]                       envir = envir)
[17:39:29.085]                     if (!future$lazy) 
[17:39:29.085]                       future <- run(future)
[17:39:29.085]                     invisible(future)
[17:39:29.085]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.085]                 }
[17:39:29.085]             }
[17:39:29.085]         }
[17:39:29.085]     })
[17:39:29.085]     if (TRUE) {
[17:39:29.085]         base::sink(type = "output", split = FALSE)
[17:39:29.085]         if (TRUE) {
[17:39:29.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.085]         }
[17:39:29.085]         else {
[17:39:29.085]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.085]         }
[17:39:29.085]         base::close(...future.stdout)
[17:39:29.085]         ...future.stdout <- NULL
[17:39:29.085]     }
[17:39:29.085]     ...future.result$conditions <- ...future.conditions
[17:39:29.085]     ...future.result$finished <- base::Sys.time()
[17:39:29.085]     ...future.result
[17:39:29.085] }
[17:39:29.088] assign_globals() ...
[17:39:29.088] List of 5
[17:39:29.088]  $ ...future.FUN            :function (x, ...)  
[17:39:29.088]  $ future.call.arguments    :List of 1
[17:39:29.088]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:29.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.088]  $ ...future.elements_ii    :List of 1
[17:39:29.088]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:39:29.088]  $ ...future.seeds_ii       : NULL
[17:39:29.088]  $ ...future.globals.maxSize: NULL
[17:39:29.088]  - attr(*, "where")=List of 5
[17:39:29.088]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.088]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.088]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.088]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.088]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.088]  - attr(*, "resolved")= logi FALSE
[17:39:29.088]  - attr(*, "total_size")= num 1328
[17:39:29.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.088]  - attr(*, "already-done")= logi TRUE
[17:39:29.094] - copied ‘...future.FUN’ to environment
[17:39:29.094] - copied ‘future.call.arguments’ to environment
[17:39:29.094] - copied ‘...future.elements_ii’ to environment
[17:39:29.094] - copied ‘...future.seeds_ii’ to environment
[17:39:29.094] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.094] assign_globals() ... done
[17:39:29.094] requestCore(): workers = 2
[17:39:29.097] MulticoreFuture started
[17:39:29.097] - Launch lazy future ... done
[17:39:29.097] run() for ‘MulticoreFuture’ ... done
[17:39:29.097] Created future:
[17:39:29.098] plan(): Setting new future strategy stack:
[17:39:29.098] List of future strategies:
[17:39:29.098] 1. sequential:
[17:39:29.098]    - args: function (..., envir = parent.frame())
[17:39:29.098]    - tweaked: FALSE
[17:39:29.098]    - call: NULL
[17:39:29.099] plan(): nbrOfWorkers() = 1
[17:39:29.102] plan(): Setting new future strategy stack:
[17:39:29.102] List of future strategies:
[17:39:29.102] 1. multicore:
[17:39:29.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.102]    - tweaked: FALSE
[17:39:29.102]    - call: plan(strategy)
[17:39:29.108] plan(): nbrOfWorkers() = 2
[17:39:29.098] MulticoreFuture:
[17:39:29.098] Label: ‘future_eapply-1’
[17:39:29.098] Expression:
[17:39:29.098] {
[17:39:29.098]     do.call(function(...) {
[17:39:29.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.098]             on.exit(options(oopts), add = TRUE)
[17:39:29.098]         }
[17:39:29.098]         {
[17:39:29.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.098]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.098]             })
[17:39:29.098]         }
[17:39:29.098]     }, args = future.call.arguments)
[17:39:29.098] }
[17:39:29.098] Lazy evaluation: FALSE
[17:39:29.098] Asynchronous evaluation: TRUE
[17:39:29.098] Local evaluation: TRUE
[17:39:29.098] Environment: R_GlobalEnv
[17:39:29.098] Capture standard output: TRUE
[17:39:29.098] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.098] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.098] Packages: 1 packages (‘stats’)
[17:39:29.098] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.098] Resolved: TRUE
[17:39:29.098] Value: <not collected>
[17:39:29.098] Conditions captured: <none>
[17:39:29.098] Early signaling: FALSE
[17:39:29.098] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.098] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.109] Chunk #1 of 2 ... DONE
[17:39:29.109] Chunk #2 of 2 ...
[17:39:29.109]  - Finding globals in 'X' for chunk #2 ...
[17:39:29.109] getGlobalsAndPackages() ...
[17:39:29.110] Searching for globals...
[17:39:29.110] 
[17:39:29.110] Searching for globals ... DONE
[17:39:29.110] - globals: [0] <none>
[17:39:29.111] getGlobalsAndPackages() ... DONE
[17:39:29.111]    + additional globals found: [n=0] 
[17:39:29.111]    + additional namespaces needed: [n=0] 
[17:39:29.111]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:29.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:29.111]  - seeds: <none>
[17:39:29.111] getGlobalsAndPackages() ...
[17:39:29.112] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.112] Resolving globals: FALSE
[17:39:29.112] Tweak future expression to call with '...' arguments ...
[17:39:29.112] {
[17:39:29.112]     do.call(function(...) {
[17:39:29.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.112]             on.exit(options(oopts), add = TRUE)
[17:39:29.112]         }
[17:39:29.112]         {
[17:39:29.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.112]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.112]             })
[17:39:29.112]         }
[17:39:29.112]     }, args = future.call.arguments)
[17:39:29.112] }
[17:39:29.113] Tweak future expression to call with '...' arguments ... DONE
[17:39:29.113] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.114] - packages: [1] ‘stats’
[17:39:29.114] getGlobalsAndPackages() ... DONE
[17:39:29.114] run() for ‘Future’ ...
[17:39:29.115] - state: ‘created’
[17:39:29.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.120]   - Field: ‘label’
[17:39:29.120]   - Field: ‘local’
[17:39:29.120]   - Field: ‘owner’
[17:39:29.121]   - Field: ‘envir’
[17:39:29.121]   - Field: ‘workers’
[17:39:29.121]   - Field: ‘packages’
[17:39:29.121]   - Field: ‘gc’
[17:39:29.121]   - Field: ‘job’
[17:39:29.121]   - Field: ‘conditions’
[17:39:29.121]   - Field: ‘expr’
[17:39:29.122]   - Field: ‘uuid’
[17:39:29.122]   - Field: ‘seed’
[17:39:29.122]   - Field: ‘version’
[17:39:29.122]   - Field: ‘result’
[17:39:29.122]   - Field: ‘asynchronous’
[17:39:29.122]   - Field: ‘calls’
[17:39:29.122]   - Field: ‘globals’
[17:39:29.123]   - Field: ‘stdout’
[17:39:29.123]   - Field: ‘earlySignal’
[17:39:29.123]   - Field: ‘lazy’
[17:39:29.123]   - Field: ‘state’
[17:39:29.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.123] - Launch lazy future ...
[17:39:29.124] Packages needed by the future expression (n = 1): ‘stats’
[17:39:29.124] Packages needed by future strategies (n = 0): <none>
[17:39:29.125] {
[17:39:29.125]     {
[17:39:29.125]         {
[17:39:29.125]             ...future.startTime <- base::Sys.time()
[17:39:29.125]             {
[17:39:29.125]                 {
[17:39:29.125]                   {
[17:39:29.125]                     {
[17:39:29.125]                       {
[17:39:29.125]                         base::local({
[17:39:29.125]                           has_future <- base::requireNamespace("future", 
[17:39:29.125]                             quietly = TRUE)
[17:39:29.125]                           if (has_future) {
[17:39:29.125]                             ns <- base::getNamespace("future")
[17:39:29.125]                             version <- ns[[".package"]][["version"]]
[17:39:29.125]                             if (is.null(version)) 
[17:39:29.125]                               version <- utils::packageVersion("future")
[17:39:29.125]                           }
[17:39:29.125]                           else {
[17:39:29.125]                             version <- NULL
[17:39:29.125]                           }
[17:39:29.125]                           if (!has_future || version < "1.8.0") {
[17:39:29.125]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.125]                               "", base::R.version$version.string), 
[17:39:29.125]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:29.125]                                 base::R.version$platform, 8 * 
[17:39:29.125]                                   base::.Machine$sizeof.pointer), 
[17:39:29.125]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.125]                                 "release", "version")], collapse = " "), 
[17:39:29.125]                               hostname = base::Sys.info()[["nodename"]])
[17:39:29.125]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.125]                               info)
[17:39:29.125]                             info <- base::paste(info, collapse = "; ")
[17:39:29.125]                             if (!has_future) {
[17:39:29.125]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.125]                                 info)
[17:39:29.125]                             }
[17:39:29.125]                             else {
[17:39:29.125]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.125]                                 info, version)
[17:39:29.125]                             }
[17:39:29.125]                             base::stop(msg)
[17:39:29.125]                           }
[17:39:29.125]                         })
[17:39:29.125]                       }
[17:39:29.125]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.125]                       base::options(mc.cores = 1L)
[17:39:29.125]                     }
[17:39:29.125]                     base::local({
[17:39:29.125]                       for (pkg in "stats") {
[17:39:29.125]                         base::loadNamespace(pkg)
[17:39:29.125]                         base::library(pkg, character.only = TRUE)
[17:39:29.125]                       }
[17:39:29.125]                     })
[17:39:29.125]                   }
[17:39:29.125]                   options(future.plan = NULL)
[17:39:29.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.125]                 }
[17:39:29.125]                 ...future.workdir <- getwd()
[17:39:29.125]             }
[17:39:29.125]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.125]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.125]         }
[17:39:29.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.125]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:29.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.125]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.125]             base::names(...future.oldOptions))
[17:39:29.125]     }
[17:39:29.125]     if (FALSE) {
[17:39:29.125]     }
[17:39:29.125]     else {
[17:39:29.125]         if (TRUE) {
[17:39:29.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.125]                 open = "w")
[17:39:29.125]         }
[17:39:29.125]         else {
[17:39:29.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.125]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.125]         }
[17:39:29.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.125]             base::sink(type = "output", split = FALSE)
[17:39:29.125]             base::close(...future.stdout)
[17:39:29.125]         }, add = TRUE)
[17:39:29.125]     }
[17:39:29.125]     ...future.frame <- base::sys.nframe()
[17:39:29.125]     ...future.conditions <- base::list()
[17:39:29.125]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.125]     if (FALSE) {
[17:39:29.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.125]     }
[17:39:29.125]     ...future.result <- base::tryCatch({
[17:39:29.125]         base::withCallingHandlers({
[17:39:29.125]             ...future.value <- base::withVisible(base::local({
[17:39:29.125]                 withCallingHandlers({
[17:39:29.125]                   {
[17:39:29.125]                     do.call(function(...) {
[17:39:29.125]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.125]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.125]                         ...future.globals.maxSize)) {
[17:39:29.125]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.125]                         on.exit(options(oopts), add = TRUE)
[17:39:29.125]                       }
[17:39:29.125]                       {
[17:39:29.125]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.125]                           FUN = function(jj) {
[17:39:29.125]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.125]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.125]                           })
[17:39:29.125]                       }
[17:39:29.125]                     }, args = future.call.arguments)
[17:39:29.125]                   }
[17:39:29.125]                 }, immediateCondition = function(cond) {
[17:39:29.125]                   save_rds <- function (object, pathname, ...) 
[17:39:29.125]                   {
[17:39:29.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.125]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.125]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.125]                         fi_tmp[["mtime"]])
[17:39:29.125]                     }
[17:39:29.125]                     tryCatch({
[17:39:29.125]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.125]                     }, error = function(ex) {
[17:39:29.125]                       msg <- conditionMessage(ex)
[17:39:29.125]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.125]                         fi_tmp[["mtime"]], msg)
[17:39:29.125]                       ex$message <- msg
[17:39:29.125]                       stop(ex)
[17:39:29.125]                     })
[17:39:29.125]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.125]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.125]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.125]                       fi <- file.info(pathname)
[17:39:29.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.125]                         fi[["size"]], fi[["mtime"]])
[17:39:29.125]                       stop(msg)
[17:39:29.125]                     }
[17:39:29.125]                     invisible(pathname)
[17:39:29.125]                   }
[17:39:29.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.125]                     rootPath = tempdir()) 
[17:39:29.125]                   {
[17:39:29.125]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.125]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.125]                       tmpdir = path, fileext = ".rds")
[17:39:29.125]                     save_rds(obj, file)
[17:39:29.125]                   }
[17:39:29.125]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.125]                   {
[17:39:29.125]                     inherits <- base::inherits
[17:39:29.125]                     invokeRestart <- base::invokeRestart
[17:39:29.125]                     is.null <- base::is.null
[17:39:29.125]                     muffled <- FALSE
[17:39:29.125]                     if (inherits(cond, "message")) {
[17:39:29.125]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.125]                       if (muffled) 
[17:39:29.125]                         invokeRestart("muffleMessage")
[17:39:29.125]                     }
[17:39:29.125]                     else if (inherits(cond, "warning")) {
[17:39:29.125]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.125]                       if (muffled) 
[17:39:29.125]                         invokeRestart("muffleWarning")
[17:39:29.125]                     }
[17:39:29.125]                     else if (inherits(cond, "condition")) {
[17:39:29.125]                       if (!is.null(pattern)) {
[17:39:29.125]                         computeRestarts <- base::computeRestarts
[17:39:29.125]                         grepl <- base::grepl
[17:39:29.125]                         restarts <- computeRestarts(cond)
[17:39:29.125]                         for (restart in restarts) {
[17:39:29.125]                           name <- restart$name
[17:39:29.125]                           if (is.null(name)) 
[17:39:29.125]                             next
[17:39:29.125]                           if (!grepl(pattern, name)) 
[17:39:29.125]                             next
[17:39:29.125]                           invokeRestart(restart)
[17:39:29.125]                           muffled <- TRUE
[17:39:29.125]                           break
[17:39:29.125]                         }
[17:39:29.125]                       }
[17:39:29.125]                     }
[17:39:29.125]                     invisible(muffled)
[17:39:29.125]                   }
[17:39:29.125]                   muffleCondition(cond)
[17:39:29.125]                 })
[17:39:29.125]             }))
[17:39:29.125]             future::FutureResult(value = ...future.value$value, 
[17:39:29.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.125]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.125]                     ...future.globalenv.names))
[17:39:29.125]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.125]         }, condition = base::local({
[17:39:29.125]             c <- base::c
[17:39:29.125]             inherits <- base::inherits
[17:39:29.125]             invokeRestart <- base::invokeRestart
[17:39:29.125]             length <- base::length
[17:39:29.125]             list <- base::list
[17:39:29.125]             seq.int <- base::seq.int
[17:39:29.125]             signalCondition <- base::signalCondition
[17:39:29.125]             sys.calls <- base::sys.calls
[17:39:29.125]             `[[` <- base::`[[`
[17:39:29.125]             `+` <- base::`+`
[17:39:29.125]             `<<-` <- base::`<<-`
[17:39:29.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.125]                   3L)]
[17:39:29.125]             }
[17:39:29.125]             function(cond) {
[17:39:29.125]                 is_error <- inherits(cond, "error")
[17:39:29.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.125]                   NULL)
[17:39:29.125]                 if (is_error) {
[17:39:29.125]                   sessionInformation <- function() {
[17:39:29.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.125]                       search = base::search(), system = base::Sys.info())
[17:39:29.125]                   }
[17:39:29.125]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.125]                     cond$call), session = sessionInformation(), 
[17:39:29.125]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.125]                   signalCondition(cond)
[17:39:29.125]                 }
[17:39:29.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.125]                 "immediateCondition"))) {
[17:39:29.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.125]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.125]                   if (TRUE && !signal) {
[17:39:29.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.125]                     {
[17:39:29.125]                       inherits <- base::inherits
[17:39:29.125]                       invokeRestart <- base::invokeRestart
[17:39:29.125]                       is.null <- base::is.null
[17:39:29.125]                       muffled <- FALSE
[17:39:29.125]                       if (inherits(cond, "message")) {
[17:39:29.125]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.125]                         if (muffled) 
[17:39:29.125]                           invokeRestart("muffleMessage")
[17:39:29.125]                       }
[17:39:29.125]                       else if (inherits(cond, "warning")) {
[17:39:29.125]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.125]                         if (muffled) 
[17:39:29.125]                           invokeRestart("muffleWarning")
[17:39:29.125]                       }
[17:39:29.125]                       else if (inherits(cond, "condition")) {
[17:39:29.125]                         if (!is.null(pattern)) {
[17:39:29.125]                           computeRestarts <- base::computeRestarts
[17:39:29.125]                           grepl <- base::grepl
[17:39:29.125]                           restarts <- computeRestarts(cond)
[17:39:29.125]                           for (restart in restarts) {
[17:39:29.125]                             name <- restart$name
[17:39:29.125]                             if (is.null(name)) 
[17:39:29.125]                               next
[17:39:29.125]                             if (!grepl(pattern, name)) 
[17:39:29.125]                               next
[17:39:29.125]                             invokeRestart(restart)
[17:39:29.125]                             muffled <- TRUE
[17:39:29.125]                             break
[17:39:29.125]                           }
[17:39:29.125]                         }
[17:39:29.125]                       }
[17:39:29.125]                       invisible(muffled)
[17:39:29.125]                     }
[17:39:29.125]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.125]                   }
[17:39:29.125]                 }
[17:39:29.125]                 else {
[17:39:29.125]                   if (TRUE) {
[17:39:29.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.125]                     {
[17:39:29.125]                       inherits <- base::inherits
[17:39:29.125]                       invokeRestart <- base::invokeRestart
[17:39:29.125]                       is.null <- base::is.null
[17:39:29.125]                       muffled <- FALSE
[17:39:29.125]                       if (inherits(cond, "message")) {
[17:39:29.125]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.125]                         if (muffled) 
[17:39:29.125]                           invokeRestart("muffleMessage")
[17:39:29.125]                       }
[17:39:29.125]                       else if (inherits(cond, "warning")) {
[17:39:29.125]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.125]                         if (muffled) 
[17:39:29.125]                           invokeRestart("muffleWarning")
[17:39:29.125]                       }
[17:39:29.125]                       else if (inherits(cond, "condition")) {
[17:39:29.125]                         if (!is.null(pattern)) {
[17:39:29.125]                           computeRestarts <- base::computeRestarts
[17:39:29.125]                           grepl <- base::grepl
[17:39:29.125]                           restarts <- computeRestarts(cond)
[17:39:29.125]                           for (restart in restarts) {
[17:39:29.125]                             name <- restart$name
[17:39:29.125]                             if (is.null(name)) 
[17:39:29.125]                               next
[17:39:29.125]                             if (!grepl(pattern, name)) 
[17:39:29.125]                               next
[17:39:29.125]                             invokeRestart(restart)
[17:39:29.125]                             muffled <- TRUE
[17:39:29.125]                             break
[17:39:29.125]                           }
[17:39:29.125]                         }
[17:39:29.125]                       }
[17:39:29.125]                       invisible(muffled)
[17:39:29.125]                     }
[17:39:29.125]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.125]                   }
[17:39:29.125]                 }
[17:39:29.125]             }
[17:39:29.125]         }))
[17:39:29.125]     }, error = function(ex) {
[17:39:29.125]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.125]                 ...future.rng), started = ...future.startTime, 
[17:39:29.125]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.125]             version = "1.8"), class = "FutureResult")
[17:39:29.125]     }, finally = {
[17:39:29.125]         if (!identical(...future.workdir, getwd())) 
[17:39:29.125]             setwd(...future.workdir)
[17:39:29.125]         {
[17:39:29.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.125]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.125]             }
[17:39:29.125]             base::options(...future.oldOptions)
[17:39:29.125]             if (.Platform$OS.type == "windows") {
[17:39:29.125]                 old_names <- names(...future.oldEnvVars)
[17:39:29.125]                 envs <- base::Sys.getenv()
[17:39:29.125]                 names <- names(envs)
[17:39:29.125]                 common <- intersect(names, old_names)
[17:39:29.125]                 added <- setdiff(names, old_names)
[17:39:29.125]                 removed <- setdiff(old_names, names)
[17:39:29.125]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.125]                   envs[common]]
[17:39:29.125]                 NAMES <- toupper(changed)
[17:39:29.125]                 args <- list()
[17:39:29.125]                 for (kk in seq_along(NAMES)) {
[17:39:29.125]                   name <- changed[[kk]]
[17:39:29.125]                   NAME <- NAMES[[kk]]
[17:39:29.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.125]                     next
[17:39:29.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.125]                 }
[17:39:29.125]                 NAMES <- toupper(added)
[17:39:29.125]                 for (kk in seq_along(NAMES)) {
[17:39:29.125]                   name <- added[[kk]]
[17:39:29.125]                   NAME <- NAMES[[kk]]
[17:39:29.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.125]                     next
[17:39:29.125]                   args[[name]] <- ""
[17:39:29.125]                 }
[17:39:29.125]                 NAMES <- toupper(removed)
[17:39:29.125]                 for (kk in seq_along(NAMES)) {
[17:39:29.125]                   name <- removed[[kk]]
[17:39:29.125]                   NAME <- NAMES[[kk]]
[17:39:29.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.125]                     next
[17:39:29.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.125]                 }
[17:39:29.125]                 if (length(args) > 0) 
[17:39:29.125]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.125]             }
[17:39:29.125]             else {
[17:39:29.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.125]             }
[17:39:29.125]             {
[17:39:29.125]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.125]                   0L) {
[17:39:29.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.125]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.125]                   base::options(opts)
[17:39:29.125]                 }
[17:39:29.125]                 {
[17:39:29.125]                   {
[17:39:29.125]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.125]                     NULL
[17:39:29.125]                   }
[17:39:29.125]                   options(future.plan = NULL)
[17:39:29.125]                   if (is.na(NA_character_)) 
[17:39:29.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.125]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.125]                     envir = parent.frame()) 
[17:39:29.125]                   {
[17:39:29.125]                     default_workers <- missing(workers)
[17:39:29.125]                     if (is.function(workers)) 
[17:39:29.125]                       workers <- workers()
[17:39:29.125]                     workers <- structure(as.integer(workers), 
[17:39:29.125]                       class = class(workers))
[17:39:29.125]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.125]                       1L)
[17:39:29.125]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.125]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.125]                       if (default_workers) 
[17:39:29.125]                         supportsMulticore(warn = TRUE)
[17:39:29.125]                       return(sequential(..., envir = envir))
[17:39:29.125]                     }
[17:39:29.125]                     oopts <- options(mc.cores = workers)
[17:39:29.125]                     on.exit(options(oopts))
[17:39:29.125]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.125]                       envir = envir)
[17:39:29.125]                     if (!future$lazy) 
[17:39:29.125]                       future <- run(future)
[17:39:29.125]                     invisible(future)
[17:39:29.125]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.125]                 }
[17:39:29.125]             }
[17:39:29.125]         }
[17:39:29.125]     })
[17:39:29.125]     if (TRUE) {
[17:39:29.125]         base::sink(type = "output", split = FALSE)
[17:39:29.125]         if (TRUE) {
[17:39:29.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.125]         }
[17:39:29.125]         else {
[17:39:29.125]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.125]         }
[17:39:29.125]         base::close(...future.stdout)
[17:39:29.125]         ...future.stdout <- NULL
[17:39:29.125]     }
[17:39:29.125]     ...future.result$conditions <- ...future.conditions
[17:39:29.125]     ...future.result$finished <- base::Sys.time()
[17:39:29.125]     ...future.result
[17:39:29.125] }
[17:39:29.129] assign_globals() ...
[17:39:29.129] List of 5
[17:39:29.129]  $ ...future.FUN            :function (x, ...)  
[17:39:29.129]  $ future.call.arguments    :List of 1
[17:39:29.129]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:29.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.129]  $ ...future.elements_ii    :List of 2
[17:39:29.129]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:29.129]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:29.129]  $ ...future.seeds_ii       : NULL
[17:39:29.129]  $ ...future.globals.maxSize: NULL
[17:39:29.129]  - attr(*, "resolved")= logi FALSE
[17:39:29.129]  - attr(*, "total_size")= num 1328
[17:39:29.129]  - attr(*, "where")=List of 5
[17:39:29.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.129]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.129]  - attr(*, "already-done")= logi TRUE
[17:39:29.142] - copied ‘...future.FUN’ to environment
[17:39:29.142] - copied ‘future.call.arguments’ to environment
[17:39:29.142] - copied ‘...future.elements_ii’ to environment
[17:39:29.143] - copied ‘...future.seeds_ii’ to environment
[17:39:29.143] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.143] assign_globals() ... done
[17:39:29.143] requestCore(): workers = 2
[17:39:29.146] MulticoreFuture started
[17:39:29.146] - Launch lazy future ... done
[17:39:29.146] run() for ‘MulticoreFuture’ ... done
[17:39:29.147] Created future:
[17:39:29.147] plan(): Setting new future strategy stack:
[17:39:29.148] List of future strategies:
[17:39:29.148] 1. sequential:
[17:39:29.148]    - args: function (..., envir = parent.frame())
[17:39:29.148]    - tweaked: FALSE
[17:39:29.148]    - call: NULL
[17:39:29.149] plan(): nbrOfWorkers() = 1
[17:39:29.151] plan(): Setting new future strategy stack:
[17:39:29.152] List of future strategies:
[17:39:29.152] 1. multicore:
[17:39:29.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.152]    - tweaked: FALSE
[17:39:29.152]    - call: plan(strategy)
[17:39:29.157] plan(): nbrOfWorkers() = 2
[17:39:29.147] MulticoreFuture:
[17:39:29.147] Label: ‘future_eapply-2’
[17:39:29.147] Expression:
[17:39:29.147] {
[17:39:29.147]     do.call(function(...) {
[17:39:29.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.147]             on.exit(options(oopts), add = TRUE)
[17:39:29.147]         }
[17:39:29.147]         {
[17:39:29.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.147]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.147]             })
[17:39:29.147]         }
[17:39:29.147]     }, args = future.call.arguments)
[17:39:29.147] }
[17:39:29.147] Lazy evaluation: FALSE
[17:39:29.147] Asynchronous evaluation: TRUE
[17:39:29.147] Local evaluation: TRUE
[17:39:29.147] Environment: R_GlobalEnv
[17:39:29.147] Capture standard output: TRUE
[17:39:29.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.147] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.147] Packages: 1 packages (‘stats’)
[17:39:29.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.147] Resolved: TRUE
[17:39:29.147] Value: <not collected>
[17:39:29.147] Conditions captured: <none>
[17:39:29.147] Early signaling: FALSE
[17:39:29.147] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.147] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.158] Chunk #2 of 2 ... DONE
[17:39:29.159] Launching 2 futures (chunks) ... DONE
[17:39:29.159] Resolving 2 futures (chunks) ...
[17:39:29.159] resolve() on list ...
[17:39:29.159]  recursive: 0
[17:39:29.159]  length: 2
[17:39:29.159] 
[17:39:29.160] Future #1
[17:39:29.161] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:29.161] - nx: 2
[17:39:29.161] - relay: TRUE
[17:39:29.161] - stdout: TRUE
[17:39:29.162] - signal: TRUE
[17:39:29.162] - resignal: FALSE
[17:39:29.162] - force: TRUE
[17:39:29.162] - relayed: [n=2] FALSE, FALSE
[17:39:29.162] - queued futures: [n=2] FALSE, FALSE
[17:39:29.162]  - until=1
[17:39:29.163]  - relaying element #1
[17:39:29.163] - relayed: [n=2] TRUE, FALSE
[17:39:29.163] - queued futures: [n=2] TRUE, FALSE
[17:39:29.163] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:29.163]  length: 1 (resolved future 1)
[17:39:29.164] Future #2
[17:39:29.165] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:29.165] - nx: 2
[17:39:29.165] - relay: TRUE
[17:39:29.165] - stdout: TRUE
[17:39:29.165] - signal: TRUE
[17:39:29.165] - resignal: FALSE
[17:39:29.166] - force: TRUE
[17:39:29.166] - relayed: [n=2] TRUE, FALSE
[17:39:29.166] - queued futures: [n=2] TRUE, FALSE
[17:39:29.166]  - until=2
[17:39:29.166]  - relaying element #2
[17:39:29.166] - relayed: [n=2] TRUE, TRUE
[17:39:29.166] - queued futures: [n=2] TRUE, TRUE
[17:39:29.167] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:29.167]  length: 0 (resolved future 2)
[17:39:29.167] Relaying remaining futures
[17:39:29.167] signalConditionsASAP(NULL, pos=0) ...
[17:39:29.167] - nx: 2
[17:39:29.167] - relay: TRUE
[17:39:29.167] - stdout: TRUE
[17:39:29.167] - signal: TRUE
[17:39:29.168] - resignal: FALSE
[17:39:29.168] - force: TRUE
[17:39:29.168] - relayed: [n=2] TRUE, TRUE
[17:39:29.168] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:29.168] - relayed: [n=2] TRUE, TRUE
[17:39:29.168] - queued futures: [n=2] TRUE, TRUE
[17:39:29.168] signalConditionsASAP(NULL, pos=0) ... done
[17:39:29.168] resolve() on list ... DONE
[17:39:29.169]  - Number of value chunks collected: 2
[17:39:29.169] Resolving 2 futures (chunks) ... DONE
[17:39:29.169] Reducing values from 2 chunks ...
[17:39:29.169]  - Number of values collected after concatenation: 3
[17:39:29.169]  - Number of values expected: 3
[17:39:29.169] Reducing values from 2 chunks ... DONE
[17:39:29.169] future_lapply() ... DONE
[17:39:29.171] future_lapply() ...
[17:39:29.176] Number of chunks: 2
[17:39:29.176] getGlobalsAndPackagesXApply() ...
[17:39:29.176]  - future.globals: TRUE
[17:39:29.176] getGlobalsAndPackages() ...
[17:39:29.176] Searching for globals...
[17:39:29.178] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:29.178] Searching for globals ... DONE
[17:39:29.178] Resolving globals: FALSE
[17:39:29.178] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:29.179] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:29.179] - globals: [1] ‘FUN’
[17:39:29.179] - packages: [1] ‘stats’
[17:39:29.179] getGlobalsAndPackages() ... DONE
[17:39:29.179]  - globals found/used: [n=1] ‘FUN’
[17:39:29.180]  - needed namespaces: [n=1] ‘stats’
[17:39:29.180] Finding globals ... DONE
[17:39:29.180]  - use_args: TRUE
[17:39:29.180]  - Getting '...' globals ...
[17:39:29.180] resolve() on list ...
[17:39:29.180]  recursive: 0
[17:39:29.181]  length: 1
[17:39:29.181]  elements: ‘...’
[17:39:29.181]  length: 0 (resolved future 1)
[17:39:29.181] resolve() on list ... DONE
[17:39:29.181]    - '...' content: [n=0] 
[17:39:29.181] List of 1
[17:39:29.181]  $ ...: list()
[17:39:29.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.181]  - attr(*, "where")=List of 1
[17:39:29.181]   ..$ ...:<environment: 0x555b6596d928> 
[17:39:29.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.181]  - attr(*, "resolved")= logi TRUE
[17:39:29.181]  - attr(*, "total_size")= num NA
[17:39:29.187]  - Getting '...' globals ... DONE
[17:39:29.187] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:29.187] List of 2
[17:39:29.187]  $ ...future.FUN:function (x, ...)  
[17:39:29.187]  $ ...          : list()
[17:39:29.187]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.187]  - attr(*, "where")=List of 2
[17:39:29.187]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:29.187]   ..$ ...          :<environment: 0x555b6596d928> 
[17:39:29.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.187]  - attr(*, "resolved")= logi FALSE
[17:39:29.187]  - attr(*, "total_size")= num 1248
[17:39:29.191] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:29.191] getGlobalsAndPackagesXApply() ... DONE
[17:39:29.191] Number of futures (= number of chunks): 2
[17:39:29.191] Launching 2 futures (chunks) ...
[17:39:29.191] Chunk #1 of 2 ...
[17:39:29.191]  - Finding globals in 'X' for chunk #1 ...
[17:39:29.192] getGlobalsAndPackages() ...
[17:39:29.192] Searching for globals...
[17:39:29.192] 
[17:39:29.192] Searching for globals ... DONE
[17:39:29.192] - globals: [0] <none>
[17:39:29.192] getGlobalsAndPackages() ... DONE
[17:39:29.192]    + additional globals found: [n=0] 
[17:39:29.193]    + additional namespaces needed: [n=0] 
[17:39:29.193]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:29.193]  - seeds: <none>
[17:39:29.193] getGlobalsAndPackages() ...
[17:39:29.193] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.193] Resolving globals: FALSE
[17:39:29.193] Tweak future expression to call with '...' arguments ...
[17:39:29.193] {
[17:39:29.193]     do.call(function(...) {
[17:39:29.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.193]             on.exit(options(oopts), add = TRUE)
[17:39:29.193]         }
[17:39:29.193]         {
[17:39:29.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.193]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.193]             })
[17:39:29.193]         }
[17:39:29.193]     }, args = future.call.arguments)
[17:39:29.193] }
[17:39:29.194] Tweak future expression to call with '...' arguments ... DONE
[17:39:29.194] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.194] - packages: [1] ‘stats’
[17:39:29.194] getGlobalsAndPackages() ... DONE
[17:39:29.195] run() for ‘Future’ ...
[17:39:29.195] - state: ‘created’
[17:39:29.195] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.199] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.199]   - Field: ‘label’
[17:39:29.199]   - Field: ‘local’
[17:39:29.199]   - Field: ‘owner’
[17:39:29.200]   - Field: ‘envir’
[17:39:29.200]   - Field: ‘workers’
[17:39:29.200]   - Field: ‘packages’
[17:39:29.200]   - Field: ‘gc’
[17:39:29.200]   - Field: ‘job’
[17:39:29.200]   - Field: ‘conditions’
[17:39:29.200]   - Field: ‘expr’
[17:39:29.200]   - Field: ‘uuid’
[17:39:29.200]   - Field: ‘seed’
[17:39:29.201]   - Field: ‘version’
[17:39:29.201]   - Field: ‘result’
[17:39:29.201]   - Field: ‘asynchronous’
[17:39:29.201]   - Field: ‘calls’
[17:39:29.201]   - Field: ‘globals’
[17:39:29.201]   - Field: ‘stdout’
[17:39:29.201]   - Field: ‘earlySignal’
[17:39:29.201]   - Field: ‘lazy’
[17:39:29.201]   - Field: ‘state’
[17:39:29.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.202] - Launch lazy future ...
[17:39:29.202] Packages needed by the future expression (n = 1): ‘stats’
[17:39:29.202] Packages needed by future strategies (n = 0): <none>
[17:39:29.203] {
[17:39:29.203]     {
[17:39:29.203]         {
[17:39:29.203]             ...future.startTime <- base::Sys.time()
[17:39:29.203]             {
[17:39:29.203]                 {
[17:39:29.203]                   {
[17:39:29.203]                     {
[17:39:29.203]                       {
[17:39:29.203]                         base::local({
[17:39:29.203]                           has_future <- base::requireNamespace("future", 
[17:39:29.203]                             quietly = TRUE)
[17:39:29.203]                           if (has_future) {
[17:39:29.203]                             ns <- base::getNamespace("future")
[17:39:29.203]                             version <- ns[[".package"]][["version"]]
[17:39:29.203]                             if (is.null(version)) 
[17:39:29.203]                               version <- utils::packageVersion("future")
[17:39:29.203]                           }
[17:39:29.203]                           else {
[17:39:29.203]                             version <- NULL
[17:39:29.203]                           }
[17:39:29.203]                           if (!has_future || version < "1.8.0") {
[17:39:29.203]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.203]                               "", base::R.version$version.string), 
[17:39:29.203]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:29.203]                                 base::R.version$platform, 8 * 
[17:39:29.203]                                   base::.Machine$sizeof.pointer), 
[17:39:29.203]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.203]                                 "release", "version")], collapse = " "), 
[17:39:29.203]                               hostname = base::Sys.info()[["nodename"]])
[17:39:29.203]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.203]                               info)
[17:39:29.203]                             info <- base::paste(info, collapse = "; ")
[17:39:29.203]                             if (!has_future) {
[17:39:29.203]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.203]                                 info)
[17:39:29.203]                             }
[17:39:29.203]                             else {
[17:39:29.203]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.203]                                 info, version)
[17:39:29.203]                             }
[17:39:29.203]                             base::stop(msg)
[17:39:29.203]                           }
[17:39:29.203]                         })
[17:39:29.203]                       }
[17:39:29.203]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.203]                       base::options(mc.cores = 1L)
[17:39:29.203]                     }
[17:39:29.203]                     base::local({
[17:39:29.203]                       for (pkg in "stats") {
[17:39:29.203]                         base::loadNamespace(pkg)
[17:39:29.203]                         base::library(pkg, character.only = TRUE)
[17:39:29.203]                       }
[17:39:29.203]                     })
[17:39:29.203]                   }
[17:39:29.203]                   options(future.plan = NULL)
[17:39:29.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.203]                 }
[17:39:29.203]                 ...future.workdir <- getwd()
[17:39:29.203]             }
[17:39:29.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.203]         }
[17:39:29.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:29.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.203]             base::names(...future.oldOptions))
[17:39:29.203]     }
[17:39:29.203]     if (FALSE) {
[17:39:29.203]     }
[17:39:29.203]     else {
[17:39:29.203]         if (TRUE) {
[17:39:29.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.203]                 open = "w")
[17:39:29.203]         }
[17:39:29.203]         else {
[17:39:29.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.203]         }
[17:39:29.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.203]             base::sink(type = "output", split = FALSE)
[17:39:29.203]             base::close(...future.stdout)
[17:39:29.203]         }, add = TRUE)
[17:39:29.203]     }
[17:39:29.203]     ...future.frame <- base::sys.nframe()
[17:39:29.203]     ...future.conditions <- base::list()
[17:39:29.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.203]     if (FALSE) {
[17:39:29.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.203]     }
[17:39:29.203]     ...future.result <- base::tryCatch({
[17:39:29.203]         base::withCallingHandlers({
[17:39:29.203]             ...future.value <- base::withVisible(base::local({
[17:39:29.203]                 withCallingHandlers({
[17:39:29.203]                   {
[17:39:29.203]                     do.call(function(...) {
[17:39:29.203]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.203]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.203]                         ...future.globals.maxSize)) {
[17:39:29.203]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.203]                         on.exit(options(oopts), add = TRUE)
[17:39:29.203]                       }
[17:39:29.203]                       {
[17:39:29.203]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.203]                           FUN = function(jj) {
[17:39:29.203]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.203]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.203]                           })
[17:39:29.203]                       }
[17:39:29.203]                     }, args = future.call.arguments)
[17:39:29.203]                   }
[17:39:29.203]                 }, immediateCondition = function(cond) {
[17:39:29.203]                   save_rds <- function (object, pathname, ...) 
[17:39:29.203]                   {
[17:39:29.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.203]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.203]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.203]                         fi_tmp[["mtime"]])
[17:39:29.203]                     }
[17:39:29.203]                     tryCatch({
[17:39:29.203]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.203]                     }, error = function(ex) {
[17:39:29.203]                       msg <- conditionMessage(ex)
[17:39:29.203]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.203]                         fi_tmp[["mtime"]], msg)
[17:39:29.203]                       ex$message <- msg
[17:39:29.203]                       stop(ex)
[17:39:29.203]                     })
[17:39:29.203]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.203]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.203]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.203]                       fi <- file.info(pathname)
[17:39:29.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.203]                         fi[["size"]], fi[["mtime"]])
[17:39:29.203]                       stop(msg)
[17:39:29.203]                     }
[17:39:29.203]                     invisible(pathname)
[17:39:29.203]                   }
[17:39:29.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.203]                     rootPath = tempdir()) 
[17:39:29.203]                   {
[17:39:29.203]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.203]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.203]                       tmpdir = path, fileext = ".rds")
[17:39:29.203]                     save_rds(obj, file)
[17:39:29.203]                   }
[17:39:29.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.203]                   {
[17:39:29.203]                     inherits <- base::inherits
[17:39:29.203]                     invokeRestart <- base::invokeRestart
[17:39:29.203]                     is.null <- base::is.null
[17:39:29.203]                     muffled <- FALSE
[17:39:29.203]                     if (inherits(cond, "message")) {
[17:39:29.203]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.203]                       if (muffled) 
[17:39:29.203]                         invokeRestart("muffleMessage")
[17:39:29.203]                     }
[17:39:29.203]                     else if (inherits(cond, "warning")) {
[17:39:29.203]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.203]                       if (muffled) 
[17:39:29.203]                         invokeRestart("muffleWarning")
[17:39:29.203]                     }
[17:39:29.203]                     else if (inherits(cond, "condition")) {
[17:39:29.203]                       if (!is.null(pattern)) {
[17:39:29.203]                         computeRestarts <- base::computeRestarts
[17:39:29.203]                         grepl <- base::grepl
[17:39:29.203]                         restarts <- computeRestarts(cond)
[17:39:29.203]                         for (restart in restarts) {
[17:39:29.203]                           name <- restart$name
[17:39:29.203]                           if (is.null(name)) 
[17:39:29.203]                             next
[17:39:29.203]                           if (!grepl(pattern, name)) 
[17:39:29.203]                             next
[17:39:29.203]                           invokeRestart(restart)
[17:39:29.203]                           muffled <- TRUE
[17:39:29.203]                           break
[17:39:29.203]                         }
[17:39:29.203]                       }
[17:39:29.203]                     }
[17:39:29.203]                     invisible(muffled)
[17:39:29.203]                   }
[17:39:29.203]                   muffleCondition(cond)
[17:39:29.203]                 })
[17:39:29.203]             }))
[17:39:29.203]             future::FutureResult(value = ...future.value$value, 
[17:39:29.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.203]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.203]                     ...future.globalenv.names))
[17:39:29.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.203]         }, condition = base::local({
[17:39:29.203]             c <- base::c
[17:39:29.203]             inherits <- base::inherits
[17:39:29.203]             invokeRestart <- base::invokeRestart
[17:39:29.203]             length <- base::length
[17:39:29.203]             list <- base::list
[17:39:29.203]             seq.int <- base::seq.int
[17:39:29.203]             signalCondition <- base::signalCondition
[17:39:29.203]             sys.calls <- base::sys.calls
[17:39:29.203]             `[[` <- base::`[[`
[17:39:29.203]             `+` <- base::`+`
[17:39:29.203]             `<<-` <- base::`<<-`
[17:39:29.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.203]                   3L)]
[17:39:29.203]             }
[17:39:29.203]             function(cond) {
[17:39:29.203]                 is_error <- inherits(cond, "error")
[17:39:29.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.203]                   NULL)
[17:39:29.203]                 if (is_error) {
[17:39:29.203]                   sessionInformation <- function() {
[17:39:29.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.203]                       search = base::search(), system = base::Sys.info())
[17:39:29.203]                   }
[17:39:29.203]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.203]                     cond$call), session = sessionInformation(), 
[17:39:29.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.203]                   signalCondition(cond)
[17:39:29.203]                 }
[17:39:29.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.203]                 "immediateCondition"))) {
[17:39:29.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.203]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.203]                   if (TRUE && !signal) {
[17:39:29.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.203]                     {
[17:39:29.203]                       inherits <- base::inherits
[17:39:29.203]                       invokeRestart <- base::invokeRestart
[17:39:29.203]                       is.null <- base::is.null
[17:39:29.203]                       muffled <- FALSE
[17:39:29.203]                       if (inherits(cond, "message")) {
[17:39:29.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.203]                         if (muffled) 
[17:39:29.203]                           invokeRestart("muffleMessage")
[17:39:29.203]                       }
[17:39:29.203]                       else if (inherits(cond, "warning")) {
[17:39:29.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.203]                         if (muffled) 
[17:39:29.203]                           invokeRestart("muffleWarning")
[17:39:29.203]                       }
[17:39:29.203]                       else if (inherits(cond, "condition")) {
[17:39:29.203]                         if (!is.null(pattern)) {
[17:39:29.203]                           computeRestarts <- base::computeRestarts
[17:39:29.203]                           grepl <- base::grepl
[17:39:29.203]                           restarts <- computeRestarts(cond)
[17:39:29.203]                           for (restart in restarts) {
[17:39:29.203]                             name <- restart$name
[17:39:29.203]                             if (is.null(name)) 
[17:39:29.203]                               next
[17:39:29.203]                             if (!grepl(pattern, name)) 
[17:39:29.203]                               next
[17:39:29.203]                             invokeRestart(restart)
[17:39:29.203]                             muffled <- TRUE
[17:39:29.203]                             break
[17:39:29.203]                           }
[17:39:29.203]                         }
[17:39:29.203]                       }
[17:39:29.203]                       invisible(muffled)
[17:39:29.203]                     }
[17:39:29.203]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.203]                   }
[17:39:29.203]                 }
[17:39:29.203]                 else {
[17:39:29.203]                   if (TRUE) {
[17:39:29.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.203]                     {
[17:39:29.203]                       inherits <- base::inherits
[17:39:29.203]                       invokeRestart <- base::invokeRestart
[17:39:29.203]                       is.null <- base::is.null
[17:39:29.203]                       muffled <- FALSE
[17:39:29.203]                       if (inherits(cond, "message")) {
[17:39:29.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.203]                         if (muffled) 
[17:39:29.203]                           invokeRestart("muffleMessage")
[17:39:29.203]                       }
[17:39:29.203]                       else if (inherits(cond, "warning")) {
[17:39:29.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.203]                         if (muffled) 
[17:39:29.203]                           invokeRestart("muffleWarning")
[17:39:29.203]                       }
[17:39:29.203]                       else if (inherits(cond, "condition")) {
[17:39:29.203]                         if (!is.null(pattern)) {
[17:39:29.203]                           computeRestarts <- base::computeRestarts
[17:39:29.203]                           grepl <- base::grepl
[17:39:29.203]                           restarts <- computeRestarts(cond)
[17:39:29.203]                           for (restart in restarts) {
[17:39:29.203]                             name <- restart$name
[17:39:29.203]                             if (is.null(name)) 
[17:39:29.203]                               next
[17:39:29.203]                             if (!grepl(pattern, name)) 
[17:39:29.203]                               next
[17:39:29.203]                             invokeRestart(restart)
[17:39:29.203]                             muffled <- TRUE
[17:39:29.203]                             break
[17:39:29.203]                           }
[17:39:29.203]                         }
[17:39:29.203]                       }
[17:39:29.203]                       invisible(muffled)
[17:39:29.203]                     }
[17:39:29.203]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.203]                   }
[17:39:29.203]                 }
[17:39:29.203]             }
[17:39:29.203]         }))
[17:39:29.203]     }, error = function(ex) {
[17:39:29.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.203]                 ...future.rng), started = ...future.startTime, 
[17:39:29.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.203]             version = "1.8"), class = "FutureResult")
[17:39:29.203]     }, finally = {
[17:39:29.203]         if (!identical(...future.workdir, getwd())) 
[17:39:29.203]             setwd(...future.workdir)
[17:39:29.203]         {
[17:39:29.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.203]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.203]             }
[17:39:29.203]             base::options(...future.oldOptions)
[17:39:29.203]             if (.Platform$OS.type == "windows") {
[17:39:29.203]                 old_names <- names(...future.oldEnvVars)
[17:39:29.203]                 envs <- base::Sys.getenv()
[17:39:29.203]                 names <- names(envs)
[17:39:29.203]                 common <- intersect(names, old_names)
[17:39:29.203]                 added <- setdiff(names, old_names)
[17:39:29.203]                 removed <- setdiff(old_names, names)
[17:39:29.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.203]                   envs[common]]
[17:39:29.203]                 NAMES <- toupper(changed)
[17:39:29.203]                 args <- list()
[17:39:29.203]                 for (kk in seq_along(NAMES)) {
[17:39:29.203]                   name <- changed[[kk]]
[17:39:29.203]                   NAME <- NAMES[[kk]]
[17:39:29.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.203]                     next
[17:39:29.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.203]                 }
[17:39:29.203]                 NAMES <- toupper(added)
[17:39:29.203]                 for (kk in seq_along(NAMES)) {
[17:39:29.203]                   name <- added[[kk]]
[17:39:29.203]                   NAME <- NAMES[[kk]]
[17:39:29.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.203]                     next
[17:39:29.203]                   args[[name]] <- ""
[17:39:29.203]                 }
[17:39:29.203]                 NAMES <- toupper(removed)
[17:39:29.203]                 for (kk in seq_along(NAMES)) {
[17:39:29.203]                   name <- removed[[kk]]
[17:39:29.203]                   NAME <- NAMES[[kk]]
[17:39:29.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.203]                     next
[17:39:29.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.203]                 }
[17:39:29.203]                 if (length(args) > 0) 
[17:39:29.203]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.203]             }
[17:39:29.203]             else {
[17:39:29.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.203]             }
[17:39:29.203]             {
[17:39:29.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.203]                   0L) {
[17:39:29.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.203]                   base::options(opts)
[17:39:29.203]                 }
[17:39:29.203]                 {
[17:39:29.203]                   {
[17:39:29.203]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.203]                     NULL
[17:39:29.203]                   }
[17:39:29.203]                   options(future.plan = NULL)
[17:39:29.203]                   if (is.na(NA_character_)) 
[17:39:29.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.203]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.203]                     envir = parent.frame()) 
[17:39:29.203]                   {
[17:39:29.203]                     default_workers <- missing(workers)
[17:39:29.203]                     if (is.function(workers)) 
[17:39:29.203]                       workers <- workers()
[17:39:29.203]                     workers <- structure(as.integer(workers), 
[17:39:29.203]                       class = class(workers))
[17:39:29.203]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.203]                       1L)
[17:39:29.203]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.203]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.203]                       if (default_workers) 
[17:39:29.203]                         supportsMulticore(warn = TRUE)
[17:39:29.203]                       return(sequential(..., envir = envir))
[17:39:29.203]                     }
[17:39:29.203]                     oopts <- options(mc.cores = workers)
[17:39:29.203]                     on.exit(options(oopts))
[17:39:29.203]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.203]                       envir = envir)
[17:39:29.203]                     if (!future$lazy) 
[17:39:29.203]                       future <- run(future)
[17:39:29.203]                     invisible(future)
[17:39:29.203]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.203]                 }
[17:39:29.203]             }
[17:39:29.203]         }
[17:39:29.203]     })
[17:39:29.203]     if (TRUE) {
[17:39:29.203]         base::sink(type = "output", split = FALSE)
[17:39:29.203]         if (TRUE) {
[17:39:29.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.203]         }
[17:39:29.203]         else {
[17:39:29.203]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.203]         }
[17:39:29.203]         base::close(...future.stdout)
[17:39:29.203]         ...future.stdout <- NULL
[17:39:29.203]     }
[17:39:29.203]     ...future.result$conditions <- ...future.conditions
[17:39:29.203]     ...future.result$finished <- base::Sys.time()
[17:39:29.203]     ...future.result
[17:39:29.203] }
[17:39:29.205] assign_globals() ...
[17:39:29.206] List of 5
[17:39:29.206]  $ ...future.FUN            :function (x, ...)  
[17:39:29.206]  $ future.call.arguments    : list()
[17:39:29.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.206]  $ ...future.elements_ii    :List of 1
[17:39:29.206]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:39:29.206]  $ ...future.seeds_ii       : NULL
[17:39:29.206]  $ ...future.globals.maxSize: NULL
[17:39:29.206]  - attr(*, "where")=List of 5
[17:39:29.206]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.206]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.206]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.206]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.206]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.206]  - attr(*, "resolved")= logi FALSE
[17:39:29.206]  - attr(*, "total_size")= num 1248
[17:39:29.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.206]  - attr(*, "already-done")= logi TRUE
[17:39:29.210] - copied ‘...future.FUN’ to environment
[17:39:29.211] - copied ‘future.call.arguments’ to environment
[17:39:29.211] - copied ‘...future.elements_ii’ to environment
[17:39:29.211] - copied ‘...future.seeds_ii’ to environment
[17:39:29.211] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.211] assign_globals() ... done
[17:39:29.211] requestCore(): workers = 2
[17:39:29.213] MulticoreFuture started
[17:39:29.214] - Launch lazy future ... done
[17:39:29.214] run() for ‘MulticoreFuture’ ... done
[17:39:29.214] Created future:
[17:39:29.215] plan(): Setting new future strategy stack:
[17:39:29.215] List of future strategies:
[17:39:29.215] 1. sequential:
[17:39:29.215]    - args: function (..., envir = parent.frame())
[17:39:29.215]    - tweaked: FALSE
[17:39:29.215]    - call: NULL
[17:39:29.219] plan(): nbrOfWorkers() = 1
[17:39:29.222] plan(): Setting new future strategy stack:
[17:39:29.222] List of future strategies:
[17:39:29.222] 1. multicore:
[17:39:29.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.222]    - tweaked: FALSE
[17:39:29.222]    - call: plan(strategy)
[17:39:29.229] plan(): nbrOfWorkers() = 2
[17:39:29.215] MulticoreFuture:
[17:39:29.215] Label: ‘future_eapply-1’
[17:39:29.215] Expression:
[17:39:29.215] {
[17:39:29.215]     do.call(function(...) {
[17:39:29.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.215]             on.exit(options(oopts), add = TRUE)
[17:39:29.215]         }
[17:39:29.215]         {
[17:39:29.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.215]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.215]             })
[17:39:29.215]         }
[17:39:29.215]     }, args = future.call.arguments)
[17:39:29.215] }
[17:39:29.215] Lazy evaluation: FALSE
[17:39:29.215] Asynchronous evaluation: TRUE
[17:39:29.215] Local evaluation: TRUE
[17:39:29.215] Environment: R_GlobalEnv
[17:39:29.215] Capture standard output: TRUE
[17:39:29.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.215] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.215] Packages: 1 packages (‘stats’)
[17:39:29.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.215] Resolved: TRUE
[17:39:29.215] Value: <not collected>
[17:39:29.215] Conditions captured: <none>
[17:39:29.215] Early signaling: FALSE
[17:39:29.215] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.215] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.230] Chunk #1 of 2 ... DONE
[17:39:29.230] Chunk #2 of 2 ...
[17:39:29.230]  - Finding globals in 'X' for chunk #2 ...
[17:39:29.230] getGlobalsAndPackages() ...
[17:39:29.231] Searching for globals...
[17:39:29.231] 
[17:39:29.232] Searching for globals ... DONE
[17:39:29.232] - globals: [0] <none>
[17:39:29.232] getGlobalsAndPackages() ... DONE
[17:39:29.232]    + additional globals found: [n=0] 
[17:39:29.232]    + additional namespaces needed: [n=0] 
[17:39:29.232]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:29.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:29.233]  - seeds: <none>
[17:39:29.233] getGlobalsAndPackages() ...
[17:39:29.233] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.233] Resolving globals: FALSE
[17:39:29.233] Tweak future expression to call with '...' arguments ...
[17:39:29.234] {
[17:39:29.234]     do.call(function(...) {
[17:39:29.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.234]             on.exit(options(oopts), add = TRUE)
[17:39:29.234]         }
[17:39:29.234]         {
[17:39:29.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.234]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.234]             })
[17:39:29.234]         }
[17:39:29.234]     }, args = future.call.arguments)
[17:39:29.234] }
[17:39:29.234] Tweak future expression to call with '...' arguments ... DONE
[17:39:29.235] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.235] - packages: [1] ‘stats’
[17:39:29.235] getGlobalsAndPackages() ... DONE
[17:39:29.236] run() for ‘Future’ ...
[17:39:29.236] - state: ‘created’
[17:39:29.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.241] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.241] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.242]   - Field: ‘label’
[17:39:29.242]   - Field: ‘local’
[17:39:29.242]   - Field: ‘owner’
[17:39:29.242]   - Field: ‘envir’
[17:39:29.242]   - Field: ‘workers’
[17:39:29.242]   - Field: ‘packages’
[17:39:29.242]   - Field: ‘gc’
[17:39:29.243]   - Field: ‘job’
[17:39:29.243]   - Field: ‘conditions’
[17:39:29.243]   - Field: ‘expr’
[17:39:29.243]   - Field: ‘uuid’
[17:39:29.243]   - Field: ‘seed’
[17:39:29.243]   - Field: ‘version’
[17:39:29.244]   - Field: ‘result’
[17:39:29.244]   - Field: ‘asynchronous’
[17:39:29.244]   - Field: ‘calls’
[17:39:29.244]   - Field: ‘globals’
[17:39:29.244]   - Field: ‘stdout’
[17:39:29.244]   - Field: ‘earlySignal’
[17:39:29.244]   - Field: ‘lazy’
[17:39:29.245]   - Field: ‘state’
[17:39:29.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.245] - Launch lazy future ...
[17:39:29.245] Packages needed by the future expression (n = 1): ‘stats’
[17:39:29.246] Packages needed by future strategies (n = 0): <none>
[17:39:29.247] {
[17:39:29.247]     {
[17:39:29.247]         {
[17:39:29.247]             ...future.startTime <- base::Sys.time()
[17:39:29.247]             {
[17:39:29.247]                 {
[17:39:29.247]                   {
[17:39:29.247]                     {
[17:39:29.247]                       {
[17:39:29.247]                         base::local({
[17:39:29.247]                           has_future <- base::requireNamespace("future", 
[17:39:29.247]                             quietly = TRUE)
[17:39:29.247]                           if (has_future) {
[17:39:29.247]                             ns <- base::getNamespace("future")
[17:39:29.247]                             version <- ns[[".package"]][["version"]]
[17:39:29.247]                             if (is.null(version)) 
[17:39:29.247]                               version <- utils::packageVersion("future")
[17:39:29.247]                           }
[17:39:29.247]                           else {
[17:39:29.247]                             version <- NULL
[17:39:29.247]                           }
[17:39:29.247]                           if (!has_future || version < "1.8.0") {
[17:39:29.247]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.247]                               "", base::R.version$version.string), 
[17:39:29.247]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:29.247]                                 base::R.version$platform, 8 * 
[17:39:29.247]                                   base::.Machine$sizeof.pointer), 
[17:39:29.247]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.247]                                 "release", "version")], collapse = " "), 
[17:39:29.247]                               hostname = base::Sys.info()[["nodename"]])
[17:39:29.247]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.247]                               info)
[17:39:29.247]                             info <- base::paste(info, collapse = "; ")
[17:39:29.247]                             if (!has_future) {
[17:39:29.247]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.247]                                 info)
[17:39:29.247]                             }
[17:39:29.247]                             else {
[17:39:29.247]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.247]                                 info, version)
[17:39:29.247]                             }
[17:39:29.247]                             base::stop(msg)
[17:39:29.247]                           }
[17:39:29.247]                         })
[17:39:29.247]                       }
[17:39:29.247]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.247]                       base::options(mc.cores = 1L)
[17:39:29.247]                     }
[17:39:29.247]                     base::local({
[17:39:29.247]                       for (pkg in "stats") {
[17:39:29.247]                         base::loadNamespace(pkg)
[17:39:29.247]                         base::library(pkg, character.only = TRUE)
[17:39:29.247]                       }
[17:39:29.247]                     })
[17:39:29.247]                   }
[17:39:29.247]                   options(future.plan = NULL)
[17:39:29.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.247]                 }
[17:39:29.247]                 ...future.workdir <- getwd()
[17:39:29.247]             }
[17:39:29.247]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.247]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.247]         }
[17:39:29.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.247]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:29.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.247]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.247]             base::names(...future.oldOptions))
[17:39:29.247]     }
[17:39:29.247]     if (FALSE) {
[17:39:29.247]     }
[17:39:29.247]     else {
[17:39:29.247]         if (TRUE) {
[17:39:29.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.247]                 open = "w")
[17:39:29.247]         }
[17:39:29.247]         else {
[17:39:29.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.247]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.247]         }
[17:39:29.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.247]             base::sink(type = "output", split = FALSE)
[17:39:29.247]             base::close(...future.stdout)
[17:39:29.247]         }, add = TRUE)
[17:39:29.247]     }
[17:39:29.247]     ...future.frame <- base::sys.nframe()
[17:39:29.247]     ...future.conditions <- base::list()
[17:39:29.247]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.247]     if (FALSE) {
[17:39:29.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.247]     }
[17:39:29.247]     ...future.result <- base::tryCatch({
[17:39:29.247]         base::withCallingHandlers({
[17:39:29.247]             ...future.value <- base::withVisible(base::local({
[17:39:29.247]                 withCallingHandlers({
[17:39:29.247]                   {
[17:39:29.247]                     do.call(function(...) {
[17:39:29.247]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.247]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.247]                         ...future.globals.maxSize)) {
[17:39:29.247]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.247]                         on.exit(options(oopts), add = TRUE)
[17:39:29.247]                       }
[17:39:29.247]                       {
[17:39:29.247]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.247]                           FUN = function(jj) {
[17:39:29.247]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.247]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.247]                           })
[17:39:29.247]                       }
[17:39:29.247]                     }, args = future.call.arguments)
[17:39:29.247]                   }
[17:39:29.247]                 }, immediateCondition = function(cond) {
[17:39:29.247]                   save_rds <- function (object, pathname, ...) 
[17:39:29.247]                   {
[17:39:29.247]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.247]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.247]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.247]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.247]                         fi_tmp[["mtime"]])
[17:39:29.247]                     }
[17:39:29.247]                     tryCatch({
[17:39:29.247]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.247]                     }, error = function(ex) {
[17:39:29.247]                       msg <- conditionMessage(ex)
[17:39:29.247]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.247]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.247]                         fi_tmp[["mtime"]], msg)
[17:39:29.247]                       ex$message <- msg
[17:39:29.247]                       stop(ex)
[17:39:29.247]                     })
[17:39:29.247]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.247]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.247]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.247]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.247]                       fi <- file.info(pathname)
[17:39:29.247]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.247]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.247]                         fi[["size"]], fi[["mtime"]])
[17:39:29.247]                       stop(msg)
[17:39:29.247]                     }
[17:39:29.247]                     invisible(pathname)
[17:39:29.247]                   }
[17:39:29.247]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.247]                     rootPath = tempdir()) 
[17:39:29.247]                   {
[17:39:29.247]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.247]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.247]                       tmpdir = path, fileext = ".rds")
[17:39:29.247]                     save_rds(obj, file)
[17:39:29.247]                   }
[17:39:29.247]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.247]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.247]                   {
[17:39:29.247]                     inherits <- base::inherits
[17:39:29.247]                     invokeRestart <- base::invokeRestart
[17:39:29.247]                     is.null <- base::is.null
[17:39:29.247]                     muffled <- FALSE
[17:39:29.247]                     if (inherits(cond, "message")) {
[17:39:29.247]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.247]                       if (muffled) 
[17:39:29.247]                         invokeRestart("muffleMessage")
[17:39:29.247]                     }
[17:39:29.247]                     else if (inherits(cond, "warning")) {
[17:39:29.247]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.247]                       if (muffled) 
[17:39:29.247]                         invokeRestart("muffleWarning")
[17:39:29.247]                     }
[17:39:29.247]                     else if (inherits(cond, "condition")) {
[17:39:29.247]                       if (!is.null(pattern)) {
[17:39:29.247]                         computeRestarts <- base::computeRestarts
[17:39:29.247]                         grepl <- base::grepl
[17:39:29.247]                         restarts <- computeRestarts(cond)
[17:39:29.247]                         for (restart in restarts) {
[17:39:29.247]                           name <- restart$name
[17:39:29.247]                           if (is.null(name)) 
[17:39:29.247]                             next
[17:39:29.247]                           if (!grepl(pattern, name)) 
[17:39:29.247]                             next
[17:39:29.247]                           invokeRestart(restart)
[17:39:29.247]                           muffled <- TRUE
[17:39:29.247]                           break
[17:39:29.247]                         }
[17:39:29.247]                       }
[17:39:29.247]                     }
[17:39:29.247]                     invisible(muffled)
[17:39:29.247]                   }
[17:39:29.247]                   muffleCondition(cond)
[17:39:29.247]                 })
[17:39:29.247]             }))
[17:39:29.247]             future::FutureResult(value = ...future.value$value, 
[17:39:29.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.247]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.247]                     ...future.globalenv.names))
[17:39:29.247]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.247]         }, condition = base::local({
[17:39:29.247]             c <- base::c
[17:39:29.247]             inherits <- base::inherits
[17:39:29.247]             invokeRestart <- base::invokeRestart
[17:39:29.247]             length <- base::length
[17:39:29.247]             list <- base::list
[17:39:29.247]             seq.int <- base::seq.int
[17:39:29.247]             signalCondition <- base::signalCondition
[17:39:29.247]             sys.calls <- base::sys.calls
[17:39:29.247]             `[[` <- base::`[[`
[17:39:29.247]             `+` <- base::`+`
[17:39:29.247]             `<<-` <- base::`<<-`
[17:39:29.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.247]                   3L)]
[17:39:29.247]             }
[17:39:29.247]             function(cond) {
[17:39:29.247]                 is_error <- inherits(cond, "error")
[17:39:29.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.247]                   NULL)
[17:39:29.247]                 if (is_error) {
[17:39:29.247]                   sessionInformation <- function() {
[17:39:29.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.247]                       search = base::search(), system = base::Sys.info())
[17:39:29.247]                   }
[17:39:29.247]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.247]                     cond$call), session = sessionInformation(), 
[17:39:29.247]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.247]                   signalCondition(cond)
[17:39:29.247]                 }
[17:39:29.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.247]                 "immediateCondition"))) {
[17:39:29.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.247]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.247]                   if (TRUE && !signal) {
[17:39:29.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.247]                     {
[17:39:29.247]                       inherits <- base::inherits
[17:39:29.247]                       invokeRestart <- base::invokeRestart
[17:39:29.247]                       is.null <- base::is.null
[17:39:29.247]                       muffled <- FALSE
[17:39:29.247]                       if (inherits(cond, "message")) {
[17:39:29.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.247]                         if (muffled) 
[17:39:29.247]                           invokeRestart("muffleMessage")
[17:39:29.247]                       }
[17:39:29.247]                       else if (inherits(cond, "warning")) {
[17:39:29.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.247]                         if (muffled) 
[17:39:29.247]                           invokeRestart("muffleWarning")
[17:39:29.247]                       }
[17:39:29.247]                       else if (inherits(cond, "condition")) {
[17:39:29.247]                         if (!is.null(pattern)) {
[17:39:29.247]                           computeRestarts <- base::computeRestarts
[17:39:29.247]                           grepl <- base::grepl
[17:39:29.247]                           restarts <- computeRestarts(cond)
[17:39:29.247]                           for (restart in restarts) {
[17:39:29.247]                             name <- restart$name
[17:39:29.247]                             if (is.null(name)) 
[17:39:29.247]                               next
[17:39:29.247]                             if (!grepl(pattern, name)) 
[17:39:29.247]                               next
[17:39:29.247]                             invokeRestart(restart)
[17:39:29.247]                             muffled <- TRUE
[17:39:29.247]                             break
[17:39:29.247]                           }
[17:39:29.247]                         }
[17:39:29.247]                       }
[17:39:29.247]                       invisible(muffled)
[17:39:29.247]                     }
[17:39:29.247]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.247]                   }
[17:39:29.247]                 }
[17:39:29.247]                 else {
[17:39:29.247]                   if (TRUE) {
[17:39:29.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.247]                     {
[17:39:29.247]                       inherits <- base::inherits
[17:39:29.247]                       invokeRestart <- base::invokeRestart
[17:39:29.247]                       is.null <- base::is.null
[17:39:29.247]                       muffled <- FALSE
[17:39:29.247]                       if (inherits(cond, "message")) {
[17:39:29.247]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.247]                         if (muffled) 
[17:39:29.247]                           invokeRestart("muffleMessage")
[17:39:29.247]                       }
[17:39:29.247]                       else if (inherits(cond, "warning")) {
[17:39:29.247]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.247]                         if (muffled) 
[17:39:29.247]                           invokeRestart("muffleWarning")
[17:39:29.247]                       }
[17:39:29.247]                       else if (inherits(cond, "condition")) {
[17:39:29.247]                         if (!is.null(pattern)) {
[17:39:29.247]                           computeRestarts <- base::computeRestarts
[17:39:29.247]                           grepl <- base::grepl
[17:39:29.247]                           restarts <- computeRestarts(cond)
[17:39:29.247]                           for (restart in restarts) {
[17:39:29.247]                             name <- restart$name
[17:39:29.247]                             if (is.null(name)) 
[17:39:29.247]                               next
[17:39:29.247]                             if (!grepl(pattern, name)) 
[17:39:29.247]                               next
[17:39:29.247]                             invokeRestart(restart)
[17:39:29.247]                             muffled <- TRUE
[17:39:29.247]                             break
[17:39:29.247]                           }
[17:39:29.247]                         }
[17:39:29.247]                       }
[17:39:29.247]                       invisible(muffled)
[17:39:29.247]                     }
[17:39:29.247]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.247]                   }
[17:39:29.247]                 }
[17:39:29.247]             }
[17:39:29.247]         }))
[17:39:29.247]     }, error = function(ex) {
[17:39:29.247]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.247]                 ...future.rng), started = ...future.startTime, 
[17:39:29.247]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.247]             version = "1.8"), class = "FutureResult")
[17:39:29.247]     }, finally = {
[17:39:29.247]         if (!identical(...future.workdir, getwd())) 
[17:39:29.247]             setwd(...future.workdir)
[17:39:29.247]         {
[17:39:29.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.247]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.247]             }
[17:39:29.247]             base::options(...future.oldOptions)
[17:39:29.247]             if (.Platform$OS.type == "windows") {
[17:39:29.247]                 old_names <- names(...future.oldEnvVars)
[17:39:29.247]                 envs <- base::Sys.getenv()
[17:39:29.247]                 names <- names(envs)
[17:39:29.247]                 common <- intersect(names, old_names)
[17:39:29.247]                 added <- setdiff(names, old_names)
[17:39:29.247]                 removed <- setdiff(old_names, names)
[17:39:29.247]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.247]                   envs[common]]
[17:39:29.247]                 NAMES <- toupper(changed)
[17:39:29.247]                 args <- list()
[17:39:29.247]                 for (kk in seq_along(NAMES)) {
[17:39:29.247]                   name <- changed[[kk]]
[17:39:29.247]                   NAME <- NAMES[[kk]]
[17:39:29.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.247]                     next
[17:39:29.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.247]                 }
[17:39:29.247]                 NAMES <- toupper(added)
[17:39:29.247]                 for (kk in seq_along(NAMES)) {
[17:39:29.247]                   name <- added[[kk]]
[17:39:29.247]                   NAME <- NAMES[[kk]]
[17:39:29.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.247]                     next
[17:39:29.247]                   args[[name]] <- ""
[17:39:29.247]                 }
[17:39:29.247]                 NAMES <- toupper(removed)
[17:39:29.247]                 for (kk in seq_along(NAMES)) {
[17:39:29.247]                   name <- removed[[kk]]
[17:39:29.247]                   NAME <- NAMES[[kk]]
[17:39:29.247]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.247]                     next
[17:39:29.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.247]                 }
[17:39:29.247]                 if (length(args) > 0) 
[17:39:29.247]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.247]             }
[17:39:29.247]             else {
[17:39:29.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.247]             }
[17:39:29.247]             {
[17:39:29.247]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.247]                   0L) {
[17:39:29.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.247]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.247]                   base::options(opts)
[17:39:29.247]                 }
[17:39:29.247]                 {
[17:39:29.247]                   {
[17:39:29.247]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.247]                     NULL
[17:39:29.247]                   }
[17:39:29.247]                   options(future.plan = NULL)
[17:39:29.247]                   if (is.na(NA_character_)) 
[17:39:29.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.247]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.247]                     envir = parent.frame()) 
[17:39:29.247]                   {
[17:39:29.247]                     default_workers <- missing(workers)
[17:39:29.247]                     if (is.function(workers)) 
[17:39:29.247]                       workers <- workers()
[17:39:29.247]                     workers <- structure(as.integer(workers), 
[17:39:29.247]                       class = class(workers))
[17:39:29.247]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.247]                       1L)
[17:39:29.247]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.247]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.247]                       if (default_workers) 
[17:39:29.247]                         supportsMulticore(warn = TRUE)
[17:39:29.247]                       return(sequential(..., envir = envir))
[17:39:29.247]                     }
[17:39:29.247]                     oopts <- options(mc.cores = workers)
[17:39:29.247]                     on.exit(options(oopts))
[17:39:29.247]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.247]                       envir = envir)
[17:39:29.247]                     if (!future$lazy) 
[17:39:29.247]                       future <- run(future)
[17:39:29.247]                     invisible(future)
[17:39:29.247]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.247]                 }
[17:39:29.247]             }
[17:39:29.247]         }
[17:39:29.247]     })
[17:39:29.247]     if (TRUE) {
[17:39:29.247]         base::sink(type = "output", split = FALSE)
[17:39:29.247]         if (TRUE) {
[17:39:29.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.247]         }
[17:39:29.247]         else {
[17:39:29.247]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.247]         }
[17:39:29.247]         base::close(...future.stdout)
[17:39:29.247]         ...future.stdout <- NULL
[17:39:29.247]     }
[17:39:29.247]     ...future.result$conditions <- ...future.conditions
[17:39:29.247]     ...future.result$finished <- base::Sys.time()
[17:39:29.247]     ...future.result
[17:39:29.247] }
[17:39:29.249] assign_globals() ...
[17:39:29.250] List of 5
[17:39:29.250]  $ ...future.FUN            :function (x, ...)  
[17:39:29.250]  $ future.call.arguments    : list()
[17:39:29.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.250]  $ ...future.elements_ii    :List of 2
[17:39:29.250]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:29.250]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:29.250]  $ ...future.seeds_ii       : NULL
[17:39:29.250]  $ ...future.globals.maxSize: NULL
[17:39:29.250]  - attr(*, "resolved")= logi FALSE
[17:39:29.250]  - attr(*, "total_size")= num 1248
[17:39:29.250]  - attr(*, "where")=List of 5
[17:39:29.250]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.250]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.250]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.250]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.250]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.250]  - attr(*, "already-done")= logi TRUE
[17:39:29.257] - copied ‘...future.FUN’ to environment
[17:39:29.257] - copied ‘future.call.arguments’ to environment
[17:39:29.258] - copied ‘...future.elements_ii’ to environment
[17:39:29.258] - copied ‘...future.seeds_ii’ to environment
[17:39:29.258] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.258] assign_globals() ... done
[17:39:29.258] requestCore(): workers = 2
[17:39:29.261] MulticoreFuture started
[17:39:29.261] - Launch lazy future ... done
[17:39:29.261] run() for ‘MulticoreFuture’ ... done
[17:39:29.262] Created future:
[17:39:29.262] plan(): Setting new future strategy stack:
[17:39:29.262] List of future strategies:
[17:39:29.262] 1. sequential:
[17:39:29.262]    - args: function (..., envir = parent.frame())
[17:39:29.262]    - tweaked: FALSE
[17:39:29.262]    - call: NULL
[17:39:29.263] plan(): nbrOfWorkers() = 1
[17:39:29.266] plan(): Setting new future strategy stack:
[17:39:29.266] List of future strategies:
[17:39:29.266] 1. multicore:
[17:39:29.266]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.266]    - tweaked: FALSE
[17:39:29.266]    - call: plan(strategy)
[17:39:29.272] plan(): nbrOfWorkers() = 2
[17:39:29.262] MulticoreFuture:
[17:39:29.262] Label: ‘future_eapply-2’
[17:39:29.262] Expression:
[17:39:29.262] {
[17:39:29.262]     do.call(function(...) {
[17:39:29.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.262]             on.exit(options(oopts), add = TRUE)
[17:39:29.262]         }
[17:39:29.262]         {
[17:39:29.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.262]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.262]             })
[17:39:29.262]         }
[17:39:29.262]     }, args = future.call.arguments)
[17:39:29.262] }
[17:39:29.262] Lazy evaluation: FALSE
[17:39:29.262] Asynchronous evaluation: TRUE
[17:39:29.262] Local evaluation: TRUE
[17:39:29.262] Environment: R_GlobalEnv
[17:39:29.262] Capture standard output: TRUE
[17:39:29.262] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.262] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.262] Packages: 1 packages (‘stats’)
[17:39:29.262] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.262] Resolved: TRUE
[17:39:29.262] Value: <not collected>
[17:39:29.262] Conditions captured: <none>
[17:39:29.262] Early signaling: FALSE
[17:39:29.262] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.262] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.273] Chunk #2 of 2 ... DONE
[17:39:29.273] Launching 2 futures (chunks) ... DONE
[17:39:29.273] Resolving 2 futures (chunks) ...
[17:39:29.273] resolve() on list ...
[17:39:29.273]  recursive: 0
[17:39:29.274]  length: 2
[17:39:29.274] 
[17:39:29.274] Future #1
[17:39:29.275] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:29.276] - nx: 2
[17:39:29.276] - relay: TRUE
[17:39:29.276] - stdout: TRUE
[17:39:29.276] - signal: TRUE
[17:39:29.276] - resignal: FALSE
[17:39:29.276] - force: TRUE
[17:39:29.276] - relayed: [n=2] FALSE, FALSE
[17:39:29.277] - queued futures: [n=2] FALSE, FALSE
[17:39:29.277]  - until=1
[17:39:29.277]  - relaying element #1
[17:39:29.277] - relayed: [n=2] TRUE, FALSE
[17:39:29.278] - queued futures: [n=2] TRUE, FALSE
[17:39:29.278] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:29.278]  length: 1 (resolved future 1)
[17:39:29.278] Future #2
[17:39:29.279] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:29.280] - nx: 2
[17:39:29.280] - relay: TRUE
[17:39:29.282] - stdout: TRUE
[17:39:29.283] - signal: TRUE
[17:39:29.283] - resignal: FALSE
[17:39:29.283] - force: TRUE
[17:39:29.283] - relayed: [n=2] TRUE, FALSE
[17:39:29.283] - queued futures: [n=2] TRUE, FALSE
[17:39:29.283]  - until=2
[17:39:29.283]  - relaying element #2
[17:39:29.284] - relayed: [n=2] TRUE, TRUE
[17:39:29.284] - queued futures: [n=2] TRUE, TRUE
[17:39:29.284] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:29.284]  length: 0 (resolved future 2)
[17:39:29.284] Relaying remaining futures
[17:39:29.284] signalConditionsASAP(NULL, pos=0) ...
[17:39:29.285] - nx: 2
[17:39:29.285] - relay: TRUE
[17:39:29.285] - stdout: TRUE
[17:39:29.285] - signal: TRUE
[17:39:29.285] - resignal: FALSE
[17:39:29.285] - force: TRUE
[17:39:29.285] - relayed: [n=2] TRUE, TRUE
[17:39:29.285] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:29.286] - relayed: [n=2] TRUE, TRUE
[17:39:29.286] - queued futures: [n=2] TRUE, TRUE
[17:39:29.286] signalConditionsASAP(NULL, pos=0) ... done
[17:39:29.286] resolve() on list ... DONE
[17:39:29.286]  - Number of value chunks collected: 2
[17:39:29.286] Resolving 2 futures (chunks) ... DONE
[17:39:29.286] Reducing values from 2 chunks ...
[17:39:29.287]  - Number of values collected after concatenation: 3
[17:39:29.287]  - Number of values expected: 3
[17:39:29.287] Reducing values from 2 chunks ... DONE
[17:39:29.287] future_lapply() ... DONE
[17:39:29.287] future_lapply() ...
[17:39:29.292] Number of chunks: 2
[17:39:29.293] getGlobalsAndPackagesXApply() ...
[17:39:29.293]  - future.globals: TRUE
[17:39:29.293] getGlobalsAndPackages() ...
[17:39:29.293] Searching for globals...
[17:39:29.294] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:29.295] Searching for globals ... DONE
[17:39:29.295] Resolving globals: FALSE
[17:39:29.295] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:29.296] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:29.296] - globals: [1] ‘FUN’
[17:39:29.296] - packages: [1] ‘stats’
[17:39:29.296] getGlobalsAndPackages() ... DONE
[17:39:29.296]  - globals found/used: [n=1] ‘FUN’
[17:39:29.296]  - needed namespaces: [n=1] ‘stats’
[17:39:29.296] Finding globals ... DONE
[17:39:29.297]  - use_args: TRUE
[17:39:29.297]  - Getting '...' globals ...
[17:39:29.297] resolve() on list ...
[17:39:29.297]  recursive: 0
[17:39:29.297]  length: 1
[17:39:29.297]  elements: ‘...’
[17:39:29.298]  length: 0 (resolved future 1)
[17:39:29.298] resolve() on list ... DONE
[17:39:29.298]    - '...' content: [n=0] 
[17:39:29.298] List of 1
[17:39:29.298]  $ ...: list()
[17:39:29.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.298]  - attr(*, "where")=List of 1
[17:39:29.298]   ..$ ...:<environment: 0x555b6427db08> 
[17:39:29.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.298]  - attr(*, "resolved")= logi TRUE
[17:39:29.298]  - attr(*, "total_size")= num NA
[17:39:29.301]  - Getting '...' globals ... DONE
[17:39:29.301] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:29.301] List of 2
[17:39:29.301]  $ ...future.FUN:function (x, ...)  
[17:39:29.301]  $ ...          : list()
[17:39:29.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.301]  - attr(*, "where")=List of 2
[17:39:29.301]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:29.301]   ..$ ...          :<environment: 0x555b6427db08> 
[17:39:29.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.301]  - attr(*, "resolved")= logi FALSE
[17:39:29.301]  - attr(*, "total_size")= num 1248
[17:39:29.305] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:29.305] getGlobalsAndPackagesXApply() ... DONE
[17:39:29.305] Number of futures (= number of chunks): 2
[17:39:29.305] Launching 2 futures (chunks) ...
[17:39:29.305] Chunk #1 of 2 ...
[17:39:29.305]  - Finding globals in 'X' for chunk #1 ...
[17:39:29.306] getGlobalsAndPackages() ...
[17:39:29.306] Searching for globals...
[17:39:29.306] 
[17:39:29.306] Searching for globals ... DONE
[17:39:29.306] - globals: [0] <none>
[17:39:29.306] getGlobalsAndPackages() ... DONE
[17:39:29.306]    + additional globals found: [n=0] 
[17:39:29.306]    + additional namespaces needed: [n=0] 
[17:39:29.306]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:29.307]  - seeds: <none>
[17:39:29.307] getGlobalsAndPackages() ...
[17:39:29.307] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.307] Resolving globals: FALSE
[17:39:29.307] Tweak future expression to call with '...' arguments ...
[17:39:29.307] {
[17:39:29.307]     do.call(function(...) {
[17:39:29.307]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.307]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.307]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.307]             on.exit(options(oopts), add = TRUE)
[17:39:29.307]         }
[17:39:29.307]         {
[17:39:29.307]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.307]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.307]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.307]             })
[17:39:29.307]         }
[17:39:29.307]     }, args = future.call.arguments)
[17:39:29.307] }
[17:39:29.307] Tweak future expression to call with '...' arguments ... DONE
[17:39:29.308] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.308] - packages: [1] ‘stats’
[17:39:29.308] getGlobalsAndPackages() ... DONE
[17:39:29.308] run() for ‘Future’ ...
[17:39:29.309] - state: ‘created’
[17:39:29.309] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.315] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.315]   - Field: ‘label’
[17:39:29.315]   - Field: ‘local’
[17:39:29.315]   - Field: ‘owner’
[17:39:29.315]   - Field: ‘envir’
[17:39:29.315]   - Field: ‘workers’
[17:39:29.315]   - Field: ‘packages’
[17:39:29.315]   - Field: ‘gc’
[17:39:29.316]   - Field: ‘job’
[17:39:29.316]   - Field: ‘conditions’
[17:39:29.316]   - Field: ‘expr’
[17:39:29.316]   - Field: ‘uuid’
[17:39:29.316]   - Field: ‘seed’
[17:39:29.316]   - Field: ‘version’
[17:39:29.316]   - Field: ‘result’
[17:39:29.316]   - Field: ‘asynchronous’
[17:39:29.316]   - Field: ‘calls’
[17:39:29.316]   - Field: ‘globals’
[17:39:29.317]   - Field: ‘stdout’
[17:39:29.317]   - Field: ‘earlySignal’
[17:39:29.317]   - Field: ‘lazy’
[17:39:29.317]   - Field: ‘state’
[17:39:29.317] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.317] - Launch lazy future ...
[17:39:29.317] Packages needed by the future expression (n = 1): ‘stats’
[17:39:29.318] Packages needed by future strategies (n = 0): <none>
[17:39:29.318] {
[17:39:29.318]     {
[17:39:29.318]         {
[17:39:29.318]             ...future.startTime <- base::Sys.time()
[17:39:29.318]             {
[17:39:29.318]                 {
[17:39:29.318]                   {
[17:39:29.318]                     {
[17:39:29.318]                       {
[17:39:29.318]                         base::local({
[17:39:29.318]                           has_future <- base::requireNamespace("future", 
[17:39:29.318]                             quietly = TRUE)
[17:39:29.318]                           if (has_future) {
[17:39:29.318]                             ns <- base::getNamespace("future")
[17:39:29.318]                             version <- ns[[".package"]][["version"]]
[17:39:29.318]                             if (is.null(version)) 
[17:39:29.318]                               version <- utils::packageVersion("future")
[17:39:29.318]                           }
[17:39:29.318]                           else {
[17:39:29.318]                             version <- NULL
[17:39:29.318]                           }
[17:39:29.318]                           if (!has_future || version < "1.8.0") {
[17:39:29.318]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.318]                               "", base::R.version$version.string), 
[17:39:29.318]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:29.318]                                 base::R.version$platform, 8 * 
[17:39:29.318]                                   base::.Machine$sizeof.pointer), 
[17:39:29.318]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.318]                                 "release", "version")], collapse = " "), 
[17:39:29.318]                               hostname = base::Sys.info()[["nodename"]])
[17:39:29.318]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.318]                               info)
[17:39:29.318]                             info <- base::paste(info, collapse = "; ")
[17:39:29.318]                             if (!has_future) {
[17:39:29.318]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.318]                                 info)
[17:39:29.318]                             }
[17:39:29.318]                             else {
[17:39:29.318]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.318]                                 info, version)
[17:39:29.318]                             }
[17:39:29.318]                             base::stop(msg)
[17:39:29.318]                           }
[17:39:29.318]                         })
[17:39:29.318]                       }
[17:39:29.318]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.318]                       base::options(mc.cores = 1L)
[17:39:29.318]                     }
[17:39:29.318]                     base::local({
[17:39:29.318]                       for (pkg in "stats") {
[17:39:29.318]                         base::loadNamespace(pkg)
[17:39:29.318]                         base::library(pkg, character.only = TRUE)
[17:39:29.318]                       }
[17:39:29.318]                     })
[17:39:29.318]                   }
[17:39:29.318]                   options(future.plan = NULL)
[17:39:29.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.318]                 }
[17:39:29.318]                 ...future.workdir <- getwd()
[17:39:29.318]             }
[17:39:29.318]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.318]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.318]         }
[17:39:29.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:29.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.318]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.318]             base::names(...future.oldOptions))
[17:39:29.318]     }
[17:39:29.318]     if (FALSE) {
[17:39:29.318]     }
[17:39:29.318]     else {
[17:39:29.318]         if (TRUE) {
[17:39:29.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.318]                 open = "w")
[17:39:29.318]         }
[17:39:29.318]         else {
[17:39:29.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.318]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.318]         }
[17:39:29.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.318]             base::sink(type = "output", split = FALSE)
[17:39:29.318]             base::close(...future.stdout)
[17:39:29.318]         }, add = TRUE)
[17:39:29.318]     }
[17:39:29.318]     ...future.frame <- base::sys.nframe()
[17:39:29.318]     ...future.conditions <- base::list()
[17:39:29.318]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.318]     if (FALSE) {
[17:39:29.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.318]     }
[17:39:29.318]     ...future.result <- base::tryCatch({
[17:39:29.318]         base::withCallingHandlers({
[17:39:29.318]             ...future.value <- base::withVisible(base::local({
[17:39:29.318]                 withCallingHandlers({
[17:39:29.318]                   {
[17:39:29.318]                     do.call(function(...) {
[17:39:29.318]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.318]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.318]                         ...future.globals.maxSize)) {
[17:39:29.318]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.318]                         on.exit(options(oopts), add = TRUE)
[17:39:29.318]                       }
[17:39:29.318]                       {
[17:39:29.318]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.318]                           FUN = function(jj) {
[17:39:29.318]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.318]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.318]                           })
[17:39:29.318]                       }
[17:39:29.318]                     }, args = future.call.arguments)
[17:39:29.318]                   }
[17:39:29.318]                 }, immediateCondition = function(cond) {
[17:39:29.318]                   save_rds <- function (object, pathname, ...) 
[17:39:29.318]                   {
[17:39:29.318]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.318]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.318]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.318]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.318]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.318]                         fi_tmp[["mtime"]])
[17:39:29.318]                     }
[17:39:29.318]                     tryCatch({
[17:39:29.318]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.318]                     }, error = function(ex) {
[17:39:29.318]                       msg <- conditionMessage(ex)
[17:39:29.318]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.318]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.318]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.318]                         fi_tmp[["mtime"]], msg)
[17:39:29.318]                       ex$message <- msg
[17:39:29.318]                       stop(ex)
[17:39:29.318]                     })
[17:39:29.318]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.318]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.318]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.318]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.318]                       fi <- file.info(pathname)
[17:39:29.318]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.318]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.318]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.318]                         fi[["size"]], fi[["mtime"]])
[17:39:29.318]                       stop(msg)
[17:39:29.318]                     }
[17:39:29.318]                     invisible(pathname)
[17:39:29.318]                   }
[17:39:29.318]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.318]                     rootPath = tempdir()) 
[17:39:29.318]                   {
[17:39:29.318]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.318]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.318]                       tmpdir = path, fileext = ".rds")
[17:39:29.318]                     save_rds(obj, file)
[17:39:29.318]                   }
[17:39:29.318]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.318]                   {
[17:39:29.318]                     inherits <- base::inherits
[17:39:29.318]                     invokeRestart <- base::invokeRestart
[17:39:29.318]                     is.null <- base::is.null
[17:39:29.318]                     muffled <- FALSE
[17:39:29.318]                     if (inherits(cond, "message")) {
[17:39:29.318]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.318]                       if (muffled) 
[17:39:29.318]                         invokeRestart("muffleMessage")
[17:39:29.318]                     }
[17:39:29.318]                     else if (inherits(cond, "warning")) {
[17:39:29.318]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.318]                       if (muffled) 
[17:39:29.318]                         invokeRestart("muffleWarning")
[17:39:29.318]                     }
[17:39:29.318]                     else if (inherits(cond, "condition")) {
[17:39:29.318]                       if (!is.null(pattern)) {
[17:39:29.318]                         computeRestarts <- base::computeRestarts
[17:39:29.318]                         grepl <- base::grepl
[17:39:29.318]                         restarts <- computeRestarts(cond)
[17:39:29.318]                         for (restart in restarts) {
[17:39:29.318]                           name <- restart$name
[17:39:29.318]                           if (is.null(name)) 
[17:39:29.318]                             next
[17:39:29.318]                           if (!grepl(pattern, name)) 
[17:39:29.318]                             next
[17:39:29.318]                           invokeRestart(restart)
[17:39:29.318]                           muffled <- TRUE
[17:39:29.318]                           break
[17:39:29.318]                         }
[17:39:29.318]                       }
[17:39:29.318]                     }
[17:39:29.318]                     invisible(muffled)
[17:39:29.318]                   }
[17:39:29.318]                   muffleCondition(cond)
[17:39:29.318]                 })
[17:39:29.318]             }))
[17:39:29.318]             future::FutureResult(value = ...future.value$value, 
[17:39:29.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.318]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.318]                     ...future.globalenv.names))
[17:39:29.318]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.318]         }, condition = base::local({
[17:39:29.318]             c <- base::c
[17:39:29.318]             inherits <- base::inherits
[17:39:29.318]             invokeRestart <- base::invokeRestart
[17:39:29.318]             length <- base::length
[17:39:29.318]             list <- base::list
[17:39:29.318]             seq.int <- base::seq.int
[17:39:29.318]             signalCondition <- base::signalCondition
[17:39:29.318]             sys.calls <- base::sys.calls
[17:39:29.318]             `[[` <- base::`[[`
[17:39:29.318]             `+` <- base::`+`
[17:39:29.318]             `<<-` <- base::`<<-`
[17:39:29.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.318]                   3L)]
[17:39:29.318]             }
[17:39:29.318]             function(cond) {
[17:39:29.318]                 is_error <- inherits(cond, "error")
[17:39:29.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.318]                   NULL)
[17:39:29.318]                 if (is_error) {
[17:39:29.318]                   sessionInformation <- function() {
[17:39:29.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.318]                       search = base::search(), system = base::Sys.info())
[17:39:29.318]                   }
[17:39:29.318]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.318]                     cond$call), session = sessionInformation(), 
[17:39:29.318]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.318]                   signalCondition(cond)
[17:39:29.318]                 }
[17:39:29.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.318]                 "immediateCondition"))) {
[17:39:29.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.318]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.318]                   if (TRUE && !signal) {
[17:39:29.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.318]                     {
[17:39:29.318]                       inherits <- base::inherits
[17:39:29.318]                       invokeRestart <- base::invokeRestart
[17:39:29.318]                       is.null <- base::is.null
[17:39:29.318]                       muffled <- FALSE
[17:39:29.318]                       if (inherits(cond, "message")) {
[17:39:29.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.318]                         if (muffled) 
[17:39:29.318]                           invokeRestart("muffleMessage")
[17:39:29.318]                       }
[17:39:29.318]                       else if (inherits(cond, "warning")) {
[17:39:29.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.318]                         if (muffled) 
[17:39:29.318]                           invokeRestart("muffleWarning")
[17:39:29.318]                       }
[17:39:29.318]                       else if (inherits(cond, "condition")) {
[17:39:29.318]                         if (!is.null(pattern)) {
[17:39:29.318]                           computeRestarts <- base::computeRestarts
[17:39:29.318]                           grepl <- base::grepl
[17:39:29.318]                           restarts <- computeRestarts(cond)
[17:39:29.318]                           for (restart in restarts) {
[17:39:29.318]                             name <- restart$name
[17:39:29.318]                             if (is.null(name)) 
[17:39:29.318]                               next
[17:39:29.318]                             if (!grepl(pattern, name)) 
[17:39:29.318]                               next
[17:39:29.318]                             invokeRestart(restart)
[17:39:29.318]                             muffled <- TRUE
[17:39:29.318]                             break
[17:39:29.318]                           }
[17:39:29.318]                         }
[17:39:29.318]                       }
[17:39:29.318]                       invisible(muffled)
[17:39:29.318]                     }
[17:39:29.318]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.318]                   }
[17:39:29.318]                 }
[17:39:29.318]                 else {
[17:39:29.318]                   if (TRUE) {
[17:39:29.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.318]                     {
[17:39:29.318]                       inherits <- base::inherits
[17:39:29.318]                       invokeRestart <- base::invokeRestart
[17:39:29.318]                       is.null <- base::is.null
[17:39:29.318]                       muffled <- FALSE
[17:39:29.318]                       if (inherits(cond, "message")) {
[17:39:29.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.318]                         if (muffled) 
[17:39:29.318]                           invokeRestart("muffleMessage")
[17:39:29.318]                       }
[17:39:29.318]                       else if (inherits(cond, "warning")) {
[17:39:29.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.318]                         if (muffled) 
[17:39:29.318]                           invokeRestart("muffleWarning")
[17:39:29.318]                       }
[17:39:29.318]                       else if (inherits(cond, "condition")) {
[17:39:29.318]                         if (!is.null(pattern)) {
[17:39:29.318]                           computeRestarts <- base::computeRestarts
[17:39:29.318]                           grepl <- base::grepl
[17:39:29.318]                           restarts <- computeRestarts(cond)
[17:39:29.318]                           for (restart in restarts) {
[17:39:29.318]                             name <- restart$name
[17:39:29.318]                             if (is.null(name)) 
[17:39:29.318]                               next
[17:39:29.318]                             if (!grepl(pattern, name)) 
[17:39:29.318]                               next
[17:39:29.318]                             invokeRestart(restart)
[17:39:29.318]                             muffled <- TRUE
[17:39:29.318]                             break
[17:39:29.318]                           }
[17:39:29.318]                         }
[17:39:29.318]                       }
[17:39:29.318]                       invisible(muffled)
[17:39:29.318]                     }
[17:39:29.318]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.318]                   }
[17:39:29.318]                 }
[17:39:29.318]             }
[17:39:29.318]         }))
[17:39:29.318]     }, error = function(ex) {
[17:39:29.318]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.318]                 ...future.rng), started = ...future.startTime, 
[17:39:29.318]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.318]             version = "1.8"), class = "FutureResult")
[17:39:29.318]     }, finally = {
[17:39:29.318]         if (!identical(...future.workdir, getwd())) 
[17:39:29.318]             setwd(...future.workdir)
[17:39:29.318]         {
[17:39:29.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.318]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.318]             }
[17:39:29.318]             base::options(...future.oldOptions)
[17:39:29.318]             if (.Platform$OS.type == "windows") {
[17:39:29.318]                 old_names <- names(...future.oldEnvVars)
[17:39:29.318]                 envs <- base::Sys.getenv()
[17:39:29.318]                 names <- names(envs)
[17:39:29.318]                 common <- intersect(names, old_names)
[17:39:29.318]                 added <- setdiff(names, old_names)
[17:39:29.318]                 removed <- setdiff(old_names, names)
[17:39:29.318]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.318]                   envs[common]]
[17:39:29.318]                 NAMES <- toupper(changed)
[17:39:29.318]                 args <- list()
[17:39:29.318]                 for (kk in seq_along(NAMES)) {
[17:39:29.318]                   name <- changed[[kk]]
[17:39:29.318]                   NAME <- NAMES[[kk]]
[17:39:29.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.318]                     next
[17:39:29.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.318]                 }
[17:39:29.318]                 NAMES <- toupper(added)
[17:39:29.318]                 for (kk in seq_along(NAMES)) {
[17:39:29.318]                   name <- added[[kk]]
[17:39:29.318]                   NAME <- NAMES[[kk]]
[17:39:29.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.318]                     next
[17:39:29.318]                   args[[name]] <- ""
[17:39:29.318]                 }
[17:39:29.318]                 NAMES <- toupper(removed)
[17:39:29.318]                 for (kk in seq_along(NAMES)) {
[17:39:29.318]                   name <- removed[[kk]]
[17:39:29.318]                   NAME <- NAMES[[kk]]
[17:39:29.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.318]                     next
[17:39:29.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.318]                 }
[17:39:29.318]                 if (length(args) > 0) 
[17:39:29.318]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.318]             }
[17:39:29.318]             else {
[17:39:29.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.318]             }
[17:39:29.318]             {
[17:39:29.318]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.318]                   0L) {
[17:39:29.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.318]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.318]                   base::options(opts)
[17:39:29.318]                 }
[17:39:29.318]                 {
[17:39:29.318]                   {
[17:39:29.318]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.318]                     NULL
[17:39:29.318]                   }
[17:39:29.318]                   options(future.plan = NULL)
[17:39:29.318]                   if (is.na(NA_character_)) 
[17:39:29.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.318]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.318]                     envir = parent.frame()) 
[17:39:29.318]                   {
[17:39:29.318]                     default_workers <- missing(workers)
[17:39:29.318]                     if (is.function(workers)) 
[17:39:29.318]                       workers <- workers()
[17:39:29.318]                     workers <- structure(as.integer(workers), 
[17:39:29.318]                       class = class(workers))
[17:39:29.318]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.318]                       1L)
[17:39:29.318]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.318]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.318]                       if (default_workers) 
[17:39:29.318]                         supportsMulticore(warn = TRUE)
[17:39:29.318]                       return(sequential(..., envir = envir))
[17:39:29.318]                     }
[17:39:29.318]                     oopts <- options(mc.cores = workers)
[17:39:29.318]                     on.exit(options(oopts))
[17:39:29.318]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.318]                       envir = envir)
[17:39:29.318]                     if (!future$lazy) 
[17:39:29.318]                       future <- run(future)
[17:39:29.318]                     invisible(future)
[17:39:29.318]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.318]                 }
[17:39:29.318]             }
[17:39:29.318]         }
[17:39:29.318]     })
[17:39:29.318]     if (TRUE) {
[17:39:29.318]         base::sink(type = "output", split = FALSE)
[17:39:29.318]         if (TRUE) {
[17:39:29.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.318]         }
[17:39:29.318]         else {
[17:39:29.318]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.318]         }
[17:39:29.318]         base::close(...future.stdout)
[17:39:29.318]         ...future.stdout <- NULL
[17:39:29.318]     }
[17:39:29.318]     ...future.result$conditions <- ...future.conditions
[17:39:29.318]     ...future.result$finished <- base::Sys.time()
[17:39:29.318]     ...future.result
[17:39:29.318] }
[17:39:29.321] assign_globals() ...
[17:39:29.321] List of 5
[17:39:29.321]  $ ...future.FUN            :function (x, ...)  
[17:39:29.321]  $ future.call.arguments    : list()
[17:39:29.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.321]  $ ...future.elements_ii    :List of 1
[17:39:29.321]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:39:29.321]  $ ...future.seeds_ii       : NULL
[17:39:29.321]  $ ...future.globals.maxSize: NULL
[17:39:29.321]  - attr(*, "where")=List of 5
[17:39:29.321]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.321]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.321]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.321]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.321]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.321]  - attr(*, "resolved")= logi FALSE
[17:39:29.321]  - attr(*, "total_size")= num 1248
[17:39:29.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.321]  - attr(*, "already-done")= logi TRUE
[17:39:29.326] - copied ‘...future.FUN’ to environment
[17:39:29.326] - copied ‘future.call.arguments’ to environment
[17:39:29.326] - copied ‘...future.elements_ii’ to environment
[17:39:29.326] - copied ‘...future.seeds_ii’ to environment
[17:39:29.326] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.326] assign_globals() ... done
[17:39:29.326] requestCore(): workers = 2
[17:39:29.329] MulticoreFuture started
[17:39:29.329] - Launch lazy future ... done
[17:39:29.329] run() for ‘MulticoreFuture’ ... done
[17:39:29.329] Created future:
[17:39:29.330] plan(): Setting new future strategy stack:
[17:39:29.330] List of future strategies:
[17:39:29.330] 1. sequential:
[17:39:29.330]    - args: function (..., envir = parent.frame())
[17:39:29.330]    - tweaked: FALSE
[17:39:29.330]    - call: NULL
[17:39:29.331] plan(): nbrOfWorkers() = 1
[17:39:29.334] plan(): Setting new future strategy stack:
[17:39:29.334] List of future strategies:
[17:39:29.334] 1. multicore:
[17:39:29.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.334]    - tweaked: FALSE
[17:39:29.334]    - call: plan(strategy)
[17:39:29.339] plan(): nbrOfWorkers() = 2
[17:39:29.330] MulticoreFuture:
[17:39:29.330] Label: ‘future_eapply-1’
[17:39:29.330] Expression:
[17:39:29.330] {
[17:39:29.330]     do.call(function(...) {
[17:39:29.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.330]             on.exit(options(oopts), add = TRUE)
[17:39:29.330]         }
[17:39:29.330]         {
[17:39:29.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.330]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.330]             })
[17:39:29.330]         }
[17:39:29.330]     }, args = future.call.arguments)
[17:39:29.330] }
[17:39:29.330] Lazy evaluation: FALSE
[17:39:29.330] Asynchronous evaluation: TRUE
[17:39:29.330] Local evaluation: TRUE
[17:39:29.330] Environment: R_GlobalEnv
[17:39:29.330] Capture standard output: TRUE
[17:39:29.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.330] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.330] Packages: 1 packages (‘stats’)
[17:39:29.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.330] Resolved: TRUE
[17:39:29.330] Value: <not collected>
[17:39:29.330] Conditions captured: <none>
[17:39:29.330] Early signaling: FALSE
[17:39:29.330] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.330] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.340] Chunk #1 of 2 ... DONE
[17:39:29.341] Chunk #2 of 2 ...
[17:39:29.341]  - Finding globals in 'X' for chunk #2 ...
[17:39:29.341] getGlobalsAndPackages() ...
[17:39:29.341] Searching for globals...
[17:39:29.342] 
[17:39:29.342] Searching for globals ... DONE
[17:39:29.342] - globals: [0] <none>
[17:39:29.342] getGlobalsAndPackages() ... DONE
[17:39:29.342]    + additional globals found: [n=0] 
[17:39:29.342]    + additional namespaces needed: [n=0] 
[17:39:29.342]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:29.343]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:29.343]  - seeds: <none>
[17:39:29.343] getGlobalsAndPackages() ...
[17:39:29.343] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.343] Resolving globals: FALSE
[17:39:29.344] Tweak future expression to call with '...' arguments ...
[17:39:29.344] {
[17:39:29.344]     do.call(function(...) {
[17:39:29.344]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.344]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.344]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.344]             on.exit(options(oopts), add = TRUE)
[17:39:29.344]         }
[17:39:29.344]         {
[17:39:29.344]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.344]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.344]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.344]             })
[17:39:29.344]         }
[17:39:29.344]     }, args = future.call.arguments)
[17:39:29.344] }
[17:39:29.344] Tweak future expression to call with '...' arguments ... DONE
[17:39:29.345] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:29.345] - packages: [1] ‘stats’
[17:39:29.345] getGlobalsAndPackages() ... DONE
[17:39:29.346] run() for ‘Future’ ...
[17:39:29.346] - state: ‘created’
[17:39:29.346] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:29.351] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.351] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:29.351]   - Field: ‘label’
[17:39:29.352]   - Field: ‘local’
[17:39:29.352]   - Field: ‘owner’
[17:39:29.352]   - Field: ‘envir’
[17:39:29.352]   - Field: ‘workers’
[17:39:29.352]   - Field: ‘packages’
[17:39:29.352]   - Field: ‘gc’
[17:39:29.352]   - Field: ‘job’
[17:39:29.353]   - Field: ‘conditions’
[17:39:29.353]   - Field: ‘expr’
[17:39:29.353]   - Field: ‘uuid’
[17:39:29.353]   - Field: ‘seed’
[17:39:29.353]   - Field: ‘version’
[17:39:29.353]   - Field: ‘result’
[17:39:29.353]   - Field: ‘asynchronous’
[17:39:29.354]   - Field: ‘calls’
[17:39:29.354]   - Field: ‘globals’
[17:39:29.354]   - Field: ‘stdout’
[17:39:29.354]   - Field: ‘earlySignal’
[17:39:29.354]   - Field: ‘lazy’
[17:39:29.354]   - Field: ‘state’
[17:39:29.355] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:29.355] - Launch lazy future ...
[17:39:29.355] Packages needed by the future expression (n = 1): ‘stats’
[17:39:29.355] Packages needed by future strategies (n = 0): <none>
[17:39:29.356] {
[17:39:29.356]     {
[17:39:29.356]         {
[17:39:29.356]             ...future.startTime <- base::Sys.time()
[17:39:29.356]             {
[17:39:29.356]                 {
[17:39:29.356]                   {
[17:39:29.356]                     {
[17:39:29.356]                       {
[17:39:29.356]                         base::local({
[17:39:29.356]                           has_future <- base::requireNamespace("future", 
[17:39:29.356]                             quietly = TRUE)
[17:39:29.356]                           if (has_future) {
[17:39:29.356]                             ns <- base::getNamespace("future")
[17:39:29.356]                             version <- ns[[".package"]][["version"]]
[17:39:29.356]                             if (is.null(version)) 
[17:39:29.356]                               version <- utils::packageVersion("future")
[17:39:29.356]                           }
[17:39:29.356]                           else {
[17:39:29.356]                             version <- NULL
[17:39:29.356]                           }
[17:39:29.356]                           if (!has_future || version < "1.8.0") {
[17:39:29.356]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.356]                               "", base::R.version$version.string), 
[17:39:29.356]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:29.356]                                 base::R.version$platform, 8 * 
[17:39:29.356]                                   base::.Machine$sizeof.pointer), 
[17:39:29.356]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.356]                                 "release", "version")], collapse = " "), 
[17:39:29.356]                               hostname = base::Sys.info()[["nodename"]])
[17:39:29.356]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.356]                               info)
[17:39:29.356]                             info <- base::paste(info, collapse = "; ")
[17:39:29.356]                             if (!has_future) {
[17:39:29.356]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.356]                                 info)
[17:39:29.356]                             }
[17:39:29.356]                             else {
[17:39:29.356]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.356]                                 info, version)
[17:39:29.356]                             }
[17:39:29.356]                             base::stop(msg)
[17:39:29.356]                           }
[17:39:29.356]                         })
[17:39:29.356]                       }
[17:39:29.356]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.356]                       base::options(mc.cores = 1L)
[17:39:29.356]                     }
[17:39:29.356]                     base::local({
[17:39:29.356]                       for (pkg in "stats") {
[17:39:29.356]                         base::loadNamespace(pkg)
[17:39:29.356]                         base::library(pkg, character.only = TRUE)
[17:39:29.356]                       }
[17:39:29.356]                     })
[17:39:29.356]                   }
[17:39:29.356]                   options(future.plan = NULL)
[17:39:29.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.356]                 }
[17:39:29.356]                 ...future.workdir <- getwd()
[17:39:29.356]             }
[17:39:29.356]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.356]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.356]         }
[17:39:29.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.356]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:29.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.356]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.356]             base::names(...future.oldOptions))
[17:39:29.356]     }
[17:39:29.356]     if (FALSE) {
[17:39:29.356]     }
[17:39:29.356]     else {
[17:39:29.356]         if (TRUE) {
[17:39:29.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.356]                 open = "w")
[17:39:29.356]         }
[17:39:29.356]         else {
[17:39:29.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.356]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.356]         }
[17:39:29.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.356]             base::sink(type = "output", split = FALSE)
[17:39:29.356]             base::close(...future.stdout)
[17:39:29.356]         }, add = TRUE)
[17:39:29.356]     }
[17:39:29.356]     ...future.frame <- base::sys.nframe()
[17:39:29.356]     ...future.conditions <- base::list()
[17:39:29.356]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.356]     if (FALSE) {
[17:39:29.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.356]     }
[17:39:29.356]     ...future.result <- base::tryCatch({
[17:39:29.356]         base::withCallingHandlers({
[17:39:29.356]             ...future.value <- base::withVisible(base::local({
[17:39:29.356]                 withCallingHandlers({
[17:39:29.356]                   {
[17:39:29.356]                     do.call(function(...) {
[17:39:29.356]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.356]                       if (!identical(...future.globals.maxSize.org, 
[17:39:29.356]                         ...future.globals.maxSize)) {
[17:39:29.356]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.356]                         on.exit(options(oopts), add = TRUE)
[17:39:29.356]                       }
[17:39:29.356]                       {
[17:39:29.356]                         lapply(seq_along(...future.elements_ii), 
[17:39:29.356]                           FUN = function(jj) {
[17:39:29.356]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.356]                             ...future.FUN(...future.X_jj, ...)
[17:39:29.356]                           })
[17:39:29.356]                       }
[17:39:29.356]                     }, args = future.call.arguments)
[17:39:29.356]                   }
[17:39:29.356]                 }, immediateCondition = function(cond) {
[17:39:29.356]                   save_rds <- function (object, pathname, ...) 
[17:39:29.356]                   {
[17:39:29.356]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:29.356]                     if (file_test("-f", pathname_tmp)) {
[17:39:29.356]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.356]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:29.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.356]                         fi_tmp[["mtime"]])
[17:39:29.356]                     }
[17:39:29.356]                     tryCatch({
[17:39:29.356]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:29.356]                     }, error = function(ex) {
[17:39:29.356]                       msg <- conditionMessage(ex)
[17:39:29.356]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.356]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:29.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.356]                         fi_tmp[["mtime"]], msg)
[17:39:29.356]                       ex$message <- msg
[17:39:29.356]                       stop(ex)
[17:39:29.356]                     })
[17:39:29.356]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:29.356]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:29.356]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:29.356]                       fi_tmp <- file.info(pathname_tmp)
[17:39:29.356]                       fi <- file.info(pathname)
[17:39:29.356]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:29.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:29.356]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:29.356]                         fi[["size"]], fi[["mtime"]])
[17:39:29.356]                       stop(msg)
[17:39:29.356]                     }
[17:39:29.356]                     invisible(pathname)
[17:39:29.356]                   }
[17:39:29.356]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:29.356]                     rootPath = tempdir()) 
[17:39:29.356]                   {
[17:39:29.356]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:29.356]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:29.356]                       tmpdir = path, fileext = ".rds")
[17:39:29.356]                     save_rds(obj, file)
[17:39:29.356]                   }
[17:39:29.356]                   saveImmediateCondition(cond, path = "/tmp/RtmpLtEkQ9/.future/immediateConditions")
[17:39:29.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.356]                   {
[17:39:29.356]                     inherits <- base::inherits
[17:39:29.356]                     invokeRestart <- base::invokeRestart
[17:39:29.356]                     is.null <- base::is.null
[17:39:29.356]                     muffled <- FALSE
[17:39:29.356]                     if (inherits(cond, "message")) {
[17:39:29.356]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.356]                       if (muffled) 
[17:39:29.356]                         invokeRestart("muffleMessage")
[17:39:29.356]                     }
[17:39:29.356]                     else if (inherits(cond, "warning")) {
[17:39:29.356]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.356]                       if (muffled) 
[17:39:29.356]                         invokeRestart("muffleWarning")
[17:39:29.356]                     }
[17:39:29.356]                     else if (inherits(cond, "condition")) {
[17:39:29.356]                       if (!is.null(pattern)) {
[17:39:29.356]                         computeRestarts <- base::computeRestarts
[17:39:29.356]                         grepl <- base::grepl
[17:39:29.356]                         restarts <- computeRestarts(cond)
[17:39:29.356]                         for (restart in restarts) {
[17:39:29.356]                           name <- restart$name
[17:39:29.356]                           if (is.null(name)) 
[17:39:29.356]                             next
[17:39:29.356]                           if (!grepl(pattern, name)) 
[17:39:29.356]                             next
[17:39:29.356]                           invokeRestart(restart)
[17:39:29.356]                           muffled <- TRUE
[17:39:29.356]                           break
[17:39:29.356]                         }
[17:39:29.356]                       }
[17:39:29.356]                     }
[17:39:29.356]                     invisible(muffled)
[17:39:29.356]                   }
[17:39:29.356]                   muffleCondition(cond)
[17:39:29.356]                 })
[17:39:29.356]             }))
[17:39:29.356]             future::FutureResult(value = ...future.value$value, 
[17:39:29.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.356]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.356]                     ...future.globalenv.names))
[17:39:29.356]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.356]         }, condition = base::local({
[17:39:29.356]             c <- base::c
[17:39:29.356]             inherits <- base::inherits
[17:39:29.356]             invokeRestart <- base::invokeRestart
[17:39:29.356]             length <- base::length
[17:39:29.356]             list <- base::list
[17:39:29.356]             seq.int <- base::seq.int
[17:39:29.356]             signalCondition <- base::signalCondition
[17:39:29.356]             sys.calls <- base::sys.calls
[17:39:29.356]             `[[` <- base::`[[`
[17:39:29.356]             `+` <- base::`+`
[17:39:29.356]             `<<-` <- base::`<<-`
[17:39:29.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.356]                   3L)]
[17:39:29.356]             }
[17:39:29.356]             function(cond) {
[17:39:29.356]                 is_error <- inherits(cond, "error")
[17:39:29.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.356]                   NULL)
[17:39:29.356]                 if (is_error) {
[17:39:29.356]                   sessionInformation <- function() {
[17:39:29.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.356]                       search = base::search(), system = base::Sys.info())
[17:39:29.356]                   }
[17:39:29.356]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.356]                     cond$call), session = sessionInformation(), 
[17:39:29.356]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.356]                   signalCondition(cond)
[17:39:29.356]                 }
[17:39:29.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.356]                 "immediateCondition"))) {
[17:39:29.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.356]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.356]                   if (TRUE && !signal) {
[17:39:29.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.356]                     {
[17:39:29.356]                       inherits <- base::inherits
[17:39:29.356]                       invokeRestart <- base::invokeRestart
[17:39:29.356]                       is.null <- base::is.null
[17:39:29.356]                       muffled <- FALSE
[17:39:29.356]                       if (inherits(cond, "message")) {
[17:39:29.356]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.356]                         if (muffled) 
[17:39:29.356]                           invokeRestart("muffleMessage")
[17:39:29.356]                       }
[17:39:29.356]                       else if (inherits(cond, "warning")) {
[17:39:29.356]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.356]                         if (muffled) 
[17:39:29.356]                           invokeRestart("muffleWarning")
[17:39:29.356]                       }
[17:39:29.356]                       else if (inherits(cond, "condition")) {
[17:39:29.356]                         if (!is.null(pattern)) {
[17:39:29.356]                           computeRestarts <- base::computeRestarts
[17:39:29.356]                           grepl <- base::grepl
[17:39:29.356]                           restarts <- computeRestarts(cond)
[17:39:29.356]                           for (restart in restarts) {
[17:39:29.356]                             name <- restart$name
[17:39:29.356]                             if (is.null(name)) 
[17:39:29.356]                               next
[17:39:29.356]                             if (!grepl(pattern, name)) 
[17:39:29.356]                               next
[17:39:29.356]                             invokeRestart(restart)
[17:39:29.356]                             muffled <- TRUE
[17:39:29.356]                             break
[17:39:29.356]                           }
[17:39:29.356]                         }
[17:39:29.356]                       }
[17:39:29.356]                       invisible(muffled)
[17:39:29.356]                     }
[17:39:29.356]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.356]                   }
[17:39:29.356]                 }
[17:39:29.356]                 else {
[17:39:29.356]                   if (TRUE) {
[17:39:29.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.356]                     {
[17:39:29.356]                       inherits <- base::inherits
[17:39:29.356]                       invokeRestart <- base::invokeRestart
[17:39:29.356]                       is.null <- base::is.null
[17:39:29.356]                       muffled <- FALSE
[17:39:29.356]                       if (inherits(cond, "message")) {
[17:39:29.356]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.356]                         if (muffled) 
[17:39:29.356]                           invokeRestart("muffleMessage")
[17:39:29.356]                       }
[17:39:29.356]                       else if (inherits(cond, "warning")) {
[17:39:29.356]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.356]                         if (muffled) 
[17:39:29.356]                           invokeRestart("muffleWarning")
[17:39:29.356]                       }
[17:39:29.356]                       else if (inherits(cond, "condition")) {
[17:39:29.356]                         if (!is.null(pattern)) {
[17:39:29.356]                           computeRestarts <- base::computeRestarts
[17:39:29.356]                           grepl <- base::grepl
[17:39:29.356]                           restarts <- computeRestarts(cond)
[17:39:29.356]                           for (restart in restarts) {
[17:39:29.356]                             name <- restart$name
[17:39:29.356]                             if (is.null(name)) 
[17:39:29.356]                               next
[17:39:29.356]                             if (!grepl(pattern, name)) 
[17:39:29.356]                               next
[17:39:29.356]                             invokeRestart(restart)
[17:39:29.356]                             muffled <- TRUE
[17:39:29.356]                             break
[17:39:29.356]                           }
[17:39:29.356]                         }
[17:39:29.356]                       }
[17:39:29.356]                       invisible(muffled)
[17:39:29.356]                     }
[17:39:29.356]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.356]                   }
[17:39:29.356]                 }
[17:39:29.356]             }
[17:39:29.356]         }))
[17:39:29.356]     }, error = function(ex) {
[17:39:29.356]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.356]                 ...future.rng), started = ...future.startTime, 
[17:39:29.356]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.356]             version = "1.8"), class = "FutureResult")
[17:39:29.356]     }, finally = {
[17:39:29.356]         if (!identical(...future.workdir, getwd())) 
[17:39:29.356]             setwd(...future.workdir)
[17:39:29.356]         {
[17:39:29.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.356]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.356]             }
[17:39:29.356]             base::options(...future.oldOptions)
[17:39:29.356]             if (.Platform$OS.type == "windows") {
[17:39:29.356]                 old_names <- names(...future.oldEnvVars)
[17:39:29.356]                 envs <- base::Sys.getenv()
[17:39:29.356]                 names <- names(envs)
[17:39:29.356]                 common <- intersect(names, old_names)
[17:39:29.356]                 added <- setdiff(names, old_names)
[17:39:29.356]                 removed <- setdiff(old_names, names)
[17:39:29.356]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.356]                   envs[common]]
[17:39:29.356]                 NAMES <- toupper(changed)
[17:39:29.356]                 args <- list()
[17:39:29.356]                 for (kk in seq_along(NAMES)) {
[17:39:29.356]                   name <- changed[[kk]]
[17:39:29.356]                   NAME <- NAMES[[kk]]
[17:39:29.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.356]                     next
[17:39:29.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.356]                 }
[17:39:29.356]                 NAMES <- toupper(added)
[17:39:29.356]                 for (kk in seq_along(NAMES)) {
[17:39:29.356]                   name <- added[[kk]]
[17:39:29.356]                   NAME <- NAMES[[kk]]
[17:39:29.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.356]                     next
[17:39:29.356]                   args[[name]] <- ""
[17:39:29.356]                 }
[17:39:29.356]                 NAMES <- toupper(removed)
[17:39:29.356]                 for (kk in seq_along(NAMES)) {
[17:39:29.356]                   name <- removed[[kk]]
[17:39:29.356]                   NAME <- NAMES[[kk]]
[17:39:29.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.356]                     next
[17:39:29.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.356]                 }
[17:39:29.356]                 if (length(args) > 0) 
[17:39:29.356]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.356]             }
[17:39:29.356]             else {
[17:39:29.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.356]             }
[17:39:29.356]             {
[17:39:29.356]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.356]                   0L) {
[17:39:29.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.356]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.356]                   base::options(opts)
[17:39:29.356]                 }
[17:39:29.356]                 {
[17:39:29.356]                   {
[17:39:29.356]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.356]                     NULL
[17:39:29.356]                   }
[17:39:29.356]                   options(future.plan = NULL)
[17:39:29.356]                   if (is.na(NA_character_)) 
[17:39:29.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.356]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:29.356]                     envir = parent.frame()) 
[17:39:29.356]                   {
[17:39:29.356]                     default_workers <- missing(workers)
[17:39:29.356]                     if (is.function(workers)) 
[17:39:29.356]                       workers <- workers()
[17:39:29.356]                     workers <- structure(as.integer(workers), 
[17:39:29.356]                       class = class(workers))
[17:39:29.356]                     stop_if_not(is.finite(workers), workers >= 
[17:39:29.356]                       1L)
[17:39:29.356]                     if ((workers == 1L && !inherits(workers, 
[17:39:29.356]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:29.356]                       if (default_workers) 
[17:39:29.356]                         supportsMulticore(warn = TRUE)
[17:39:29.356]                       return(sequential(..., envir = envir))
[17:39:29.356]                     }
[17:39:29.356]                     oopts <- options(mc.cores = workers)
[17:39:29.356]                     on.exit(options(oopts))
[17:39:29.356]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:29.356]                       envir = envir)
[17:39:29.356]                     if (!future$lazy) 
[17:39:29.356]                       future <- run(future)
[17:39:29.356]                     invisible(future)
[17:39:29.356]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.356]                 }
[17:39:29.356]             }
[17:39:29.356]         }
[17:39:29.356]     })
[17:39:29.356]     if (TRUE) {
[17:39:29.356]         base::sink(type = "output", split = FALSE)
[17:39:29.356]         if (TRUE) {
[17:39:29.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.356]         }
[17:39:29.356]         else {
[17:39:29.356]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.356]         }
[17:39:29.356]         base::close(...future.stdout)
[17:39:29.356]         ...future.stdout <- NULL
[17:39:29.356]     }
[17:39:29.356]     ...future.result$conditions <- ...future.conditions
[17:39:29.356]     ...future.result$finished <- base::Sys.time()
[17:39:29.356]     ...future.result
[17:39:29.356] }
[17:39:29.360] assign_globals() ...
[17:39:29.360] List of 5
[17:39:29.360]  $ ...future.FUN            :function (x, ...)  
[17:39:29.360]  $ future.call.arguments    : list()
[17:39:29.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:29.360]  $ ...future.elements_ii    :List of 2
[17:39:29.360]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:39:29.360]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:39:29.360]  $ ...future.seeds_ii       : NULL
[17:39:29.360]  $ ...future.globals.maxSize: NULL
[17:39:29.360]  - attr(*, "resolved")= logi FALSE
[17:39:29.360]  - attr(*, "total_size")= num 1248
[17:39:29.360]  - attr(*, "where")=List of 5
[17:39:29.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:29.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:29.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:29.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:29.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:29.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:29.360]  - attr(*, "already-done")= logi TRUE
[17:39:29.372] - copied ‘...future.FUN’ to environment
[17:39:29.373] - copied ‘future.call.arguments’ to environment
[17:39:29.373] - copied ‘...future.elements_ii’ to environment
[17:39:29.373] - copied ‘...future.seeds_ii’ to environment
[17:39:29.373] - copied ‘...future.globals.maxSize’ to environment
[17:39:29.373] assign_globals() ... done
[17:39:29.373] requestCore(): workers = 2
[17:39:29.376] MulticoreFuture started
[17:39:29.376] - Launch lazy future ... done
[17:39:29.376] run() for ‘MulticoreFuture’ ... done
[17:39:29.377] Created future:
[17:39:29.377] plan(): Setting new future strategy stack:
[17:39:29.378] List of future strategies:
[17:39:29.378] 1. sequential:
[17:39:29.378]    - args: function (..., envir = parent.frame())
[17:39:29.378]    - tweaked: FALSE
[17:39:29.378]    - call: NULL
[17:39:29.378] plan(): nbrOfWorkers() = 1
[17:39:29.381] plan(): Setting new future strategy stack:
[17:39:29.381] List of future strategies:
[17:39:29.381] 1. multicore:
[17:39:29.381]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:29.381]    - tweaked: FALSE
[17:39:29.381]    - call: plan(strategy)
[17:39:29.387] plan(): nbrOfWorkers() = 2
[17:39:29.377] MulticoreFuture:
[17:39:29.377] Label: ‘future_eapply-2’
[17:39:29.377] Expression:
[17:39:29.377] {
[17:39:29.377]     do.call(function(...) {
[17:39:29.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:29.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:29.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:29.377]             on.exit(options(oopts), add = TRUE)
[17:39:29.377]         }
[17:39:29.377]         {
[17:39:29.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:29.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:29.377]                 ...future.FUN(...future.X_jj, ...)
[17:39:29.377]             })
[17:39:29.377]         }
[17:39:29.377]     }, args = future.call.arguments)
[17:39:29.377] }
[17:39:29.377] Lazy evaluation: FALSE
[17:39:29.377] Asynchronous evaluation: TRUE
[17:39:29.377] Local evaluation: TRUE
[17:39:29.377] Environment: R_GlobalEnv
[17:39:29.377] Capture standard output: TRUE
[17:39:29.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:29.377] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:29.377] Packages: 1 packages (‘stats’)
[17:39:29.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:29.377] Resolved: TRUE
[17:39:29.377] Value: <not collected>
[17:39:29.377] Conditions captured: <none>
[17:39:29.377] Early signaling: FALSE
[17:39:29.377] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:29.377] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:29.388] Chunk #2 of 2 ... DONE
[17:39:29.388] Launching 2 futures (chunks) ... DONE
[17:39:29.388] Resolving 2 futures (chunks) ...
[17:39:29.389] resolve() on list ...
[17:39:29.389]  recursive: 0
[17:39:29.389]  length: 2
[17:39:29.389] 
[17:39:29.389] Future #1
[17:39:29.391] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:29.391] - nx: 2
[17:39:29.391] - relay: TRUE
[17:39:29.391] - stdout: TRUE
[17:39:29.391] - signal: TRUE
[17:39:29.392] - resignal: FALSE
[17:39:29.392] - force: TRUE
[17:39:29.392] - relayed: [n=2] FALSE, FALSE
[17:39:29.392] - queued futures: [n=2] FALSE, FALSE
[17:39:29.392]  - until=1
[17:39:29.393]  - relaying element #1
[17:39:29.393] - relayed: [n=2] TRUE, FALSE
[17:39:29.393] - queued futures: [n=2] TRUE, FALSE
[17:39:29.393] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:29.394]  length: 1 (resolved future 1)
[17:39:29.394] Future #2
[17:39:29.395] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:29.395] - nx: 2
[17:39:29.395] - relay: TRUE
[17:39:29.395] - stdout: TRUE
[17:39:29.396] - signal: TRUE
[17:39:29.396] - resignal: FALSE
[17:39:29.396] - force: TRUE
[17:39:29.396] - relayed: [n=2] TRUE, FALSE
[17:39:29.396] - queued futures: [n=2] TRUE, FALSE
[17:39:29.396]  - until=2
[17:39:29.396]  - relaying element #2
[17:39:29.397] - relayed: [n=2] TRUE, TRUE
[17:39:29.397] - queued futures: [n=2] TRUE, TRUE
[17:39:29.397] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:29.397]  length: 0 (resolved future 2)
[17:39:29.397] Relaying remaining futures
[17:39:29.397] signalConditionsASAP(NULL, pos=0) ...
[17:39:29.397] - nx: 2
[17:39:29.398] - relay: TRUE
[17:39:29.398] - stdout: TRUE
[17:39:29.398] - signal: TRUE
[17:39:29.398] - resignal: FALSE
[17:39:29.398] - force: TRUE
[17:39:29.398] - relayed: [n=2] TRUE, TRUE
[17:39:29.398] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:29.398] - relayed: [n=2] TRUE, TRUE
[17:39:29.398] - queued futures: [n=2] TRUE, TRUE
[17:39:29.399] signalConditionsASAP(NULL, pos=0) ... done
[17:39:29.399] resolve() on list ... DONE
[17:39:29.399]  - Number of value chunks collected: 2
[17:39:29.399] Resolving 2 futures (chunks) ... DONE
[17:39:29.399] Reducing values from 2 chunks ...
[17:39:29.399]  - Number of values collected after concatenation: 3
[17:39:29.399]  - Number of values expected: 3
[17:39:29.400] Reducing values from 2 chunks ... DONE
[17:39:29.400] future_lapply() ... DONE
[17:39:29.400] plan(): Setting new future strategy stack:
[17:39:29.400] List of future strategies:
[17:39:29.400] 1. sequential:
[17:39:29.400]    - args: function (..., envir = parent.frame())
[17:39:29.400]    - tweaked: FALSE
[17:39:29.400]    - call: plan(sequential)
[17:39:29.401] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:39:29.402] plan(): Setting new future strategy stack:
[17:39:29.402] List of future strategies:
[17:39:29.402] 1. multisession:
[17:39:29.402]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:29.402]    - tweaked: FALSE
[17:39:29.402]    - call: plan(strategy)
[17:39:29.402] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:29.402] multisession:
[17:39:29.402] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:29.402] - tweaked: FALSE
[17:39:29.402] - call: plan(strategy)
[17:39:29.409] getGlobalsAndPackages() ...
[17:39:29.409] Not searching for globals
[17:39:29.410] - globals: [0] <none>
[17:39:29.410] getGlobalsAndPackages() ... DONE
[17:39:29.410] [local output] makeClusterPSOCK() ...
[17:39:29.457] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:29.463] [local output] Base port: 11640
[17:39:29.463] [local output] Getting setup options for 2 cluster nodes ...
[17:39:29.463] [local output]  - Node 1 of 2 ...
[17:39:29.463] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:29.464] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLtEkQ9/worker.rank=1.parallelly.parent=31048.794836d0c90f.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpLtEkQ9/worker.rank=1.parallelly.parent=31048.794836d0c90f.pid")'’
[17:39:29.656] - Possible to infer worker's PID: TRUE
[17:39:29.657] [local output] Rscript port: 11640

[17:39:29.657] [local output]  - Node 2 of 2 ...
[17:39:29.657] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:29.658] [local output] Rscript port: 11640

[17:39:29.658] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:29.659] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:29.659] [local output] Setting up PSOCK nodes in parallel
[17:39:29.659] List of 36
[17:39:29.659]  $ worker          : chr "localhost"
[17:39:29.659]   ..- attr(*, "localhost")= logi TRUE
[17:39:29.659]  $ master          : chr "localhost"
[17:39:29.659]  $ port            : int 11640
[17:39:29.659]  $ connectTimeout  : num 120
[17:39:29.659]  $ timeout         : num 2592000
[17:39:29.659]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:29.659]  $ homogeneous     : logi TRUE
[17:39:29.659]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:29.659]  $ rscript_envs    : NULL
[17:39:29.659]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:29.659]  $ rscript_startup : NULL
[17:39:29.659]  $ rscript_sh      : chr "sh"
[17:39:29.659]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:29.659]  $ methods         : logi TRUE
[17:39:29.659]  $ socketOptions   : chr "no-delay"
[17:39:29.659]  $ useXDR          : logi FALSE
[17:39:29.659]  $ outfile         : chr "/dev/null"
[17:39:29.659]  $ renice          : int NA
[17:39:29.659]  $ rshcmd          : NULL
[17:39:29.659]  $ user            : chr(0) 
[17:39:29.659]  $ revtunnel       : logi FALSE
[17:39:29.659]  $ rshlogfile      : NULL
[17:39:29.659]  $ rshopts         : chr(0) 
[17:39:29.659]  $ rank            : int 1
[17:39:29.659]  $ manual          : logi FALSE
[17:39:29.659]  $ dryrun          : logi FALSE
[17:39:29.659]  $ quiet           : logi FALSE
[17:39:29.659]  $ setup_strategy  : chr "parallel"
[17:39:29.659]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:29.659]  $ pidfile         : chr "/tmp/RtmpLtEkQ9/worker.rank=1.parallelly.parent=31048.794836d0c90f.pid"
[17:39:29.659]  $ rshcmd_label    : NULL
[17:39:29.659]  $ rsh_call        : NULL
[17:39:29.659]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:29.659]  $ localMachine    : logi TRUE
[17:39:29.659]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:29.659]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:29.659]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:29.659]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:29.659]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:29.659]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:29.659]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:29.659]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:29.659]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:29.659]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:29.659]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:29.659]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:29.659]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:29.659]  $ arguments       :List of 28
[17:39:29.659]   ..$ worker          : chr "localhost"
[17:39:29.659]   ..$ master          : NULL
[17:39:29.659]   ..$ port            : int 11640
[17:39:29.659]   ..$ connectTimeout  : num 120
[17:39:29.659]   ..$ timeout         : num 2592000
[17:39:29.659]   ..$ rscript         : NULL
[17:39:29.659]   ..$ homogeneous     : NULL
[17:39:29.659]   ..$ rscript_args    : NULL
[17:39:29.659]   ..$ rscript_envs    : NULL
[17:39:29.659]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:29.659]   ..$ rscript_startup : NULL
[17:39:29.659]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:29.659]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:29.659]   ..$ methods         : logi TRUE
[17:39:29.659]   ..$ socketOptions   : chr "no-delay"
[17:39:29.659]   ..$ useXDR          : logi FALSE
[17:39:29.659]   ..$ outfile         : chr "/dev/null"
[17:39:29.659]   ..$ renice          : int NA
[17:39:29.659]   ..$ rshcmd          : NULL
[17:39:29.659]   ..$ user            : NULL
[17:39:29.659]   ..$ revtunnel       : logi NA
[17:39:29.659]   ..$ rshlogfile      : NULL
[17:39:29.659]   ..$ rshopts         : NULL
[17:39:29.659]   ..$ rank            : int 1
[17:39:29.659]   ..$ manual          : logi FALSE
[17:39:29.659]   ..$ dryrun          : logi FALSE
[17:39:29.659]   ..$ quiet           : logi FALSE
[17:39:29.659]   ..$ setup_strategy  : chr "parallel"
[17:39:29.659]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:29.676] [local output] System call to launch all workers:
[17:39:29.677] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLtEkQ9/worker.rank=1.parallelly.parent=31048.794836d0c90f.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11640 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:29.677] [local output] Starting PSOCK main server
[17:39:29.678] [local output] Workers launched
[17:39:29.678] [local output] Waiting for workers to connect back
[17:39:29.679]  - [local output] 0 workers out of 2 ready
[17:39:29.921]  - [local output] 0 workers out of 2 ready
[17:39:29.922]  - [local output] 1 workers out of 2 ready
[17:39:29.922]  - [local output] 2 workers out of 2 ready
[17:39:29.922] [local output] Launching of workers completed
[17:39:29.922] [local output] Collecting session information from workers
[17:39:29.923] [local output]  - Worker #1 of 2
[17:39:29.924] [local output]  - Worker #2 of 2
[17:39:29.924] [local output] makeClusterPSOCK() ... done
[17:39:29.936] Packages needed by the future expression (n = 0): <none>
[17:39:29.936] Packages needed by future strategies (n = 0): <none>
[17:39:29.937] {
[17:39:29.937]     {
[17:39:29.937]         {
[17:39:29.937]             ...future.startTime <- base::Sys.time()
[17:39:29.937]             {
[17:39:29.937]                 {
[17:39:29.937]                   {
[17:39:29.937]                     {
[17:39:29.937]                       base::local({
[17:39:29.937]                         has_future <- base::requireNamespace("future", 
[17:39:29.937]                           quietly = TRUE)
[17:39:29.937]                         if (has_future) {
[17:39:29.937]                           ns <- base::getNamespace("future")
[17:39:29.937]                           version <- ns[[".package"]][["version"]]
[17:39:29.937]                           if (is.null(version)) 
[17:39:29.937]                             version <- utils::packageVersion("future")
[17:39:29.937]                         }
[17:39:29.937]                         else {
[17:39:29.937]                           version <- NULL
[17:39:29.937]                         }
[17:39:29.937]                         if (!has_future || version < "1.8.0") {
[17:39:29.937]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:29.937]                             "", base::R.version$version.string), 
[17:39:29.937]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:29.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:29.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:29.937]                               "release", "version")], collapse = " "), 
[17:39:29.937]                             hostname = base::Sys.info()[["nodename"]])
[17:39:29.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:29.937]                             info)
[17:39:29.937]                           info <- base::paste(info, collapse = "; ")
[17:39:29.937]                           if (!has_future) {
[17:39:29.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:29.937]                               info)
[17:39:29.937]                           }
[17:39:29.937]                           else {
[17:39:29.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:29.937]                               info, version)
[17:39:29.937]                           }
[17:39:29.937]                           base::stop(msg)
[17:39:29.937]                         }
[17:39:29.937]                       })
[17:39:29.937]                     }
[17:39:29.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:29.937]                     base::options(mc.cores = 1L)
[17:39:29.937]                   }
[17:39:29.937]                   options(future.plan = NULL)
[17:39:29.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:29.937]                 }
[17:39:29.937]                 ...future.workdir <- getwd()
[17:39:29.937]             }
[17:39:29.937]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:29.937]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:29.937]         }
[17:39:29.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:29.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:29.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:29.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:29.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:29.937]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:29.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:29.937]             base::names(...future.oldOptions))
[17:39:29.937]     }
[17:39:29.937]     if (FALSE) {
[17:39:29.937]     }
[17:39:29.937]     else {
[17:39:29.937]         if (TRUE) {
[17:39:29.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:29.937]                 open = "w")
[17:39:29.937]         }
[17:39:29.937]         else {
[17:39:29.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:29.937]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:29.937]         }
[17:39:29.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:29.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:29.937]             base::sink(type = "output", split = FALSE)
[17:39:29.937]             base::close(...future.stdout)
[17:39:29.937]         }, add = TRUE)
[17:39:29.937]     }
[17:39:29.937]     ...future.frame <- base::sys.nframe()
[17:39:29.937]     ...future.conditions <- base::list()
[17:39:29.937]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:29.937]     if (FALSE) {
[17:39:29.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:29.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:29.937]     }
[17:39:29.937]     ...future.result <- base::tryCatch({
[17:39:29.937]         base::withCallingHandlers({
[17:39:29.937]             ...future.value <- base::withVisible(base::local({
[17:39:29.937]                 ...future.makeSendCondition <- local({
[17:39:29.937]                   sendCondition <- NULL
[17:39:29.937]                   function(frame = 1L) {
[17:39:29.937]                     if (is.function(sendCondition)) 
[17:39:29.937]                       return(sendCondition)
[17:39:29.937]                     ns <- getNamespace("parallel")
[17:39:29.937]                     if (exists("sendData", mode = "function", 
[17:39:29.937]                       envir = ns)) {
[17:39:29.937]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:29.937]                         envir = ns)
[17:39:29.937]                       envir <- sys.frame(frame)
[17:39:29.937]                       master <- NULL
[17:39:29.937]                       while (!identical(envir, .GlobalEnv) && 
[17:39:29.937]                         !identical(envir, emptyenv())) {
[17:39:29.937]                         if (exists("master", mode = "list", envir = envir, 
[17:39:29.937]                           inherits = FALSE)) {
[17:39:29.937]                           master <- get("master", mode = "list", 
[17:39:29.937]                             envir = envir, inherits = FALSE)
[17:39:29.937]                           if (inherits(master, c("SOCKnode", 
[17:39:29.937]                             "SOCK0node"))) {
[17:39:29.937]                             sendCondition <<- function(cond) {
[17:39:29.937]                               data <- list(type = "VALUE", value = cond, 
[17:39:29.937]                                 success = TRUE)
[17:39:29.937]                               parallel_sendData(master, data)
[17:39:29.937]                             }
[17:39:29.937]                             return(sendCondition)
[17:39:29.937]                           }
[17:39:29.937]                         }
[17:39:29.937]                         frame <- frame + 1L
[17:39:29.937]                         envir <- sys.frame(frame)
[17:39:29.937]                       }
[17:39:29.937]                     }
[17:39:29.937]                     sendCondition <<- function(cond) NULL
[17:39:29.937]                   }
[17:39:29.937]                 })
[17:39:29.937]                 withCallingHandlers({
[17:39:29.937]                   NA
[17:39:29.937]                 }, immediateCondition = function(cond) {
[17:39:29.937]                   sendCondition <- ...future.makeSendCondition()
[17:39:29.937]                   sendCondition(cond)
[17:39:29.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.937]                   {
[17:39:29.937]                     inherits <- base::inherits
[17:39:29.937]                     invokeRestart <- base::invokeRestart
[17:39:29.937]                     is.null <- base::is.null
[17:39:29.937]                     muffled <- FALSE
[17:39:29.937]                     if (inherits(cond, "message")) {
[17:39:29.937]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:29.937]                       if (muffled) 
[17:39:29.937]                         invokeRestart("muffleMessage")
[17:39:29.937]                     }
[17:39:29.937]                     else if (inherits(cond, "warning")) {
[17:39:29.937]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:29.937]                       if (muffled) 
[17:39:29.937]                         invokeRestart("muffleWarning")
[17:39:29.937]                     }
[17:39:29.937]                     else if (inherits(cond, "condition")) {
[17:39:29.937]                       if (!is.null(pattern)) {
[17:39:29.937]                         computeRestarts <- base::computeRestarts
[17:39:29.937]                         grepl <- base::grepl
[17:39:29.937]                         restarts <- computeRestarts(cond)
[17:39:29.937]                         for (restart in restarts) {
[17:39:29.937]                           name <- restart$name
[17:39:29.937]                           if (is.null(name)) 
[17:39:29.937]                             next
[17:39:29.937]                           if (!grepl(pattern, name)) 
[17:39:29.937]                             next
[17:39:29.937]                           invokeRestart(restart)
[17:39:29.937]                           muffled <- TRUE
[17:39:29.937]                           break
[17:39:29.937]                         }
[17:39:29.937]                       }
[17:39:29.937]                     }
[17:39:29.937]                     invisible(muffled)
[17:39:29.937]                   }
[17:39:29.937]                   muffleCondition(cond)
[17:39:29.937]                 })
[17:39:29.937]             }))
[17:39:29.937]             future::FutureResult(value = ...future.value$value, 
[17:39:29.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.937]                   ...future.rng), globalenv = if (FALSE) 
[17:39:29.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:29.937]                     ...future.globalenv.names))
[17:39:29.937]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:29.937]         }, condition = base::local({
[17:39:29.937]             c <- base::c
[17:39:29.937]             inherits <- base::inherits
[17:39:29.937]             invokeRestart <- base::invokeRestart
[17:39:29.937]             length <- base::length
[17:39:29.937]             list <- base::list
[17:39:29.937]             seq.int <- base::seq.int
[17:39:29.937]             signalCondition <- base::signalCondition
[17:39:29.937]             sys.calls <- base::sys.calls
[17:39:29.937]             `[[` <- base::`[[`
[17:39:29.937]             `+` <- base::`+`
[17:39:29.937]             `<<-` <- base::`<<-`
[17:39:29.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:29.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:29.937]                   3L)]
[17:39:29.937]             }
[17:39:29.937]             function(cond) {
[17:39:29.937]                 is_error <- inherits(cond, "error")
[17:39:29.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:29.937]                   NULL)
[17:39:29.937]                 if (is_error) {
[17:39:29.937]                   sessionInformation <- function() {
[17:39:29.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:29.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:29.937]                       search = base::search(), system = base::Sys.info())
[17:39:29.937]                   }
[17:39:29.937]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:29.937]                     cond$call), session = sessionInformation(), 
[17:39:29.937]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:29.937]                   signalCondition(cond)
[17:39:29.937]                 }
[17:39:29.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:29.937]                 "immediateCondition"))) {
[17:39:29.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:29.937]                   ...future.conditions[[length(...future.conditions) + 
[17:39:29.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:29.937]                   if (TRUE && !signal) {
[17:39:29.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.937]                     {
[17:39:29.937]                       inherits <- base::inherits
[17:39:29.937]                       invokeRestart <- base::invokeRestart
[17:39:29.937]                       is.null <- base::is.null
[17:39:29.937]                       muffled <- FALSE
[17:39:29.937]                       if (inherits(cond, "message")) {
[17:39:29.937]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.937]                         if (muffled) 
[17:39:29.937]                           invokeRestart("muffleMessage")
[17:39:29.937]                       }
[17:39:29.937]                       else if (inherits(cond, "warning")) {
[17:39:29.937]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.937]                         if (muffled) 
[17:39:29.937]                           invokeRestart("muffleWarning")
[17:39:29.937]                       }
[17:39:29.937]                       else if (inherits(cond, "condition")) {
[17:39:29.937]                         if (!is.null(pattern)) {
[17:39:29.937]                           computeRestarts <- base::computeRestarts
[17:39:29.937]                           grepl <- base::grepl
[17:39:29.937]                           restarts <- computeRestarts(cond)
[17:39:29.937]                           for (restart in restarts) {
[17:39:29.937]                             name <- restart$name
[17:39:29.937]                             if (is.null(name)) 
[17:39:29.937]                               next
[17:39:29.937]                             if (!grepl(pattern, name)) 
[17:39:29.937]                               next
[17:39:29.937]                             invokeRestart(restart)
[17:39:29.937]                             muffled <- TRUE
[17:39:29.937]                             break
[17:39:29.937]                           }
[17:39:29.937]                         }
[17:39:29.937]                       }
[17:39:29.937]                       invisible(muffled)
[17:39:29.937]                     }
[17:39:29.937]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.937]                   }
[17:39:29.937]                 }
[17:39:29.937]                 else {
[17:39:29.937]                   if (TRUE) {
[17:39:29.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:29.937]                     {
[17:39:29.937]                       inherits <- base::inherits
[17:39:29.937]                       invokeRestart <- base::invokeRestart
[17:39:29.937]                       is.null <- base::is.null
[17:39:29.937]                       muffled <- FALSE
[17:39:29.937]                       if (inherits(cond, "message")) {
[17:39:29.937]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:29.937]                         if (muffled) 
[17:39:29.937]                           invokeRestart("muffleMessage")
[17:39:29.937]                       }
[17:39:29.937]                       else if (inherits(cond, "warning")) {
[17:39:29.937]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:29.937]                         if (muffled) 
[17:39:29.937]                           invokeRestart("muffleWarning")
[17:39:29.937]                       }
[17:39:29.937]                       else if (inherits(cond, "condition")) {
[17:39:29.937]                         if (!is.null(pattern)) {
[17:39:29.937]                           computeRestarts <- base::computeRestarts
[17:39:29.937]                           grepl <- base::grepl
[17:39:29.937]                           restarts <- computeRestarts(cond)
[17:39:29.937]                           for (restart in restarts) {
[17:39:29.937]                             name <- restart$name
[17:39:29.937]                             if (is.null(name)) 
[17:39:29.937]                               next
[17:39:29.937]                             if (!grepl(pattern, name)) 
[17:39:29.937]                               next
[17:39:29.937]                             invokeRestart(restart)
[17:39:29.937]                             muffled <- TRUE
[17:39:29.937]                             break
[17:39:29.937]                           }
[17:39:29.937]                         }
[17:39:29.937]                       }
[17:39:29.937]                       invisible(muffled)
[17:39:29.937]                     }
[17:39:29.937]                     muffleCondition(cond, pattern = "^muffle")
[17:39:29.937]                   }
[17:39:29.937]                 }
[17:39:29.937]             }
[17:39:29.937]         }))
[17:39:29.937]     }, error = function(ex) {
[17:39:29.937]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:29.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:29.937]                 ...future.rng), started = ...future.startTime, 
[17:39:29.937]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:29.937]             version = "1.8"), class = "FutureResult")
[17:39:29.937]     }, finally = {
[17:39:29.937]         if (!identical(...future.workdir, getwd())) 
[17:39:29.937]             setwd(...future.workdir)
[17:39:29.937]         {
[17:39:29.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:29.937]                 ...future.oldOptions$nwarnings <- NULL
[17:39:29.937]             }
[17:39:29.937]             base::options(...future.oldOptions)
[17:39:29.937]             if (.Platform$OS.type == "windows") {
[17:39:29.937]                 old_names <- names(...future.oldEnvVars)
[17:39:29.937]                 envs <- base::Sys.getenv()
[17:39:29.937]                 names <- names(envs)
[17:39:29.937]                 common <- intersect(names, old_names)
[17:39:29.937]                 added <- setdiff(names, old_names)
[17:39:29.937]                 removed <- setdiff(old_names, names)
[17:39:29.937]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:29.937]                   envs[common]]
[17:39:29.937]                 NAMES <- toupper(changed)
[17:39:29.937]                 args <- list()
[17:39:29.937]                 for (kk in seq_along(NAMES)) {
[17:39:29.937]                   name <- changed[[kk]]
[17:39:29.937]                   NAME <- NAMES[[kk]]
[17:39:29.937]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.937]                     next
[17:39:29.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.937]                 }
[17:39:29.937]                 NAMES <- toupper(added)
[17:39:29.937]                 for (kk in seq_along(NAMES)) {
[17:39:29.937]                   name <- added[[kk]]
[17:39:29.937]                   NAME <- NAMES[[kk]]
[17:39:29.937]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.937]                     next
[17:39:29.937]                   args[[name]] <- ""
[17:39:29.937]                 }
[17:39:29.937]                 NAMES <- toupper(removed)
[17:39:29.937]                 for (kk in seq_along(NAMES)) {
[17:39:29.937]                   name <- removed[[kk]]
[17:39:29.937]                   NAME <- NAMES[[kk]]
[17:39:29.937]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:29.937]                     next
[17:39:29.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:29.937]                 }
[17:39:29.937]                 if (length(args) > 0) 
[17:39:29.937]                   base::do.call(base::Sys.setenv, args = args)
[17:39:29.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:29.937]             }
[17:39:29.937]             else {
[17:39:29.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:29.937]             }
[17:39:29.937]             {
[17:39:29.937]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:29.937]                   0L) {
[17:39:29.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:29.937]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:29.937]                   base::options(opts)
[17:39:29.937]                 }
[17:39:29.937]                 {
[17:39:29.937]                   {
[17:39:29.937]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:29.937]                     NULL
[17:39:29.937]                   }
[17:39:29.937]                   options(future.plan = NULL)
[17:39:29.937]                   if (is.na(NA_character_)) 
[17:39:29.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:29.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:29.937]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:29.937]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:29.937]                     envir = parent.frame()) 
[17:39:29.937]                   {
[17:39:29.937]                     if (is.function(workers)) 
[17:39:29.937]                       workers <- workers()
[17:39:29.937]                     workers <- structure(as.integer(workers), 
[17:39:29.937]                       class = class(workers))
[17:39:29.937]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:29.937]                       workers >= 1)
[17:39:29.937]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:29.937]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:29.937]                     }
[17:39:29.937]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:29.937]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:29.937]                       envir = envir)
[17:39:29.937]                     if (!future$lazy) 
[17:39:29.937]                       future <- run(future)
[17:39:29.937]                     invisible(future)
[17:39:29.937]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:29.937]                 }
[17:39:29.937]             }
[17:39:29.937]         }
[17:39:29.937]     })
[17:39:29.937]     if (TRUE) {
[17:39:29.937]         base::sink(type = "output", split = FALSE)
[17:39:29.937]         if (TRUE) {
[17:39:29.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:29.937]         }
[17:39:29.937]         else {
[17:39:29.937]             ...future.result["stdout"] <- base::list(NULL)
[17:39:29.937]         }
[17:39:29.937]         base::close(...future.stdout)
[17:39:29.937]         ...future.stdout <- NULL
[17:39:29.937]     }
[17:39:29.937]     ...future.result$conditions <- ...future.conditions
[17:39:29.937]     ...future.result$finished <- base::Sys.time()
[17:39:29.937]     ...future.result
[17:39:29.937] }
[17:39:30.010] MultisessionFuture started
[17:39:30.011] result() for ClusterFuture ...
[17:39:30.011] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.011] - Validating connection of MultisessionFuture
[17:39:30.044] - received message: FutureResult
[17:39:30.044] - Received FutureResult
[17:39:30.044] - Erased future from FutureRegistry
[17:39:30.044] result() for ClusterFuture ...
[17:39:30.044] - result already collected: FutureResult
[17:39:30.044] result() for ClusterFuture ... done
[17:39:30.044] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.045] result() for ClusterFuture ... done
[17:39:30.045] result() for ClusterFuture ...
[17:39:30.045] - result already collected: FutureResult
[17:39:30.045] result() for ClusterFuture ... done
[17:39:30.045] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:30.049] plan(): nbrOfWorkers() = 2
[17:39:30.049] future_lapply() ...
[17:39:30.053] Number of chunks: 2
[17:39:30.054] getGlobalsAndPackagesXApply() ...
[17:39:30.054]  - future.globals: TRUE
[17:39:30.054] getGlobalsAndPackages() ...
[17:39:30.054] Searching for globals...
[17:39:30.055] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:30.055] Searching for globals ... DONE
[17:39:30.056] Resolving globals: FALSE
[17:39:30.056] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:30.056] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:30.057] - globals: [1] ‘FUN’
[17:39:30.057] 
[17:39:30.057] getGlobalsAndPackages() ... DONE
[17:39:30.057]  - globals found/used: [n=1] ‘FUN’
[17:39:30.057]  - needed namespaces: [n=0] 
[17:39:30.057] Finding globals ... DONE
[17:39:30.057]  - use_args: TRUE
[17:39:30.057]  - Getting '...' globals ...
[17:39:30.058] resolve() on list ...
[17:39:30.058]  recursive: 0
[17:39:30.058]  length: 1
[17:39:30.058]  elements: ‘...’
[17:39:30.058]  length: 0 (resolved future 1)
[17:39:30.058] resolve() on list ... DONE
[17:39:30.059]    - '...' content: [n=0] 
[17:39:30.059] List of 1
[17:39:30.059]  $ ...: list()
[17:39:30.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.059]  - attr(*, "where")=List of 1
[17:39:30.059]   ..$ ...:<environment: 0x555b66ccdda8> 
[17:39:30.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.059]  - attr(*, "resolved")= logi TRUE
[17:39:30.059]  - attr(*, "total_size")= num NA
[17:39:30.062]  - Getting '...' globals ... DONE
[17:39:30.062] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:30.062] List of 2
[17:39:30.062]  $ ...future.FUN:function (x, ...)  
[17:39:30.062]  $ ...          : list()
[17:39:30.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.062]  - attr(*, "where")=List of 2
[17:39:30.062]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:30.062]   ..$ ...          :<environment: 0x555b66ccdda8> 
[17:39:30.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.062]  - attr(*, "resolved")= logi FALSE
[17:39:30.062]  - attr(*, "total_size")= num 1240
[17:39:30.066] Packages to be attached in all futures: [n=0] 
[17:39:30.066] getGlobalsAndPackagesXApply() ... DONE
[17:39:30.066] Number of futures (= number of chunks): 2
[17:39:30.066] Launching 2 futures (chunks) ...
[17:39:30.066] Chunk #1 of 2 ...
[17:39:30.066]  - Finding globals in 'X' for chunk #1 ...
[17:39:30.067] getGlobalsAndPackages() ...
[17:39:30.067] Searching for globals...
[17:39:30.067] 
[17:39:30.067] Searching for globals ... DONE
[17:39:30.067] - globals: [0] <none>
[17:39:30.067] getGlobalsAndPackages() ... DONE
[17:39:30.068]    + additional globals found: [n=0] 
[17:39:30.068]    + additional namespaces needed: [n=0] 
[17:39:30.068]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:30.068]  - seeds: <none>
[17:39:30.068] getGlobalsAndPackages() ...
[17:39:30.068] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.068] Resolving globals: FALSE
[17:39:30.068] Tweak future expression to call with '...' arguments ...
[17:39:30.069] {
[17:39:30.069]     do.call(function(...) {
[17:39:30.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.069]             on.exit(options(oopts), add = TRUE)
[17:39:30.069]         }
[17:39:30.069]         {
[17:39:30.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.069]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.069]             })
[17:39:30.069]         }
[17:39:30.069]     }, args = future.call.arguments)
[17:39:30.069] }
[17:39:30.069] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.069] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.069] 
[17:39:30.070] getGlobalsAndPackages() ... DONE
[17:39:30.070] run() for ‘Future’ ...
[17:39:30.070] - state: ‘created’
[17:39:30.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.086] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.086]   - Field: ‘node’
[17:39:30.086]   - Field: ‘label’
[17:39:30.086]   - Field: ‘local’
[17:39:30.086]   - Field: ‘owner’
[17:39:30.087]   - Field: ‘envir’
[17:39:30.087]   - Field: ‘workers’
[17:39:30.087]   - Field: ‘packages’
[17:39:30.087]   - Field: ‘gc’
[17:39:30.087]   - Field: ‘conditions’
[17:39:30.087]   - Field: ‘persistent’
[17:39:30.087]   - Field: ‘expr’
[17:39:30.087]   - Field: ‘uuid’
[17:39:30.087]   - Field: ‘seed’
[17:39:30.088]   - Field: ‘version’
[17:39:30.088]   - Field: ‘result’
[17:39:30.088]   - Field: ‘asynchronous’
[17:39:30.088]   - Field: ‘calls’
[17:39:30.088]   - Field: ‘globals’
[17:39:30.088]   - Field: ‘stdout’
[17:39:30.088]   - Field: ‘earlySignal’
[17:39:30.088]   - Field: ‘lazy’
[17:39:30.089]   - Field: ‘state’
[17:39:30.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.089] - Launch lazy future ...
[17:39:30.089] Packages needed by the future expression (n = 0): <none>
[17:39:30.089] Packages needed by future strategies (n = 0): <none>
[17:39:30.090] {
[17:39:30.090]     {
[17:39:30.090]         {
[17:39:30.090]             ...future.startTime <- base::Sys.time()
[17:39:30.090]             {
[17:39:30.090]                 {
[17:39:30.090]                   {
[17:39:30.090]                     {
[17:39:30.090]                       base::local({
[17:39:30.090]                         has_future <- base::requireNamespace("future", 
[17:39:30.090]                           quietly = TRUE)
[17:39:30.090]                         if (has_future) {
[17:39:30.090]                           ns <- base::getNamespace("future")
[17:39:30.090]                           version <- ns[[".package"]][["version"]]
[17:39:30.090]                           if (is.null(version)) 
[17:39:30.090]                             version <- utils::packageVersion("future")
[17:39:30.090]                         }
[17:39:30.090]                         else {
[17:39:30.090]                           version <- NULL
[17:39:30.090]                         }
[17:39:30.090]                         if (!has_future || version < "1.8.0") {
[17:39:30.090]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.090]                             "", base::R.version$version.string), 
[17:39:30.090]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:30.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:30.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.090]                               "release", "version")], collapse = " "), 
[17:39:30.090]                             hostname = base::Sys.info()[["nodename"]])
[17:39:30.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.090]                             info)
[17:39:30.090]                           info <- base::paste(info, collapse = "; ")
[17:39:30.090]                           if (!has_future) {
[17:39:30.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.090]                               info)
[17:39:30.090]                           }
[17:39:30.090]                           else {
[17:39:30.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.090]                               info, version)
[17:39:30.090]                           }
[17:39:30.090]                           base::stop(msg)
[17:39:30.090]                         }
[17:39:30.090]                       })
[17:39:30.090]                     }
[17:39:30.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.090]                     base::options(mc.cores = 1L)
[17:39:30.090]                   }
[17:39:30.090]                   options(future.plan = NULL)
[17:39:30.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.090]                 }
[17:39:30.090]                 ...future.workdir <- getwd()
[17:39:30.090]             }
[17:39:30.090]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.090]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.090]         }
[17:39:30.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:30.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.090]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.090]             base::names(...future.oldOptions))
[17:39:30.090]     }
[17:39:30.090]     if (FALSE) {
[17:39:30.090]     }
[17:39:30.090]     else {
[17:39:30.090]         if (TRUE) {
[17:39:30.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.090]                 open = "w")
[17:39:30.090]         }
[17:39:30.090]         else {
[17:39:30.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.090]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.090]         }
[17:39:30.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.090]             base::sink(type = "output", split = FALSE)
[17:39:30.090]             base::close(...future.stdout)
[17:39:30.090]         }, add = TRUE)
[17:39:30.090]     }
[17:39:30.090]     ...future.frame <- base::sys.nframe()
[17:39:30.090]     ...future.conditions <- base::list()
[17:39:30.090]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.090]     if (FALSE) {
[17:39:30.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.090]     }
[17:39:30.090]     ...future.result <- base::tryCatch({
[17:39:30.090]         base::withCallingHandlers({
[17:39:30.090]             ...future.value <- base::withVisible(base::local({
[17:39:30.090]                 ...future.makeSendCondition <- local({
[17:39:30.090]                   sendCondition <- NULL
[17:39:30.090]                   function(frame = 1L) {
[17:39:30.090]                     if (is.function(sendCondition)) 
[17:39:30.090]                       return(sendCondition)
[17:39:30.090]                     ns <- getNamespace("parallel")
[17:39:30.090]                     if (exists("sendData", mode = "function", 
[17:39:30.090]                       envir = ns)) {
[17:39:30.090]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.090]                         envir = ns)
[17:39:30.090]                       envir <- sys.frame(frame)
[17:39:30.090]                       master <- NULL
[17:39:30.090]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.090]                         !identical(envir, emptyenv())) {
[17:39:30.090]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.090]                           inherits = FALSE)) {
[17:39:30.090]                           master <- get("master", mode = "list", 
[17:39:30.090]                             envir = envir, inherits = FALSE)
[17:39:30.090]                           if (inherits(master, c("SOCKnode", 
[17:39:30.090]                             "SOCK0node"))) {
[17:39:30.090]                             sendCondition <<- function(cond) {
[17:39:30.090]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.090]                                 success = TRUE)
[17:39:30.090]                               parallel_sendData(master, data)
[17:39:30.090]                             }
[17:39:30.090]                             return(sendCondition)
[17:39:30.090]                           }
[17:39:30.090]                         }
[17:39:30.090]                         frame <- frame + 1L
[17:39:30.090]                         envir <- sys.frame(frame)
[17:39:30.090]                       }
[17:39:30.090]                     }
[17:39:30.090]                     sendCondition <<- function(cond) NULL
[17:39:30.090]                   }
[17:39:30.090]                 })
[17:39:30.090]                 withCallingHandlers({
[17:39:30.090]                   {
[17:39:30.090]                     do.call(function(...) {
[17:39:30.090]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.090]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.090]                         ...future.globals.maxSize)) {
[17:39:30.090]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.090]                         on.exit(options(oopts), add = TRUE)
[17:39:30.090]                       }
[17:39:30.090]                       {
[17:39:30.090]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.090]                           FUN = function(jj) {
[17:39:30.090]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.090]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.090]                           })
[17:39:30.090]                       }
[17:39:30.090]                     }, args = future.call.arguments)
[17:39:30.090]                   }
[17:39:30.090]                 }, immediateCondition = function(cond) {
[17:39:30.090]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.090]                   sendCondition(cond)
[17:39:30.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.090]                   {
[17:39:30.090]                     inherits <- base::inherits
[17:39:30.090]                     invokeRestart <- base::invokeRestart
[17:39:30.090]                     is.null <- base::is.null
[17:39:30.090]                     muffled <- FALSE
[17:39:30.090]                     if (inherits(cond, "message")) {
[17:39:30.090]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.090]                       if (muffled) 
[17:39:30.090]                         invokeRestart("muffleMessage")
[17:39:30.090]                     }
[17:39:30.090]                     else if (inherits(cond, "warning")) {
[17:39:30.090]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.090]                       if (muffled) 
[17:39:30.090]                         invokeRestart("muffleWarning")
[17:39:30.090]                     }
[17:39:30.090]                     else if (inherits(cond, "condition")) {
[17:39:30.090]                       if (!is.null(pattern)) {
[17:39:30.090]                         computeRestarts <- base::computeRestarts
[17:39:30.090]                         grepl <- base::grepl
[17:39:30.090]                         restarts <- computeRestarts(cond)
[17:39:30.090]                         for (restart in restarts) {
[17:39:30.090]                           name <- restart$name
[17:39:30.090]                           if (is.null(name)) 
[17:39:30.090]                             next
[17:39:30.090]                           if (!grepl(pattern, name)) 
[17:39:30.090]                             next
[17:39:30.090]                           invokeRestart(restart)
[17:39:30.090]                           muffled <- TRUE
[17:39:30.090]                           break
[17:39:30.090]                         }
[17:39:30.090]                       }
[17:39:30.090]                     }
[17:39:30.090]                     invisible(muffled)
[17:39:30.090]                   }
[17:39:30.090]                   muffleCondition(cond)
[17:39:30.090]                 })
[17:39:30.090]             }))
[17:39:30.090]             future::FutureResult(value = ...future.value$value, 
[17:39:30.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.090]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.090]                     ...future.globalenv.names))
[17:39:30.090]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.090]         }, condition = base::local({
[17:39:30.090]             c <- base::c
[17:39:30.090]             inherits <- base::inherits
[17:39:30.090]             invokeRestart <- base::invokeRestart
[17:39:30.090]             length <- base::length
[17:39:30.090]             list <- base::list
[17:39:30.090]             seq.int <- base::seq.int
[17:39:30.090]             signalCondition <- base::signalCondition
[17:39:30.090]             sys.calls <- base::sys.calls
[17:39:30.090]             `[[` <- base::`[[`
[17:39:30.090]             `+` <- base::`+`
[17:39:30.090]             `<<-` <- base::`<<-`
[17:39:30.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.090]                   3L)]
[17:39:30.090]             }
[17:39:30.090]             function(cond) {
[17:39:30.090]                 is_error <- inherits(cond, "error")
[17:39:30.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.090]                   NULL)
[17:39:30.090]                 if (is_error) {
[17:39:30.090]                   sessionInformation <- function() {
[17:39:30.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.090]                       search = base::search(), system = base::Sys.info())
[17:39:30.090]                   }
[17:39:30.090]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.090]                     cond$call), session = sessionInformation(), 
[17:39:30.090]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.090]                   signalCondition(cond)
[17:39:30.090]                 }
[17:39:30.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.090]                 "immediateCondition"))) {
[17:39:30.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.090]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.090]                   if (TRUE && !signal) {
[17:39:30.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.090]                     {
[17:39:30.090]                       inherits <- base::inherits
[17:39:30.090]                       invokeRestart <- base::invokeRestart
[17:39:30.090]                       is.null <- base::is.null
[17:39:30.090]                       muffled <- FALSE
[17:39:30.090]                       if (inherits(cond, "message")) {
[17:39:30.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.090]                         if (muffled) 
[17:39:30.090]                           invokeRestart("muffleMessage")
[17:39:30.090]                       }
[17:39:30.090]                       else if (inherits(cond, "warning")) {
[17:39:30.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.090]                         if (muffled) 
[17:39:30.090]                           invokeRestart("muffleWarning")
[17:39:30.090]                       }
[17:39:30.090]                       else if (inherits(cond, "condition")) {
[17:39:30.090]                         if (!is.null(pattern)) {
[17:39:30.090]                           computeRestarts <- base::computeRestarts
[17:39:30.090]                           grepl <- base::grepl
[17:39:30.090]                           restarts <- computeRestarts(cond)
[17:39:30.090]                           for (restart in restarts) {
[17:39:30.090]                             name <- restart$name
[17:39:30.090]                             if (is.null(name)) 
[17:39:30.090]                               next
[17:39:30.090]                             if (!grepl(pattern, name)) 
[17:39:30.090]                               next
[17:39:30.090]                             invokeRestart(restart)
[17:39:30.090]                             muffled <- TRUE
[17:39:30.090]                             break
[17:39:30.090]                           }
[17:39:30.090]                         }
[17:39:30.090]                       }
[17:39:30.090]                       invisible(muffled)
[17:39:30.090]                     }
[17:39:30.090]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.090]                   }
[17:39:30.090]                 }
[17:39:30.090]                 else {
[17:39:30.090]                   if (TRUE) {
[17:39:30.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.090]                     {
[17:39:30.090]                       inherits <- base::inherits
[17:39:30.090]                       invokeRestart <- base::invokeRestart
[17:39:30.090]                       is.null <- base::is.null
[17:39:30.090]                       muffled <- FALSE
[17:39:30.090]                       if (inherits(cond, "message")) {
[17:39:30.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.090]                         if (muffled) 
[17:39:30.090]                           invokeRestart("muffleMessage")
[17:39:30.090]                       }
[17:39:30.090]                       else if (inherits(cond, "warning")) {
[17:39:30.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.090]                         if (muffled) 
[17:39:30.090]                           invokeRestart("muffleWarning")
[17:39:30.090]                       }
[17:39:30.090]                       else if (inherits(cond, "condition")) {
[17:39:30.090]                         if (!is.null(pattern)) {
[17:39:30.090]                           computeRestarts <- base::computeRestarts
[17:39:30.090]                           grepl <- base::grepl
[17:39:30.090]                           restarts <- computeRestarts(cond)
[17:39:30.090]                           for (restart in restarts) {
[17:39:30.090]                             name <- restart$name
[17:39:30.090]                             if (is.null(name)) 
[17:39:30.090]                               next
[17:39:30.090]                             if (!grepl(pattern, name)) 
[17:39:30.090]                               next
[17:39:30.090]                             invokeRestart(restart)
[17:39:30.090]                             muffled <- TRUE
[17:39:30.090]                             break
[17:39:30.090]                           }
[17:39:30.090]                         }
[17:39:30.090]                       }
[17:39:30.090]                       invisible(muffled)
[17:39:30.090]                     }
[17:39:30.090]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.090]                   }
[17:39:30.090]                 }
[17:39:30.090]             }
[17:39:30.090]         }))
[17:39:30.090]     }, error = function(ex) {
[17:39:30.090]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.090]                 ...future.rng), started = ...future.startTime, 
[17:39:30.090]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.090]             version = "1.8"), class = "FutureResult")
[17:39:30.090]     }, finally = {
[17:39:30.090]         if (!identical(...future.workdir, getwd())) 
[17:39:30.090]             setwd(...future.workdir)
[17:39:30.090]         {
[17:39:30.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.090]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.090]             }
[17:39:30.090]             base::options(...future.oldOptions)
[17:39:30.090]             if (.Platform$OS.type == "windows") {
[17:39:30.090]                 old_names <- names(...future.oldEnvVars)
[17:39:30.090]                 envs <- base::Sys.getenv()
[17:39:30.090]                 names <- names(envs)
[17:39:30.090]                 common <- intersect(names, old_names)
[17:39:30.090]                 added <- setdiff(names, old_names)
[17:39:30.090]                 removed <- setdiff(old_names, names)
[17:39:30.090]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.090]                   envs[common]]
[17:39:30.090]                 NAMES <- toupper(changed)
[17:39:30.090]                 args <- list()
[17:39:30.090]                 for (kk in seq_along(NAMES)) {
[17:39:30.090]                   name <- changed[[kk]]
[17:39:30.090]                   NAME <- NAMES[[kk]]
[17:39:30.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.090]                     next
[17:39:30.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.090]                 }
[17:39:30.090]                 NAMES <- toupper(added)
[17:39:30.090]                 for (kk in seq_along(NAMES)) {
[17:39:30.090]                   name <- added[[kk]]
[17:39:30.090]                   NAME <- NAMES[[kk]]
[17:39:30.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.090]                     next
[17:39:30.090]                   args[[name]] <- ""
[17:39:30.090]                 }
[17:39:30.090]                 NAMES <- toupper(removed)
[17:39:30.090]                 for (kk in seq_along(NAMES)) {
[17:39:30.090]                   name <- removed[[kk]]
[17:39:30.090]                   NAME <- NAMES[[kk]]
[17:39:30.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.090]                     next
[17:39:30.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.090]                 }
[17:39:30.090]                 if (length(args) > 0) 
[17:39:30.090]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.090]             }
[17:39:30.090]             else {
[17:39:30.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.090]             }
[17:39:30.090]             {
[17:39:30.090]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.090]                   0L) {
[17:39:30.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.090]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.090]                   base::options(opts)
[17:39:30.090]                 }
[17:39:30.090]                 {
[17:39:30.090]                   {
[17:39:30.090]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.090]                     NULL
[17:39:30.090]                   }
[17:39:30.090]                   options(future.plan = NULL)
[17:39:30.090]                   if (is.na(NA_character_)) 
[17:39:30.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.090]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.090]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.090]                     envir = parent.frame()) 
[17:39:30.090]                   {
[17:39:30.090]                     if (is.function(workers)) 
[17:39:30.090]                       workers <- workers()
[17:39:30.090]                     workers <- structure(as.integer(workers), 
[17:39:30.090]                       class = class(workers))
[17:39:30.090]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.090]                       workers >= 1)
[17:39:30.090]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.090]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.090]                     }
[17:39:30.090]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.090]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.090]                       envir = envir)
[17:39:30.090]                     if (!future$lazy) 
[17:39:30.090]                       future <- run(future)
[17:39:30.090]                     invisible(future)
[17:39:30.090]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.090]                 }
[17:39:30.090]             }
[17:39:30.090]         }
[17:39:30.090]     })
[17:39:30.090]     if (TRUE) {
[17:39:30.090]         base::sink(type = "output", split = FALSE)
[17:39:30.090]         if (TRUE) {
[17:39:30.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.090]         }
[17:39:30.090]         else {
[17:39:30.090]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.090]         }
[17:39:30.090]         base::close(...future.stdout)
[17:39:30.090]         ...future.stdout <- NULL
[17:39:30.090]     }
[17:39:30.090]     ...future.result$conditions <- ...future.conditions
[17:39:30.090]     ...future.result$finished <- base::Sys.time()
[17:39:30.090]     ...future.result
[17:39:30.090] }
[17:39:30.093] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:39:30.093] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:39:30.094] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:39:30.094] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:30.094] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.095] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:39:30.095] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:39:30.095] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:30.095] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.096] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:30.096] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.096] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:39:30.097] MultisessionFuture started
[17:39:30.097] - Launch lazy future ... done
[17:39:30.097] run() for ‘MultisessionFuture’ ... done
[17:39:30.097] Created future:
[17:39:30.097] MultisessionFuture:
[17:39:30.097] Label: ‘future_eapply-1’
[17:39:30.097] Expression:
[17:39:30.097] {
[17:39:30.097]     do.call(function(...) {
[17:39:30.097]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.097]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.097]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.097]             on.exit(options(oopts), add = TRUE)
[17:39:30.097]         }
[17:39:30.097]         {
[17:39:30.097]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.097]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.097]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.097]             })
[17:39:30.097]         }
[17:39:30.097]     }, args = future.call.arguments)
[17:39:30.097] }
[17:39:30.097] Lazy evaluation: FALSE
[17:39:30.097] Asynchronous evaluation: TRUE
[17:39:30.097] Local evaluation: TRUE
[17:39:30.097] Environment: R_GlobalEnv
[17:39:30.097] Capture standard output: TRUE
[17:39:30.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.097] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.097] Packages: <none>
[17:39:30.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.097] Resolved: FALSE
[17:39:30.097] Value: <not collected>
[17:39:30.097] Conditions captured: <none>
[17:39:30.097] Early signaling: FALSE
[17:39:30.097] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.097] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.109] Chunk #1 of 2 ... DONE
[17:39:30.109] Chunk #2 of 2 ...
[17:39:30.110]  - Finding globals in 'X' for chunk #2 ...
[17:39:30.110] getGlobalsAndPackages() ...
[17:39:30.110] Searching for globals...
[17:39:30.110] 
[17:39:30.110] Searching for globals ... DONE
[17:39:30.110] - globals: [0] <none>
[17:39:30.111] getGlobalsAndPackages() ... DONE
[17:39:30.111]    + additional globals found: [n=0] 
[17:39:30.111]    + additional namespaces needed: [n=0] 
[17:39:30.111]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:30.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:30.111]  - seeds: <none>
[17:39:30.111] getGlobalsAndPackages() ...
[17:39:30.111] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.112] Resolving globals: FALSE
[17:39:30.112] Tweak future expression to call with '...' arguments ...
[17:39:30.112] {
[17:39:30.112]     do.call(function(...) {
[17:39:30.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.112]             on.exit(options(oopts), add = TRUE)
[17:39:30.112]         }
[17:39:30.112]         {
[17:39:30.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.112]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.112]             })
[17:39:30.112]         }
[17:39:30.112]     }, args = future.call.arguments)
[17:39:30.112] }
[17:39:30.112] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.113] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.113] 
[17:39:30.113] getGlobalsAndPackages() ... DONE
[17:39:30.113] run() for ‘Future’ ...
[17:39:30.113] - state: ‘created’
[17:39:30.114] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.130]   - Field: ‘node’
[17:39:30.130]   - Field: ‘label’
[17:39:30.130]   - Field: ‘local’
[17:39:30.130]   - Field: ‘owner’
[17:39:30.130]   - Field: ‘envir’
[17:39:30.130]   - Field: ‘workers’
[17:39:30.130]   - Field: ‘packages’
[17:39:30.130]   - Field: ‘gc’
[17:39:30.130]   - Field: ‘conditions’
[17:39:30.131]   - Field: ‘persistent’
[17:39:30.131]   - Field: ‘expr’
[17:39:30.131]   - Field: ‘uuid’
[17:39:30.131]   - Field: ‘seed’
[17:39:30.131]   - Field: ‘version’
[17:39:30.131]   - Field: ‘result’
[17:39:30.131]   - Field: ‘asynchronous’
[17:39:30.131]   - Field: ‘calls’
[17:39:30.132]   - Field: ‘globals’
[17:39:30.132]   - Field: ‘stdout’
[17:39:30.132]   - Field: ‘earlySignal’
[17:39:30.132]   - Field: ‘lazy’
[17:39:30.132]   - Field: ‘state’
[17:39:30.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.132] - Launch lazy future ...
[17:39:30.133] Packages needed by the future expression (n = 0): <none>
[17:39:30.133] Packages needed by future strategies (n = 0): <none>
[17:39:30.133] {
[17:39:30.133]     {
[17:39:30.133]         {
[17:39:30.133]             ...future.startTime <- base::Sys.time()
[17:39:30.133]             {
[17:39:30.133]                 {
[17:39:30.133]                   {
[17:39:30.133]                     {
[17:39:30.133]                       base::local({
[17:39:30.133]                         has_future <- base::requireNamespace("future", 
[17:39:30.133]                           quietly = TRUE)
[17:39:30.133]                         if (has_future) {
[17:39:30.133]                           ns <- base::getNamespace("future")
[17:39:30.133]                           version <- ns[[".package"]][["version"]]
[17:39:30.133]                           if (is.null(version)) 
[17:39:30.133]                             version <- utils::packageVersion("future")
[17:39:30.133]                         }
[17:39:30.133]                         else {
[17:39:30.133]                           version <- NULL
[17:39:30.133]                         }
[17:39:30.133]                         if (!has_future || version < "1.8.0") {
[17:39:30.133]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.133]                             "", base::R.version$version.string), 
[17:39:30.133]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:30.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:30.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.133]                               "release", "version")], collapse = " "), 
[17:39:30.133]                             hostname = base::Sys.info()[["nodename"]])
[17:39:30.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.133]                             info)
[17:39:30.133]                           info <- base::paste(info, collapse = "; ")
[17:39:30.133]                           if (!has_future) {
[17:39:30.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.133]                               info)
[17:39:30.133]                           }
[17:39:30.133]                           else {
[17:39:30.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.133]                               info, version)
[17:39:30.133]                           }
[17:39:30.133]                           base::stop(msg)
[17:39:30.133]                         }
[17:39:30.133]                       })
[17:39:30.133]                     }
[17:39:30.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.133]                     base::options(mc.cores = 1L)
[17:39:30.133]                   }
[17:39:30.133]                   options(future.plan = NULL)
[17:39:30.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.133]                 }
[17:39:30.133]                 ...future.workdir <- getwd()
[17:39:30.133]             }
[17:39:30.133]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.133]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.133]         }
[17:39:30.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:30.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.133]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.133]             base::names(...future.oldOptions))
[17:39:30.133]     }
[17:39:30.133]     if (FALSE) {
[17:39:30.133]     }
[17:39:30.133]     else {
[17:39:30.133]         if (TRUE) {
[17:39:30.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.133]                 open = "w")
[17:39:30.133]         }
[17:39:30.133]         else {
[17:39:30.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.133]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.133]         }
[17:39:30.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.133]             base::sink(type = "output", split = FALSE)
[17:39:30.133]             base::close(...future.stdout)
[17:39:30.133]         }, add = TRUE)
[17:39:30.133]     }
[17:39:30.133]     ...future.frame <- base::sys.nframe()
[17:39:30.133]     ...future.conditions <- base::list()
[17:39:30.133]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.133]     if (FALSE) {
[17:39:30.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.133]     }
[17:39:30.133]     ...future.result <- base::tryCatch({
[17:39:30.133]         base::withCallingHandlers({
[17:39:30.133]             ...future.value <- base::withVisible(base::local({
[17:39:30.133]                 ...future.makeSendCondition <- local({
[17:39:30.133]                   sendCondition <- NULL
[17:39:30.133]                   function(frame = 1L) {
[17:39:30.133]                     if (is.function(sendCondition)) 
[17:39:30.133]                       return(sendCondition)
[17:39:30.133]                     ns <- getNamespace("parallel")
[17:39:30.133]                     if (exists("sendData", mode = "function", 
[17:39:30.133]                       envir = ns)) {
[17:39:30.133]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.133]                         envir = ns)
[17:39:30.133]                       envir <- sys.frame(frame)
[17:39:30.133]                       master <- NULL
[17:39:30.133]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.133]                         !identical(envir, emptyenv())) {
[17:39:30.133]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.133]                           inherits = FALSE)) {
[17:39:30.133]                           master <- get("master", mode = "list", 
[17:39:30.133]                             envir = envir, inherits = FALSE)
[17:39:30.133]                           if (inherits(master, c("SOCKnode", 
[17:39:30.133]                             "SOCK0node"))) {
[17:39:30.133]                             sendCondition <<- function(cond) {
[17:39:30.133]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.133]                                 success = TRUE)
[17:39:30.133]                               parallel_sendData(master, data)
[17:39:30.133]                             }
[17:39:30.133]                             return(sendCondition)
[17:39:30.133]                           }
[17:39:30.133]                         }
[17:39:30.133]                         frame <- frame + 1L
[17:39:30.133]                         envir <- sys.frame(frame)
[17:39:30.133]                       }
[17:39:30.133]                     }
[17:39:30.133]                     sendCondition <<- function(cond) NULL
[17:39:30.133]                   }
[17:39:30.133]                 })
[17:39:30.133]                 withCallingHandlers({
[17:39:30.133]                   {
[17:39:30.133]                     do.call(function(...) {
[17:39:30.133]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.133]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.133]                         ...future.globals.maxSize)) {
[17:39:30.133]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.133]                         on.exit(options(oopts), add = TRUE)
[17:39:30.133]                       }
[17:39:30.133]                       {
[17:39:30.133]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.133]                           FUN = function(jj) {
[17:39:30.133]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.133]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.133]                           })
[17:39:30.133]                       }
[17:39:30.133]                     }, args = future.call.arguments)
[17:39:30.133]                   }
[17:39:30.133]                 }, immediateCondition = function(cond) {
[17:39:30.133]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.133]                   sendCondition(cond)
[17:39:30.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.133]                   {
[17:39:30.133]                     inherits <- base::inherits
[17:39:30.133]                     invokeRestart <- base::invokeRestart
[17:39:30.133]                     is.null <- base::is.null
[17:39:30.133]                     muffled <- FALSE
[17:39:30.133]                     if (inherits(cond, "message")) {
[17:39:30.133]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.133]                       if (muffled) 
[17:39:30.133]                         invokeRestart("muffleMessage")
[17:39:30.133]                     }
[17:39:30.133]                     else if (inherits(cond, "warning")) {
[17:39:30.133]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.133]                       if (muffled) 
[17:39:30.133]                         invokeRestart("muffleWarning")
[17:39:30.133]                     }
[17:39:30.133]                     else if (inherits(cond, "condition")) {
[17:39:30.133]                       if (!is.null(pattern)) {
[17:39:30.133]                         computeRestarts <- base::computeRestarts
[17:39:30.133]                         grepl <- base::grepl
[17:39:30.133]                         restarts <- computeRestarts(cond)
[17:39:30.133]                         for (restart in restarts) {
[17:39:30.133]                           name <- restart$name
[17:39:30.133]                           if (is.null(name)) 
[17:39:30.133]                             next
[17:39:30.133]                           if (!grepl(pattern, name)) 
[17:39:30.133]                             next
[17:39:30.133]                           invokeRestart(restart)
[17:39:30.133]                           muffled <- TRUE
[17:39:30.133]                           break
[17:39:30.133]                         }
[17:39:30.133]                       }
[17:39:30.133]                     }
[17:39:30.133]                     invisible(muffled)
[17:39:30.133]                   }
[17:39:30.133]                   muffleCondition(cond)
[17:39:30.133]                 })
[17:39:30.133]             }))
[17:39:30.133]             future::FutureResult(value = ...future.value$value, 
[17:39:30.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.133]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.133]                     ...future.globalenv.names))
[17:39:30.133]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.133]         }, condition = base::local({
[17:39:30.133]             c <- base::c
[17:39:30.133]             inherits <- base::inherits
[17:39:30.133]             invokeRestart <- base::invokeRestart
[17:39:30.133]             length <- base::length
[17:39:30.133]             list <- base::list
[17:39:30.133]             seq.int <- base::seq.int
[17:39:30.133]             signalCondition <- base::signalCondition
[17:39:30.133]             sys.calls <- base::sys.calls
[17:39:30.133]             `[[` <- base::`[[`
[17:39:30.133]             `+` <- base::`+`
[17:39:30.133]             `<<-` <- base::`<<-`
[17:39:30.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.133]                   3L)]
[17:39:30.133]             }
[17:39:30.133]             function(cond) {
[17:39:30.133]                 is_error <- inherits(cond, "error")
[17:39:30.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.133]                   NULL)
[17:39:30.133]                 if (is_error) {
[17:39:30.133]                   sessionInformation <- function() {
[17:39:30.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.133]                       search = base::search(), system = base::Sys.info())
[17:39:30.133]                   }
[17:39:30.133]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.133]                     cond$call), session = sessionInformation(), 
[17:39:30.133]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.133]                   signalCondition(cond)
[17:39:30.133]                 }
[17:39:30.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.133]                 "immediateCondition"))) {
[17:39:30.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.133]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.133]                   if (TRUE && !signal) {
[17:39:30.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.133]                     {
[17:39:30.133]                       inherits <- base::inherits
[17:39:30.133]                       invokeRestart <- base::invokeRestart
[17:39:30.133]                       is.null <- base::is.null
[17:39:30.133]                       muffled <- FALSE
[17:39:30.133]                       if (inherits(cond, "message")) {
[17:39:30.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.133]                         if (muffled) 
[17:39:30.133]                           invokeRestart("muffleMessage")
[17:39:30.133]                       }
[17:39:30.133]                       else if (inherits(cond, "warning")) {
[17:39:30.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.133]                         if (muffled) 
[17:39:30.133]                           invokeRestart("muffleWarning")
[17:39:30.133]                       }
[17:39:30.133]                       else if (inherits(cond, "condition")) {
[17:39:30.133]                         if (!is.null(pattern)) {
[17:39:30.133]                           computeRestarts <- base::computeRestarts
[17:39:30.133]                           grepl <- base::grepl
[17:39:30.133]                           restarts <- computeRestarts(cond)
[17:39:30.133]                           for (restart in restarts) {
[17:39:30.133]                             name <- restart$name
[17:39:30.133]                             if (is.null(name)) 
[17:39:30.133]                               next
[17:39:30.133]                             if (!grepl(pattern, name)) 
[17:39:30.133]                               next
[17:39:30.133]                             invokeRestart(restart)
[17:39:30.133]                             muffled <- TRUE
[17:39:30.133]                             break
[17:39:30.133]                           }
[17:39:30.133]                         }
[17:39:30.133]                       }
[17:39:30.133]                       invisible(muffled)
[17:39:30.133]                     }
[17:39:30.133]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.133]                   }
[17:39:30.133]                 }
[17:39:30.133]                 else {
[17:39:30.133]                   if (TRUE) {
[17:39:30.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.133]                     {
[17:39:30.133]                       inherits <- base::inherits
[17:39:30.133]                       invokeRestart <- base::invokeRestart
[17:39:30.133]                       is.null <- base::is.null
[17:39:30.133]                       muffled <- FALSE
[17:39:30.133]                       if (inherits(cond, "message")) {
[17:39:30.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.133]                         if (muffled) 
[17:39:30.133]                           invokeRestart("muffleMessage")
[17:39:30.133]                       }
[17:39:30.133]                       else if (inherits(cond, "warning")) {
[17:39:30.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.133]                         if (muffled) 
[17:39:30.133]                           invokeRestart("muffleWarning")
[17:39:30.133]                       }
[17:39:30.133]                       else if (inherits(cond, "condition")) {
[17:39:30.133]                         if (!is.null(pattern)) {
[17:39:30.133]                           computeRestarts <- base::computeRestarts
[17:39:30.133]                           grepl <- base::grepl
[17:39:30.133]                           restarts <- computeRestarts(cond)
[17:39:30.133]                           for (restart in restarts) {
[17:39:30.133]                             name <- restart$name
[17:39:30.133]                             if (is.null(name)) 
[17:39:30.133]                               next
[17:39:30.133]                             if (!grepl(pattern, name)) 
[17:39:30.133]                               next
[17:39:30.133]                             invokeRestart(restart)
[17:39:30.133]                             muffled <- TRUE
[17:39:30.133]                             break
[17:39:30.133]                           }
[17:39:30.133]                         }
[17:39:30.133]                       }
[17:39:30.133]                       invisible(muffled)
[17:39:30.133]                     }
[17:39:30.133]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.133]                   }
[17:39:30.133]                 }
[17:39:30.133]             }
[17:39:30.133]         }))
[17:39:30.133]     }, error = function(ex) {
[17:39:30.133]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.133]                 ...future.rng), started = ...future.startTime, 
[17:39:30.133]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.133]             version = "1.8"), class = "FutureResult")
[17:39:30.133]     }, finally = {
[17:39:30.133]         if (!identical(...future.workdir, getwd())) 
[17:39:30.133]             setwd(...future.workdir)
[17:39:30.133]         {
[17:39:30.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.133]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.133]             }
[17:39:30.133]             base::options(...future.oldOptions)
[17:39:30.133]             if (.Platform$OS.type == "windows") {
[17:39:30.133]                 old_names <- names(...future.oldEnvVars)
[17:39:30.133]                 envs <- base::Sys.getenv()
[17:39:30.133]                 names <- names(envs)
[17:39:30.133]                 common <- intersect(names, old_names)
[17:39:30.133]                 added <- setdiff(names, old_names)
[17:39:30.133]                 removed <- setdiff(old_names, names)
[17:39:30.133]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.133]                   envs[common]]
[17:39:30.133]                 NAMES <- toupper(changed)
[17:39:30.133]                 args <- list()
[17:39:30.133]                 for (kk in seq_along(NAMES)) {
[17:39:30.133]                   name <- changed[[kk]]
[17:39:30.133]                   NAME <- NAMES[[kk]]
[17:39:30.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.133]                     next
[17:39:30.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.133]                 }
[17:39:30.133]                 NAMES <- toupper(added)
[17:39:30.133]                 for (kk in seq_along(NAMES)) {
[17:39:30.133]                   name <- added[[kk]]
[17:39:30.133]                   NAME <- NAMES[[kk]]
[17:39:30.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.133]                     next
[17:39:30.133]                   args[[name]] <- ""
[17:39:30.133]                 }
[17:39:30.133]                 NAMES <- toupper(removed)
[17:39:30.133]                 for (kk in seq_along(NAMES)) {
[17:39:30.133]                   name <- removed[[kk]]
[17:39:30.133]                   NAME <- NAMES[[kk]]
[17:39:30.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.133]                     next
[17:39:30.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.133]                 }
[17:39:30.133]                 if (length(args) > 0) 
[17:39:30.133]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.133]             }
[17:39:30.133]             else {
[17:39:30.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.133]             }
[17:39:30.133]             {
[17:39:30.133]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.133]                   0L) {
[17:39:30.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.133]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.133]                   base::options(opts)
[17:39:30.133]                 }
[17:39:30.133]                 {
[17:39:30.133]                   {
[17:39:30.133]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.133]                     NULL
[17:39:30.133]                   }
[17:39:30.133]                   options(future.plan = NULL)
[17:39:30.133]                   if (is.na(NA_character_)) 
[17:39:30.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.133]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.133]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.133]                     envir = parent.frame()) 
[17:39:30.133]                   {
[17:39:30.133]                     if (is.function(workers)) 
[17:39:30.133]                       workers <- workers()
[17:39:30.133]                     workers <- structure(as.integer(workers), 
[17:39:30.133]                       class = class(workers))
[17:39:30.133]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.133]                       workers >= 1)
[17:39:30.133]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.133]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.133]                     }
[17:39:30.133]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.133]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.133]                       envir = envir)
[17:39:30.133]                     if (!future$lazy) 
[17:39:30.133]                       future <- run(future)
[17:39:30.133]                     invisible(future)
[17:39:30.133]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.133]                 }
[17:39:30.133]             }
[17:39:30.133]         }
[17:39:30.133]     })
[17:39:30.133]     if (TRUE) {
[17:39:30.133]         base::sink(type = "output", split = FALSE)
[17:39:30.133]         if (TRUE) {
[17:39:30.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.133]         }
[17:39:30.133]         else {
[17:39:30.133]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.133]         }
[17:39:30.133]         base::close(...future.stdout)
[17:39:30.133]         ...future.stdout <- NULL
[17:39:30.133]     }
[17:39:30.133]     ...future.result$conditions <- ...future.conditions
[17:39:30.133]     ...future.result$finished <- base::Sys.time()
[17:39:30.133]     ...future.result
[17:39:30.133] }
[17:39:30.205] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:39:30.205] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:39:30.206] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:39:30.206] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:30.207] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.207] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:39:30.207] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:39:30.208] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:30.208] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.208] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:30.209] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.209] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:39:30.209] MultisessionFuture started
[17:39:30.210] - Launch lazy future ... done
[17:39:30.210] run() for ‘MultisessionFuture’ ... done
[17:39:30.210] Created future:
[17:39:30.210] MultisessionFuture:
[17:39:30.210] Label: ‘future_eapply-2’
[17:39:30.210] Expression:
[17:39:30.210] {
[17:39:30.210]     do.call(function(...) {
[17:39:30.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.210]             on.exit(options(oopts), add = TRUE)
[17:39:30.210]         }
[17:39:30.210]         {
[17:39:30.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.210]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.210]             })
[17:39:30.210]         }
[17:39:30.210]     }, args = future.call.arguments)
[17:39:30.210] }
[17:39:30.210] Lazy evaluation: FALSE
[17:39:30.210] Asynchronous evaluation: TRUE
[17:39:30.210] Local evaluation: TRUE
[17:39:30.210] Environment: R_GlobalEnv
[17:39:30.210] Capture standard output: TRUE
[17:39:30.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.210] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.210] Packages: <none>
[17:39:30.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.210] Resolved: FALSE
[17:39:30.210] Value: <not collected>
[17:39:30.210] Conditions captured: <none>
[17:39:30.210] Early signaling: FALSE
[17:39:30.210] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.210] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.222] Chunk #2 of 2 ... DONE
[17:39:30.222] Launching 2 futures (chunks) ... DONE
[17:39:30.222] Resolving 2 futures (chunks) ...
[17:39:30.223] resolve() on list ...
[17:39:30.223]  recursive: 0
[17:39:30.223]  length: 2
[17:39:30.223] 
[17:39:30.224] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.224] - Validating connection of MultisessionFuture
[17:39:30.224] - received message: FutureResult
[17:39:30.224] - Received FutureResult
[17:39:30.224] - Erased future from FutureRegistry
[17:39:30.224] result() for ClusterFuture ...
[17:39:30.224] - result already collected: FutureResult
[17:39:30.225] result() for ClusterFuture ... done
[17:39:30.225] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.225] Future #1
[17:39:30.225] result() for ClusterFuture ...
[17:39:30.225] - result already collected: FutureResult
[17:39:30.225] result() for ClusterFuture ... done
[17:39:30.225] result() for ClusterFuture ...
[17:39:30.229] - result already collected: FutureResult
[17:39:30.230] result() for ClusterFuture ... done
[17:39:30.230] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:30.230] - nx: 2
[17:39:30.230] - relay: TRUE
[17:39:30.230] - stdout: TRUE
[17:39:30.230] - signal: TRUE
[17:39:30.230] - resignal: FALSE
[17:39:30.230] - force: TRUE
[17:39:30.230] - relayed: [n=2] FALSE, FALSE
[17:39:30.230] - queued futures: [n=2] FALSE, FALSE
[17:39:30.230]  - until=1
[17:39:30.231]  - relaying element #1
[17:39:30.231] result() for ClusterFuture ...
[17:39:30.231] - result already collected: FutureResult
[17:39:30.231] result() for ClusterFuture ... done
[17:39:30.231] result() for ClusterFuture ...
[17:39:30.231] - result already collected: FutureResult
[17:39:30.231] result() for ClusterFuture ... done
[17:39:30.231] result() for ClusterFuture ...
[17:39:30.231] - result already collected: FutureResult
[17:39:30.231] result() for ClusterFuture ... done
[17:39:30.231] result() for ClusterFuture ...
[17:39:30.232] - result already collected: FutureResult
[17:39:30.232] result() for ClusterFuture ... done
[17:39:30.232] - relayed: [n=2] TRUE, FALSE
[17:39:30.232] - queued futures: [n=2] TRUE, FALSE
[17:39:30.232] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:30.232]  length: 1 (resolved future 1)
[17:39:30.295] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.295] - Validating connection of MultisessionFuture
[17:39:30.296] - received message: FutureResult
[17:39:30.296] - Received FutureResult
[17:39:30.296] - Erased future from FutureRegistry
[17:39:30.296] result() for ClusterFuture ...
[17:39:30.296] - result already collected: FutureResult
[17:39:30.296] result() for ClusterFuture ... done
[17:39:30.296] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.296] Future #2
[17:39:30.297] result() for ClusterFuture ...
[17:39:30.297] - result already collected: FutureResult
[17:39:30.297] result() for ClusterFuture ... done
[17:39:30.297] result() for ClusterFuture ...
[17:39:30.297] - result already collected: FutureResult
[17:39:30.297] result() for ClusterFuture ... done
[17:39:30.297] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:30.297] - nx: 2
[17:39:30.297] - relay: TRUE
[17:39:30.297] - stdout: TRUE
[17:39:30.297] - signal: TRUE
[17:39:30.298] - resignal: FALSE
[17:39:30.298] - force: TRUE
[17:39:30.298] - relayed: [n=2] TRUE, FALSE
[17:39:30.298] - queued futures: [n=2] TRUE, FALSE
[17:39:30.298]  - until=2
[17:39:30.298]  - relaying element #2
[17:39:30.298] result() for ClusterFuture ...
[17:39:30.298] - result already collected: FutureResult
[17:39:30.298] result() for ClusterFuture ... done
[17:39:30.298] result() for ClusterFuture ...
[17:39:30.298] - result already collected: FutureResult
[17:39:30.299] result() for ClusterFuture ... done
[17:39:30.299] result() for ClusterFuture ...
[17:39:30.299] - result already collected: FutureResult
[17:39:30.299] result() for ClusterFuture ... done
[17:39:30.299] result() for ClusterFuture ...
[17:39:30.299] - result already collected: FutureResult
[17:39:30.299] result() for ClusterFuture ... done
[17:39:30.299] - relayed: [n=2] TRUE, TRUE
[17:39:30.299] - queued futures: [n=2] TRUE, TRUE
[17:39:30.299] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:30.300]  length: 0 (resolved future 2)
[17:39:30.300] Relaying remaining futures
[17:39:30.300] signalConditionsASAP(NULL, pos=0) ...
[17:39:30.300] - nx: 2
[17:39:30.300] - relay: TRUE
[17:39:30.300] - stdout: TRUE
[17:39:30.300] - signal: TRUE
[17:39:30.300] - resignal: FALSE
[17:39:30.300] - force: TRUE
[17:39:30.300] - relayed: [n=2] TRUE, TRUE
[17:39:30.300] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:30.301] - relayed: [n=2] TRUE, TRUE
[17:39:30.301] - queued futures: [n=2] TRUE, TRUE
[17:39:30.301] signalConditionsASAP(NULL, pos=0) ... done
[17:39:30.301] resolve() on list ... DONE
[17:39:30.301] result() for ClusterFuture ...
[17:39:30.301] - result already collected: FutureResult
[17:39:30.301] result() for ClusterFuture ... done
[17:39:30.301] result() for ClusterFuture ...
[17:39:30.301] - result already collected: FutureResult
[17:39:30.301] result() for ClusterFuture ... done
[17:39:30.301] result() for ClusterFuture ...
[17:39:30.301] - result already collected: FutureResult
[17:39:30.302] result() for ClusterFuture ... done
[17:39:30.302] result() for ClusterFuture ...
[17:39:30.302] - result already collected: FutureResult
[17:39:30.302] result() for ClusterFuture ... done
[17:39:30.302]  - Number of value chunks collected: 2
[17:39:30.302] Resolving 2 futures (chunks) ... DONE
[17:39:30.302] Reducing values from 2 chunks ...
[17:39:30.302]  - Number of values collected after concatenation: 3
[17:39:30.302]  - Number of values expected: 3
[17:39:30.302] Reducing values from 2 chunks ... DONE
[17:39:30.302] future_lapply() ... DONE
[17:39:30.303] future_lapply() ...
[17:39:30.307] Number of chunks: 2
[17:39:30.307] getGlobalsAndPackagesXApply() ...
[17:39:30.307]  - future.globals: TRUE
[17:39:30.308] getGlobalsAndPackages() ...
[17:39:30.308] Searching for globals...
[17:39:30.309] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:30.309] Searching for globals ... DONE
[17:39:30.309] Resolving globals: FALSE
[17:39:30.309] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:30.310] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:30.310] - globals: [1] ‘FUN’
[17:39:30.310] - packages: [1] ‘stats’
[17:39:30.310] getGlobalsAndPackages() ... DONE
[17:39:30.310]  - globals found/used: [n=1] ‘FUN’
[17:39:30.310]  - needed namespaces: [n=1] ‘stats’
[17:39:30.310] Finding globals ... DONE
[17:39:30.310]  - use_args: TRUE
[17:39:30.311]  - Getting '...' globals ...
[17:39:30.311] resolve() on list ...
[17:39:30.311]  recursive: 0
[17:39:30.311]  length: 1
[17:39:30.311]  elements: ‘...’
[17:39:30.311]  length: 0 (resolved future 1)
[17:39:30.311] resolve() on list ... DONE
[17:39:30.311]    - '...' content: [n=1] ‘probs’
[17:39:30.312] List of 1
[17:39:30.312]  $ ...:List of 1
[17:39:30.312]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:30.312]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.312]  - attr(*, "where")=List of 1
[17:39:30.312]   ..$ ...:<environment: 0x555b658264c0> 
[17:39:30.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.312]  - attr(*, "resolved")= logi TRUE
[17:39:30.312]  - attr(*, "total_size")= num NA
[17:39:30.315]  - Getting '...' globals ... DONE
[17:39:30.315] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:30.315] List of 2
[17:39:30.315]  $ ...future.FUN:function (x, ...)  
[17:39:30.315]  $ ...          :List of 1
[17:39:30.315]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:39:30.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.315]  - attr(*, "where")=List of 2
[17:39:30.315]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:30.315]   ..$ ...          :<environment: 0x555b658264c0> 
[17:39:30.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.315]  - attr(*, "resolved")= logi FALSE
[17:39:30.315]  - attr(*, "total_size")= num 1328
[17:39:30.318] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:30.318] getGlobalsAndPackagesXApply() ... DONE
[17:39:30.318] Number of futures (= number of chunks): 2
[17:39:30.319] Launching 2 futures (chunks) ...
[17:39:30.319] Chunk #1 of 2 ...
[17:39:30.319]  - Finding globals in 'X' for chunk #1 ...
[17:39:30.319] getGlobalsAndPackages() ...
[17:39:30.319] Searching for globals...
[17:39:30.319] 
[17:39:30.319] Searching for globals ... DONE
[17:39:30.320] - globals: [0] <none>
[17:39:30.320] getGlobalsAndPackages() ... DONE
[17:39:30.320]    + additional globals found: [n=0] 
[17:39:30.320]    + additional namespaces needed: [n=0] 
[17:39:30.320]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:30.320]  - seeds: <none>
[17:39:30.320] getGlobalsAndPackages() ...
[17:39:30.320] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.320] Resolving globals: FALSE
[17:39:30.320] Tweak future expression to call with '...' arguments ...
[17:39:30.321] {
[17:39:30.321]     do.call(function(...) {
[17:39:30.321]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.321]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.321]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.321]             on.exit(options(oopts), add = TRUE)
[17:39:30.321]         }
[17:39:30.321]         {
[17:39:30.321]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.321]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.321]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.321]             })
[17:39:30.321]         }
[17:39:30.321]     }, args = future.call.arguments)
[17:39:30.321] }
[17:39:30.321] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.321] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.321] - packages: [1] ‘stats’
[17:39:30.321] getGlobalsAndPackages() ... DONE
[17:39:30.322] run() for ‘Future’ ...
[17:39:30.322] - state: ‘created’
[17:39:30.322] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.337] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.337]   - Field: ‘node’
[17:39:30.337]   - Field: ‘label’
[17:39:30.337]   - Field: ‘local’
[17:39:30.337]   - Field: ‘owner’
[17:39:30.337]   - Field: ‘envir’
[17:39:30.337]   - Field: ‘workers’
[17:39:30.337]   - Field: ‘packages’
[17:39:30.338]   - Field: ‘gc’
[17:39:30.338]   - Field: ‘conditions’
[17:39:30.338]   - Field: ‘persistent’
[17:39:30.338]   - Field: ‘expr’
[17:39:30.338]   - Field: ‘uuid’
[17:39:30.338]   - Field: ‘seed’
[17:39:30.338]   - Field: ‘version’
[17:39:30.338]   - Field: ‘result’
[17:39:30.338]   - Field: ‘asynchronous’
[17:39:30.338]   - Field: ‘calls’
[17:39:30.338]   - Field: ‘globals’
[17:39:30.339]   - Field: ‘stdout’
[17:39:30.339]   - Field: ‘earlySignal’
[17:39:30.339]   - Field: ‘lazy’
[17:39:30.339]   - Field: ‘state’
[17:39:30.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.339] - Launch lazy future ...
[17:39:30.339] Packages needed by the future expression (n = 1): ‘stats’
[17:39:30.340] Packages needed by future strategies (n = 0): <none>
[17:39:30.340] {
[17:39:30.340]     {
[17:39:30.340]         {
[17:39:30.340]             ...future.startTime <- base::Sys.time()
[17:39:30.340]             {
[17:39:30.340]                 {
[17:39:30.340]                   {
[17:39:30.340]                     {
[17:39:30.340]                       {
[17:39:30.340]                         base::local({
[17:39:30.340]                           has_future <- base::requireNamespace("future", 
[17:39:30.340]                             quietly = TRUE)
[17:39:30.340]                           if (has_future) {
[17:39:30.340]                             ns <- base::getNamespace("future")
[17:39:30.340]                             version <- ns[[".package"]][["version"]]
[17:39:30.340]                             if (is.null(version)) 
[17:39:30.340]                               version <- utils::packageVersion("future")
[17:39:30.340]                           }
[17:39:30.340]                           else {
[17:39:30.340]                             version <- NULL
[17:39:30.340]                           }
[17:39:30.340]                           if (!has_future || version < "1.8.0") {
[17:39:30.340]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.340]                               "", base::R.version$version.string), 
[17:39:30.340]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:30.340]                                 base::R.version$platform, 8 * 
[17:39:30.340]                                   base::.Machine$sizeof.pointer), 
[17:39:30.340]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.340]                                 "release", "version")], collapse = " "), 
[17:39:30.340]                               hostname = base::Sys.info()[["nodename"]])
[17:39:30.340]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.340]                               info)
[17:39:30.340]                             info <- base::paste(info, collapse = "; ")
[17:39:30.340]                             if (!has_future) {
[17:39:30.340]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.340]                                 info)
[17:39:30.340]                             }
[17:39:30.340]                             else {
[17:39:30.340]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.340]                                 info, version)
[17:39:30.340]                             }
[17:39:30.340]                             base::stop(msg)
[17:39:30.340]                           }
[17:39:30.340]                         })
[17:39:30.340]                       }
[17:39:30.340]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.340]                       base::options(mc.cores = 1L)
[17:39:30.340]                     }
[17:39:30.340]                     base::local({
[17:39:30.340]                       for (pkg in "stats") {
[17:39:30.340]                         base::loadNamespace(pkg)
[17:39:30.340]                         base::library(pkg, character.only = TRUE)
[17:39:30.340]                       }
[17:39:30.340]                     })
[17:39:30.340]                   }
[17:39:30.340]                   options(future.plan = NULL)
[17:39:30.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.340]                 }
[17:39:30.340]                 ...future.workdir <- getwd()
[17:39:30.340]             }
[17:39:30.340]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.340]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.340]         }
[17:39:30.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:30.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.340]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.340]             base::names(...future.oldOptions))
[17:39:30.340]     }
[17:39:30.340]     if (FALSE) {
[17:39:30.340]     }
[17:39:30.340]     else {
[17:39:30.340]         if (TRUE) {
[17:39:30.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.340]                 open = "w")
[17:39:30.340]         }
[17:39:30.340]         else {
[17:39:30.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.340]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.340]         }
[17:39:30.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.340]             base::sink(type = "output", split = FALSE)
[17:39:30.340]             base::close(...future.stdout)
[17:39:30.340]         }, add = TRUE)
[17:39:30.340]     }
[17:39:30.340]     ...future.frame <- base::sys.nframe()
[17:39:30.340]     ...future.conditions <- base::list()
[17:39:30.340]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.340]     if (FALSE) {
[17:39:30.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.340]     }
[17:39:30.340]     ...future.result <- base::tryCatch({
[17:39:30.340]         base::withCallingHandlers({
[17:39:30.340]             ...future.value <- base::withVisible(base::local({
[17:39:30.340]                 ...future.makeSendCondition <- local({
[17:39:30.340]                   sendCondition <- NULL
[17:39:30.340]                   function(frame = 1L) {
[17:39:30.340]                     if (is.function(sendCondition)) 
[17:39:30.340]                       return(sendCondition)
[17:39:30.340]                     ns <- getNamespace("parallel")
[17:39:30.340]                     if (exists("sendData", mode = "function", 
[17:39:30.340]                       envir = ns)) {
[17:39:30.340]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.340]                         envir = ns)
[17:39:30.340]                       envir <- sys.frame(frame)
[17:39:30.340]                       master <- NULL
[17:39:30.340]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.340]                         !identical(envir, emptyenv())) {
[17:39:30.340]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.340]                           inherits = FALSE)) {
[17:39:30.340]                           master <- get("master", mode = "list", 
[17:39:30.340]                             envir = envir, inherits = FALSE)
[17:39:30.340]                           if (inherits(master, c("SOCKnode", 
[17:39:30.340]                             "SOCK0node"))) {
[17:39:30.340]                             sendCondition <<- function(cond) {
[17:39:30.340]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.340]                                 success = TRUE)
[17:39:30.340]                               parallel_sendData(master, data)
[17:39:30.340]                             }
[17:39:30.340]                             return(sendCondition)
[17:39:30.340]                           }
[17:39:30.340]                         }
[17:39:30.340]                         frame <- frame + 1L
[17:39:30.340]                         envir <- sys.frame(frame)
[17:39:30.340]                       }
[17:39:30.340]                     }
[17:39:30.340]                     sendCondition <<- function(cond) NULL
[17:39:30.340]                   }
[17:39:30.340]                 })
[17:39:30.340]                 withCallingHandlers({
[17:39:30.340]                   {
[17:39:30.340]                     do.call(function(...) {
[17:39:30.340]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.340]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.340]                         ...future.globals.maxSize)) {
[17:39:30.340]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.340]                         on.exit(options(oopts), add = TRUE)
[17:39:30.340]                       }
[17:39:30.340]                       {
[17:39:30.340]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.340]                           FUN = function(jj) {
[17:39:30.340]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.340]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.340]                           })
[17:39:30.340]                       }
[17:39:30.340]                     }, args = future.call.arguments)
[17:39:30.340]                   }
[17:39:30.340]                 }, immediateCondition = function(cond) {
[17:39:30.340]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.340]                   sendCondition(cond)
[17:39:30.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.340]                   {
[17:39:30.340]                     inherits <- base::inherits
[17:39:30.340]                     invokeRestart <- base::invokeRestart
[17:39:30.340]                     is.null <- base::is.null
[17:39:30.340]                     muffled <- FALSE
[17:39:30.340]                     if (inherits(cond, "message")) {
[17:39:30.340]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.340]                       if (muffled) 
[17:39:30.340]                         invokeRestart("muffleMessage")
[17:39:30.340]                     }
[17:39:30.340]                     else if (inherits(cond, "warning")) {
[17:39:30.340]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.340]                       if (muffled) 
[17:39:30.340]                         invokeRestart("muffleWarning")
[17:39:30.340]                     }
[17:39:30.340]                     else if (inherits(cond, "condition")) {
[17:39:30.340]                       if (!is.null(pattern)) {
[17:39:30.340]                         computeRestarts <- base::computeRestarts
[17:39:30.340]                         grepl <- base::grepl
[17:39:30.340]                         restarts <- computeRestarts(cond)
[17:39:30.340]                         for (restart in restarts) {
[17:39:30.340]                           name <- restart$name
[17:39:30.340]                           if (is.null(name)) 
[17:39:30.340]                             next
[17:39:30.340]                           if (!grepl(pattern, name)) 
[17:39:30.340]                             next
[17:39:30.340]                           invokeRestart(restart)
[17:39:30.340]                           muffled <- TRUE
[17:39:30.340]                           break
[17:39:30.340]                         }
[17:39:30.340]                       }
[17:39:30.340]                     }
[17:39:30.340]                     invisible(muffled)
[17:39:30.340]                   }
[17:39:30.340]                   muffleCondition(cond)
[17:39:30.340]                 })
[17:39:30.340]             }))
[17:39:30.340]             future::FutureResult(value = ...future.value$value, 
[17:39:30.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.340]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.340]                     ...future.globalenv.names))
[17:39:30.340]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.340]         }, condition = base::local({
[17:39:30.340]             c <- base::c
[17:39:30.340]             inherits <- base::inherits
[17:39:30.340]             invokeRestart <- base::invokeRestart
[17:39:30.340]             length <- base::length
[17:39:30.340]             list <- base::list
[17:39:30.340]             seq.int <- base::seq.int
[17:39:30.340]             signalCondition <- base::signalCondition
[17:39:30.340]             sys.calls <- base::sys.calls
[17:39:30.340]             `[[` <- base::`[[`
[17:39:30.340]             `+` <- base::`+`
[17:39:30.340]             `<<-` <- base::`<<-`
[17:39:30.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.340]                   3L)]
[17:39:30.340]             }
[17:39:30.340]             function(cond) {
[17:39:30.340]                 is_error <- inherits(cond, "error")
[17:39:30.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.340]                   NULL)
[17:39:30.340]                 if (is_error) {
[17:39:30.340]                   sessionInformation <- function() {
[17:39:30.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.340]                       search = base::search(), system = base::Sys.info())
[17:39:30.340]                   }
[17:39:30.340]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.340]                     cond$call), session = sessionInformation(), 
[17:39:30.340]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.340]                   signalCondition(cond)
[17:39:30.340]                 }
[17:39:30.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.340]                 "immediateCondition"))) {
[17:39:30.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.340]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.340]                   if (TRUE && !signal) {
[17:39:30.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.340]                     {
[17:39:30.340]                       inherits <- base::inherits
[17:39:30.340]                       invokeRestart <- base::invokeRestart
[17:39:30.340]                       is.null <- base::is.null
[17:39:30.340]                       muffled <- FALSE
[17:39:30.340]                       if (inherits(cond, "message")) {
[17:39:30.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.340]                         if (muffled) 
[17:39:30.340]                           invokeRestart("muffleMessage")
[17:39:30.340]                       }
[17:39:30.340]                       else if (inherits(cond, "warning")) {
[17:39:30.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.340]                         if (muffled) 
[17:39:30.340]                           invokeRestart("muffleWarning")
[17:39:30.340]                       }
[17:39:30.340]                       else if (inherits(cond, "condition")) {
[17:39:30.340]                         if (!is.null(pattern)) {
[17:39:30.340]                           computeRestarts <- base::computeRestarts
[17:39:30.340]                           grepl <- base::grepl
[17:39:30.340]                           restarts <- computeRestarts(cond)
[17:39:30.340]                           for (restart in restarts) {
[17:39:30.340]                             name <- restart$name
[17:39:30.340]                             if (is.null(name)) 
[17:39:30.340]                               next
[17:39:30.340]                             if (!grepl(pattern, name)) 
[17:39:30.340]                               next
[17:39:30.340]                             invokeRestart(restart)
[17:39:30.340]                             muffled <- TRUE
[17:39:30.340]                             break
[17:39:30.340]                           }
[17:39:30.340]                         }
[17:39:30.340]                       }
[17:39:30.340]                       invisible(muffled)
[17:39:30.340]                     }
[17:39:30.340]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.340]                   }
[17:39:30.340]                 }
[17:39:30.340]                 else {
[17:39:30.340]                   if (TRUE) {
[17:39:30.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.340]                     {
[17:39:30.340]                       inherits <- base::inherits
[17:39:30.340]                       invokeRestart <- base::invokeRestart
[17:39:30.340]                       is.null <- base::is.null
[17:39:30.340]                       muffled <- FALSE
[17:39:30.340]                       if (inherits(cond, "message")) {
[17:39:30.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.340]                         if (muffled) 
[17:39:30.340]                           invokeRestart("muffleMessage")
[17:39:30.340]                       }
[17:39:30.340]                       else if (inherits(cond, "warning")) {
[17:39:30.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.340]                         if (muffled) 
[17:39:30.340]                           invokeRestart("muffleWarning")
[17:39:30.340]                       }
[17:39:30.340]                       else if (inherits(cond, "condition")) {
[17:39:30.340]                         if (!is.null(pattern)) {
[17:39:30.340]                           computeRestarts <- base::computeRestarts
[17:39:30.340]                           grepl <- base::grepl
[17:39:30.340]                           restarts <- computeRestarts(cond)
[17:39:30.340]                           for (restart in restarts) {
[17:39:30.340]                             name <- restart$name
[17:39:30.340]                             if (is.null(name)) 
[17:39:30.340]                               next
[17:39:30.340]                             if (!grepl(pattern, name)) 
[17:39:30.340]                               next
[17:39:30.340]                             invokeRestart(restart)
[17:39:30.340]                             muffled <- TRUE
[17:39:30.340]                             break
[17:39:30.340]                           }
[17:39:30.340]                         }
[17:39:30.340]                       }
[17:39:30.340]                       invisible(muffled)
[17:39:30.340]                     }
[17:39:30.340]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.340]                   }
[17:39:30.340]                 }
[17:39:30.340]             }
[17:39:30.340]         }))
[17:39:30.340]     }, error = function(ex) {
[17:39:30.340]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.340]                 ...future.rng), started = ...future.startTime, 
[17:39:30.340]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.340]             version = "1.8"), class = "FutureResult")
[17:39:30.340]     }, finally = {
[17:39:30.340]         if (!identical(...future.workdir, getwd())) 
[17:39:30.340]             setwd(...future.workdir)
[17:39:30.340]         {
[17:39:30.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.340]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.340]             }
[17:39:30.340]             base::options(...future.oldOptions)
[17:39:30.340]             if (.Platform$OS.type == "windows") {
[17:39:30.340]                 old_names <- names(...future.oldEnvVars)
[17:39:30.340]                 envs <- base::Sys.getenv()
[17:39:30.340]                 names <- names(envs)
[17:39:30.340]                 common <- intersect(names, old_names)
[17:39:30.340]                 added <- setdiff(names, old_names)
[17:39:30.340]                 removed <- setdiff(old_names, names)
[17:39:30.340]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.340]                   envs[common]]
[17:39:30.340]                 NAMES <- toupper(changed)
[17:39:30.340]                 args <- list()
[17:39:30.340]                 for (kk in seq_along(NAMES)) {
[17:39:30.340]                   name <- changed[[kk]]
[17:39:30.340]                   NAME <- NAMES[[kk]]
[17:39:30.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.340]                     next
[17:39:30.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.340]                 }
[17:39:30.340]                 NAMES <- toupper(added)
[17:39:30.340]                 for (kk in seq_along(NAMES)) {
[17:39:30.340]                   name <- added[[kk]]
[17:39:30.340]                   NAME <- NAMES[[kk]]
[17:39:30.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.340]                     next
[17:39:30.340]                   args[[name]] <- ""
[17:39:30.340]                 }
[17:39:30.340]                 NAMES <- toupper(removed)
[17:39:30.340]                 for (kk in seq_along(NAMES)) {
[17:39:30.340]                   name <- removed[[kk]]
[17:39:30.340]                   NAME <- NAMES[[kk]]
[17:39:30.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.340]                     next
[17:39:30.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.340]                 }
[17:39:30.340]                 if (length(args) > 0) 
[17:39:30.340]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.340]             }
[17:39:30.340]             else {
[17:39:30.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.340]             }
[17:39:30.340]             {
[17:39:30.340]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.340]                   0L) {
[17:39:30.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.340]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.340]                   base::options(opts)
[17:39:30.340]                 }
[17:39:30.340]                 {
[17:39:30.340]                   {
[17:39:30.340]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.340]                     NULL
[17:39:30.340]                   }
[17:39:30.340]                   options(future.plan = NULL)
[17:39:30.340]                   if (is.na(NA_character_)) 
[17:39:30.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.340]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.340]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.340]                     envir = parent.frame()) 
[17:39:30.340]                   {
[17:39:30.340]                     if (is.function(workers)) 
[17:39:30.340]                       workers <- workers()
[17:39:30.340]                     workers <- structure(as.integer(workers), 
[17:39:30.340]                       class = class(workers))
[17:39:30.340]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.340]                       workers >= 1)
[17:39:30.340]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.340]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.340]                     }
[17:39:30.340]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.340]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.340]                       envir = envir)
[17:39:30.340]                     if (!future$lazy) 
[17:39:30.340]                       future <- run(future)
[17:39:30.340]                     invisible(future)
[17:39:30.340]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.340]                 }
[17:39:30.340]             }
[17:39:30.340]         }
[17:39:30.340]     })
[17:39:30.340]     if (TRUE) {
[17:39:30.340]         base::sink(type = "output", split = FALSE)
[17:39:30.340]         if (TRUE) {
[17:39:30.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.340]         }
[17:39:30.340]         else {
[17:39:30.340]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.340]         }
[17:39:30.340]         base::close(...future.stdout)
[17:39:30.340]         ...future.stdout <- NULL
[17:39:30.340]     }
[17:39:30.340]     ...future.result$conditions <- ...future.conditions
[17:39:30.340]     ...future.result$finished <- base::Sys.time()
[17:39:30.340]     ...future.result
[17:39:30.340] }
[17:39:30.343] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[17:39:30.343] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:39:30.344] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:39:30.344] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[17:39:30.344] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[17:39:30.344] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:39:30.345] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:39:30.345] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:30.345] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.345] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:30.346] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.346] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[17:39:30.346] MultisessionFuture started
[17:39:30.346] - Launch lazy future ... done
[17:39:30.347] run() for ‘MultisessionFuture’ ... done
[17:39:30.347] Created future:
[17:39:30.347] MultisessionFuture:
[17:39:30.347] Label: ‘future_eapply-1’
[17:39:30.347] Expression:
[17:39:30.347] {
[17:39:30.347]     do.call(function(...) {
[17:39:30.347]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.347]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.347]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.347]             on.exit(options(oopts), add = TRUE)
[17:39:30.347]         }
[17:39:30.347]         {
[17:39:30.347]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.347]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.347]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.347]             })
[17:39:30.347]         }
[17:39:30.347]     }, args = future.call.arguments)
[17:39:30.347] }
[17:39:30.347] Lazy evaluation: FALSE
[17:39:30.347] Asynchronous evaluation: TRUE
[17:39:30.347] Local evaluation: TRUE
[17:39:30.347] Environment: R_GlobalEnv
[17:39:30.347] Capture standard output: TRUE
[17:39:30.347] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.347] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.347] Packages: 1 packages (‘stats’)
[17:39:30.347] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.347] Resolved: FALSE
[17:39:30.347] Value: <not collected>
[17:39:30.347] Conditions captured: <none>
[17:39:30.347] Early signaling: FALSE
[17:39:30.347] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.347] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.359] Chunk #1 of 2 ... DONE
[17:39:30.359] Chunk #2 of 2 ...
[17:39:30.359]  - Finding globals in 'X' for chunk #2 ...
[17:39:30.359] getGlobalsAndPackages() ...
[17:39:30.359] Searching for globals...
[17:39:30.359] 
[17:39:30.360] Searching for globals ... DONE
[17:39:30.360] - globals: [0] <none>
[17:39:30.360] getGlobalsAndPackages() ... DONE
[17:39:30.360]    + additional globals found: [n=0] 
[17:39:30.360]    + additional namespaces needed: [n=0] 
[17:39:30.360]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:30.360]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:30.360]  - seeds: <none>
[17:39:30.360] getGlobalsAndPackages() ...
[17:39:30.360] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.361] Resolving globals: FALSE
[17:39:30.361] Tweak future expression to call with '...' arguments ...
[17:39:30.361] {
[17:39:30.361]     do.call(function(...) {
[17:39:30.361]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.361]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.361]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.361]             on.exit(options(oopts), add = TRUE)
[17:39:30.361]         }
[17:39:30.361]         {
[17:39:30.361]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.361]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.361]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.361]             })
[17:39:30.361]         }
[17:39:30.361]     }, args = future.call.arguments)
[17:39:30.361] }
[17:39:30.361] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.362] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.362] - packages: [1] ‘stats’
[17:39:30.362] getGlobalsAndPackages() ... DONE
[17:39:30.362] run() for ‘Future’ ...
[17:39:30.362] - state: ‘created’
[17:39:30.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.377] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.378]   - Field: ‘node’
[17:39:30.378]   - Field: ‘label’
[17:39:30.378]   - Field: ‘local’
[17:39:30.378]   - Field: ‘owner’
[17:39:30.378]   - Field: ‘envir’
[17:39:30.378]   - Field: ‘workers’
[17:39:30.378]   - Field: ‘packages’
[17:39:30.379]   - Field: ‘gc’
[17:39:30.379]   - Field: ‘conditions’
[17:39:30.379]   - Field: ‘persistent’
[17:39:30.379]   - Field: ‘expr’
[17:39:30.379]   - Field: ‘uuid’
[17:39:30.379]   - Field: ‘seed’
[17:39:30.379]   - Field: ‘version’
[17:39:30.379]   - Field: ‘result’
[17:39:30.379]   - Field: ‘asynchronous’
[17:39:30.379]   - Field: ‘calls’
[17:39:30.379]   - Field: ‘globals’
[17:39:30.380]   - Field: ‘stdout’
[17:39:30.380]   - Field: ‘earlySignal’
[17:39:30.380]   - Field: ‘lazy’
[17:39:30.380]   - Field: ‘state’
[17:39:30.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.380] - Launch lazy future ...
[17:39:30.380] Packages needed by the future expression (n = 1): ‘stats’
[17:39:30.380] Packages needed by future strategies (n = 0): <none>
[17:39:30.381] {
[17:39:30.381]     {
[17:39:30.381]         {
[17:39:30.381]             ...future.startTime <- base::Sys.time()
[17:39:30.381]             {
[17:39:30.381]                 {
[17:39:30.381]                   {
[17:39:30.381]                     {
[17:39:30.381]                       {
[17:39:30.381]                         base::local({
[17:39:30.381]                           has_future <- base::requireNamespace("future", 
[17:39:30.381]                             quietly = TRUE)
[17:39:30.381]                           if (has_future) {
[17:39:30.381]                             ns <- base::getNamespace("future")
[17:39:30.381]                             version <- ns[[".package"]][["version"]]
[17:39:30.381]                             if (is.null(version)) 
[17:39:30.381]                               version <- utils::packageVersion("future")
[17:39:30.381]                           }
[17:39:30.381]                           else {
[17:39:30.381]                             version <- NULL
[17:39:30.381]                           }
[17:39:30.381]                           if (!has_future || version < "1.8.0") {
[17:39:30.381]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.381]                               "", base::R.version$version.string), 
[17:39:30.381]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:30.381]                                 base::R.version$platform, 8 * 
[17:39:30.381]                                   base::.Machine$sizeof.pointer), 
[17:39:30.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.381]                                 "release", "version")], collapse = " "), 
[17:39:30.381]                               hostname = base::Sys.info()[["nodename"]])
[17:39:30.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.381]                               info)
[17:39:30.381]                             info <- base::paste(info, collapse = "; ")
[17:39:30.381]                             if (!has_future) {
[17:39:30.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.381]                                 info)
[17:39:30.381]                             }
[17:39:30.381]                             else {
[17:39:30.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.381]                                 info, version)
[17:39:30.381]                             }
[17:39:30.381]                             base::stop(msg)
[17:39:30.381]                           }
[17:39:30.381]                         })
[17:39:30.381]                       }
[17:39:30.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.381]                       base::options(mc.cores = 1L)
[17:39:30.381]                     }
[17:39:30.381]                     base::local({
[17:39:30.381]                       for (pkg in "stats") {
[17:39:30.381]                         base::loadNamespace(pkg)
[17:39:30.381]                         base::library(pkg, character.only = TRUE)
[17:39:30.381]                       }
[17:39:30.381]                     })
[17:39:30.381]                   }
[17:39:30.381]                   options(future.plan = NULL)
[17:39:30.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.381]                 }
[17:39:30.381]                 ...future.workdir <- getwd()
[17:39:30.381]             }
[17:39:30.381]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.381]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.381]         }
[17:39:30.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.381]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:30.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.381]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.381]             base::names(...future.oldOptions))
[17:39:30.381]     }
[17:39:30.381]     if (FALSE) {
[17:39:30.381]     }
[17:39:30.381]     else {
[17:39:30.381]         if (TRUE) {
[17:39:30.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.381]                 open = "w")
[17:39:30.381]         }
[17:39:30.381]         else {
[17:39:30.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.381]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.381]         }
[17:39:30.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.381]             base::sink(type = "output", split = FALSE)
[17:39:30.381]             base::close(...future.stdout)
[17:39:30.381]         }, add = TRUE)
[17:39:30.381]     }
[17:39:30.381]     ...future.frame <- base::sys.nframe()
[17:39:30.381]     ...future.conditions <- base::list()
[17:39:30.381]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.381]     if (FALSE) {
[17:39:30.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.381]     }
[17:39:30.381]     ...future.result <- base::tryCatch({
[17:39:30.381]         base::withCallingHandlers({
[17:39:30.381]             ...future.value <- base::withVisible(base::local({
[17:39:30.381]                 ...future.makeSendCondition <- local({
[17:39:30.381]                   sendCondition <- NULL
[17:39:30.381]                   function(frame = 1L) {
[17:39:30.381]                     if (is.function(sendCondition)) 
[17:39:30.381]                       return(sendCondition)
[17:39:30.381]                     ns <- getNamespace("parallel")
[17:39:30.381]                     if (exists("sendData", mode = "function", 
[17:39:30.381]                       envir = ns)) {
[17:39:30.381]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.381]                         envir = ns)
[17:39:30.381]                       envir <- sys.frame(frame)
[17:39:30.381]                       master <- NULL
[17:39:30.381]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.381]                         !identical(envir, emptyenv())) {
[17:39:30.381]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.381]                           inherits = FALSE)) {
[17:39:30.381]                           master <- get("master", mode = "list", 
[17:39:30.381]                             envir = envir, inherits = FALSE)
[17:39:30.381]                           if (inherits(master, c("SOCKnode", 
[17:39:30.381]                             "SOCK0node"))) {
[17:39:30.381]                             sendCondition <<- function(cond) {
[17:39:30.381]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.381]                                 success = TRUE)
[17:39:30.381]                               parallel_sendData(master, data)
[17:39:30.381]                             }
[17:39:30.381]                             return(sendCondition)
[17:39:30.381]                           }
[17:39:30.381]                         }
[17:39:30.381]                         frame <- frame + 1L
[17:39:30.381]                         envir <- sys.frame(frame)
[17:39:30.381]                       }
[17:39:30.381]                     }
[17:39:30.381]                     sendCondition <<- function(cond) NULL
[17:39:30.381]                   }
[17:39:30.381]                 })
[17:39:30.381]                 withCallingHandlers({
[17:39:30.381]                   {
[17:39:30.381]                     do.call(function(...) {
[17:39:30.381]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.381]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.381]                         ...future.globals.maxSize)) {
[17:39:30.381]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.381]                         on.exit(options(oopts), add = TRUE)
[17:39:30.381]                       }
[17:39:30.381]                       {
[17:39:30.381]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.381]                           FUN = function(jj) {
[17:39:30.381]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.381]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.381]                           })
[17:39:30.381]                       }
[17:39:30.381]                     }, args = future.call.arguments)
[17:39:30.381]                   }
[17:39:30.381]                 }, immediateCondition = function(cond) {
[17:39:30.381]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.381]                   sendCondition(cond)
[17:39:30.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.381]                   {
[17:39:30.381]                     inherits <- base::inherits
[17:39:30.381]                     invokeRestart <- base::invokeRestart
[17:39:30.381]                     is.null <- base::is.null
[17:39:30.381]                     muffled <- FALSE
[17:39:30.381]                     if (inherits(cond, "message")) {
[17:39:30.381]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.381]                       if (muffled) 
[17:39:30.381]                         invokeRestart("muffleMessage")
[17:39:30.381]                     }
[17:39:30.381]                     else if (inherits(cond, "warning")) {
[17:39:30.381]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.381]                       if (muffled) 
[17:39:30.381]                         invokeRestart("muffleWarning")
[17:39:30.381]                     }
[17:39:30.381]                     else if (inherits(cond, "condition")) {
[17:39:30.381]                       if (!is.null(pattern)) {
[17:39:30.381]                         computeRestarts <- base::computeRestarts
[17:39:30.381]                         grepl <- base::grepl
[17:39:30.381]                         restarts <- computeRestarts(cond)
[17:39:30.381]                         for (restart in restarts) {
[17:39:30.381]                           name <- restart$name
[17:39:30.381]                           if (is.null(name)) 
[17:39:30.381]                             next
[17:39:30.381]                           if (!grepl(pattern, name)) 
[17:39:30.381]                             next
[17:39:30.381]                           invokeRestart(restart)
[17:39:30.381]                           muffled <- TRUE
[17:39:30.381]                           break
[17:39:30.381]                         }
[17:39:30.381]                       }
[17:39:30.381]                     }
[17:39:30.381]                     invisible(muffled)
[17:39:30.381]                   }
[17:39:30.381]                   muffleCondition(cond)
[17:39:30.381]                 })
[17:39:30.381]             }))
[17:39:30.381]             future::FutureResult(value = ...future.value$value, 
[17:39:30.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.381]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.381]                     ...future.globalenv.names))
[17:39:30.381]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.381]         }, condition = base::local({
[17:39:30.381]             c <- base::c
[17:39:30.381]             inherits <- base::inherits
[17:39:30.381]             invokeRestart <- base::invokeRestart
[17:39:30.381]             length <- base::length
[17:39:30.381]             list <- base::list
[17:39:30.381]             seq.int <- base::seq.int
[17:39:30.381]             signalCondition <- base::signalCondition
[17:39:30.381]             sys.calls <- base::sys.calls
[17:39:30.381]             `[[` <- base::`[[`
[17:39:30.381]             `+` <- base::`+`
[17:39:30.381]             `<<-` <- base::`<<-`
[17:39:30.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.381]                   3L)]
[17:39:30.381]             }
[17:39:30.381]             function(cond) {
[17:39:30.381]                 is_error <- inherits(cond, "error")
[17:39:30.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.381]                   NULL)
[17:39:30.381]                 if (is_error) {
[17:39:30.381]                   sessionInformation <- function() {
[17:39:30.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.381]                       search = base::search(), system = base::Sys.info())
[17:39:30.381]                   }
[17:39:30.381]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.381]                     cond$call), session = sessionInformation(), 
[17:39:30.381]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.381]                   signalCondition(cond)
[17:39:30.381]                 }
[17:39:30.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.381]                 "immediateCondition"))) {
[17:39:30.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.381]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.381]                   if (TRUE && !signal) {
[17:39:30.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.381]                     {
[17:39:30.381]                       inherits <- base::inherits
[17:39:30.381]                       invokeRestart <- base::invokeRestart
[17:39:30.381]                       is.null <- base::is.null
[17:39:30.381]                       muffled <- FALSE
[17:39:30.381]                       if (inherits(cond, "message")) {
[17:39:30.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.381]                         if (muffled) 
[17:39:30.381]                           invokeRestart("muffleMessage")
[17:39:30.381]                       }
[17:39:30.381]                       else if (inherits(cond, "warning")) {
[17:39:30.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.381]                         if (muffled) 
[17:39:30.381]                           invokeRestart("muffleWarning")
[17:39:30.381]                       }
[17:39:30.381]                       else if (inherits(cond, "condition")) {
[17:39:30.381]                         if (!is.null(pattern)) {
[17:39:30.381]                           computeRestarts <- base::computeRestarts
[17:39:30.381]                           grepl <- base::grepl
[17:39:30.381]                           restarts <- computeRestarts(cond)
[17:39:30.381]                           for (restart in restarts) {
[17:39:30.381]                             name <- restart$name
[17:39:30.381]                             if (is.null(name)) 
[17:39:30.381]                               next
[17:39:30.381]                             if (!grepl(pattern, name)) 
[17:39:30.381]                               next
[17:39:30.381]                             invokeRestart(restart)
[17:39:30.381]                             muffled <- TRUE
[17:39:30.381]                             break
[17:39:30.381]                           }
[17:39:30.381]                         }
[17:39:30.381]                       }
[17:39:30.381]                       invisible(muffled)
[17:39:30.381]                     }
[17:39:30.381]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.381]                   }
[17:39:30.381]                 }
[17:39:30.381]                 else {
[17:39:30.381]                   if (TRUE) {
[17:39:30.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.381]                     {
[17:39:30.381]                       inherits <- base::inherits
[17:39:30.381]                       invokeRestart <- base::invokeRestart
[17:39:30.381]                       is.null <- base::is.null
[17:39:30.381]                       muffled <- FALSE
[17:39:30.381]                       if (inherits(cond, "message")) {
[17:39:30.381]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.381]                         if (muffled) 
[17:39:30.381]                           invokeRestart("muffleMessage")
[17:39:30.381]                       }
[17:39:30.381]                       else if (inherits(cond, "warning")) {
[17:39:30.381]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.381]                         if (muffled) 
[17:39:30.381]                           invokeRestart("muffleWarning")
[17:39:30.381]                       }
[17:39:30.381]                       else if (inherits(cond, "condition")) {
[17:39:30.381]                         if (!is.null(pattern)) {
[17:39:30.381]                           computeRestarts <- base::computeRestarts
[17:39:30.381]                           grepl <- base::grepl
[17:39:30.381]                           restarts <- computeRestarts(cond)
[17:39:30.381]                           for (restart in restarts) {
[17:39:30.381]                             name <- restart$name
[17:39:30.381]                             if (is.null(name)) 
[17:39:30.381]                               next
[17:39:30.381]                             if (!grepl(pattern, name)) 
[17:39:30.381]                               next
[17:39:30.381]                             invokeRestart(restart)
[17:39:30.381]                             muffled <- TRUE
[17:39:30.381]                             break
[17:39:30.381]                           }
[17:39:30.381]                         }
[17:39:30.381]                       }
[17:39:30.381]                       invisible(muffled)
[17:39:30.381]                     }
[17:39:30.381]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.381]                   }
[17:39:30.381]                 }
[17:39:30.381]             }
[17:39:30.381]         }))
[17:39:30.381]     }, error = function(ex) {
[17:39:30.381]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.381]                 ...future.rng), started = ...future.startTime, 
[17:39:30.381]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.381]             version = "1.8"), class = "FutureResult")
[17:39:30.381]     }, finally = {
[17:39:30.381]         if (!identical(...future.workdir, getwd())) 
[17:39:30.381]             setwd(...future.workdir)
[17:39:30.381]         {
[17:39:30.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.381]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.381]             }
[17:39:30.381]             base::options(...future.oldOptions)
[17:39:30.381]             if (.Platform$OS.type == "windows") {
[17:39:30.381]                 old_names <- names(...future.oldEnvVars)
[17:39:30.381]                 envs <- base::Sys.getenv()
[17:39:30.381]                 names <- names(envs)
[17:39:30.381]                 common <- intersect(names, old_names)
[17:39:30.381]                 added <- setdiff(names, old_names)
[17:39:30.381]                 removed <- setdiff(old_names, names)
[17:39:30.381]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.381]                   envs[common]]
[17:39:30.381]                 NAMES <- toupper(changed)
[17:39:30.381]                 args <- list()
[17:39:30.381]                 for (kk in seq_along(NAMES)) {
[17:39:30.381]                   name <- changed[[kk]]
[17:39:30.381]                   NAME <- NAMES[[kk]]
[17:39:30.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.381]                     next
[17:39:30.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.381]                 }
[17:39:30.381]                 NAMES <- toupper(added)
[17:39:30.381]                 for (kk in seq_along(NAMES)) {
[17:39:30.381]                   name <- added[[kk]]
[17:39:30.381]                   NAME <- NAMES[[kk]]
[17:39:30.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.381]                     next
[17:39:30.381]                   args[[name]] <- ""
[17:39:30.381]                 }
[17:39:30.381]                 NAMES <- toupper(removed)
[17:39:30.381]                 for (kk in seq_along(NAMES)) {
[17:39:30.381]                   name <- removed[[kk]]
[17:39:30.381]                   NAME <- NAMES[[kk]]
[17:39:30.381]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.381]                     next
[17:39:30.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.381]                 }
[17:39:30.381]                 if (length(args) > 0) 
[17:39:30.381]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.381]             }
[17:39:30.381]             else {
[17:39:30.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.381]             }
[17:39:30.381]             {
[17:39:30.381]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.381]                   0L) {
[17:39:30.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.381]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.381]                   base::options(opts)
[17:39:30.381]                 }
[17:39:30.381]                 {
[17:39:30.381]                   {
[17:39:30.381]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.381]                     NULL
[17:39:30.381]                   }
[17:39:30.381]                   options(future.plan = NULL)
[17:39:30.381]                   if (is.na(NA_character_)) 
[17:39:30.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.381]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.381]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.381]                     envir = parent.frame()) 
[17:39:30.381]                   {
[17:39:30.381]                     if (is.function(workers)) 
[17:39:30.381]                       workers <- workers()
[17:39:30.381]                     workers <- structure(as.integer(workers), 
[17:39:30.381]                       class = class(workers))
[17:39:30.381]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.381]                       workers >= 1)
[17:39:30.381]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.381]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.381]                     }
[17:39:30.381]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.381]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.381]                       envir = envir)
[17:39:30.381]                     if (!future$lazy) 
[17:39:30.381]                       future <- run(future)
[17:39:30.381]                     invisible(future)
[17:39:30.381]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.381]                 }
[17:39:30.381]             }
[17:39:30.381]         }
[17:39:30.381]     })
[17:39:30.381]     if (TRUE) {
[17:39:30.381]         base::sink(type = "output", split = FALSE)
[17:39:30.381]         if (TRUE) {
[17:39:30.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.381]         }
[17:39:30.381]         else {
[17:39:30.381]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.381]         }
[17:39:30.381]         base::close(...future.stdout)
[17:39:30.381]         ...future.stdout <- NULL
[17:39:30.381]     }
[17:39:30.381]     ...future.result$conditions <- ...future.conditions
[17:39:30.381]     ...future.result$finished <- base::Sys.time()
[17:39:30.381]     ...future.result
[17:39:30.381] }
[17:39:30.384] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[17:39:30.384] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:39:30.385] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:39:30.385] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[17:39:30.385] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[17:39:30.385] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:39:30.386] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:39:30.386] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:30.386] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.386] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:30.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.387] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[17:39:30.387] MultisessionFuture started
[17:39:30.388] - Launch lazy future ... done
[17:39:30.388] run() for ‘MultisessionFuture’ ... done
[17:39:30.388] Created future:
[17:39:30.388] MultisessionFuture:
[17:39:30.388] Label: ‘future_eapply-2’
[17:39:30.388] Expression:
[17:39:30.388] {
[17:39:30.388]     do.call(function(...) {
[17:39:30.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.388]             on.exit(options(oopts), add = TRUE)
[17:39:30.388]         }
[17:39:30.388]         {
[17:39:30.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.388]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.388]             })
[17:39:30.388]         }
[17:39:30.388]     }, args = future.call.arguments)
[17:39:30.388] }
[17:39:30.388] Lazy evaluation: FALSE
[17:39:30.388] Asynchronous evaluation: TRUE
[17:39:30.388] Local evaluation: TRUE
[17:39:30.388] Environment: R_GlobalEnv
[17:39:30.388] Capture standard output: TRUE
[17:39:30.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.388] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.388] Packages: 1 packages (‘stats’)
[17:39:30.388] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.388] Resolved: FALSE
[17:39:30.388] Value: <not collected>
[17:39:30.388] Conditions captured: <none>
[17:39:30.388] Early signaling: FALSE
[17:39:30.388] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.388] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.400] Chunk #2 of 2 ... DONE
[17:39:30.400] Launching 2 futures (chunks) ... DONE
[17:39:30.400] Resolving 2 futures (chunks) ...
[17:39:30.400] resolve() on list ...
[17:39:30.400]  recursive: 0
[17:39:30.400]  length: 2
[17:39:30.400] 
[17:39:30.401] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.401] - Validating connection of MultisessionFuture
[17:39:30.401] - received message: FutureResult
[17:39:30.401] - Received FutureResult
[17:39:30.401] - Erased future from FutureRegistry
[17:39:30.402] result() for ClusterFuture ...
[17:39:30.402] - result already collected: FutureResult
[17:39:30.402] result() for ClusterFuture ... done
[17:39:30.402] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.402] Future #1
[17:39:30.402] result() for ClusterFuture ...
[17:39:30.402] - result already collected: FutureResult
[17:39:30.402] result() for ClusterFuture ... done
[17:39:30.402] result() for ClusterFuture ...
[17:39:30.402] - result already collected: FutureResult
[17:39:30.402] result() for ClusterFuture ... done
[17:39:30.403] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:30.403] - nx: 2
[17:39:30.403] - relay: TRUE
[17:39:30.403] - stdout: TRUE
[17:39:30.403] - signal: TRUE
[17:39:30.403] - resignal: FALSE
[17:39:30.403] - force: TRUE
[17:39:30.403] - relayed: [n=2] FALSE, FALSE
[17:39:30.403] - queued futures: [n=2] FALSE, FALSE
[17:39:30.403]  - until=1
[17:39:30.404]  - relaying element #1
[17:39:30.404] result() for ClusterFuture ...
[17:39:30.404] - result already collected: FutureResult
[17:39:30.404] result() for ClusterFuture ... done
[17:39:30.404] result() for ClusterFuture ...
[17:39:30.404] - result already collected: FutureResult
[17:39:30.404] result() for ClusterFuture ... done
[17:39:30.404] result() for ClusterFuture ...
[17:39:30.404] - result already collected: FutureResult
[17:39:30.404] result() for ClusterFuture ... done
[17:39:30.404] result() for ClusterFuture ...
[17:39:30.405] - result already collected: FutureResult
[17:39:30.405] result() for ClusterFuture ... done
[17:39:30.405] - relayed: [n=2] TRUE, FALSE
[17:39:30.405] - queued futures: [n=2] TRUE, FALSE
[17:39:30.405] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:30.405]  length: 1 (resolved future 1)
[17:39:30.447] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.447] - Validating connection of MultisessionFuture
[17:39:30.447] - received message: FutureResult
[17:39:30.447] - Received FutureResult
[17:39:30.448] - Erased future from FutureRegistry
[17:39:30.448] result() for ClusterFuture ...
[17:39:30.448] - result already collected: FutureResult
[17:39:30.448] result() for ClusterFuture ... done
[17:39:30.448] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.448] Future #2
[17:39:30.448] result() for ClusterFuture ...
[17:39:30.448] - result already collected: FutureResult
[17:39:30.448] result() for ClusterFuture ... done
[17:39:30.448] result() for ClusterFuture ...
[17:39:30.449] - result already collected: FutureResult
[17:39:30.449] result() for ClusterFuture ... done
[17:39:30.449] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:30.449] - nx: 2
[17:39:30.449] - relay: TRUE
[17:39:30.449] - stdout: TRUE
[17:39:30.449] - signal: TRUE
[17:39:30.449] - resignal: FALSE
[17:39:30.449] - force: TRUE
[17:39:30.449] - relayed: [n=2] TRUE, FALSE
[17:39:30.449] - queued futures: [n=2] TRUE, FALSE
[17:39:30.450]  - until=2
[17:39:30.450]  - relaying element #2
[17:39:30.450] result() for ClusterFuture ...
[17:39:30.450] - result already collected: FutureResult
[17:39:30.450] result() for ClusterFuture ... done
[17:39:30.450] result() for ClusterFuture ...
[17:39:30.450] - result already collected: FutureResult
[17:39:30.450] result() for ClusterFuture ... done
[17:39:30.450] result() for ClusterFuture ...
[17:39:30.450] - result already collected: FutureResult
[17:39:30.450] result() for ClusterFuture ... done
[17:39:30.451] result() for ClusterFuture ...
[17:39:30.451] - result already collected: FutureResult
[17:39:30.451] result() for ClusterFuture ... done
[17:39:30.451] - relayed: [n=2] TRUE, TRUE
[17:39:30.451] - queued futures: [n=2] TRUE, TRUE
[17:39:30.451] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:30.451]  length: 0 (resolved future 2)
[17:39:30.451] Relaying remaining futures
[17:39:30.451] signalConditionsASAP(NULL, pos=0) ...
[17:39:30.451] - nx: 2
[17:39:30.452] - relay: TRUE
[17:39:30.452] - stdout: TRUE
[17:39:30.452] - signal: TRUE
[17:39:30.452] - resignal: FALSE
[17:39:30.452] - force: TRUE
[17:39:30.452] - relayed: [n=2] TRUE, TRUE
[17:39:30.452] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:30.452] - relayed: [n=2] TRUE, TRUE
[17:39:30.452] - queued futures: [n=2] TRUE, TRUE
[17:39:30.452] signalConditionsASAP(NULL, pos=0) ... done
[17:39:30.452] resolve() on list ... DONE
[17:39:30.453] result() for ClusterFuture ...
[17:39:30.453] - result already collected: FutureResult
[17:39:30.453] result() for ClusterFuture ... done
[17:39:30.453] result() for ClusterFuture ...
[17:39:30.453] - result already collected: FutureResult
[17:39:30.453] result() for ClusterFuture ... done
[17:39:30.453] result() for ClusterFuture ...
[17:39:30.453] - result already collected: FutureResult
[17:39:30.453] result() for ClusterFuture ... done
[17:39:30.453] result() for ClusterFuture ...
[17:39:30.453] - result already collected: FutureResult
[17:39:30.454] result() for ClusterFuture ... done
[17:39:30.454]  - Number of value chunks collected: 2
[17:39:30.454] Resolving 2 futures (chunks) ... DONE
[17:39:30.454] Reducing values from 2 chunks ...
[17:39:30.454]  - Number of values collected after concatenation: 3
[17:39:30.454]  - Number of values expected: 3
[17:39:30.454] Reducing values from 2 chunks ... DONE
[17:39:30.454] future_lapply() ... DONE
[17:39:30.455] future_lapply() ...
[17:39:30.459] Number of chunks: 2
[17:39:30.459] getGlobalsAndPackagesXApply() ...
[17:39:30.459]  - future.globals: TRUE
[17:39:30.460] getGlobalsAndPackages() ...
[17:39:30.460] Searching for globals...
[17:39:30.461] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:30.461] Searching for globals ... DONE
[17:39:30.461] Resolving globals: FALSE
[17:39:30.461] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:30.462] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:30.462] - globals: [1] ‘FUN’
[17:39:30.462] - packages: [1] ‘stats’
[17:39:30.462] getGlobalsAndPackages() ... DONE
[17:39:30.462]  - globals found/used: [n=1] ‘FUN’
[17:39:30.462]  - needed namespaces: [n=1] ‘stats’
[17:39:30.462] Finding globals ... DONE
[17:39:30.462]  - use_args: TRUE
[17:39:30.463]  - Getting '...' globals ...
[17:39:30.463] resolve() on list ...
[17:39:30.463]  recursive: 0
[17:39:30.463]  length: 1
[17:39:30.463]  elements: ‘...’
[17:39:30.463]  length: 0 (resolved future 1)
[17:39:30.463] resolve() on list ... DONE
[17:39:30.463]    - '...' content: [n=0] 
[17:39:30.464] List of 1
[17:39:30.464]  $ ...: list()
[17:39:30.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.464]  - attr(*, "where")=List of 1
[17:39:30.464]   ..$ ...:<environment: 0x555b6757fbe0> 
[17:39:30.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.464]  - attr(*, "resolved")= logi TRUE
[17:39:30.464]  - attr(*, "total_size")= num NA
[17:39:30.468]  - Getting '...' globals ... DONE
[17:39:30.468] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:30.468] List of 2
[17:39:30.468]  $ ...future.FUN:function (x, ...)  
[17:39:30.468]  $ ...          : list()
[17:39:30.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.468]  - attr(*, "where")=List of 2
[17:39:30.468]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:30.468]   ..$ ...          :<environment: 0x555b6757fbe0> 
[17:39:30.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.468]  - attr(*, "resolved")= logi FALSE
[17:39:30.468]  - attr(*, "total_size")= num 1248
[17:39:30.471] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:30.471] getGlobalsAndPackagesXApply() ... DONE
[17:39:30.471] Number of futures (= number of chunks): 2
[17:39:30.471] Launching 2 futures (chunks) ...
[17:39:30.472] Chunk #1 of 2 ...
[17:39:30.472]  - Finding globals in 'X' for chunk #1 ...
[17:39:30.472] getGlobalsAndPackages() ...
[17:39:30.472] Searching for globals...
[17:39:30.472] 
[17:39:30.472] Searching for globals ... DONE
[17:39:30.472] - globals: [0] <none>
[17:39:30.472] getGlobalsAndPackages() ... DONE
[17:39:30.472]    + additional globals found: [n=0] 
[17:39:30.473]    + additional namespaces needed: [n=0] 
[17:39:30.473]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:30.473]  - seeds: <none>
[17:39:30.473] getGlobalsAndPackages() ...
[17:39:30.473] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.473] Resolving globals: FALSE
[17:39:30.473] Tweak future expression to call with '...' arguments ...
[17:39:30.473] {
[17:39:30.473]     do.call(function(...) {
[17:39:30.473]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.473]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.473]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.473]             on.exit(options(oopts), add = TRUE)
[17:39:30.473]         }
[17:39:30.473]         {
[17:39:30.473]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.473]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.473]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.473]             })
[17:39:30.473]         }
[17:39:30.473]     }, args = future.call.arguments)
[17:39:30.473] }
[17:39:30.473] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.474] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.474] - packages: [1] ‘stats’
[17:39:30.474] getGlobalsAndPackages() ... DONE
[17:39:30.474] run() for ‘Future’ ...
[17:39:30.474] - state: ‘created’
[17:39:30.475] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.490]   - Field: ‘node’
[17:39:30.490]   - Field: ‘label’
[17:39:30.490]   - Field: ‘local’
[17:39:30.490]   - Field: ‘owner’
[17:39:30.490]   - Field: ‘envir’
[17:39:30.491]   - Field: ‘workers’
[17:39:30.491]   - Field: ‘packages’
[17:39:30.491]   - Field: ‘gc’
[17:39:30.491]   - Field: ‘conditions’
[17:39:30.491]   - Field: ‘persistent’
[17:39:30.491]   - Field: ‘expr’
[17:39:30.491]   - Field: ‘uuid’
[17:39:30.491]   - Field: ‘seed’
[17:39:30.491]   - Field: ‘version’
[17:39:30.491]   - Field: ‘result’
[17:39:30.491]   - Field: ‘asynchronous’
[17:39:30.492]   - Field: ‘calls’
[17:39:30.492]   - Field: ‘globals’
[17:39:30.492]   - Field: ‘stdout’
[17:39:30.492]   - Field: ‘earlySignal’
[17:39:30.492]   - Field: ‘lazy’
[17:39:30.492]   - Field: ‘state’
[17:39:30.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.492] - Launch lazy future ...
[17:39:30.493] Packages needed by the future expression (n = 1): ‘stats’
[17:39:30.493] Packages needed by future strategies (n = 0): <none>
[17:39:30.493] {
[17:39:30.493]     {
[17:39:30.493]         {
[17:39:30.493]             ...future.startTime <- base::Sys.time()
[17:39:30.493]             {
[17:39:30.493]                 {
[17:39:30.493]                   {
[17:39:30.493]                     {
[17:39:30.493]                       {
[17:39:30.493]                         base::local({
[17:39:30.493]                           has_future <- base::requireNamespace("future", 
[17:39:30.493]                             quietly = TRUE)
[17:39:30.493]                           if (has_future) {
[17:39:30.493]                             ns <- base::getNamespace("future")
[17:39:30.493]                             version <- ns[[".package"]][["version"]]
[17:39:30.493]                             if (is.null(version)) 
[17:39:30.493]                               version <- utils::packageVersion("future")
[17:39:30.493]                           }
[17:39:30.493]                           else {
[17:39:30.493]                             version <- NULL
[17:39:30.493]                           }
[17:39:30.493]                           if (!has_future || version < "1.8.0") {
[17:39:30.493]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.493]                               "", base::R.version$version.string), 
[17:39:30.493]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:30.493]                                 base::R.version$platform, 8 * 
[17:39:30.493]                                   base::.Machine$sizeof.pointer), 
[17:39:30.493]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.493]                                 "release", "version")], collapse = " "), 
[17:39:30.493]                               hostname = base::Sys.info()[["nodename"]])
[17:39:30.493]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.493]                               info)
[17:39:30.493]                             info <- base::paste(info, collapse = "; ")
[17:39:30.493]                             if (!has_future) {
[17:39:30.493]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.493]                                 info)
[17:39:30.493]                             }
[17:39:30.493]                             else {
[17:39:30.493]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.493]                                 info, version)
[17:39:30.493]                             }
[17:39:30.493]                             base::stop(msg)
[17:39:30.493]                           }
[17:39:30.493]                         })
[17:39:30.493]                       }
[17:39:30.493]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.493]                       base::options(mc.cores = 1L)
[17:39:30.493]                     }
[17:39:30.493]                     base::local({
[17:39:30.493]                       for (pkg in "stats") {
[17:39:30.493]                         base::loadNamespace(pkg)
[17:39:30.493]                         base::library(pkg, character.only = TRUE)
[17:39:30.493]                       }
[17:39:30.493]                     })
[17:39:30.493]                   }
[17:39:30.493]                   options(future.plan = NULL)
[17:39:30.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.493]                 }
[17:39:30.493]                 ...future.workdir <- getwd()
[17:39:30.493]             }
[17:39:30.493]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.493]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.493]         }
[17:39:30.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:30.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.493]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.493]             base::names(...future.oldOptions))
[17:39:30.493]     }
[17:39:30.493]     if (FALSE) {
[17:39:30.493]     }
[17:39:30.493]     else {
[17:39:30.493]         if (TRUE) {
[17:39:30.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.493]                 open = "w")
[17:39:30.493]         }
[17:39:30.493]         else {
[17:39:30.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.493]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.493]         }
[17:39:30.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.493]             base::sink(type = "output", split = FALSE)
[17:39:30.493]             base::close(...future.stdout)
[17:39:30.493]         }, add = TRUE)
[17:39:30.493]     }
[17:39:30.493]     ...future.frame <- base::sys.nframe()
[17:39:30.493]     ...future.conditions <- base::list()
[17:39:30.493]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.493]     if (FALSE) {
[17:39:30.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.493]     }
[17:39:30.493]     ...future.result <- base::tryCatch({
[17:39:30.493]         base::withCallingHandlers({
[17:39:30.493]             ...future.value <- base::withVisible(base::local({
[17:39:30.493]                 ...future.makeSendCondition <- local({
[17:39:30.493]                   sendCondition <- NULL
[17:39:30.493]                   function(frame = 1L) {
[17:39:30.493]                     if (is.function(sendCondition)) 
[17:39:30.493]                       return(sendCondition)
[17:39:30.493]                     ns <- getNamespace("parallel")
[17:39:30.493]                     if (exists("sendData", mode = "function", 
[17:39:30.493]                       envir = ns)) {
[17:39:30.493]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.493]                         envir = ns)
[17:39:30.493]                       envir <- sys.frame(frame)
[17:39:30.493]                       master <- NULL
[17:39:30.493]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.493]                         !identical(envir, emptyenv())) {
[17:39:30.493]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.493]                           inherits = FALSE)) {
[17:39:30.493]                           master <- get("master", mode = "list", 
[17:39:30.493]                             envir = envir, inherits = FALSE)
[17:39:30.493]                           if (inherits(master, c("SOCKnode", 
[17:39:30.493]                             "SOCK0node"))) {
[17:39:30.493]                             sendCondition <<- function(cond) {
[17:39:30.493]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.493]                                 success = TRUE)
[17:39:30.493]                               parallel_sendData(master, data)
[17:39:30.493]                             }
[17:39:30.493]                             return(sendCondition)
[17:39:30.493]                           }
[17:39:30.493]                         }
[17:39:30.493]                         frame <- frame + 1L
[17:39:30.493]                         envir <- sys.frame(frame)
[17:39:30.493]                       }
[17:39:30.493]                     }
[17:39:30.493]                     sendCondition <<- function(cond) NULL
[17:39:30.493]                   }
[17:39:30.493]                 })
[17:39:30.493]                 withCallingHandlers({
[17:39:30.493]                   {
[17:39:30.493]                     do.call(function(...) {
[17:39:30.493]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.493]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.493]                         ...future.globals.maxSize)) {
[17:39:30.493]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.493]                         on.exit(options(oopts), add = TRUE)
[17:39:30.493]                       }
[17:39:30.493]                       {
[17:39:30.493]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.493]                           FUN = function(jj) {
[17:39:30.493]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.493]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.493]                           })
[17:39:30.493]                       }
[17:39:30.493]                     }, args = future.call.arguments)
[17:39:30.493]                   }
[17:39:30.493]                 }, immediateCondition = function(cond) {
[17:39:30.493]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.493]                   sendCondition(cond)
[17:39:30.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.493]                   {
[17:39:30.493]                     inherits <- base::inherits
[17:39:30.493]                     invokeRestart <- base::invokeRestart
[17:39:30.493]                     is.null <- base::is.null
[17:39:30.493]                     muffled <- FALSE
[17:39:30.493]                     if (inherits(cond, "message")) {
[17:39:30.493]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.493]                       if (muffled) 
[17:39:30.493]                         invokeRestart("muffleMessage")
[17:39:30.493]                     }
[17:39:30.493]                     else if (inherits(cond, "warning")) {
[17:39:30.493]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.493]                       if (muffled) 
[17:39:30.493]                         invokeRestart("muffleWarning")
[17:39:30.493]                     }
[17:39:30.493]                     else if (inherits(cond, "condition")) {
[17:39:30.493]                       if (!is.null(pattern)) {
[17:39:30.493]                         computeRestarts <- base::computeRestarts
[17:39:30.493]                         grepl <- base::grepl
[17:39:30.493]                         restarts <- computeRestarts(cond)
[17:39:30.493]                         for (restart in restarts) {
[17:39:30.493]                           name <- restart$name
[17:39:30.493]                           if (is.null(name)) 
[17:39:30.493]                             next
[17:39:30.493]                           if (!grepl(pattern, name)) 
[17:39:30.493]                             next
[17:39:30.493]                           invokeRestart(restart)
[17:39:30.493]                           muffled <- TRUE
[17:39:30.493]                           break
[17:39:30.493]                         }
[17:39:30.493]                       }
[17:39:30.493]                     }
[17:39:30.493]                     invisible(muffled)
[17:39:30.493]                   }
[17:39:30.493]                   muffleCondition(cond)
[17:39:30.493]                 })
[17:39:30.493]             }))
[17:39:30.493]             future::FutureResult(value = ...future.value$value, 
[17:39:30.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.493]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.493]                     ...future.globalenv.names))
[17:39:30.493]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.493]         }, condition = base::local({
[17:39:30.493]             c <- base::c
[17:39:30.493]             inherits <- base::inherits
[17:39:30.493]             invokeRestart <- base::invokeRestart
[17:39:30.493]             length <- base::length
[17:39:30.493]             list <- base::list
[17:39:30.493]             seq.int <- base::seq.int
[17:39:30.493]             signalCondition <- base::signalCondition
[17:39:30.493]             sys.calls <- base::sys.calls
[17:39:30.493]             `[[` <- base::`[[`
[17:39:30.493]             `+` <- base::`+`
[17:39:30.493]             `<<-` <- base::`<<-`
[17:39:30.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.493]                   3L)]
[17:39:30.493]             }
[17:39:30.493]             function(cond) {
[17:39:30.493]                 is_error <- inherits(cond, "error")
[17:39:30.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.493]                   NULL)
[17:39:30.493]                 if (is_error) {
[17:39:30.493]                   sessionInformation <- function() {
[17:39:30.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.493]                       search = base::search(), system = base::Sys.info())
[17:39:30.493]                   }
[17:39:30.493]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.493]                     cond$call), session = sessionInformation(), 
[17:39:30.493]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.493]                   signalCondition(cond)
[17:39:30.493]                 }
[17:39:30.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.493]                 "immediateCondition"))) {
[17:39:30.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.493]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.493]                   if (TRUE && !signal) {
[17:39:30.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.493]                     {
[17:39:30.493]                       inherits <- base::inherits
[17:39:30.493]                       invokeRestart <- base::invokeRestart
[17:39:30.493]                       is.null <- base::is.null
[17:39:30.493]                       muffled <- FALSE
[17:39:30.493]                       if (inherits(cond, "message")) {
[17:39:30.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.493]                         if (muffled) 
[17:39:30.493]                           invokeRestart("muffleMessage")
[17:39:30.493]                       }
[17:39:30.493]                       else if (inherits(cond, "warning")) {
[17:39:30.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.493]                         if (muffled) 
[17:39:30.493]                           invokeRestart("muffleWarning")
[17:39:30.493]                       }
[17:39:30.493]                       else if (inherits(cond, "condition")) {
[17:39:30.493]                         if (!is.null(pattern)) {
[17:39:30.493]                           computeRestarts <- base::computeRestarts
[17:39:30.493]                           grepl <- base::grepl
[17:39:30.493]                           restarts <- computeRestarts(cond)
[17:39:30.493]                           for (restart in restarts) {
[17:39:30.493]                             name <- restart$name
[17:39:30.493]                             if (is.null(name)) 
[17:39:30.493]                               next
[17:39:30.493]                             if (!grepl(pattern, name)) 
[17:39:30.493]                               next
[17:39:30.493]                             invokeRestart(restart)
[17:39:30.493]                             muffled <- TRUE
[17:39:30.493]                             break
[17:39:30.493]                           }
[17:39:30.493]                         }
[17:39:30.493]                       }
[17:39:30.493]                       invisible(muffled)
[17:39:30.493]                     }
[17:39:30.493]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.493]                   }
[17:39:30.493]                 }
[17:39:30.493]                 else {
[17:39:30.493]                   if (TRUE) {
[17:39:30.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.493]                     {
[17:39:30.493]                       inherits <- base::inherits
[17:39:30.493]                       invokeRestart <- base::invokeRestart
[17:39:30.493]                       is.null <- base::is.null
[17:39:30.493]                       muffled <- FALSE
[17:39:30.493]                       if (inherits(cond, "message")) {
[17:39:30.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.493]                         if (muffled) 
[17:39:30.493]                           invokeRestart("muffleMessage")
[17:39:30.493]                       }
[17:39:30.493]                       else if (inherits(cond, "warning")) {
[17:39:30.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.493]                         if (muffled) 
[17:39:30.493]                           invokeRestart("muffleWarning")
[17:39:30.493]                       }
[17:39:30.493]                       else if (inherits(cond, "condition")) {
[17:39:30.493]                         if (!is.null(pattern)) {
[17:39:30.493]                           computeRestarts <- base::computeRestarts
[17:39:30.493]                           grepl <- base::grepl
[17:39:30.493]                           restarts <- computeRestarts(cond)
[17:39:30.493]                           for (restart in restarts) {
[17:39:30.493]                             name <- restart$name
[17:39:30.493]                             if (is.null(name)) 
[17:39:30.493]                               next
[17:39:30.493]                             if (!grepl(pattern, name)) 
[17:39:30.493]                               next
[17:39:30.493]                             invokeRestart(restart)
[17:39:30.493]                             muffled <- TRUE
[17:39:30.493]                             break
[17:39:30.493]                           }
[17:39:30.493]                         }
[17:39:30.493]                       }
[17:39:30.493]                       invisible(muffled)
[17:39:30.493]                     }
[17:39:30.493]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.493]                   }
[17:39:30.493]                 }
[17:39:30.493]             }
[17:39:30.493]         }))
[17:39:30.493]     }, error = function(ex) {
[17:39:30.493]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.493]                 ...future.rng), started = ...future.startTime, 
[17:39:30.493]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.493]             version = "1.8"), class = "FutureResult")
[17:39:30.493]     }, finally = {
[17:39:30.493]         if (!identical(...future.workdir, getwd())) 
[17:39:30.493]             setwd(...future.workdir)
[17:39:30.493]         {
[17:39:30.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.493]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.493]             }
[17:39:30.493]             base::options(...future.oldOptions)
[17:39:30.493]             if (.Platform$OS.type == "windows") {
[17:39:30.493]                 old_names <- names(...future.oldEnvVars)
[17:39:30.493]                 envs <- base::Sys.getenv()
[17:39:30.493]                 names <- names(envs)
[17:39:30.493]                 common <- intersect(names, old_names)
[17:39:30.493]                 added <- setdiff(names, old_names)
[17:39:30.493]                 removed <- setdiff(old_names, names)
[17:39:30.493]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.493]                   envs[common]]
[17:39:30.493]                 NAMES <- toupper(changed)
[17:39:30.493]                 args <- list()
[17:39:30.493]                 for (kk in seq_along(NAMES)) {
[17:39:30.493]                   name <- changed[[kk]]
[17:39:30.493]                   NAME <- NAMES[[kk]]
[17:39:30.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.493]                     next
[17:39:30.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.493]                 }
[17:39:30.493]                 NAMES <- toupper(added)
[17:39:30.493]                 for (kk in seq_along(NAMES)) {
[17:39:30.493]                   name <- added[[kk]]
[17:39:30.493]                   NAME <- NAMES[[kk]]
[17:39:30.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.493]                     next
[17:39:30.493]                   args[[name]] <- ""
[17:39:30.493]                 }
[17:39:30.493]                 NAMES <- toupper(removed)
[17:39:30.493]                 for (kk in seq_along(NAMES)) {
[17:39:30.493]                   name <- removed[[kk]]
[17:39:30.493]                   NAME <- NAMES[[kk]]
[17:39:30.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.493]                     next
[17:39:30.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.493]                 }
[17:39:30.493]                 if (length(args) > 0) 
[17:39:30.493]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.493]             }
[17:39:30.493]             else {
[17:39:30.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.493]             }
[17:39:30.493]             {
[17:39:30.493]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.493]                   0L) {
[17:39:30.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.493]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.493]                   base::options(opts)
[17:39:30.493]                 }
[17:39:30.493]                 {
[17:39:30.493]                   {
[17:39:30.493]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.493]                     NULL
[17:39:30.493]                   }
[17:39:30.493]                   options(future.plan = NULL)
[17:39:30.493]                   if (is.na(NA_character_)) 
[17:39:30.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.493]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.493]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.493]                     envir = parent.frame()) 
[17:39:30.493]                   {
[17:39:30.493]                     if (is.function(workers)) 
[17:39:30.493]                       workers <- workers()
[17:39:30.493]                     workers <- structure(as.integer(workers), 
[17:39:30.493]                       class = class(workers))
[17:39:30.493]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.493]                       workers >= 1)
[17:39:30.493]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.493]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.493]                     }
[17:39:30.493]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.493]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.493]                       envir = envir)
[17:39:30.493]                     if (!future$lazy) 
[17:39:30.493]                       future <- run(future)
[17:39:30.493]                     invisible(future)
[17:39:30.493]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.493]                 }
[17:39:30.493]             }
[17:39:30.493]         }
[17:39:30.493]     })
[17:39:30.493]     if (TRUE) {
[17:39:30.493]         base::sink(type = "output", split = FALSE)
[17:39:30.493]         if (TRUE) {
[17:39:30.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.493]         }
[17:39:30.493]         else {
[17:39:30.493]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.493]         }
[17:39:30.493]         base::close(...future.stdout)
[17:39:30.493]         ...future.stdout <- NULL
[17:39:30.493]     }
[17:39:30.493]     ...future.result$conditions <- ...future.conditions
[17:39:30.493]     ...future.result$finished <- base::Sys.time()
[17:39:30.493]     ...future.result
[17:39:30.493] }
[17:39:30.496] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:39:30.496] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:39:30.497] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:39:30.497] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:30.497] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.497] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:39:30.498] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:39:30.498] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:30.498] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.498] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:30.499] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.499] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:39:30.500] MultisessionFuture started
[17:39:30.500] - Launch lazy future ... done
[17:39:30.500] run() for ‘MultisessionFuture’ ... done
[17:39:30.500] Created future:
[17:39:30.500] MultisessionFuture:
[17:39:30.500] Label: ‘future_eapply-1’
[17:39:30.500] Expression:
[17:39:30.500] {
[17:39:30.500]     do.call(function(...) {
[17:39:30.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.500]             on.exit(options(oopts), add = TRUE)
[17:39:30.500]         }
[17:39:30.500]         {
[17:39:30.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.500]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.500]             })
[17:39:30.500]         }
[17:39:30.500]     }, args = future.call.arguments)
[17:39:30.500] }
[17:39:30.500] Lazy evaluation: FALSE
[17:39:30.500] Asynchronous evaluation: TRUE
[17:39:30.500] Local evaluation: TRUE
[17:39:30.500] Environment: R_GlobalEnv
[17:39:30.500] Capture standard output: TRUE
[17:39:30.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.500] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.500] Packages: 1 packages (‘stats’)
[17:39:30.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.500] Resolved: FALSE
[17:39:30.500] Value: <not collected>
[17:39:30.500] Conditions captured: <none>
[17:39:30.500] Early signaling: FALSE
[17:39:30.500] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.500] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.512] Chunk #1 of 2 ... DONE
[17:39:30.512] Chunk #2 of 2 ...
[17:39:30.512]  - Finding globals in 'X' for chunk #2 ...
[17:39:30.512] getGlobalsAndPackages() ...
[17:39:30.512] Searching for globals...
[17:39:30.512] 
[17:39:30.513] Searching for globals ... DONE
[17:39:30.513] - globals: [0] <none>
[17:39:30.513] getGlobalsAndPackages() ... DONE
[17:39:30.513]    + additional globals found: [n=0] 
[17:39:30.513]    + additional namespaces needed: [n=0] 
[17:39:30.513]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:30.513]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:30.513]  - seeds: <none>
[17:39:30.513] getGlobalsAndPackages() ...
[17:39:30.513] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.514] Resolving globals: FALSE
[17:39:30.514] Tweak future expression to call with '...' arguments ...
[17:39:30.514] {
[17:39:30.514]     do.call(function(...) {
[17:39:30.514]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.514]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.514]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.514]             on.exit(options(oopts), add = TRUE)
[17:39:30.514]         }
[17:39:30.514]         {
[17:39:30.514]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.514]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.514]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.514]             })
[17:39:30.514]         }
[17:39:30.514]     }, args = future.call.arguments)
[17:39:30.514] }
[17:39:30.514] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.514] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.515] - packages: [1] ‘stats’
[17:39:30.515] getGlobalsAndPackages() ... DONE
[17:39:30.515] run() for ‘Future’ ...
[17:39:30.515] - state: ‘created’
[17:39:30.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.530]   - Field: ‘node’
[17:39:30.531]   - Field: ‘label’
[17:39:30.531]   - Field: ‘local’
[17:39:30.531]   - Field: ‘owner’
[17:39:30.531]   - Field: ‘envir’
[17:39:30.531]   - Field: ‘workers’
[17:39:30.531]   - Field: ‘packages’
[17:39:30.531]   - Field: ‘gc’
[17:39:30.531]   - Field: ‘conditions’
[17:39:30.531]   - Field: ‘persistent’
[17:39:30.531]   - Field: ‘expr’
[17:39:30.532]   - Field: ‘uuid’
[17:39:30.532]   - Field: ‘seed’
[17:39:30.532]   - Field: ‘version’
[17:39:30.532]   - Field: ‘result’
[17:39:30.532]   - Field: ‘asynchronous’
[17:39:30.532]   - Field: ‘calls’
[17:39:30.532]   - Field: ‘globals’
[17:39:30.532]   - Field: ‘stdout’
[17:39:30.532]   - Field: ‘earlySignal’
[17:39:30.532]   - Field: ‘lazy’
[17:39:30.533]   - Field: ‘state’
[17:39:30.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.533] - Launch lazy future ...
[17:39:30.533] Packages needed by the future expression (n = 1): ‘stats’
[17:39:30.533] Packages needed by future strategies (n = 0): <none>
[17:39:30.534] {
[17:39:30.534]     {
[17:39:30.534]         {
[17:39:30.534]             ...future.startTime <- base::Sys.time()
[17:39:30.534]             {
[17:39:30.534]                 {
[17:39:30.534]                   {
[17:39:30.534]                     {
[17:39:30.534]                       {
[17:39:30.534]                         base::local({
[17:39:30.534]                           has_future <- base::requireNamespace("future", 
[17:39:30.534]                             quietly = TRUE)
[17:39:30.534]                           if (has_future) {
[17:39:30.534]                             ns <- base::getNamespace("future")
[17:39:30.534]                             version <- ns[[".package"]][["version"]]
[17:39:30.534]                             if (is.null(version)) 
[17:39:30.534]                               version <- utils::packageVersion("future")
[17:39:30.534]                           }
[17:39:30.534]                           else {
[17:39:30.534]                             version <- NULL
[17:39:30.534]                           }
[17:39:30.534]                           if (!has_future || version < "1.8.0") {
[17:39:30.534]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.534]                               "", base::R.version$version.string), 
[17:39:30.534]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:30.534]                                 base::R.version$platform, 8 * 
[17:39:30.534]                                   base::.Machine$sizeof.pointer), 
[17:39:30.534]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.534]                                 "release", "version")], collapse = " "), 
[17:39:30.534]                               hostname = base::Sys.info()[["nodename"]])
[17:39:30.534]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.534]                               info)
[17:39:30.534]                             info <- base::paste(info, collapse = "; ")
[17:39:30.534]                             if (!has_future) {
[17:39:30.534]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.534]                                 info)
[17:39:30.534]                             }
[17:39:30.534]                             else {
[17:39:30.534]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.534]                                 info, version)
[17:39:30.534]                             }
[17:39:30.534]                             base::stop(msg)
[17:39:30.534]                           }
[17:39:30.534]                         })
[17:39:30.534]                       }
[17:39:30.534]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.534]                       base::options(mc.cores = 1L)
[17:39:30.534]                     }
[17:39:30.534]                     base::local({
[17:39:30.534]                       for (pkg in "stats") {
[17:39:30.534]                         base::loadNamespace(pkg)
[17:39:30.534]                         base::library(pkg, character.only = TRUE)
[17:39:30.534]                       }
[17:39:30.534]                     })
[17:39:30.534]                   }
[17:39:30.534]                   options(future.plan = NULL)
[17:39:30.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.534]                 }
[17:39:30.534]                 ...future.workdir <- getwd()
[17:39:30.534]             }
[17:39:30.534]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.534]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.534]         }
[17:39:30.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.534]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:30.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.534]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.534]             base::names(...future.oldOptions))
[17:39:30.534]     }
[17:39:30.534]     if (FALSE) {
[17:39:30.534]     }
[17:39:30.534]     else {
[17:39:30.534]         if (TRUE) {
[17:39:30.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.534]                 open = "w")
[17:39:30.534]         }
[17:39:30.534]         else {
[17:39:30.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.534]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.534]         }
[17:39:30.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.534]             base::sink(type = "output", split = FALSE)
[17:39:30.534]             base::close(...future.stdout)
[17:39:30.534]         }, add = TRUE)
[17:39:30.534]     }
[17:39:30.534]     ...future.frame <- base::sys.nframe()
[17:39:30.534]     ...future.conditions <- base::list()
[17:39:30.534]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.534]     if (FALSE) {
[17:39:30.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.534]     }
[17:39:30.534]     ...future.result <- base::tryCatch({
[17:39:30.534]         base::withCallingHandlers({
[17:39:30.534]             ...future.value <- base::withVisible(base::local({
[17:39:30.534]                 ...future.makeSendCondition <- local({
[17:39:30.534]                   sendCondition <- NULL
[17:39:30.534]                   function(frame = 1L) {
[17:39:30.534]                     if (is.function(sendCondition)) 
[17:39:30.534]                       return(sendCondition)
[17:39:30.534]                     ns <- getNamespace("parallel")
[17:39:30.534]                     if (exists("sendData", mode = "function", 
[17:39:30.534]                       envir = ns)) {
[17:39:30.534]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.534]                         envir = ns)
[17:39:30.534]                       envir <- sys.frame(frame)
[17:39:30.534]                       master <- NULL
[17:39:30.534]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.534]                         !identical(envir, emptyenv())) {
[17:39:30.534]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.534]                           inherits = FALSE)) {
[17:39:30.534]                           master <- get("master", mode = "list", 
[17:39:30.534]                             envir = envir, inherits = FALSE)
[17:39:30.534]                           if (inherits(master, c("SOCKnode", 
[17:39:30.534]                             "SOCK0node"))) {
[17:39:30.534]                             sendCondition <<- function(cond) {
[17:39:30.534]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.534]                                 success = TRUE)
[17:39:30.534]                               parallel_sendData(master, data)
[17:39:30.534]                             }
[17:39:30.534]                             return(sendCondition)
[17:39:30.534]                           }
[17:39:30.534]                         }
[17:39:30.534]                         frame <- frame + 1L
[17:39:30.534]                         envir <- sys.frame(frame)
[17:39:30.534]                       }
[17:39:30.534]                     }
[17:39:30.534]                     sendCondition <<- function(cond) NULL
[17:39:30.534]                   }
[17:39:30.534]                 })
[17:39:30.534]                 withCallingHandlers({
[17:39:30.534]                   {
[17:39:30.534]                     do.call(function(...) {
[17:39:30.534]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.534]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.534]                         ...future.globals.maxSize)) {
[17:39:30.534]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.534]                         on.exit(options(oopts), add = TRUE)
[17:39:30.534]                       }
[17:39:30.534]                       {
[17:39:30.534]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.534]                           FUN = function(jj) {
[17:39:30.534]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.534]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.534]                           })
[17:39:30.534]                       }
[17:39:30.534]                     }, args = future.call.arguments)
[17:39:30.534]                   }
[17:39:30.534]                 }, immediateCondition = function(cond) {
[17:39:30.534]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.534]                   sendCondition(cond)
[17:39:30.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.534]                   {
[17:39:30.534]                     inherits <- base::inherits
[17:39:30.534]                     invokeRestart <- base::invokeRestart
[17:39:30.534]                     is.null <- base::is.null
[17:39:30.534]                     muffled <- FALSE
[17:39:30.534]                     if (inherits(cond, "message")) {
[17:39:30.534]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.534]                       if (muffled) 
[17:39:30.534]                         invokeRestart("muffleMessage")
[17:39:30.534]                     }
[17:39:30.534]                     else if (inherits(cond, "warning")) {
[17:39:30.534]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.534]                       if (muffled) 
[17:39:30.534]                         invokeRestart("muffleWarning")
[17:39:30.534]                     }
[17:39:30.534]                     else if (inherits(cond, "condition")) {
[17:39:30.534]                       if (!is.null(pattern)) {
[17:39:30.534]                         computeRestarts <- base::computeRestarts
[17:39:30.534]                         grepl <- base::grepl
[17:39:30.534]                         restarts <- computeRestarts(cond)
[17:39:30.534]                         for (restart in restarts) {
[17:39:30.534]                           name <- restart$name
[17:39:30.534]                           if (is.null(name)) 
[17:39:30.534]                             next
[17:39:30.534]                           if (!grepl(pattern, name)) 
[17:39:30.534]                             next
[17:39:30.534]                           invokeRestart(restart)
[17:39:30.534]                           muffled <- TRUE
[17:39:30.534]                           break
[17:39:30.534]                         }
[17:39:30.534]                       }
[17:39:30.534]                     }
[17:39:30.534]                     invisible(muffled)
[17:39:30.534]                   }
[17:39:30.534]                   muffleCondition(cond)
[17:39:30.534]                 })
[17:39:30.534]             }))
[17:39:30.534]             future::FutureResult(value = ...future.value$value, 
[17:39:30.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.534]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.534]                     ...future.globalenv.names))
[17:39:30.534]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.534]         }, condition = base::local({
[17:39:30.534]             c <- base::c
[17:39:30.534]             inherits <- base::inherits
[17:39:30.534]             invokeRestart <- base::invokeRestart
[17:39:30.534]             length <- base::length
[17:39:30.534]             list <- base::list
[17:39:30.534]             seq.int <- base::seq.int
[17:39:30.534]             signalCondition <- base::signalCondition
[17:39:30.534]             sys.calls <- base::sys.calls
[17:39:30.534]             `[[` <- base::`[[`
[17:39:30.534]             `+` <- base::`+`
[17:39:30.534]             `<<-` <- base::`<<-`
[17:39:30.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.534]                   3L)]
[17:39:30.534]             }
[17:39:30.534]             function(cond) {
[17:39:30.534]                 is_error <- inherits(cond, "error")
[17:39:30.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.534]                   NULL)
[17:39:30.534]                 if (is_error) {
[17:39:30.534]                   sessionInformation <- function() {
[17:39:30.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.534]                       search = base::search(), system = base::Sys.info())
[17:39:30.534]                   }
[17:39:30.534]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.534]                     cond$call), session = sessionInformation(), 
[17:39:30.534]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.534]                   signalCondition(cond)
[17:39:30.534]                 }
[17:39:30.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.534]                 "immediateCondition"))) {
[17:39:30.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.534]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.534]                   if (TRUE && !signal) {
[17:39:30.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.534]                     {
[17:39:30.534]                       inherits <- base::inherits
[17:39:30.534]                       invokeRestart <- base::invokeRestart
[17:39:30.534]                       is.null <- base::is.null
[17:39:30.534]                       muffled <- FALSE
[17:39:30.534]                       if (inherits(cond, "message")) {
[17:39:30.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.534]                         if (muffled) 
[17:39:30.534]                           invokeRestart("muffleMessage")
[17:39:30.534]                       }
[17:39:30.534]                       else if (inherits(cond, "warning")) {
[17:39:30.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.534]                         if (muffled) 
[17:39:30.534]                           invokeRestart("muffleWarning")
[17:39:30.534]                       }
[17:39:30.534]                       else if (inherits(cond, "condition")) {
[17:39:30.534]                         if (!is.null(pattern)) {
[17:39:30.534]                           computeRestarts <- base::computeRestarts
[17:39:30.534]                           grepl <- base::grepl
[17:39:30.534]                           restarts <- computeRestarts(cond)
[17:39:30.534]                           for (restart in restarts) {
[17:39:30.534]                             name <- restart$name
[17:39:30.534]                             if (is.null(name)) 
[17:39:30.534]                               next
[17:39:30.534]                             if (!grepl(pattern, name)) 
[17:39:30.534]                               next
[17:39:30.534]                             invokeRestart(restart)
[17:39:30.534]                             muffled <- TRUE
[17:39:30.534]                             break
[17:39:30.534]                           }
[17:39:30.534]                         }
[17:39:30.534]                       }
[17:39:30.534]                       invisible(muffled)
[17:39:30.534]                     }
[17:39:30.534]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.534]                   }
[17:39:30.534]                 }
[17:39:30.534]                 else {
[17:39:30.534]                   if (TRUE) {
[17:39:30.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.534]                     {
[17:39:30.534]                       inherits <- base::inherits
[17:39:30.534]                       invokeRestart <- base::invokeRestart
[17:39:30.534]                       is.null <- base::is.null
[17:39:30.534]                       muffled <- FALSE
[17:39:30.534]                       if (inherits(cond, "message")) {
[17:39:30.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.534]                         if (muffled) 
[17:39:30.534]                           invokeRestart("muffleMessage")
[17:39:30.534]                       }
[17:39:30.534]                       else if (inherits(cond, "warning")) {
[17:39:30.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.534]                         if (muffled) 
[17:39:30.534]                           invokeRestart("muffleWarning")
[17:39:30.534]                       }
[17:39:30.534]                       else if (inherits(cond, "condition")) {
[17:39:30.534]                         if (!is.null(pattern)) {
[17:39:30.534]                           computeRestarts <- base::computeRestarts
[17:39:30.534]                           grepl <- base::grepl
[17:39:30.534]                           restarts <- computeRestarts(cond)
[17:39:30.534]                           for (restart in restarts) {
[17:39:30.534]                             name <- restart$name
[17:39:30.534]                             if (is.null(name)) 
[17:39:30.534]                               next
[17:39:30.534]                             if (!grepl(pattern, name)) 
[17:39:30.534]                               next
[17:39:30.534]                             invokeRestart(restart)
[17:39:30.534]                             muffled <- TRUE
[17:39:30.534]                             break
[17:39:30.534]                           }
[17:39:30.534]                         }
[17:39:30.534]                       }
[17:39:30.534]                       invisible(muffled)
[17:39:30.534]                     }
[17:39:30.534]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.534]                   }
[17:39:30.534]                 }
[17:39:30.534]             }
[17:39:30.534]         }))
[17:39:30.534]     }, error = function(ex) {
[17:39:30.534]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.534]                 ...future.rng), started = ...future.startTime, 
[17:39:30.534]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.534]             version = "1.8"), class = "FutureResult")
[17:39:30.534]     }, finally = {
[17:39:30.534]         if (!identical(...future.workdir, getwd())) 
[17:39:30.534]             setwd(...future.workdir)
[17:39:30.534]         {
[17:39:30.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.534]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.534]             }
[17:39:30.534]             base::options(...future.oldOptions)
[17:39:30.534]             if (.Platform$OS.type == "windows") {
[17:39:30.534]                 old_names <- names(...future.oldEnvVars)
[17:39:30.534]                 envs <- base::Sys.getenv()
[17:39:30.534]                 names <- names(envs)
[17:39:30.534]                 common <- intersect(names, old_names)
[17:39:30.534]                 added <- setdiff(names, old_names)
[17:39:30.534]                 removed <- setdiff(old_names, names)
[17:39:30.534]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.534]                   envs[common]]
[17:39:30.534]                 NAMES <- toupper(changed)
[17:39:30.534]                 args <- list()
[17:39:30.534]                 for (kk in seq_along(NAMES)) {
[17:39:30.534]                   name <- changed[[kk]]
[17:39:30.534]                   NAME <- NAMES[[kk]]
[17:39:30.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.534]                     next
[17:39:30.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.534]                 }
[17:39:30.534]                 NAMES <- toupper(added)
[17:39:30.534]                 for (kk in seq_along(NAMES)) {
[17:39:30.534]                   name <- added[[kk]]
[17:39:30.534]                   NAME <- NAMES[[kk]]
[17:39:30.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.534]                     next
[17:39:30.534]                   args[[name]] <- ""
[17:39:30.534]                 }
[17:39:30.534]                 NAMES <- toupper(removed)
[17:39:30.534]                 for (kk in seq_along(NAMES)) {
[17:39:30.534]                   name <- removed[[kk]]
[17:39:30.534]                   NAME <- NAMES[[kk]]
[17:39:30.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.534]                     next
[17:39:30.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.534]                 }
[17:39:30.534]                 if (length(args) > 0) 
[17:39:30.534]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.534]             }
[17:39:30.534]             else {
[17:39:30.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.534]             }
[17:39:30.534]             {
[17:39:30.534]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.534]                   0L) {
[17:39:30.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.534]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.534]                   base::options(opts)
[17:39:30.534]                 }
[17:39:30.534]                 {
[17:39:30.534]                   {
[17:39:30.534]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.534]                     NULL
[17:39:30.534]                   }
[17:39:30.534]                   options(future.plan = NULL)
[17:39:30.534]                   if (is.na(NA_character_)) 
[17:39:30.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.534]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.534]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.534]                     envir = parent.frame()) 
[17:39:30.534]                   {
[17:39:30.534]                     if (is.function(workers)) 
[17:39:30.534]                       workers <- workers()
[17:39:30.534]                     workers <- structure(as.integer(workers), 
[17:39:30.534]                       class = class(workers))
[17:39:30.534]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.534]                       workers >= 1)
[17:39:30.534]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.534]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.534]                     }
[17:39:30.534]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.534]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.534]                       envir = envir)
[17:39:30.534]                     if (!future$lazy) 
[17:39:30.534]                       future <- run(future)
[17:39:30.534]                     invisible(future)
[17:39:30.534]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.534]                 }
[17:39:30.534]             }
[17:39:30.534]         }
[17:39:30.534]     })
[17:39:30.534]     if (TRUE) {
[17:39:30.534]         base::sink(type = "output", split = FALSE)
[17:39:30.534]         if (TRUE) {
[17:39:30.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.534]         }
[17:39:30.534]         else {
[17:39:30.534]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.534]         }
[17:39:30.534]         base::close(...future.stdout)
[17:39:30.534]         ...future.stdout <- NULL
[17:39:30.534]     }
[17:39:30.534]     ...future.result$conditions <- ...future.conditions
[17:39:30.534]     ...future.result$finished <- base::Sys.time()
[17:39:30.534]     ...future.result
[17:39:30.534] }
[17:39:30.537] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:39:30.537] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:39:30.537] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:39:30.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:30.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.538] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:39:30.538] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:39:30.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:30.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:30.540] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.540] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:39:30.540] MultisessionFuture started
[17:39:30.540] - Launch lazy future ... done
[17:39:30.541] run() for ‘MultisessionFuture’ ... done
[17:39:30.541] Created future:
[17:39:30.541] MultisessionFuture:
[17:39:30.541] Label: ‘future_eapply-2’
[17:39:30.541] Expression:
[17:39:30.541] {
[17:39:30.541]     do.call(function(...) {
[17:39:30.541]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.541]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.541]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.541]             on.exit(options(oopts), add = TRUE)
[17:39:30.541]         }
[17:39:30.541]         {
[17:39:30.541]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.541]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.541]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.541]             })
[17:39:30.541]         }
[17:39:30.541]     }, args = future.call.arguments)
[17:39:30.541] }
[17:39:30.541] Lazy evaluation: FALSE
[17:39:30.541] Asynchronous evaluation: TRUE
[17:39:30.541] Local evaluation: TRUE
[17:39:30.541] Environment: R_GlobalEnv
[17:39:30.541] Capture standard output: TRUE
[17:39:30.541] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.541] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.541] Packages: 1 packages (‘stats’)
[17:39:30.541] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.541] Resolved: FALSE
[17:39:30.541] Value: <not collected>
[17:39:30.541] Conditions captured: <none>
[17:39:30.541] Early signaling: FALSE
[17:39:30.541] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.541] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.552] Chunk #2 of 2 ... DONE
[17:39:30.553] Launching 2 futures (chunks) ... DONE
[17:39:30.553] Resolving 2 futures (chunks) ...
[17:39:30.553] resolve() on list ...
[17:39:30.553]  recursive: 0
[17:39:30.553]  length: 2
[17:39:30.553] 
[17:39:30.554] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.554] - Validating connection of MultisessionFuture
[17:39:30.554] - received message: FutureResult
[17:39:30.554] - Received FutureResult
[17:39:30.554] - Erased future from FutureRegistry
[17:39:30.554] result() for ClusterFuture ...
[17:39:30.554] - result already collected: FutureResult
[17:39:30.554] result() for ClusterFuture ... done
[17:39:30.554] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.555] Future #1
[17:39:30.555] result() for ClusterFuture ...
[17:39:30.555] - result already collected: FutureResult
[17:39:30.555] result() for ClusterFuture ... done
[17:39:30.555] result() for ClusterFuture ...
[17:39:30.555] - result already collected: FutureResult
[17:39:30.555] result() for ClusterFuture ... done
[17:39:30.555] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:30.555] - nx: 2
[17:39:30.555] - relay: TRUE
[17:39:30.556] - stdout: TRUE
[17:39:30.556] - signal: TRUE
[17:39:30.556] - resignal: FALSE
[17:39:30.556] - force: TRUE
[17:39:30.556] - relayed: [n=2] FALSE, FALSE
[17:39:30.556] - queued futures: [n=2] FALSE, FALSE
[17:39:30.556]  - until=1
[17:39:30.556]  - relaying element #1
[17:39:30.556] result() for ClusterFuture ...
[17:39:30.556] - result already collected: FutureResult
[17:39:30.556] result() for ClusterFuture ... done
[17:39:30.556] result() for ClusterFuture ...
[17:39:30.557] - result already collected: FutureResult
[17:39:30.557] result() for ClusterFuture ... done
[17:39:30.557] result() for ClusterFuture ...
[17:39:30.557] - result already collected: FutureResult
[17:39:30.557] result() for ClusterFuture ... done
[17:39:30.557] result() for ClusterFuture ...
[17:39:30.557] - result already collected: FutureResult
[17:39:30.557] result() for ClusterFuture ... done
[17:39:30.557] - relayed: [n=2] TRUE, FALSE
[17:39:30.557] - queued futures: [n=2] TRUE, FALSE
[17:39:30.557] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:30.558]  length: 1 (resolved future 1)
[17:39:30.600] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.600] - Validating connection of MultisessionFuture
[17:39:30.600] - received message: FutureResult
[17:39:30.600] - Received FutureResult
[17:39:30.600] - Erased future from FutureRegistry
[17:39:30.601] result() for ClusterFuture ...
[17:39:30.601] - result already collected: FutureResult
[17:39:30.601] result() for ClusterFuture ... done
[17:39:30.601] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.601] Future #2
[17:39:30.601] result() for ClusterFuture ...
[17:39:30.601] - result already collected: FutureResult
[17:39:30.601] result() for ClusterFuture ... done
[17:39:30.601] result() for ClusterFuture ...
[17:39:30.601] - result already collected: FutureResult
[17:39:30.601] result() for ClusterFuture ... done
[17:39:30.602] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:30.602] - nx: 2
[17:39:30.602] - relay: TRUE
[17:39:30.602] - stdout: TRUE
[17:39:30.602] - signal: TRUE
[17:39:30.602] - resignal: FALSE
[17:39:30.602] - force: TRUE
[17:39:30.602] - relayed: [n=2] TRUE, FALSE
[17:39:30.602] - queued futures: [n=2] TRUE, FALSE
[17:39:30.602]  - until=2
[17:39:30.602]  - relaying element #2
[17:39:30.603] result() for ClusterFuture ...
[17:39:30.603] - result already collected: FutureResult
[17:39:30.603] result() for ClusterFuture ... done
[17:39:30.603] result() for ClusterFuture ...
[17:39:30.603] - result already collected: FutureResult
[17:39:30.603] result() for ClusterFuture ... done
[17:39:30.603] result() for ClusterFuture ...
[17:39:30.603] - result already collected: FutureResult
[17:39:30.603] result() for ClusterFuture ... done
[17:39:30.603] result() for ClusterFuture ...
[17:39:30.604] - result already collected: FutureResult
[17:39:30.604] result() for ClusterFuture ... done
[17:39:30.604] - relayed: [n=2] TRUE, TRUE
[17:39:30.604] - queued futures: [n=2] TRUE, TRUE
[17:39:30.604] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:30.604]  length: 0 (resolved future 2)
[17:39:30.604] Relaying remaining futures
[17:39:30.604] signalConditionsASAP(NULL, pos=0) ...
[17:39:30.604] - nx: 2
[17:39:30.604] - relay: TRUE
[17:39:30.604] - stdout: TRUE
[17:39:30.604] - signal: TRUE
[17:39:30.605] - resignal: FALSE
[17:39:30.605] - force: TRUE
[17:39:30.605] - relayed: [n=2] TRUE, TRUE
[17:39:30.605] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:30.605] - relayed: [n=2] TRUE, TRUE
[17:39:30.605] - queued futures: [n=2] TRUE, TRUE
[17:39:30.605] signalConditionsASAP(NULL, pos=0) ... done
[17:39:30.605] resolve() on list ... DONE
[17:39:30.605] result() for ClusterFuture ...
[17:39:30.605] - result already collected: FutureResult
[17:39:30.605] result() for ClusterFuture ... done
[17:39:30.606] result() for ClusterFuture ...
[17:39:30.606] - result already collected: FutureResult
[17:39:30.606] result() for ClusterFuture ... done
[17:39:30.606] result() for ClusterFuture ...
[17:39:30.606] - result already collected: FutureResult
[17:39:30.606] result() for ClusterFuture ... done
[17:39:30.606] result() for ClusterFuture ...
[17:39:30.606] - result already collected: FutureResult
[17:39:30.606] result() for ClusterFuture ... done
[17:39:30.606]  - Number of value chunks collected: 2
[17:39:30.607] Resolving 2 futures (chunks) ... DONE
[17:39:30.607] Reducing values from 2 chunks ...
[17:39:30.607]  - Number of values collected after concatenation: 3
[17:39:30.607]  - Number of values expected: 3
[17:39:30.607] Reducing values from 2 chunks ... DONE
[17:39:30.607] future_lapply() ... DONE
[17:39:30.607] future_lapply() ...
[17:39:30.612] Number of chunks: 2
[17:39:30.612] getGlobalsAndPackagesXApply() ...
[17:39:30.612]  - future.globals: TRUE
[17:39:30.612] getGlobalsAndPackages() ...
[17:39:30.612] Searching for globals...
[17:39:30.613] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:30.613] Searching for globals ... DONE
[17:39:30.613] Resolving globals: FALSE
[17:39:30.614] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:30.614] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:30.614] - globals: [1] ‘FUN’
[17:39:30.614] - packages: [1] ‘stats’
[17:39:30.615] getGlobalsAndPackages() ... DONE
[17:39:30.615]  - globals found/used: [n=1] ‘FUN’
[17:39:30.615]  - needed namespaces: [n=1] ‘stats’
[17:39:30.615] Finding globals ... DONE
[17:39:30.615]  - use_args: TRUE
[17:39:30.615]  - Getting '...' globals ...
[17:39:30.615] resolve() on list ...
[17:39:30.615]  recursive: 0
[17:39:30.616]  length: 1
[17:39:30.616]  elements: ‘...’
[17:39:30.616]  length: 0 (resolved future 1)
[17:39:30.616] resolve() on list ... DONE
[17:39:30.616]    - '...' content: [n=0] 
[17:39:30.616] List of 1
[17:39:30.616]  $ ...: list()
[17:39:30.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.616]  - attr(*, "where")=List of 1
[17:39:30.616]   ..$ ...:<environment: 0x555b66d4c420> 
[17:39:30.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.616]  - attr(*, "resolved")= logi TRUE
[17:39:30.616]  - attr(*, "total_size")= num NA
[17:39:30.619]  - Getting '...' globals ... DONE
[17:39:30.619] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:30.619] List of 2
[17:39:30.619]  $ ...future.FUN:function (x, ...)  
[17:39:30.619]  $ ...          : list()
[17:39:30.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:30.619]  - attr(*, "where")=List of 2
[17:39:30.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:30.619]   ..$ ...          :<environment: 0x555b66d4c420> 
[17:39:30.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:30.619]  - attr(*, "resolved")= logi FALSE
[17:39:30.619]  - attr(*, "total_size")= num 1248
[17:39:30.622] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:30.622] getGlobalsAndPackagesXApply() ... DONE
[17:39:30.622] Number of futures (= number of chunks): 2
[17:39:30.622] Launching 2 futures (chunks) ...
[17:39:30.622] Chunk #1 of 2 ...
[17:39:30.622]  - Finding globals in 'X' for chunk #1 ...
[17:39:30.622] getGlobalsAndPackages() ...
[17:39:30.623] Searching for globals...
[17:39:30.623] 
[17:39:30.623] Searching for globals ... DONE
[17:39:30.623] - globals: [0] <none>
[17:39:30.623] getGlobalsAndPackages() ... DONE
[17:39:30.623]    + additional globals found: [n=0] 
[17:39:30.623]    + additional namespaces needed: [n=0] 
[17:39:30.623]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:30.623]  - seeds: <none>
[17:39:30.624] getGlobalsAndPackages() ...
[17:39:30.624] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.624] Resolving globals: FALSE
[17:39:30.624] Tweak future expression to call with '...' arguments ...
[17:39:30.624] {
[17:39:30.624]     do.call(function(...) {
[17:39:30.624]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.624]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.624]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.624]             on.exit(options(oopts), add = TRUE)
[17:39:30.624]         }
[17:39:30.624]         {
[17:39:30.624]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.624]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.624]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.624]             })
[17:39:30.624]         }
[17:39:30.624]     }, args = future.call.arguments)
[17:39:30.624] }
[17:39:30.624] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.625] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.625] - packages: [1] ‘stats’
[17:39:30.625] getGlobalsAndPackages() ... DONE
[17:39:30.625] run() for ‘Future’ ...
[17:39:30.625] - state: ‘created’
[17:39:30.625] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.640]   - Field: ‘node’
[17:39:30.640]   - Field: ‘label’
[17:39:30.640]   - Field: ‘local’
[17:39:30.640]   - Field: ‘owner’
[17:39:30.640]   - Field: ‘envir’
[17:39:30.641]   - Field: ‘workers’
[17:39:30.641]   - Field: ‘packages’
[17:39:30.641]   - Field: ‘gc’
[17:39:30.641]   - Field: ‘conditions’
[17:39:30.641]   - Field: ‘persistent’
[17:39:30.641]   - Field: ‘expr’
[17:39:30.641]   - Field: ‘uuid’
[17:39:30.641]   - Field: ‘seed’
[17:39:30.641]   - Field: ‘version’
[17:39:30.641]   - Field: ‘result’
[17:39:30.642]   - Field: ‘asynchronous’
[17:39:30.642]   - Field: ‘calls’
[17:39:30.642]   - Field: ‘globals’
[17:39:30.642]   - Field: ‘stdout’
[17:39:30.642]   - Field: ‘earlySignal’
[17:39:30.642]   - Field: ‘lazy’
[17:39:30.642]   - Field: ‘state’
[17:39:30.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.642] - Launch lazy future ...
[17:39:30.643] Packages needed by the future expression (n = 1): ‘stats’
[17:39:30.643] Packages needed by future strategies (n = 0): <none>
[17:39:30.643] {
[17:39:30.643]     {
[17:39:30.643]         {
[17:39:30.643]             ...future.startTime <- base::Sys.time()
[17:39:30.643]             {
[17:39:30.643]                 {
[17:39:30.643]                   {
[17:39:30.643]                     {
[17:39:30.643]                       {
[17:39:30.643]                         base::local({
[17:39:30.643]                           has_future <- base::requireNamespace("future", 
[17:39:30.643]                             quietly = TRUE)
[17:39:30.643]                           if (has_future) {
[17:39:30.643]                             ns <- base::getNamespace("future")
[17:39:30.643]                             version <- ns[[".package"]][["version"]]
[17:39:30.643]                             if (is.null(version)) 
[17:39:30.643]                               version <- utils::packageVersion("future")
[17:39:30.643]                           }
[17:39:30.643]                           else {
[17:39:30.643]                             version <- NULL
[17:39:30.643]                           }
[17:39:30.643]                           if (!has_future || version < "1.8.0") {
[17:39:30.643]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.643]                               "", base::R.version$version.string), 
[17:39:30.643]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:30.643]                                 base::R.version$platform, 8 * 
[17:39:30.643]                                   base::.Machine$sizeof.pointer), 
[17:39:30.643]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.643]                                 "release", "version")], collapse = " "), 
[17:39:30.643]                               hostname = base::Sys.info()[["nodename"]])
[17:39:30.643]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.643]                               info)
[17:39:30.643]                             info <- base::paste(info, collapse = "; ")
[17:39:30.643]                             if (!has_future) {
[17:39:30.643]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.643]                                 info)
[17:39:30.643]                             }
[17:39:30.643]                             else {
[17:39:30.643]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.643]                                 info, version)
[17:39:30.643]                             }
[17:39:30.643]                             base::stop(msg)
[17:39:30.643]                           }
[17:39:30.643]                         })
[17:39:30.643]                       }
[17:39:30.643]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.643]                       base::options(mc.cores = 1L)
[17:39:30.643]                     }
[17:39:30.643]                     base::local({
[17:39:30.643]                       for (pkg in "stats") {
[17:39:30.643]                         base::loadNamespace(pkg)
[17:39:30.643]                         base::library(pkg, character.only = TRUE)
[17:39:30.643]                       }
[17:39:30.643]                     })
[17:39:30.643]                   }
[17:39:30.643]                   options(future.plan = NULL)
[17:39:30.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.643]                 }
[17:39:30.643]                 ...future.workdir <- getwd()
[17:39:30.643]             }
[17:39:30.643]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.643]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.643]         }
[17:39:30.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:30.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.643]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.643]             base::names(...future.oldOptions))
[17:39:30.643]     }
[17:39:30.643]     if (FALSE) {
[17:39:30.643]     }
[17:39:30.643]     else {
[17:39:30.643]         if (TRUE) {
[17:39:30.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.643]                 open = "w")
[17:39:30.643]         }
[17:39:30.643]         else {
[17:39:30.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.643]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.643]         }
[17:39:30.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.643]             base::sink(type = "output", split = FALSE)
[17:39:30.643]             base::close(...future.stdout)
[17:39:30.643]         }, add = TRUE)
[17:39:30.643]     }
[17:39:30.643]     ...future.frame <- base::sys.nframe()
[17:39:30.643]     ...future.conditions <- base::list()
[17:39:30.643]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.643]     if (FALSE) {
[17:39:30.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.643]     }
[17:39:30.643]     ...future.result <- base::tryCatch({
[17:39:30.643]         base::withCallingHandlers({
[17:39:30.643]             ...future.value <- base::withVisible(base::local({
[17:39:30.643]                 ...future.makeSendCondition <- local({
[17:39:30.643]                   sendCondition <- NULL
[17:39:30.643]                   function(frame = 1L) {
[17:39:30.643]                     if (is.function(sendCondition)) 
[17:39:30.643]                       return(sendCondition)
[17:39:30.643]                     ns <- getNamespace("parallel")
[17:39:30.643]                     if (exists("sendData", mode = "function", 
[17:39:30.643]                       envir = ns)) {
[17:39:30.643]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.643]                         envir = ns)
[17:39:30.643]                       envir <- sys.frame(frame)
[17:39:30.643]                       master <- NULL
[17:39:30.643]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.643]                         !identical(envir, emptyenv())) {
[17:39:30.643]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.643]                           inherits = FALSE)) {
[17:39:30.643]                           master <- get("master", mode = "list", 
[17:39:30.643]                             envir = envir, inherits = FALSE)
[17:39:30.643]                           if (inherits(master, c("SOCKnode", 
[17:39:30.643]                             "SOCK0node"))) {
[17:39:30.643]                             sendCondition <<- function(cond) {
[17:39:30.643]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.643]                                 success = TRUE)
[17:39:30.643]                               parallel_sendData(master, data)
[17:39:30.643]                             }
[17:39:30.643]                             return(sendCondition)
[17:39:30.643]                           }
[17:39:30.643]                         }
[17:39:30.643]                         frame <- frame + 1L
[17:39:30.643]                         envir <- sys.frame(frame)
[17:39:30.643]                       }
[17:39:30.643]                     }
[17:39:30.643]                     sendCondition <<- function(cond) NULL
[17:39:30.643]                   }
[17:39:30.643]                 })
[17:39:30.643]                 withCallingHandlers({
[17:39:30.643]                   {
[17:39:30.643]                     do.call(function(...) {
[17:39:30.643]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.643]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.643]                         ...future.globals.maxSize)) {
[17:39:30.643]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.643]                         on.exit(options(oopts), add = TRUE)
[17:39:30.643]                       }
[17:39:30.643]                       {
[17:39:30.643]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.643]                           FUN = function(jj) {
[17:39:30.643]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.643]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.643]                           })
[17:39:30.643]                       }
[17:39:30.643]                     }, args = future.call.arguments)
[17:39:30.643]                   }
[17:39:30.643]                 }, immediateCondition = function(cond) {
[17:39:30.643]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.643]                   sendCondition(cond)
[17:39:30.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.643]                   {
[17:39:30.643]                     inherits <- base::inherits
[17:39:30.643]                     invokeRestart <- base::invokeRestart
[17:39:30.643]                     is.null <- base::is.null
[17:39:30.643]                     muffled <- FALSE
[17:39:30.643]                     if (inherits(cond, "message")) {
[17:39:30.643]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.643]                       if (muffled) 
[17:39:30.643]                         invokeRestart("muffleMessage")
[17:39:30.643]                     }
[17:39:30.643]                     else if (inherits(cond, "warning")) {
[17:39:30.643]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.643]                       if (muffled) 
[17:39:30.643]                         invokeRestart("muffleWarning")
[17:39:30.643]                     }
[17:39:30.643]                     else if (inherits(cond, "condition")) {
[17:39:30.643]                       if (!is.null(pattern)) {
[17:39:30.643]                         computeRestarts <- base::computeRestarts
[17:39:30.643]                         grepl <- base::grepl
[17:39:30.643]                         restarts <- computeRestarts(cond)
[17:39:30.643]                         for (restart in restarts) {
[17:39:30.643]                           name <- restart$name
[17:39:30.643]                           if (is.null(name)) 
[17:39:30.643]                             next
[17:39:30.643]                           if (!grepl(pattern, name)) 
[17:39:30.643]                             next
[17:39:30.643]                           invokeRestart(restart)
[17:39:30.643]                           muffled <- TRUE
[17:39:30.643]                           break
[17:39:30.643]                         }
[17:39:30.643]                       }
[17:39:30.643]                     }
[17:39:30.643]                     invisible(muffled)
[17:39:30.643]                   }
[17:39:30.643]                   muffleCondition(cond)
[17:39:30.643]                 })
[17:39:30.643]             }))
[17:39:30.643]             future::FutureResult(value = ...future.value$value, 
[17:39:30.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.643]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.643]                     ...future.globalenv.names))
[17:39:30.643]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.643]         }, condition = base::local({
[17:39:30.643]             c <- base::c
[17:39:30.643]             inherits <- base::inherits
[17:39:30.643]             invokeRestart <- base::invokeRestart
[17:39:30.643]             length <- base::length
[17:39:30.643]             list <- base::list
[17:39:30.643]             seq.int <- base::seq.int
[17:39:30.643]             signalCondition <- base::signalCondition
[17:39:30.643]             sys.calls <- base::sys.calls
[17:39:30.643]             `[[` <- base::`[[`
[17:39:30.643]             `+` <- base::`+`
[17:39:30.643]             `<<-` <- base::`<<-`
[17:39:30.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.643]                   3L)]
[17:39:30.643]             }
[17:39:30.643]             function(cond) {
[17:39:30.643]                 is_error <- inherits(cond, "error")
[17:39:30.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.643]                   NULL)
[17:39:30.643]                 if (is_error) {
[17:39:30.643]                   sessionInformation <- function() {
[17:39:30.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.643]                       search = base::search(), system = base::Sys.info())
[17:39:30.643]                   }
[17:39:30.643]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.643]                     cond$call), session = sessionInformation(), 
[17:39:30.643]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.643]                   signalCondition(cond)
[17:39:30.643]                 }
[17:39:30.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.643]                 "immediateCondition"))) {
[17:39:30.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.643]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.643]                   if (TRUE && !signal) {
[17:39:30.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.643]                     {
[17:39:30.643]                       inherits <- base::inherits
[17:39:30.643]                       invokeRestart <- base::invokeRestart
[17:39:30.643]                       is.null <- base::is.null
[17:39:30.643]                       muffled <- FALSE
[17:39:30.643]                       if (inherits(cond, "message")) {
[17:39:30.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.643]                         if (muffled) 
[17:39:30.643]                           invokeRestart("muffleMessage")
[17:39:30.643]                       }
[17:39:30.643]                       else if (inherits(cond, "warning")) {
[17:39:30.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.643]                         if (muffled) 
[17:39:30.643]                           invokeRestart("muffleWarning")
[17:39:30.643]                       }
[17:39:30.643]                       else if (inherits(cond, "condition")) {
[17:39:30.643]                         if (!is.null(pattern)) {
[17:39:30.643]                           computeRestarts <- base::computeRestarts
[17:39:30.643]                           grepl <- base::grepl
[17:39:30.643]                           restarts <- computeRestarts(cond)
[17:39:30.643]                           for (restart in restarts) {
[17:39:30.643]                             name <- restart$name
[17:39:30.643]                             if (is.null(name)) 
[17:39:30.643]                               next
[17:39:30.643]                             if (!grepl(pattern, name)) 
[17:39:30.643]                               next
[17:39:30.643]                             invokeRestart(restart)
[17:39:30.643]                             muffled <- TRUE
[17:39:30.643]                             break
[17:39:30.643]                           }
[17:39:30.643]                         }
[17:39:30.643]                       }
[17:39:30.643]                       invisible(muffled)
[17:39:30.643]                     }
[17:39:30.643]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.643]                   }
[17:39:30.643]                 }
[17:39:30.643]                 else {
[17:39:30.643]                   if (TRUE) {
[17:39:30.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.643]                     {
[17:39:30.643]                       inherits <- base::inherits
[17:39:30.643]                       invokeRestart <- base::invokeRestart
[17:39:30.643]                       is.null <- base::is.null
[17:39:30.643]                       muffled <- FALSE
[17:39:30.643]                       if (inherits(cond, "message")) {
[17:39:30.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.643]                         if (muffled) 
[17:39:30.643]                           invokeRestart("muffleMessage")
[17:39:30.643]                       }
[17:39:30.643]                       else if (inherits(cond, "warning")) {
[17:39:30.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.643]                         if (muffled) 
[17:39:30.643]                           invokeRestart("muffleWarning")
[17:39:30.643]                       }
[17:39:30.643]                       else if (inherits(cond, "condition")) {
[17:39:30.643]                         if (!is.null(pattern)) {
[17:39:30.643]                           computeRestarts <- base::computeRestarts
[17:39:30.643]                           grepl <- base::grepl
[17:39:30.643]                           restarts <- computeRestarts(cond)
[17:39:30.643]                           for (restart in restarts) {
[17:39:30.643]                             name <- restart$name
[17:39:30.643]                             if (is.null(name)) 
[17:39:30.643]                               next
[17:39:30.643]                             if (!grepl(pattern, name)) 
[17:39:30.643]                               next
[17:39:30.643]                             invokeRestart(restart)
[17:39:30.643]                             muffled <- TRUE
[17:39:30.643]                             break
[17:39:30.643]                           }
[17:39:30.643]                         }
[17:39:30.643]                       }
[17:39:30.643]                       invisible(muffled)
[17:39:30.643]                     }
[17:39:30.643]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.643]                   }
[17:39:30.643]                 }
[17:39:30.643]             }
[17:39:30.643]         }))
[17:39:30.643]     }, error = function(ex) {
[17:39:30.643]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.643]                 ...future.rng), started = ...future.startTime, 
[17:39:30.643]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.643]             version = "1.8"), class = "FutureResult")
[17:39:30.643]     }, finally = {
[17:39:30.643]         if (!identical(...future.workdir, getwd())) 
[17:39:30.643]             setwd(...future.workdir)
[17:39:30.643]         {
[17:39:30.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.643]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.643]             }
[17:39:30.643]             base::options(...future.oldOptions)
[17:39:30.643]             if (.Platform$OS.type == "windows") {
[17:39:30.643]                 old_names <- names(...future.oldEnvVars)
[17:39:30.643]                 envs <- base::Sys.getenv()
[17:39:30.643]                 names <- names(envs)
[17:39:30.643]                 common <- intersect(names, old_names)
[17:39:30.643]                 added <- setdiff(names, old_names)
[17:39:30.643]                 removed <- setdiff(old_names, names)
[17:39:30.643]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.643]                   envs[common]]
[17:39:30.643]                 NAMES <- toupper(changed)
[17:39:30.643]                 args <- list()
[17:39:30.643]                 for (kk in seq_along(NAMES)) {
[17:39:30.643]                   name <- changed[[kk]]
[17:39:30.643]                   NAME <- NAMES[[kk]]
[17:39:30.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.643]                     next
[17:39:30.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.643]                 }
[17:39:30.643]                 NAMES <- toupper(added)
[17:39:30.643]                 for (kk in seq_along(NAMES)) {
[17:39:30.643]                   name <- added[[kk]]
[17:39:30.643]                   NAME <- NAMES[[kk]]
[17:39:30.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.643]                     next
[17:39:30.643]                   args[[name]] <- ""
[17:39:30.643]                 }
[17:39:30.643]                 NAMES <- toupper(removed)
[17:39:30.643]                 for (kk in seq_along(NAMES)) {
[17:39:30.643]                   name <- removed[[kk]]
[17:39:30.643]                   NAME <- NAMES[[kk]]
[17:39:30.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.643]                     next
[17:39:30.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.643]                 }
[17:39:30.643]                 if (length(args) > 0) 
[17:39:30.643]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.643]             }
[17:39:30.643]             else {
[17:39:30.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.643]             }
[17:39:30.643]             {
[17:39:30.643]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.643]                   0L) {
[17:39:30.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.643]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.643]                   base::options(opts)
[17:39:30.643]                 }
[17:39:30.643]                 {
[17:39:30.643]                   {
[17:39:30.643]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.643]                     NULL
[17:39:30.643]                   }
[17:39:30.643]                   options(future.plan = NULL)
[17:39:30.643]                   if (is.na(NA_character_)) 
[17:39:30.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.643]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.643]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.643]                     envir = parent.frame()) 
[17:39:30.643]                   {
[17:39:30.643]                     if (is.function(workers)) 
[17:39:30.643]                       workers <- workers()
[17:39:30.643]                     workers <- structure(as.integer(workers), 
[17:39:30.643]                       class = class(workers))
[17:39:30.643]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.643]                       workers >= 1)
[17:39:30.643]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.643]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.643]                     }
[17:39:30.643]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.643]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.643]                       envir = envir)
[17:39:30.643]                     if (!future$lazy) 
[17:39:30.643]                       future <- run(future)
[17:39:30.643]                     invisible(future)
[17:39:30.643]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.643]                 }
[17:39:30.643]             }
[17:39:30.643]         }
[17:39:30.643]     })
[17:39:30.643]     if (TRUE) {
[17:39:30.643]         base::sink(type = "output", split = FALSE)
[17:39:30.643]         if (TRUE) {
[17:39:30.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.643]         }
[17:39:30.643]         else {
[17:39:30.643]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.643]         }
[17:39:30.643]         base::close(...future.stdout)
[17:39:30.643]         ...future.stdout <- NULL
[17:39:30.643]     }
[17:39:30.643]     ...future.result$conditions <- ...future.conditions
[17:39:30.643]     ...future.result$finished <- base::Sys.time()
[17:39:30.643]     ...future.result
[17:39:30.643] }
[17:39:30.646] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:39:30.646] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:39:30.647] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:39:30.647] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:30.647] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.647] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:39:30.648] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:39:30.648] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:30.648] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.648] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:30.649] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:30.649] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:39:30.649] MultisessionFuture started
[17:39:30.649] - Launch lazy future ... done
[17:39:30.649] run() for ‘MultisessionFuture’ ... done
[17:39:30.649] Created future:
[17:39:30.650] MultisessionFuture:
[17:39:30.650] Label: ‘future_eapply-1’
[17:39:30.650] Expression:
[17:39:30.650] {
[17:39:30.650]     do.call(function(...) {
[17:39:30.650]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.650]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.650]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.650]             on.exit(options(oopts), add = TRUE)
[17:39:30.650]         }
[17:39:30.650]         {
[17:39:30.650]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.650]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.650]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.650]             })
[17:39:30.650]         }
[17:39:30.650]     }, args = future.call.arguments)
[17:39:30.650] }
[17:39:30.650] Lazy evaluation: FALSE
[17:39:30.650] Asynchronous evaluation: TRUE
[17:39:30.650] Local evaluation: TRUE
[17:39:30.650] Environment: R_GlobalEnv
[17:39:30.650] Capture standard output: TRUE
[17:39:30.650] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.650] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.650] Packages: 1 packages (‘stats’)
[17:39:30.650] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.650] Resolved: FALSE
[17:39:30.650] Value: <not collected>
[17:39:30.650] Conditions captured: <none>
[17:39:30.650] Early signaling: FALSE
[17:39:30.650] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.650] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.661] Chunk #1 of 2 ... DONE
[17:39:30.661] Chunk #2 of 2 ...
[17:39:30.661]  - Finding globals in 'X' for chunk #2 ...
[17:39:30.662] getGlobalsAndPackages() ...
[17:39:30.662] Searching for globals...
[17:39:30.662] 
[17:39:30.662] Searching for globals ... DONE
[17:39:30.662] - globals: [0] <none>
[17:39:30.662] getGlobalsAndPackages() ... DONE
[17:39:30.662]    + additional globals found: [n=0] 
[17:39:30.662]    + additional namespaces needed: [n=0] 
[17:39:30.662]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:30.663]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:30.663]  - seeds: <none>
[17:39:30.663] getGlobalsAndPackages() ...
[17:39:30.663] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.663] Resolving globals: FALSE
[17:39:30.663] Tweak future expression to call with '...' arguments ...
[17:39:30.663] {
[17:39:30.663]     do.call(function(...) {
[17:39:30.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.663]             on.exit(options(oopts), add = TRUE)
[17:39:30.663]         }
[17:39:30.663]         {
[17:39:30.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.663]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.663]             })
[17:39:30.663]         }
[17:39:30.663]     }, args = future.call.arguments)
[17:39:30.663] }
[17:39:30.664] Tweak future expression to call with '...' arguments ... DONE
[17:39:30.664] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:30.664] - packages: [1] ‘stats’
[17:39:30.664] getGlobalsAndPackages() ... DONE
[17:39:30.664] run() for ‘Future’ ...
[17:39:30.665] - state: ‘created’
[17:39:30.665] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:30.682] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:30.682]   - Field: ‘node’
[17:39:30.682]   - Field: ‘label’
[17:39:30.682]   - Field: ‘local’
[17:39:30.682]   - Field: ‘owner’
[17:39:30.682]   - Field: ‘envir’
[17:39:30.682]   - Field: ‘workers’
[17:39:30.682]   - Field: ‘packages’
[17:39:30.683]   - Field: ‘gc’
[17:39:30.683]   - Field: ‘conditions’
[17:39:30.683]   - Field: ‘persistent’
[17:39:30.683]   - Field: ‘expr’
[17:39:30.683]   - Field: ‘uuid’
[17:39:30.683]   - Field: ‘seed’
[17:39:30.683]   - Field: ‘version’
[17:39:30.683]   - Field: ‘result’
[17:39:30.683]   - Field: ‘asynchronous’
[17:39:30.683]   - Field: ‘calls’
[17:39:30.684]   - Field: ‘globals’
[17:39:30.684]   - Field: ‘stdout’
[17:39:30.684]   - Field: ‘earlySignal’
[17:39:30.684]   - Field: ‘lazy’
[17:39:30.684]   - Field: ‘state’
[17:39:30.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:30.684] - Launch lazy future ...
[17:39:30.684] Packages needed by the future expression (n = 1): ‘stats’
[17:39:30.685] Packages needed by future strategies (n = 0): <none>
[17:39:30.685] {
[17:39:30.685]     {
[17:39:30.685]         {
[17:39:30.685]             ...future.startTime <- base::Sys.time()
[17:39:30.685]             {
[17:39:30.685]                 {
[17:39:30.685]                   {
[17:39:30.685]                     {
[17:39:30.685]                       {
[17:39:30.685]                         base::local({
[17:39:30.685]                           has_future <- base::requireNamespace("future", 
[17:39:30.685]                             quietly = TRUE)
[17:39:30.685]                           if (has_future) {
[17:39:30.685]                             ns <- base::getNamespace("future")
[17:39:30.685]                             version <- ns[[".package"]][["version"]]
[17:39:30.685]                             if (is.null(version)) 
[17:39:30.685]                               version <- utils::packageVersion("future")
[17:39:30.685]                           }
[17:39:30.685]                           else {
[17:39:30.685]                             version <- NULL
[17:39:30.685]                           }
[17:39:30.685]                           if (!has_future || version < "1.8.0") {
[17:39:30.685]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:30.685]                               "", base::R.version$version.string), 
[17:39:30.685]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:30.685]                                 base::R.version$platform, 8 * 
[17:39:30.685]                                   base::.Machine$sizeof.pointer), 
[17:39:30.685]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:30.685]                                 "release", "version")], collapse = " "), 
[17:39:30.685]                               hostname = base::Sys.info()[["nodename"]])
[17:39:30.685]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:30.685]                               info)
[17:39:30.685]                             info <- base::paste(info, collapse = "; ")
[17:39:30.685]                             if (!has_future) {
[17:39:30.685]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:30.685]                                 info)
[17:39:30.685]                             }
[17:39:30.685]                             else {
[17:39:30.685]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:30.685]                                 info, version)
[17:39:30.685]                             }
[17:39:30.685]                             base::stop(msg)
[17:39:30.685]                           }
[17:39:30.685]                         })
[17:39:30.685]                       }
[17:39:30.685]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:30.685]                       base::options(mc.cores = 1L)
[17:39:30.685]                     }
[17:39:30.685]                     base::local({
[17:39:30.685]                       for (pkg in "stats") {
[17:39:30.685]                         base::loadNamespace(pkg)
[17:39:30.685]                         base::library(pkg, character.only = TRUE)
[17:39:30.685]                       }
[17:39:30.685]                     })
[17:39:30.685]                   }
[17:39:30.685]                   options(future.plan = NULL)
[17:39:30.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:30.685]                 }
[17:39:30.685]                 ...future.workdir <- getwd()
[17:39:30.685]             }
[17:39:30.685]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:30.685]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:30.685]         }
[17:39:30.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:30.685]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:30.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:30.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:30.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:30.685]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:30.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:30.685]             base::names(...future.oldOptions))
[17:39:30.685]     }
[17:39:30.685]     if (FALSE) {
[17:39:30.685]     }
[17:39:30.685]     else {
[17:39:30.685]         if (TRUE) {
[17:39:30.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:30.685]                 open = "w")
[17:39:30.685]         }
[17:39:30.685]         else {
[17:39:30.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:30.685]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:30.685]         }
[17:39:30.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:30.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:30.685]             base::sink(type = "output", split = FALSE)
[17:39:30.685]             base::close(...future.stdout)
[17:39:30.685]         }, add = TRUE)
[17:39:30.685]     }
[17:39:30.685]     ...future.frame <- base::sys.nframe()
[17:39:30.685]     ...future.conditions <- base::list()
[17:39:30.685]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:30.685]     if (FALSE) {
[17:39:30.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:30.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:30.685]     }
[17:39:30.685]     ...future.result <- base::tryCatch({
[17:39:30.685]         base::withCallingHandlers({
[17:39:30.685]             ...future.value <- base::withVisible(base::local({
[17:39:30.685]                 ...future.makeSendCondition <- local({
[17:39:30.685]                   sendCondition <- NULL
[17:39:30.685]                   function(frame = 1L) {
[17:39:30.685]                     if (is.function(sendCondition)) 
[17:39:30.685]                       return(sendCondition)
[17:39:30.685]                     ns <- getNamespace("parallel")
[17:39:30.685]                     if (exists("sendData", mode = "function", 
[17:39:30.685]                       envir = ns)) {
[17:39:30.685]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:30.685]                         envir = ns)
[17:39:30.685]                       envir <- sys.frame(frame)
[17:39:30.685]                       master <- NULL
[17:39:30.685]                       while (!identical(envir, .GlobalEnv) && 
[17:39:30.685]                         !identical(envir, emptyenv())) {
[17:39:30.685]                         if (exists("master", mode = "list", envir = envir, 
[17:39:30.685]                           inherits = FALSE)) {
[17:39:30.685]                           master <- get("master", mode = "list", 
[17:39:30.685]                             envir = envir, inherits = FALSE)
[17:39:30.685]                           if (inherits(master, c("SOCKnode", 
[17:39:30.685]                             "SOCK0node"))) {
[17:39:30.685]                             sendCondition <<- function(cond) {
[17:39:30.685]                               data <- list(type = "VALUE", value = cond, 
[17:39:30.685]                                 success = TRUE)
[17:39:30.685]                               parallel_sendData(master, data)
[17:39:30.685]                             }
[17:39:30.685]                             return(sendCondition)
[17:39:30.685]                           }
[17:39:30.685]                         }
[17:39:30.685]                         frame <- frame + 1L
[17:39:30.685]                         envir <- sys.frame(frame)
[17:39:30.685]                       }
[17:39:30.685]                     }
[17:39:30.685]                     sendCondition <<- function(cond) NULL
[17:39:30.685]                   }
[17:39:30.685]                 })
[17:39:30.685]                 withCallingHandlers({
[17:39:30.685]                   {
[17:39:30.685]                     do.call(function(...) {
[17:39:30.685]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.685]                       if (!identical(...future.globals.maxSize.org, 
[17:39:30.685]                         ...future.globals.maxSize)) {
[17:39:30.685]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.685]                         on.exit(options(oopts), add = TRUE)
[17:39:30.685]                       }
[17:39:30.685]                       {
[17:39:30.685]                         lapply(seq_along(...future.elements_ii), 
[17:39:30.685]                           FUN = function(jj) {
[17:39:30.685]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.685]                             ...future.FUN(...future.X_jj, ...)
[17:39:30.685]                           })
[17:39:30.685]                       }
[17:39:30.685]                     }, args = future.call.arguments)
[17:39:30.685]                   }
[17:39:30.685]                 }, immediateCondition = function(cond) {
[17:39:30.685]                   sendCondition <- ...future.makeSendCondition()
[17:39:30.685]                   sendCondition(cond)
[17:39:30.685]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.685]                   {
[17:39:30.685]                     inherits <- base::inherits
[17:39:30.685]                     invokeRestart <- base::invokeRestart
[17:39:30.685]                     is.null <- base::is.null
[17:39:30.685]                     muffled <- FALSE
[17:39:30.685]                     if (inherits(cond, "message")) {
[17:39:30.685]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:30.685]                       if (muffled) 
[17:39:30.685]                         invokeRestart("muffleMessage")
[17:39:30.685]                     }
[17:39:30.685]                     else if (inherits(cond, "warning")) {
[17:39:30.685]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:30.685]                       if (muffled) 
[17:39:30.685]                         invokeRestart("muffleWarning")
[17:39:30.685]                     }
[17:39:30.685]                     else if (inherits(cond, "condition")) {
[17:39:30.685]                       if (!is.null(pattern)) {
[17:39:30.685]                         computeRestarts <- base::computeRestarts
[17:39:30.685]                         grepl <- base::grepl
[17:39:30.685]                         restarts <- computeRestarts(cond)
[17:39:30.685]                         for (restart in restarts) {
[17:39:30.685]                           name <- restart$name
[17:39:30.685]                           if (is.null(name)) 
[17:39:30.685]                             next
[17:39:30.685]                           if (!grepl(pattern, name)) 
[17:39:30.685]                             next
[17:39:30.685]                           invokeRestart(restart)
[17:39:30.685]                           muffled <- TRUE
[17:39:30.685]                           break
[17:39:30.685]                         }
[17:39:30.685]                       }
[17:39:30.685]                     }
[17:39:30.685]                     invisible(muffled)
[17:39:30.685]                   }
[17:39:30.685]                   muffleCondition(cond)
[17:39:30.685]                 })
[17:39:30.685]             }))
[17:39:30.685]             future::FutureResult(value = ...future.value$value, 
[17:39:30.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.685]                   ...future.rng), globalenv = if (FALSE) 
[17:39:30.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:30.685]                     ...future.globalenv.names))
[17:39:30.685]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:30.685]         }, condition = base::local({
[17:39:30.685]             c <- base::c
[17:39:30.685]             inherits <- base::inherits
[17:39:30.685]             invokeRestart <- base::invokeRestart
[17:39:30.685]             length <- base::length
[17:39:30.685]             list <- base::list
[17:39:30.685]             seq.int <- base::seq.int
[17:39:30.685]             signalCondition <- base::signalCondition
[17:39:30.685]             sys.calls <- base::sys.calls
[17:39:30.685]             `[[` <- base::`[[`
[17:39:30.685]             `+` <- base::`+`
[17:39:30.685]             `<<-` <- base::`<<-`
[17:39:30.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:30.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:30.685]                   3L)]
[17:39:30.685]             }
[17:39:30.685]             function(cond) {
[17:39:30.685]                 is_error <- inherits(cond, "error")
[17:39:30.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:30.685]                   NULL)
[17:39:30.685]                 if (is_error) {
[17:39:30.685]                   sessionInformation <- function() {
[17:39:30.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:30.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:30.685]                       search = base::search(), system = base::Sys.info())
[17:39:30.685]                   }
[17:39:30.685]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:30.685]                     cond$call), session = sessionInformation(), 
[17:39:30.685]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:30.685]                   signalCondition(cond)
[17:39:30.685]                 }
[17:39:30.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:30.685]                 "immediateCondition"))) {
[17:39:30.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:30.685]                   ...future.conditions[[length(...future.conditions) + 
[17:39:30.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:30.685]                   if (TRUE && !signal) {
[17:39:30.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.685]                     {
[17:39:30.685]                       inherits <- base::inherits
[17:39:30.685]                       invokeRestart <- base::invokeRestart
[17:39:30.685]                       is.null <- base::is.null
[17:39:30.685]                       muffled <- FALSE
[17:39:30.685]                       if (inherits(cond, "message")) {
[17:39:30.685]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.685]                         if (muffled) 
[17:39:30.685]                           invokeRestart("muffleMessage")
[17:39:30.685]                       }
[17:39:30.685]                       else if (inherits(cond, "warning")) {
[17:39:30.685]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.685]                         if (muffled) 
[17:39:30.685]                           invokeRestart("muffleWarning")
[17:39:30.685]                       }
[17:39:30.685]                       else if (inherits(cond, "condition")) {
[17:39:30.685]                         if (!is.null(pattern)) {
[17:39:30.685]                           computeRestarts <- base::computeRestarts
[17:39:30.685]                           grepl <- base::grepl
[17:39:30.685]                           restarts <- computeRestarts(cond)
[17:39:30.685]                           for (restart in restarts) {
[17:39:30.685]                             name <- restart$name
[17:39:30.685]                             if (is.null(name)) 
[17:39:30.685]                               next
[17:39:30.685]                             if (!grepl(pattern, name)) 
[17:39:30.685]                               next
[17:39:30.685]                             invokeRestart(restart)
[17:39:30.685]                             muffled <- TRUE
[17:39:30.685]                             break
[17:39:30.685]                           }
[17:39:30.685]                         }
[17:39:30.685]                       }
[17:39:30.685]                       invisible(muffled)
[17:39:30.685]                     }
[17:39:30.685]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.685]                   }
[17:39:30.685]                 }
[17:39:30.685]                 else {
[17:39:30.685]                   if (TRUE) {
[17:39:30.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:30.685]                     {
[17:39:30.685]                       inherits <- base::inherits
[17:39:30.685]                       invokeRestart <- base::invokeRestart
[17:39:30.685]                       is.null <- base::is.null
[17:39:30.685]                       muffled <- FALSE
[17:39:30.685]                       if (inherits(cond, "message")) {
[17:39:30.685]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:30.685]                         if (muffled) 
[17:39:30.685]                           invokeRestart("muffleMessage")
[17:39:30.685]                       }
[17:39:30.685]                       else if (inherits(cond, "warning")) {
[17:39:30.685]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:30.685]                         if (muffled) 
[17:39:30.685]                           invokeRestart("muffleWarning")
[17:39:30.685]                       }
[17:39:30.685]                       else if (inherits(cond, "condition")) {
[17:39:30.685]                         if (!is.null(pattern)) {
[17:39:30.685]                           computeRestarts <- base::computeRestarts
[17:39:30.685]                           grepl <- base::grepl
[17:39:30.685]                           restarts <- computeRestarts(cond)
[17:39:30.685]                           for (restart in restarts) {
[17:39:30.685]                             name <- restart$name
[17:39:30.685]                             if (is.null(name)) 
[17:39:30.685]                               next
[17:39:30.685]                             if (!grepl(pattern, name)) 
[17:39:30.685]                               next
[17:39:30.685]                             invokeRestart(restart)
[17:39:30.685]                             muffled <- TRUE
[17:39:30.685]                             break
[17:39:30.685]                           }
[17:39:30.685]                         }
[17:39:30.685]                       }
[17:39:30.685]                       invisible(muffled)
[17:39:30.685]                     }
[17:39:30.685]                     muffleCondition(cond, pattern = "^muffle")
[17:39:30.685]                   }
[17:39:30.685]                 }
[17:39:30.685]             }
[17:39:30.685]         }))
[17:39:30.685]     }, error = function(ex) {
[17:39:30.685]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:30.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:30.685]                 ...future.rng), started = ...future.startTime, 
[17:39:30.685]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:30.685]             version = "1.8"), class = "FutureResult")
[17:39:30.685]     }, finally = {
[17:39:30.685]         if (!identical(...future.workdir, getwd())) 
[17:39:30.685]             setwd(...future.workdir)
[17:39:30.685]         {
[17:39:30.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:30.685]                 ...future.oldOptions$nwarnings <- NULL
[17:39:30.685]             }
[17:39:30.685]             base::options(...future.oldOptions)
[17:39:30.685]             if (.Platform$OS.type == "windows") {
[17:39:30.685]                 old_names <- names(...future.oldEnvVars)
[17:39:30.685]                 envs <- base::Sys.getenv()
[17:39:30.685]                 names <- names(envs)
[17:39:30.685]                 common <- intersect(names, old_names)
[17:39:30.685]                 added <- setdiff(names, old_names)
[17:39:30.685]                 removed <- setdiff(old_names, names)
[17:39:30.685]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:30.685]                   envs[common]]
[17:39:30.685]                 NAMES <- toupper(changed)
[17:39:30.685]                 args <- list()
[17:39:30.685]                 for (kk in seq_along(NAMES)) {
[17:39:30.685]                   name <- changed[[kk]]
[17:39:30.685]                   NAME <- NAMES[[kk]]
[17:39:30.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.685]                     next
[17:39:30.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.685]                 }
[17:39:30.685]                 NAMES <- toupper(added)
[17:39:30.685]                 for (kk in seq_along(NAMES)) {
[17:39:30.685]                   name <- added[[kk]]
[17:39:30.685]                   NAME <- NAMES[[kk]]
[17:39:30.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.685]                     next
[17:39:30.685]                   args[[name]] <- ""
[17:39:30.685]                 }
[17:39:30.685]                 NAMES <- toupper(removed)
[17:39:30.685]                 for (kk in seq_along(NAMES)) {
[17:39:30.685]                   name <- removed[[kk]]
[17:39:30.685]                   NAME <- NAMES[[kk]]
[17:39:30.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:30.685]                     next
[17:39:30.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:30.685]                 }
[17:39:30.685]                 if (length(args) > 0) 
[17:39:30.685]                   base::do.call(base::Sys.setenv, args = args)
[17:39:30.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:30.685]             }
[17:39:30.685]             else {
[17:39:30.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:30.685]             }
[17:39:30.685]             {
[17:39:30.685]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:30.685]                   0L) {
[17:39:30.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:30.685]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:30.685]                   base::options(opts)
[17:39:30.685]                 }
[17:39:30.685]                 {
[17:39:30.685]                   {
[17:39:30.685]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:30.685]                     NULL
[17:39:30.685]                   }
[17:39:30.685]                   options(future.plan = NULL)
[17:39:30.685]                   if (is.na(NA_character_)) 
[17:39:30.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:30.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:30.685]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:30.685]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:30.685]                     envir = parent.frame()) 
[17:39:30.685]                   {
[17:39:30.685]                     if (is.function(workers)) 
[17:39:30.685]                       workers <- workers()
[17:39:30.685]                     workers <- structure(as.integer(workers), 
[17:39:30.685]                       class = class(workers))
[17:39:30.685]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:30.685]                       workers >= 1)
[17:39:30.685]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:30.685]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:30.685]                     }
[17:39:30.685]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:30.685]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:30.685]                       envir = envir)
[17:39:30.685]                     if (!future$lazy) 
[17:39:30.685]                       future <- run(future)
[17:39:30.685]                     invisible(future)
[17:39:30.685]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:30.685]                 }
[17:39:30.685]             }
[17:39:30.685]         }
[17:39:30.685]     })
[17:39:30.685]     if (TRUE) {
[17:39:30.685]         base::sink(type = "output", split = FALSE)
[17:39:30.685]         if (TRUE) {
[17:39:30.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:30.685]         }
[17:39:30.685]         else {
[17:39:30.685]             ...future.result["stdout"] <- base::list(NULL)
[17:39:30.685]         }
[17:39:30.685]         base::close(...future.stdout)
[17:39:30.685]         ...future.stdout <- NULL
[17:39:30.685]     }
[17:39:30.685]     ...future.result$conditions <- ...future.conditions
[17:39:30.685]     ...future.result$finished <- base::Sys.time()
[17:39:30.685]     ...future.result
[17:39:30.685] }
[17:39:30.688] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:39:30.688] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:39:30.689] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:39:30.689] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:30.689] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.689] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:39:30.690] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:39:30.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:30.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:30.691] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:30.691] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:39:30.691] MultisessionFuture started
[17:39:30.692] - Launch lazy future ... done
[17:39:30.692] run() for ‘MultisessionFuture’ ... done
[17:39:30.692] Created future:
[17:39:30.692] MultisessionFuture:
[17:39:30.692] Label: ‘future_eapply-2’
[17:39:30.692] Expression:
[17:39:30.692] {
[17:39:30.692]     do.call(function(...) {
[17:39:30.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:30.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:30.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:30.692]             on.exit(options(oopts), add = TRUE)
[17:39:30.692]         }
[17:39:30.692]         {
[17:39:30.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:30.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:30.692]                 ...future.FUN(...future.X_jj, ...)
[17:39:30.692]             })
[17:39:30.692]         }
[17:39:30.692]     }, args = future.call.arguments)
[17:39:30.692] }
[17:39:30.692] Lazy evaluation: FALSE
[17:39:30.692] Asynchronous evaluation: TRUE
[17:39:30.692] Local evaluation: TRUE
[17:39:30.692] Environment: R_GlobalEnv
[17:39:30.692] Capture standard output: TRUE
[17:39:30.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:30.692] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:30.692] Packages: 1 packages (‘stats’)
[17:39:30.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:30.692] Resolved: FALSE
[17:39:30.692] Value: <not collected>
[17:39:30.692] Conditions captured: <none>
[17:39:30.692] Early signaling: FALSE
[17:39:30.692] Owner process: 50ace9dd-3963-96ce-5401-ad04c1c202c7
[17:39:30.692] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:30.704] Chunk #2 of 2 ... DONE
[17:39:30.704] Launching 2 futures (chunks) ... DONE
[17:39:30.704] Resolving 2 futures (chunks) ...
[17:39:30.704] resolve() on list ...
[17:39:30.704]  recursive: 0
[17:39:30.704]  length: 2
[17:39:30.704] 
[17:39:30.705] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.705] - Validating connection of MultisessionFuture
[17:39:30.706] - received message: FutureResult
[17:39:30.706] - Received FutureResult
[17:39:30.706] - Erased future from FutureRegistry
[17:39:30.706] result() for ClusterFuture ...
[17:39:30.706] - result already collected: FutureResult
[17:39:30.706] result() for ClusterFuture ... done
[17:39:30.706] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.706] Future #1
[17:39:30.706] result() for ClusterFuture ...
[17:39:30.706] - result already collected: FutureResult
[17:39:30.707] result() for ClusterFuture ... done
[17:39:30.707] result() for ClusterFuture ...
[17:39:30.707] - result already collected: FutureResult
[17:39:30.707] result() for ClusterFuture ... done
[17:39:30.707] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:30.707] - nx: 2
[17:39:30.707] - relay: TRUE
[17:39:30.707] - stdout: TRUE
[17:39:30.707] - signal: TRUE
[17:39:30.707] - resignal: FALSE
[17:39:30.707] - force: TRUE
[17:39:30.708] - relayed: [n=2] FALSE, FALSE
[17:39:30.708] - queued futures: [n=2] FALSE, FALSE
[17:39:30.708]  - until=1
[17:39:30.708]  - relaying element #1
[17:39:30.708] result() for ClusterFuture ...
[17:39:30.708] - result already collected: FutureResult
[17:39:30.708] result() for ClusterFuture ... done
[17:39:30.708] result() for ClusterFuture ...
[17:39:30.708] - result already collected: FutureResult
[17:39:30.708] result() for ClusterFuture ... done
[17:39:30.709] result() for ClusterFuture ...
[17:39:30.709] - result already collected: FutureResult
[17:39:30.709] result() for ClusterFuture ... done
[17:39:30.709] result() for ClusterFuture ...
[17:39:30.709] - result already collected: FutureResult
[17:39:30.709] result() for ClusterFuture ... done
[17:39:30.709] - relayed: [n=2] TRUE, FALSE
[17:39:30.709] - queued futures: [n=2] TRUE, FALSE
[17:39:30.709] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:30.709]  length: 1 (resolved future 1)
[17:39:30.740] receiveMessageFromWorker() for ClusterFuture ...
[17:39:30.741] - Validating connection of MultisessionFuture
[17:39:30.741] - received message: FutureResult
[17:39:30.741] - Received FutureResult
[17:39:30.741] - Erased future from FutureRegistry
[17:39:30.741] result() for ClusterFuture ...
[17:39:30.741] - result already collected: FutureResult
[17:39:30.742] result() for ClusterFuture ... done
[17:39:30.742] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:30.742] Future #2
[17:39:30.742] result() for ClusterFuture ...
[17:39:30.742] - result already collected: FutureResult
[17:39:30.742] result() for ClusterFuture ... done
[17:39:30.742] result() for ClusterFuture ...
[17:39:30.742] - result already collected: FutureResult
[17:39:30.742] result() for ClusterFuture ... done
[17:39:30.742] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:30.743] - nx: 2
[17:39:30.743] - relay: TRUE
[17:39:30.743] - stdout: TRUE
[17:39:30.743] - signal: TRUE
[17:39:30.743] - resignal: FALSE
[17:39:30.743] - force: TRUE
[17:39:30.743] - relayed: [n=2] TRUE, FALSE
[17:39:30.743] - queued futures: [n=2] TRUE, FALSE
[17:39:30.743]  - until=2
[17:39:30.743]  - relaying element #2
[17:39:30.743] result() for ClusterFuture ...
[17:39:30.744] - result already collected: FutureResult
[17:39:30.744] result() for ClusterFuture ... done
[17:39:30.744] result() for ClusterFuture ...
[17:39:30.744] - result already collected: FutureResult
[17:39:30.744] result() for ClusterFuture ... done
[17:39:30.744] result() for ClusterFuture ...
[17:39:30.744] - result already collected: FutureResult
[17:39:30.744] result() for ClusterFuture ... done
[17:39:30.744] result() for ClusterFuture ...
[17:39:30.744] - result already collected: FutureResult
[17:39:30.745] result() for ClusterFuture ... done
[17:39:30.745] - relayed: [n=2] TRUE, TRUE
[17:39:30.745] - queued futures: [n=2] TRUE, TRUE
[17:39:30.745] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:30.745]  length: 0 (resolved future 2)
[17:39:30.745] Relaying remaining futures
[17:39:30.745] signalConditionsASAP(NULL, pos=0) ...
[17:39:30.745] - nx: 2
[17:39:30.745] - relay: TRUE
[17:39:30.745] - stdout: TRUE
[17:39:30.745] - signal: TRUE
[17:39:30.746] - resignal: FALSE
[17:39:30.746] - force: TRUE
[17:39:30.746] - relayed: [n=2] TRUE, TRUE
[17:39:30.746] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:30.746] - relayed: [n=2] TRUE, TRUE
[17:39:30.746] - queued futures: [n=2] TRUE, TRUE
[17:39:30.746] signalConditionsASAP(NULL, pos=0) ... done
[17:39:30.746] resolve() on list ... DONE
[17:39:30.746] result() for ClusterFuture ...
[17:39:30.746] - result already collected: FutureResult
[17:39:30.746] result() for ClusterFuture ... done
[17:39:30.747] result() for ClusterFuture ...
[17:39:30.747] - result already collected: FutureResult
[17:39:30.747] result() for ClusterFuture ... done
[17:39:30.747] result() for ClusterFuture ...
[17:39:30.747] - result already collected: FutureResult
[17:39:30.747] result() for ClusterFuture ... done
[17:39:30.747] result() for ClusterFuture ...
[17:39:30.747] - result already collected: FutureResult
[17:39:30.747] result() for ClusterFuture ... done
[17:39:30.747]  - Number of value chunks collected: 2
[17:39:30.748] Resolving 2 futures (chunks) ... DONE
[17:39:30.748] Reducing values from 2 chunks ...
[17:39:30.748]  - Number of values collected after concatenation: 3
[17:39:30.748]  - Number of values expected: 3
[17:39:30.748] Reducing values from 2 chunks ... DONE
[17:39:30.748] future_lapply() ... DONE
[17:39:30.748] plan(): Setting new future strategy stack:
[17:39:30.748] List of future strategies:
[17:39:30.748] 1. sequential:
[17:39:30.748]    - args: function (..., envir = parent.frame())
[17:39:30.748]    - tweaked: FALSE
[17:39:30.748]    - call: plan(sequential)
[17:39:30.749] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[17:39:30.750] plan(): Setting new future strategy stack:
[17:39:30.751] List of future strategies:
[17:39:30.751] 1. FutureStrategy:
[17:39:30.751]    - args: function (..., envir = parent.frame())
[17:39:30.751]    - tweaked: FALSE
[17:39:30.751]    - call: future::plan(oplan)
[17:39:30.751] plan(): nbrOfWorkers() = 1
> 
