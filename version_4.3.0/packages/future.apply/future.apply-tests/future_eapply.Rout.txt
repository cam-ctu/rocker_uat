
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:17:32.518] plan(): Setting new future strategy stack:
[13:17:32.518] List of future strategies:
[13:17:32.518] 1. sequential:
[13:17:32.518]    - args: function (..., envir = parent.frame())
[13:17:32.518]    - tweaked: FALSE
[13:17:32.518]    - call: future::plan("sequential")
[13:17:32.528] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:17:32.551] plan(): Setting new future strategy stack:
[13:17:32.552] List of future strategies:
[13:17:32.552] 1. sequential:
[13:17:32.552]    - args: function (..., envir = parent.frame())
[13:17:32.552]    - tweaked: FALSE
[13:17:32.552]    - call: plan(strategy)
[13:17:32.563] plan(): nbrOfWorkers() = 1
[13:17:32.563] future_lapply() ...
[13:17:32.567] Number of chunks: 1
[13:17:32.568] getGlobalsAndPackagesXApply() ...
[13:17:32.568]  - future.globals: TRUE
[13:17:32.569] getGlobalsAndPackages() ...
[13:17:32.569] Searching for globals...
[13:17:32.571] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.571] Searching for globals ... DONE
[13:17:32.571] Resolving globals: FALSE
[13:17:32.572] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:32.572] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:32.573] - globals: [1] ‘FUN’
[13:17:32.573] 
[13:17:32.573] getGlobalsAndPackages() ... DONE
[13:17:32.573]  - globals found/used: [n=1] ‘FUN’
[13:17:32.573]  - needed namespaces: [n=0] 
[13:17:32.573] Finding globals ... DONE
[13:17:32.573]  - use_args: TRUE
[13:17:32.573]  - Getting '...' globals ...
[13:17:32.574] resolve() on list ...
[13:17:32.574]  recursive: 0
[13:17:32.575]  length: 1
[13:17:32.575]  elements: ‘...’
[13:17:32.575]  length: 0 (resolved future 1)
[13:17:32.575] resolve() on list ... DONE
[13:17:32.575]    - '...' content: [n=0] 
[13:17:32.575] List of 1
[13:17:32.575]  $ ...: list()
[13:17:32.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.575]  - attr(*, "where")=List of 1
[13:17:32.575]   ..$ ...:<environment: 0x55be3dbe8fe8> 
[13:17:32.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.575]  - attr(*, "resolved")= logi TRUE
[13:17:32.575]  - attr(*, "total_size")= num NA
[13:17:32.580]  - Getting '...' globals ... DONE
[13:17:32.580] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.580] List of 2
[13:17:32.580]  $ ...future.FUN:function (x, ...)  
[13:17:32.580]  $ ...          : list()
[13:17:32.580]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.580]  - attr(*, "where")=List of 2
[13:17:32.580]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.580]   ..$ ...          :<environment: 0x55be3dbe8fe8> 
[13:17:32.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.580]  - attr(*, "resolved")= logi FALSE
[13:17:32.580]  - attr(*, "total_size")= num 1240
[13:17:32.585] Packages to be attached in all futures: [n=0] 
[13:17:32.585] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.586] Number of futures (= number of chunks): 1
[13:17:32.586] Launching 1 futures (chunks) ...
[13:17:32.586] Chunk #1 of 1 ...
[13:17:32.586]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.586] getGlobalsAndPackages() ...
[13:17:32.586] Searching for globals...
[13:17:32.587] 
[13:17:32.587] Searching for globals ... DONE
[13:17:32.587] - globals: [0] <none>
[13:17:32.587] getGlobalsAndPackages() ... DONE
[13:17:32.587]    + additional globals found: [n=0] 
[13:17:32.587]    + additional namespaces needed: [n=0] 
[13:17:32.587]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.587]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:32.587]  - seeds: <none>
[13:17:32.588] getGlobalsAndPackages() ...
[13:17:32.588] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.588] Resolving globals: FALSE
[13:17:32.588] Tweak future expression to call with '...' arguments ...
[13:17:32.588] {
[13:17:32.588]     do.call(function(...) {
[13:17:32.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.588]             on.exit(options(oopts), add = TRUE)
[13:17:32.588]         }
[13:17:32.588]         {
[13:17:32.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.588]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.588]             })
[13:17:32.588]         }
[13:17:32.588]     }, args = future.call.arguments)
[13:17:32.588] }
[13:17:32.588] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.589] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.589] 
[13:17:32.589] getGlobalsAndPackages() ... DONE
[13:17:32.590] run() for ‘Future’ ...
[13:17:32.590] - state: ‘created’
[13:17:32.590] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:32.590] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:32.591]   - Field: ‘label’
[13:17:32.591]   - Field: ‘local’
[13:17:32.591]   - Field: ‘owner’
[13:17:32.591]   - Field: ‘envir’
[13:17:32.591]   - Field: ‘packages’
[13:17:32.591]   - Field: ‘gc’
[13:17:32.591]   - Field: ‘conditions’
[13:17:32.591]   - Field: ‘expr’
[13:17:32.591]   - Field: ‘uuid’
[13:17:32.591]   - Field: ‘seed’
[13:17:32.591]   - Field: ‘version’
[13:17:32.592]   - Field: ‘result’
[13:17:32.592]   - Field: ‘asynchronous’
[13:17:32.592]   - Field: ‘calls’
[13:17:32.592]   - Field: ‘globals’
[13:17:32.592]   - Field: ‘stdout’
[13:17:32.592]   - Field: ‘earlySignal’
[13:17:32.592]   - Field: ‘lazy’
[13:17:32.592]   - Field: ‘state’
[13:17:32.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:32.592] - Launch lazy future ...
[13:17:32.593] Packages needed by the future expression (n = 0): <none>
[13:17:32.593] Packages needed by future strategies (n = 0): <none>
[13:17:32.594] {
[13:17:32.594]     {
[13:17:32.594]         {
[13:17:32.594]             ...future.startTime <- base::Sys.time()
[13:17:32.594]             {
[13:17:32.594]                 {
[13:17:32.594]                   {
[13:17:32.594]                     base::local({
[13:17:32.594]                       has_future <- base::requireNamespace("future", 
[13:17:32.594]                         quietly = TRUE)
[13:17:32.594]                       if (has_future) {
[13:17:32.594]                         ns <- base::getNamespace("future")
[13:17:32.594]                         version <- ns[[".package"]][["version"]]
[13:17:32.594]                         if (is.null(version)) 
[13:17:32.594]                           version <- utils::packageVersion("future")
[13:17:32.594]                       }
[13:17:32.594]                       else {
[13:17:32.594]                         version <- NULL
[13:17:32.594]                       }
[13:17:32.594]                       if (!has_future || version < "1.8.0") {
[13:17:32.594]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.594]                           "", base::R.version$version.string), 
[13:17:32.594]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:32.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.594]                             "release", "version")], collapse = " "), 
[13:17:32.594]                           hostname = base::Sys.info()[["nodename"]])
[13:17:32.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.594]                           info)
[13:17:32.594]                         info <- base::paste(info, collapse = "; ")
[13:17:32.594]                         if (!has_future) {
[13:17:32.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.594]                             info)
[13:17:32.594]                         }
[13:17:32.594]                         else {
[13:17:32.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.594]                             info, version)
[13:17:32.594]                         }
[13:17:32.594]                         base::stop(msg)
[13:17:32.594]                       }
[13:17:32.594]                     })
[13:17:32.594]                   }
[13:17:32.594]                   options(future.plan = NULL)
[13:17:32.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.594]                 }
[13:17:32.594]                 ...future.workdir <- getwd()
[13:17:32.594]             }
[13:17:32.594]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.594]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.594]         }
[13:17:32.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.594]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:32.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.594]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.594]             base::names(...future.oldOptions))
[13:17:32.594]     }
[13:17:32.594]     if (FALSE) {
[13:17:32.594]     }
[13:17:32.594]     else {
[13:17:32.594]         if (TRUE) {
[13:17:32.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.594]                 open = "w")
[13:17:32.594]         }
[13:17:32.594]         else {
[13:17:32.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.594]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.594]         }
[13:17:32.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.594]             base::sink(type = "output", split = FALSE)
[13:17:32.594]             base::close(...future.stdout)
[13:17:32.594]         }, add = TRUE)
[13:17:32.594]     }
[13:17:32.594]     ...future.frame <- base::sys.nframe()
[13:17:32.594]     ...future.conditions <- base::list()
[13:17:32.594]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.594]     if (FALSE) {
[13:17:32.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.594]     }
[13:17:32.594]     ...future.result <- base::tryCatch({
[13:17:32.594]         base::withCallingHandlers({
[13:17:32.594]             ...future.value <- base::withVisible(base::local({
[13:17:32.594]                 do.call(function(...) {
[13:17:32.594]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.594]                   if (!identical(...future.globals.maxSize.org, 
[13:17:32.594]                     ...future.globals.maxSize)) {
[13:17:32.594]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.594]                     on.exit(options(oopts), add = TRUE)
[13:17:32.594]                   }
[13:17:32.594]                   {
[13:17:32.594]                     lapply(seq_along(...future.elements_ii), 
[13:17:32.594]                       FUN = function(jj) {
[13:17:32.594]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.594]                         ...future.FUN(...future.X_jj, ...)
[13:17:32.594]                       })
[13:17:32.594]                   }
[13:17:32.594]                 }, args = future.call.arguments)
[13:17:32.594]             }))
[13:17:32.594]             future::FutureResult(value = ...future.value$value, 
[13:17:32.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.594]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.594]                     ...future.globalenv.names))
[13:17:32.594]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.594]         }, condition = base::local({
[13:17:32.594]             c <- base::c
[13:17:32.594]             inherits <- base::inherits
[13:17:32.594]             invokeRestart <- base::invokeRestart
[13:17:32.594]             length <- base::length
[13:17:32.594]             list <- base::list
[13:17:32.594]             seq.int <- base::seq.int
[13:17:32.594]             signalCondition <- base::signalCondition
[13:17:32.594]             sys.calls <- base::sys.calls
[13:17:32.594]             `[[` <- base::`[[`
[13:17:32.594]             `+` <- base::`+`
[13:17:32.594]             `<<-` <- base::`<<-`
[13:17:32.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.594]                   3L)]
[13:17:32.594]             }
[13:17:32.594]             function(cond) {
[13:17:32.594]                 is_error <- inherits(cond, "error")
[13:17:32.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.594]                   NULL)
[13:17:32.594]                 if (is_error) {
[13:17:32.594]                   sessionInformation <- function() {
[13:17:32.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.594]                       search = base::search(), system = base::Sys.info())
[13:17:32.594]                   }
[13:17:32.594]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.594]                     cond$call), session = sessionInformation(), 
[13:17:32.594]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.594]                   signalCondition(cond)
[13:17:32.594]                 }
[13:17:32.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.594]                 "immediateCondition"))) {
[13:17:32.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.594]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.594]                   if (TRUE && !signal) {
[13:17:32.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.594]                     {
[13:17:32.594]                       inherits <- base::inherits
[13:17:32.594]                       invokeRestart <- base::invokeRestart
[13:17:32.594]                       is.null <- base::is.null
[13:17:32.594]                       muffled <- FALSE
[13:17:32.594]                       if (inherits(cond, "message")) {
[13:17:32.594]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.594]                         if (muffled) 
[13:17:32.594]                           invokeRestart("muffleMessage")
[13:17:32.594]                       }
[13:17:32.594]                       else if (inherits(cond, "warning")) {
[13:17:32.594]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.594]                         if (muffled) 
[13:17:32.594]                           invokeRestart("muffleWarning")
[13:17:32.594]                       }
[13:17:32.594]                       else if (inherits(cond, "condition")) {
[13:17:32.594]                         if (!is.null(pattern)) {
[13:17:32.594]                           computeRestarts <- base::computeRestarts
[13:17:32.594]                           grepl <- base::grepl
[13:17:32.594]                           restarts <- computeRestarts(cond)
[13:17:32.594]                           for (restart in restarts) {
[13:17:32.594]                             name <- restart$name
[13:17:32.594]                             if (is.null(name)) 
[13:17:32.594]                               next
[13:17:32.594]                             if (!grepl(pattern, name)) 
[13:17:32.594]                               next
[13:17:32.594]                             invokeRestart(restart)
[13:17:32.594]                             muffled <- TRUE
[13:17:32.594]                             break
[13:17:32.594]                           }
[13:17:32.594]                         }
[13:17:32.594]                       }
[13:17:32.594]                       invisible(muffled)
[13:17:32.594]                     }
[13:17:32.594]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.594]                   }
[13:17:32.594]                 }
[13:17:32.594]                 else {
[13:17:32.594]                   if (TRUE) {
[13:17:32.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.594]                     {
[13:17:32.594]                       inherits <- base::inherits
[13:17:32.594]                       invokeRestart <- base::invokeRestart
[13:17:32.594]                       is.null <- base::is.null
[13:17:32.594]                       muffled <- FALSE
[13:17:32.594]                       if (inherits(cond, "message")) {
[13:17:32.594]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.594]                         if (muffled) 
[13:17:32.594]                           invokeRestart("muffleMessage")
[13:17:32.594]                       }
[13:17:32.594]                       else if (inherits(cond, "warning")) {
[13:17:32.594]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.594]                         if (muffled) 
[13:17:32.594]                           invokeRestart("muffleWarning")
[13:17:32.594]                       }
[13:17:32.594]                       else if (inherits(cond, "condition")) {
[13:17:32.594]                         if (!is.null(pattern)) {
[13:17:32.594]                           computeRestarts <- base::computeRestarts
[13:17:32.594]                           grepl <- base::grepl
[13:17:32.594]                           restarts <- computeRestarts(cond)
[13:17:32.594]                           for (restart in restarts) {
[13:17:32.594]                             name <- restart$name
[13:17:32.594]                             if (is.null(name)) 
[13:17:32.594]                               next
[13:17:32.594]                             if (!grepl(pattern, name)) 
[13:17:32.594]                               next
[13:17:32.594]                             invokeRestart(restart)
[13:17:32.594]                             muffled <- TRUE
[13:17:32.594]                             break
[13:17:32.594]                           }
[13:17:32.594]                         }
[13:17:32.594]                       }
[13:17:32.594]                       invisible(muffled)
[13:17:32.594]                     }
[13:17:32.594]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.594]                   }
[13:17:32.594]                 }
[13:17:32.594]             }
[13:17:32.594]         }))
[13:17:32.594]     }, error = function(ex) {
[13:17:32.594]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.594]                 ...future.rng), started = ...future.startTime, 
[13:17:32.594]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.594]             version = "1.8"), class = "FutureResult")
[13:17:32.594]     }, finally = {
[13:17:32.594]         if (!identical(...future.workdir, getwd())) 
[13:17:32.594]             setwd(...future.workdir)
[13:17:32.594]         {
[13:17:32.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.594]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.594]             }
[13:17:32.594]             base::options(...future.oldOptions)
[13:17:32.594]             if (.Platform$OS.type == "windows") {
[13:17:32.594]                 old_names <- names(...future.oldEnvVars)
[13:17:32.594]                 envs <- base::Sys.getenv()
[13:17:32.594]                 names <- names(envs)
[13:17:32.594]                 common <- intersect(names, old_names)
[13:17:32.594]                 added <- setdiff(names, old_names)
[13:17:32.594]                 removed <- setdiff(old_names, names)
[13:17:32.594]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.594]                   envs[common]]
[13:17:32.594]                 NAMES <- toupper(changed)
[13:17:32.594]                 args <- list()
[13:17:32.594]                 for (kk in seq_along(NAMES)) {
[13:17:32.594]                   name <- changed[[kk]]
[13:17:32.594]                   NAME <- NAMES[[kk]]
[13:17:32.594]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.594]                     next
[13:17:32.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.594]                 }
[13:17:32.594]                 NAMES <- toupper(added)
[13:17:32.594]                 for (kk in seq_along(NAMES)) {
[13:17:32.594]                   name <- added[[kk]]
[13:17:32.594]                   NAME <- NAMES[[kk]]
[13:17:32.594]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.594]                     next
[13:17:32.594]                   args[[name]] <- ""
[13:17:32.594]                 }
[13:17:32.594]                 NAMES <- toupper(removed)
[13:17:32.594]                 for (kk in seq_along(NAMES)) {
[13:17:32.594]                   name <- removed[[kk]]
[13:17:32.594]                   NAME <- NAMES[[kk]]
[13:17:32.594]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.594]                     next
[13:17:32.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.594]                 }
[13:17:32.594]                 if (length(args) > 0) 
[13:17:32.594]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.594]             }
[13:17:32.594]             else {
[13:17:32.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.594]             }
[13:17:32.594]             {
[13:17:32.594]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.594]                   0L) {
[13:17:32.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.594]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.594]                   base::options(opts)
[13:17:32.594]                 }
[13:17:32.594]                 {
[13:17:32.594]                   {
[13:17:32.594]                     NULL
[13:17:32.594]                     RNGkind("Mersenne-Twister")
[13:17:32.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:32.594]                       inherits = FALSE)
[13:17:32.594]                   }
[13:17:32.594]                   options(future.plan = NULL)
[13:17:32.594]                   if (is.na(NA_character_)) 
[13:17:32.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.594]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:32.594]                   {
[13:17:32.594]                     future <- SequentialFuture(..., envir = envir)
[13:17:32.594]                     if (!future$lazy) 
[13:17:32.594]                       future <- run(future)
[13:17:32.594]                     invisible(future)
[13:17:32.594]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.594]                 }
[13:17:32.594]             }
[13:17:32.594]         }
[13:17:32.594]     })
[13:17:32.594]     if (TRUE) {
[13:17:32.594]         base::sink(type = "output", split = FALSE)
[13:17:32.594]         if (TRUE) {
[13:17:32.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.594]         }
[13:17:32.594]         else {
[13:17:32.594]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.594]         }
[13:17:32.594]         base::close(...future.stdout)
[13:17:32.594]         ...future.stdout <- NULL
[13:17:32.594]     }
[13:17:32.594]     ...future.result$conditions <- ...future.conditions
[13:17:32.594]     ...future.result$finished <- base::Sys.time()
[13:17:32.594]     ...future.result
[13:17:32.594] }
[13:17:32.596] assign_globals() ...
[13:17:32.596] List of 5
[13:17:32.596]  $ ...future.FUN            :function (x, ...)  
[13:17:32.596]  $ future.call.arguments    : list()
[13:17:32.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.596]  $ ...future.elements_ii    :List of 3
[13:17:32.596]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.596]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:32.596]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:32.596]  $ ...future.seeds_ii       : NULL
[13:17:32.596]  $ ...future.globals.maxSize: NULL
[13:17:32.596]  - attr(*, "resolved")= logi FALSE
[13:17:32.596]  - attr(*, "total_size")= num 1240
[13:17:32.596]  - attr(*, "where")=List of 5
[13:17:32.596]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.596]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.596]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.596]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.596]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.596]  - attr(*, "already-done")= logi TRUE
[13:17:32.601] - copied ‘...future.FUN’ to environment
[13:17:32.601] - copied ‘future.call.arguments’ to environment
[13:17:32.602] - copied ‘...future.elements_ii’ to environment
[13:17:32.602] - copied ‘...future.seeds_ii’ to environment
[13:17:32.602] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.602] assign_globals() ... done
[13:17:32.602] plan(): Setting new future strategy stack:
[13:17:32.602] List of future strategies:
[13:17:32.602] 1. sequential:
[13:17:32.602]    - args: function (..., envir = parent.frame())
[13:17:32.602]    - tweaked: FALSE
[13:17:32.602]    - call: NULL
[13:17:32.603] plan(): nbrOfWorkers() = 1
[13:17:32.604] plan(): Setting new future strategy stack:
[13:17:32.604] List of future strategies:
[13:17:32.604] 1. sequential:
[13:17:32.604]    - args: function (..., envir = parent.frame())
[13:17:32.604]    - tweaked: FALSE
[13:17:32.604]    - call: plan(strategy)
[13:17:32.604] plan(): nbrOfWorkers() = 1
[13:17:32.604] SequentialFuture started (and completed)
[13:17:32.605] - Launch lazy future ... done
[13:17:32.605] run() for ‘SequentialFuture’ ... done
[13:17:32.605] Created future:
[13:17:32.605] SequentialFuture:
[13:17:32.605] Label: ‘future_eapply-1’
[13:17:32.605] Expression:
[13:17:32.605] {
[13:17:32.605]     do.call(function(...) {
[13:17:32.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.605]             on.exit(options(oopts), add = TRUE)
[13:17:32.605]         }
[13:17:32.605]         {
[13:17:32.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.605]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.605]             })
[13:17:32.605]         }
[13:17:32.605]     }, args = future.call.arguments)
[13:17:32.605] }
[13:17:32.605] Lazy evaluation: FALSE
[13:17:32.605] Asynchronous evaluation: FALSE
[13:17:32.605] Local evaluation: TRUE
[13:17:32.605] Environment: R_GlobalEnv
[13:17:32.605] Capture standard output: TRUE
[13:17:32.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.605] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.605] Packages: <none>
[13:17:32.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.605] Resolved: TRUE
[13:17:32.605] Value: 168 bytes of class ‘list’
[13:17:32.605] Early signaling: FALSE
[13:17:32.605] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.605] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.607] Chunk #1 of 1 ... DONE
[13:17:32.607] Launching 1 futures (chunks) ... DONE
[13:17:32.607] Resolving 1 futures (chunks) ...
[13:17:32.607] resolve() on list ...
[13:17:32.607]  recursive: 0
[13:17:32.607]  length: 1
[13:17:32.607] 
[13:17:32.607] resolved() for ‘SequentialFuture’ ...
[13:17:32.608] - state: ‘finished’
[13:17:32.608] - run: TRUE
[13:17:32.608] - result: ‘FutureResult’
[13:17:32.608] resolved() for ‘SequentialFuture’ ... done
[13:17:32.608] Future #1
[13:17:32.608] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:32.608] - nx: 1
[13:17:32.608] - relay: TRUE
[13:17:32.609] - stdout: TRUE
[13:17:32.609] - signal: TRUE
[13:17:32.609] - resignal: FALSE
[13:17:32.609] - force: TRUE
[13:17:32.609] - relayed: [n=1] FALSE
[13:17:32.609] - queued futures: [n=1] FALSE
[13:17:32.609]  - until=1
[13:17:32.609]  - relaying element #1
[13:17:32.609] - relayed: [n=1] TRUE
[13:17:32.609] - queued futures: [n=1] TRUE
[13:17:32.610] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:32.610]  length: 0 (resolved future 1)
[13:17:32.610] Relaying remaining futures
[13:17:32.610] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.610] - nx: 1
[13:17:32.610] - relay: TRUE
[13:17:32.610] - stdout: TRUE
[13:17:32.610] - signal: TRUE
[13:17:32.610] - resignal: FALSE
[13:17:32.610] - force: TRUE
[13:17:32.611] - relayed: [n=1] TRUE
[13:17:32.611] - queued futures: [n=1] TRUE
 - flush all
[13:17:32.611] - relayed: [n=1] TRUE
[13:17:32.611] - queued futures: [n=1] TRUE
[13:17:32.611] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.611] resolve() on list ... DONE
[13:17:32.611]  - Number of value chunks collected: 1
[13:17:32.611] Resolving 1 futures (chunks) ... DONE
[13:17:32.611] Reducing values from 1 chunks ...
[13:17:32.611]  - Number of values collected after concatenation: 3
[13:17:32.611]  - Number of values expected: 3
[13:17:32.612] Reducing values from 1 chunks ... DONE
[13:17:32.612] future_lapply() ... DONE
[13:17:32.616] future_lapply() ...
[13:17:32.616] Number of chunks: 1
[13:17:32.616] getGlobalsAndPackagesXApply() ...
[13:17:32.616]  - future.globals: TRUE
[13:17:32.616] getGlobalsAndPackages() ...
[13:17:32.616] Searching for globals...
[13:17:32.617] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.618] Searching for globals ... DONE
[13:17:32.618] Resolving globals: FALSE
[13:17:32.618] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:32.618] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:32.619] - globals: [1] ‘FUN’
[13:17:32.619] - packages: [1] ‘stats’
[13:17:32.619] getGlobalsAndPackages() ... DONE
[13:17:32.619]  - globals found/used: [n=1] ‘FUN’
[13:17:32.619]  - needed namespaces: [n=1] ‘stats’
[13:17:32.619] Finding globals ... DONE
[13:17:32.619]  - use_args: TRUE
[13:17:32.619]  - Getting '...' globals ...
[13:17:32.619] resolve() on list ...
[13:17:32.620]  recursive: 0
[13:17:32.620]  length: 1
[13:17:32.620]  elements: ‘...’
[13:17:32.620]  length: 0 (resolved future 1)
[13:17:32.620] resolve() on list ... DONE
[13:17:32.620]    - '...' content: [n=1] ‘probs’
[13:17:32.620] List of 1
[13:17:32.620]  $ ...:List of 1
[13:17:32.620]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.620]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.620]  - attr(*, "where")=List of 1
[13:17:32.620]   ..$ ...:<environment: 0x55be3d3273d8> 
[13:17:32.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.620]  - attr(*, "resolved")= logi TRUE
[13:17:32.620]  - attr(*, "total_size")= num NA
[13:17:32.623]  - Getting '...' globals ... DONE
[13:17:32.623] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.623] List of 2
[13:17:32.623]  $ ...future.FUN:function (x, ...)  
[13:17:32.623]  $ ...          :List of 1
[13:17:32.623]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.623]  - attr(*, "where")=List of 2
[13:17:32.623]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.623]   ..$ ...          :<environment: 0x55be3d3273d8> 
[13:17:32.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.623]  - attr(*, "resolved")= logi FALSE
[13:17:32.623]  - attr(*, "total_size")= num 1328
[13:17:32.626] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:32.626] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.627] Number of futures (= number of chunks): 1
[13:17:32.627] Launching 1 futures (chunks) ...
[13:17:32.627] Chunk #1 of 1 ...
[13:17:32.627]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.627] getGlobalsAndPackages() ...
[13:17:32.627] Searching for globals...
[13:17:32.627] 
[13:17:32.627] Searching for globals ... DONE
[13:17:32.627] - globals: [0] <none>
[13:17:32.628] getGlobalsAndPackages() ... DONE
[13:17:32.628]    + additional globals found: [n=0] 
[13:17:32.628]    + additional namespaces needed: [n=0] 
[13:17:32.628]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.628]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:32.628]  - seeds: <none>
[13:17:32.628] getGlobalsAndPackages() ...
[13:17:32.628] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.628] Resolving globals: FALSE
[13:17:32.628] Tweak future expression to call with '...' arguments ...
[13:17:32.629] {
[13:17:32.629]     do.call(function(...) {
[13:17:32.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.629]             on.exit(options(oopts), add = TRUE)
[13:17:32.629]         }
[13:17:32.629]         {
[13:17:32.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.629]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.629]             })
[13:17:32.629]         }
[13:17:32.629]     }, args = future.call.arguments)
[13:17:32.629] }
[13:17:32.629] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.629] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.629] - packages: [1] ‘stats’
[13:17:32.629] getGlobalsAndPackages() ... DONE
[13:17:32.630] run() for ‘Future’ ...
[13:17:32.630] - state: ‘created’
[13:17:32.630] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:32.630] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:32.630]   - Field: ‘label’
[13:17:32.630]   - Field: ‘local’
[13:17:32.631]   - Field: ‘owner’
[13:17:32.631]   - Field: ‘envir’
[13:17:32.631]   - Field: ‘packages’
[13:17:32.631]   - Field: ‘gc’
[13:17:32.631]   - Field: ‘conditions’
[13:17:32.631]   - Field: ‘expr’
[13:17:32.631]   - Field: ‘uuid’
[13:17:32.631]   - Field: ‘seed’
[13:17:32.631]   - Field: ‘version’
[13:17:32.631]   - Field: ‘result’
[13:17:32.631]   - Field: ‘asynchronous’
[13:17:32.632]   - Field: ‘calls’
[13:17:32.632]   - Field: ‘globals’
[13:17:32.632]   - Field: ‘stdout’
[13:17:32.632]   - Field: ‘earlySignal’
[13:17:32.632]   - Field: ‘lazy’
[13:17:32.632]   - Field: ‘state’
[13:17:32.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:32.632] - Launch lazy future ...
[13:17:32.632] Packages needed by the future expression (n = 1): ‘stats’
[13:17:32.632] Packages needed by future strategies (n = 0): <none>
[13:17:32.633] {
[13:17:32.633]     {
[13:17:32.633]         {
[13:17:32.633]             ...future.startTime <- base::Sys.time()
[13:17:32.633]             {
[13:17:32.633]                 {
[13:17:32.633]                   {
[13:17:32.633]                     {
[13:17:32.633]                       base::local({
[13:17:32.633]                         has_future <- base::requireNamespace("future", 
[13:17:32.633]                           quietly = TRUE)
[13:17:32.633]                         if (has_future) {
[13:17:32.633]                           ns <- base::getNamespace("future")
[13:17:32.633]                           version <- ns[[".package"]][["version"]]
[13:17:32.633]                           if (is.null(version)) 
[13:17:32.633]                             version <- utils::packageVersion("future")
[13:17:32.633]                         }
[13:17:32.633]                         else {
[13:17:32.633]                           version <- NULL
[13:17:32.633]                         }
[13:17:32.633]                         if (!has_future || version < "1.8.0") {
[13:17:32.633]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.633]                             "", base::R.version$version.string), 
[13:17:32.633]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.633]                               "release", "version")], collapse = " "), 
[13:17:32.633]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.633]                             info)
[13:17:32.633]                           info <- base::paste(info, collapse = "; ")
[13:17:32.633]                           if (!has_future) {
[13:17:32.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.633]                               info)
[13:17:32.633]                           }
[13:17:32.633]                           else {
[13:17:32.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.633]                               info, version)
[13:17:32.633]                           }
[13:17:32.633]                           base::stop(msg)
[13:17:32.633]                         }
[13:17:32.633]                       })
[13:17:32.633]                     }
[13:17:32.633]                     base::local({
[13:17:32.633]                       for (pkg in "stats") {
[13:17:32.633]                         base::loadNamespace(pkg)
[13:17:32.633]                         base::library(pkg, character.only = TRUE)
[13:17:32.633]                       }
[13:17:32.633]                     })
[13:17:32.633]                   }
[13:17:32.633]                   options(future.plan = NULL)
[13:17:32.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.633]                 }
[13:17:32.633]                 ...future.workdir <- getwd()
[13:17:32.633]             }
[13:17:32.633]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.633]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.633]         }
[13:17:32.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.633]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:32.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.633]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.633]             base::names(...future.oldOptions))
[13:17:32.633]     }
[13:17:32.633]     if (FALSE) {
[13:17:32.633]     }
[13:17:32.633]     else {
[13:17:32.633]         if (TRUE) {
[13:17:32.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.633]                 open = "w")
[13:17:32.633]         }
[13:17:32.633]         else {
[13:17:32.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.633]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.633]         }
[13:17:32.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.633]             base::sink(type = "output", split = FALSE)
[13:17:32.633]             base::close(...future.stdout)
[13:17:32.633]         }, add = TRUE)
[13:17:32.633]     }
[13:17:32.633]     ...future.frame <- base::sys.nframe()
[13:17:32.633]     ...future.conditions <- base::list()
[13:17:32.633]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.633]     if (FALSE) {
[13:17:32.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.633]     }
[13:17:32.633]     ...future.result <- base::tryCatch({
[13:17:32.633]         base::withCallingHandlers({
[13:17:32.633]             ...future.value <- base::withVisible(base::local({
[13:17:32.633]                 do.call(function(...) {
[13:17:32.633]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.633]                   if (!identical(...future.globals.maxSize.org, 
[13:17:32.633]                     ...future.globals.maxSize)) {
[13:17:32.633]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.633]                     on.exit(options(oopts), add = TRUE)
[13:17:32.633]                   }
[13:17:32.633]                   {
[13:17:32.633]                     lapply(seq_along(...future.elements_ii), 
[13:17:32.633]                       FUN = function(jj) {
[13:17:32.633]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.633]                         ...future.FUN(...future.X_jj, ...)
[13:17:32.633]                       })
[13:17:32.633]                   }
[13:17:32.633]                 }, args = future.call.arguments)
[13:17:32.633]             }))
[13:17:32.633]             future::FutureResult(value = ...future.value$value, 
[13:17:32.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.633]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.633]                     ...future.globalenv.names))
[13:17:32.633]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.633]         }, condition = base::local({
[13:17:32.633]             c <- base::c
[13:17:32.633]             inherits <- base::inherits
[13:17:32.633]             invokeRestart <- base::invokeRestart
[13:17:32.633]             length <- base::length
[13:17:32.633]             list <- base::list
[13:17:32.633]             seq.int <- base::seq.int
[13:17:32.633]             signalCondition <- base::signalCondition
[13:17:32.633]             sys.calls <- base::sys.calls
[13:17:32.633]             `[[` <- base::`[[`
[13:17:32.633]             `+` <- base::`+`
[13:17:32.633]             `<<-` <- base::`<<-`
[13:17:32.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.633]                   3L)]
[13:17:32.633]             }
[13:17:32.633]             function(cond) {
[13:17:32.633]                 is_error <- inherits(cond, "error")
[13:17:32.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.633]                   NULL)
[13:17:32.633]                 if (is_error) {
[13:17:32.633]                   sessionInformation <- function() {
[13:17:32.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.633]                       search = base::search(), system = base::Sys.info())
[13:17:32.633]                   }
[13:17:32.633]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.633]                     cond$call), session = sessionInformation(), 
[13:17:32.633]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.633]                   signalCondition(cond)
[13:17:32.633]                 }
[13:17:32.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.633]                 "immediateCondition"))) {
[13:17:32.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.633]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.633]                   if (TRUE && !signal) {
[13:17:32.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.633]                     {
[13:17:32.633]                       inherits <- base::inherits
[13:17:32.633]                       invokeRestart <- base::invokeRestart
[13:17:32.633]                       is.null <- base::is.null
[13:17:32.633]                       muffled <- FALSE
[13:17:32.633]                       if (inherits(cond, "message")) {
[13:17:32.633]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.633]                         if (muffled) 
[13:17:32.633]                           invokeRestart("muffleMessage")
[13:17:32.633]                       }
[13:17:32.633]                       else if (inherits(cond, "warning")) {
[13:17:32.633]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.633]                         if (muffled) 
[13:17:32.633]                           invokeRestart("muffleWarning")
[13:17:32.633]                       }
[13:17:32.633]                       else if (inherits(cond, "condition")) {
[13:17:32.633]                         if (!is.null(pattern)) {
[13:17:32.633]                           computeRestarts <- base::computeRestarts
[13:17:32.633]                           grepl <- base::grepl
[13:17:32.633]                           restarts <- computeRestarts(cond)
[13:17:32.633]                           for (restart in restarts) {
[13:17:32.633]                             name <- restart$name
[13:17:32.633]                             if (is.null(name)) 
[13:17:32.633]                               next
[13:17:32.633]                             if (!grepl(pattern, name)) 
[13:17:32.633]                               next
[13:17:32.633]                             invokeRestart(restart)
[13:17:32.633]                             muffled <- TRUE
[13:17:32.633]                             break
[13:17:32.633]                           }
[13:17:32.633]                         }
[13:17:32.633]                       }
[13:17:32.633]                       invisible(muffled)
[13:17:32.633]                     }
[13:17:32.633]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.633]                   }
[13:17:32.633]                 }
[13:17:32.633]                 else {
[13:17:32.633]                   if (TRUE) {
[13:17:32.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.633]                     {
[13:17:32.633]                       inherits <- base::inherits
[13:17:32.633]                       invokeRestart <- base::invokeRestart
[13:17:32.633]                       is.null <- base::is.null
[13:17:32.633]                       muffled <- FALSE
[13:17:32.633]                       if (inherits(cond, "message")) {
[13:17:32.633]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.633]                         if (muffled) 
[13:17:32.633]                           invokeRestart("muffleMessage")
[13:17:32.633]                       }
[13:17:32.633]                       else if (inherits(cond, "warning")) {
[13:17:32.633]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.633]                         if (muffled) 
[13:17:32.633]                           invokeRestart("muffleWarning")
[13:17:32.633]                       }
[13:17:32.633]                       else if (inherits(cond, "condition")) {
[13:17:32.633]                         if (!is.null(pattern)) {
[13:17:32.633]                           computeRestarts <- base::computeRestarts
[13:17:32.633]                           grepl <- base::grepl
[13:17:32.633]                           restarts <- computeRestarts(cond)
[13:17:32.633]                           for (restart in restarts) {
[13:17:32.633]                             name <- restart$name
[13:17:32.633]                             if (is.null(name)) 
[13:17:32.633]                               next
[13:17:32.633]                             if (!grepl(pattern, name)) 
[13:17:32.633]                               next
[13:17:32.633]                             invokeRestart(restart)
[13:17:32.633]                             muffled <- TRUE
[13:17:32.633]                             break
[13:17:32.633]                           }
[13:17:32.633]                         }
[13:17:32.633]                       }
[13:17:32.633]                       invisible(muffled)
[13:17:32.633]                     }
[13:17:32.633]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.633]                   }
[13:17:32.633]                 }
[13:17:32.633]             }
[13:17:32.633]         }))
[13:17:32.633]     }, error = function(ex) {
[13:17:32.633]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.633]                 ...future.rng), started = ...future.startTime, 
[13:17:32.633]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.633]             version = "1.8"), class = "FutureResult")
[13:17:32.633]     }, finally = {
[13:17:32.633]         if (!identical(...future.workdir, getwd())) 
[13:17:32.633]             setwd(...future.workdir)
[13:17:32.633]         {
[13:17:32.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.633]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.633]             }
[13:17:32.633]             base::options(...future.oldOptions)
[13:17:32.633]             if (.Platform$OS.type == "windows") {
[13:17:32.633]                 old_names <- names(...future.oldEnvVars)
[13:17:32.633]                 envs <- base::Sys.getenv()
[13:17:32.633]                 names <- names(envs)
[13:17:32.633]                 common <- intersect(names, old_names)
[13:17:32.633]                 added <- setdiff(names, old_names)
[13:17:32.633]                 removed <- setdiff(old_names, names)
[13:17:32.633]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.633]                   envs[common]]
[13:17:32.633]                 NAMES <- toupper(changed)
[13:17:32.633]                 args <- list()
[13:17:32.633]                 for (kk in seq_along(NAMES)) {
[13:17:32.633]                   name <- changed[[kk]]
[13:17:32.633]                   NAME <- NAMES[[kk]]
[13:17:32.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.633]                     next
[13:17:32.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.633]                 }
[13:17:32.633]                 NAMES <- toupper(added)
[13:17:32.633]                 for (kk in seq_along(NAMES)) {
[13:17:32.633]                   name <- added[[kk]]
[13:17:32.633]                   NAME <- NAMES[[kk]]
[13:17:32.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.633]                     next
[13:17:32.633]                   args[[name]] <- ""
[13:17:32.633]                 }
[13:17:32.633]                 NAMES <- toupper(removed)
[13:17:32.633]                 for (kk in seq_along(NAMES)) {
[13:17:32.633]                   name <- removed[[kk]]
[13:17:32.633]                   NAME <- NAMES[[kk]]
[13:17:32.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.633]                     next
[13:17:32.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.633]                 }
[13:17:32.633]                 if (length(args) > 0) 
[13:17:32.633]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.633]             }
[13:17:32.633]             else {
[13:17:32.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.633]             }
[13:17:32.633]             {
[13:17:32.633]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.633]                   0L) {
[13:17:32.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.633]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.633]                   base::options(opts)
[13:17:32.633]                 }
[13:17:32.633]                 {
[13:17:32.633]                   {
[13:17:32.633]                     NULL
[13:17:32.633]                     RNGkind("Mersenne-Twister")
[13:17:32.633]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:32.633]                       inherits = FALSE)
[13:17:32.633]                   }
[13:17:32.633]                   options(future.plan = NULL)
[13:17:32.633]                   if (is.na(NA_character_)) 
[13:17:32.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.633]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:32.633]                   {
[13:17:32.633]                     future <- SequentialFuture(..., envir = envir)
[13:17:32.633]                     if (!future$lazy) 
[13:17:32.633]                       future <- run(future)
[13:17:32.633]                     invisible(future)
[13:17:32.633]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.633]                 }
[13:17:32.633]             }
[13:17:32.633]         }
[13:17:32.633]     })
[13:17:32.633]     if (TRUE) {
[13:17:32.633]         base::sink(type = "output", split = FALSE)
[13:17:32.633]         if (TRUE) {
[13:17:32.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.633]         }
[13:17:32.633]         else {
[13:17:32.633]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.633]         }
[13:17:32.633]         base::close(...future.stdout)
[13:17:32.633]         ...future.stdout <- NULL
[13:17:32.633]     }
[13:17:32.633]     ...future.result$conditions <- ...future.conditions
[13:17:32.633]     ...future.result$finished <- base::Sys.time()
[13:17:32.633]     ...future.result
[13:17:32.633] }
[13:17:32.635] assign_globals() ...
[13:17:32.635] List of 5
[13:17:32.635]  $ ...future.FUN            :function (x, ...)  
[13:17:32.635]  $ future.call.arguments    :List of 1
[13:17:32.635]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.635]  $ ...future.elements_ii    :List of 3
[13:17:32.635]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.635]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:32.635]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:32.635]  $ ...future.seeds_ii       : NULL
[13:17:32.635]  $ ...future.globals.maxSize: NULL
[13:17:32.635]  - attr(*, "resolved")= logi FALSE
[13:17:32.635]  - attr(*, "total_size")= num 1328
[13:17:32.635]  - attr(*, "where")=List of 5
[13:17:32.635]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.635]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.635]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.635]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.635]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.635]  - attr(*, "already-done")= logi TRUE
[13:17:32.642] - copied ‘...future.FUN’ to environment
[13:17:32.642] - copied ‘future.call.arguments’ to environment
[13:17:32.642] - copied ‘...future.elements_ii’ to environment
[13:17:32.642] - copied ‘...future.seeds_ii’ to environment
[13:17:32.642] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.642] assign_globals() ... done
[13:17:32.642] plan(): Setting new future strategy stack:
[13:17:32.642] List of future strategies:
[13:17:32.642] 1. sequential:
[13:17:32.642]    - args: function (..., envir = parent.frame())
[13:17:32.642]    - tweaked: FALSE
[13:17:32.642]    - call: NULL
[13:17:32.643] plan(): nbrOfWorkers() = 1
[13:17:32.644] plan(): Setting new future strategy stack:
[13:17:32.644] List of future strategies:
[13:17:32.644] 1. sequential:
[13:17:32.644]    - args: function (..., envir = parent.frame())
[13:17:32.644]    - tweaked: FALSE
[13:17:32.644]    - call: plan(strategy)
[13:17:32.644] plan(): nbrOfWorkers() = 1
[13:17:32.645] SequentialFuture started (and completed)
[13:17:32.645] - Launch lazy future ... done
[13:17:32.645] run() for ‘SequentialFuture’ ... done
[13:17:32.645] Created future:
[13:17:32.645] SequentialFuture:
[13:17:32.645] Label: ‘future_eapply-1’
[13:17:32.645] Expression:
[13:17:32.645] {
[13:17:32.645]     do.call(function(...) {
[13:17:32.645]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.645]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.645]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.645]             on.exit(options(oopts), add = TRUE)
[13:17:32.645]         }
[13:17:32.645]         {
[13:17:32.645]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.645]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.645]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.645]             })
[13:17:32.645]         }
[13:17:32.645]     }, args = future.call.arguments)
[13:17:32.645] }
[13:17:32.645] Lazy evaluation: FALSE
[13:17:32.645] Asynchronous evaluation: FALSE
[13:17:32.645] Local evaluation: TRUE
[13:17:32.645] Environment: R_GlobalEnv
[13:17:32.645] Capture standard output: TRUE
[13:17:32.645] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.645] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.645] Packages: 1 packages (‘stats’)
[13:17:32.645] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.645] Resolved: TRUE
[13:17:32.645] Value: 1.29 KiB of class ‘list’
[13:17:32.645] Early signaling: FALSE
[13:17:32.645] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.645] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.646] Chunk #1 of 1 ... DONE
[13:17:32.646] Launching 1 futures (chunks) ... DONE
[13:17:32.646] Resolving 1 futures (chunks) ...
[13:17:32.646] resolve() on list ...
[13:17:32.646]  recursive: 0
[13:17:32.646]  length: 1
[13:17:32.646] 
[13:17:32.647] resolved() for ‘SequentialFuture’ ...
[13:17:32.647] - state: ‘finished’
[13:17:32.647] - run: TRUE
[13:17:32.647] - result: ‘FutureResult’
[13:17:32.647] resolved() for ‘SequentialFuture’ ... done
[13:17:32.647] Future #1
[13:17:32.647] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:32.647] - nx: 1
[13:17:32.647] - relay: TRUE
[13:17:32.647] - stdout: TRUE
[13:17:32.647] - signal: TRUE
[13:17:32.648] - resignal: FALSE
[13:17:32.648] - force: TRUE
[13:17:32.648] - relayed: [n=1] FALSE
[13:17:32.648] - queued futures: [n=1] FALSE
[13:17:32.648]  - until=1
[13:17:32.648]  - relaying element #1
[13:17:32.648] - relayed: [n=1] TRUE
[13:17:32.648] - queued futures: [n=1] TRUE
[13:17:32.648] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:32.648]  length: 0 (resolved future 1)
[13:17:32.649] Relaying remaining futures
[13:17:32.649] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.649] - nx: 1
[13:17:32.649] - relay: TRUE
[13:17:32.649] - stdout: TRUE
[13:17:32.649] - signal: TRUE
[13:17:32.649] - resignal: FALSE
[13:17:32.649] - force: TRUE
[13:17:32.649] - relayed: [n=1] TRUE
[13:17:32.649] - queued futures: [n=1] TRUE
 - flush all
[13:17:32.649] - relayed: [n=1] TRUE
[13:17:32.649] - queued futures: [n=1] TRUE
[13:17:32.650] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.650] resolve() on list ... DONE
[13:17:32.650]  - Number of value chunks collected: 1
[13:17:32.650] Resolving 1 futures (chunks) ... DONE
[13:17:32.650] Reducing values from 1 chunks ...
[13:17:32.650]  - Number of values collected after concatenation: 3
[13:17:32.650]  - Number of values expected: 3
[13:17:32.650] Reducing values from 1 chunks ... DONE
[13:17:32.650] future_lapply() ... DONE
[13:17:32.652] future_lapply() ...
[13:17:32.652] Number of chunks: 1
[13:17:32.652] getGlobalsAndPackagesXApply() ...
[13:17:32.652]  - future.globals: TRUE
[13:17:32.652] getGlobalsAndPackages() ...
[13:17:32.652] Searching for globals...
[13:17:32.653] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.654] Searching for globals ... DONE
[13:17:32.654] Resolving globals: FALSE
[13:17:32.654] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:32.654] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:32.654] - globals: [1] ‘FUN’
[13:17:32.655] - packages: [1] ‘stats’
[13:17:32.655] getGlobalsAndPackages() ... DONE
[13:17:32.655]  - globals found/used: [n=1] ‘FUN’
[13:17:32.655]  - needed namespaces: [n=1] ‘stats’
[13:17:32.655] Finding globals ... DONE
[13:17:32.655]  - use_args: TRUE
[13:17:32.655]  - Getting '...' globals ...
[13:17:32.655] resolve() on list ...
[13:17:32.655]  recursive: 0
[13:17:32.656]  length: 1
[13:17:32.656]  elements: ‘...’
[13:17:32.656]  length: 0 (resolved future 1)
[13:17:32.656] resolve() on list ... DONE
[13:17:32.656]    - '...' content: [n=0] 
[13:17:32.656] List of 1
[13:17:32.656]  $ ...: list()
[13:17:32.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.656]  - attr(*, "where")=List of 1
[13:17:32.656]   ..$ ...:<environment: 0x55be3d8565c8> 
[13:17:32.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.656]  - attr(*, "resolved")= logi TRUE
[13:17:32.656]  - attr(*, "total_size")= num NA
[13:17:32.658]  - Getting '...' globals ... DONE
[13:17:32.659] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.659] List of 2
[13:17:32.659]  $ ...future.FUN:function (x, ...)  
[13:17:32.659]  $ ...          : list()
[13:17:32.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.659]  - attr(*, "where")=List of 2
[13:17:32.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.659]   ..$ ...          :<environment: 0x55be3d8565c8> 
[13:17:32.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.659]  - attr(*, "resolved")= logi FALSE
[13:17:32.659]  - attr(*, "total_size")= num 1248
[13:17:32.661] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:32.661] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.663] Number of futures (= number of chunks): 1
[13:17:32.663] Launching 1 futures (chunks) ...
[13:17:32.663] Chunk #1 of 1 ...
[13:17:32.663]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.663] getGlobalsAndPackages() ...
[13:17:32.663] Searching for globals...
[13:17:32.664] 
[13:17:32.664] Searching for globals ... DONE
[13:17:32.664] - globals: [0] <none>
[13:17:32.664] getGlobalsAndPackages() ... DONE
[13:17:32.664]    + additional globals found: [n=0] 
[13:17:32.664]    + additional namespaces needed: [n=0] 
[13:17:32.664]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.664]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:32.664]  - seeds: <none>
[13:17:32.665] getGlobalsAndPackages() ...
[13:17:32.665] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.665] Resolving globals: FALSE
[13:17:32.665] Tweak future expression to call with '...' arguments ...
[13:17:32.665] {
[13:17:32.665]     do.call(function(...) {
[13:17:32.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.665]             on.exit(options(oopts), add = TRUE)
[13:17:32.665]         }
[13:17:32.665]         {
[13:17:32.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.665]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.665]             })
[13:17:32.665]         }
[13:17:32.665]     }, args = future.call.arguments)
[13:17:32.665] }
[13:17:32.665] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.666] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.666] - packages: [1] ‘stats’
[13:17:32.666] getGlobalsAndPackages() ... DONE
[13:17:32.666] run() for ‘Future’ ...
[13:17:32.666] - state: ‘created’
[13:17:32.666] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:32.667] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:32.667]   - Field: ‘label’
[13:17:32.667]   - Field: ‘local’
[13:17:32.667]   - Field: ‘owner’
[13:17:32.667]   - Field: ‘envir’
[13:17:32.667]   - Field: ‘packages’
[13:17:32.667]   - Field: ‘gc’
[13:17:32.667]   - Field: ‘conditions’
[13:17:32.667]   - Field: ‘expr’
[13:17:32.668]   - Field: ‘uuid’
[13:17:32.668]   - Field: ‘seed’
[13:17:32.668]   - Field: ‘version’
[13:17:32.668]   - Field: ‘result’
[13:17:32.668]   - Field: ‘asynchronous’
[13:17:32.668]   - Field: ‘calls’
[13:17:32.668]   - Field: ‘globals’
[13:17:32.668]   - Field: ‘stdout’
[13:17:32.668]   - Field: ‘earlySignal’
[13:17:32.668]   - Field: ‘lazy’
[13:17:32.668]   - Field: ‘state’
[13:17:32.669] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:32.669] - Launch lazy future ...
[13:17:32.669] Packages needed by the future expression (n = 1): ‘stats’
[13:17:32.669] Packages needed by future strategies (n = 0): <none>
[13:17:32.669] {
[13:17:32.669]     {
[13:17:32.669]         {
[13:17:32.669]             ...future.startTime <- base::Sys.time()
[13:17:32.669]             {
[13:17:32.669]                 {
[13:17:32.669]                   {
[13:17:32.669]                     {
[13:17:32.669]                       base::local({
[13:17:32.669]                         has_future <- base::requireNamespace("future", 
[13:17:32.669]                           quietly = TRUE)
[13:17:32.669]                         if (has_future) {
[13:17:32.669]                           ns <- base::getNamespace("future")
[13:17:32.669]                           version <- ns[[".package"]][["version"]]
[13:17:32.669]                           if (is.null(version)) 
[13:17:32.669]                             version <- utils::packageVersion("future")
[13:17:32.669]                         }
[13:17:32.669]                         else {
[13:17:32.669]                           version <- NULL
[13:17:32.669]                         }
[13:17:32.669]                         if (!has_future || version < "1.8.0") {
[13:17:32.669]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.669]                             "", base::R.version$version.string), 
[13:17:32.669]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.669]                               "release", "version")], collapse = " "), 
[13:17:32.669]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.669]                             info)
[13:17:32.669]                           info <- base::paste(info, collapse = "; ")
[13:17:32.669]                           if (!has_future) {
[13:17:32.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.669]                               info)
[13:17:32.669]                           }
[13:17:32.669]                           else {
[13:17:32.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.669]                               info, version)
[13:17:32.669]                           }
[13:17:32.669]                           base::stop(msg)
[13:17:32.669]                         }
[13:17:32.669]                       })
[13:17:32.669]                     }
[13:17:32.669]                     base::local({
[13:17:32.669]                       for (pkg in "stats") {
[13:17:32.669]                         base::loadNamespace(pkg)
[13:17:32.669]                         base::library(pkg, character.only = TRUE)
[13:17:32.669]                       }
[13:17:32.669]                     })
[13:17:32.669]                   }
[13:17:32.669]                   options(future.plan = NULL)
[13:17:32.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.669]                 }
[13:17:32.669]                 ...future.workdir <- getwd()
[13:17:32.669]             }
[13:17:32.669]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.669]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.669]         }
[13:17:32.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.669]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:32.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.669]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.669]             base::names(...future.oldOptions))
[13:17:32.669]     }
[13:17:32.669]     if (FALSE) {
[13:17:32.669]     }
[13:17:32.669]     else {
[13:17:32.669]         if (TRUE) {
[13:17:32.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.669]                 open = "w")
[13:17:32.669]         }
[13:17:32.669]         else {
[13:17:32.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.669]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.669]         }
[13:17:32.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.669]             base::sink(type = "output", split = FALSE)
[13:17:32.669]             base::close(...future.stdout)
[13:17:32.669]         }, add = TRUE)
[13:17:32.669]     }
[13:17:32.669]     ...future.frame <- base::sys.nframe()
[13:17:32.669]     ...future.conditions <- base::list()
[13:17:32.669]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.669]     if (FALSE) {
[13:17:32.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.669]     }
[13:17:32.669]     ...future.result <- base::tryCatch({
[13:17:32.669]         base::withCallingHandlers({
[13:17:32.669]             ...future.value <- base::withVisible(base::local({
[13:17:32.669]                 do.call(function(...) {
[13:17:32.669]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.669]                   if (!identical(...future.globals.maxSize.org, 
[13:17:32.669]                     ...future.globals.maxSize)) {
[13:17:32.669]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.669]                     on.exit(options(oopts), add = TRUE)
[13:17:32.669]                   }
[13:17:32.669]                   {
[13:17:32.669]                     lapply(seq_along(...future.elements_ii), 
[13:17:32.669]                       FUN = function(jj) {
[13:17:32.669]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.669]                         ...future.FUN(...future.X_jj, ...)
[13:17:32.669]                       })
[13:17:32.669]                   }
[13:17:32.669]                 }, args = future.call.arguments)
[13:17:32.669]             }))
[13:17:32.669]             future::FutureResult(value = ...future.value$value, 
[13:17:32.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.669]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.669]                     ...future.globalenv.names))
[13:17:32.669]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.669]         }, condition = base::local({
[13:17:32.669]             c <- base::c
[13:17:32.669]             inherits <- base::inherits
[13:17:32.669]             invokeRestart <- base::invokeRestart
[13:17:32.669]             length <- base::length
[13:17:32.669]             list <- base::list
[13:17:32.669]             seq.int <- base::seq.int
[13:17:32.669]             signalCondition <- base::signalCondition
[13:17:32.669]             sys.calls <- base::sys.calls
[13:17:32.669]             `[[` <- base::`[[`
[13:17:32.669]             `+` <- base::`+`
[13:17:32.669]             `<<-` <- base::`<<-`
[13:17:32.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.669]                   3L)]
[13:17:32.669]             }
[13:17:32.669]             function(cond) {
[13:17:32.669]                 is_error <- inherits(cond, "error")
[13:17:32.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.669]                   NULL)
[13:17:32.669]                 if (is_error) {
[13:17:32.669]                   sessionInformation <- function() {
[13:17:32.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.669]                       search = base::search(), system = base::Sys.info())
[13:17:32.669]                   }
[13:17:32.669]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.669]                     cond$call), session = sessionInformation(), 
[13:17:32.669]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.669]                   signalCondition(cond)
[13:17:32.669]                 }
[13:17:32.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.669]                 "immediateCondition"))) {
[13:17:32.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.669]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.669]                   if (TRUE && !signal) {
[13:17:32.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.669]                     {
[13:17:32.669]                       inherits <- base::inherits
[13:17:32.669]                       invokeRestart <- base::invokeRestart
[13:17:32.669]                       is.null <- base::is.null
[13:17:32.669]                       muffled <- FALSE
[13:17:32.669]                       if (inherits(cond, "message")) {
[13:17:32.669]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.669]                         if (muffled) 
[13:17:32.669]                           invokeRestart("muffleMessage")
[13:17:32.669]                       }
[13:17:32.669]                       else if (inherits(cond, "warning")) {
[13:17:32.669]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.669]                         if (muffled) 
[13:17:32.669]                           invokeRestart("muffleWarning")
[13:17:32.669]                       }
[13:17:32.669]                       else if (inherits(cond, "condition")) {
[13:17:32.669]                         if (!is.null(pattern)) {
[13:17:32.669]                           computeRestarts <- base::computeRestarts
[13:17:32.669]                           grepl <- base::grepl
[13:17:32.669]                           restarts <- computeRestarts(cond)
[13:17:32.669]                           for (restart in restarts) {
[13:17:32.669]                             name <- restart$name
[13:17:32.669]                             if (is.null(name)) 
[13:17:32.669]                               next
[13:17:32.669]                             if (!grepl(pattern, name)) 
[13:17:32.669]                               next
[13:17:32.669]                             invokeRestart(restart)
[13:17:32.669]                             muffled <- TRUE
[13:17:32.669]                             break
[13:17:32.669]                           }
[13:17:32.669]                         }
[13:17:32.669]                       }
[13:17:32.669]                       invisible(muffled)
[13:17:32.669]                     }
[13:17:32.669]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.669]                   }
[13:17:32.669]                 }
[13:17:32.669]                 else {
[13:17:32.669]                   if (TRUE) {
[13:17:32.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.669]                     {
[13:17:32.669]                       inherits <- base::inherits
[13:17:32.669]                       invokeRestart <- base::invokeRestart
[13:17:32.669]                       is.null <- base::is.null
[13:17:32.669]                       muffled <- FALSE
[13:17:32.669]                       if (inherits(cond, "message")) {
[13:17:32.669]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.669]                         if (muffled) 
[13:17:32.669]                           invokeRestart("muffleMessage")
[13:17:32.669]                       }
[13:17:32.669]                       else if (inherits(cond, "warning")) {
[13:17:32.669]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.669]                         if (muffled) 
[13:17:32.669]                           invokeRestart("muffleWarning")
[13:17:32.669]                       }
[13:17:32.669]                       else if (inherits(cond, "condition")) {
[13:17:32.669]                         if (!is.null(pattern)) {
[13:17:32.669]                           computeRestarts <- base::computeRestarts
[13:17:32.669]                           grepl <- base::grepl
[13:17:32.669]                           restarts <- computeRestarts(cond)
[13:17:32.669]                           for (restart in restarts) {
[13:17:32.669]                             name <- restart$name
[13:17:32.669]                             if (is.null(name)) 
[13:17:32.669]                               next
[13:17:32.669]                             if (!grepl(pattern, name)) 
[13:17:32.669]                               next
[13:17:32.669]                             invokeRestart(restart)
[13:17:32.669]                             muffled <- TRUE
[13:17:32.669]                             break
[13:17:32.669]                           }
[13:17:32.669]                         }
[13:17:32.669]                       }
[13:17:32.669]                       invisible(muffled)
[13:17:32.669]                     }
[13:17:32.669]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.669]                   }
[13:17:32.669]                 }
[13:17:32.669]             }
[13:17:32.669]         }))
[13:17:32.669]     }, error = function(ex) {
[13:17:32.669]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.669]                 ...future.rng), started = ...future.startTime, 
[13:17:32.669]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.669]             version = "1.8"), class = "FutureResult")
[13:17:32.669]     }, finally = {
[13:17:32.669]         if (!identical(...future.workdir, getwd())) 
[13:17:32.669]             setwd(...future.workdir)
[13:17:32.669]         {
[13:17:32.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.669]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.669]             }
[13:17:32.669]             base::options(...future.oldOptions)
[13:17:32.669]             if (.Platform$OS.type == "windows") {
[13:17:32.669]                 old_names <- names(...future.oldEnvVars)
[13:17:32.669]                 envs <- base::Sys.getenv()
[13:17:32.669]                 names <- names(envs)
[13:17:32.669]                 common <- intersect(names, old_names)
[13:17:32.669]                 added <- setdiff(names, old_names)
[13:17:32.669]                 removed <- setdiff(old_names, names)
[13:17:32.669]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.669]                   envs[common]]
[13:17:32.669]                 NAMES <- toupper(changed)
[13:17:32.669]                 args <- list()
[13:17:32.669]                 for (kk in seq_along(NAMES)) {
[13:17:32.669]                   name <- changed[[kk]]
[13:17:32.669]                   NAME <- NAMES[[kk]]
[13:17:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.669]                     next
[13:17:32.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.669]                 }
[13:17:32.669]                 NAMES <- toupper(added)
[13:17:32.669]                 for (kk in seq_along(NAMES)) {
[13:17:32.669]                   name <- added[[kk]]
[13:17:32.669]                   NAME <- NAMES[[kk]]
[13:17:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.669]                     next
[13:17:32.669]                   args[[name]] <- ""
[13:17:32.669]                 }
[13:17:32.669]                 NAMES <- toupper(removed)
[13:17:32.669]                 for (kk in seq_along(NAMES)) {
[13:17:32.669]                   name <- removed[[kk]]
[13:17:32.669]                   NAME <- NAMES[[kk]]
[13:17:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.669]                     next
[13:17:32.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.669]                 }
[13:17:32.669]                 if (length(args) > 0) 
[13:17:32.669]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.669]             }
[13:17:32.669]             else {
[13:17:32.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.669]             }
[13:17:32.669]             {
[13:17:32.669]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.669]                   0L) {
[13:17:32.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.669]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.669]                   base::options(opts)
[13:17:32.669]                 }
[13:17:32.669]                 {
[13:17:32.669]                   {
[13:17:32.669]                     NULL
[13:17:32.669]                     RNGkind("Mersenne-Twister")
[13:17:32.669]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:32.669]                       inherits = FALSE)
[13:17:32.669]                   }
[13:17:32.669]                   options(future.plan = NULL)
[13:17:32.669]                   if (is.na(NA_character_)) 
[13:17:32.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.669]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:32.669]                   {
[13:17:32.669]                     future <- SequentialFuture(..., envir = envir)
[13:17:32.669]                     if (!future$lazy) 
[13:17:32.669]                       future <- run(future)
[13:17:32.669]                     invisible(future)
[13:17:32.669]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.669]                 }
[13:17:32.669]             }
[13:17:32.669]         }
[13:17:32.669]     })
[13:17:32.669]     if (TRUE) {
[13:17:32.669]         base::sink(type = "output", split = FALSE)
[13:17:32.669]         if (TRUE) {
[13:17:32.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.669]         }
[13:17:32.669]         else {
[13:17:32.669]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.669]         }
[13:17:32.669]         base::close(...future.stdout)
[13:17:32.669]         ...future.stdout <- NULL
[13:17:32.669]     }
[13:17:32.669]     ...future.result$conditions <- ...future.conditions
[13:17:32.669]     ...future.result$finished <- base::Sys.time()
[13:17:32.669]     ...future.result
[13:17:32.669] }
[13:17:32.671] assign_globals() ...
[13:17:32.671] List of 5
[13:17:32.671]  $ ...future.FUN            :function (x, ...)  
[13:17:32.671]  $ future.call.arguments    : list()
[13:17:32.671]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.671]  $ ...future.elements_ii    :List of 3
[13:17:32.671]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.671]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:32.671]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:32.671]  $ ...future.seeds_ii       : NULL
[13:17:32.671]  $ ...future.globals.maxSize: NULL
[13:17:32.671]  - attr(*, "resolved")= logi FALSE
[13:17:32.671]  - attr(*, "total_size")= num 1248
[13:17:32.671]  - attr(*, "where")=List of 5
[13:17:32.671]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.671]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.671]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.671]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.671]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.671]  - attr(*, "already-done")= logi TRUE
[13:17:32.676] - copied ‘...future.FUN’ to environment
[13:17:32.676] - copied ‘future.call.arguments’ to environment
[13:17:32.677] - copied ‘...future.elements_ii’ to environment
[13:17:32.677] - copied ‘...future.seeds_ii’ to environment
[13:17:32.677] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.677] assign_globals() ... done
[13:17:32.677] plan(): Setting new future strategy stack:
[13:17:32.677] List of future strategies:
[13:17:32.677] 1. sequential:
[13:17:32.677]    - args: function (..., envir = parent.frame())
[13:17:32.677]    - tweaked: FALSE
[13:17:32.677]    - call: NULL
[13:17:32.678] plan(): nbrOfWorkers() = 1
[13:17:32.679] plan(): Setting new future strategy stack:
[13:17:32.679] List of future strategies:
[13:17:32.679] 1. sequential:
[13:17:32.679]    - args: function (..., envir = parent.frame())
[13:17:32.679]    - tweaked: FALSE
[13:17:32.679]    - call: plan(strategy)
[13:17:32.679] plan(): nbrOfWorkers() = 1
[13:17:32.679] SequentialFuture started (and completed)
[13:17:32.680] - Launch lazy future ... done
[13:17:32.680] run() for ‘SequentialFuture’ ... done
[13:17:32.680] Created future:
[13:17:32.680] SequentialFuture:
[13:17:32.680] Label: ‘future_eapply-1’
[13:17:32.680] Expression:
[13:17:32.680] {
[13:17:32.680]     do.call(function(...) {
[13:17:32.680]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.680]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.680]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.680]             on.exit(options(oopts), add = TRUE)
[13:17:32.680]         }
[13:17:32.680]         {
[13:17:32.680]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.680]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.680]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.680]             })
[13:17:32.680]         }
[13:17:32.680]     }, args = future.call.arguments)
[13:17:32.680] }
[13:17:32.680] Lazy evaluation: FALSE
[13:17:32.680] Asynchronous evaluation: FALSE
[13:17:32.680] Local evaluation: TRUE
[13:17:32.680] Environment: R_GlobalEnv
[13:17:32.680] Capture standard output: TRUE
[13:17:32.680] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.680] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.680] Packages: 1 packages (‘stats’)
[13:17:32.680] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.680] Resolved: TRUE
[13:17:32.680] Value: 1.71 KiB of class ‘list’
[13:17:32.680] Early signaling: FALSE
[13:17:32.680] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.680] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.681] Chunk #1 of 1 ... DONE
[13:17:32.681] Launching 1 futures (chunks) ... DONE
[13:17:32.681] Resolving 1 futures (chunks) ...
[13:17:32.681] resolve() on list ...
[13:17:32.681]  recursive: 0
[13:17:32.681]  length: 1
[13:17:32.681] 
[13:17:32.682] resolved() for ‘SequentialFuture’ ...
[13:17:32.682] - state: ‘finished’
[13:17:32.682] - run: TRUE
[13:17:32.682] - result: ‘FutureResult’
[13:17:32.682] resolved() for ‘SequentialFuture’ ... done
[13:17:32.682] Future #1
[13:17:32.682] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:32.682] - nx: 1
[13:17:32.682] - relay: TRUE
[13:17:32.682] - stdout: TRUE
[13:17:32.683] - signal: TRUE
[13:17:32.683] - resignal: FALSE
[13:17:32.683] - force: TRUE
[13:17:32.683] - relayed: [n=1] FALSE
[13:17:32.683] - queued futures: [n=1] FALSE
[13:17:32.683]  - until=1
[13:17:32.683]  - relaying element #1
[13:17:32.683] - relayed: [n=1] TRUE
[13:17:32.683] - queued futures: [n=1] TRUE
[13:17:32.683] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:32.683]  length: 0 (resolved future 1)
[13:17:32.684] Relaying remaining futures
[13:17:32.684] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.684] - nx: 1
[13:17:32.684] - relay: TRUE
[13:17:32.684] - stdout: TRUE
[13:17:32.684] - signal: TRUE
[13:17:32.684] - resignal: FALSE
[13:17:32.684] - force: TRUE
[13:17:32.684] - relayed: [n=1] TRUE
[13:17:32.684] - queued futures: [n=1] TRUE
 - flush all
[13:17:32.684] - relayed: [n=1] TRUE
[13:17:32.684] - queued futures: [n=1] TRUE
[13:17:32.685] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.685] resolve() on list ... DONE
[13:17:32.685]  - Number of value chunks collected: 1
[13:17:32.685] Resolving 1 futures (chunks) ... DONE
[13:17:32.685] Reducing values from 1 chunks ...
[13:17:32.685]  - Number of values collected after concatenation: 3
[13:17:32.685]  - Number of values expected: 3
[13:17:32.685] Reducing values from 1 chunks ... DONE
[13:17:32.685] future_lapply() ... DONE
[13:17:32.686] future_lapply() ...
[13:17:32.687] Number of chunks: 1
[13:17:32.688] getGlobalsAndPackagesXApply() ...
[13:17:32.688]  - future.globals: TRUE
[13:17:32.688] getGlobalsAndPackages() ...
[13:17:32.688] Searching for globals...
[13:17:32.689] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.689] Searching for globals ... DONE
[13:17:32.689] Resolving globals: FALSE
[13:17:32.689] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:32.690] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:32.690] - globals: [1] ‘FUN’
[13:17:32.690] - packages: [1] ‘stats’
[13:17:32.690] getGlobalsAndPackages() ... DONE
[13:17:32.690]  - globals found/used: [n=1] ‘FUN’
[13:17:32.690]  - needed namespaces: [n=1] ‘stats’
[13:17:32.690] Finding globals ... DONE
[13:17:32.690]  - use_args: TRUE
[13:17:32.691]  - Getting '...' globals ...
[13:17:32.691] resolve() on list ...
[13:17:32.691]  recursive: 0
[13:17:32.691]  length: 1
[13:17:32.691]  elements: ‘...’
[13:17:32.691]  length: 0 (resolved future 1)
[13:17:32.691] resolve() on list ... DONE
[13:17:32.691]    - '...' content: [n=0] 
[13:17:32.691] List of 1
[13:17:32.691]  $ ...: list()
[13:17:32.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.691]  - attr(*, "where")=List of 1
[13:17:32.691]   ..$ ...:<environment: 0x55be3e35e4e8> 
[13:17:32.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.691]  - attr(*, "resolved")= logi TRUE
[13:17:32.691]  - attr(*, "total_size")= num NA
[13:17:32.694]  - Getting '...' globals ... DONE
[13:17:32.694] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.694] List of 2
[13:17:32.694]  $ ...future.FUN:function (x, ...)  
[13:17:32.694]  $ ...          : list()
[13:17:32.694]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.694]  - attr(*, "where")=List of 2
[13:17:32.694]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.694]   ..$ ...          :<environment: 0x55be3e35e4e8> 
[13:17:32.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.694]  - attr(*, "resolved")= logi FALSE
[13:17:32.694]  - attr(*, "total_size")= num 1248
[13:17:32.697] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:32.697] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.697] Number of futures (= number of chunks): 1
[13:17:32.697] Launching 1 futures (chunks) ...
[13:17:32.697] Chunk #1 of 1 ...
[13:17:32.697]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.697] getGlobalsAndPackages() ...
[13:17:32.698] Searching for globals...
[13:17:32.698] 
[13:17:32.698] Searching for globals ... DONE
[13:17:32.698] - globals: [0] <none>
[13:17:32.698] getGlobalsAndPackages() ... DONE
[13:17:32.698]    + additional globals found: [n=0] 
[13:17:32.698]    + additional namespaces needed: [n=0] 
[13:17:32.698]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.698]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[13:17:32.699]  - seeds: <none>
[13:17:32.699] getGlobalsAndPackages() ...
[13:17:32.699] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.699] Resolving globals: FALSE
[13:17:32.699] Tweak future expression to call with '...' arguments ...
[13:17:32.699] {
[13:17:32.699]     do.call(function(...) {
[13:17:32.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.699]             on.exit(options(oopts), add = TRUE)
[13:17:32.699]         }
[13:17:32.699]         {
[13:17:32.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.699]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.699]             })
[13:17:32.699]         }
[13:17:32.699]     }, args = future.call.arguments)
[13:17:32.699] }
[13:17:32.699] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.700] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.700] - packages: [1] ‘stats’
[13:17:32.700] getGlobalsAndPackages() ... DONE
[13:17:32.700] run() for ‘Future’ ...
[13:17:32.700] - state: ‘created’
[13:17:32.700] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:32.701] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:32.701]   - Field: ‘label’
[13:17:32.701]   - Field: ‘local’
[13:17:32.701]   - Field: ‘owner’
[13:17:32.701]   - Field: ‘envir’
[13:17:32.701]   - Field: ‘packages’
[13:17:32.701]   - Field: ‘gc’
[13:17:32.701]   - Field: ‘conditions’
[13:17:32.702]   - Field: ‘expr’
[13:17:32.702]   - Field: ‘uuid’
[13:17:32.702]   - Field: ‘seed’
[13:17:32.702]   - Field: ‘version’
[13:17:32.702]   - Field: ‘result’
[13:17:32.702]   - Field: ‘asynchronous’
[13:17:32.702]   - Field: ‘calls’
[13:17:32.702]   - Field: ‘globals’
[13:17:32.702]   - Field: ‘stdout’
[13:17:32.702]   - Field: ‘earlySignal’
[13:17:32.702]   - Field: ‘lazy’
[13:17:32.703]   - Field: ‘state’
[13:17:32.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:32.703] - Launch lazy future ...
[13:17:32.703] Packages needed by the future expression (n = 1): ‘stats’
[13:17:32.703] Packages needed by future strategies (n = 0): <none>
[13:17:32.704] {
[13:17:32.704]     {
[13:17:32.704]         {
[13:17:32.704]             ...future.startTime <- base::Sys.time()
[13:17:32.704]             {
[13:17:32.704]                 {
[13:17:32.704]                   {
[13:17:32.704]                     {
[13:17:32.704]                       base::local({
[13:17:32.704]                         has_future <- base::requireNamespace("future", 
[13:17:32.704]                           quietly = TRUE)
[13:17:32.704]                         if (has_future) {
[13:17:32.704]                           ns <- base::getNamespace("future")
[13:17:32.704]                           version <- ns[[".package"]][["version"]]
[13:17:32.704]                           if (is.null(version)) 
[13:17:32.704]                             version <- utils::packageVersion("future")
[13:17:32.704]                         }
[13:17:32.704]                         else {
[13:17:32.704]                           version <- NULL
[13:17:32.704]                         }
[13:17:32.704]                         if (!has_future || version < "1.8.0") {
[13:17:32.704]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.704]                             "", base::R.version$version.string), 
[13:17:32.704]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.704]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.704]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.704]                               "release", "version")], collapse = " "), 
[13:17:32.704]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.704]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.704]                             info)
[13:17:32.704]                           info <- base::paste(info, collapse = "; ")
[13:17:32.704]                           if (!has_future) {
[13:17:32.704]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.704]                               info)
[13:17:32.704]                           }
[13:17:32.704]                           else {
[13:17:32.704]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.704]                               info, version)
[13:17:32.704]                           }
[13:17:32.704]                           base::stop(msg)
[13:17:32.704]                         }
[13:17:32.704]                       })
[13:17:32.704]                     }
[13:17:32.704]                     base::local({
[13:17:32.704]                       for (pkg in "stats") {
[13:17:32.704]                         base::loadNamespace(pkg)
[13:17:32.704]                         base::library(pkg, character.only = TRUE)
[13:17:32.704]                       }
[13:17:32.704]                     })
[13:17:32.704]                   }
[13:17:32.704]                   options(future.plan = NULL)
[13:17:32.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.704]                 }
[13:17:32.704]                 ...future.workdir <- getwd()
[13:17:32.704]             }
[13:17:32.704]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.704]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.704]         }
[13:17:32.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.704]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[13:17:32.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.704]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.704]             base::names(...future.oldOptions))
[13:17:32.704]     }
[13:17:32.704]     if (FALSE) {
[13:17:32.704]     }
[13:17:32.704]     else {
[13:17:32.704]         if (TRUE) {
[13:17:32.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.704]                 open = "w")
[13:17:32.704]         }
[13:17:32.704]         else {
[13:17:32.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.704]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.704]         }
[13:17:32.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.704]             base::sink(type = "output", split = FALSE)
[13:17:32.704]             base::close(...future.stdout)
[13:17:32.704]         }, add = TRUE)
[13:17:32.704]     }
[13:17:32.704]     ...future.frame <- base::sys.nframe()
[13:17:32.704]     ...future.conditions <- base::list()
[13:17:32.704]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.704]     if (FALSE) {
[13:17:32.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.704]     }
[13:17:32.704]     ...future.result <- base::tryCatch({
[13:17:32.704]         base::withCallingHandlers({
[13:17:32.704]             ...future.value <- base::withVisible(base::local({
[13:17:32.704]                 do.call(function(...) {
[13:17:32.704]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.704]                   if (!identical(...future.globals.maxSize.org, 
[13:17:32.704]                     ...future.globals.maxSize)) {
[13:17:32.704]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.704]                     on.exit(options(oopts), add = TRUE)
[13:17:32.704]                   }
[13:17:32.704]                   {
[13:17:32.704]                     lapply(seq_along(...future.elements_ii), 
[13:17:32.704]                       FUN = function(jj) {
[13:17:32.704]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.704]                         ...future.FUN(...future.X_jj, ...)
[13:17:32.704]                       })
[13:17:32.704]                   }
[13:17:32.704]                 }, args = future.call.arguments)
[13:17:32.704]             }))
[13:17:32.704]             future::FutureResult(value = ...future.value$value, 
[13:17:32.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.704]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.704]                     ...future.globalenv.names))
[13:17:32.704]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.704]         }, condition = base::local({
[13:17:32.704]             c <- base::c
[13:17:32.704]             inherits <- base::inherits
[13:17:32.704]             invokeRestart <- base::invokeRestart
[13:17:32.704]             length <- base::length
[13:17:32.704]             list <- base::list
[13:17:32.704]             seq.int <- base::seq.int
[13:17:32.704]             signalCondition <- base::signalCondition
[13:17:32.704]             sys.calls <- base::sys.calls
[13:17:32.704]             `[[` <- base::`[[`
[13:17:32.704]             `+` <- base::`+`
[13:17:32.704]             `<<-` <- base::`<<-`
[13:17:32.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.704]                   3L)]
[13:17:32.704]             }
[13:17:32.704]             function(cond) {
[13:17:32.704]                 is_error <- inherits(cond, "error")
[13:17:32.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.704]                   NULL)
[13:17:32.704]                 if (is_error) {
[13:17:32.704]                   sessionInformation <- function() {
[13:17:32.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.704]                       search = base::search(), system = base::Sys.info())
[13:17:32.704]                   }
[13:17:32.704]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.704]                     cond$call), session = sessionInformation(), 
[13:17:32.704]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.704]                   signalCondition(cond)
[13:17:32.704]                 }
[13:17:32.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.704]                 "immediateCondition"))) {
[13:17:32.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.704]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.704]                   if (TRUE && !signal) {
[13:17:32.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.704]                     {
[13:17:32.704]                       inherits <- base::inherits
[13:17:32.704]                       invokeRestart <- base::invokeRestart
[13:17:32.704]                       is.null <- base::is.null
[13:17:32.704]                       muffled <- FALSE
[13:17:32.704]                       if (inherits(cond, "message")) {
[13:17:32.704]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.704]                         if (muffled) 
[13:17:32.704]                           invokeRestart("muffleMessage")
[13:17:32.704]                       }
[13:17:32.704]                       else if (inherits(cond, "warning")) {
[13:17:32.704]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.704]                         if (muffled) 
[13:17:32.704]                           invokeRestart("muffleWarning")
[13:17:32.704]                       }
[13:17:32.704]                       else if (inherits(cond, "condition")) {
[13:17:32.704]                         if (!is.null(pattern)) {
[13:17:32.704]                           computeRestarts <- base::computeRestarts
[13:17:32.704]                           grepl <- base::grepl
[13:17:32.704]                           restarts <- computeRestarts(cond)
[13:17:32.704]                           for (restart in restarts) {
[13:17:32.704]                             name <- restart$name
[13:17:32.704]                             if (is.null(name)) 
[13:17:32.704]                               next
[13:17:32.704]                             if (!grepl(pattern, name)) 
[13:17:32.704]                               next
[13:17:32.704]                             invokeRestart(restart)
[13:17:32.704]                             muffled <- TRUE
[13:17:32.704]                             break
[13:17:32.704]                           }
[13:17:32.704]                         }
[13:17:32.704]                       }
[13:17:32.704]                       invisible(muffled)
[13:17:32.704]                     }
[13:17:32.704]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.704]                   }
[13:17:32.704]                 }
[13:17:32.704]                 else {
[13:17:32.704]                   if (TRUE) {
[13:17:32.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.704]                     {
[13:17:32.704]                       inherits <- base::inherits
[13:17:32.704]                       invokeRestart <- base::invokeRestart
[13:17:32.704]                       is.null <- base::is.null
[13:17:32.704]                       muffled <- FALSE
[13:17:32.704]                       if (inherits(cond, "message")) {
[13:17:32.704]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.704]                         if (muffled) 
[13:17:32.704]                           invokeRestart("muffleMessage")
[13:17:32.704]                       }
[13:17:32.704]                       else if (inherits(cond, "warning")) {
[13:17:32.704]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.704]                         if (muffled) 
[13:17:32.704]                           invokeRestart("muffleWarning")
[13:17:32.704]                       }
[13:17:32.704]                       else if (inherits(cond, "condition")) {
[13:17:32.704]                         if (!is.null(pattern)) {
[13:17:32.704]                           computeRestarts <- base::computeRestarts
[13:17:32.704]                           grepl <- base::grepl
[13:17:32.704]                           restarts <- computeRestarts(cond)
[13:17:32.704]                           for (restart in restarts) {
[13:17:32.704]                             name <- restart$name
[13:17:32.704]                             if (is.null(name)) 
[13:17:32.704]                               next
[13:17:32.704]                             if (!grepl(pattern, name)) 
[13:17:32.704]                               next
[13:17:32.704]                             invokeRestart(restart)
[13:17:32.704]                             muffled <- TRUE
[13:17:32.704]                             break
[13:17:32.704]                           }
[13:17:32.704]                         }
[13:17:32.704]                       }
[13:17:32.704]                       invisible(muffled)
[13:17:32.704]                     }
[13:17:32.704]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.704]                   }
[13:17:32.704]                 }
[13:17:32.704]             }
[13:17:32.704]         }))
[13:17:32.704]     }, error = function(ex) {
[13:17:32.704]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.704]                 ...future.rng), started = ...future.startTime, 
[13:17:32.704]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.704]             version = "1.8"), class = "FutureResult")
[13:17:32.704]     }, finally = {
[13:17:32.704]         if (!identical(...future.workdir, getwd())) 
[13:17:32.704]             setwd(...future.workdir)
[13:17:32.704]         {
[13:17:32.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.704]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.704]             }
[13:17:32.704]             base::options(...future.oldOptions)
[13:17:32.704]             if (.Platform$OS.type == "windows") {
[13:17:32.704]                 old_names <- names(...future.oldEnvVars)
[13:17:32.704]                 envs <- base::Sys.getenv()
[13:17:32.704]                 names <- names(envs)
[13:17:32.704]                 common <- intersect(names, old_names)
[13:17:32.704]                 added <- setdiff(names, old_names)
[13:17:32.704]                 removed <- setdiff(old_names, names)
[13:17:32.704]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.704]                   envs[common]]
[13:17:32.704]                 NAMES <- toupper(changed)
[13:17:32.704]                 args <- list()
[13:17:32.704]                 for (kk in seq_along(NAMES)) {
[13:17:32.704]                   name <- changed[[kk]]
[13:17:32.704]                   NAME <- NAMES[[kk]]
[13:17:32.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.704]                     next
[13:17:32.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.704]                 }
[13:17:32.704]                 NAMES <- toupper(added)
[13:17:32.704]                 for (kk in seq_along(NAMES)) {
[13:17:32.704]                   name <- added[[kk]]
[13:17:32.704]                   NAME <- NAMES[[kk]]
[13:17:32.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.704]                     next
[13:17:32.704]                   args[[name]] <- ""
[13:17:32.704]                 }
[13:17:32.704]                 NAMES <- toupper(removed)
[13:17:32.704]                 for (kk in seq_along(NAMES)) {
[13:17:32.704]                   name <- removed[[kk]]
[13:17:32.704]                   NAME <- NAMES[[kk]]
[13:17:32.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.704]                     next
[13:17:32.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.704]                 }
[13:17:32.704]                 if (length(args) > 0) 
[13:17:32.704]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.704]             }
[13:17:32.704]             else {
[13:17:32.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.704]             }
[13:17:32.704]             {
[13:17:32.704]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.704]                   0L) {
[13:17:32.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.704]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.704]                   base::options(opts)
[13:17:32.704]                 }
[13:17:32.704]                 {
[13:17:32.704]                   {
[13:17:32.704]                     NULL
[13:17:32.704]                     RNGkind("Mersenne-Twister")
[13:17:32.704]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:32.704]                       inherits = FALSE)
[13:17:32.704]                   }
[13:17:32.704]                   options(future.plan = NULL)
[13:17:32.704]                   if (is.na(NA_character_)) 
[13:17:32.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.704]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:32.704]                   {
[13:17:32.704]                     future <- SequentialFuture(..., envir = envir)
[13:17:32.704]                     if (!future$lazy) 
[13:17:32.704]                       future <- run(future)
[13:17:32.704]                     invisible(future)
[13:17:32.704]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.704]                 }
[13:17:32.704]             }
[13:17:32.704]         }
[13:17:32.704]     })
[13:17:32.704]     if (TRUE) {
[13:17:32.704]         base::sink(type = "output", split = FALSE)
[13:17:32.704]         if (TRUE) {
[13:17:32.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.704]         }
[13:17:32.704]         else {
[13:17:32.704]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.704]         }
[13:17:32.704]         base::close(...future.stdout)
[13:17:32.704]         ...future.stdout <- NULL
[13:17:32.704]     }
[13:17:32.704]     ...future.result$conditions <- ...future.conditions
[13:17:32.704]     ...future.result$finished <- base::Sys.time()
[13:17:32.704]     ...future.result
[13:17:32.704] }
[13:17:32.705] assign_globals() ...
[13:17:32.705] List of 5
[13:17:32.705]  $ ...future.FUN            :function (x, ...)  
[13:17:32.705]  $ future.call.arguments    : list()
[13:17:32.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.705]  $ ...future.elements_ii    :List of 3
[13:17:32.705]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.705]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:32.705]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:32.705]  $ ...future.seeds_ii       : NULL
[13:17:32.705]  $ ...future.globals.maxSize: NULL
[13:17:32.705]  - attr(*, "resolved")= logi FALSE
[13:17:32.705]  - attr(*, "total_size")= num 1248
[13:17:32.705]  - attr(*, "where")=List of 5
[13:17:32.705]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.705]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.705]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.705]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.705]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.705]  - attr(*, "already-done")= logi TRUE
[13:17:32.712] - copied ‘...future.FUN’ to environment
[13:17:32.713] - copied ‘future.call.arguments’ to environment
[13:17:32.713] - copied ‘...future.elements_ii’ to environment
[13:17:32.713] - copied ‘...future.seeds_ii’ to environment
[13:17:32.713] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.713] assign_globals() ... done
[13:17:32.713] plan(): Setting new future strategy stack:
[13:17:32.714] List of future strategies:
[13:17:32.714] 1. sequential:
[13:17:32.714]    - args: function (..., envir = parent.frame())
[13:17:32.714]    - tweaked: FALSE
[13:17:32.714]    - call: NULL
[13:17:32.714] plan(): nbrOfWorkers() = 1
[13:17:32.715] plan(): Setting new future strategy stack:
[13:17:32.715] List of future strategies:
[13:17:32.715] 1. sequential:
[13:17:32.715]    - args: function (..., envir = parent.frame())
[13:17:32.715]    - tweaked: FALSE
[13:17:32.715]    - call: plan(strategy)
[13:17:32.716] plan(): nbrOfWorkers() = 1
[13:17:32.716] SequentialFuture started (and completed)
[13:17:32.716] - Launch lazy future ... done
[13:17:32.716] run() for ‘SequentialFuture’ ... done
[13:17:32.716] Created future:
[13:17:32.716] SequentialFuture:
[13:17:32.716] Label: ‘future_eapply-1’
[13:17:32.716] Expression:
[13:17:32.716] {
[13:17:32.716]     do.call(function(...) {
[13:17:32.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.716]             on.exit(options(oopts), add = TRUE)
[13:17:32.716]         }
[13:17:32.716]         {
[13:17:32.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.716]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.716]             })
[13:17:32.716]         }
[13:17:32.716]     }, args = future.call.arguments)
[13:17:32.716] }
[13:17:32.716] Lazy evaluation: FALSE
[13:17:32.716] Asynchronous evaluation: FALSE
[13:17:32.716] Local evaluation: TRUE
[13:17:32.716] Environment: R_GlobalEnv
[13:17:32.716] Capture standard output: TRUE
[13:17:32.716] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.716] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.716] Packages: 1 packages (‘stats’)
[13:17:32.716] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.716] Resolved: TRUE
[13:17:32.716] Value: 1.71 KiB of class ‘list’
[13:17:32.716] Early signaling: FALSE
[13:17:32.716] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.716] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:32.717] Chunk #1 of 1 ... DONE
[13:17:32.718] Launching 1 futures (chunks) ... DONE
[13:17:32.718] Resolving 1 futures (chunks) ...
[13:17:32.718] resolve() on list ...
[13:17:32.718]  recursive: 0
[13:17:32.718]  length: 1
[13:17:32.718] 
[13:17:32.718] resolved() for ‘SequentialFuture’ ...
[13:17:32.718] - state: ‘finished’
[13:17:32.718] - run: TRUE
[13:17:32.718] - result: ‘FutureResult’
[13:17:32.718] resolved() for ‘SequentialFuture’ ... done
[13:17:32.719] Future #1
[13:17:32.719] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:32.719] - nx: 1
[13:17:32.719] - relay: TRUE
[13:17:32.719] - stdout: TRUE
[13:17:32.719] - signal: TRUE
[13:17:32.719] - resignal: FALSE
[13:17:32.719] - force: TRUE
[13:17:32.719] - relayed: [n=1] FALSE
[13:17:32.719] - queued futures: [n=1] FALSE
[13:17:32.720]  - until=1
[13:17:32.720]  - relaying element #1
[13:17:32.720] - relayed: [n=1] TRUE
[13:17:32.720] - queued futures: [n=1] TRUE
[13:17:32.720] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:32.720]  length: 0 (resolved future 1)
[13:17:32.720] Relaying remaining futures
[13:17:32.720] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.720] - nx: 1
[13:17:32.720] - relay: TRUE
[13:17:32.721] - stdout: TRUE
[13:17:32.721] - signal: TRUE
[13:17:32.721] - resignal: FALSE
[13:17:32.721] - force: TRUE
[13:17:32.721] - relayed: [n=1] TRUE
[13:17:32.721] - queued futures: [n=1] TRUE
 - flush all
[13:17:32.721] - relayed: [n=1] TRUE
[13:17:32.721] - queued futures: [n=1] TRUE
[13:17:32.721] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.721] resolve() on list ... DONE
[13:17:32.722]  - Number of value chunks collected: 1
[13:17:32.722] Resolving 1 futures (chunks) ... DONE
[13:17:32.722] Reducing values from 1 chunks ...
[13:17:32.722]  - Number of values collected after concatenation: 3
[13:17:32.722]  - Number of values expected: 3
[13:17:32.722] Reducing values from 1 chunks ... DONE
[13:17:32.722] future_lapply() ... DONE
[13:17:32.723] plan(): Setting new future strategy stack:
[13:17:32.723] List of future strategies:
[13:17:32.723] 1. sequential:
[13:17:32.723]    - args: function (..., envir = parent.frame())
[13:17:32.723]    - tweaked: FALSE
[13:17:32.723]    - call: plan(sequential)
[13:17:32.723] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:17:32.724] plan(): Setting new future strategy stack:
[13:17:32.724] List of future strategies:
[13:17:32.724] 1. multicore:
[13:17:32.724]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:32.724]    - tweaked: FALSE
[13:17:32.724]    - call: plan(strategy)
[13:17:32.728] plan(): nbrOfWorkers() = 2
[13:17:32.728] future_lapply() ...
[13:17:32.733] Number of chunks: 2
[13:17:32.733] getGlobalsAndPackagesXApply() ...
[13:17:32.733]  - future.globals: TRUE
[13:17:32.733] getGlobalsAndPackages() ...
[13:17:32.733] Searching for globals...
[13:17:32.735] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.735] Searching for globals ... DONE
[13:17:32.735] Resolving globals: FALSE
[13:17:32.735] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:32.735] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:32.736] - globals: [1] ‘FUN’
[13:17:32.736] 
[13:17:32.736] getGlobalsAndPackages() ... DONE
[13:17:32.736]  - globals found/used: [n=1] ‘FUN’
[13:17:32.736]  - needed namespaces: [n=0] 
[13:17:32.736] Finding globals ... DONE
[13:17:32.736]  - use_args: TRUE
[13:17:32.736]  - Getting '...' globals ...
[13:17:32.737] resolve() on list ...
[13:17:32.737]  recursive: 0
[13:17:32.737]  length: 1
[13:17:32.737]  elements: ‘...’
[13:17:32.737]  length: 0 (resolved future 1)
[13:17:32.737] resolve() on list ... DONE
[13:17:32.737]    - '...' content: [n=0] 
[13:17:32.737] List of 1
[13:17:32.737]  $ ...: list()
[13:17:32.737]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.737]  - attr(*, "where")=List of 1
[13:17:32.737]   ..$ ...:<environment: 0x55be3da6cf38> 
[13:17:32.737]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.737]  - attr(*, "resolved")= logi TRUE
[13:17:32.737]  - attr(*, "total_size")= num NA
[13:17:32.740]  - Getting '...' globals ... DONE
[13:17:32.740] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.740] List of 2
[13:17:32.740]  $ ...future.FUN:function (x, ...)  
[13:17:32.740]  $ ...          : list()
[13:17:32.740]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.740]  - attr(*, "where")=List of 2
[13:17:32.740]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.740]   ..$ ...          :<environment: 0x55be3da6cf38> 
[13:17:32.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.740]  - attr(*, "resolved")= logi FALSE
[13:17:32.740]  - attr(*, "total_size")= num 1240
[13:17:32.745] Packages to be attached in all futures: [n=0] 
[13:17:32.745] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.745] Number of futures (= number of chunks): 2
[13:17:32.745] Launching 2 futures (chunks) ...
[13:17:32.745] Chunk #1 of 2 ...
[13:17:32.746]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.746] getGlobalsAndPackages() ...
[13:17:32.746] Searching for globals...
[13:17:32.746] 
[13:17:32.746] Searching for globals ... DONE
[13:17:32.746] - globals: [0] <none>
[13:17:32.746] getGlobalsAndPackages() ... DONE
[13:17:32.746]    + additional globals found: [n=0] 
[13:17:32.746]    + additional namespaces needed: [n=0] 
[13:17:32.747]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.747]  - seeds: <none>
[13:17:32.747] getGlobalsAndPackages() ...
[13:17:32.747] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.747] Resolving globals: FALSE
[13:17:32.747] Tweak future expression to call with '...' arguments ...
[13:17:32.747] {
[13:17:32.747]     do.call(function(...) {
[13:17:32.747]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.747]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.747]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.747]             on.exit(options(oopts), add = TRUE)
[13:17:32.747]         }
[13:17:32.747]         {
[13:17:32.747]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.747]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.747]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.747]             })
[13:17:32.747]         }
[13:17:32.747]     }, args = future.call.arguments)
[13:17:32.747] }
[13:17:32.747] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.748] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.748] 
[13:17:32.748] getGlobalsAndPackages() ... DONE
[13:17:32.748] run() for ‘Future’ ...
[13:17:32.748] - state: ‘created’
[13:17:32.749] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:32.752]   - Field: ‘label’
[13:17:32.753]   - Field: ‘local’
[13:17:32.753]   - Field: ‘owner’
[13:17:32.753]   - Field: ‘envir’
[13:17:32.753]   - Field: ‘workers’
[13:17:32.753]   - Field: ‘packages’
[13:17:32.753]   - Field: ‘gc’
[13:17:32.753]   - Field: ‘job’
[13:17:32.753]   - Field: ‘conditions’
[13:17:32.753]   - Field: ‘expr’
[13:17:32.753]   - Field: ‘uuid’
[13:17:32.754]   - Field: ‘seed’
[13:17:32.754]   - Field: ‘version’
[13:17:32.754]   - Field: ‘result’
[13:17:32.754]   - Field: ‘asynchronous’
[13:17:32.754]   - Field: ‘calls’
[13:17:32.754]   - Field: ‘globals’
[13:17:32.754]   - Field: ‘stdout’
[13:17:32.754]   - Field: ‘earlySignal’
[13:17:32.754]   - Field: ‘lazy’
[13:17:32.754]   - Field: ‘state’
[13:17:32.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:32.755] - Launch lazy future ...
[13:17:32.756] Packages needed by the future expression (n = 0): <none>
[13:17:32.756] Packages needed by future strategies (n = 0): <none>
[13:17:32.756] {
[13:17:32.756]     {
[13:17:32.756]         {
[13:17:32.756]             ...future.startTime <- base::Sys.time()
[13:17:32.756]             {
[13:17:32.756]                 {
[13:17:32.756]                   {
[13:17:32.756]                     {
[13:17:32.756]                       base::local({
[13:17:32.756]                         has_future <- base::requireNamespace("future", 
[13:17:32.756]                           quietly = TRUE)
[13:17:32.756]                         if (has_future) {
[13:17:32.756]                           ns <- base::getNamespace("future")
[13:17:32.756]                           version <- ns[[".package"]][["version"]]
[13:17:32.756]                           if (is.null(version)) 
[13:17:32.756]                             version <- utils::packageVersion("future")
[13:17:32.756]                         }
[13:17:32.756]                         else {
[13:17:32.756]                           version <- NULL
[13:17:32.756]                         }
[13:17:32.756]                         if (!has_future || version < "1.8.0") {
[13:17:32.756]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.756]                             "", base::R.version$version.string), 
[13:17:32.756]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.756]                               "release", "version")], collapse = " "), 
[13:17:32.756]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.756]                             info)
[13:17:32.756]                           info <- base::paste(info, collapse = "; ")
[13:17:32.756]                           if (!has_future) {
[13:17:32.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.756]                               info)
[13:17:32.756]                           }
[13:17:32.756]                           else {
[13:17:32.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.756]                               info, version)
[13:17:32.756]                           }
[13:17:32.756]                           base::stop(msg)
[13:17:32.756]                         }
[13:17:32.756]                       })
[13:17:32.756]                     }
[13:17:32.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.756]                     base::options(mc.cores = 1L)
[13:17:32.756]                   }
[13:17:32.756]                   options(future.plan = NULL)
[13:17:32.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.756]                 }
[13:17:32.756]                 ...future.workdir <- getwd()
[13:17:32.756]             }
[13:17:32.756]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.756]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.756]         }
[13:17:32.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:32.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.756]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.756]             base::names(...future.oldOptions))
[13:17:32.756]     }
[13:17:32.756]     if (FALSE) {
[13:17:32.756]     }
[13:17:32.756]     else {
[13:17:32.756]         if (TRUE) {
[13:17:32.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.756]                 open = "w")
[13:17:32.756]         }
[13:17:32.756]         else {
[13:17:32.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.756]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.756]         }
[13:17:32.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.756]             base::sink(type = "output", split = FALSE)
[13:17:32.756]             base::close(...future.stdout)
[13:17:32.756]         }, add = TRUE)
[13:17:32.756]     }
[13:17:32.756]     ...future.frame <- base::sys.nframe()
[13:17:32.756]     ...future.conditions <- base::list()
[13:17:32.756]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.756]     if (FALSE) {
[13:17:32.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.756]     }
[13:17:32.756]     ...future.result <- base::tryCatch({
[13:17:32.756]         base::withCallingHandlers({
[13:17:32.756]             ...future.value <- base::withVisible(base::local({
[13:17:32.756]                 withCallingHandlers({
[13:17:32.756]                   {
[13:17:32.756]                     do.call(function(...) {
[13:17:32.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.756]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.756]                         ...future.globals.maxSize)) {
[13:17:32.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.756]                         on.exit(options(oopts), add = TRUE)
[13:17:32.756]                       }
[13:17:32.756]                       {
[13:17:32.756]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.756]                           FUN = function(jj) {
[13:17:32.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.756]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.756]                           })
[13:17:32.756]                       }
[13:17:32.756]                     }, args = future.call.arguments)
[13:17:32.756]                   }
[13:17:32.756]                 }, immediateCondition = function(cond) {
[13:17:32.756]                   save_rds <- function (object, pathname, ...) 
[13:17:32.756]                   {
[13:17:32.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:32.756]                     if (file_test("-f", pathname_tmp)) {
[13:17:32.756]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:32.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.756]                         fi_tmp[["mtime"]])
[13:17:32.756]                     }
[13:17:32.756]                     tryCatch({
[13:17:32.756]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:32.756]                     }, error = function(ex) {
[13:17:32.756]                       msg <- conditionMessage(ex)
[13:17:32.756]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:32.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.756]                         fi_tmp[["mtime"]], msg)
[13:17:32.756]                       ex$message <- msg
[13:17:32.756]                       stop(ex)
[13:17:32.756]                     })
[13:17:32.756]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:32.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:32.756]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:32.756]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.756]                       fi <- file.info(pathname)
[13:17:32.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:32.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:32.756]                         fi[["size"]], fi[["mtime"]])
[13:17:32.756]                       stop(msg)
[13:17:32.756]                     }
[13:17:32.756]                     invisible(pathname)
[13:17:32.756]                   }
[13:17:32.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:32.756]                     rootPath = tempdir()) 
[13:17:32.756]                   {
[13:17:32.756]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:32.756]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:32.756]                       tmpdir = path, fileext = ".rds")
[13:17:32.756]                     save_rds(obj, file)
[13:17:32.756]                   }
[13:17:32.756]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:32.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.756]                   {
[13:17:32.756]                     inherits <- base::inherits
[13:17:32.756]                     invokeRestart <- base::invokeRestart
[13:17:32.756]                     is.null <- base::is.null
[13:17:32.756]                     muffled <- FALSE
[13:17:32.756]                     if (inherits(cond, "message")) {
[13:17:32.756]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.756]                       if (muffled) 
[13:17:32.756]                         invokeRestart("muffleMessage")
[13:17:32.756]                     }
[13:17:32.756]                     else if (inherits(cond, "warning")) {
[13:17:32.756]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.756]                       if (muffled) 
[13:17:32.756]                         invokeRestart("muffleWarning")
[13:17:32.756]                     }
[13:17:32.756]                     else if (inherits(cond, "condition")) {
[13:17:32.756]                       if (!is.null(pattern)) {
[13:17:32.756]                         computeRestarts <- base::computeRestarts
[13:17:32.756]                         grepl <- base::grepl
[13:17:32.756]                         restarts <- computeRestarts(cond)
[13:17:32.756]                         for (restart in restarts) {
[13:17:32.756]                           name <- restart$name
[13:17:32.756]                           if (is.null(name)) 
[13:17:32.756]                             next
[13:17:32.756]                           if (!grepl(pattern, name)) 
[13:17:32.756]                             next
[13:17:32.756]                           invokeRestart(restart)
[13:17:32.756]                           muffled <- TRUE
[13:17:32.756]                           break
[13:17:32.756]                         }
[13:17:32.756]                       }
[13:17:32.756]                     }
[13:17:32.756]                     invisible(muffled)
[13:17:32.756]                   }
[13:17:32.756]                   muffleCondition(cond)
[13:17:32.756]                 })
[13:17:32.756]             }))
[13:17:32.756]             future::FutureResult(value = ...future.value$value, 
[13:17:32.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.756]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.756]                     ...future.globalenv.names))
[13:17:32.756]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.756]         }, condition = base::local({
[13:17:32.756]             c <- base::c
[13:17:32.756]             inherits <- base::inherits
[13:17:32.756]             invokeRestart <- base::invokeRestart
[13:17:32.756]             length <- base::length
[13:17:32.756]             list <- base::list
[13:17:32.756]             seq.int <- base::seq.int
[13:17:32.756]             signalCondition <- base::signalCondition
[13:17:32.756]             sys.calls <- base::sys.calls
[13:17:32.756]             `[[` <- base::`[[`
[13:17:32.756]             `+` <- base::`+`
[13:17:32.756]             `<<-` <- base::`<<-`
[13:17:32.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.756]                   3L)]
[13:17:32.756]             }
[13:17:32.756]             function(cond) {
[13:17:32.756]                 is_error <- inherits(cond, "error")
[13:17:32.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.756]                   NULL)
[13:17:32.756]                 if (is_error) {
[13:17:32.756]                   sessionInformation <- function() {
[13:17:32.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.756]                       search = base::search(), system = base::Sys.info())
[13:17:32.756]                   }
[13:17:32.756]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.756]                     cond$call), session = sessionInformation(), 
[13:17:32.756]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.756]                   signalCondition(cond)
[13:17:32.756]                 }
[13:17:32.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.756]                 "immediateCondition"))) {
[13:17:32.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.756]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.756]                   if (TRUE && !signal) {
[13:17:32.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.756]                     {
[13:17:32.756]                       inherits <- base::inherits
[13:17:32.756]                       invokeRestart <- base::invokeRestart
[13:17:32.756]                       is.null <- base::is.null
[13:17:32.756]                       muffled <- FALSE
[13:17:32.756]                       if (inherits(cond, "message")) {
[13:17:32.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.756]                         if (muffled) 
[13:17:32.756]                           invokeRestart("muffleMessage")
[13:17:32.756]                       }
[13:17:32.756]                       else if (inherits(cond, "warning")) {
[13:17:32.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.756]                         if (muffled) 
[13:17:32.756]                           invokeRestart("muffleWarning")
[13:17:32.756]                       }
[13:17:32.756]                       else if (inherits(cond, "condition")) {
[13:17:32.756]                         if (!is.null(pattern)) {
[13:17:32.756]                           computeRestarts <- base::computeRestarts
[13:17:32.756]                           grepl <- base::grepl
[13:17:32.756]                           restarts <- computeRestarts(cond)
[13:17:32.756]                           for (restart in restarts) {
[13:17:32.756]                             name <- restart$name
[13:17:32.756]                             if (is.null(name)) 
[13:17:32.756]                               next
[13:17:32.756]                             if (!grepl(pattern, name)) 
[13:17:32.756]                               next
[13:17:32.756]                             invokeRestart(restart)
[13:17:32.756]                             muffled <- TRUE
[13:17:32.756]                             break
[13:17:32.756]                           }
[13:17:32.756]                         }
[13:17:32.756]                       }
[13:17:32.756]                       invisible(muffled)
[13:17:32.756]                     }
[13:17:32.756]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.756]                   }
[13:17:32.756]                 }
[13:17:32.756]                 else {
[13:17:32.756]                   if (TRUE) {
[13:17:32.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.756]                     {
[13:17:32.756]                       inherits <- base::inherits
[13:17:32.756]                       invokeRestart <- base::invokeRestart
[13:17:32.756]                       is.null <- base::is.null
[13:17:32.756]                       muffled <- FALSE
[13:17:32.756]                       if (inherits(cond, "message")) {
[13:17:32.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.756]                         if (muffled) 
[13:17:32.756]                           invokeRestart("muffleMessage")
[13:17:32.756]                       }
[13:17:32.756]                       else if (inherits(cond, "warning")) {
[13:17:32.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.756]                         if (muffled) 
[13:17:32.756]                           invokeRestart("muffleWarning")
[13:17:32.756]                       }
[13:17:32.756]                       else if (inherits(cond, "condition")) {
[13:17:32.756]                         if (!is.null(pattern)) {
[13:17:32.756]                           computeRestarts <- base::computeRestarts
[13:17:32.756]                           grepl <- base::grepl
[13:17:32.756]                           restarts <- computeRestarts(cond)
[13:17:32.756]                           for (restart in restarts) {
[13:17:32.756]                             name <- restart$name
[13:17:32.756]                             if (is.null(name)) 
[13:17:32.756]                               next
[13:17:32.756]                             if (!grepl(pattern, name)) 
[13:17:32.756]                               next
[13:17:32.756]                             invokeRestart(restart)
[13:17:32.756]                             muffled <- TRUE
[13:17:32.756]                             break
[13:17:32.756]                           }
[13:17:32.756]                         }
[13:17:32.756]                       }
[13:17:32.756]                       invisible(muffled)
[13:17:32.756]                     }
[13:17:32.756]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.756]                   }
[13:17:32.756]                 }
[13:17:32.756]             }
[13:17:32.756]         }))
[13:17:32.756]     }, error = function(ex) {
[13:17:32.756]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.756]                 ...future.rng), started = ...future.startTime, 
[13:17:32.756]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.756]             version = "1.8"), class = "FutureResult")
[13:17:32.756]     }, finally = {
[13:17:32.756]         if (!identical(...future.workdir, getwd())) 
[13:17:32.756]             setwd(...future.workdir)
[13:17:32.756]         {
[13:17:32.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.756]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.756]             }
[13:17:32.756]             base::options(...future.oldOptions)
[13:17:32.756]             if (.Platform$OS.type == "windows") {
[13:17:32.756]                 old_names <- names(...future.oldEnvVars)
[13:17:32.756]                 envs <- base::Sys.getenv()
[13:17:32.756]                 names <- names(envs)
[13:17:32.756]                 common <- intersect(names, old_names)
[13:17:32.756]                 added <- setdiff(names, old_names)
[13:17:32.756]                 removed <- setdiff(old_names, names)
[13:17:32.756]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.756]                   envs[common]]
[13:17:32.756]                 NAMES <- toupper(changed)
[13:17:32.756]                 args <- list()
[13:17:32.756]                 for (kk in seq_along(NAMES)) {
[13:17:32.756]                   name <- changed[[kk]]
[13:17:32.756]                   NAME <- NAMES[[kk]]
[13:17:32.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.756]                     next
[13:17:32.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.756]                 }
[13:17:32.756]                 NAMES <- toupper(added)
[13:17:32.756]                 for (kk in seq_along(NAMES)) {
[13:17:32.756]                   name <- added[[kk]]
[13:17:32.756]                   NAME <- NAMES[[kk]]
[13:17:32.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.756]                     next
[13:17:32.756]                   args[[name]] <- ""
[13:17:32.756]                 }
[13:17:32.756]                 NAMES <- toupper(removed)
[13:17:32.756]                 for (kk in seq_along(NAMES)) {
[13:17:32.756]                   name <- removed[[kk]]
[13:17:32.756]                   NAME <- NAMES[[kk]]
[13:17:32.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.756]                     next
[13:17:32.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.756]                 }
[13:17:32.756]                 if (length(args) > 0) 
[13:17:32.756]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.756]             }
[13:17:32.756]             else {
[13:17:32.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.756]             }
[13:17:32.756]             {
[13:17:32.756]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.756]                   0L) {
[13:17:32.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.756]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.756]                   base::options(opts)
[13:17:32.756]                 }
[13:17:32.756]                 {
[13:17:32.756]                   {
[13:17:32.756]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.756]                     NULL
[13:17:32.756]                   }
[13:17:32.756]                   options(future.plan = NULL)
[13:17:32.756]                   if (is.na(NA_character_)) 
[13:17:32.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.756]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:32.756]                     envir = parent.frame()) 
[13:17:32.756]                   {
[13:17:32.756]                     default_workers <- missing(workers)
[13:17:32.756]                     if (is.function(workers)) 
[13:17:32.756]                       workers <- workers()
[13:17:32.756]                     workers <- structure(as.integer(workers), 
[13:17:32.756]                       class = class(workers))
[13:17:32.756]                     stop_if_not(is.finite(workers), workers >= 
[13:17:32.756]                       1L)
[13:17:32.756]                     if ((workers == 1L && !inherits(workers, 
[13:17:32.756]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:32.756]                       if (default_workers) 
[13:17:32.756]                         supportsMulticore(warn = TRUE)
[13:17:32.756]                       return(sequential(..., envir = envir))
[13:17:32.756]                     }
[13:17:32.756]                     oopts <- options(mc.cores = workers)
[13:17:32.756]                     on.exit(options(oopts))
[13:17:32.756]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:32.756]                       envir = envir)
[13:17:32.756]                     if (!future$lazy) 
[13:17:32.756]                       future <- run(future)
[13:17:32.756]                     invisible(future)
[13:17:32.756]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.756]                 }
[13:17:32.756]             }
[13:17:32.756]         }
[13:17:32.756]     })
[13:17:32.756]     if (TRUE) {
[13:17:32.756]         base::sink(type = "output", split = FALSE)
[13:17:32.756]         if (TRUE) {
[13:17:32.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.756]         }
[13:17:32.756]         else {
[13:17:32.756]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.756]         }
[13:17:32.756]         base::close(...future.stdout)
[13:17:32.756]         ...future.stdout <- NULL
[13:17:32.756]     }
[13:17:32.756]     ...future.result$conditions <- ...future.conditions
[13:17:32.756]     ...future.result$finished <- base::Sys.time()
[13:17:32.756]     ...future.result
[13:17:32.756] }
[13:17:32.759] assign_globals() ...
[13:17:32.759] List of 5
[13:17:32.759]  $ ...future.FUN            :function (x, ...)  
[13:17:32.759]  $ future.call.arguments    : list()
[13:17:32.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.759]  $ ...future.elements_ii    :List of 1
[13:17:32.759]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.759]  $ ...future.seeds_ii       : NULL
[13:17:32.759]  $ ...future.globals.maxSize: NULL
[13:17:32.759]  - attr(*, "where")=List of 5
[13:17:32.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.759]  - attr(*, "resolved")= logi FALSE
[13:17:32.759]  - attr(*, "total_size")= num 1240
[13:17:32.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.759]  - attr(*, "already-done")= logi TRUE
[13:17:32.764] - copied ‘...future.FUN’ to environment
[13:17:32.764] - copied ‘future.call.arguments’ to environment
[13:17:32.764] - copied ‘...future.elements_ii’ to environment
[13:17:32.764] - copied ‘...future.seeds_ii’ to environment
[13:17:32.764] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.764] assign_globals() ... done
[13:17:32.764] requestCore(): workers = 2
[13:17:32.767] MulticoreFuture started
[13:17:32.768] - Launch lazy future ... done
[13:17:32.768] plan(): Setting new future strategy stack:
[13:17:32.768] run() for ‘MulticoreFuture’ ... done
[13:17:32.768] Created future:
[13:17:32.768] List of future strategies:
[13:17:32.768] 1. sequential:
[13:17:32.768]    - args: function (..., envir = parent.frame())
[13:17:32.768]    - tweaked: FALSE
[13:17:32.768]    - call: NULL
[13:17:32.769] plan(): nbrOfWorkers() = 1
[13:17:32.771] plan(): Setting new future strategy stack:
[13:17:32.771] List of future strategies:
[13:17:32.771] 1. multicore:
[13:17:32.771]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:32.771]    - tweaked: FALSE
[13:17:32.771]    - call: plan(strategy)
[13:17:32.776] plan(): nbrOfWorkers() = 2
[13:17:32.768] MulticoreFuture:
[13:17:32.768] Label: ‘future_eapply-1’
[13:17:32.768] Expression:
[13:17:32.768] {
[13:17:32.768]     do.call(function(...) {
[13:17:32.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.768]             on.exit(options(oopts), add = TRUE)
[13:17:32.768]         }
[13:17:32.768]         {
[13:17:32.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.768]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.768]             })
[13:17:32.768]         }
[13:17:32.768]     }, args = future.call.arguments)
[13:17:32.768] }
[13:17:32.768] Lazy evaluation: FALSE
[13:17:32.768] Asynchronous evaluation: TRUE
[13:17:32.768] Local evaluation: TRUE
[13:17:32.768] Environment: R_GlobalEnv
[13:17:32.768] Capture standard output: TRUE
[13:17:32.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.768] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.768] Packages: <none>
[13:17:32.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.768] Resolved: TRUE
[13:17:32.768] Value: <not collected>
[13:17:32.768] Conditions captured: <none>
[13:17:32.768] Early signaling: FALSE
[13:17:32.768] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.768] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.777] Chunk #1 of 2 ... DONE
[13:17:32.777] Chunk #2 of 2 ...
[13:17:32.777]  - Finding globals in 'X' for chunk #2 ...
[13:17:32.778] getGlobalsAndPackages() ...
[13:17:32.778] Searching for globals...
[13:17:32.778] 
[13:17:32.778] Searching for globals ... DONE
[13:17:32.778] - globals: [0] <none>
[13:17:32.779] getGlobalsAndPackages() ... DONE
[13:17:32.779]    + additional globals found: [n=0] 
[13:17:32.779]    + additional namespaces needed: [n=0] 
[13:17:32.779]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:32.779]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:32.779]  - seeds: <none>
[13:17:32.779] getGlobalsAndPackages() ...
[13:17:32.780] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.780] Resolving globals: FALSE
[13:17:32.780] Tweak future expression to call with '...' arguments ...
[13:17:32.780] {
[13:17:32.780]     do.call(function(...) {
[13:17:32.780]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.780]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.780]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.780]             on.exit(options(oopts), add = TRUE)
[13:17:32.780]         }
[13:17:32.780]         {
[13:17:32.780]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.780]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.780]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.780]             })
[13:17:32.780]         }
[13:17:32.780]     }, args = future.call.arguments)
[13:17:32.780] }
[13:17:32.781] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.781] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.781] 
[13:17:32.781] getGlobalsAndPackages() ... DONE
[13:17:32.786] run() for ‘Future’ ...
[13:17:32.786] - state: ‘created’
[13:17:32.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.792] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:32.792]   - Field: ‘label’
[13:17:32.792]   - Field: ‘local’
[13:17:32.793]   - Field: ‘owner’
[13:17:32.793]   - Field: ‘envir’
[13:17:32.793]   - Field: ‘workers’
[13:17:32.793]   - Field: ‘packages’
[13:17:32.793]   - Field: ‘gc’
[13:17:32.794]   - Field: ‘job’
[13:17:32.794]   - Field: ‘conditions’
[13:17:32.794]   - Field: ‘expr’
[13:17:32.794]   - Field: ‘uuid’
[13:17:32.794]   - Field: ‘seed’
[13:17:32.794]   - Field: ‘version’
[13:17:32.795]   - Field: ‘result’
[13:17:32.795]   - Field: ‘asynchronous’
[13:17:32.795]   - Field: ‘calls’
[13:17:32.795]   - Field: ‘globals’
[13:17:32.795]   - Field: ‘stdout’
[13:17:32.795]   - Field: ‘earlySignal’
[13:17:32.796]   - Field: ‘lazy’
[13:17:32.796]   - Field: ‘state’
[13:17:32.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:32.796] - Launch lazy future ...
[13:17:32.796] Packages needed by the future expression (n = 0): <none>
[13:17:32.797] Packages needed by future strategies (n = 0): <none>
[13:17:32.798] {
[13:17:32.798]     {
[13:17:32.798]         {
[13:17:32.798]             ...future.startTime <- base::Sys.time()
[13:17:32.798]             {
[13:17:32.798]                 {
[13:17:32.798]                   {
[13:17:32.798]                     {
[13:17:32.798]                       base::local({
[13:17:32.798]                         has_future <- base::requireNamespace("future", 
[13:17:32.798]                           quietly = TRUE)
[13:17:32.798]                         if (has_future) {
[13:17:32.798]                           ns <- base::getNamespace("future")
[13:17:32.798]                           version <- ns[[".package"]][["version"]]
[13:17:32.798]                           if (is.null(version)) 
[13:17:32.798]                             version <- utils::packageVersion("future")
[13:17:32.798]                         }
[13:17:32.798]                         else {
[13:17:32.798]                           version <- NULL
[13:17:32.798]                         }
[13:17:32.798]                         if (!has_future || version < "1.8.0") {
[13:17:32.798]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.798]                             "", base::R.version$version.string), 
[13:17:32.798]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:32.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:32.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.798]                               "release", "version")], collapse = " "), 
[13:17:32.798]                             hostname = base::Sys.info()[["nodename"]])
[13:17:32.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.798]                             info)
[13:17:32.798]                           info <- base::paste(info, collapse = "; ")
[13:17:32.798]                           if (!has_future) {
[13:17:32.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.798]                               info)
[13:17:32.798]                           }
[13:17:32.798]                           else {
[13:17:32.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.798]                               info, version)
[13:17:32.798]                           }
[13:17:32.798]                           base::stop(msg)
[13:17:32.798]                         }
[13:17:32.798]                       })
[13:17:32.798]                     }
[13:17:32.798]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.798]                     base::options(mc.cores = 1L)
[13:17:32.798]                   }
[13:17:32.798]                   options(future.plan = NULL)
[13:17:32.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.798]                 }
[13:17:32.798]                 ...future.workdir <- getwd()
[13:17:32.798]             }
[13:17:32.798]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.798]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.798]         }
[13:17:32.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.798]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:32.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.798]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.798]             base::names(...future.oldOptions))
[13:17:32.798]     }
[13:17:32.798]     if (FALSE) {
[13:17:32.798]     }
[13:17:32.798]     else {
[13:17:32.798]         if (TRUE) {
[13:17:32.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.798]                 open = "w")
[13:17:32.798]         }
[13:17:32.798]         else {
[13:17:32.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.798]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.798]         }
[13:17:32.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.798]             base::sink(type = "output", split = FALSE)
[13:17:32.798]             base::close(...future.stdout)
[13:17:32.798]         }, add = TRUE)
[13:17:32.798]     }
[13:17:32.798]     ...future.frame <- base::sys.nframe()
[13:17:32.798]     ...future.conditions <- base::list()
[13:17:32.798]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.798]     if (FALSE) {
[13:17:32.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.798]     }
[13:17:32.798]     ...future.result <- base::tryCatch({
[13:17:32.798]         base::withCallingHandlers({
[13:17:32.798]             ...future.value <- base::withVisible(base::local({
[13:17:32.798]                 withCallingHandlers({
[13:17:32.798]                   {
[13:17:32.798]                     do.call(function(...) {
[13:17:32.798]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.798]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.798]                         ...future.globals.maxSize)) {
[13:17:32.798]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.798]                         on.exit(options(oopts), add = TRUE)
[13:17:32.798]                       }
[13:17:32.798]                       {
[13:17:32.798]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.798]                           FUN = function(jj) {
[13:17:32.798]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.798]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.798]                           })
[13:17:32.798]                       }
[13:17:32.798]                     }, args = future.call.arguments)
[13:17:32.798]                   }
[13:17:32.798]                 }, immediateCondition = function(cond) {
[13:17:32.798]                   save_rds <- function (object, pathname, ...) 
[13:17:32.798]                   {
[13:17:32.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:32.798]                     if (file_test("-f", pathname_tmp)) {
[13:17:32.798]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:32.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.798]                         fi_tmp[["mtime"]])
[13:17:32.798]                     }
[13:17:32.798]                     tryCatch({
[13:17:32.798]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:32.798]                     }, error = function(ex) {
[13:17:32.798]                       msg <- conditionMessage(ex)
[13:17:32.798]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:32.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.798]                         fi_tmp[["mtime"]], msg)
[13:17:32.798]                       ex$message <- msg
[13:17:32.798]                       stop(ex)
[13:17:32.798]                     })
[13:17:32.798]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:32.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:32.798]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:32.798]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.798]                       fi <- file.info(pathname)
[13:17:32.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:32.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:32.798]                         fi[["size"]], fi[["mtime"]])
[13:17:32.798]                       stop(msg)
[13:17:32.798]                     }
[13:17:32.798]                     invisible(pathname)
[13:17:32.798]                   }
[13:17:32.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:32.798]                     rootPath = tempdir()) 
[13:17:32.798]                   {
[13:17:32.798]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:32.798]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:32.798]                       tmpdir = path, fileext = ".rds")
[13:17:32.798]                     save_rds(obj, file)
[13:17:32.798]                   }
[13:17:32.798]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:32.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.798]                   {
[13:17:32.798]                     inherits <- base::inherits
[13:17:32.798]                     invokeRestart <- base::invokeRestart
[13:17:32.798]                     is.null <- base::is.null
[13:17:32.798]                     muffled <- FALSE
[13:17:32.798]                     if (inherits(cond, "message")) {
[13:17:32.798]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.798]                       if (muffled) 
[13:17:32.798]                         invokeRestart("muffleMessage")
[13:17:32.798]                     }
[13:17:32.798]                     else if (inherits(cond, "warning")) {
[13:17:32.798]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.798]                       if (muffled) 
[13:17:32.798]                         invokeRestart("muffleWarning")
[13:17:32.798]                     }
[13:17:32.798]                     else if (inherits(cond, "condition")) {
[13:17:32.798]                       if (!is.null(pattern)) {
[13:17:32.798]                         computeRestarts <- base::computeRestarts
[13:17:32.798]                         grepl <- base::grepl
[13:17:32.798]                         restarts <- computeRestarts(cond)
[13:17:32.798]                         for (restart in restarts) {
[13:17:32.798]                           name <- restart$name
[13:17:32.798]                           if (is.null(name)) 
[13:17:32.798]                             next
[13:17:32.798]                           if (!grepl(pattern, name)) 
[13:17:32.798]                             next
[13:17:32.798]                           invokeRestart(restart)
[13:17:32.798]                           muffled <- TRUE
[13:17:32.798]                           break
[13:17:32.798]                         }
[13:17:32.798]                       }
[13:17:32.798]                     }
[13:17:32.798]                     invisible(muffled)
[13:17:32.798]                   }
[13:17:32.798]                   muffleCondition(cond)
[13:17:32.798]                 })
[13:17:32.798]             }))
[13:17:32.798]             future::FutureResult(value = ...future.value$value, 
[13:17:32.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.798]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.798]                     ...future.globalenv.names))
[13:17:32.798]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.798]         }, condition = base::local({
[13:17:32.798]             c <- base::c
[13:17:32.798]             inherits <- base::inherits
[13:17:32.798]             invokeRestart <- base::invokeRestart
[13:17:32.798]             length <- base::length
[13:17:32.798]             list <- base::list
[13:17:32.798]             seq.int <- base::seq.int
[13:17:32.798]             signalCondition <- base::signalCondition
[13:17:32.798]             sys.calls <- base::sys.calls
[13:17:32.798]             `[[` <- base::`[[`
[13:17:32.798]             `+` <- base::`+`
[13:17:32.798]             `<<-` <- base::`<<-`
[13:17:32.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.798]                   3L)]
[13:17:32.798]             }
[13:17:32.798]             function(cond) {
[13:17:32.798]                 is_error <- inherits(cond, "error")
[13:17:32.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.798]                   NULL)
[13:17:32.798]                 if (is_error) {
[13:17:32.798]                   sessionInformation <- function() {
[13:17:32.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.798]                       search = base::search(), system = base::Sys.info())
[13:17:32.798]                   }
[13:17:32.798]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.798]                     cond$call), session = sessionInformation(), 
[13:17:32.798]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.798]                   signalCondition(cond)
[13:17:32.798]                 }
[13:17:32.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.798]                 "immediateCondition"))) {
[13:17:32.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.798]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.798]                   if (TRUE && !signal) {
[13:17:32.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.798]                     {
[13:17:32.798]                       inherits <- base::inherits
[13:17:32.798]                       invokeRestart <- base::invokeRestart
[13:17:32.798]                       is.null <- base::is.null
[13:17:32.798]                       muffled <- FALSE
[13:17:32.798]                       if (inherits(cond, "message")) {
[13:17:32.798]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.798]                         if (muffled) 
[13:17:32.798]                           invokeRestart("muffleMessage")
[13:17:32.798]                       }
[13:17:32.798]                       else if (inherits(cond, "warning")) {
[13:17:32.798]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.798]                         if (muffled) 
[13:17:32.798]                           invokeRestart("muffleWarning")
[13:17:32.798]                       }
[13:17:32.798]                       else if (inherits(cond, "condition")) {
[13:17:32.798]                         if (!is.null(pattern)) {
[13:17:32.798]                           computeRestarts <- base::computeRestarts
[13:17:32.798]                           grepl <- base::grepl
[13:17:32.798]                           restarts <- computeRestarts(cond)
[13:17:32.798]                           for (restart in restarts) {
[13:17:32.798]                             name <- restart$name
[13:17:32.798]                             if (is.null(name)) 
[13:17:32.798]                               next
[13:17:32.798]                             if (!grepl(pattern, name)) 
[13:17:32.798]                               next
[13:17:32.798]                             invokeRestart(restart)
[13:17:32.798]                             muffled <- TRUE
[13:17:32.798]                             break
[13:17:32.798]                           }
[13:17:32.798]                         }
[13:17:32.798]                       }
[13:17:32.798]                       invisible(muffled)
[13:17:32.798]                     }
[13:17:32.798]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.798]                   }
[13:17:32.798]                 }
[13:17:32.798]                 else {
[13:17:32.798]                   if (TRUE) {
[13:17:32.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.798]                     {
[13:17:32.798]                       inherits <- base::inherits
[13:17:32.798]                       invokeRestart <- base::invokeRestart
[13:17:32.798]                       is.null <- base::is.null
[13:17:32.798]                       muffled <- FALSE
[13:17:32.798]                       if (inherits(cond, "message")) {
[13:17:32.798]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.798]                         if (muffled) 
[13:17:32.798]                           invokeRestart("muffleMessage")
[13:17:32.798]                       }
[13:17:32.798]                       else if (inherits(cond, "warning")) {
[13:17:32.798]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.798]                         if (muffled) 
[13:17:32.798]                           invokeRestart("muffleWarning")
[13:17:32.798]                       }
[13:17:32.798]                       else if (inherits(cond, "condition")) {
[13:17:32.798]                         if (!is.null(pattern)) {
[13:17:32.798]                           computeRestarts <- base::computeRestarts
[13:17:32.798]                           grepl <- base::grepl
[13:17:32.798]                           restarts <- computeRestarts(cond)
[13:17:32.798]                           for (restart in restarts) {
[13:17:32.798]                             name <- restart$name
[13:17:32.798]                             if (is.null(name)) 
[13:17:32.798]                               next
[13:17:32.798]                             if (!grepl(pattern, name)) 
[13:17:32.798]                               next
[13:17:32.798]                             invokeRestart(restart)
[13:17:32.798]                             muffled <- TRUE
[13:17:32.798]                             break
[13:17:32.798]                           }
[13:17:32.798]                         }
[13:17:32.798]                       }
[13:17:32.798]                       invisible(muffled)
[13:17:32.798]                     }
[13:17:32.798]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.798]                   }
[13:17:32.798]                 }
[13:17:32.798]             }
[13:17:32.798]         }))
[13:17:32.798]     }, error = function(ex) {
[13:17:32.798]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.798]                 ...future.rng), started = ...future.startTime, 
[13:17:32.798]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.798]             version = "1.8"), class = "FutureResult")
[13:17:32.798]     }, finally = {
[13:17:32.798]         if (!identical(...future.workdir, getwd())) 
[13:17:32.798]             setwd(...future.workdir)
[13:17:32.798]         {
[13:17:32.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.798]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.798]             }
[13:17:32.798]             base::options(...future.oldOptions)
[13:17:32.798]             if (.Platform$OS.type == "windows") {
[13:17:32.798]                 old_names <- names(...future.oldEnvVars)
[13:17:32.798]                 envs <- base::Sys.getenv()
[13:17:32.798]                 names <- names(envs)
[13:17:32.798]                 common <- intersect(names, old_names)
[13:17:32.798]                 added <- setdiff(names, old_names)
[13:17:32.798]                 removed <- setdiff(old_names, names)
[13:17:32.798]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.798]                   envs[common]]
[13:17:32.798]                 NAMES <- toupper(changed)
[13:17:32.798]                 args <- list()
[13:17:32.798]                 for (kk in seq_along(NAMES)) {
[13:17:32.798]                   name <- changed[[kk]]
[13:17:32.798]                   NAME <- NAMES[[kk]]
[13:17:32.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.798]                     next
[13:17:32.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.798]                 }
[13:17:32.798]                 NAMES <- toupper(added)
[13:17:32.798]                 for (kk in seq_along(NAMES)) {
[13:17:32.798]                   name <- added[[kk]]
[13:17:32.798]                   NAME <- NAMES[[kk]]
[13:17:32.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.798]                     next
[13:17:32.798]                   args[[name]] <- ""
[13:17:32.798]                 }
[13:17:32.798]                 NAMES <- toupper(removed)
[13:17:32.798]                 for (kk in seq_along(NAMES)) {
[13:17:32.798]                   name <- removed[[kk]]
[13:17:32.798]                   NAME <- NAMES[[kk]]
[13:17:32.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.798]                     next
[13:17:32.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.798]                 }
[13:17:32.798]                 if (length(args) > 0) 
[13:17:32.798]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.798]             }
[13:17:32.798]             else {
[13:17:32.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.798]             }
[13:17:32.798]             {
[13:17:32.798]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.798]                   0L) {
[13:17:32.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.798]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.798]                   base::options(opts)
[13:17:32.798]                 }
[13:17:32.798]                 {
[13:17:32.798]                   {
[13:17:32.798]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.798]                     NULL
[13:17:32.798]                   }
[13:17:32.798]                   options(future.plan = NULL)
[13:17:32.798]                   if (is.na(NA_character_)) 
[13:17:32.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.798]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:32.798]                     envir = parent.frame()) 
[13:17:32.798]                   {
[13:17:32.798]                     default_workers <- missing(workers)
[13:17:32.798]                     if (is.function(workers)) 
[13:17:32.798]                       workers <- workers()
[13:17:32.798]                     workers <- structure(as.integer(workers), 
[13:17:32.798]                       class = class(workers))
[13:17:32.798]                     stop_if_not(is.finite(workers), workers >= 
[13:17:32.798]                       1L)
[13:17:32.798]                     if ((workers == 1L && !inherits(workers, 
[13:17:32.798]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:32.798]                       if (default_workers) 
[13:17:32.798]                         supportsMulticore(warn = TRUE)
[13:17:32.798]                       return(sequential(..., envir = envir))
[13:17:32.798]                     }
[13:17:32.798]                     oopts <- options(mc.cores = workers)
[13:17:32.798]                     on.exit(options(oopts))
[13:17:32.798]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:32.798]                       envir = envir)
[13:17:32.798]                     if (!future$lazy) 
[13:17:32.798]                       future <- run(future)
[13:17:32.798]                     invisible(future)
[13:17:32.798]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.798]                 }
[13:17:32.798]             }
[13:17:32.798]         }
[13:17:32.798]     })
[13:17:32.798]     if (TRUE) {
[13:17:32.798]         base::sink(type = "output", split = FALSE)
[13:17:32.798]         if (TRUE) {
[13:17:32.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.798]         }
[13:17:32.798]         else {
[13:17:32.798]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.798]         }
[13:17:32.798]         base::close(...future.stdout)
[13:17:32.798]         ...future.stdout <- NULL
[13:17:32.798]     }
[13:17:32.798]     ...future.result$conditions <- ...future.conditions
[13:17:32.798]     ...future.result$finished <- base::Sys.time()
[13:17:32.798]     ...future.result
[13:17:32.798] }
[13:17:32.800] assign_globals() ...
[13:17:32.800] List of 5
[13:17:32.800]  $ ...future.FUN            :function (x, ...)  
[13:17:32.800]  $ future.call.arguments    : list()
[13:17:32.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.800]  $ ...future.elements_ii    :List of 2
[13:17:32.800]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:32.800]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:32.800]  $ ...future.seeds_ii       : NULL
[13:17:32.800]  $ ...future.globals.maxSize: NULL
[13:17:32.800]  - attr(*, "resolved")= logi FALSE
[13:17:32.800]  - attr(*, "total_size")= num 1240
[13:17:32.800]  - attr(*, "where")=List of 5
[13:17:32.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.800]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.800]  - attr(*, "already-done")= logi TRUE
[13:17:32.808] - copied ‘...future.FUN’ to environment
[13:17:32.808] - copied ‘future.call.arguments’ to environment
[13:17:32.808] - copied ‘...future.elements_ii’ to environment
[13:17:32.808] - copied ‘...future.seeds_ii’ to environment
[13:17:32.808] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.809] assign_globals() ... done
[13:17:32.809] requestCore(): workers = 2
[13:17:32.814] MulticoreFuture started
[13:17:32.815] - Launch lazy future ... done
[13:17:32.815] run() for ‘MulticoreFuture’ ... done
[13:17:32.815] Created future:
[13:17:32.815] plan(): Setting new future strategy stack:
[13:17:32.816] List of future strategies:
[13:17:32.816] 1. sequential:
[13:17:32.816]    - args: function (..., envir = parent.frame())
[13:17:32.816]    - tweaked: FALSE
[13:17:32.816]    - call: NULL
[13:17:32.817] plan(): nbrOfWorkers() = 1
[13:17:32.819] plan(): Setting new future strategy stack:
[13:17:32.819] List of future strategies:
[13:17:32.819] 1. multicore:
[13:17:32.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:32.819]    - tweaked: FALSE
[13:17:32.819]    - call: plan(strategy)
[13:17:32.824] plan(): nbrOfWorkers() = 2
[13:17:32.815] MulticoreFuture:
[13:17:32.815] Label: ‘future_eapply-2’
[13:17:32.815] Expression:
[13:17:32.815] {
[13:17:32.815]     do.call(function(...) {
[13:17:32.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.815]             on.exit(options(oopts), add = TRUE)
[13:17:32.815]         }
[13:17:32.815]         {
[13:17:32.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.815]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.815]             })
[13:17:32.815]         }
[13:17:32.815]     }, args = future.call.arguments)
[13:17:32.815] }
[13:17:32.815] Lazy evaluation: FALSE
[13:17:32.815] Asynchronous evaluation: TRUE
[13:17:32.815] Local evaluation: TRUE
[13:17:32.815] Environment: R_GlobalEnv
[13:17:32.815] Capture standard output: TRUE
[13:17:32.815] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.815] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.815] Packages: <none>
[13:17:32.815] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.815] Resolved: TRUE
[13:17:32.815] Value: <not collected>
[13:17:32.815] Conditions captured: <none>
[13:17:32.815] Early signaling: FALSE
[13:17:32.815] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.815] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.825] Chunk #2 of 2 ... DONE
[13:17:32.826] Launching 2 futures (chunks) ... DONE
[13:17:32.826] Resolving 2 futures (chunks) ...
[13:17:32.826] resolve() on list ...
[13:17:32.826]  recursive: 0
[13:17:32.826]  length: 2
[13:17:32.826] 
[13:17:32.827] Future #1
[13:17:32.829] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:32.829] - nx: 2
[13:17:32.829] - relay: TRUE
[13:17:32.830] - stdout: TRUE
[13:17:32.830] - signal: TRUE
[13:17:32.830] - resignal: FALSE
[13:17:32.830] - force: TRUE
[13:17:32.830] - relayed: [n=2] FALSE, FALSE
[13:17:32.830] - queued futures: [n=2] FALSE, FALSE
[13:17:32.830]  - until=1
[13:17:32.830]  - relaying element #1
[13:17:32.831] - relayed: [n=2] TRUE, FALSE
[13:17:32.831] - queued futures: [n=2] TRUE, FALSE
[13:17:32.831] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:32.831]  length: 1 (resolved future 1)
[13:17:32.832] Future #2
[13:17:32.832] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:32.832] - nx: 2
[13:17:32.833] - relay: TRUE
[13:17:32.833] - stdout: TRUE
[13:17:32.833] - signal: TRUE
[13:17:32.833] - resignal: FALSE
[13:17:32.833] - force: TRUE
[13:17:32.833] - relayed: [n=2] TRUE, FALSE
[13:17:32.833] - queued futures: [n=2] TRUE, FALSE
[13:17:32.833]  - until=2
[13:17:32.834]  - relaying element #2
[13:17:32.834] - relayed: [n=2] TRUE, TRUE
[13:17:32.834] - queued futures: [n=2] TRUE, TRUE
[13:17:32.834] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:32.834]  length: 0 (resolved future 2)
[13:17:32.834] Relaying remaining futures
[13:17:32.835] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.835] - nx: 2
[13:17:32.835] - relay: TRUE
[13:17:32.835] - stdout: TRUE
[13:17:32.838] - signal: TRUE
[13:17:32.838] - resignal: FALSE
[13:17:32.838] - force: TRUE
[13:17:32.838] - relayed: [n=2] TRUE, TRUE
[13:17:32.838] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:32.838] - relayed: [n=2] TRUE, TRUE
[13:17:32.838] - queued futures: [n=2] TRUE, TRUE
[13:17:32.838] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.838] resolve() on list ... DONE
[13:17:32.839]  - Number of value chunks collected: 2
[13:17:32.839] Resolving 2 futures (chunks) ... DONE
[13:17:32.839] Reducing values from 2 chunks ...
[13:17:32.839]  - Number of values collected after concatenation: 3
[13:17:32.839]  - Number of values expected: 3
[13:17:32.840] Reducing values from 2 chunks ... DONE
[13:17:32.840] future_lapply() ... DONE
[13:17:32.841] future_lapply() ...
[13:17:32.845] Number of chunks: 2
[13:17:32.845] getGlobalsAndPackagesXApply() ...
[13:17:32.846]  - future.globals: TRUE
[13:17:32.846] getGlobalsAndPackages() ...
[13:17:32.846] Searching for globals...
[13:17:32.847] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.847] Searching for globals ... DONE
[13:17:32.848] Resolving globals: FALSE
[13:17:32.848] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:32.848] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:32.849] - globals: [1] ‘FUN’
[13:17:32.849] - packages: [1] ‘stats’
[13:17:32.849] getGlobalsAndPackages() ... DONE
[13:17:32.849]  - globals found/used: [n=1] ‘FUN’
[13:17:32.849]  - needed namespaces: [n=1] ‘stats’
[13:17:32.849] Finding globals ... DONE
[13:17:32.849]  - use_args: TRUE
[13:17:32.849]  - Getting '...' globals ...
[13:17:32.850] resolve() on list ...
[13:17:32.850]  recursive: 0
[13:17:32.850]  length: 1
[13:17:32.850]  elements: ‘...’
[13:17:32.850]  length: 0 (resolved future 1)
[13:17:32.850] resolve() on list ... DONE
[13:17:32.851]    - '...' content: [n=1] ‘probs’
[13:17:32.851] List of 1
[13:17:32.851]  $ ...:List of 1
[13:17:32.851]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.851]  - attr(*, "where")=List of 1
[13:17:32.851]   ..$ ...:<environment: 0x55be3c805720> 
[13:17:32.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.851]  - attr(*, "resolved")= logi TRUE
[13:17:32.851]  - attr(*, "total_size")= num NA
[13:17:32.854]  - Getting '...' globals ... DONE
[13:17:32.855] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.855] List of 2
[13:17:32.855]  $ ...future.FUN:function (x, ...)  
[13:17:32.855]  $ ...          :List of 1
[13:17:32.855]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.855]  - attr(*, "where")=List of 2
[13:17:32.855]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.855]   ..$ ...          :<environment: 0x55be3c805720> 
[13:17:32.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.855]  - attr(*, "resolved")= logi FALSE
[13:17:32.855]  - attr(*, "total_size")= num 1328
[13:17:32.858] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:32.858] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.859] Number of futures (= number of chunks): 2
[13:17:32.859] Launching 2 futures (chunks) ...
[13:17:32.859] Chunk #1 of 2 ...
[13:17:32.859]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.859] getGlobalsAndPackages() ...
[13:17:32.859] Searching for globals...
[13:17:32.859] 
[13:17:32.859] Searching for globals ... DONE
[13:17:32.860] - globals: [0] <none>
[13:17:32.860] getGlobalsAndPackages() ... DONE
[13:17:32.860]    + additional globals found: [n=0] 
[13:17:32.860]    + additional namespaces needed: [n=0] 
[13:17:32.860]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.860]  - seeds: <none>
[13:17:32.860] getGlobalsAndPackages() ...
[13:17:32.860] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.860] Resolving globals: FALSE
[13:17:32.860] Tweak future expression to call with '...' arguments ...
[13:17:32.861] {
[13:17:32.861]     do.call(function(...) {
[13:17:32.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.861]             on.exit(options(oopts), add = TRUE)
[13:17:32.861]         }
[13:17:32.861]         {
[13:17:32.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.861]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.861]             })
[13:17:32.861]         }
[13:17:32.861]     }, args = future.call.arguments)
[13:17:32.861] }
[13:17:32.861] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.861] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.861] - packages: [1] ‘stats’
[13:17:32.861] getGlobalsAndPackages() ... DONE
[13:17:32.862] run() for ‘Future’ ...
[13:17:32.862] - state: ‘created’
[13:17:32.862] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:32.866]   - Field: ‘label’
[13:17:32.866]   - Field: ‘local’
[13:17:32.866]   - Field: ‘owner’
[13:17:32.866]   - Field: ‘envir’
[13:17:32.866]   - Field: ‘workers’
[13:17:32.866]   - Field: ‘packages’
[13:17:32.866]   - Field: ‘gc’
[13:17:32.867]   - Field: ‘job’
[13:17:32.867]   - Field: ‘conditions’
[13:17:32.867]   - Field: ‘expr’
[13:17:32.867]   - Field: ‘uuid’
[13:17:32.869]   - Field: ‘seed’
[13:17:32.869]   - Field: ‘version’
[13:17:32.869]   - Field: ‘result’
[13:17:32.869]   - Field: ‘asynchronous’
[13:17:32.869]   - Field: ‘calls’
[13:17:32.869]   - Field: ‘globals’
[13:17:32.869]   - Field: ‘stdout’
[13:17:32.869]   - Field: ‘earlySignal’
[13:17:32.869]   - Field: ‘lazy’
[13:17:32.870]   - Field: ‘state’
[13:17:32.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:32.870] - Launch lazy future ...
[13:17:32.870] Packages needed by the future expression (n = 1): ‘stats’
[13:17:32.870] Packages needed by future strategies (n = 0): <none>
[13:17:32.871] {
[13:17:32.871]     {
[13:17:32.871]         {
[13:17:32.871]             ...future.startTime <- base::Sys.time()
[13:17:32.871]             {
[13:17:32.871]                 {
[13:17:32.871]                   {
[13:17:32.871]                     {
[13:17:32.871]                       {
[13:17:32.871]                         base::local({
[13:17:32.871]                           has_future <- base::requireNamespace("future", 
[13:17:32.871]                             quietly = TRUE)
[13:17:32.871]                           if (has_future) {
[13:17:32.871]                             ns <- base::getNamespace("future")
[13:17:32.871]                             version <- ns[[".package"]][["version"]]
[13:17:32.871]                             if (is.null(version)) 
[13:17:32.871]                               version <- utils::packageVersion("future")
[13:17:32.871]                           }
[13:17:32.871]                           else {
[13:17:32.871]                             version <- NULL
[13:17:32.871]                           }
[13:17:32.871]                           if (!has_future || version < "1.8.0") {
[13:17:32.871]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.871]                               "", base::R.version$version.string), 
[13:17:32.871]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:32.871]                                 base::R.version$platform, 8 * 
[13:17:32.871]                                   base::.Machine$sizeof.pointer), 
[13:17:32.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.871]                                 "release", "version")], collapse = " "), 
[13:17:32.871]                               hostname = base::Sys.info()[["nodename"]])
[13:17:32.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.871]                               info)
[13:17:32.871]                             info <- base::paste(info, collapse = "; ")
[13:17:32.871]                             if (!has_future) {
[13:17:32.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.871]                                 info)
[13:17:32.871]                             }
[13:17:32.871]                             else {
[13:17:32.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.871]                                 info, version)
[13:17:32.871]                             }
[13:17:32.871]                             base::stop(msg)
[13:17:32.871]                           }
[13:17:32.871]                         })
[13:17:32.871]                       }
[13:17:32.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.871]                       base::options(mc.cores = 1L)
[13:17:32.871]                     }
[13:17:32.871]                     base::local({
[13:17:32.871]                       for (pkg in "stats") {
[13:17:32.871]                         base::loadNamespace(pkg)
[13:17:32.871]                         base::library(pkg, character.only = TRUE)
[13:17:32.871]                       }
[13:17:32.871]                     })
[13:17:32.871]                   }
[13:17:32.871]                   options(future.plan = NULL)
[13:17:32.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.871]                 }
[13:17:32.871]                 ...future.workdir <- getwd()
[13:17:32.871]             }
[13:17:32.871]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.871]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.871]         }
[13:17:32.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:32.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.871]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.871]             base::names(...future.oldOptions))
[13:17:32.871]     }
[13:17:32.871]     if (FALSE) {
[13:17:32.871]     }
[13:17:32.871]     else {
[13:17:32.871]         if (TRUE) {
[13:17:32.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.871]                 open = "w")
[13:17:32.871]         }
[13:17:32.871]         else {
[13:17:32.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.871]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.871]         }
[13:17:32.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.871]             base::sink(type = "output", split = FALSE)
[13:17:32.871]             base::close(...future.stdout)
[13:17:32.871]         }, add = TRUE)
[13:17:32.871]     }
[13:17:32.871]     ...future.frame <- base::sys.nframe()
[13:17:32.871]     ...future.conditions <- base::list()
[13:17:32.871]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.871]     if (FALSE) {
[13:17:32.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.871]     }
[13:17:32.871]     ...future.result <- base::tryCatch({
[13:17:32.871]         base::withCallingHandlers({
[13:17:32.871]             ...future.value <- base::withVisible(base::local({
[13:17:32.871]                 withCallingHandlers({
[13:17:32.871]                   {
[13:17:32.871]                     do.call(function(...) {
[13:17:32.871]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.871]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.871]                         ...future.globals.maxSize)) {
[13:17:32.871]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.871]                         on.exit(options(oopts), add = TRUE)
[13:17:32.871]                       }
[13:17:32.871]                       {
[13:17:32.871]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.871]                           FUN = function(jj) {
[13:17:32.871]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.871]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.871]                           })
[13:17:32.871]                       }
[13:17:32.871]                     }, args = future.call.arguments)
[13:17:32.871]                   }
[13:17:32.871]                 }, immediateCondition = function(cond) {
[13:17:32.871]                   save_rds <- function (object, pathname, ...) 
[13:17:32.871]                   {
[13:17:32.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:32.871]                     if (file_test("-f", pathname_tmp)) {
[13:17:32.871]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:32.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.871]                         fi_tmp[["mtime"]])
[13:17:32.871]                     }
[13:17:32.871]                     tryCatch({
[13:17:32.871]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:32.871]                     }, error = function(ex) {
[13:17:32.871]                       msg <- conditionMessage(ex)
[13:17:32.871]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:32.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.871]                         fi_tmp[["mtime"]], msg)
[13:17:32.871]                       ex$message <- msg
[13:17:32.871]                       stop(ex)
[13:17:32.871]                     })
[13:17:32.871]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:32.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:32.871]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:32.871]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.871]                       fi <- file.info(pathname)
[13:17:32.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:32.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:32.871]                         fi[["size"]], fi[["mtime"]])
[13:17:32.871]                       stop(msg)
[13:17:32.871]                     }
[13:17:32.871]                     invisible(pathname)
[13:17:32.871]                   }
[13:17:32.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:32.871]                     rootPath = tempdir()) 
[13:17:32.871]                   {
[13:17:32.871]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:32.871]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:32.871]                       tmpdir = path, fileext = ".rds")
[13:17:32.871]                     save_rds(obj, file)
[13:17:32.871]                   }
[13:17:32.871]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:32.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.871]                   {
[13:17:32.871]                     inherits <- base::inherits
[13:17:32.871]                     invokeRestart <- base::invokeRestart
[13:17:32.871]                     is.null <- base::is.null
[13:17:32.871]                     muffled <- FALSE
[13:17:32.871]                     if (inherits(cond, "message")) {
[13:17:32.871]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.871]                       if (muffled) 
[13:17:32.871]                         invokeRestart("muffleMessage")
[13:17:32.871]                     }
[13:17:32.871]                     else if (inherits(cond, "warning")) {
[13:17:32.871]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.871]                       if (muffled) 
[13:17:32.871]                         invokeRestart("muffleWarning")
[13:17:32.871]                     }
[13:17:32.871]                     else if (inherits(cond, "condition")) {
[13:17:32.871]                       if (!is.null(pattern)) {
[13:17:32.871]                         computeRestarts <- base::computeRestarts
[13:17:32.871]                         grepl <- base::grepl
[13:17:32.871]                         restarts <- computeRestarts(cond)
[13:17:32.871]                         for (restart in restarts) {
[13:17:32.871]                           name <- restart$name
[13:17:32.871]                           if (is.null(name)) 
[13:17:32.871]                             next
[13:17:32.871]                           if (!grepl(pattern, name)) 
[13:17:32.871]                             next
[13:17:32.871]                           invokeRestart(restart)
[13:17:32.871]                           muffled <- TRUE
[13:17:32.871]                           break
[13:17:32.871]                         }
[13:17:32.871]                       }
[13:17:32.871]                     }
[13:17:32.871]                     invisible(muffled)
[13:17:32.871]                   }
[13:17:32.871]                   muffleCondition(cond)
[13:17:32.871]                 })
[13:17:32.871]             }))
[13:17:32.871]             future::FutureResult(value = ...future.value$value, 
[13:17:32.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.871]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.871]                     ...future.globalenv.names))
[13:17:32.871]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.871]         }, condition = base::local({
[13:17:32.871]             c <- base::c
[13:17:32.871]             inherits <- base::inherits
[13:17:32.871]             invokeRestart <- base::invokeRestart
[13:17:32.871]             length <- base::length
[13:17:32.871]             list <- base::list
[13:17:32.871]             seq.int <- base::seq.int
[13:17:32.871]             signalCondition <- base::signalCondition
[13:17:32.871]             sys.calls <- base::sys.calls
[13:17:32.871]             `[[` <- base::`[[`
[13:17:32.871]             `+` <- base::`+`
[13:17:32.871]             `<<-` <- base::`<<-`
[13:17:32.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.871]                   3L)]
[13:17:32.871]             }
[13:17:32.871]             function(cond) {
[13:17:32.871]                 is_error <- inherits(cond, "error")
[13:17:32.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.871]                   NULL)
[13:17:32.871]                 if (is_error) {
[13:17:32.871]                   sessionInformation <- function() {
[13:17:32.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.871]                       search = base::search(), system = base::Sys.info())
[13:17:32.871]                   }
[13:17:32.871]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.871]                     cond$call), session = sessionInformation(), 
[13:17:32.871]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.871]                   signalCondition(cond)
[13:17:32.871]                 }
[13:17:32.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.871]                 "immediateCondition"))) {
[13:17:32.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.871]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.871]                   if (TRUE && !signal) {
[13:17:32.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.871]                     {
[13:17:32.871]                       inherits <- base::inherits
[13:17:32.871]                       invokeRestart <- base::invokeRestart
[13:17:32.871]                       is.null <- base::is.null
[13:17:32.871]                       muffled <- FALSE
[13:17:32.871]                       if (inherits(cond, "message")) {
[13:17:32.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.871]                         if (muffled) 
[13:17:32.871]                           invokeRestart("muffleMessage")
[13:17:32.871]                       }
[13:17:32.871]                       else if (inherits(cond, "warning")) {
[13:17:32.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.871]                         if (muffled) 
[13:17:32.871]                           invokeRestart("muffleWarning")
[13:17:32.871]                       }
[13:17:32.871]                       else if (inherits(cond, "condition")) {
[13:17:32.871]                         if (!is.null(pattern)) {
[13:17:32.871]                           computeRestarts <- base::computeRestarts
[13:17:32.871]                           grepl <- base::grepl
[13:17:32.871]                           restarts <- computeRestarts(cond)
[13:17:32.871]                           for (restart in restarts) {
[13:17:32.871]                             name <- restart$name
[13:17:32.871]                             if (is.null(name)) 
[13:17:32.871]                               next
[13:17:32.871]                             if (!grepl(pattern, name)) 
[13:17:32.871]                               next
[13:17:32.871]                             invokeRestart(restart)
[13:17:32.871]                             muffled <- TRUE
[13:17:32.871]                             break
[13:17:32.871]                           }
[13:17:32.871]                         }
[13:17:32.871]                       }
[13:17:32.871]                       invisible(muffled)
[13:17:32.871]                     }
[13:17:32.871]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.871]                   }
[13:17:32.871]                 }
[13:17:32.871]                 else {
[13:17:32.871]                   if (TRUE) {
[13:17:32.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.871]                     {
[13:17:32.871]                       inherits <- base::inherits
[13:17:32.871]                       invokeRestart <- base::invokeRestart
[13:17:32.871]                       is.null <- base::is.null
[13:17:32.871]                       muffled <- FALSE
[13:17:32.871]                       if (inherits(cond, "message")) {
[13:17:32.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.871]                         if (muffled) 
[13:17:32.871]                           invokeRestart("muffleMessage")
[13:17:32.871]                       }
[13:17:32.871]                       else if (inherits(cond, "warning")) {
[13:17:32.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.871]                         if (muffled) 
[13:17:32.871]                           invokeRestart("muffleWarning")
[13:17:32.871]                       }
[13:17:32.871]                       else if (inherits(cond, "condition")) {
[13:17:32.871]                         if (!is.null(pattern)) {
[13:17:32.871]                           computeRestarts <- base::computeRestarts
[13:17:32.871]                           grepl <- base::grepl
[13:17:32.871]                           restarts <- computeRestarts(cond)
[13:17:32.871]                           for (restart in restarts) {
[13:17:32.871]                             name <- restart$name
[13:17:32.871]                             if (is.null(name)) 
[13:17:32.871]                               next
[13:17:32.871]                             if (!grepl(pattern, name)) 
[13:17:32.871]                               next
[13:17:32.871]                             invokeRestart(restart)
[13:17:32.871]                             muffled <- TRUE
[13:17:32.871]                             break
[13:17:32.871]                           }
[13:17:32.871]                         }
[13:17:32.871]                       }
[13:17:32.871]                       invisible(muffled)
[13:17:32.871]                     }
[13:17:32.871]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.871]                   }
[13:17:32.871]                 }
[13:17:32.871]             }
[13:17:32.871]         }))
[13:17:32.871]     }, error = function(ex) {
[13:17:32.871]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.871]                 ...future.rng), started = ...future.startTime, 
[13:17:32.871]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.871]             version = "1.8"), class = "FutureResult")
[13:17:32.871]     }, finally = {
[13:17:32.871]         if (!identical(...future.workdir, getwd())) 
[13:17:32.871]             setwd(...future.workdir)
[13:17:32.871]         {
[13:17:32.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.871]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.871]             }
[13:17:32.871]             base::options(...future.oldOptions)
[13:17:32.871]             if (.Platform$OS.type == "windows") {
[13:17:32.871]                 old_names <- names(...future.oldEnvVars)
[13:17:32.871]                 envs <- base::Sys.getenv()
[13:17:32.871]                 names <- names(envs)
[13:17:32.871]                 common <- intersect(names, old_names)
[13:17:32.871]                 added <- setdiff(names, old_names)
[13:17:32.871]                 removed <- setdiff(old_names, names)
[13:17:32.871]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.871]                   envs[common]]
[13:17:32.871]                 NAMES <- toupper(changed)
[13:17:32.871]                 args <- list()
[13:17:32.871]                 for (kk in seq_along(NAMES)) {
[13:17:32.871]                   name <- changed[[kk]]
[13:17:32.871]                   NAME <- NAMES[[kk]]
[13:17:32.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.871]                     next
[13:17:32.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.871]                 }
[13:17:32.871]                 NAMES <- toupper(added)
[13:17:32.871]                 for (kk in seq_along(NAMES)) {
[13:17:32.871]                   name <- added[[kk]]
[13:17:32.871]                   NAME <- NAMES[[kk]]
[13:17:32.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.871]                     next
[13:17:32.871]                   args[[name]] <- ""
[13:17:32.871]                 }
[13:17:32.871]                 NAMES <- toupper(removed)
[13:17:32.871]                 for (kk in seq_along(NAMES)) {
[13:17:32.871]                   name <- removed[[kk]]
[13:17:32.871]                   NAME <- NAMES[[kk]]
[13:17:32.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.871]                     next
[13:17:32.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.871]                 }
[13:17:32.871]                 if (length(args) > 0) 
[13:17:32.871]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.871]             }
[13:17:32.871]             else {
[13:17:32.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.871]             }
[13:17:32.871]             {
[13:17:32.871]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.871]                   0L) {
[13:17:32.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.871]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.871]                   base::options(opts)
[13:17:32.871]                 }
[13:17:32.871]                 {
[13:17:32.871]                   {
[13:17:32.871]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.871]                     NULL
[13:17:32.871]                   }
[13:17:32.871]                   options(future.plan = NULL)
[13:17:32.871]                   if (is.na(NA_character_)) 
[13:17:32.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.871]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:32.871]                     envir = parent.frame()) 
[13:17:32.871]                   {
[13:17:32.871]                     default_workers <- missing(workers)
[13:17:32.871]                     if (is.function(workers)) 
[13:17:32.871]                       workers <- workers()
[13:17:32.871]                     workers <- structure(as.integer(workers), 
[13:17:32.871]                       class = class(workers))
[13:17:32.871]                     stop_if_not(is.finite(workers), workers >= 
[13:17:32.871]                       1L)
[13:17:32.871]                     if ((workers == 1L && !inherits(workers, 
[13:17:32.871]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:32.871]                       if (default_workers) 
[13:17:32.871]                         supportsMulticore(warn = TRUE)
[13:17:32.871]                       return(sequential(..., envir = envir))
[13:17:32.871]                     }
[13:17:32.871]                     oopts <- options(mc.cores = workers)
[13:17:32.871]                     on.exit(options(oopts))
[13:17:32.871]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:32.871]                       envir = envir)
[13:17:32.871]                     if (!future$lazy) 
[13:17:32.871]                       future <- run(future)
[13:17:32.871]                     invisible(future)
[13:17:32.871]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.871]                 }
[13:17:32.871]             }
[13:17:32.871]         }
[13:17:32.871]     })
[13:17:32.871]     if (TRUE) {
[13:17:32.871]         base::sink(type = "output", split = FALSE)
[13:17:32.871]         if (TRUE) {
[13:17:32.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.871]         }
[13:17:32.871]         else {
[13:17:32.871]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.871]         }
[13:17:32.871]         base::close(...future.stdout)
[13:17:32.871]         ...future.stdout <- NULL
[13:17:32.871]     }
[13:17:32.871]     ...future.result$conditions <- ...future.conditions
[13:17:32.871]     ...future.result$finished <- base::Sys.time()
[13:17:32.871]     ...future.result
[13:17:32.871] }
[13:17:32.873] assign_globals() ...
[13:17:32.873] List of 5
[13:17:32.873]  $ ...future.FUN            :function (x, ...)  
[13:17:32.873]  $ future.call.arguments    :List of 1
[13:17:32.873]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.873]  $ ...future.elements_ii    :List of 1
[13:17:32.873]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.873]  $ ...future.seeds_ii       : NULL
[13:17:32.873]  $ ...future.globals.maxSize: NULL
[13:17:32.873]  - attr(*, "where")=List of 5
[13:17:32.873]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.873]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.873]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.873]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.873]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.873]  - attr(*, "resolved")= logi FALSE
[13:17:32.873]  - attr(*, "total_size")= num 1328
[13:17:32.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.873]  - attr(*, "already-done")= logi TRUE
[13:17:32.878] - copied ‘...future.FUN’ to environment
[13:17:32.879] - copied ‘future.call.arguments’ to environment
[13:17:32.879] - copied ‘...future.elements_ii’ to environment
[13:17:32.879] - copied ‘...future.seeds_ii’ to environment
[13:17:32.879] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.879] assign_globals() ... done
[13:17:32.879] requestCore(): workers = 2
[13:17:32.881] MulticoreFuture started
[13:17:32.881] - Launch lazy future ... done
[13:17:32.882] run() for ‘MulticoreFuture’ ... done
[13:17:32.882] Created future:
[13:17:32.883] plan(): Setting new future strategy stack:
[13:17:32.883] List of future strategies:
[13:17:32.883] 1. sequential:
[13:17:32.883]    - args: function (..., envir = parent.frame())
[13:17:32.883]    - tweaked: FALSE
[13:17:32.883]    - call: NULL
[13:17:32.884] plan(): nbrOfWorkers() = 1
[13:17:32.886] plan(): Setting new future strategy stack:
[13:17:32.886] List of future strategies:
[13:17:32.886] 1. multicore:
[13:17:32.886]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:32.886]    - tweaked: FALSE
[13:17:32.886]    - call: plan(strategy)
[13:17:32.891] plan(): nbrOfWorkers() = 2
[13:17:32.882] MulticoreFuture:
[13:17:32.882] Label: ‘future_eapply-1’
[13:17:32.882] Expression:
[13:17:32.882] {
[13:17:32.882]     do.call(function(...) {
[13:17:32.882]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.882]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.882]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.882]             on.exit(options(oopts), add = TRUE)
[13:17:32.882]         }
[13:17:32.882]         {
[13:17:32.882]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.882]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.882]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.882]             })
[13:17:32.882]         }
[13:17:32.882]     }, args = future.call.arguments)
[13:17:32.882] }
[13:17:32.882] Lazy evaluation: FALSE
[13:17:32.882] Asynchronous evaluation: TRUE
[13:17:32.882] Local evaluation: TRUE
[13:17:32.882] Environment: R_GlobalEnv
[13:17:32.882] Capture standard output: TRUE
[13:17:32.882] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.882] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.882] Packages: 1 packages (‘stats’)
[13:17:32.882] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.882] Resolved: TRUE
[13:17:32.882] Value: <not collected>
[13:17:32.882] Conditions captured: <none>
[13:17:32.882] Early signaling: FALSE
[13:17:32.882] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.882] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.892] Chunk #1 of 2 ... DONE
[13:17:32.893] Chunk #2 of 2 ...
[13:17:32.893]  - Finding globals in 'X' for chunk #2 ...
[13:17:32.893] getGlobalsAndPackages() ...
[13:17:32.893] Searching for globals...
[13:17:32.894] 
[13:17:32.894] Searching for globals ... DONE
[13:17:32.894] - globals: [0] <none>
[13:17:32.894] getGlobalsAndPackages() ... DONE
[13:17:32.894]    + additional globals found: [n=0] 
[13:17:32.894]    + additional namespaces needed: [n=0] 
[13:17:32.894]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:32.895]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:32.895]  - seeds: <none>
[13:17:32.895] getGlobalsAndPackages() ...
[13:17:32.895] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.895] Resolving globals: FALSE
[13:17:32.895] Tweak future expression to call with '...' arguments ...
[13:17:32.896] {
[13:17:32.896]     do.call(function(...) {
[13:17:32.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.896]             on.exit(options(oopts), add = TRUE)
[13:17:32.896]         }
[13:17:32.896]         {
[13:17:32.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.896]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.896]             })
[13:17:32.896]         }
[13:17:32.896]     }, args = future.call.arguments)
[13:17:32.896] }
[13:17:32.896] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.897] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.897] - packages: [1] ‘stats’
[13:17:32.897] getGlobalsAndPackages() ... DONE
[13:17:32.897] run() for ‘Future’ ...
[13:17:32.898] - state: ‘created’
[13:17:32.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.902] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:32.903]   - Field: ‘label’
[13:17:32.903]   - Field: ‘local’
[13:17:32.903]   - Field: ‘owner’
[13:17:32.903]   - Field: ‘envir’
[13:17:32.903]   - Field: ‘workers’
[13:17:32.904]   - Field: ‘packages’
[13:17:32.904]   - Field: ‘gc’
[13:17:32.904]   - Field: ‘job’
[13:17:32.904]   - Field: ‘conditions’
[13:17:32.904]   - Field: ‘expr’
[13:17:32.904]   - Field: ‘uuid’
[13:17:32.904]   - Field: ‘seed’
[13:17:32.905]   - Field: ‘version’
[13:17:32.905]   - Field: ‘result’
[13:17:32.905]   - Field: ‘asynchronous’
[13:17:32.905]   - Field: ‘calls’
[13:17:32.905]   - Field: ‘globals’
[13:17:32.905]   - Field: ‘stdout’
[13:17:32.905]   - Field: ‘earlySignal’
[13:17:32.906]   - Field: ‘lazy’
[13:17:32.906]   - Field: ‘state’
[13:17:32.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:32.906] - Launch lazy future ...
[13:17:32.906] Packages needed by the future expression (n = 1): ‘stats’
[13:17:32.907] Packages needed by future strategies (n = 0): <none>
[13:17:32.907] {
[13:17:32.907]     {
[13:17:32.907]         {
[13:17:32.907]             ...future.startTime <- base::Sys.time()
[13:17:32.907]             {
[13:17:32.907]                 {
[13:17:32.907]                   {
[13:17:32.907]                     {
[13:17:32.907]                       {
[13:17:32.907]                         base::local({
[13:17:32.907]                           has_future <- base::requireNamespace("future", 
[13:17:32.907]                             quietly = TRUE)
[13:17:32.907]                           if (has_future) {
[13:17:32.907]                             ns <- base::getNamespace("future")
[13:17:32.907]                             version <- ns[[".package"]][["version"]]
[13:17:32.907]                             if (is.null(version)) 
[13:17:32.907]                               version <- utils::packageVersion("future")
[13:17:32.907]                           }
[13:17:32.907]                           else {
[13:17:32.907]                             version <- NULL
[13:17:32.907]                           }
[13:17:32.907]                           if (!has_future || version < "1.8.0") {
[13:17:32.907]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.907]                               "", base::R.version$version.string), 
[13:17:32.907]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:32.907]                                 base::R.version$platform, 8 * 
[13:17:32.907]                                   base::.Machine$sizeof.pointer), 
[13:17:32.907]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.907]                                 "release", "version")], collapse = " "), 
[13:17:32.907]                               hostname = base::Sys.info()[["nodename"]])
[13:17:32.907]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.907]                               info)
[13:17:32.907]                             info <- base::paste(info, collapse = "; ")
[13:17:32.907]                             if (!has_future) {
[13:17:32.907]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.907]                                 info)
[13:17:32.907]                             }
[13:17:32.907]                             else {
[13:17:32.907]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.907]                                 info, version)
[13:17:32.907]                             }
[13:17:32.907]                             base::stop(msg)
[13:17:32.907]                           }
[13:17:32.907]                         })
[13:17:32.907]                       }
[13:17:32.907]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.907]                       base::options(mc.cores = 1L)
[13:17:32.907]                     }
[13:17:32.907]                     base::local({
[13:17:32.907]                       for (pkg in "stats") {
[13:17:32.907]                         base::loadNamespace(pkg)
[13:17:32.907]                         base::library(pkg, character.only = TRUE)
[13:17:32.907]                       }
[13:17:32.907]                     })
[13:17:32.907]                   }
[13:17:32.907]                   options(future.plan = NULL)
[13:17:32.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.907]                 }
[13:17:32.907]                 ...future.workdir <- getwd()
[13:17:32.907]             }
[13:17:32.907]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.907]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.907]         }
[13:17:32.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.907]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:32.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.907]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.907]             base::names(...future.oldOptions))
[13:17:32.907]     }
[13:17:32.907]     if (FALSE) {
[13:17:32.907]     }
[13:17:32.907]     else {
[13:17:32.907]         if (TRUE) {
[13:17:32.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.907]                 open = "w")
[13:17:32.907]         }
[13:17:32.907]         else {
[13:17:32.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.907]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.907]         }
[13:17:32.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.907]             base::sink(type = "output", split = FALSE)
[13:17:32.907]             base::close(...future.stdout)
[13:17:32.907]         }, add = TRUE)
[13:17:32.907]     }
[13:17:32.907]     ...future.frame <- base::sys.nframe()
[13:17:32.907]     ...future.conditions <- base::list()
[13:17:32.907]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.907]     if (FALSE) {
[13:17:32.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.907]     }
[13:17:32.907]     ...future.result <- base::tryCatch({
[13:17:32.907]         base::withCallingHandlers({
[13:17:32.907]             ...future.value <- base::withVisible(base::local({
[13:17:32.907]                 withCallingHandlers({
[13:17:32.907]                   {
[13:17:32.907]                     do.call(function(...) {
[13:17:32.907]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.907]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.907]                         ...future.globals.maxSize)) {
[13:17:32.907]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.907]                         on.exit(options(oopts), add = TRUE)
[13:17:32.907]                       }
[13:17:32.907]                       {
[13:17:32.907]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.907]                           FUN = function(jj) {
[13:17:32.907]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.907]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.907]                           })
[13:17:32.907]                       }
[13:17:32.907]                     }, args = future.call.arguments)
[13:17:32.907]                   }
[13:17:32.907]                 }, immediateCondition = function(cond) {
[13:17:32.907]                   save_rds <- function (object, pathname, ...) 
[13:17:32.907]                   {
[13:17:32.907]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:32.907]                     if (file_test("-f", pathname_tmp)) {
[13:17:32.907]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.907]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:32.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.907]                         fi_tmp[["mtime"]])
[13:17:32.907]                     }
[13:17:32.907]                     tryCatch({
[13:17:32.907]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:32.907]                     }, error = function(ex) {
[13:17:32.907]                       msg <- conditionMessage(ex)
[13:17:32.907]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.907]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:32.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.907]                         fi_tmp[["mtime"]], msg)
[13:17:32.907]                       ex$message <- msg
[13:17:32.907]                       stop(ex)
[13:17:32.907]                     })
[13:17:32.907]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:32.907]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:32.907]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:32.907]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.907]                       fi <- file.info(pathname)
[13:17:32.907]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:32.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.907]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:32.907]                         fi[["size"]], fi[["mtime"]])
[13:17:32.907]                       stop(msg)
[13:17:32.907]                     }
[13:17:32.907]                     invisible(pathname)
[13:17:32.907]                   }
[13:17:32.907]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:32.907]                     rootPath = tempdir()) 
[13:17:32.907]                   {
[13:17:32.907]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:32.907]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:32.907]                       tmpdir = path, fileext = ".rds")
[13:17:32.907]                     save_rds(obj, file)
[13:17:32.907]                   }
[13:17:32.907]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:32.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.907]                   {
[13:17:32.907]                     inherits <- base::inherits
[13:17:32.907]                     invokeRestart <- base::invokeRestart
[13:17:32.907]                     is.null <- base::is.null
[13:17:32.907]                     muffled <- FALSE
[13:17:32.907]                     if (inherits(cond, "message")) {
[13:17:32.907]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.907]                       if (muffled) 
[13:17:32.907]                         invokeRestart("muffleMessage")
[13:17:32.907]                     }
[13:17:32.907]                     else if (inherits(cond, "warning")) {
[13:17:32.907]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.907]                       if (muffled) 
[13:17:32.907]                         invokeRestart("muffleWarning")
[13:17:32.907]                     }
[13:17:32.907]                     else if (inherits(cond, "condition")) {
[13:17:32.907]                       if (!is.null(pattern)) {
[13:17:32.907]                         computeRestarts <- base::computeRestarts
[13:17:32.907]                         grepl <- base::grepl
[13:17:32.907]                         restarts <- computeRestarts(cond)
[13:17:32.907]                         for (restart in restarts) {
[13:17:32.907]                           name <- restart$name
[13:17:32.907]                           if (is.null(name)) 
[13:17:32.907]                             next
[13:17:32.907]                           if (!grepl(pattern, name)) 
[13:17:32.907]                             next
[13:17:32.907]                           invokeRestart(restart)
[13:17:32.907]                           muffled <- TRUE
[13:17:32.907]                           break
[13:17:32.907]                         }
[13:17:32.907]                       }
[13:17:32.907]                     }
[13:17:32.907]                     invisible(muffled)
[13:17:32.907]                   }
[13:17:32.907]                   muffleCondition(cond)
[13:17:32.907]                 })
[13:17:32.907]             }))
[13:17:32.907]             future::FutureResult(value = ...future.value$value, 
[13:17:32.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.907]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.907]                     ...future.globalenv.names))
[13:17:32.907]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.907]         }, condition = base::local({
[13:17:32.907]             c <- base::c
[13:17:32.907]             inherits <- base::inherits
[13:17:32.907]             invokeRestart <- base::invokeRestart
[13:17:32.907]             length <- base::length
[13:17:32.907]             list <- base::list
[13:17:32.907]             seq.int <- base::seq.int
[13:17:32.907]             signalCondition <- base::signalCondition
[13:17:32.907]             sys.calls <- base::sys.calls
[13:17:32.907]             `[[` <- base::`[[`
[13:17:32.907]             `+` <- base::`+`
[13:17:32.907]             `<<-` <- base::`<<-`
[13:17:32.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.907]                   3L)]
[13:17:32.907]             }
[13:17:32.907]             function(cond) {
[13:17:32.907]                 is_error <- inherits(cond, "error")
[13:17:32.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.907]                   NULL)
[13:17:32.907]                 if (is_error) {
[13:17:32.907]                   sessionInformation <- function() {
[13:17:32.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.907]                       search = base::search(), system = base::Sys.info())
[13:17:32.907]                   }
[13:17:32.907]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.907]                     cond$call), session = sessionInformation(), 
[13:17:32.907]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.907]                   signalCondition(cond)
[13:17:32.907]                 }
[13:17:32.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.907]                 "immediateCondition"))) {
[13:17:32.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.907]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.907]                   if (TRUE && !signal) {
[13:17:32.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.907]                     {
[13:17:32.907]                       inherits <- base::inherits
[13:17:32.907]                       invokeRestart <- base::invokeRestart
[13:17:32.907]                       is.null <- base::is.null
[13:17:32.907]                       muffled <- FALSE
[13:17:32.907]                       if (inherits(cond, "message")) {
[13:17:32.907]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.907]                         if (muffled) 
[13:17:32.907]                           invokeRestart("muffleMessage")
[13:17:32.907]                       }
[13:17:32.907]                       else if (inherits(cond, "warning")) {
[13:17:32.907]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.907]                         if (muffled) 
[13:17:32.907]                           invokeRestart("muffleWarning")
[13:17:32.907]                       }
[13:17:32.907]                       else if (inherits(cond, "condition")) {
[13:17:32.907]                         if (!is.null(pattern)) {
[13:17:32.907]                           computeRestarts <- base::computeRestarts
[13:17:32.907]                           grepl <- base::grepl
[13:17:32.907]                           restarts <- computeRestarts(cond)
[13:17:32.907]                           for (restart in restarts) {
[13:17:32.907]                             name <- restart$name
[13:17:32.907]                             if (is.null(name)) 
[13:17:32.907]                               next
[13:17:32.907]                             if (!grepl(pattern, name)) 
[13:17:32.907]                               next
[13:17:32.907]                             invokeRestart(restart)
[13:17:32.907]                             muffled <- TRUE
[13:17:32.907]                             break
[13:17:32.907]                           }
[13:17:32.907]                         }
[13:17:32.907]                       }
[13:17:32.907]                       invisible(muffled)
[13:17:32.907]                     }
[13:17:32.907]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.907]                   }
[13:17:32.907]                 }
[13:17:32.907]                 else {
[13:17:32.907]                   if (TRUE) {
[13:17:32.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.907]                     {
[13:17:32.907]                       inherits <- base::inherits
[13:17:32.907]                       invokeRestart <- base::invokeRestart
[13:17:32.907]                       is.null <- base::is.null
[13:17:32.907]                       muffled <- FALSE
[13:17:32.907]                       if (inherits(cond, "message")) {
[13:17:32.907]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.907]                         if (muffled) 
[13:17:32.907]                           invokeRestart("muffleMessage")
[13:17:32.907]                       }
[13:17:32.907]                       else if (inherits(cond, "warning")) {
[13:17:32.907]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.907]                         if (muffled) 
[13:17:32.907]                           invokeRestart("muffleWarning")
[13:17:32.907]                       }
[13:17:32.907]                       else if (inherits(cond, "condition")) {
[13:17:32.907]                         if (!is.null(pattern)) {
[13:17:32.907]                           computeRestarts <- base::computeRestarts
[13:17:32.907]                           grepl <- base::grepl
[13:17:32.907]                           restarts <- computeRestarts(cond)
[13:17:32.907]                           for (restart in restarts) {
[13:17:32.907]                             name <- restart$name
[13:17:32.907]                             if (is.null(name)) 
[13:17:32.907]                               next
[13:17:32.907]                             if (!grepl(pattern, name)) 
[13:17:32.907]                               next
[13:17:32.907]                             invokeRestart(restart)
[13:17:32.907]                             muffled <- TRUE
[13:17:32.907]                             break
[13:17:32.907]                           }
[13:17:32.907]                         }
[13:17:32.907]                       }
[13:17:32.907]                       invisible(muffled)
[13:17:32.907]                     }
[13:17:32.907]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.907]                   }
[13:17:32.907]                 }
[13:17:32.907]             }
[13:17:32.907]         }))
[13:17:32.907]     }, error = function(ex) {
[13:17:32.907]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.907]                 ...future.rng), started = ...future.startTime, 
[13:17:32.907]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.907]             version = "1.8"), class = "FutureResult")
[13:17:32.907]     }, finally = {
[13:17:32.907]         if (!identical(...future.workdir, getwd())) 
[13:17:32.907]             setwd(...future.workdir)
[13:17:32.907]         {
[13:17:32.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.907]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.907]             }
[13:17:32.907]             base::options(...future.oldOptions)
[13:17:32.907]             if (.Platform$OS.type == "windows") {
[13:17:32.907]                 old_names <- names(...future.oldEnvVars)
[13:17:32.907]                 envs <- base::Sys.getenv()
[13:17:32.907]                 names <- names(envs)
[13:17:32.907]                 common <- intersect(names, old_names)
[13:17:32.907]                 added <- setdiff(names, old_names)
[13:17:32.907]                 removed <- setdiff(old_names, names)
[13:17:32.907]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.907]                   envs[common]]
[13:17:32.907]                 NAMES <- toupper(changed)
[13:17:32.907]                 args <- list()
[13:17:32.907]                 for (kk in seq_along(NAMES)) {
[13:17:32.907]                   name <- changed[[kk]]
[13:17:32.907]                   NAME <- NAMES[[kk]]
[13:17:32.907]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.907]                     next
[13:17:32.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.907]                 }
[13:17:32.907]                 NAMES <- toupper(added)
[13:17:32.907]                 for (kk in seq_along(NAMES)) {
[13:17:32.907]                   name <- added[[kk]]
[13:17:32.907]                   NAME <- NAMES[[kk]]
[13:17:32.907]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.907]                     next
[13:17:32.907]                   args[[name]] <- ""
[13:17:32.907]                 }
[13:17:32.907]                 NAMES <- toupper(removed)
[13:17:32.907]                 for (kk in seq_along(NAMES)) {
[13:17:32.907]                   name <- removed[[kk]]
[13:17:32.907]                   NAME <- NAMES[[kk]]
[13:17:32.907]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.907]                     next
[13:17:32.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.907]                 }
[13:17:32.907]                 if (length(args) > 0) 
[13:17:32.907]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.907]             }
[13:17:32.907]             else {
[13:17:32.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.907]             }
[13:17:32.907]             {
[13:17:32.907]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.907]                   0L) {
[13:17:32.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.907]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.907]                   base::options(opts)
[13:17:32.907]                 }
[13:17:32.907]                 {
[13:17:32.907]                   {
[13:17:32.907]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.907]                     NULL
[13:17:32.907]                   }
[13:17:32.907]                   options(future.plan = NULL)
[13:17:32.907]                   if (is.na(NA_character_)) 
[13:17:32.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.907]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:32.907]                     envir = parent.frame()) 
[13:17:32.907]                   {
[13:17:32.907]                     default_workers <- missing(workers)
[13:17:32.907]                     if (is.function(workers)) 
[13:17:32.907]                       workers <- workers()
[13:17:32.907]                     workers <- structure(as.integer(workers), 
[13:17:32.907]                       class = class(workers))
[13:17:32.907]                     stop_if_not(is.finite(workers), workers >= 
[13:17:32.907]                       1L)
[13:17:32.907]                     if ((workers == 1L && !inherits(workers, 
[13:17:32.907]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:32.907]                       if (default_workers) 
[13:17:32.907]                         supportsMulticore(warn = TRUE)
[13:17:32.907]                       return(sequential(..., envir = envir))
[13:17:32.907]                     }
[13:17:32.907]                     oopts <- options(mc.cores = workers)
[13:17:32.907]                     on.exit(options(oopts))
[13:17:32.907]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:32.907]                       envir = envir)
[13:17:32.907]                     if (!future$lazy) 
[13:17:32.907]                       future <- run(future)
[13:17:32.907]                     invisible(future)
[13:17:32.907]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.907]                 }
[13:17:32.907]             }
[13:17:32.907]         }
[13:17:32.907]     })
[13:17:32.907]     if (TRUE) {
[13:17:32.907]         base::sink(type = "output", split = FALSE)
[13:17:32.907]         if (TRUE) {
[13:17:32.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.907]         }
[13:17:32.907]         else {
[13:17:32.907]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.907]         }
[13:17:32.907]         base::close(...future.stdout)
[13:17:32.907]         ...future.stdout <- NULL
[13:17:32.907]     }
[13:17:32.907]     ...future.result$conditions <- ...future.conditions
[13:17:32.907]     ...future.result$finished <- base::Sys.time()
[13:17:32.907]     ...future.result
[13:17:32.907] }
[13:17:32.911] assign_globals() ...
[13:17:32.911] List of 5
[13:17:32.911]  $ ...future.FUN            :function (x, ...)  
[13:17:32.911]  $ future.call.arguments    :List of 1
[13:17:32.911]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:32.911]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.911]  $ ...future.elements_ii    :List of 2
[13:17:32.911]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:32.911]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:32.911]  $ ...future.seeds_ii       : NULL
[13:17:32.911]  $ ...future.globals.maxSize: NULL
[13:17:32.911]  - attr(*, "resolved")= logi FALSE
[13:17:32.911]  - attr(*, "total_size")= num 1328
[13:17:32.911]  - attr(*, "where")=List of 5
[13:17:32.911]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.911]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.911]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.911]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.911]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.911]  - attr(*, "already-done")= logi TRUE
[13:17:32.923] - copied ‘...future.FUN’ to environment
[13:17:32.923] - copied ‘future.call.arguments’ to environment
[13:17:32.924] - copied ‘...future.elements_ii’ to environment
[13:17:32.924] - copied ‘...future.seeds_ii’ to environment
[13:17:32.924] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.924] assign_globals() ... done
[13:17:32.924] requestCore(): workers = 2
[13:17:32.926] MulticoreFuture started
[13:17:32.927] - Launch lazy future ... done
[13:17:32.927] run() for ‘MulticoreFuture’ ... done
[13:17:32.927] Created future:
[13:17:32.928] plan(): Setting new future strategy stack:
[13:17:32.928] List of future strategies:
[13:17:32.928] 1. sequential:
[13:17:32.928]    - args: function (..., envir = parent.frame())
[13:17:32.928]    - tweaked: FALSE
[13:17:32.928]    - call: NULL
[13:17:32.929] plan(): nbrOfWorkers() = 1
[13:17:32.932] plan(): Setting new future strategy stack:
[13:17:32.932] List of future strategies:
[13:17:32.932] 1. multicore:
[13:17:32.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:32.932]    - tweaked: FALSE
[13:17:32.932]    - call: plan(strategy)
[13:17:32.937] plan(): nbrOfWorkers() = 2
[13:17:32.927] MulticoreFuture:
[13:17:32.927] Label: ‘future_eapply-2’
[13:17:32.927] Expression:
[13:17:32.927] {
[13:17:32.927]     do.call(function(...) {
[13:17:32.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.927]             on.exit(options(oopts), add = TRUE)
[13:17:32.927]         }
[13:17:32.927]         {
[13:17:32.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.927]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.927]             })
[13:17:32.927]         }
[13:17:32.927]     }, args = future.call.arguments)
[13:17:32.927] }
[13:17:32.927] Lazy evaluation: FALSE
[13:17:32.927] Asynchronous evaluation: TRUE
[13:17:32.927] Local evaluation: TRUE
[13:17:32.927] Environment: R_GlobalEnv
[13:17:32.927] Capture standard output: TRUE
[13:17:32.927] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.927] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.927] Packages: 1 packages (‘stats’)
[13:17:32.927] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.927] Resolved: TRUE
[13:17:32.927] Value: <not collected>
[13:17:32.927] Conditions captured: <none>
[13:17:32.927] Early signaling: FALSE
[13:17:32.927] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.927] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.938] Chunk #2 of 2 ... DONE
[13:17:32.938] Launching 2 futures (chunks) ... DONE
[13:17:32.938] Resolving 2 futures (chunks) ...
[13:17:32.938] resolve() on list ...
[13:17:32.939]  recursive: 0
[13:17:32.939]  length: 2
[13:17:32.939] 
[13:17:32.939] Future #1
[13:17:32.940] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:32.940] - nx: 2
[13:17:32.940] - relay: TRUE
[13:17:32.941] - stdout: TRUE
[13:17:32.941] - signal: TRUE
[13:17:32.941] - resignal: FALSE
[13:17:32.941] - force: TRUE
[13:17:32.941] - relayed: [n=2] FALSE, FALSE
[13:17:32.941] - queued futures: [n=2] FALSE, FALSE
[13:17:32.941]  - until=1
[13:17:32.942]  - relaying element #1
[13:17:32.942] - relayed: [n=2] TRUE, FALSE
[13:17:32.942] - queued futures: [n=2] TRUE, FALSE
[13:17:32.942] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:32.942]  length: 1 (resolved future 1)
[13:17:32.943] Future #2
[13:17:32.944] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:32.944] - nx: 2
[13:17:32.944] - relay: TRUE
[13:17:32.944] - stdout: TRUE
[13:17:32.944] - signal: TRUE
[13:17:32.944] - resignal: FALSE
[13:17:32.944] - force: TRUE
[13:17:32.945] - relayed: [n=2] TRUE, FALSE
[13:17:32.945] - queued futures: [n=2] TRUE, FALSE
[13:17:32.945]  - until=2
[13:17:32.945]  - relaying element #2
[13:17:32.945] - relayed: [n=2] TRUE, TRUE
[13:17:32.945] - queued futures: [n=2] TRUE, TRUE
[13:17:32.945] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:32.946]  length: 0 (resolved future 2)
[13:17:32.946] Relaying remaining futures
[13:17:32.946] signalConditionsASAP(NULL, pos=0) ...
[13:17:32.946] - nx: 2
[13:17:32.946] - relay: TRUE
[13:17:32.946] - stdout: TRUE
[13:17:32.946] - signal: TRUE
[13:17:32.946] - resignal: FALSE
[13:17:32.946] - force: TRUE
[13:17:32.946] - relayed: [n=2] TRUE, TRUE
[13:17:32.947] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:32.947] - relayed: [n=2] TRUE, TRUE
[13:17:32.947] - queued futures: [n=2] TRUE, TRUE
[13:17:32.947] signalConditionsASAP(NULL, pos=0) ... done
[13:17:32.947] resolve() on list ... DONE
[13:17:32.947]  - Number of value chunks collected: 2
[13:17:32.947] Resolving 2 futures (chunks) ... DONE
[13:17:32.948] Reducing values from 2 chunks ...
[13:17:32.948]  - Number of values collected after concatenation: 3
[13:17:32.948]  - Number of values expected: 3
[13:17:32.948] Reducing values from 2 chunks ... DONE
[13:17:32.948] future_lapply() ... DONE
[13:17:32.949] future_lapply() ...
[13:17:32.954] Number of chunks: 2
[13:17:32.954] getGlobalsAndPackagesXApply() ...
[13:17:32.954]  - future.globals: TRUE
[13:17:32.954] getGlobalsAndPackages() ...
[13:17:32.954] Searching for globals...
[13:17:32.955] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:32.956] Searching for globals ... DONE
[13:17:32.956] Resolving globals: FALSE
[13:17:32.956] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:32.956] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:32.957] - globals: [1] ‘FUN’
[13:17:32.957] - packages: [1] ‘stats’
[13:17:32.957] getGlobalsAndPackages() ... DONE
[13:17:32.957]  - globals found/used: [n=1] ‘FUN’
[13:17:32.957]  - needed namespaces: [n=1] ‘stats’
[13:17:32.957] Finding globals ... DONE
[13:17:32.957]  - use_args: TRUE
[13:17:32.958]  - Getting '...' globals ...
[13:17:32.958] resolve() on list ...
[13:17:32.958]  recursive: 0
[13:17:32.958]  length: 1
[13:17:32.958]  elements: ‘...’
[13:17:32.958]  length: 0 (resolved future 1)
[13:17:32.958] resolve() on list ... DONE
[13:17:32.959]    - '...' content: [n=0] 
[13:17:32.959] List of 1
[13:17:32.959]  $ ...: list()
[13:17:32.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.959]  - attr(*, "where")=List of 1
[13:17:32.959]   ..$ ...:<environment: 0x55be3db8b230> 
[13:17:32.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.959]  - attr(*, "resolved")= logi TRUE
[13:17:32.959]  - attr(*, "total_size")= num NA
[13:17:32.964]  - Getting '...' globals ... DONE
[13:17:32.964] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:32.965] List of 2
[13:17:32.965]  $ ...future.FUN:function (x, ...)  
[13:17:32.965]  $ ...          : list()
[13:17:32.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.965]  - attr(*, "where")=List of 2
[13:17:32.965]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:32.965]   ..$ ...          :<environment: 0x55be3db8b230> 
[13:17:32.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.965]  - attr(*, "resolved")= logi FALSE
[13:17:32.965]  - attr(*, "total_size")= num 1248
[13:17:32.968] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:32.968] getGlobalsAndPackagesXApply() ... DONE
[13:17:32.968] Number of futures (= number of chunks): 2
[13:17:32.968] Launching 2 futures (chunks) ...
[13:17:32.968] Chunk #1 of 2 ...
[13:17:32.969]  - Finding globals in 'X' for chunk #1 ...
[13:17:32.969] getGlobalsAndPackages() ...
[13:17:32.969] Searching for globals...
[13:17:32.969] 
[13:17:32.969] Searching for globals ... DONE
[13:17:32.969] - globals: [0] <none>
[13:17:32.969] getGlobalsAndPackages() ... DONE
[13:17:32.969]    + additional globals found: [n=0] 
[13:17:32.970]    + additional namespaces needed: [n=0] 
[13:17:32.970]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:32.970]  - seeds: <none>
[13:17:32.970] getGlobalsAndPackages() ...
[13:17:32.970] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.970] Resolving globals: FALSE
[13:17:32.970] Tweak future expression to call with '...' arguments ...
[13:17:32.970] {
[13:17:32.970]     do.call(function(...) {
[13:17:32.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.970]             on.exit(options(oopts), add = TRUE)
[13:17:32.970]         }
[13:17:32.970]         {
[13:17:32.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.970]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.970]             })
[13:17:32.970]         }
[13:17:32.970]     }, args = future.call.arguments)
[13:17:32.970] }
[13:17:32.970] Tweak future expression to call with '...' arguments ... DONE
[13:17:32.971] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:32.971] - packages: [1] ‘stats’
[13:17:32.971] getGlobalsAndPackages() ... DONE
[13:17:32.971] run() for ‘Future’ ...
[13:17:32.972] - state: ‘created’
[13:17:32.972] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:32.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:32.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:32.976]   - Field: ‘label’
[13:17:32.976]   - Field: ‘local’
[13:17:32.976]   - Field: ‘owner’
[13:17:32.976]   - Field: ‘envir’
[13:17:32.976]   - Field: ‘workers’
[13:17:32.976]   - Field: ‘packages’
[13:17:32.976]   - Field: ‘gc’
[13:17:32.976]   - Field: ‘job’
[13:17:32.976]   - Field: ‘conditions’
[13:17:32.977]   - Field: ‘expr’
[13:17:32.977]   - Field: ‘uuid’
[13:17:32.977]   - Field: ‘seed’
[13:17:32.977]   - Field: ‘version’
[13:17:32.977]   - Field: ‘result’
[13:17:32.977]   - Field: ‘asynchronous’
[13:17:32.977]   - Field: ‘calls’
[13:17:32.977]   - Field: ‘globals’
[13:17:32.977]   - Field: ‘stdout’
[13:17:32.977]   - Field: ‘earlySignal’
[13:17:32.978]   - Field: ‘lazy’
[13:17:32.978]   - Field: ‘state’
[13:17:32.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:32.978] - Launch lazy future ...
[13:17:32.978] Packages needed by the future expression (n = 1): ‘stats’
[13:17:32.978] Packages needed by future strategies (n = 0): <none>
[13:17:32.979] {
[13:17:32.979]     {
[13:17:32.979]         {
[13:17:32.979]             ...future.startTime <- base::Sys.time()
[13:17:32.979]             {
[13:17:32.979]                 {
[13:17:32.979]                   {
[13:17:32.979]                     {
[13:17:32.979]                       {
[13:17:32.979]                         base::local({
[13:17:32.979]                           has_future <- base::requireNamespace("future", 
[13:17:32.979]                             quietly = TRUE)
[13:17:32.979]                           if (has_future) {
[13:17:32.979]                             ns <- base::getNamespace("future")
[13:17:32.979]                             version <- ns[[".package"]][["version"]]
[13:17:32.979]                             if (is.null(version)) 
[13:17:32.979]                               version <- utils::packageVersion("future")
[13:17:32.979]                           }
[13:17:32.979]                           else {
[13:17:32.979]                             version <- NULL
[13:17:32.979]                           }
[13:17:32.979]                           if (!has_future || version < "1.8.0") {
[13:17:32.979]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:32.979]                               "", base::R.version$version.string), 
[13:17:32.979]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:32.979]                                 base::R.version$platform, 8 * 
[13:17:32.979]                                   base::.Machine$sizeof.pointer), 
[13:17:32.979]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:32.979]                                 "release", "version")], collapse = " "), 
[13:17:32.979]                               hostname = base::Sys.info()[["nodename"]])
[13:17:32.979]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:32.979]                               info)
[13:17:32.979]                             info <- base::paste(info, collapse = "; ")
[13:17:32.979]                             if (!has_future) {
[13:17:32.979]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:32.979]                                 info)
[13:17:32.979]                             }
[13:17:32.979]                             else {
[13:17:32.979]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:32.979]                                 info, version)
[13:17:32.979]                             }
[13:17:32.979]                             base::stop(msg)
[13:17:32.979]                           }
[13:17:32.979]                         })
[13:17:32.979]                       }
[13:17:32.979]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:32.979]                       base::options(mc.cores = 1L)
[13:17:32.979]                     }
[13:17:32.979]                     base::local({
[13:17:32.979]                       for (pkg in "stats") {
[13:17:32.979]                         base::loadNamespace(pkg)
[13:17:32.979]                         base::library(pkg, character.only = TRUE)
[13:17:32.979]                       }
[13:17:32.979]                     })
[13:17:32.979]                   }
[13:17:32.979]                   options(future.plan = NULL)
[13:17:32.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:32.979]                 }
[13:17:32.979]                 ...future.workdir <- getwd()
[13:17:32.979]             }
[13:17:32.979]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:32.979]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:32.979]         }
[13:17:32.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:32.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:32.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:32.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:32.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:32.979]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:32.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:32.979]             base::names(...future.oldOptions))
[13:17:32.979]     }
[13:17:32.979]     if (FALSE) {
[13:17:32.979]     }
[13:17:32.979]     else {
[13:17:32.979]         if (TRUE) {
[13:17:32.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:32.979]                 open = "w")
[13:17:32.979]         }
[13:17:32.979]         else {
[13:17:32.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:32.979]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:32.979]         }
[13:17:32.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:32.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:32.979]             base::sink(type = "output", split = FALSE)
[13:17:32.979]             base::close(...future.stdout)
[13:17:32.979]         }, add = TRUE)
[13:17:32.979]     }
[13:17:32.979]     ...future.frame <- base::sys.nframe()
[13:17:32.979]     ...future.conditions <- base::list()
[13:17:32.979]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:32.979]     if (FALSE) {
[13:17:32.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:32.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:32.979]     }
[13:17:32.979]     ...future.result <- base::tryCatch({
[13:17:32.979]         base::withCallingHandlers({
[13:17:32.979]             ...future.value <- base::withVisible(base::local({
[13:17:32.979]                 withCallingHandlers({
[13:17:32.979]                   {
[13:17:32.979]                     do.call(function(...) {
[13:17:32.979]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.979]                       if (!identical(...future.globals.maxSize.org, 
[13:17:32.979]                         ...future.globals.maxSize)) {
[13:17:32.979]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.979]                         on.exit(options(oopts), add = TRUE)
[13:17:32.979]                       }
[13:17:32.979]                       {
[13:17:32.979]                         lapply(seq_along(...future.elements_ii), 
[13:17:32.979]                           FUN = function(jj) {
[13:17:32.979]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.979]                             ...future.FUN(...future.X_jj, ...)
[13:17:32.979]                           })
[13:17:32.979]                       }
[13:17:32.979]                     }, args = future.call.arguments)
[13:17:32.979]                   }
[13:17:32.979]                 }, immediateCondition = function(cond) {
[13:17:32.979]                   save_rds <- function (object, pathname, ...) 
[13:17:32.979]                   {
[13:17:32.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:32.979]                     if (file_test("-f", pathname_tmp)) {
[13:17:32.979]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:32.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.979]                         fi_tmp[["mtime"]])
[13:17:32.979]                     }
[13:17:32.979]                     tryCatch({
[13:17:32.979]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:32.979]                     }, error = function(ex) {
[13:17:32.979]                       msg <- conditionMessage(ex)
[13:17:32.979]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:32.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.979]                         fi_tmp[["mtime"]], msg)
[13:17:32.979]                       ex$message <- msg
[13:17:32.979]                       stop(ex)
[13:17:32.979]                     })
[13:17:32.979]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:32.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:32.979]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:32.979]                       fi_tmp <- file.info(pathname_tmp)
[13:17:32.979]                       fi <- file.info(pathname)
[13:17:32.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:32.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:32.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:32.979]                         fi[["size"]], fi[["mtime"]])
[13:17:32.979]                       stop(msg)
[13:17:32.979]                     }
[13:17:32.979]                     invisible(pathname)
[13:17:32.979]                   }
[13:17:32.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:32.979]                     rootPath = tempdir()) 
[13:17:32.979]                   {
[13:17:32.979]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:32.979]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:32.979]                       tmpdir = path, fileext = ".rds")
[13:17:32.979]                     save_rds(obj, file)
[13:17:32.979]                   }
[13:17:32.979]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:32.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.979]                   {
[13:17:32.979]                     inherits <- base::inherits
[13:17:32.979]                     invokeRestart <- base::invokeRestart
[13:17:32.979]                     is.null <- base::is.null
[13:17:32.979]                     muffled <- FALSE
[13:17:32.979]                     if (inherits(cond, "message")) {
[13:17:32.979]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:32.979]                       if (muffled) 
[13:17:32.979]                         invokeRestart("muffleMessage")
[13:17:32.979]                     }
[13:17:32.979]                     else if (inherits(cond, "warning")) {
[13:17:32.979]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:32.979]                       if (muffled) 
[13:17:32.979]                         invokeRestart("muffleWarning")
[13:17:32.979]                     }
[13:17:32.979]                     else if (inherits(cond, "condition")) {
[13:17:32.979]                       if (!is.null(pattern)) {
[13:17:32.979]                         computeRestarts <- base::computeRestarts
[13:17:32.979]                         grepl <- base::grepl
[13:17:32.979]                         restarts <- computeRestarts(cond)
[13:17:32.979]                         for (restart in restarts) {
[13:17:32.979]                           name <- restart$name
[13:17:32.979]                           if (is.null(name)) 
[13:17:32.979]                             next
[13:17:32.979]                           if (!grepl(pattern, name)) 
[13:17:32.979]                             next
[13:17:32.979]                           invokeRestart(restart)
[13:17:32.979]                           muffled <- TRUE
[13:17:32.979]                           break
[13:17:32.979]                         }
[13:17:32.979]                       }
[13:17:32.979]                     }
[13:17:32.979]                     invisible(muffled)
[13:17:32.979]                   }
[13:17:32.979]                   muffleCondition(cond)
[13:17:32.979]                 })
[13:17:32.979]             }))
[13:17:32.979]             future::FutureResult(value = ...future.value$value, 
[13:17:32.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.979]                   ...future.rng), globalenv = if (FALSE) 
[13:17:32.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:32.979]                     ...future.globalenv.names))
[13:17:32.979]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:32.979]         }, condition = base::local({
[13:17:32.979]             c <- base::c
[13:17:32.979]             inherits <- base::inherits
[13:17:32.979]             invokeRestart <- base::invokeRestart
[13:17:32.979]             length <- base::length
[13:17:32.979]             list <- base::list
[13:17:32.979]             seq.int <- base::seq.int
[13:17:32.979]             signalCondition <- base::signalCondition
[13:17:32.979]             sys.calls <- base::sys.calls
[13:17:32.979]             `[[` <- base::`[[`
[13:17:32.979]             `+` <- base::`+`
[13:17:32.979]             `<<-` <- base::`<<-`
[13:17:32.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:32.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:32.979]                   3L)]
[13:17:32.979]             }
[13:17:32.979]             function(cond) {
[13:17:32.979]                 is_error <- inherits(cond, "error")
[13:17:32.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:32.979]                   NULL)
[13:17:32.979]                 if (is_error) {
[13:17:32.979]                   sessionInformation <- function() {
[13:17:32.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:32.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:32.979]                       search = base::search(), system = base::Sys.info())
[13:17:32.979]                   }
[13:17:32.979]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:32.979]                     cond$call), session = sessionInformation(), 
[13:17:32.979]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:32.979]                   signalCondition(cond)
[13:17:32.979]                 }
[13:17:32.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:32.979]                 "immediateCondition"))) {
[13:17:32.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:32.979]                   ...future.conditions[[length(...future.conditions) + 
[13:17:32.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:32.979]                   if (TRUE && !signal) {
[13:17:32.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.979]                     {
[13:17:32.979]                       inherits <- base::inherits
[13:17:32.979]                       invokeRestart <- base::invokeRestart
[13:17:32.979]                       is.null <- base::is.null
[13:17:32.979]                       muffled <- FALSE
[13:17:32.979]                       if (inherits(cond, "message")) {
[13:17:32.979]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.979]                         if (muffled) 
[13:17:32.979]                           invokeRestart("muffleMessage")
[13:17:32.979]                       }
[13:17:32.979]                       else if (inherits(cond, "warning")) {
[13:17:32.979]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.979]                         if (muffled) 
[13:17:32.979]                           invokeRestart("muffleWarning")
[13:17:32.979]                       }
[13:17:32.979]                       else if (inherits(cond, "condition")) {
[13:17:32.979]                         if (!is.null(pattern)) {
[13:17:32.979]                           computeRestarts <- base::computeRestarts
[13:17:32.979]                           grepl <- base::grepl
[13:17:32.979]                           restarts <- computeRestarts(cond)
[13:17:32.979]                           for (restart in restarts) {
[13:17:32.979]                             name <- restart$name
[13:17:32.979]                             if (is.null(name)) 
[13:17:32.979]                               next
[13:17:32.979]                             if (!grepl(pattern, name)) 
[13:17:32.979]                               next
[13:17:32.979]                             invokeRestart(restart)
[13:17:32.979]                             muffled <- TRUE
[13:17:32.979]                             break
[13:17:32.979]                           }
[13:17:32.979]                         }
[13:17:32.979]                       }
[13:17:32.979]                       invisible(muffled)
[13:17:32.979]                     }
[13:17:32.979]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.979]                   }
[13:17:32.979]                 }
[13:17:32.979]                 else {
[13:17:32.979]                   if (TRUE) {
[13:17:32.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:32.979]                     {
[13:17:32.979]                       inherits <- base::inherits
[13:17:32.979]                       invokeRestart <- base::invokeRestart
[13:17:32.979]                       is.null <- base::is.null
[13:17:32.979]                       muffled <- FALSE
[13:17:32.979]                       if (inherits(cond, "message")) {
[13:17:32.979]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:32.979]                         if (muffled) 
[13:17:32.979]                           invokeRestart("muffleMessage")
[13:17:32.979]                       }
[13:17:32.979]                       else if (inherits(cond, "warning")) {
[13:17:32.979]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:32.979]                         if (muffled) 
[13:17:32.979]                           invokeRestart("muffleWarning")
[13:17:32.979]                       }
[13:17:32.979]                       else if (inherits(cond, "condition")) {
[13:17:32.979]                         if (!is.null(pattern)) {
[13:17:32.979]                           computeRestarts <- base::computeRestarts
[13:17:32.979]                           grepl <- base::grepl
[13:17:32.979]                           restarts <- computeRestarts(cond)
[13:17:32.979]                           for (restart in restarts) {
[13:17:32.979]                             name <- restart$name
[13:17:32.979]                             if (is.null(name)) 
[13:17:32.979]                               next
[13:17:32.979]                             if (!grepl(pattern, name)) 
[13:17:32.979]                               next
[13:17:32.979]                             invokeRestart(restart)
[13:17:32.979]                             muffled <- TRUE
[13:17:32.979]                             break
[13:17:32.979]                           }
[13:17:32.979]                         }
[13:17:32.979]                       }
[13:17:32.979]                       invisible(muffled)
[13:17:32.979]                     }
[13:17:32.979]                     muffleCondition(cond, pattern = "^muffle")
[13:17:32.979]                   }
[13:17:32.979]                 }
[13:17:32.979]             }
[13:17:32.979]         }))
[13:17:32.979]     }, error = function(ex) {
[13:17:32.979]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:32.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:32.979]                 ...future.rng), started = ...future.startTime, 
[13:17:32.979]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:32.979]             version = "1.8"), class = "FutureResult")
[13:17:32.979]     }, finally = {
[13:17:32.979]         if (!identical(...future.workdir, getwd())) 
[13:17:32.979]             setwd(...future.workdir)
[13:17:32.979]         {
[13:17:32.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:32.979]                 ...future.oldOptions$nwarnings <- NULL
[13:17:32.979]             }
[13:17:32.979]             base::options(...future.oldOptions)
[13:17:32.979]             if (.Platform$OS.type == "windows") {
[13:17:32.979]                 old_names <- names(...future.oldEnvVars)
[13:17:32.979]                 envs <- base::Sys.getenv()
[13:17:32.979]                 names <- names(envs)
[13:17:32.979]                 common <- intersect(names, old_names)
[13:17:32.979]                 added <- setdiff(names, old_names)
[13:17:32.979]                 removed <- setdiff(old_names, names)
[13:17:32.979]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:32.979]                   envs[common]]
[13:17:32.979]                 NAMES <- toupper(changed)
[13:17:32.979]                 args <- list()
[13:17:32.979]                 for (kk in seq_along(NAMES)) {
[13:17:32.979]                   name <- changed[[kk]]
[13:17:32.979]                   NAME <- NAMES[[kk]]
[13:17:32.979]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.979]                     next
[13:17:32.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.979]                 }
[13:17:32.979]                 NAMES <- toupper(added)
[13:17:32.979]                 for (kk in seq_along(NAMES)) {
[13:17:32.979]                   name <- added[[kk]]
[13:17:32.979]                   NAME <- NAMES[[kk]]
[13:17:32.979]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.979]                     next
[13:17:32.979]                   args[[name]] <- ""
[13:17:32.979]                 }
[13:17:32.979]                 NAMES <- toupper(removed)
[13:17:32.979]                 for (kk in seq_along(NAMES)) {
[13:17:32.979]                   name <- removed[[kk]]
[13:17:32.979]                   NAME <- NAMES[[kk]]
[13:17:32.979]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:32.979]                     next
[13:17:32.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:32.979]                 }
[13:17:32.979]                 if (length(args) > 0) 
[13:17:32.979]                   base::do.call(base::Sys.setenv, args = args)
[13:17:32.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:32.979]             }
[13:17:32.979]             else {
[13:17:32.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:32.979]             }
[13:17:32.979]             {
[13:17:32.979]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:32.979]                   0L) {
[13:17:32.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:32.979]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:32.979]                   base::options(opts)
[13:17:32.979]                 }
[13:17:32.979]                 {
[13:17:32.979]                   {
[13:17:32.979]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:32.979]                     NULL
[13:17:32.979]                   }
[13:17:32.979]                   options(future.plan = NULL)
[13:17:32.979]                   if (is.na(NA_character_)) 
[13:17:32.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:32.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:32.979]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:32.979]                     envir = parent.frame()) 
[13:17:32.979]                   {
[13:17:32.979]                     default_workers <- missing(workers)
[13:17:32.979]                     if (is.function(workers)) 
[13:17:32.979]                       workers <- workers()
[13:17:32.979]                     workers <- structure(as.integer(workers), 
[13:17:32.979]                       class = class(workers))
[13:17:32.979]                     stop_if_not(is.finite(workers), workers >= 
[13:17:32.979]                       1L)
[13:17:32.979]                     if ((workers == 1L && !inherits(workers, 
[13:17:32.979]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:32.979]                       if (default_workers) 
[13:17:32.979]                         supportsMulticore(warn = TRUE)
[13:17:32.979]                       return(sequential(..., envir = envir))
[13:17:32.979]                     }
[13:17:32.979]                     oopts <- options(mc.cores = workers)
[13:17:32.979]                     on.exit(options(oopts))
[13:17:32.979]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:32.979]                       envir = envir)
[13:17:32.979]                     if (!future$lazy) 
[13:17:32.979]                       future <- run(future)
[13:17:32.979]                     invisible(future)
[13:17:32.979]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:32.979]                 }
[13:17:32.979]             }
[13:17:32.979]         }
[13:17:32.979]     })
[13:17:32.979]     if (TRUE) {
[13:17:32.979]         base::sink(type = "output", split = FALSE)
[13:17:32.979]         if (TRUE) {
[13:17:32.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:32.979]         }
[13:17:32.979]         else {
[13:17:32.979]             ...future.result["stdout"] <- base::list(NULL)
[13:17:32.979]         }
[13:17:32.979]         base::close(...future.stdout)
[13:17:32.979]         ...future.stdout <- NULL
[13:17:32.979]     }
[13:17:32.979]     ...future.result$conditions <- ...future.conditions
[13:17:32.979]     ...future.result$finished <- base::Sys.time()
[13:17:32.979]     ...future.result
[13:17:32.979] }
[13:17:32.981] assign_globals() ...
[13:17:32.982] List of 5
[13:17:32.982]  $ ...future.FUN            :function (x, ...)  
[13:17:32.982]  $ future.call.arguments    : list()
[13:17:32.982]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:32.982]  $ ...future.elements_ii    :List of 1
[13:17:32.982]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:17:32.982]  $ ...future.seeds_ii       : NULL
[13:17:32.982]  $ ...future.globals.maxSize: NULL
[13:17:32.982]  - attr(*, "where")=List of 5
[13:17:32.982]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:32.982]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:32.982]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:32.982]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:32.982]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:32.982]  - attr(*, "resolved")= logi FALSE
[13:17:32.982]  - attr(*, "total_size")= num 1248
[13:17:32.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:32.982]  - attr(*, "already-done")= logi TRUE
[13:17:32.986] - copied ‘...future.FUN’ to environment
[13:17:32.986] - copied ‘future.call.arguments’ to environment
[13:17:32.987] - copied ‘...future.elements_ii’ to environment
[13:17:32.987] - copied ‘...future.seeds_ii’ to environment
[13:17:32.987] - copied ‘...future.globals.maxSize’ to environment
[13:17:32.987] assign_globals() ... done
[13:17:32.987] requestCore(): workers = 2
[13:17:32.989] MulticoreFuture started
[13:17:32.989] - Launch lazy future ... done
[13:17:32.990] run() for ‘MulticoreFuture’ ... done
[13:17:32.990] Created future:
[13:17:32.991] plan(): Setting new future strategy stack:
[13:17:32.991] List of future strategies:
[13:17:32.991] 1. sequential:
[13:17:32.991]    - args: function (..., envir = parent.frame())
[13:17:32.991]    - tweaked: FALSE
[13:17:32.991]    - call: NULL
[13:17:32.995] plan(): nbrOfWorkers() = 1
[13:17:32.997] plan(): Setting new future strategy stack:
[13:17:32.998] List of future strategies:
[13:17:32.998] 1. multicore:
[13:17:32.998]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:32.998]    - tweaked: FALSE
[13:17:32.998]    - call: plan(strategy)
[13:17:33.003] plan(): nbrOfWorkers() = 2
[13:17:32.990] MulticoreFuture:
[13:17:32.990] Label: ‘future_eapply-1’
[13:17:32.990] Expression:
[13:17:32.990] {
[13:17:32.990]     do.call(function(...) {
[13:17:32.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:32.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:32.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:32.990]             on.exit(options(oopts), add = TRUE)
[13:17:32.990]         }
[13:17:32.990]         {
[13:17:32.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:32.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:32.990]                 ...future.FUN(...future.X_jj, ...)
[13:17:32.990]             })
[13:17:32.990]         }
[13:17:32.990]     }, args = future.call.arguments)
[13:17:32.990] }
[13:17:32.990] Lazy evaluation: FALSE
[13:17:32.990] Asynchronous evaluation: TRUE
[13:17:32.990] Local evaluation: TRUE
[13:17:32.990] Environment: R_GlobalEnv
[13:17:32.990] Capture standard output: TRUE
[13:17:32.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:32.990] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:32.990] Packages: 1 packages (‘stats’)
[13:17:32.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:32.990] Resolved: TRUE
[13:17:32.990] Value: <not collected>
[13:17:32.990] Conditions captured: <none>
[13:17:32.990] Early signaling: FALSE
[13:17:32.990] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:32.990] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.005] Chunk #1 of 2 ... DONE
[13:17:33.005] Chunk #2 of 2 ...
[13:17:33.005]  - Finding globals in 'X' for chunk #2 ...
[13:17:33.005] getGlobalsAndPackages() ...
[13:17:33.005] Searching for globals...
[13:17:33.006] 
[13:17:33.006] Searching for globals ... DONE
[13:17:33.006] - globals: [0] <none>
[13:17:33.006] getGlobalsAndPackages() ... DONE
[13:17:33.007]    + additional globals found: [n=0] 
[13:17:33.007]    + additional namespaces needed: [n=0] 
[13:17:33.007]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:33.007]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:33.007]  - seeds: <none>
[13:17:33.007] getGlobalsAndPackages() ...
[13:17:33.008] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.008] Resolving globals: FALSE
[13:17:33.008] Tweak future expression to call with '...' arguments ...
[13:17:33.008] {
[13:17:33.008]     do.call(function(...) {
[13:17:33.008]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.008]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.008]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.008]             on.exit(options(oopts), add = TRUE)
[13:17:33.008]         }
[13:17:33.008]         {
[13:17:33.008]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.008]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.008]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.008]             })
[13:17:33.008]         }
[13:17:33.008]     }, args = future.call.arguments)
[13:17:33.008] }
[13:17:33.009] Tweak future expression to call with '...' arguments ... DONE
[13:17:33.009] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.010] - packages: [1] ‘stats’
[13:17:33.010] getGlobalsAndPackages() ... DONE
[13:17:33.010] run() for ‘Future’ ...
[13:17:33.011] - state: ‘created’
[13:17:33.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:33.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:33.016]   - Field: ‘label’
[13:17:33.016]   - Field: ‘local’
[13:17:33.016]   - Field: ‘owner’
[13:17:33.016]   - Field: ‘envir’
[13:17:33.016]   - Field: ‘workers’
[13:17:33.017]   - Field: ‘packages’
[13:17:33.017]   - Field: ‘gc’
[13:17:33.017]   - Field: ‘job’
[13:17:33.017]   - Field: ‘conditions’
[13:17:33.017]   - Field: ‘expr’
[13:17:33.017]   - Field: ‘uuid’
[13:17:33.018]   - Field: ‘seed’
[13:17:33.018]   - Field: ‘version’
[13:17:33.018]   - Field: ‘result’
[13:17:33.018]   - Field: ‘asynchronous’
[13:17:33.018]   - Field: ‘calls’
[13:17:33.018]   - Field: ‘globals’
[13:17:33.018]   - Field: ‘stdout’
[13:17:33.018]   - Field: ‘earlySignal’
[13:17:33.019]   - Field: ‘lazy’
[13:17:33.019]   - Field: ‘state’
[13:17:33.019] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:33.019] - Launch lazy future ...
[13:17:33.019] Packages needed by the future expression (n = 1): ‘stats’
[13:17:33.020] Packages needed by future strategies (n = 0): <none>
[13:17:33.021] {
[13:17:33.021]     {
[13:17:33.021]         {
[13:17:33.021]             ...future.startTime <- base::Sys.time()
[13:17:33.021]             {
[13:17:33.021]                 {
[13:17:33.021]                   {
[13:17:33.021]                     {
[13:17:33.021]                       {
[13:17:33.021]                         base::local({
[13:17:33.021]                           has_future <- base::requireNamespace("future", 
[13:17:33.021]                             quietly = TRUE)
[13:17:33.021]                           if (has_future) {
[13:17:33.021]                             ns <- base::getNamespace("future")
[13:17:33.021]                             version <- ns[[".package"]][["version"]]
[13:17:33.021]                             if (is.null(version)) 
[13:17:33.021]                               version <- utils::packageVersion("future")
[13:17:33.021]                           }
[13:17:33.021]                           else {
[13:17:33.021]                             version <- NULL
[13:17:33.021]                           }
[13:17:33.021]                           if (!has_future || version < "1.8.0") {
[13:17:33.021]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:33.021]                               "", base::R.version$version.string), 
[13:17:33.021]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:33.021]                                 base::R.version$platform, 8 * 
[13:17:33.021]                                   base::.Machine$sizeof.pointer), 
[13:17:33.021]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:33.021]                                 "release", "version")], collapse = " "), 
[13:17:33.021]                               hostname = base::Sys.info()[["nodename"]])
[13:17:33.021]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:33.021]                               info)
[13:17:33.021]                             info <- base::paste(info, collapse = "; ")
[13:17:33.021]                             if (!has_future) {
[13:17:33.021]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:33.021]                                 info)
[13:17:33.021]                             }
[13:17:33.021]                             else {
[13:17:33.021]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:33.021]                                 info, version)
[13:17:33.021]                             }
[13:17:33.021]                             base::stop(msg)
[13:17:33.021]                           }
[13:17:33.021]                         })
[13:17:33.021]                       }
[13:17:33.021]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:33.021]                       base::options(mc.cores = 1L)
[13:17:33.021]                     }
[13:17:33.021]                     base::local({
[13:17:33.021]                       for (pkg in "stats") {
[13:17:33.021]                         base::loadNamespace(pkg)
[13:17:33.021]                         base::library(pkg, character.only = TRUE)
[13:17:33.021]                       }
[13:17:33.021]                     })
[13:17:33.021]                   }
[13:17:33.021]                   options(future.plan = NULL)
[13:17:33.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:33.021]                 }
[13:17:33.021]                 ...future.workdir <- getwd()
[13:17:33.021]             }
[13:17:33.021]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:33.021]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:33.021]         }
[13:17:33.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:33.021]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:33.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:33.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:33.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:33.021]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:33.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:33.021]             base::names(...future.oldOptions))
[13:17:33.021]     }
[13:17:33.021]     if (FALSE) {
[13:17:33.021]     }
[13:17:33.021]     else {
[13:17:33.021]         if (TRUE) {
[13:17:33.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:33.021]                 open = "w")
[13:17:33.021]         }
[13:17:33.021]         else {
[13:17:33.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:33.021]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:33.021]         }
[13:17:33.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:33.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:33.021]             base::sink(type = "output", split = FALSE)
[13:17:33.021]             base::close(...future.stdout)
[13:17:33.021]         }, add = TRUE)
[13:17:33.021]     }
[13:17:33.021]     ...future.frame <- base::sys.nframe()
[13:17:33.021]     ...future.conditions <- base::list()
[13:17:33.021]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:33.021]     if (FALSE) {
[13:17:33.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:33.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:33.021]     }
[13:17:33.021]     ...future.result <- base::tryCatch({
[13:17:33.021]         base::withCallingHandlers({
[13:17:33.021]             ...future.value <- base::withVisible(base::local({
[13:17:33.021]                 withCallingHandlers({
[13:17:33.021]                   {
[13:17:33.021]                     do.call(function(...) {
[13:17:33.021]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.021]                       if (!identical(...future.globals.maxSize.org, 
[13:17:33.021]                         ...future.globals.maxSize)) {
[13:17:33.021]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.021]                         on.exit(options(oopts), add = TRUE)
[13:17:33.021]                       }
[13:17:33.021]                       {
[13:17:33.021]                         lapply(seq_along(...future.elements_ii), 
[13:17:33.021]                           FUN = function(jj) {
[13:17:33.021]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.021]                             ...future.FUN(...future.X_jj, ...)
[13:17:33.021]                           })
[13:17:33.021]                       }
[13:17:33.021]                     }, args = future.call.arguments)
[13:17:33.021]                   }
[13:17:33.021]                 }, immediateCondition = function(cond) {
[13:17:33.021]                   save_rds <- function (object, pathname, ...) 
[13:17:33.021]                   {
[13:17:33.021]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:33.021]                     if (file_test("-f", pathname_tmp)) {
[13:17:33.021]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.021]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:33.021]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.021]                         fi_tmp[["mtime"]])
[13:17:33.021]                     }
[13:17:33.021]                     tryCatch({
[13:17:33.021]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:33.021]                     }, error = function(ex) {
[13:17:33.021]                       msg <- conditionMessage(ex)
[13:17:33.021]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.021]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:33.021]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.021]                         fi_tmp[["mtime"]], msg)
[13:17:33.021]                       ex$message <- msg
[13:17:33.021]                       stop(ex)
[13:17:33.021]                     })
[13:17:33.021]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:33.021]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:33.021]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:33.021]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.021]                       fi <- file.info(pathname)
[13:17:33.021]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:33.021]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.021]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:33.021]                         fi[["size"]], fi[["mtime"]])
[13:17:33.021]                       stop(msg)
[13:17:33.021]                     }
[13:17:33.021]                     invisible(pathname)
[13:17:33.021]                   }
[13:17:33.021]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:33.021]                     rootPath = tempdir()) 
[13:17:33.021]                   {
[13:17:33.021]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:33.021]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:33.021]                       tmpdir = path, fileext = ".rds")
[13:17:33.021]                     save_rds(obj, file)
[13:17:33.021]                   }
[13:17:33.021]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:33.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.021]                   {
[13:17:33.021]                     inherits <- base::inherits
[13:17:33.021]                     invokeRestart <- base::invokeRestart
[13:17:33.021]                     is.null <- base::is.null
[13:17:33.021]                     muffled <- FALSE
[13:17:33.021]                     if (inherits(cond, "message")) {
[13:17:33.021]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:33.021]                       if (muffled) 
[13:17:33.021]                         invokeRestart("muffleMessage")
[13:17:33.021]                     }
[13:17:33.021]                     else if (inherits(cond, "warning")) {
[13:17:33.021]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:33.021]                       if (muffled) 
[13:17:33.021]                         invokeRestart("muffleWarning")
[13:17:33.021]                     }
[13:17:33.021]                     else if (inherits(cond, "condition")) {
[13:17:33.021]                       if (!is.null(pattern)) {
[13:17:33.021]                         computeRestarts <- base::computeRestarts
[13:17:33.021]                         grepl <- base::grepl
[13:17:33.021]                         restarts <- computeRestarts(cond)
[13:17:33.021]                         for (restart in restarts) {
[13:17:33.021]                           name <- restart$name
[13:17:33.021]                           if (is.null(name)) 
[13:17:33.021]                             next
[13:17:33.021]                           if (!grepl(pattern, name)) 
[13:17:33.021]                             next
[13:17:33.021]                           invokeRestart(restart)
[13:17:33.021]                           muffled <- TRUE
[13:17:33.021]                           break
[13:17:33.021]                         }
[13:17:33.021]                       }
[13:17:33.021]                     }
[13:17:33.021]                     invisible(muffled)
[13:17:33.021]                   }
[13:17:33.021]                   muffleCondition(cond)
[13:17:33.021]                 })
[13:17:33.021]             }))
[13:17:33.021]             future::FutureResult(value = ...future.value$value, 
[13:17:33.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.021]                   ...future.rng), globalenv = if (FALSE) 
[13:17:33.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:33.021]                     ...future.globalenv.names))
[13:17:33.021]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:33.021]         }, condition = base::local({
[13:17:33.021]             c <- base::c
[13:17:33.021]             inherits <- base::inherits
[13:17:33.021]             invokeRestart <- base::invokeRestart
[13:17:33.021]             length <- base::length
[13:17:33.021]             list <- base::list
[13:17:33.021]             seq.int <- base::seq.int
[13:17:33.021]             signalCondition <- base::signalCondition
[13:17:33.021]             sys.calls <- base::sys.calls
[13:17:33.021]             `[[` <- base::`[[`
[13:17:33.021]             `+` <- base::`+`
[13:17:33.021]             `<<-` <- base::`<<-`
[13:17:33.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:33.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:33.021]                   3L)]
[13:17:33.021]             }
[13:17:33.021]             function(cond) {
[13:17:33.021]                 is_error <- inherits(cond, "error")
[13:17:33.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:33.021]                   NULL)
[13:17:33.021]                 if (is_error) {
[13:17:33.021]                   sessionInformation <- function() {
[13:17:33.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:33.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:33.021]                       search = base::search(), system = base::Sys.info())
[13:17:33.021]                   }
[13:17:33.021]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:33.021]                     cond$call), session = sessionInformation(), 
[13:17:33.021]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:33.021]                   signalCondition(cond)
[13:17:33.021]                 }
[13:17:33.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:33.021]                 "immediateCondition"))) {
[13:17:33.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:33.021]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:33.021]                   if (TRUE && !signal) {
[13:17:33.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.021]                     {
[13:17:33.021]                       inherits <- base::inherits
[13:17:33.021]                       invokeRestart <- base::invokeRestart
[13:17:33.021]                       is.null <- base::is.null
[13:17:33.021]                       muffled <- FALSE
[13:17:33.021]                       if (inherits(cond, "message")) {
[13:17:33.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.021]                         if (muffled) 
[13:17:33.021]                           invokeRestart("muffleMessage")
[13:17:33.021]                       }
[13:17:33.021]                       else if (inherits(cond, "warning")) {
[13:17:33.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.021]                         if (muffled) 
[13:17:33.021]                           invokeRestart("muffleWarning")
[13:17:33.021]                       }
[13:17:33.021]                       else if (inherits(cond, "condition")) {
[13:17:33.021]                         if (!is.null(pattern)) {
[13:17:33.021]                           computeRestarts <- base::computeRestarts
[13:17:33.021]                           grepl <- base::grepl
[13:17:33.021]                           restarts <- computeRestarts(cond)
[13:17:33.021]                           for (restart in restarts) {
[13:17:33.021]                             name <- restart$name
[13:17:33.021]                             if (is.null(name)) 
[13:17:33.021]                               next
[13:17:33.021]                             if (!grepl(pattern, name)) 
[13:17:33.021]                               next
[13:17:33.021]                             invokeRestart(restart)
[13:17:33.021]                             muffled <- TRUE
[13:17:33.021]                             break
[13:17:33.021]                           }
[13:17:33.021]                         }
[13:17:33.021]                       }
[13:17:33.021]                       invisible(muffled)
[13:17:33.021]                     }
[13:17:33.021]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.021]                   }
[13:17:33.021]                 }
[13:17:33.021]                 else {
[13:17:33.021]                   if (TRUE) {
[13:17:33.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.021]                     {
[13:17:33.021]                       inherits <- base::inherits
[13:17:33.021]                       invokeRestart <- base::invokeRestart
[13:17:33.021]                       is.null <- base::is.null
[13:17:33.021]                       muffled <- FALSE
[13:17:33.021]                       if (inherits(cond, "message")) {
[13:17:33.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.021]                         if (muffled) 
[13:17:33.021]                           invokeRestart("muffleMessage")
[13:17:33.021]                       }
[13:17:33.021]                       else if (inherits(cond, "warning")) {
[13:17:33.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.021]                         if (muffled) 
[13:17:33.021]                           invokeRestart("muffleWarning")
[13:17:33.021]                       }
[13:17:33.021]                       else if (inherits(cond, "condition")) {
[13:17:33.021]                         if (!is.null(pattern)) {
[13:17:33.021]                           computeRestarts <- base::computeRestarts
[13:17:33.021]                           grepl <- base::grepl
[13:17:33.021]                           restarts <- computeRestarts(cond)
[13:17:33.021]                           for (restart in restarts) {
[13:17:33.021]                             name <- restart$name
[13:17:33.021]                             if (is.null(name)) 
[13:17:33.021]                               next
[13:17:33.021]                             if (!grepl(pattern, name)) 
[13:17:33.021]                               next
[13:17:33.021]                             invokeRestart(restart)
[13:17:33.021]                             muffled <- TRUE
[13:17:33.021]                             break
[13:17:33.021]                           }
[13:17:33.021]                         }
[13:17:33.021]                       }
[13:17:33.021]                       invisible(muffled)
[13:17:33.021]                     }
[13:17:33.021]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.021]                   }
[13:17:33.021]                 }
[13:17:33.021]             }
[13:17:33.021]         }))
[13:17:33.021]     }, error = function(ex) {
[13:17:33.021]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:33.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.021]                 ...future.rng), started = ...future.startTime, 
[13:17:33.021]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:33.021]             version = "1.8"), class = "FutureResult")
[13:17:33.021]     }, finally = {
[13:17:33.021]         if (!identical(...future.workdir, getwd())) 
[13:17:33.021]             setwd(...future.workdir)
[13:17:33.021]         {
[13:17:33.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:33.021]                 ...future.oldOptions$nwarnings <- NULL
[13:17:33.021]             }
[13:17:33.021]             base::options(...future.oldOptions)
[13:17:33.021]             if (.Platform$OS.type == "windows") {
[13:17:33.021]                 old_names <- names(...future.oldEnvVars)
[13:17:33.021]                 envs <- base::Sys.getenv()
[13:17:33.021]                 names <- names(envs)
[13:17:33.021]                 common <- intersect(names, old_names)
[13:17:33.021]                 added <- setdiff(names, old_names)
[13:17:33.021]                 removed <- setdiff(old_names, names)
[13:17:33.021]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:33.021]                   envs[common]]
[13:17:33.021]                 NAMES <- toupper(changed)
[13:17:33.021]                 args <- list()
[13:17:33.021]                 for (kk in seq_along(NAMES)) {
[13:17:33.021]                   name <- changed[[kk]]
[13:17:33.021]                   NAME <- NAMES[[kk]]
[13:17:33.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.021]                     next
[13:17:33.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.021]                 }
[13:17:33.021]                 NAMES <- toupper(added)
[13:17:33.021]                 for (kk in seq_along(NAMES)) {
[13:17:33.021]                   name <- added[[kk]]
[13:17:33.021]                   NAME <- NAMES[[kk]]
[13:17:33.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.021]                     next
[13:17:33.021]                   args[[name]] <- ""
[13:17:33.021]                 }
[13:17:33.021]                 NAMES <- toupper(removed)
[13:17:33.021]                 for (kk in seq_along(NAMES)) {
[13:17:33.021]                   name <- removed[[kk]]
[13:17:33.021]                   NAME <- NAMES[[kk]]
[13:17:33.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.021]                     next
[13:17:33.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.021]                 }
[13:17:33.021]                 if (length(args) > 0) 
[13:17:33.021]                   base::do.call(base::Sys.setenv, args = args)
[13:17:33.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:33.021]             }
[13:17:33.021]             else {
[13:17:33.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:33.021]             }
[13:17:33.021]             {
[13:17:33.021]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:33.021]                   0L) {
[13:17:33.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:33.021]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:33.021]                   base::options(opts)
[13:17:33.021]                 }
[13:17:33.021]                 {
[13:17:33.021]                   {
[13:17:33.021]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:33.021]                     NULL
[13:17:33.021]                   }
[13:17:33.021]                   options(future.plan = NULL)
[13:17:33.021]                   if (is.na(NA_character_)) 
[13:17:33.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:33.021]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:33.021]                     envir = parent.frame()) 
[13:17:33.021]                   {
[13:17:33.021]                     default_workers <- missing(workers)
[13:17:33.021]                     if (is.function(workers)) 
[13:17:33.021]                       workers <- workers()
[13:17:33.021]                     workers <- structure(as.integer(workers), 
[13:17:33.021]                       class = class(workers))
[13:17:33.021]                     stop_if_not(is.finite(workers), workers >= 
[13:17:33.021]                       1L)
[13:17:33.021]                     if ((workers == 1L && !inherits(workers, 
[13:17:33.021]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:33.021]                       if (default_workers) 
[13:17:33.021]                         supportsMulticore(warn = TRUE)
[13:17:33.021]                       return(sequential(..., envir = envir))
[13:17:33.021]                     }
[13:17:33.021]                     oopts <- options(mc.cores = workers)
[13:17:33.021]                     on.exit(options(oopts))
[13:17:33.021]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:33.021]                       envir = envir)
[13:17:33.021]                     if (!future$lazy) 
[13:17:33.021]                       future <- run(future)
[13:17:33.021]                     invisible(future)
[13:17:33.021]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:33.021]                 }
[13:17:33.021]             }
[13:17:33.021]         }
[13:17:33.021]     })
[13:17:33.021]     if (TRUE) {
[13:17:33.021]         base::sink(type = "output", split = FALSE)
[13:17:33.021]         if (TRUE) {
[13:17:33.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:33.021]         }
[13:17:33.021]         else {
[13:17:33.021]             ...future.result["stdout"] <- base::list(NULL)
[13:17:33.021]         }
[13:17:33.021]         base::close(...future.stdout)
[13:17:33.021]         ...future.stdout <- NULL
[13:17:33.021]     }
[13:17:33.021]     ...future.result$conditions <- ...future.conditions
[13:17:33.021]     ...future.result$finished <- base::Sys.time()
[13:17:33.021]     ...future.result
[13:17:33.021] }
[13:17:33.023] assign_globals() ...
[13:17:33.024] List of 5
[13:17:33.024]  $ ...future.FUN            :function (x, ...)  
[13:17:33.024]  $ future.call.arguments    : list()
[13:17:33.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.024]  $ ...future.elements_ii    :List of 2
[13:17:33.024]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:33.024]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:33.024]  $ ...future.seeds_ii       : NULL
[13:17:33.024]  $ ...future.globals.maxSize: NULL
[13:17:33.024]  - attr(*, "resolved")= logi FALSE
[13:17:33.024]  - attr(*, "total_size")= num 1248
[13:17:33.024]  - attr(*, "where")=List of 5
[13:17:33.024]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:33.024]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:33.024]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:33.024]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:33.024]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:33.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.024]  - attr(*, "already-done")= logi TRUE
[13:17:33.031] - copied ‘...future.FUN’ to environment
[13:17:33.031] - copied ‘future.call.arguments’ to environment
[13:17:33.031] - copied ‘...future.elements_ii’ to environment
[13:17:33.032] - copied ‘...future.seeds_ii’ to environment
[13:17:33.032] - copied ‘...future.globals.maxSize’ to environment
[13:17:33.032] assign_globals() ... done
[13:17:33.032] requestCore(): workers = 2
[13:17:33.034] MulticoreFuture started
[13:17:33.035] - Launch lazy future ... done
[13:17:33.035] run() for ‘MulticoreFuture’ ... done
[13:17:33.035] Created future:
[13:17:33.036] plan(): Setting new future strategy stack:
[13:17:33.036] List of future strategies:
[13:17:33.036] 1. sequential:
[13:17:33.036]    - args: function (..., envir = parent.frame())
[13:17:33.036]    - tweaked: FALSE
[13:17:33.036]    - call: NULL
[13:17:33.037] plan(): nbrOfWorkers() = 1
[13:17:33.040] plan(): Setting new future strategy stack:
[13:17:33.040] List of future strategies:
[13:17:33.040] 1. multicore:
[13:17:33.040]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:33.040]    - tweaked: FALSE
[13:17:33.040]    - call: plan(strategy)
[13:17:33.045] plan(): nbrOfWorkers() = 2
[13:17:33.035] MulticoreFuture:
[13:17:33.035] Label: ‘future_eapply-2’
[13:17:33.035] Expression:
[13:17:33.035] {
[13:17:33.035]     do.call(function(...) {
[13:17:33.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.035]             on.exit(options(oopts), add = TRUE)
[13:17:33.035]         }
[13:17:33.035]         {
[13:17:33.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.035]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.035]             })
[13:17:33.035]         }
[13:17:33.035]     }, args = future.call.arguments)
[13:17:33.035] }
[13:17:33.035] Lazy evaluation: FALSE
[13:17:33.035] Asynchronous evaluation: TRUE
[13:17:33.035] Local evaluation: TRUE
[13:17:33.035] Environment: R_GlobalEnv
[13:17:33.035] Capture standard output: TRUE
[13:17:33.035] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:33.035] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:33.035] Packages: 1 packages (‘stats’)
[13:17:33.035] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:33.035] Resolved: TRUE
[13:17:33.035] Value: <not collected>
[13:17:33.035] Conditions captured: <none>
[13:17:33.035] Early signaling: FALSE
[13:17:33.035] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:33.035] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.046] Chunk #2 of 2 ... DONE
[13:17:33.047] Launching 2 futures (chunks) ... DONE
[13:17:33.047] Resolving 2 futures (chunks) ...
[13:17:33.047] resolve() on list ...
[13:17:33.047]  recursive: 0
[13:17:33.047]  length: 2
[13:17:33.047] 
[13:17:33.048] Future #1
[13:17:33.049] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:33.049] - nx: 2
[13:17:33.049] - relay: TRUE
[13:17:33.049] - stdout: TRUE
[13:17:33.049] - signal: TRUE
[13:17:33.049] - resignal: FALSE
[13:17:33.049] - force: TRUE
[13:17:33.049] - relayed: [n=2] FALSE, FALSE
[13:17:33.050] - queued futures: [n=2] FALSE, FALSE
[13:17:33.050]  - until=1
[13:17:33.050]  - relaying element #1
[13:17:33.050] - relayed: [n=2] TRUE, FALSE
[13:17:33.050] - queued futures: [n=2] TRUE, FALSE
[13:17:33.050] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:33.051]  length: 1 (resolved future 1)
[13:17:33.051] Future #2
[13:17:33.052] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:33.052] - nx: 2
[13:17:33.052] - relay: TRUE
[13:17:33.056] - stdout: TRUE
[13:17:33.056] - signal: TRUE
[13:17:33.056] - resignal: FALSE
[13:17:33.056] - force: TRUE
[13:17:33.056] - relayed: [n=2] TRUE, FALSE
[13:17:33.056] - queued futures: [n=2] TRUE, FALSE
[13:17:33.056]  - until=2
[13:17:33.056]  - relaying element #2
[13:17:33.057] - relayed: [n=2] TRUE, TRUE
[13:17:33.057] - queued futures: [n=2] TRUE, TRUE
[13:17:33.057] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:33.057]  length: 0 (resolved future 2)
[13:17:33.057] Relaying remaining futures
[13:17:33.058] signalConditionsASAP(NULL, pos=0) ...
[13:17:33.058] - nx: 2
[13:17:33.058] - relay: TRUE
[13:17:33.058] - stdout: TRUE
[13:17:33.058] - signal: TRUE
[13:17:33.058] - resignal: FALSE
[13:17:33.058] - force: TRUE
[13:17:33.058] - relayed: [n=2] TRUE, TRUE
[13:17:33.059] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:33.059] - relayed: [n=2] TRUE, TRUE
[13:17:33.059] - queued futures: [n=2] TRUE, TRUE
[13:17:33.059] signalConditionsASAP(NULL, pos=0) ... done
[13:17:33.059] resolve() on list ... DONE
[13:17:33.059]  - Number of value chunks collected: 2
[13:17:33.059] Resolving 2 futures (chunks) ... DONE
[13:17:33.060] Reducing values from 2 chunks ...
[13:17:33.060]  - Number of values collected after concatenation: 3
[13:17:33.060]  - Number of values expected: 3
[13:17:33.060] Reducing values from 2 chunks ... DONE
[13:17:33.060] future_lapply() ... DONE
[13:17:33.060] future_lapply() ...
[13:17:33.065] Number of chunks: 2
[13:17:33.066] getGlobalsAndPackagesXApply() ...
[13:17:33.066]  - future.globals: TRUE
[13:17:33.066] getGlobalsAndPackages() ...
[13:17:33.066] Searching for globals...
[13:17:33.067] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:33.067] Searching for globals ... DONE
[13:17:33.068] Resolving globals: FALSE
[13:17:33.068] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:33.068] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:33.068] - globals: [1] ‘FUN’
[13:17:33.069] - packages: [1] ‘stats’
[13:17:33.069] getGlobalsAndPackages() ... DONE
[13:17:33.069]  - globals found/used: [n=1] ‘FUN’
[13:17:33.069]  - needed namespaces: [n=1] ‘stats’
[13:17:33.069] Finding globals ... DONE
[13:17:33.069]  - use_args: TRUE
[13:17:33.069]  - Getting '...' globals ...
[13:17:33.070] resolve() on list ...
[13:17:33.070]  recursive: 0
[13:17:33.070]  length: 1
[13:17:33.070]  elements: ‘...’
[13:17:33.070]  length: 0 (resolved future 1)
[13:17:33.070] resolve() on list ... DONE
[13:17:33.070]    - '...' content: [n=0] 
[13:17:33.071] List of 1
[13:17:33.071]  $ ...: list()
[13:17:33.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.071]  - attr(*, "where")=List of 1
[13:17:33.071]   ..$ ...:<environment: 0x55be3c4a5820> 
[13:17:33.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.071]  - attr(*, "resolved")= logi TRUE
[13:17:33.071]  - attr(*, "total_size")= num NA
[13:17:33.074]  - Getting '...' globals ... DONE
[13:17:33.074] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:33.074] List of 2
[13:17:33.074]  $ ...future.FUN:function (x, ...)  
[13:17:33.074]  $ ...          : list()
[13:17:33.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.074]  - attr(*, "where")=List of 2
[13:17:33.074]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:33.074]   ..$ ...          :<environment: 0x55be3c4a5820> 
[13:17:33.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.074]  - attr(*, "resolved")= logi FALSE
[13:17:33.074]  - attr(*, "total_size")= num 1248
[13:17:33.077] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:33.077] getGlobalsAndPackagesXApply() ... DONE
[13:17:33.078] Number of futures (= number of chunks): 2
[13:17:33.078] Launching 2 futures (chunks) ...
[13:17:33.078] Chunk #1 of 2 ...
[13:17:33.078]  - Finding globals in 'X' for chunk #1 ...
[13:17:33.078] getGlobalsAndPackages() ...
[13:17:33.078] Searching for globals...
[13:17:33.078] 
[13:17:33.078] Searching for globals ... DONE
[13:17:33.079] - globals: [0] <none>
[13:17:33.079] getGlobalsAndPackages() ... DONE
[13:17:33.079]    + additional globals found: [n=0] 
[13:17:33.079]    + additional namespaces needed: [n=0] 
[13:17:33.079]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:33.079]  - seeds: <none>
[13:17:33.079] getGlobalsAndPackages() ...
[13:17:33.079] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.079] Resolving globals: FALSE
[13:17:33.079] Tweak future expression to call with '...' arguments ...
[13:17:33.079] {
[13:17:33.079]     do.call(function(...) {
[13:17:33.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.079]             on.exit(options(oopts), add = TRUE)
[13:17:33.079]         }
[13:17:33.079]         {
[13:17:33.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.079]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.079]             })
[13:17:33.079]         }
[13:17:33.079]     }, args = future.call.arguments)
[13:17:33.079] }
[13:17:33.080] Tweak future expression to call with '...' arguments ... DONE
[13:17:33.080] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.080] - packages: [1] ‘stats’
[13:17:33.080] getGlobalsAndPackages() ... DONE
[13:17:33.081] run() for ‘Future’ ...
[13:17:33.081] - state: ‘created’
[13:17:33.081] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:33.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:33.087]   - Field: ‘label’
[13:17:33.087]   - Field: ‘local’
[13:17:33.087]   - Field: ‘owner’
[13:17:33.087]   - Field: ‘envir’
[13:17:33.087]   - Field: ‘workers’
[13:17:33.087]   - Field: ‘packages’
[13:17:33.087]   - Field: ‘gc’
[13:17:33.087]   - Field: ‘job’
[13:17:33.087]   - Field: ‘conditions’
[13:17:33.087]   - Field: ‘expr’
[13:17:33.088]   - Field: ‘uuid’
[13:17:33.088]   - Field: ‘seed’
[13:17:33.088]   - Field: ‘version’
[13:17:33.088]   - Field: ‘result’
[13:17:33.088]   - Field: ‘asynchronous’
[13:17:33.088]   - Field: ‘calls’
[13:17:33.088]   - Field: ‘globals’
[13:17:33.088]   - Field: ‘stdout’
[13:17:33.088]   - Field: ‘earlySignal’
[13:17:33.088]   - Field: ‘lazy’
[13:17:33.089]   - Field: ‘state’
[13:17:33.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:33.089] - Launch lazy future ...
[13:17:33.089] Packages needed by the future expression (n = 1): ‘stats’
[13:17:33.089] Packages needed by future strategies (n = 0): <none>
[13:17:33.090] {
[13:17:33.090]     {
[13:17:33.090]         {
[13:17:33.090]             ...future.startTime <- base::Sys.time()
[13:17:33.090]             {
[13:17:33.090]                 {
[13:17:33.090]                   {
[13:17:33.090]                     {
[13:17:33.090]                       {
[13:17:33.090]                         base::local({
[13:17:33.090]                           has_future <- base::requireNamespace("future", 
[13:17:33.090]                             quietly = TRUE)
[13:17:33.090]                           if (has_future) {
[13:17:33.090]                             ns <- base::getNamespace("future")
[13:17:33.090]                             version <- ns[[".package"]][["version"]]
[13:17:33.090]                             if (is.null(version)) 
[13:17:33.090]                               version <- utils::packageVersion("future")
[13:17:33.090]                           }
[13:17:33.090]                           else {
[13:17:33.090]                             version <- NULL
[13:17:33.090]                           }
[13:17:33.090]                           if (!has_future || version < "1.8.0") {
[13:17:33.090]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:33.090]                               "", base::R.version$version.string), 
[13:17:33.090]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:33.090]                                 base::R.version$platform, 8 * 
[13:17:33.090]                                   base::.Machine$sizeof.pointer), 
[13:17:33.090]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:33.090]                                 "release", "version")], collapse = " "), 
[13:17:33.090]                               hostname = base::Sys.info()[["nodename"]])
[13:17:33.090]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:33.090]                               info)
[13:17:33.090]                             info <- base::paste(info, collapse = "; ")
[13:17:33.090]                             if (!has_future) {
[13:17:33.090]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:33.090]                                 info)
[13:17:33.090]                             }
[13:17:33.090]                             else {
[13:17:33.090]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:33.090]                                 info, version)
[13:17:33.090]                             }
[13:17:33.090]                             base::stop(msg)
[13:17:33.090]                           }
[13:17:33.090]                         })
[13:17:33.090]                       }
[13:17:33.090]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:33.090]                       base::options(mc.cores = 1L)
[13:17:33.090]                     }
[13:17:33.090]                     base::local({
[13:17:33.090]                       for (pkg in "stats") {
[13:17:33.090]                         base::loadNamespace(pkg)
[13:17:33.090]                         base::library(pkg, character.only = TRUE)
[13:17:33.090]                       }
[13:17:33.090]                     })
[13:17:33.090]                   }
[13:17:33.090]                   options(future.plan = NULL)
[13:17:33.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:33.090]                 }
[13:17:33.090]                 ...future.workdir <- getwd()
[13:17:33.090]             }
[13:17:33.090]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:33.090]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:33.090]         }
[13:17:33.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:33.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:33.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:33.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:33.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:33.090]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:33.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:33.090]             base::names(...future.oldOptions))
[13:17:33.090]     }
[13:17:33.090]     if (FALSE) {
[13:17:33.090]     }
[13:17:33.090]     else {
[13:17:33.090]         if (TRUE) {
[13:17:33.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:33.090]                 open = "w")
[13:17:33.090]         }
[13:17:33.090]         else {
[13:17:33.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:33.090]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:33.090]         }
[13:17:33.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:33.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:33.090]             base::sink(type = "output", split = FALSE)
[13:17:33.090]             base::close(...future.stdout)
[13:17:33.090]         }, add = TRUE)
[13:17:33.090]     }
[13:17:33.090]     ...future.frame <- base::sys.nframe()
[13:17:33.090]     ...future.conditions <- base::list()
[13:17:33.090]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:33.090]     if (FALSE) {
[13:17:33.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:33.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:33.090]     }
[13:17:33.090]     ...future.result <- base::tryCatch({
[13:17:33.090]         base::withCallingHandlers({
[13:17:33.090]             ...future.value <- base::withVisible(base::local({
[13:17:33.090]                 withCallingHandlers({
[13:17:33.090]                   {
[13:17:33.090]                     do.call(function(...) {
[13:17:33.090]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.090]                       if (!identical(...future.globals.maxSize.org, 
[13:17:33.090]                         ...future.globals.maxSize)) {
[13:17:33.090]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.090]                         on.exit(options(oopts), add = TRUE)
[13:17:33.090]                       }
[13:17:33.090]                       {
[13:17:33.090]                         lapply(seq_along(...future.elements_ii), 
[13:17:33.090]                           FUN = function(jj) {
[13:17:33.090]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.090]                             ...future.FUN(...future.X_jj, ...)
[13:17:33.090]                           })
[13:17:33.090]                       }
[13:17:33.090]                     }, args = future.call.arguments)
[13:17:33.090]                   }
[13:17:33.090]                 }, immediateCondition = function(cond) {
[13:17:33.090]                   save_rds <- function (object, pathname, ...) 
[13:17:33.090]                   {
[13:17:33.090]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:33.090]                     if (file_test("-f", pathname_tmp)) {
[13:17:33.090]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.090]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:33.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.090]                         fi_tmp[["mtime"]])
[13:17:33.090]                     }
[13:17:33.090]                     tryCatch({
[13:17:33.090]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:33.090]                     }, error = function(ex) {
[13:17:33.090]                       msg <- conditionMessage(ex)
[13:17:33.090]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.090]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:33.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.090]                         fi_tmp[["mtime"]], msg)
[13:17:33.090]                       ex$message <- msg
[13:17:33.090]                       stop(ex)
[13:17:33.090]                     })
[13:17:33.090]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:33.090]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:33.090]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:33.090]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.090]                       fi <- file.info(pathname)
[13:17:33.090]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:33.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.090]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:33.090]                         fi[["size"]], fi[["mtime"]])
[13:17:33.090]                       stop(msg)
[13:17:33.090]                     }
[13:17:33.090]                     invisible(pathname)
[13:17:33.090]                   }
[13:17:33.090]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:33.090]                     rootPath = tempdir()) 
[13:17:33.090]                   {
[13:17:33.090]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:33.090]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:33.090]                       tmpdir = path, fileext = ".rds")
[13:17:33.090]                     save_rds(obj, file)
[13:17:33.090]                   }
[13:17:33.090]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:33.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.090]                   {
[13:17:33.090]                     inherits <- base::inherits
[13:17:33.090]                     invokeRestart <- base::invokeRestart
[13:17:33.090]                     is.null <- base::is.null
[13:17:33.090]                     muffled <- FALSE
[13:17:33.090]                     if (inherits(cond, "message")) {
[13:17:33.090]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:33.090]                       if (muffled) 
[13:17:33.090]                         invokeRestart("muffleMessage")
[13:17:33.090]                     }
[13:17:33.090]                     else if (inherits(cond, "warning")) {
[13:17:33.090]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:33.090]                       if (muffled) 
[13:17:33.090]                         invokeRestart("muffleWarning")
[13:17:33.090]                     }
[13:17:33.090]                     else if (inherits(cond, "condition")) {
[13:17:33.090]                       if (!is.null(pattern)) {
[13:17:33.090]                         computeRestarts <- base::computeRestarts
[13:17:33.090]                         grepl <- base::grepl
[13:17:33.090]                         restarts <- computeRestarts(cond)
[13:17:33.090]                         for (restart in restarts) {
[13:17:33.090]                           name <- restart$name
[13:17:33.090]                           if (is.null(name)) 
[13:17:33.090]                             next
[13:17:33.090]                           if (!grepl(pattern, name)) 
[13:17:33.090]                             next
[13:17:33.090]                           invokeRestart(restart)
[13:17:33.090]                           muffled <- TRUE
[13:17:33.090]                           break
[13:17:33.090]                         }
[13:17:33.090]                       }
[13:17:33.090]                     }
[13:17:33.090]                     invisible(muffled)
[13:17:33.090]                   }
[13:17:33.090]                   muffleCondition(cond)
[13:17:33.090]                 })
[13:17:33.090]             }))
[13:17:33.090]             future::FutureResult(value = ...future.value$value, 
[13:17:33.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.090]                   ...future.rng), globalenv = if (FALSE) 
[13:17:33.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:33.090]                     ...future.globalenv.names))
[13:17:33.090]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:33.090]         }, condition = base::local({
[13:17:33.090]             c <- base::c
[13:17:33.090]             inherits <- base::inherits
[13:17:33.090]             invokeRestart <- base::invokeRestart
[13:17:33.090]             length <- base::length
[13:17:33.090]             list <- base::list
[13:17:33.090]             seq.int <- base::seq.int
[13:17:33.090]             signalCondition <- base::signalCondition
[13:17:33.090]             sys.calls <- base::sys.calls
[13:17:33.090]             `[[` <- base::`[[`
[13:17:33.090]             `+` <- base::`+`
[13:17:33.090]             `<<-` <- base::`<<-`
[13:17:33.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:33.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:33.090]                   3L)]
[13:17:33.090]             }
[13:17:33.090]             function(cond) {
[13:17:33.090]                 is_error <- inherits(cond, "error")
[13:17:33.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:33.090]                   NULL)
[13:17:33.090]                 if (is_error) {
[13:17:33.090]                   sessionInformation <- function() {
[13:17:33.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:33.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:33.090]                       search = base::search(), system = base::Sys.info())
[13:17:33.090]                   }
[13:17:33.090]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:33.090]                     cond$call), session = sessionInformation(), 
[13:17:33.090]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:33.090]                   signalCondition(cond)
[13:17:33.090]                 }
[13:17:33.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:33.090]                 "immediateCondition"))) {
[13:17:33.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:33.090]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:33.090]                   if (TRUE && !signal) {
[13:17:33.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.090]                     {
[13:17:33.090]                       inherits <- base::inherits
[13:17:33.090]                       invokeRestart <- base::invokeRestart
[13:17:33.090]                       is.null <- base::is.null
[13:17:33.090]                       muffled <- FALSE
[13:17:33.090]                       if (inherits(cond, "message")) {
[13:17:33.090]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.090]                         if (muffled) 
[13:17:33.090]                           invokeRestart("muffleMessage")
[13:17:33.090]                       }
[13:17:33.090]                       else if (inherits(cond, "warning")) {
[13:17:33.090]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.090]                         if (muffled) 
[13:17:33.090]                           invokeRestart("muffleWarning")
[13:17:33.090]                       }
[13:17:33.090]                       else if (inherits(cond, "condition")) {
[13:17:33.090]                         if (!is.null(pattern)) {
[13:17:33.090]                           computeRestarts <- base::computeRestarts
[13:17:33.090]                           grepl <- base::grepl
[13:17:33.090]                           restarts <- computeRestarts(cond)
[13:17:33.090]                           for (restart in restarts) {
[13:17:33.090]                             name <- restart$name
[13:17:33.090]                             if (is.null(name)) 
[13:17:33.090]                               next
[13:17:33.090]                             if (!grepl(pattern, name)) 
[13:17:33.090]                               next
[13:17:33.090]                             invokeRestart(restart)
[13:17:33.090]                             muffled <- TRUE
[13:17:33.090]                             break
[13:17:33.090]                           }
[13:17:33.090]                         }
[13:17:33.090]                       }
[13:17:33.090]                       invisible(muffled)
[13:17:33.090]                     }
[13:17:33.090]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.090]                   }
[13:17:33.090]                 }
[13:17:33.090]                 else {
[13:17:33.090]                   if (TRUE) {
[13:17:33.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.090]                     {
[13:17:33.090]                       inherits <- base::inherits
[13:17:33.090]                       invokeRestart <- base::invokeRestart
[13:17:33.090]                       is.null <- base::is.null
[13:17:33.090]                       muffled <- FALSE
[13:17:33.090]                       if (inherits(cond, "message")) {
[13:17:33.090]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.090]                         if (muffled) 
[13:17:33.090]                           invokeRestart("muffleMessage")
[13:17:33.090]                       }
[13:17:33.090]                       else if (inherits(cond, "warning")) {
[13:17:33.090]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.090]                         if (muffled) 
[13:17:33.090]                           invokeRestart("muffleWarning")
[13:17:33.090]                       }
[13:17:33.090]                       else if (inherits(cond, "condition")) {
[13:17:33.090]                         if (!is.null(pattern)) {
[13:17:33.090]                           computeRestarts <- base::computeRestarts
[13:17:33.090]                           grepl <- base::grepl
[13:17:33.090]                           restarts <- computeRestarts(cond)
[13:17:33.090]                           for (restart in restarts) {
[13:17:33.090]                             name <- restart$name
[13:17:33.090]                             if (is.null(name)) 
[13:17:33.090]                               next
[13:17:33.090]                             if (!grepl(pattern, name)) 
[13:17:33.090]                               next
[13:17:33.090]                             invokeRestart(restart)
[13:17:33.090]                             muffled <- TRUE
[13:17:33.090]                             break
[13:17:33.090]                           }
[13:17:33.090]                         }
[13:17:33.090]                       }
[13:17:33.090]                       invisible(muffled)
[13:17:33.090]                     }
[13:17:33.090]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.090]                   }
[13:17:33.090]                 }
[13:17:33.090]             }
[13:17:33.090]         }))
[13:17:33.090]     }, error = function(ex) {
[13:17:33.090]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:33.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.090]                 ...future.rng), started = ...future.startTime, 
[13:17:33.090]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:33.090]             version = "1.8"), class = "FutureResult")
[13:17:33.090]     }, finally = {
[13:17:33.090]         if (!identical(...future.workdir, getwd())) 
[13:17:33.090]             setwd(...future.workdir)
[13:17:33.090]         {
[13:17:33.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:33.090]                 ...future.oldOptions$nwarnings <- NULL
[13:17:33.090]             }
[13:17:33.090]             base::options(...future.oldOptions)
[13:17:33.090]             if (.Platform$OS.type == "windows") {
[13:17:33.090]                 old_names <- names(...future.oldEnvVars)
[13:17:33.090]                 envs <- base::Sys.getenv()
[13:17:33.090]                 names <- names(envs)
[13:17:33.090]                 common <- intersect(names, old_names)
[13:17:33.090]                 added <- setdiff(names, old_names)
[13:17:33.090]                 removed <- setdiff(old_names, names)
[13:17:33.090]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:33.090]                   envs[common]]
[13:17:33.090]                 NAMES <- toupper(changed)
[13:17:33.090]                 args <- list()
[13:17:33.090]                 for (kk in seq_along(NAMES)) {
[13:17:33.090]                   name <- changed[[kk]]
[13:17:33.090]                   NAME <- NAMES[[kk]]
[13:17:33.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.090]                     next
[13:17:33.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.090]                 }
[13:17:33.090]                 NAMES <- toupper(added)
[13:17:33.090]                 for (kk in seq_along(NAMES)) {
[13:17:33.090]                   name <- added[[kk]]
[13:17:33.090]                   NAME <- NAMES[[kk]]
[13:17:33.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.090]                     next
[13:17:33.090]                   args[[name]] <- ""
[13:17:33.090]                 }
[13:17:33.090]                 NAMES <- toupper(removed)
[13:17:33.090]                 for (kk in seq_along(NAMES)) {
[13:17:33.090]                   name <- removed[[kk]]
[13:17:33.090]                   NAME <- NAMES[[kk]]
[13:17:33.090]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.090]                     next
[13:17:33.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.090]                 }
[13:17:33.090]                 if (length(args) > 0) 
[13:17:33.090]                   base::do.call(base::Sys.setenv, args = args)
[13:17:33.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:33.090]             }
[13:17:33.090]             else {
[13:17:33.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:33.090]             }
[13:17:33.090]             {
[13:17:33.090]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:33.090]                   0L) {
[13:17:33.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:33.090]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:33.090]                   base::options(opts)
[13:17:33.090]                 }
[13:17:33.090]                 {
[13:17:33.090]                   {
[13:17:33.090]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:33.090]                     NULL
[13:17:33.090]                   }
[13:17:33.090]                   options(future.plan = NULL)
[13:17:33.090]                   if (is.na(NA_character_)) 
[13:17:33.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:33.090]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:33.090]                     envir = parent.frame()) 
[13:17:33.090]                   {
[13:17:33.090]                     default_workers <- missing(workers)
[13:17:33.090]                     if (is.function(workers)) 
[13:17:33.090]                       workers <- workers()
[13:17:33.090]                     workers <- structure(as.integer(workers), 
[13:17:33.090]                       class = class(workers))
[13:17:33.090]                     stop_if_not(is.finite(workers), workers >= 
[13:17:33.090]                       1L)
[13:17:33.090]                     if ((workers == 1L && !inherits(workers, 
[13:17:33.090]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:33.090]                       if (default_workers) 
[13:17:33.090]                         supportsMulticore(warn = TRUE)
[13:17:33.090]                       return(sequential(..., envir = envir))
[13:17:33.090]                     }
[13:17:33.090]                     oopts <- options(mc.cores = workers)
[13:17:33.090]                     on.exit(options(oopts))
[13:17:33.090]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:33.090]                       envir = envir)
[13:17:33.090]                     if (!future$lazy) 
[13:17:33.090]                       future <- run(future)
[13:17:33.090]                     invisible(future)
[13:17:33.090]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:33.090]                 }
[13:17:33.090]             }
[13:17:33.090]         }
[13:17:33.090]     })
[13:17:33.090]     if (TRUE) {
[13:17:33.090]         base::sink(type = "output", split = FALSE)
[13:17:33.090]         if (TRUE) {
[13:17:33.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:33.090]         }
[13:17:33.090]         else {
[13:17:33.090]             ...future.result["stdout"] <- base::list(NULL)
[13:17:33.090]         }
[13:17:33.090]         base::close(...future.stdout)
[13:17:33.090]         ...future.stdout <- NULL
[13:17:33.090]     }
[13:17:33.090]     ...future.result$conditions <- ...future.conditions
[13:17:33.090]     ...future.result$finished <- base::Sys.time()
[13:17:33.090]     ...future.result
[13:17:33.090] }
[13:17:33.092] assign_globals() ...
[13:17:33.092] List of 5
[13:17:33.092]  $ ...future.FUN            :function (x, ...)  
[13:17:33.092]  $ future.call.arguments    : list()
[13:17:33.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.092]  $ ...future.elements_ii    :List of 1
[13:17:33.092]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:17:33.092]  $ ...future.seeds_ii       : NULL
[13:17:33.092]  $ ...future.globals.maxSize: NULL
[13:17:33.092]  - attr(*, "where")=List of 5
[13:17:33.092]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:33.092]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:33.092]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:33.092]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:33.092]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:33.092]  - attr(*, "resolved")= logi FALSE
[13:17:33.092]  - attr(*, "total_size")= num 1248
[13:17:33.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.092]  - attr(*, "already-done")= logi TRUE
[13:17:33.097] - copied ‘...future.FUN’ to environment
[13:17:33.097] - copied ‘future.call.arguments’ to environment
[13:17:33.097] - copied ‘...future.elements_ii’ to environment
[13:17:33.097] - copied ‘...future.seeds_ii’ to environment
[13:17:33.097] - copied ‘...future.globals.maxSize’ to environment
[13:17:33.098] assign_globals() ... done
[13:17:33.098] requestCore(): workers = 2
[13:17:33.100] MulticoreFuture started
[13:17:33.100] - Launch lazy future ... done
[13:17:33.100] run() for ‘MulticoreFuture’ ... done
[13:17:33.100] Created future:
[13:17:33.101] plan(): Setting new future strategy stack:
[13:17:33.101] List of future strategies:
[13:17:33.101] 1. sequential:
[13:17:33.101]    - args: function (..., envir = parent.frame())
[13:17:33.101]    - tweaked: FALSE
[13:17:33.101]    - call: NULL
[13:17:33.102] plan(): nbrOfWorkers() = 1
[13:17:33.105] plan(): Setting new future strategy stack:
[13:17:33.105] List of future strategies:
[13:17:33.105] 1. multicore:
[13:17:33.105]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:33.105]    - tweaked: FALSE
[13:17:33.105]    - call: plan(strategy)
[13:17:33.110] plan(): nbrOfWorkers() = 2
[13:17:33.101] MulticoreFuture:
[13:17:33.101] Label: ‘future_eapply-1’
[13:17:33.101] Expression:
[13:17:33.101] {
[13:17:33.101]     do.call(function(...) {
[13:17:33.101]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.101]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.101]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.101]             on.exit(options(oopts), add = TRUE)
[13:17:33.101]         }
[13:17:33.101]         {
[13:17:33.101]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.101]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.101]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.101]             })
[13:17:33.101]         }
[13:17:33.101]     }, args = future.call.arguments)
[13:17:33.101] }
[13:17:33.101] Lazy evaluation: FALSE
[13:17:33.101] Asynchronous evaluation: TRUE
[13:17:33.101] Local evaluation: TRUE
[13:17:33.101] Environment: R_GlobalEnv
[13:17:33.101] Capture standard output: TRUE
[13:17:33.101] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:33.101] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:33.101] Packages: 1 packages (‘stats’)
[13:17:33.101] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:33.101] Resolved: TRUE
[13:17:33.101] Value: <not collected>
[13:17:33.101] Conditions captured: <none>
[13:17:33.101] Early signaling: FALSE
[13:17:33.101] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:33.101] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.111] Chunk #1 of 2 ... DONE
[13:17:33.111] Chunk #2 of 2 ...
[13:17:33.111]  - Finding globals in 'X' for chunk #2 ...
[13:17:33.112] getGlobalsAndPackages() ...
[13:17:33.112] Searching for globals...
[13:17:33.112] 
[13:17:33.112] Searching for globals ... DONE
[13:17:33.112] - globals: [0] <none>
[13:17:33.113] getGlobalsAndPackages() ... DONE
[13:17:33.113]    + additional globals found: [n=0] 
[13:17:33.113]    + additional namespaces needed: [n=0] 
[13:17:33.113]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:33.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:33.113]  - seeds: <none>
[13:17:33.113] getGlobalsAndPackages() ...
[13:17:33.113] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.114] Resolving globals: FALSE
[13:17:33.114] Tweak future expression to call with '...' arguments ...
[13:17:33.114] {
[13:17:33.114]     do.call(function(...) {
[13:17:33.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.114]             on.exit(options(oopts), add = TRUE)
[13:17:33.114]         }
[13:17:33.114]         {
[13:17:33.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.114]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.114]             })
[13:17:33.114]         }
[13:17:33.114]     }, args = future.call.arguments)
[13:17:33.114] }
[13:17:33.114] Tweak future expression to call with '...' arguments ... DONE
[13:17:33.115] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.115] - packages: [1] ‘stats’
[13:17:33.115] getGlobalsAndPackages() ... DONE
[13:17:33.116] run() for ‘Future’ ...
[13:17:33.116] - state: ‘created’
[13:17:33.116] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:33.121] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:33.121]   - Field: ‘label’
[13:17:33.121]   - Field: ‘local’
[13:17:33.122]   - Field: ‘owner’
[13:17:33.122]   - Field: ‘envir’
[13:17:33.122]   - Field: ‘workers’
[13:17:33.122]   - Field: ‘packages’
[13:17:33.122]   - Field: ‘gc’
[13:17:33.122]   - Field: ‘job’
[13:17:33.122]   - Field: ‘conditions’
[13:17:33.123]   - Field: ‘expr’
[13:17:33.123]   - Field: ‘uuid’
[13:17:33.123]   - Field: ‘seed’
[13:17:33.123]   - Field: ‘version’
[13:17:33.123]   - Field: ‘result’
[13:17:33.123]   - Field: ‘asynchronous’
[13:17:33.123]   - Field: ‘calls’
[13:17:33.123]   - Field: ‘globals’
[13:17:33.124]   - Field: ‘stdout’
[13:17:33.124]   - Field: ‘earlySignal’
[13:17:33.124]   - Field: ‘lazy’
[13:17:33.124]   - Field: ‘state’
[13:17:33.124] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:33.124] - Launch lazy future ...
[13:17:33.125] Packages needed by the future expression (n = 1): ‘stats’
[13:17:33.125] Packages needed by future strategies (n = 0): <none>
[13:17:33.126] {
[13:17:33.126]     {
[13:17:33.126]         {
[13:17:33.126]             ...future.startTime <- base::Sys.time()
[13:17:33.126]             {
[13:17:33.126]                 {
[13:17:33.126]                   {
[13:17:33.126]                     {
[13:17:33.126]                       {
[13:17:33.126]                         base::local({
[13:17:33.126]                           has_future <- base::requireNamespace("future", 
[13:17:33.126]                             quietly = TRUE)
[13:17:33.126]                           if (has_future) {
[13:17:33.126]                             ns <- base::getNamespace("future")
[13:17:33.126]                             version <- ns[[".package"]][["version"]]
[13:17:33.126]                             if (is.null(version)) 
[13:17:33.126]                               version <- utils::packageVersion("future")
[13:17:33.126]                           }
[13:17:33.126]                           else {
[13:17:33.126]                             version <- NULL
[13:17:33.126]                           }
[13:17:33.126]                           if (!has_future || version < "1.8.0") {
[13:17:33.126]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:33.126]                               "", base::R.version$version.string), 
[13:17:33.126]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:33.126]                                 base::R.version$platform, 8 * 
[13:17:33.126]                                   base::.Machine$sizeof.pointer), 
[13:17:33.126]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:33.126]                                 "release", "version")], collapse = " "), 
[13:17:33.126]                               hostname = base::Sys.info()[["nodename"]])
[13:17:33.126]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:33.126]                               info)
[13:17:33.126]                             info <- base::paste(info, collapse = "; ")
[13:17:33.126]                             if (!has_future) {
[13:17:33.126]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:33.126]                                 info)
[13:17:33.126]                             }
[13:17:33.126]                             else {
[13:17:33.126]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:33.126]                                 info, version)
[13:17:33.126]                             }
[13:17:33.126]                             base::stop(msg)
[13:17:33.126]                           }
[13:17:33.126]                         })
[13:17:33.126]                       }
[13:17:33.126]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:33.126]                       base::options(mc.cores = 1L)
[13:17:33.126]                     }
[13:17:33.126]                     base::local({
[13:17:33.126]                       for (pkg in "stats") {
[13:17:33.126]                         base::loadNamespace(pkg)
[13:17:33.126]                         base::library(pkg, character.only = TRUE)
[13:17:33.126]                       }
[13:17:33.126]                     })
[13:17:33.126]                   }
[13:17:33.126]                   options(future.plan = NULL)
[13:17:33.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:33.126]                 }
[13:17:33.126]                 ...future.workdir <- getwd()
[13:17:33.126]             }
[13:17:33.126]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:33.126]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:33.126]         }
[13:17:33.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:33.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:33.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:33.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:33.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:33.126]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:33.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:33.126]             base::names(...future.oldOptions))
[13:17:33.126]     }
[13:17:33.126]     if (FALSE) {
[13:17:33.126]     }
[13:17:33.126]     else {
[13:17:33.126]         if (TRUE) {
[13:17:33.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:33.126]                 open = "w")
[13:17:33.126]         }
[13:17:33.126]         else {
[13:17:33.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:33.126]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:33.126]         }
[13:17:33.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:33.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:33.126]             base::sink(type = "output", split = FALSE)
[13:17:33.126]             base::close(...future.stdout)
[13:17:33.126]         }, add = TRUE)
[13:17:33.126]     }
[13:17:33.126]     ...future.frame <- base::sys.nframe()
[13:17:33.126]     ...future.conditions <- base::list()
[13:17:33.126]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:33.126]     if (FALSE) {
[13:17:33.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:33.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:33.126]     }
[13:17:33.126]     ...future.result <- base::tryCatch({
[13:17:33.126]         base::withCallingHandlers({
[13:17:33.126]             ...future.value <- base::withVisible(base::local({
[13:17:33.126]                 withCallingHandlers({
[13:17:33.126]                   {
[13:17:33.126]                     do.call(function(...) {
[13:17:33.126]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.126]                       if (!identical(...future.globals.maxSize.org, 
[13:17:33.126]                         ...future.globals.maxSize)) {
[13:17:33.126]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.126]                         on.exit(options(oopts), add = TRUE)
[13:17:33.126]                       }
[13:17:33.126]                       {
[13:17:33.126]                         lapply(seq_along(...future.elements_ii), 
[13:17:33.126]                           FUN = function(jj) {
[13:17:33.126]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.126]                             ...future.FUN(...future.X_jj, ...)
[13:17:33.126]                           })
[13:17:33.126]                       }
[13:17:33.126]                     }, args = future.call.arguments)
[13:17:33.126]                   }
[13:17:33.126]                 }, immediateCondition = function(cond) {
[13:17:33.126]                   save_rds <- function (object, pathname, ...) 
[13:17:33.126]                   {
[13:17:33.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:33.126]                     if (file_test("-f", pathname_tmp)) {
[13:17:33.126]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:33.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.126]                         fi_tmp[["mtime"]])
[13:17:33.126]                     }
[13:17:33.126]                     tryCatch({
[13:17:33.126]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:33.126]                     }, error = function(ex) {
[13:17:33.126]                       msg <- conditionMessage(ex)
[13:17:33.126]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:33.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.126]                         fi_tmp[["mtime"]], msg)
[13:17:33.126]                       ex$message <- msg
[13:17:33.126]                       stop(ex)
[13:17:33.126]                     })
[13:17:33.126]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:33.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:33.126]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:33.126]                       fi_tmp <- file.info(pathname_tmp)
[13:17:33.126]                       fi <- file.info(pathname)
[13:17:33.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:33.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:33.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:33.126]                         fi[["size"]], fi[["mtime"]])
[13:17:33.126]                       stop(msg)
[13:17:33.126]                     }
[13:17:33.126]                     invisible(pathname)
[13:17:33.126]                   }
[13:17:33.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:33.126]                     rootPath = tempdir()) 
[13:17:33.126]                   {
[13:17:33.126]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:33.126]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:33.126]                       tmpdir = path, fileext = ".rds")
[13:17:33.126]                     save_rds(obj, file)
[13:17:33.126]                   }
[13:17:33.126]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8oNlRe/.future/immediateConditions")
[13:17:33.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.126]                   {
[13:17:33.126]                     inherits <- base::inherits
[13:17:33.126]                     invokeRestart <- base::invokeRestart
[13:17:33.126]                     is.null <- base::is.null
[13:17:33.126]                     muffled <- FALSE
[13:17:33.126]                     if (inherits(cond, "message")) {
[13:17:33.126]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:33.126]                       if (muffled) 
[13:17:33.126]                         invokeRestart("muffleMessage")
[13:17:33.126]                     }
[13:17:33.126]                     else if (inherits(cond, "warning")) {
[13:17:33.126]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:33.126]                       if (muffled) 
[13:17:33.126]                         invokeRestart("muffleWarning")
[13:17:33.126]                     }
[13:17:33.126]                     else if (inherits(cond, "condition")) {
[13:17:33.126]                       if (!is.null(pattern)) {
[13:17:33.126]                         computeRestarts <- base::computeRestarts
[13:17:33.126]                         grepl <- base::grepl
[13:17:33.126]                         restarts <- computeRestarts(cond)
[13:17:33.126]                         for (restart in restarts) {
[13:17:33.126]                           name <- restart$name
[13:17:33.126]                           if (is.null(name)) 
[13:17:33.126]                             next
[13:17:33.126]                           if (!grepl(pattern, name)) 
[13:17:33.126]                             next
[13:17:33.126]                           invokeRestart(restart)
[13:17:33.126]                           muffled <- TRUE
[13:17:33.126]                           break
[13:17:33.126]                         }
[13:17:33.126]                       }
[13:17:33.126]                     }
[13:17:33.126]                     invisible(muffled)
[13:17:33.126]                   }
[13:17:33.126]                   muffleCondition(cond)
[13:17:33.126]                 })
[13:17:33.126]             }))
[13:17:33.126]             future::FutureResult(value = ...future.value$value, 
[13:17:33.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.126]                   ...future.rng), globalenv = if (FALSE) 
[13:17:33.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:33.126]                     ...future.globalenv.names))
[13:17:33.126]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:33.126]         }, condition = base::local({
[13:17:33.126]             c <- base::c
[13:17:33.126]             inherits <- base::inherits
[13:17:33.126]             invokeRestart <- base::invokeRestart
[13:17:33.126]             length <- base::length
[13:17:33.126]             list <- base::list
[13:17:33.126]             seq.int <- base::seq.int
[13:17:33.126]             signalCondition <- base::signalCondition
[13:17:33.126]             sys.calls <- base::sys.calls
[13:17:33.126]             `[[` <- base::`[[`
[13:17:33.126]             `+` <- base::`+`
[13:17:33.126]             `<<-` <- base::`<<-`
[13:17:33.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:33.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:33.126]                   3L)]
[13:17:33.126]             }
[13:17:33.126]             function(cond) {
[13:17:33.126]                 is_error <- inherits(cond, "error")
[13:17:33.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:33.126]                   NULL)
[13:17:33.126]                 if (is_error) {
[13:17:33.126]                   sessionInformation <- function() {
[13:17:33.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:33.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:33.126]                       search = base::search(), system = base::Sys.info())
[13:17:33.126]                   }
[13:17:33.126]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:33.126]                     cond$call), session = sessionInformation(), 
[13:17:33.126]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:33.126]                   signalCondition(cond)
[13:17:33.126]                 }
[13:17:33.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:33.126]                 "immediateCondition"))) {
[13:17:33.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:33.126]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:33.126]                   if (TRUE && !signal) {
[13:17:33.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.126]                     {
[13:17:33.126]                       inherits <- base::inherits
[13:17:33.126]                       invokeRestart <- base::invokeRestart
[13:17:33.126]                       is.null <- base::is.null
[13:17:33.126]                       muffled <- FALSE
[13:17:33.126]                       if (inherits(cond, "message")) {
[13:17:33.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.126]                         if (muffled) 
[13:17:33.126]                           invokeRestart("muffleMessage")
[13:17:33.126]                       }
[13:17:33.126]                       else if (inherits(cond, "warning")) {
[13:17:33.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.126]                         if (muffled) 
[13:17:33.126]                           invokeRestart("muffleWarning")
[13:17:33.126]                       }
[13:17:33.126]                       else if (inherits(cond, "condition")) {
[13:17:33.126]                         if (!is.null(pattern)) {
[13:17:33.126]                           computeRestarts <- base::computeRestarts
[13:17:33.126]                           grepl <- base::grepl
[13:17:33.126]                           restarts <- computeRestarts(cond)
[13:17:33.126]                           for (restart in restarts) {
[13:17:33.126]                             name <- restart$name
[13:17:33.126]                             if (is.null(name)) 
[13:17:33.126]                               next
[13:17:33.126]                             if (!grepl(pattern, name)) 
[13:17:33.126]                               next
[13:17:33.126]                             invokeRestart(restart)
[13:17:33.126]                             muffled <- TRUE
[13:17:33.126]                             break
[13:17:33.126]                           }
[13:17:33.126]                         }
[13:17:33.126]                       }
[13:17:33.126]                       invisible(muffled)
[13:17:33.126]                     }
[13:17:33.126]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.126]                   }
[13:17:33.126]                 }
[13:17:33.126]                 else {
[13:17:33.126]                   if (TRUE) {
[13:17:33.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.126]                     {
[13:17:33.126]                       inherits <- base::inherits
[13:17:33.126]                       invokeRestart <- base::invokeRestart
[13:17:33.126]                       is.null <- base::is.null
[13:17:33.126]                       muffled <- FALSE
[13:17:33.126]                       if (inherits(cond, "message")) {
[13:17:33.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.126]                         if (muffled) 
[13:17:33.126]                           invokeRestart("muffleMessage")
[13:17:33.126]                       }
[13:17:33.126]                       else if (inherits(cond, "warning")) {
[13:17:33.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.126]                         if (muffled) 
[13:17:33.126]                           invokeRestart("muffleWarning")
[13:17:33.126]                       }
[13:17:33.126]                       else if (inherits(cond, "condition")) {
[13:17:33.126]                         if (!is.null(pattern)) {
[13:17:33.126]                           computeRestarts <- base::computeRestarts
[13:17:33.126]                           grepl <- base::grepl
[13:17:33.126]                           restarts <- computeRestarts(cond)
[13:17:33.126]                           for (restart in restarts) {
[13:17:33.126]                             name <- restart$name
[13:17:33.126]                             if (is.null(name)) 
[13:17:33.126]                               next
[13:17:33.126]                             if (!grepl(pattern, name)) 
[13:17:33.126]                               next
[13:17:33.126]                             invokeRestart(restart)
[13:17:33.126]                             muffled <- TRUE
[13:17:33.126]                             break
[13:17:33.126]                           }
[13:17:33.126]                         }
[13:17:33.126]                       }
[13:17:33.126]                       invisible(muffled)
[13:17:33.126]                     }
[13:17:33.126]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.126]                   }
[13:17:33.126]                 }
[13:17:33.126]             }
[13:17:33.126]         }))
[13:17:33.126]     }, error = function(ex) {
[13:17:33.126]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:33.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.126]                 ...future.rng), started = ...future.startTime, 
[13:17:33.126]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:33.126]             version = "1.8"), class = "FutureResult")
[13:17:33.126]     }, finally = {
[13:17:33.126]         if (!identical(...future.workdir, getwd())) 
[13:17:33.126]             setwd(...future.workdir)
[13:17:33.126]         {
[13:17:33.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:33.126]                 ...future.oldOptions$nwarnings <- NULL
[13:17:33.126]             }
[13:17:33.126]             base::options(...future.oldOptions)
[13:17:33.126]             if (.Platform$OS.type == "windows") {
[13:17:33.126]                 old_names <- names(...future.oldEnvVars)
[13:17:33.126]                 envs <- base::Sys.getenv()
[13:17:33.126]                 names <- names(envs)
[13:17:33.126]                 common <- intersect(names, old_names)
[13:17:33.126]                 added <- setdiff(names, old_names)
[13:17:33.126]                 removed <- setdiff(old_names, names)
[13:17:33.126]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:33.126]                   envs[common]]
[13:17:33.126]                 NAMES <- toupper(changed)
[13:17:33.126]                 args <- list()
[13:17:33.126]                 for (kk in seq_along(NAMES)) {
[13:17:33.126]                   name <- changed[[kk]]
[13:17:33.126]                   NAME <- NAMES[[kk]]
[13:17:33.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.126]                     next
[13:17:33.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.126]                 }
[13:17:33.126]                 NAMES <- toupper(added)
[13:17:33.126]                 for (kk in seq_along(NAMES)) {
[13:17:33.126]                   name <- added[[kk]]
[13:17:33.126]                   NAME <- NAMES[[kk]]
[13:17:33.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.126]                     next
[13:17:33.126]                   args[[name]] <- ""
[13:17:33.126]                 }
[13:17:33.126]                 NAMES <- toupper(removed)
[13:17:33.126]                 for (kk in seq_along(NAMES)) {
[13:17:33.126]                   name <- removed[[kk]]
[13:17:33.126]                   NAME <- NAMES[[kk]]
[13:17:33.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.126]                     next
[13:17:33.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.126]                 }
[13:17:33.126]                 if (length(args) > 0) 
[13:17:33.126]                   base::do.call(base::Sys.setenv, args = args)
[13:17:33.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:33.126]             }
[13:17:33.126]             else {
[13:17:33.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:33.126]             }
[13:17:33.126]             {
[13:17:33.126]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:33.126]                   0L) {
[13:17:33.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:33.126]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:33.126]                   base::options(opts)
[13:17:33.126]                 }
[13:17:33.126]                 {
[13:17:33.126]                   {
[13:17:33.126]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:33.126]                     NULL
[13:17:33.126]                   }
[13:17:33.126]                   options(future.plan = NULL)
[13:17:33.126]                   if (is.na(NA_character_)) 
[13:17:33.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:33.126]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:33.126]                     envir = parent.frame()) 
[13:17:33.126]                   {
[13:17:33.126]                     default_workers <- missing(workers)
[13:17:33.126]                     if (is.function(workers)) 
[13:17:33.126]                       workers <- workers()
[13:17:33.126]                     workers <- structure(as.integer(workers), 
[13:17:33.126]                       class = class(workers))
[13:17:33.126]                     stop_if_not(is.finite(workers), workers >= 
[13:17:33.126]                       1L)
[13:17:33.126]                     if ((workers == 1L && !inherits(workers, 
[13:17:33.126]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:33.126]                       if (default_workers) 
[13:17:33.126]                         supportsMulticore(warn = TRUE)
[13:17:33.126]                       return(sequential(..., envir = envir))
[13:17:33.126]                     }
[13:17:33.126]                     oopts <- options(mc.cores = workers)
[13:17:33.126]                     on.exit(options(oopts))
[13:17:33.126]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:33.126]                       envir = envir)
[13:17:33.126]                     if (!future$lazy) 
[13:17:33.126]                       future <- run(future)
[13:17:33.126]                     invisible(future)
[13:17:33.126]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:33.126]                 }
[13:17:33.126]             }
[13:17:33.126]         }
[13:17:33.126]     })
[13:17:33.126]     if (TRUE) {
[13:17:33.126]         base::sink(type = "output", split = FALSE)
[13:17:33.126]         if (TRUE) {
[13:17:33.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:33.126]         }
[13:17:33.126]         else {
[13:17:33.126]             ...future.result["stdout"] <- base::list(NULL)
[13:17:33.126]         }
[13:17:33.126]         base::close(...future.stdout)
[13:17:33.126]         ...future.stdout <- NULL
[13:17:33.126]     }
[13:17:33.126]     ...future.result$conditions <- ...future.conditions
[13:17:33.126]     ...future.result$finished <- base::Sys.time()
[13:17:33.126]     ...future.result
[13:17:33.126] }
[13:17:33.129] assign_globals() ...
[13:17:33.129] List of 5
[13:17:33.129]  $ ...future.FUN            :function (x, ...)  
[13:17:33.129]  $ future.call.arguments    : list()
[13:17:33.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.129]  $ ...future.elements_ii    :List of 2
[13:17:33.129]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:17:33.129]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:17:33.129]  $ ...future.seeds_ii       : NULL
[13:17:33.129]  $ ...future.globals.maxSize: NULL
[13:17:33.129]  - attr(*, "resolved")= logi FALSE
[13:17:33.129]  - attr(*, "total_size")= num 1248
[13:17:33.129]  - attr(*, "where")=List of 5
[13:17:33.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:33.129]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:33.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:33.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:33.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:33.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.129]  - attr(*, "already-done")= logi TRUE
[13:17:33.141] - copied ‘...future.FUN’ to environment
[13:17:33.142] - copied ‘future.call.arguments’ to environment
[13:17:33.142] - copied ‘...future.elements_ii’ to environment
[13:17:33.142] - copied ‘...future.seeds_ii’ to environment
[13:17:33.142] - copied ‘...future.globals.maxSize’ to environment
[13:17:33.142] assign_globals() ... done
[13:17:33.142] requestCore(): workers = 2
[13:17:33.144] MulticoreFuture started
[13:17:33.145] - Launch lazy future ... done
[13:17:33.145] run() for ‘MulticoreFuture’ ... done
[13:17:33.145] Created future:
[13:17:33.146] plan(): Setting new future strategy stack:
[13:17:33.146] List of future strategies:
[13:17:33.146] 1. sequential:
[13:17:33.146]    - args: function (..., envir = parent.frame())
[13:17:33.146]    - tweaked: FALSE
[13:17:33.146]    - call: NULL
[13:17:33.147] plan(): nbrOfWorkers() = 1
[13:17:33.150] plan(): Setting new future strategy stack:
[13:17:33.150] List of future strategies:
[13:17:33.150] 1. multicore:
[13:17:33.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:33.150]    - tweaked: FALSE
[13:17:33.150]    - call: plan(strategy)
[13:17:33.156] plan(): nbrOfWorkers() = 2
[13:17:33.146] MulticoreFuture:
[13:17:33.146] Label: ‘future_eapply-2’
[13:17:33.146] Expression:
[13:17:33.146] {
[13:17:33.146]     do.call(function(...) {
[13:17:33.146]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.146]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.146]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.146]             on.exit(options(oopts), add = TRUE)
[13:17:33.146]         }
[13:17:33.146]         {
[13:17:33.146]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.146]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.146]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.146]             })
[13:17:33.146]         }
[13:17:33.146]     }, args = future.call.arguments)
[13:17:33.146] }
[13:17:33.146] Lazy evaluation: FALSE
[13:17:33.146] Asynchronous evaluation: TRUE
[13:17:33.146] Local evaluation: TRUE
[13:17:33.146] Environment: R_GlobalEnv
[13:17:33.146] Capture standard output: TRUE
[13:17:33.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:33.146] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:33.146] Packages: 1 packages (‘stats’)
[13:17:33.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:33.146] Resolved: TRUE
[13:17:33.146] Value: <not collected>
[13:17:33.146] Conditions captured: <none>
[13:17:33.146] Early signaling: FALSE
[13:17:33.146] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:33.146] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.157] Chunk #2 of 2 ... DONE
[13:17:33.157] Launching 2 futures (chunks) ... DONE
[13:17:33.157] Resolving 2 futures (chunks) ...
[13:17:33.157] resolve() on list ...
[13:17:33.157]  recursive: 0
[13:17:33.158]  length: 2
[13:17:33.158] 
[13:17:33.158] Future #1
[13:17:33.159] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:33.159] - nx: 2
[13:17:33.160] - relay: TRUE
[13:17:33.160] - stdout: TRUE
[13:17:33.160] - signal: TRUE
[13:17:33.160] - resignal: FALSE
[13:17:33.160] - force: TRUE
[13:17:33.160] - relayed: [n=2] FALSE, FALSE
[13:17:33.160] - queued futures: [n=2] FALSE, FALSE
[13:17:33.161]  - until=1
[13:17:33.161]  - relaying element #1
[13:17:33.161] - relayed: [n=2] TRUE, FALSE
[13:17:33.161] - queued futures: [n=2] TRUE, FALSE
[13:17:33.161] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:33.161]  length: 1 (resolved future 1)
[13:17:33.162] Future #2
[13:17:33.163] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:33.163] - nx: 2
[13:17:33.163] - relay: TRUE
[13:17:33.163] - stdout: TRUE
[13:17:33.163] - signal: TRUE
[13:17:33.163] - resignal: FALSE
[13:17:33.164] - force: TRUE
[13:17:33.164] - relayed: [n=2] TRUE, FALSE
[13:17:33.164] - queued futures: [n=2] TRUE, FALSE
[13:17:33.164]  - until=2
[13:17:33.164]  - relaying element #2
[13:17:33.164] - relayed: [n=2] TRUE, TRUE
[13:17:33.164] - queued futures: [n=2] TRUE, TRUE
[13:17:33.165] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:33.165]  length: 0 (resolved future 2)
[13:17:33.165] Relaying remaining futures
[13:17:33.165] signalConditionsASAP(NULL, pos=0) ...
[13:17:33.165] - nx: 2
[13:17:33.165] - relay: TRUE
[13:17:33.165] - stdout: TRUE
[13:17:33.165] - signal: TRUE
[13:17:33.165] - resignal: FALSE
[13:17:33.166] - force: TRUE
[13:17:33.166] - relayed: [n=2] TRUE, TRUE
[13:17:33.166] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:33.166] - relayed: [n=2] TRUE, TRUE
[13:17:33.166] - queued futures: [n=2] TRUE, TRUE
[13:17:33.166] signalConditionsASAP(NULL, pos=0) ... done
[13:17:33.166] resolve() on list ... DONE
[13:17:33.166]  - Number of value chunks collected: 2
[13:17:33.167] Resolving 2 futures (chunks) ... DONE
[13:17:33.167] Reducing values from 2 chunks ...
[13:17:33.167]  - Number of values collected after concatenation: 3
[13:17:33.167]  - Number of values expected: 3
[13:17:33.167] Reducing values from 2 chunks ... DONE
[13:17:33.167] future_lapply() ... DONE
[13:17:33.168] plan(): Setting new future strategy stack:
[13:17:33.168] List of future strategies:
[13:17:33.168] 1. sequential:
[13:17:33.168]    - args: function (..., envir = parent.frame())
[13:17:33.168]    - tweaked: FALSE
[13:17:33.168]    - call: plan(sequential)
[13:17:33.168] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:17:33.169] plan(): Setting new future strategy stack:
[13:17:33.169] List of future strategies:
[13:17:33.169] 1. multisession:
[13:17:33.169]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:33.169]    - tweaked: FALSE
[13:17:33.169]    - call: plan(strategy)
[13:17:33.169] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:17:33.170] multisession:
[13:17:33.170] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:33.170] - tweaked: FALSE
[13:17:33.170] - call: plan(strategy)
[13:17:33.176] getGlobalsAndPackages() ...
[13:17:33.176] Not searching for globals
[13:17:33.176] - globals: [0] <none>
[13:17:33.177] getGlobalsAndPackages() ... DONE
[13:17:33.177] [local output] makeClusterPSOCK() ...
[13:17:33.219] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:17:33.225] [local output] Base port: 11844
[13:17:33.225] [local output] Getting setup options for 2 cluster nodes ...
[13:17:33.225] [local output]  - Node 1 of 2 ...
[13:17:33.225] [local output] localMachine=TRUE => revtunnel=FALSE

[13:17:33.226] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8oNlRe/worker.rank=1.parallelly.parent=70698.1142a198cda26.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp8oNlRe/worker.rank=1.parallelly.parent=70698.1142a198cda26.pid")'’
[13:17:33.417] - Possible to infer worker's PID: TRUE
[13:17:33.417] [local output] Rscript port: 11844

[13:17:33.418] [local output]  - Node 2 of 2 ...
[13:17:33.418] [local output] localMachine=TRUE => revtunnel=FALSE

[13:17:33.419] [local output] Rscript port: 11844

[13:17:33.419] [local output] Getting setup options for 2 cluster nodes ... done
[13:17:33.419] [local output]  - Parallel setup requested for some PSOCK nodes
[13:17:33.420] [local output] Setting up PSOCK nodes in parallel
[13:17:33.420] List of 36
[13:17:33.420]  $ worker          : chr "localhost"
[13:17:33.420]   ..- attr(*, "localhost")= logi TRUE
[13:17:33.420]  $ master          : chr "localhost"
[13:17:33.420]  $ port            : int 11844
[13:17:33.420]  $ connectTimeout  : num 120
[13:17:33.420]  $ timeout         : num 2592000
[13:17:33.420]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:17:33.420]  $ homogeneous     : logi TRUE
[13:17:33.420]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:17:33.420]  $ rscript_envs    : NULL
[13:17:33.420]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:17:33.420]  $ rscript_startup : NULL
[13:17:33.420]  $ rscript_sh      : chr "sh"
[13:17:33.420]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:17:33.420]  $ methods         : logi TRUE
[13:17:33.420]  $ socketOptions   : chr "no-delay"
[13:17:33.420]  $ useXDR          : logi FALSE
[13:17:33.420]  $ outfile         : chr "/dev/null"
[13:17:33.420]  $ renice          : int NA
[13:17:33.420]  $ rshcmd          : NULL
[13:17:33.420]  $ user            : chr(0) 
[13:17:33.420]  $ revtunnel       : logi FALSE
[13:17:33.420]  $ rshlogfile      : NULL
[13:17:33.420]  $ rshopts         : chr(0) 
[13:17:33.420]  $ rank            : int 1
[13:17:33.420]  $ manual          : logi FALSE
[13:17:33.420]  $ dryrun          : logi FALSE
[13:17:33.420]  $ quiet           : logi FALSE
[13:17:33.420]  $ setup_strategy  : chr "parallel"
[13:17:33.420]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:17:33.420]  $ pidfile         : chr "/tmp/Rtmp8oNlRe/worker.rank=1.parallelly.parent=70698.1142a198cda26.pid"
[13:17:33.420]  $ rshcmd_label    : NULL
[13:17:33.420]  $ rsh_call        : NULL
[13:17:33.420]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:17:33.420]  $ localMachine    : logi TRUE
[13:17:33.420]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:17:33.420]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:17:33.420]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:17:33.420]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:17:33.420]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:17:33.420]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:17:33.420]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:17:33.420]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:17:33.420]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:17:33.420]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:17:33.420]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:17:33.420]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:17:33.420]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:17:33.420]  $ arguments       :List of 28
[13:17:33.420]   ..$ worker          : chr "localhost"
[13:17:33.420]   ..$ master          : NULL
[13:17:33.420]   ..$ port            : int 11844
[13:17:33.420]   ..$ connectTimeout  : num 120
[13:17:33.420]   ..$ timeout         : num 2592000
[13:17:33.420]   ..$ rscript         : NULL
[13:17:33.420]   ..$ homogeneous     : NULL
[13:17:33.420]   ..$ rscript_args    : NULL
[13:17:33.420]   ..$ rscript_envs    : NULL
[13:17:33.420]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:17:33.420]   ..$ rscript_startup : NULL
[13:17:33.420]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:17:33.420]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:17:33.420]   ..$ methods         : logi TRUE
[13:17:33.420]   ..$ socketOptions   : chr "no-delay"
[13:17:33.420]   ..$ useXDR          : logi FALSE
[13:17:33.420]   ..$ outfile         : chr "/dev/null"
[13:17:33.420]   ..$ renice          : int NA
[13:17:33.420]   ..$ rshcmd          : NULL
[13:17:33.420]   ..$ user            : NULL
[13:17:33.420]   ..$ revtunnel       : logi NA
[13:17:33.420]   ..$ rshlogfile      : NULL
[13:17:33.420]   ..$ rshopts         : NULL
[13:17:33.420]   ..$ rank            : int 1
[13:17:33.420]   ..$ manual          : logi FALSE
[13:17:33.420]   ..$ dryrun          : logi FALSE
[13:17:33.420]   ..$ quiet           : logi FALSE
[13:17:33.420]   ..$ setup_strategy  : chr "parallel"
[13:17:33.420]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:17:33.438] [local output] System call to launch all workers:
[13:17:33.438] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8oNlRe/worker.rank=1.parallelly.parent=70698.1142a198cda26.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11844 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:17:33.438] [local output] Starting PSOCK main server
[13:17:33.439] [local output] Workers launched
[13:17:33.439] [local output] Waiting for workers to connect back
[13:17:33.440]  - [local output] 0 workers out of 2 ready
[13:17:33.686]  - [local output] 0 workers out of 2 ready
[13:17:33.687]  - [local output] 1 workers out of 2 ready
[13:17:33.687]  - [local output] 2 workers out of 2 ready
[13:17:33.687] [local output] Launching of workers completed
[13:17:33.687] [local output] Collecting session information from workers
[13:17:33.688] [local output]  - Worker #1 of 2
[13:17:33.689] [local output]  - Worker #2 of 2
[13:17:33.689] [local output] makeClusterPSOCK() ... done
[13:17:33.701] Packages needed by the future expression (n = 0): <none>
[13:17:33.701] Packages needed by future strategies (n = 0): <none>
[13:17:33.702] {
[13:17:33.702]     {
[13:17:33.702]         {
[13:17:33.702]             ...future.startTime <- base::Sys.time()
[13:17:33.702]             {
[13:17:33.702]                 {
[13:17:33.702]                   {
[13:17:33.702]                     {
[13:17:33.702]                       base::local({
[13:17:33.702]                         has_future <- base::requireNamespace("future", 
[13:17:33.702]                           quietly = TRUE)
[13:17:33.702]                         if (has_future) {
[13:17:33.702]                           ns <- base::getNamespace("future")
[13:17:33.702]                           version <- ns[[".package"]][["version"]]
[13:17:33.702]                           if (is.null(version)) 
[13:17:33.702]                             version <- utils::packageVersion("future")
[13:17:33.702]                         }
[13:17:33.702]                         else {
[13:17:33.702]                           version <- NULL
[13:17:33.702]                         }
[13:17:33.702]                         if (!has_future || version < "1.8.0") {
[13:17:33.702]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:33.702]                             "", base::R.version$version.string), 
[13:17:33.702]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:33.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:33.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:33.702]                               "release", "version")], collapse = " "), 
[13:17:33.702]                             hostname = base::Sys.info()[["nodename"]])
[13:17:33.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:33.702]                             info)
[13:17:33.702]                           info <- base::paste(info, collapse = "; ")
[13:17:33.702]                           if (!has_future) {
[13:17:33.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:33.702]                               info)
[13:17:33.702]                           }
[13:17:33.702]                           else {
[13:17:33.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:33.702]                               info, version)
[13:17:33.702]                           }
[13:17:33.702]                           base::stop(msg)
[13:17:33.702]                         }
[13:17:33.702]                       })
[13:17:33.702]                     }
[13:17:33.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:33.702]                     base::options(mc.cores = 1L)
[13:17:33.702]                   }
[13:17:33.702]                   options(future.plan = NULL)
[13:17:33.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:33.702]                 }
[13:17:33.702]                 ...future.workdir <- getwd()
[13:17:33.702]             }
[13:17:33.702]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:33.702]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:33.702]         }
[13:17:33.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:33.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:33.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:33.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:33.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:33.702]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:33.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:33.702]             base::names(...future.oldOptions))
[13:17:33.702]     }
[13:17:33.702]     if (FALSE) {
[13:17:33.702]     }
[13:17:33.702]     else {
[13:17:33.702]         if (TRUE) {
[13:17:33.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:33.702]                 open = "w")
[13:17:33.702]         }
[13:17:33.702]         else {
[13:17:33.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:33.702]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:33.702]         }
[13:17:33.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:33.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:33.702]             base::sink(type = "output", split = FALSE)
[13:17:33.702]             base::close(...future.stdout)
[13:17:33.702]         }, add = TRUE)
[13:17:33.702]     }
[13:17:33.702]     ...future.frame <- base::sys.nframe()
[13:17:33.702]     ...future.conditions <- base::list()
[13:17:33.702]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:33.702]     if (FALSE) {
[13:17:33.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:33.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:33.702]     }
[13:17:33.702]     ...future.result <- base::tryCatch({
[13:17:33.702]         base::withCallingHandlers({
[13:17:33.702]             ...future.value <- base::withVisible(base::local({
[13:17:33.702]                 ...future.makeSendCondition <- local({
[13:17:33.702]                   sendCondition <- NULL
[13:17:33.702]                   function(frame = 1L) {
[13:17:33.702]                     if (is.function(sendCondition)) 
[13:17:33.702]                       return(sendCondition)
[13:17:33.702]                     ns <- getNamespace("parallel")
[13:17:33.702]                     if (exists("sendData", mode = "function", 
[13:17:33.702]                       envir = ns)) {
[13:17:33.702]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:33.702]                         envir = ns)
[13:17:33.702]                       envir <- sys.frame(frame)
[13:17:33.702]                       master <- NULL
[13:17:33.702]                       while (!identical(envir, .GlobalEnv) && 
[13:17:33.702]                         !identical(envir, emptyenv())) {
[13:17:33.702]                         if (exists("master", mode = "list", envir = envir, 
[13:17:33.702]                           inherits = FALSE)) {
[13:17:33.702]                           master <- get("master", mode = "list", 
[13:17:33.702]                             envir = envir, inherits = FALSE)
[13:17:33.702]                           if (inherits(master, c("SOCKnode", 
[13:17:33.702]                             "SOCK0node"))) {
[13:17:33.702]                             sendCondition <<- function(cond) {
[13:17:33.702]                               data <- list(type = "VALUE", value = cond, 
[13:17:33.702]                                 success = TRUE)
[13:17:33.702]                               parallel_sendData(master, data)
[13:17:33.702]                             }
[13:17:33.702]                             return(sendCondition)
[13:17:33.702]                           }
[13:17:33.702]                         }
[13:17:33.702]                         frame <- frame + 1L
[13:17:33.702]                         envir <- sys.frame(frame)
[13:17:33.702]                       }
[13:17:33.702]                     }
[13:17:33.702]                     sendCondition <<- function(cond) NULL
[13:17:33.702]                   }
[13:17:33.702]                 })
[13:17:33.702]                 withCallingHandlers({
[13:17:33.702]                   NA
[13:17:33.702]                 }, immediateCondition = function(cond) {
[13:17:33.702]                   sendCondition <- ...future.makeSendCondition()
[13:17:33.702]                   sendCondition(cond)
[13:17:33.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.702]                   {
[13:17:33.702]                     inherits <- base::inherits
[13:17:33.702]                     invokeRestart <- base::invokeRestart
[13:17:33.702]                     is.null <- base::is.null
[13:17:33.702]                     muffled <- FALSE
[13:17:33.702]                     if (inherits(cond, "message")) {
[13:17:33.702]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:33.702]                       if (muffled) 
[13:17:33.702]                         invokeRestart("muffleMessage")
[13:17:33.702]                     }
[13:17:33.702]                     else if (inherits(cond, "warning")) {
[13:17:33.702]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:33.702]                       if (muffled) 
[13:17:33.702]                         invokeRestart("muffleWarning")
[13:17:33.702]                     }
[13:17:33.702]                     else if (inherits(cond, "condition")) {
[13:17:33.702]                       if (!is.null(pattern)) {
[13:17:33.702]                         computeRestarts <- base::computeRestarts
[13:17:33.702]                         grepl <- base::grepl
[13:17:33.702]                         restarts <- computeRestarts(cond)
[13:17:33.702]                         for (restart in restarts) {
[13:17:33.702]                           name <- restart$name
[13:17:33.702]                           if (is.null(name)) 
[13:17:33.702]                             next
[13:17:33.702]                           if (!grepl(pattern, name)) 
[13:17:33.702]                             next
[13:17:33.702]                           invokeRestart(restart)
[13:17:33.702]                           muffled <- TRUE
[13:17:33.702]                           break
[13:17:33.702]                         }
[13:17:33.702]                       }
[13:17:33.702]                     }
[13:17:33.702]                     invisible(muffled)
[13:17:33.702]                   }
[13:17:33.702]                   muffleCondition(cond)
[13:17:33.702]                 })
[13:17:33.702]             }))
[13:17:33.702]             future::FutureResult(value = ...future.value$value, 
[13:17:33.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.702]                   ...future.rng), globalenv = if (FALSE) 
[13:17:33.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:33.702]                     ...future.globalenv.names))
[13:17:33.702]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:33.702]         }, condition = base::local({
[13:17:33.702]             c <- base::c
[13:17:33.702]             inherits <- base::inherits
[13:17:33.702]             invokeRestart <- base::invokeRestart
[13:17:33.702]             length <- base::length
[13:17:33.702]             list <- base::list
[13:17:33.702]             seq.int <- base::seq.int
[13:17:33.702]             signalCondition <- base::signalCondition
[13:17:33.702]             sys.calls <- base::sys.calls
[13:17:33.702]             `[[` <- base::`[[`
[13:17:33.702]             `+` <- base::`+`
[13:17:33.702]             `<<-` <- base::`<<-`
[13:17:33.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:33.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:33.702]                   3L)]
[13:17:33.702]             }
[13:17:33.702]             function(cond) {
[13:17:33.702]                 is_error <- inherits(cond, "error")
[13:17:33.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:33.702]                   NULL)
[13:17:33.702]                 if (is_error) {
[13:17:33.702]                   sessionInformation <- function() {
[13:17:33.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:33.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:33.702]                       search = base::search(), system = base::Sys.info())
[13:17:33.702]                   }
[13:17:33.702]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:33.702]                     cond$call), session = sessionInformation(), 
[13:17:33.702]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:33.702]                   signalCondition(cond)
[13:17:33.702]                 }
[13:17:33.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:33.702]                 "immediateCondition"))) {
[13:17:33.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:33.702]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:33.702]                   if (TRUE && !signal) {
[13:17:33.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.702]                     {
[13:17:33.702]                       inherits <- base::inherits
[13:17:33.702]                       invokeRestart <- base::invokeRestart
[13:17:33.702]                       is.null <- base::is.null
[13:17:33.702]                       muffled <- FALSE
[13:17:33.702]                       if (inherits(cond, "message")) {
[13:17:33.702]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.702]                         if (muffled) 
[13:17:33.702]                           invokeRestart("muffleMessage")
[13:17:33.702]                       }
[13:17:33.702]                       else if (inherits(cond, "warning")) {
[13:17:33.702]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.702]                         if (muffled) 
[13:17:33.702]                           invokeRestart("muffleWarning")
[13:17:33.702]                       }
[13:17:33.702]                       else if (inherits(cond, "condition")) {
[13:17:33.702]                         if (!is.null(pattern)) {
[13:17:33.702]                           computeRestarts <- base::computeRestarts
[13:17:33.702]                           grepl <- base::grepl
[13:17:33.702]                           restarts <- computeRestarts(cond)
[13:17:33.702]                           for (restart in restarts) {
[13:17:33.702]                             name <- restart$name
[13:17:33.702]                             if (is.null(name)) 
[13:17:33.702]                               next
[13:17:33.702]                             if (!grepl(pattern, name)) 
[13:17:33.702]                               next
[13:17:33.702]                             invokeRestart(restart)
[13:17:33.702]                             muffled <- TRUE
[13:17:33.702]                             break
[13:17:33.702]                           }
[13:17:33.702]                         }
[13:17:33.702]                       }
[13:17:33.702]                       invisible(muffled)
[13:17:33.702]                     }
[13:17:33.702]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.702]                   }
[13:17:33.702]                 }
[13:17:33.702]                 else {
[13:17:33.702]                   if (TRUE) {
[13:17:33.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.702]                     {
[13:17:33.702]                       inherits <- base::inherits
[13:17:33.702]                       invokeRestart <- base::invokeRestart
[13:17:33.702]                       is.null <- base::is.null
[13:17:33.702]                       muffled <- FALSE
[13:17:33.702]                       if (inherits(cond, "message")) {
[13:17:33.702]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.702]                         if (muffled) 
[13:17:33.702]                           invokeRestart("muffleMessage")
[13:17:33.702]                       }
[13:17:33.702]                       else if (inherits(cond, "warning")) {
[13:17:33.702]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.702]                         if (muffled) 
[13:17:33.702]                           invokeRestart("muffleWarning")
[13:17:33.702]                       }
[13:17:33.702]                       else if (inherits(cond, "condition")) {
[13:17:33.702]                         if (!is.null(pattern)) {
[13:17:33.702]                           computeRestarts <- base::computeRestarts
[13:17:33.702]                           grepl <- base::grepl
[13:17:33.702]                           restarts <- computeRestarts(cond)
[13:17:33.702]                           for (restart in restarts) {
[13:17:33.702]                             name <- restart$name
[13:17:33.702]                             if (is.null(name)) 
[13:17:33.702]                               next
[13:17:33.702]                             if (!grepl(pattern, name)) 
[13:17:33.702]                               next
[13:17:33.702]                             invokeRestart(restart)
[13:17:33.702]                             muffled <- TRUE
[13:17:33.702]                             break
[13:17:33.702]                           }
[13:17:33.702]                         }
[13:17:33.702]                       }
[13:17:33.702]                       invisible(muffled)
[13:17:33.702]                     }
[13:17:33.702]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.702]                   }
[13:17:33.702]                 }
[13:17:33.702]             }
[13:17:33.702]         }))
[13:17:33.702]     }, error = function(ex) {
[13:17:33.702]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:33.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.702]                 ...future.rng), started = ...future.startTime, 
[13:17:33.702]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:33.702]             version = "1.8"), class = "FutureResult")
[13:17:33.702]     }, finally = {
[13:17:33.702]         if (!identical(...future.workdir, getwd())) 
[13:17:33.702]             setwd(...future.workdir)
[13:17:33.702]         {
[13:17:33.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:33.702]                 ...future.oldOptions$nwarnings <- NULL
[13:17:33.702]             }
[13:17:33.702]             base::options(...future.oldOptions)
[13:17:33.702]             if (.Platform$OS.type == "windows") {
[13:17:33.702]                 old_names <- names(...future.oldEnvVars)
[13:17:33.702]                 envs <- base::Sys.getenv()
[13:17:33.702]                 names <- names(envs)
[13:17:33.702]                 common <- intersect(names, old_names)
[13:17:33.702]                 added <- setdiff(names, old_names)
[13:17:33.702]                 removed <- setdiff(old_names, names)
[13:17:33.702]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:33.702]                   envs[common]]
[13:17:33.702]                 NAMES <- toupper(changed)
[13:17:33.702]                 args <- list()
[13:17:33.702]                 for (kk in seq_along(NAMES)) {
[13:17:33.702]                   name <- changed[[kk]]
[13:17:33.702]                   NAME <- NAMES[[kk]]
[13:17:33.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.702]                     next
[13:17:33.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.702]                 }
[13:17:33.702]                 NAMES <- toupper(added)
[13:17:33.702]                 for (kk in seq_along(NAMES)) {
[13:17:33.702]                   name <- added[[kk]]
[13:17:33.702]                   NAME <- NAMES[[kk]]
[13:17:33.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.702]                     next
[13:17:33.702]                   args[[name]] <- ""
[13:17:33.702]                 }
[13:17:33.702]                 NAMES <- toupper(removed)
[13:17:33.702]                 for (kk in seq_along(NAMES)) {
[13:17:33.702]                   name <- removed[[kk]]
[13:17:33.702]                   NAME <- NAMES[[kk]]
[13:17:33.702]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.702]                     next
[13:17:33.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.702]                 }
[13:17:33.702]                 if (length(args) > 0) 
[13:17:33.702]                   base::do.call(base::Sys.setenv, args = args)
[13:17:33.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:33.702]             }
[13:17:33.702]             else {
[13:17:33.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:33.702]             }
[13:17:33.702]             {
[13:17:33.702]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:33.702]                   0L) {
[13:17:33.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:33.702]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:33.702]                   base::options(opts)
[13:17:33.702]                 }
[13:17:33.702]                 {
[13:17:33.702]                   {
[13:17:33.702]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:33.702]                     NULL
[13:17:33.702]                   }
[13:17:33.702]                   options(future.plan = NULL)
[13:17:33.702]                   if (is.na(NA_character_)) 
[13:17:33.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:33.702]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:33.702]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:33.702]                     envir = parent.frame()) 
[13:17:33.702]                   {
[13:17:33.702]                     if (is.function(workers)) 
[13:17:33.702]                       workers <- workers()
[13:17:33.702]                     workers <- structure(as.integer(workers), 
[13:17:33.702]                       class = class(workers))
[13:17:33.702]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:33.702]                       workers >= 1)
[13:17:33.702]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:33.702]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:33.702]                     }
[13:17:33.702]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:33.702]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:33.702]                       envir = envir)
[13:17:33.702]                     if (!future$lazy) 
[13:17:33.702]                       future <- run(future)
[13:17:33.702]                     invisible(future)
[13:17:33.702]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:33.702]                 }
[13:17:33.702]             }
[13:17:33.702]         }
[13:17:33.702]     })
[13:17:33.702]     if (TRUE) {
[13:17:33.702]         base::sink(type = "output", split = FALSE)
[13:17:33.702]         if (TRUE) {
[13:17:33.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:33.702]         }
[13:17:33.702]         else {
[13:17:33.702]             ...future.result["stdout"] <- base::list(NULL)
[13:17:33.702]         }
[13:17:33.702]         base::close(...future.stdout)
[13:17:33.702]         ...future.stdout <- NULL
[13:17:33.702]     }
[13:17:33.702]     ...future.result$conditions <- ...future.conditions
[13:17:33.702]     ...future.result$finished <- base::Sys.time()
[13:17:33.702]     ...future.result
[13:17:33.702] }
[13:17:33.775] MultisessionFuture started
[13:17:33.776] result() for ClusterFuture ...
[13:17:33.776] receiveMessageFromWorker() for ClusterFuture ...
[13:17:33.777] - Validating connection of MultisessionFuture
[13:17:33.809] - received message: FutureResult
[13:17:33.809] - Received FutureResult
[13:17:33.809] - Erased future from FutureRegistry
[13:17:33.809] result() for ClusterFuture ...
[13:17:33.809] - result already collected: FutureResult
[13:17:33.810] result() for ClusterFuture ... done
[13:17:33.810] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:33.810] result() for ClusterFuture ... done
[13:17:33.810] result() for ClusterFuture ...
[13:17:33.810] - result already collected: FutureResult
[13:17:33.810] result() for ClusterFuture ... done
[13:17:33.810] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:17:33.814] plan(): nbrOfWorkers() = 2
[13:17:33.814] future_lapply() ...
[13:17:33.819] Number of chunks: 2
[13:17:33.819] getGlobalsAndPackagesXApply() ...
[13:17:33.819]  - future.globals: TRUE
[13:17:33.819] getGlobalsAndPackages() ...
[13:17:33.819] Searching for globals...
[13:17:33.820] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:33.821] Searching for globals ... DONE
[13:17:33.821] Resolving globals: FALSE
[13:17:33.821] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:17:33.822] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:17:33.822] - globals: [1] ‘FUN’
[13:17:33.822] 
[13:17:33.822] getGlobalsAndPackages() ... DONE
[13:17:33.822]  - globals found/used: [n=1] ‘FUN’
[13:17:33.822]  - needed namespaces: [n=0] 
[13:17:33.822] Finding globals ... DONE
[13:17:33.822]  - use_args: TRUE
[13:17:33.823]  - Getting '...' globals ...
[13:17:33.823] resolve() on list ...
[13:17:33.823]  recursive: 0
[13:17:33.823]  length: 1
[13:17:33.823]  elements: ‘...’
[13:17:33.823]  length: 0 (resolved future 1)
[13:17:33.824] resolve() on list ... DONE
[13:17:33.824]    - '...' content: [n=0] 
[13:17:33.824] List of 1
[13:17:33.824]  $ ...: list()
[13:17:33.824]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.824]  - attr(*, "where")=List of 1
[13:17:33.824]   ..$ ...:<environment: 0x55be3eef2a78> 
[13:17:33.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.824]  - attr(*, "resolved")= logi TRUE
[13:17:33.824]  - attr(*, "total_size")= num NA
[13:17:33.827]  - Getting '...' globals ... DONE
[13:17:33.827] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:33.827] List of 2
[13:17:33.827]  $ ...future.FUN:function (x, ...)  
[13:17:33.827]  $ ...          : list()
[13:17:33.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:33.827]  - attr(*, "where")=List of 2
[13:17:33.827]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:33.827]   ..$ ...          :<environment: 0x55be3eef2a78> 
[13:17:33.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:33.827]  - attr(*, "resolved")= logi FALSE
[13:17:33.827]  - attr(*, "total_size")= num 1240
[13:17:33.831] Packages to be attached in all futures: [n=0] 
[13:17:33.831] getGlobalsAndPackagesXApply() ... DONE
[13:17:33.831] Number of futures (= number of chunks): 2
[13:17:33.831] Launching 2 futures (chunks) ...
[13:17:33.831] Chunk #1 of 2 ...
[13:17:33.832]  - Finding globals in 'X' for chunk #1 ...
[13:17:33.832] getGlobalsAndPackages() ...
[13:17:33.832] Searching for globals...
[13:17:33.832] 
[13:17:33.832] Searching for globals ... DONE
[13:17:33.832] - globals: [0] <none>
[13:17:33.832] getGlobalsAndPackages() ... DONE
[13:17:33.832]    + additional globals found: [n=0] 
[13:17:33.833]    + additional namespaces needed: [n=0] 
[13:17:33.833]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:33.833]  - seeds: <none>
[13:17:33.833] getGlobalsAndPackages() ...
[13:17:33.833] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.833] Resolving globals: FALSE
[13:17:33.833] Tweak future expression to call with '...' arguments ...
[13:17:33.833] {
[13:17:33.833]     do.call(function(...) {
[13:17:33.833]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.833]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.833]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.833]             on.exit(options(oopts), add = TRUE)
[13:17:33.833]         }
[13:17:33.833]         {
[13:17:33.833]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.833]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.833]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.833]             })
[13:17:33.833]         }
[13:17:33.833]     }, args = future.call.arguments)
[13:17:33.833] }
[13:17:33.834] Tweak future expression to call with '...' arguments ... DONE
[13:17:33.834] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.834] 
[13:17:33.834] getGlobalsAndPackages() ... DONE
[13:17:33.835] run() for ‘Future’ ...
[13:17:33.835] - state: ‘created’
[13:17:33.835] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:33.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:33.851]   - Field: ‘node’
[13:17:33.851]   - Field: ‘label’
[13:17:33.851]   - Field: ‘local’
[13:17:33.851]   - Field: ‘owner’
[13:17:33.851]   - Field: ‘envir’
[13:17:33.851]   - Field: ‘workers’
[13:17:33.851]   - Field: ‘packages’
[13:17:33.851]   - Field: ‘gc’
[13:17:33.851]   - Field: ‘conditions’
[13:17:33.851]   - Field: ‘persistent’
[13:17:33.852]   - Field: ‘expr’
[13:17:33.852]   - Field: ‘uuid’
[13:17:33.852]   - Field: ‘seed’
[13:17:33.852]   - Field: ‘version’
[13:17:33.852]   - Field: ‘result’
[13:17:33.852]   - Field: ‘asynchronous’
[13:17:33.852]   - Field: ‘calls’
[13:17:33.852]   - Field: ‘globals’
[13:17:33.852]   - Field: ‘stdout’
[13:17:33.853]   - Field: ‘earlySignal’
[13:17:33.853]   - Field: ‘lazy’
[13:17:33.853]   - Field: ‘state’
[13:17:33.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:33.853] - Launch lazy future ...
[13:17:33.853] Packages needed by the future expression (n = 0): <none>
[13:17:33.854] Packages needed by future strategies (n = 0): <none>
[13:17:33.854] {
[13:17:33.854]     {
[13:17:33.854]         {
[13:17:33.854]             ...future.startTime <- base::Sys.time()
[13:17:33.854]             {
[13:17:33.854]                 {
[13:17:33.854]                   {
[13:17:33.854]                     {
[13:17:33.854]                       base::local({
[13:17:33.854]                         has_future <- base::requireNamespace("future", 
[13:17:33.854]                           quietly = TRUE)
[13:17:33.854]                         if (has_future) {
[13:17:33.854]                           ns <- base::getNamespace("future")
[13:17:33.854]                           version <- ns[[".package"]][["version"]]
[13:17:33.854]                           if (is.null(version)) 
[13:17:33.854]                             version <- utils::packageVersion("future")
[13:17:33.854]                         }
[13:17:33.854]                         else {
[13:17:33.854]                           version <- NULL
[13:17:33.854]                         }
[13:17:33.854]                         if (!has_future || version < "1.8.0") {
[13:17:33.854]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:33.854]                             "", base::R.version$version.string), 
[13:17:33.854]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:33.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:33.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:33.854]                               "release", "version")], collapse = " "), 
[13:17:33.854]                             hostname = base::Sys.info()[["nodename"]])
[13:17:33.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:33.854]                             info)
[13:17:33.854]                           info <- base::paste(info, collapse = "; ")
[13:17:33.854]                           if (!has_future) {
[13:17:33.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:33.854]                               info)
[13:17:33.854]                           }
[13:17:33.854]                           else {
[13:17:33.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:33.854]                               info, version)
[13:17:33.854]                           }
[13:17:33.854]                           base::stop(msg)
[13:17:33.854]                         }
[13:17:33.854]                       })
[13:17:33.854]                     }
[13:17:33.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:33.854]                     base::options(mc.cores = 1L)
[13:17:33.854]                   }
[13:17:33.854]                   options(future.plan = NULL)
[13:17:33.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:33.854]                 }
[13:17:33.854]                 ...future.workdir <- getwd()
[13:17:33.854]             }
[13:17:33.854]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:33.854]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:33.854]         }
[13:17:33.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:33.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:33.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:33.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:33.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:33.854]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:33.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:33.854]             base::names(...future.oldOptions))
[13:17:33.854]     }
[13:17:33.854]     if (FALSE) {
[13:17:33.854]     }
[13:17:33.854]     else {
[13:17:33.854]         if (TRUE) {
[13:17:33.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:33.854]                 open = "w")
[13:17:33.854]         }
[13:17:33.854]         else {
[13:17:33.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:33.854]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:33.854]         }
[13:17:33.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:33.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:33.854]             base::sink(type = "output", split = FALSE)
[13:17:33.854]             base::close(...future.stdout)
[13:17:33.854]         }, add = TRUE)
[13:17:33.854]     }
[13:17:33.854]     ...future.frame <- base::sys.nframe()
[13:17:33.854]     ...future.conditions <- base::list()
[13:17:33.854]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:33.854]     if (FALSE) {
[13:17:33.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:33.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:33.854]     }
[13:17:33.854]     ...future.result <- base::tryCatch({
[13:17:33.854]         base::withCallingHandlers({
[13:17:33.854]             ...future.value <- base::withVisible(base::local({
[13:17:33.854]                 ...future.makeSendCondition <- local({
[13:17:33.854]                   sendCondition <- NULL
[13:17:33.854]                   function(frame = 1L) {
[13:17:33.854]                     if (is.function(sendCondition)) 
[13:17:33.854]                       return(sendCondition)
[13:17:33.854]                     ns <- getNamespace("parallel")
[13:17:33.854]                     if (exists("sendData", mode = "function", 
[13:17:33.854]                       envir = ns)) {
[13:17:33.854]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:33.854]                         envir = ns)
[13:17:33.854]                       envir <- sys.frame(frame)
[13:17:33.854]                       master <- NULL
[13:17:33.854]                       while (!identical(envir, .GlobalEnv) && 
[13:17:33.854]                         !identical(envir, emptyenv())) {
[13:17:33.854]                         if (exists("master", mode = "list", envir = envir, 
[13:17:33.854]                           inherits = FALSE)) {
[13:17:33.854]                           master <- get("master", mode = "list", 
[13:17:33.854]                             envir = envir, inherits = FALSE)
[13:17:33.854]                           if (inherits(master, c("SOCKnode", 
[13:17:33.854]                             "SOCK0node"))) {
[13:17:33.854]                             sendCondition <<- function(cond) {
[13:17:33.854]                               data <- list(type = "VALUE", value = cond, 
[13:17:33.854]                                 success = TRUE)
[13:17:33.854]                               parallel_sendData(master, data)
[13:17:33.854]                             }
[13:17:33.854]                             return(sendCondition)
[13:17:33.854]                           }
[13:17:33.854]                         }
[13:17:33.854]                         frame <- frame + 1L
[13:17:33.854]                         envir <- sys.frame(frame)
[13:17:33.854]                       }
[13:17:33.854]                     }
[13:17:33.854]                     sendCondition <<- function(cond) NULL
[13:17:33.854]                   }
[13:17:33.854]                 })
[13:17:33.854]                 withCallingHandlers({
[13:17:33.854]                   {
[13:17:33.854]                     do.call(function(...) {
[13:17:33.854]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.854]                       if (!identical(...future.globals.maxSize.org, 
[13:17:33.854]                         ...future.globals.maxSize)) {
[13:17:33.854]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.854]                         on.exit(options(oopts), add = TRUE)
[13:17:33.854]                       }
[13:17:33.854]                       {
[13:17:33.854]                         lapply(seq_along(...future.elements_ii), 
[13:17:33.854]                           FUN = function(jj) {
[13:17:33.854]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.854]                             ...future.FUN(...future.X_jj, ...)
[13:17:33.854]                           })
[13:17:33.854]                       }
[13:17:33.854]                     }, args = future.call.arguments)
[13:17:33.854]                   }
[13:17:33.854]                 }, immediateCondition = function(cond) {
[13:17:33.854]                   sendCondition <- ...future.makeSendCondition()
[13:17:33.854]                   sendCondition(cond)
[13:17:33.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.854]                   {
[13:17:33.854]                     inherits <- base::inherits
[13:17:33.854]                     invokeRestart <- base::invokeRestart
[13:17:33.854]                     is.null <- base::is.null
[13:17:33.854]                     muffled <- FALSE
[13:17:33.854]                     if (inherits(cond, "message")) {
[13:17:33.854]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:33.854]                       if (muffled) 
[13:17:33.854]                         invokeRestart("muffleMessage")
[13:17:33.854]                     }
[13:17:33.854]                     else if (inherits(cond, "warning")) {
[13:17:33.854]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:33.854]                       if (muffled) 
[13:17:33.854]                         invokeRestart("muffleWarning")
[13:17:33.854]                     }
[13:17:33.854]                     else if (inherits(cond, "condition")) {
[13:17:33.854]                       if (!is.null(pattern)) {
[13:17:33.854]                         computeRestarts <- base::computeRestarts
[13:17:33.854]                         grepl <- base::grepl
[13:17:33.854]                         restarts <- computeRestarts(cond)
[13:17:33.854]                         for (restart in restarts) {
[13:17:33.854]                           name <- restart$name
[13:17:33.854]                           if (is.null(name)) 
[13:17:33.854]                             next
[13:17:33.854]                           if (!grepl(pattern, name)) 
[13:17:33.854]                             next
[13:17:33.854]                           invokeRestart(restart)
[13:17:33.854]                           muffled <- TRUE
[13:17:33.854]                           break
[13:17:33.854]                         }
[13:17:33.854]                       }
[13:17:33.854]                     }
[13:17:33.854]                     invisible(muffled)
[13:17:33.854]                   }
[13:17:33.854]                   muffleCondition(cond)
[13:17:33.854]                 })
[13:17:33.854]             }))
[13:17:33.854]             future::FutureResult(value = ...future.value$value, 
[13:17:33.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.854]                   ...future.rng), globalenv = if (FALSE) 
[13:17:33.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:33.854]                     ...future.globalenv.names))
[13:17:33.854]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:33.854]         }, condition = base::local({
[13:17:33.854]             c <- base::c
[13:17:33.854]             inherits <- base::inherits
[13:17:33.854]             invokeRestart <- base::invokeRestart
[13:17:33.854]             length <- base::length
[13:17:33.854]             list <- base::list
[13:17:33.854]             seq.int <- base::seq.int
[13:17:33.854]             signalCondition <- base::signalCondition
[13:17:33.854]             sys.calls <- base::sys.calls
[13:17:33.854]             `[[` <- base::`[[`
[13:17:33.854]             `+` <- base::`+`
[13:17:33.854]             `<<-` <- base::`<<-`
[13:17:33.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:33.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:33.854]                   3L)]
[13:17:33.854]             }
[13:17:33.854]             function(cond) {
[13:17:33.854]                 is_error <- inherits(cond, "error")
[13:17:33.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:33.854]                   NULL)
[13:17:33.854]                 if (is_error) {
[13:17:33.854]                   sessionInformation <- function() {
[13:17:33.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:33.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:33.854]                       search = base::search(), system = base::Sys.info())
[13:17:33.854]                   }
[13:17:33.854]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:33.854]                     cond$call), session = sessionInformation(), 
[13:17:33.854]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:33.854]                   signalCondition(cond)
[13:17:33.854]                 }
[13:17:33.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:33.854]                 "immediateCondition"))) {
[13:17:33.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:33.854]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:33.854]                   if (TRUE && !signal) {
[13:17:33.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.854]                     {
[13:17:33.854]                       inherits <- base::inherits
[13:17:33.854]                       invokeRestart <- base::invokeRestart
[13:17:33.854]                       is.null <- base::is.null
[13:17:33.854]                       muffled <- FALSE
[13:17:33.854]                       if (inherits(cond, "message")) {
[13:17:33.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.854]                         if (muffled) 
[13:17:33.854]                           invokeRestart("muffleMessage")
[13:17:33.854]                       }
[13:17:33.854]                       else if (inherits(cond, "warning")) {
[13:17:33.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.854]                         if (muffled) 
[13:17:33.854]                           invokeRestart("muffleWarning")
[13:17:33.854]                       }
[13:17:33.854]                       else if (inherits(cond, "condition")) {
[13:17:33.854]                         if (!is.null(pattern)) {
[13:17:33.854]                           computeRestarts <- base::computeRestarts
[13:17:33.854]                           grepl <- base::grepl
[13:17:33.854]                           restarts <- computeRestarts(cond)
[13:17:33.854]                           for (restart in restarts) {
[13:17:33.854]                             name <- restart$name
[13:17:33.854]                             if (is.null(name)) 
[13:17:33.854]                               next
[13:17:33.854]                             if (!grepl(pattern, name)) 
[13:17:33.854]                               next
[13:17:33.854]                             invokeRestart(restart)
[13:17:33.854]                             muffled <- TRUE
[13:17:33.854]                             break
[13:17:33.854]                           }
[13:17:33.854]                         }
[13:17:33.854]                       }
[13:17:33.854]                       invisible(muffled)
[13:17:33.854]                     }
[13:17:33.854]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.854]                   }
[13:17:33.854]                 }
[13:17:33.854]                 else {
[13:17:33.854]                   if (TRUE) {
[13:17:33.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.854]                     {
[13:17:33.854]                       inherits <- base::inherits
[13:17:33.854]                       invokeRestart <- base::invokeRestart
[13:17:33.854]                       is.null <- base::is.null
[13:17:33.854]                       muffled <- FALSE
[13:17:33.854]                       if (inherits(cond, "message")) {
[13:17:33.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.854]                         if (muffled) 
[13:17:33.854]                           invokeRestart("muffleMessage")
[13:17:33.854]                       }
[13:17:33.854]                       else if (inherits(cond, "warning")) {
[13:17:33.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.854]                         if (muffled) 
[13:17:33.854]                           invokeRestart("muffleWarning")
[13:17:33.854]                       }
[13:17:33.854]                       else if (inherits(cond, "condition")) {
[13:17:33.854]                         if (!is.null(pattern)) {
[13:17:33.854]                           computeRestarts <- base::computeRestarts
[13:17:33.854]                           grepl <- base::grepl
[13:17:33.854]                           restarts <- computeRestarts(cond)
[13:17:33.854]                           for (restart in restarts) {
[13:17:33.854]                             name <- restart$name
[13:17:33.854]                             if (is.null(name)) 
[13:17:33.854]                               next
[13:17:33.854]                             if (!grepl(pattern, name)) 
[13:17:33.854]                               next
[13:17:33.854]                             invokeRestart(restart)
[13:17:33.854]                             muffled <- TRUE
[13:17:33.854]                             break
[13:17:33.854]                           }
[13:17:33.854]                         }
[13:17:33.854]                       }
[13:17:33.854]                       invisible(muffled)
[13:17:33.854]                     }
[13:17:33.854]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.854]                   }
[13:17:33.854]                 }
[13:17:33.854]             }
[13:17:33.854]         }))
[13:17:33.854]     }, error = function(ex) {
[13:17:33.854]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:33.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.854]                 ...future.rng), started = ...future.startTime, 
[13:17:33.854]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:33.854]             version = "1.8"), class = "FutureResult")
[13:17:33.854]     }, finally = {
[13:17:33.854]         if (!identical(...future.workdir, getwd())) 
[13:17:33.854]             setwd(...future.workdir)
[13:17:33.854]         {
[13:17:33.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:33.854]                 ...future.oldOptions$nwarnings <- NULL
[13:17:33.854]             }
[13:17:33.854]             base::options(...future.oldOptions)
[13:17:33.854]             if (.Platform$OS.type == "windows") {
[13:17:33.854]                 old_names <- names(...future.oldEnvVars)
[13:17:33.854]                 envs <- base::Sys.getenv()
[13:17:33.854]                 names <- names(envs)
[13:17:33.854]                 common <- intersect(names, old_names)
[13:17:33.854]                 added <- setdiff(names, old_names)
[13:17:33.854]                 removed <- setdiff(old_names, names)
[13:17:33.854]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:33.854]                   envs[common]]
[13:17:33.854]                 NAMES <- toupper(changed)
[13:17:33.854]                 args <- list()
[13:17:33.854]                 for (kk in seq_along(NAMES)) {
[13:17:33.854]                   name <- changed[[kk]]
[13:17:33.854]                   NAME <- NAMES[[kk]]
[13:17:33.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.854]                     next
[13:17:33.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.854]                 }
[13:17:33.854]                 NAMES <- toupper(added)
[13:17:33.854]                 for (kk in seq_along(NAMES)) {
[13:17:33.854]                   name <- added[[kk]]
[13:17:33.854]                   NAME <- NAMES[[kk]]
[13:17:33.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.854]                     next
[13:17:33.854]                   args[[name]] <- ""
[13:17:33.854]                 }
[13:17:33.854]                 NAMES <- toupper(removed)
[13:17:33.854]                 for (kk in seq_along(NAMES)) {
[13:17:33.854]                   name <- removed[[kk]]
[13:17:33.854]                   NAME <- NAMES[[kk]]
[13:17:33.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.854]                     next
[13:17:33.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.854]                 }
[13:17:33.854]                 if (length(args) > 0) 
[13:17:33.854]                   base::do.call(base::Sys.setenv, args = args)
[13:17:33.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:33.854]             }
[13:17:33.854]             else {
[13:17:33.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:33.854]             }
[13:17:33.854]             {
[13:17:33.854]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:33.854]                   0L) {
[13:17:33.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:33.854]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:33.854]                   base::options(opts)
[13:17:33.854]                 }
[13:17:33.854]                 {
[13:17:33.854]                   {
[13:17:33.854]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:33.854]                     NULL
[13:17:33.854]                   }
[13:17:33.854]                   options(future.plan = NULL)
[13:17:33.854]                   if (is.na(NA_character_)) 
[13:17:33.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:33.854]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:33.854]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:33.854]                     envir = parent.frame()) 
[13:17:33.854]                   {
[13:17:33.854]                     if (is.function(workers)) 
[13:17:33.854]                       workers <- workers()
[13:17:33.854]                     workers <- structure(as.integer(workers), 
[13:17:33.854]                       class = class(workers))
[13:17:33.854]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:33.854]                       workers >= 1)
[13:17:33.854]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:33.854]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:33.854]                     }
[13:17:33.854]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:33.854]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:33.854]                       envir = envir)
[13:17:33.854]                     if (!future$lazy) 
[13:17:33.854]                       future <- run(future)
[13:17:33.854]                     invisible(future)
[13:17:33.854]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:33.854]                 }
[13:17:33.854]             }
[13:17:33.854]         }
[13:17:33.854]     })
[13:17:33.854]     if (TRUE) {
[13:17:33.854]         base::sink(type = "output", split = FALSE)
[13:17:33.854]         if (TRUE) {
[13:17:33.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:33.854]         }
[13:17:33.854]         else {
[13:17:33.854]             ...future.result["stdout"] <- base::list(NULL)
[13:17:33.854]         }
[13:17:33.854]         base::close(...future.stdout)
[13:17:33.854]         ...future.stdout <- NULL
[13:17:33.854]     }
[13:17:33.854]     ...future.result$conditions <- ...future.conditions
[13:17:33.854]     ...future.result$finished <- base::Sys.time()
[13:17:33.854]     ...future.result
[13:17:33.854] }
[13:17:33.857] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:17:33.858] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:17:33.858] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:17:33.858] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:33.859] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:33.859] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:17:33.859] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:17:33.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:33.860] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:33.860] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:33.860] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:33.860] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:17:33.861] MultisessionFuture started
[13:17:33.861] - Launch lazy future ... done
[13:17:33.861] run() for ‘MultisessionFuture’ ... done
[13:17:33.861] Created future:
[13:17:33.861] MultisessionFuture:
[13:17:33.861] Label: ‘future_eapply-1’
[13:17:33.861] Expression:
[13:17:33.861] {
[13:17:33.861]     do.call(function(...) {
[13:17:33.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.861]             on.exit(options(oopts), add = TRUE)
[13:17:33.861]         }
[13:17:33.861]         {
[13:17:33.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.861]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.861]             })
[13:17:33.861]         }
[13:17:33.861]     }, args = future.call.arguments)
[13:17:33.861] }
[13:17:33.861] Lazy evaluation: FALSE
[13:17:33.861] Asynchronous evaluation: TRUE
[13:17:33.861] Local evaluation: TRUE
[13:17:33.861] Environment: R_GlobalEnv
[13:17:33.861] Capture standard output: TRUE
[13:17:33.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:33.861] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:33.861] Packages: <none>
[13:17:33.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:33.861] Resolved: FALSE
[13:17:33.861] Value: <not collected>
[13:17:33.861] Conditions captured: <none>
[13:17:33.861] Early signaling: FALSE
[13:17:33.861] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:33.861] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.873] Chunk #1 of 2 ... DONE
[13:17:33.874] Chunk #2 of 2 ...
[13:17:33.874]  - Finding globals in 'X' for chunk #2 ...
[13:17:33.874] getGlobalsAndPackages() ...
[13:17:33.874] Searching for globals...
[13:17:33.874] 
[13:17:33.874] Searching for globals ... DONE
[13:17:33.875] - globals: [0] <none>
[13:17:33.875] getGlobalsAndPackages() ... DONE
[13:17:33.875]    + additional globals found: [n=0] 
[13:17:33.875]    + additional namespaces needed: [n=0] 
[13:17:33.875]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:33.875]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:33.875]  - seeds: <none>
[13:17:33.875] getGlobalsAndPackages() ...
[13:17:33.876] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.876] Resolving globals: FALSE
[13:17:33.876] Tweak future expression to call with '...' arguments ...
[13:17:33.876] {
[13:17:33.876]     do.call(function(...) {
[13:17:33.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.876]             on.exit(options(oopts), add = TRUE)
[13:17:33.876]         }
[13:17:33.876]         {
[13:17:33.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.876]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.876]             })
[13:17:33.876]         }
[13:17:33.876]     }, args = future.call.arguments)
[13:17:33.876] }
[13:17:33.876] Tweak future expression to call with '...' arguments ... DONE
[13:17:33.877] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:33.877] 
[13:17:33.877] getGlobalsAndPackages() ... DONE
[13:17:33.877] run() for ‘Future’ ...
[13:17:33.877] - state: ‘created’
[13:17:33.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:33.893] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:33.893]   - Field: ‘node’
[13:17:33.893]   - Field: ‘label’
[13:17:33.893]   - Field: ‘local’
[13:17:33.893]   - Field: ‘owner’
[13:17:33.893]   - Field: ‘envir’
[13:17:33.893]   - Field: ‘workers’
[13:17:33.894]   - Field: ‘packages’
[13:17:33.894]   - Field: ‘gc’
[13:17:33.894]   - Field: ‘conditions’
[13:17:33.894]   - Field: ‘persistent’
[13:17:33.894]   - Field: ‘expr’
[13:17:33.894]   - Field: ‘uuid’
[13:17:33.894]   - Field: ‘seed’
[13:17:33.894]   - Field: ‘version’
[13:17:33.894]   - Field: ‘result’
[13:17:33.895]   - Field: ‘asynchronous’
[13:17:33.895]   - Field: ‘calls’
[13:17:33.895]   - Field: ‘globals’
[13:17:33.895]   - Field: ‘stdout’
[13:17:33.895]   - Field: ‘earlySignal’
[13:17:33.895]   - Field: ‘lazy’
[13:17:33.895]   - Field: ‘state’
[13:17:33.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:33.896] - Launch lazy future ...
[13:17:33.896] Packages needed by the future expression (n = 0): <none>
[13:17:33.896] Packages needed by future strategies (n = 0): <none>
[13:17:33.896] {
[13:17:33.896]     {
[13:17:33.896]         {
[13:17:33.896]             ...future.startTime <- base::Sys.time()
[13:17:33.896]             {
[13:17:33.896]                 {
[13:17:33.896]                   {
[13:17:33.896]                     {
[13:17:33.896]                       base::local({
[13:17:33.896]                         has_future <- base::requireNamespace("future", 
[13:17:33.896]                           quietly = TRUE)
[13:17:33.896]                         if (has_future) {
[13:17:33.896]                           ns <- base::getNamespace("future")
[13:17:33.896]                           version <- ns[[".package"]][["version"]]
[13:17:33.896]                           if (is.null(version)) 
[13:17:33.896]                             version <- utils::packageVersion("future")
[13:17:33.896]                         }
[13:17:33.896]                         else {
[13:17:33.896]                           version <- NULL
[13:17:33.896]                         }
[13:17:33.896]                         if (!has_future || version < "1.8.0") {
[13:17:33.896]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:33.896]                             "", base::R.version$version.string), 
[13:17:33.896]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:33.896]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:33.896]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:33.896]                               "release", "version")], collapse = " "), 
[13:17:33.896]                             hostname = base::Sys.info()[["nodename"]])
[13:17:33.896]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:33.896]                             info)
[13:17:33.896]                           info <- base::paste(info, collapse = "; ")
[13:17:33.896]                           if (!has_future) {
[13:17:33.896]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:33.896]                               info)
[13:17:33.896]                           }
[13:17:33.896]                           else {
[13:17:33.896]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:33.896]                               info, version)
[13:17:33.896]                           }
[13:17:33.896]                           base::stop(msg)
[13:17:33.896]                         }
[13:17:33.896]                       })
[13:17:33.896]                     }
[13:17:33.896]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:33.896]                     base::options(mc.cores = 1L)
[13:17:33.896]                   }
[13:17:33.896]                   options(future.plan = NULL)
[13:17:33.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:33.896]                 }
[13:17:33.896]                 ...future.workdir <- getwd()
[13:17:33.896]             }
[13:17:33.896]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:33.896]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:33.896]         }
[13:17:33.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:33.896]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:33.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:33.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:33.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:33.896]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:33.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:33.896]             base::names(...future.oldOptions))
[13:17:33.896]     }
[13:17:33.896]     if (FALSE) {
[13:17:33.896]     }
[13:17:33.896]     else {
[13:17:33.896]         if (TRUE) {
[13:17:33.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:33.896]                 open = "w")
[13:17:33.896]         }
[13:17:33.896]         else {
[13:17:33.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:33.896]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:33.896]         }
[13:17:33.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:33.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:33.896]             base::sink(type = "output", split = FALSE)
[13:17:33.896]             base::close(...future.stdout)
[13:17:33.896]         }, add = TRUE)
[13:17:33.896]     }
[13:17:33.896]     ...future.frame <- base::sys.nframe()
[13:17:33.896]     ...future.conditions <- base::list()
[13:17:33.896]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:33.896]     if (FALSE) {
[13:17:33.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:33.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:33.896]     }
[13:17:33.896]     ...future.result <- base::tryCatch({
[13:17:33.896]         base::withCallingHandlers({
[13:17:33.896]             ...future.value <- base::withVisible(base::local({
[13:17:33.896]                 ...future.makeSendCondition <- local({
[13:17:33.896]                   sendCondition <- NULL
[13:17:33.896]                   function(frame = 1L) {
[13:17:33.896]                     if (is.function(sendCondition)) 
[13:17:33.896]                       return(sendCondition)
[13:17:33.896]                     ns <- getNamespace("parallel")
[13:17:33.896]                     if (exists("sendData", mode = "function", 
[13:17:33.896]                       envir = ns)) {
[13:17:33.896]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:33.896]                         envir = ns)
[13:17:33.896]                       envir <- sys.frame(frame)
[13:17:33.896]                       master <- NULL
[13:17:33.896]                       while (!identical(envir, .GlobalEnv) && 
[13:17:33.896]                         !identical(envir, emptyenv())) {
[13:17:33.896]                         if (exists("master", mode = "list", envir = envir, 
[13:17:33.896]                           inherits = FALSE)) {
[13:17:33.896]                           master <- get("master", mode = "list", 
[13:17:33.896]                             envir = envir, inherits = FALSE)
[13:17:33.896]                           if (inherits(master, c("SOCKnode", 
[13:17:33.896]                             "SOCK0node"))) {
[13:17:33.896]                             sendCondition <<- function(cond) {
[13:17:33.896]                               data <- list(type = "VALUE", value = cond, 
[13:17:33.896]                                 success = TRUE)
[13:17:33.896]                               parallel_sendData(master, data)
[13:17:33.896]                             }
[13:17:33.896]                             return(sendCondition)
[13:17:33.896]                           }
[13:17:33.896]                         }
[13:17:33.896]                         frame <- frame + 1L
[13:17:33.896]                         envir <- sys.frame(frame)
[13:17:33.896]                       }
[13:17:33.896]                     }
[13:17:33.896]                     sendCondition <<- function(cond) NULL
[13:17:33.896]                   }
[13:17:33.896]                 })
[13:17:33.896]                 withCallingHandlers({
[13:17:33.896]                   {
[13:17:33.896]                     do.call(function(...) {
[13:17:33.896]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.896]                       if (!identical(...future.globals.maxSize.org, 
[13:17:33.896]                         ...future.globals.maxSize)) {
[13:17:33.896]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.896]                         on.exit(options(oopts), add = TRUE)
[13:17:33.896]                       }
[13:17:33.896]                       {
[13:17:33.896]                         lapply(seq_along(...future.elements_ii), 
[13:17:33.896]                           FUN = function(jj) {
[13:17:33.896]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.896]                             ...future.FUN(...future.X_jj, ...)
[13:17:33.896]                           })
[13:17:33.896]                       }
[13:17:33.896]                     }, args = future.call.arguments)
[13:17:33.896]                   }
[13:17:33.896]                 }, immediateCondition = function(cond) {
[13:17:33.896]                   sendCondition <- ...future.makeSendCondition()
[13:17:33.896]                   sendCondition(cond)
[13:17:33.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.896]                   {
[13:17:33.896]                     inherits <- base::inherits
[13:17:33.896]                     invokeRestart <- base::invokeRestart
[13:17:33.896]                     is.null <- base::is.null
[13:17:33.896]                     muffled <- FALSE
[13:17:33.896]                     if (inherits(cond, "message")) {
[13:17:33.896]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:33.896]                       if (muffled) 
[13:17:33.896]                         invokeRestart("muffleMessage")
[13:17:33.896]                     }
[13:17:33.896]                     else if (inherits(cond, "warning")) {
[13:17:33.896]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:33.896]                       if (muffled) 
[13:17:33.896]                         invokeRestart("muffleWarning")
[13:17:33.896]                     }
[13:17:33.896]                     else if (inherits(cond, "condition")) {
[13:17:33.896]                       if (!is.null(pattern)) {
[13:17:33.896]                         computeRestarts <- base::computeRestarts
[13:17:33.896]                         grepl <- base::grepl
[13:17:33.896]                         restarts <- computeRestarts(cond)
[13:17:33.896]                         for (restart in restarts) {
[13:17:33.896]                           name <- restart$name
[13:17:33.896]                           if (is.null(name)) 
[13:17:33.896]                             next
[13:17:33.896]                           if (!grepl(pattern, name)) 
[13:17:33.896]                             next
[13:17:33.896]                           invokeRestart(restart)
[13:17:33.896]                           muffled <- TRUE
[13:17:33.896]                           break
[13:17:33.896]                         }
[13:17:33.896]                       }
[13:17:33.896]                     }
[13:17:33.896]                     invisible(muffled)
[13:17:33.896]                   }
[13:17:33.896]                   muffleCondition(cond)
[13:17:33.896]                 })
[13:17:33.896]             }))
[13:17:33.896]             future::FutureResult(value = ...future.value$value, 
[13:17:33.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.896]                   ...future.rng), globalenv = if (FALSE) 
[13:17:33.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:33.896]                     ...future.globalenv.names))
[13:17:33.896]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:33.896]         }, condition = base::local({
[13:17:33.896]             c <- base::c
[13:17:33.896]             inherits <- base::inherits
[13:17:33.896]             invokeRestart <- base::invokeRestart
[13:17:33.896]             length <- base::length
[13:17:33.896]             list <- base::list
[13:17:33.896]             seq.int <- base::seq.int
[13:17:33.896]             signalCondition <- base::signalCondition
[13:17:33.896]             sys.calls <- base::sys.calls
[13:17:33.896]             `[[` <- base::`[[`
[13:17:33.896]             `+` <- base::`+`
[13:17:33.896]             `<<-` <- base::`<<-`
[13:17:33.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:33.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:33.896]                   3L)]
[13:17:33.896]             }
[13:17:33.896]             function(cond) {
[13:17:33.896]                 is_error <- inherits(cond, "error")
[13:17:33.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:33.896]                   NULL)
[13:17:33.896]                 if (is_error) {
[13:17:33.896]                   sessionInformation <- function() {
[13:17:33.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:33.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:33.896]                       search = base::search(), system = base::Sys.info())
[13:17:33.896]                   }
[13:17:33.896]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:33.896]                     cond$call), session = sessionInformation(), 
[13:17:33.896]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:33.896]                   signalCondition(cond)
[13:17:33.896]                 }
[13:17:33.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:33.896]                 "immediateCondition"))) {
[13:17:33.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:33.896]                   ...future.conditions[[length(...future.conditions) + 
[13:17:33.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:33.896]                   if (TRUE && !signal) {
[13:17:33.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.896]                     {
[13:17:33.896]                       inherits <- base::inherits
[13:17:33.896]                       invokeRestart <- base::invokeRestart
[13:17:33.896]                       is.null <- base::is.null
[13:17:33.896]                       muffled <- FALSE
[13:17:33.896]                       if (inherits(cond, "message")) {
[13:17:33.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.896]                         if (muffled) 
[13:17:33.896]                           invokeRestart("muffleMessage")
[13:17:33.896]                       }
[13:17:33.896]                       else if (inherits(cond, "warning")) {
[13:17:33.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.896]                         if (muffled) 
[13:17:33.896]                           invokeRestart("muffleWarning")
[13:17:33.896]                       }
[13:17:33.896]                       else if (inherits(cond, "condition")) {
[13:17:33.896]                         if (!is.null(pattern)) {
[13:17:33.896]                           computeRestarts <- base::computeRestarts
[13:17:33.896]                           grepl <- base::grepl
[13:17:33.896]                           restarts <- computeRestarts(cond)
[13:17:33.896]                           for (restart in restarts) {
[13:17:33.896]                             name <- restart$name
[13:17:33.896]                             if (is.null(name)) 
[13:17:33.896]                               next
[13:17:33.896]                             if (!grepl(pattern, name)) 
[13:17:33.896]                               next
[13:17:33.896]                             invokeRestart(restart)
[13:17:33.896]                             muffled <- TRUE
[13:17:33.896]                             break
[13:17:33.896]                           }
[13:17:33.896]                         }
[13:17:33.896]                       }
[13:17:33.896]                       invisible(muffled)
[13:17:33.896]                     }
[13:17:33.896]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.896]                   }
[13:17:33.896]                 }
[13:17:33.896]                 else {
[13:17:33.896]                   if (TRUE) {
[13:17:33.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:33.896]                     {
[13:17:33.896]                       inherits <- base::inherits
[13:17:33.896]                       invokeRestart <- base::invokeRestart
[13:17:33.896]                       is.null <- base::is.null
[13:17:33.896]                       muffled <- FALSE
[13:17:33.896]                       if (inherits(cond, "message")) {
[13:17:33.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:33.896]                         if (muffled) 
[13:17:33.896]                           invokeRestart("muffleMessage")
[13:17:33.896]                       }
[13:17:33.896]                       else if (inherits(cond, "warning")) {
[13:17:33.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:33.896]                         if (muffled) 
[13:17:33.896]                           invokeRestart("muffleWarning")
[13:17:33.896]                       }
[13:17:33.896]                       else if (inherits(cond, "condition")) {
[13:17:33.896]                         if (!is.null(pattern)) {
[13:17:33.896]                           computeRestarts <- base::computeRestarts
[13:17:33.896]                           grepl <- base::grepl
[13:17:33.896]                           restarts <- computeRestarts(cond)
[13:17:33.896]                           for (restart in restarts) {
[13:17:33.896]                             name <- restart$name
[13:17:33.896]                             if (is.null(name)) 
[13:17:33.896]                               next
[13:17:33.896]                             if (!grepl(pattern, name)) 
[13:17:33.896]                               next
[13:17:33.896]                             invokeRestart(restart)
[13:17:33.896]                             muffled <- TRUE
[13:17:33.896]                             break
[13:17:33.896]                           }
[13:17:33.896]                         }
[13:17:33.896]                       }
[13:17:33.896]                       invisible(muffled)
[13:17:33.896]                     }
[13:17:33.896]                     muffleCondition(cond, pattern = "^muffle")
[13:17:33.896]                   }
[13:17:33.896]                 }
[13:17:33.896]             }
[13:17:33.896]         }))
[13:17:33.896]     }, error = function(ex) {
[13:17:33.896]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:33.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:33.896]                 ...future.rng), started = ...future.startTime, 
[13:17:33.896]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:33.896]             version = "1.8"), class = "FutureResult")
[13:17:33.896]     }, finally = {
[13:17:33.896]         if (!identical(...future.workdir, getwd())) 
[13:17:33.896]             setwd(...future.workdir)
[13:17:33.896]         {
[13:17:33.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:33.896]                 ...future.oldOptions$nwarnings <- NULL
[13:17:33.896]             }
[13:17:33.896]             base::options(...future.oldOptions)
[13:17:33.896]             if (.Platform$OS.type == "windows") {
[13:17:33.896]                 old_names <- names(...future.oldEnvVars)
[13:17:33.896]                 envs <- base::Sys.getenv()
[13:17:33.896]                 names <- names(envs)
[13:17:33.896]                 common <- intersect(names, old_names)
[13:17:33.896]                 added <- setdiff(names, old_names)
[13:17:33.896]                 removed <- setdiff(old_names, names)
[13:17:33.896]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:33.896]                   envs[common]]
[13:17:33.896]                 NAMES <- toupper(changed)
[13:17:33.896]                 args <- list()
[13:17:33.896]                 for (kk in seq_along(NAMES)) {
[13:17:33.896]                   name <- changed[[kk]]
[13:17:33.896]                   NAME <- NAMES[[kk]]
[13:17:33.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.896]                     next
[13:17:33.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.896]                 }
[13:17:33.896]                 NAMES <- toupper(added)
[13:17:33.896]                 for (kk in seq_along(NAMES)) {
[13:17:33.896]                   name <- added[[kk]]
[13:17:33.896]                   NAME <- NAMES[[kk]]
[13:17:33.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.896]                     next
[13:17:33.896]                   args[[name]] <- ""
[13:17:33.896]                 }
[13:17:33.896]                 NAMES <- toupper(removed)
[13:17:33.896]                 for (kk in seq_along(NAMES)) {
[13:17:33.896]                   name <- removed[[kk]]
[13:17:33.896]                   NAME <- NAMES[[kk]]
[13:17:33.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:33.896]                     next
[13:17:33.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:33.896]                 }
[13:17:33.896]                 if (length(args) > 0) 
[13:17:33.896]                   base::do.call(base::Sys.setenv, args = args)
[13:17:33.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:33.896]             }
[13:17:33.896]             else {
[13:17:33.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:33.896]             }
[13:17:33.896]             {
[13:17:33.896]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:33.896]                   0L) {
[13:17:33.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:33.896]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:33.896]                   base::options(opts)
[13:17:33.896]                 }
[13:17:33.896]                 {
[13:17:33.896]                   {
[13:17:33.896]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:33.896]                     NULL
[13:17:33.896]                   }
[13:17:33.896]                   options(future.plan = NULL)
[13:17:33.896]                   if (is.na(NA_character_)) 
[13:17:33.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:33.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:33.896]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:33.896]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:33.896]                     envir = parent.frame()) 
[13:17:33.896]                   {
[13:17:33.896]                     if (is.function(workers)) 
[13:17:33.896]                       workers <- workers()
[13:17:33.896]                     workers <- structure(as.integer(workers), 
[13:17:33.896]                       class = class(workers))
[13:17:33.896]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:33.896]                       workers >= 1)
[13:17:33.896]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:33.896]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:33.896]                     }
[13:17:33.896]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:33.896]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:33.896]                       envir = envir)
[13:17:33.896]                     if (!future$lazy) 
[13:17:33.896]                       future <- run(future)
[13:17:33.896]                     invisible(future)
[13:17:33.896]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:33.896]                 }
[13:17:33.896]             }
[13:17:33.896]         }
[13:17:33.896]     })
[13:17:33.896]     if (TRUE) {
[13:17:33.896]         base::sink(type = "output", split = FALSE)
[13:17:33.896]         if (TRUE) {
[13:17:33.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:33.896]         }
[13:17:33.896]         else {
[13:17:33.896]             ...future.result["stdout"] <- base::list(NULL)
[13:17:33.896]         }
[13:17:33.896]         base::close(...future.stdout)
[13:17:33.896]         ...future.stdout <- NULL
[13:17:33.896]     }
[13:17:33.896]     ...future.result$conditions <- ...future.conditions
[13:17:33.896]     ...future.result$finished <- base::Sys.time()
[13:17:33.896]     ...future.result
[13:17:33.896] }
[13:17:33.969] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:17:33.970] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:17:33.970] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:17:33.970] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:33.971] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:33.971] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:17:33.971] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:17:33.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:33.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:33.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:33.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:33.973] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:17:33.973] MultisessionFuture started
[13:17:33.973] - Launch lazy future ... done
[13:17:33.973] run() for ‘MultisessionFuture’ ... done
[13:17:33.974] Created future:
[13:17:33.974] MultisessionFuture:
[13:17:33.974] Label: ‘future_eapply-2’
[13:17:33.974] Expression:
[13:17:33.974] {
[13:17:33.974]     do.call(function(...) {
[13:17:33.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:33.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:33.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:33.974]             on.exit(options(oopts), add = TRUE)
[13:17:33.974]         }
[13:17:33.974]         {
[13:17:33.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:33.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:33.974]                 ...future.FUN(...future.X_jj, ...)
[13:17:33.974]             })
[13:17:33.974]         }
[13:17:33.974]     }, args = future.call.arguments)
[13:17:33.974] }
[13:17:33.974] Lazy evaluation: FALSE
[13:17:33.974] Asynchronous evaluation: TRUE
[13:17:33.974] Local evaluation: TRUE
[13:17:33.974] Environment: R_GlobalEnv
[13:17:33.974] Capture standard output: TRUE
[13:17:33.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:33.974] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:33.974] Packages: <none>
[13:17:33.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:33.974] Resolved: FALSE
[13:17:33.974] Value: <not collected>
[13:17:33.974] Conditions captured: <none>
[13:17:33.974] Early signaling: FALSE
[13:17:33.974] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:33.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:33.986] Chunk #2 of 2 ... DONE
[13:17:33.986] Launching 2 futures (chunks) ... DONE
[13:17:33.986] Resolving 2 futures (chunks) ...
[13:17:33.986] resolve() on list ...
[13:17:33.986]  recursive: 0
[13:17:33.986]  length: 2
[13:17:33.987] 
[13:17:33.987] receiveMessageFromWorker() for ClusterFuture ...
[13:17:33.987] - Validating connection of MultisessionFuture
[13:17:33.987] - received message: FutureResult
[13:17:33.988] - Received FutureResult
[13:17:33.988] - Erased future from FutureRegistry
[13:17:33.988] result() for ClusterFuture ...
[13:17:33.988] - result already collected: FutureResult
[13:17:33.988] result() for ClusterFuture ... done
[13:17:33.988] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:33.988] Future #1
[13:17:33.988] result() for ClusterFuture ...
[13:17:33.989] - result already collected: FutureResult
[13:17:33.989] result() for ClusterFuture ... done
[13:17:33.989] result() for ClusterFuture ...
[13:17:33.993] - result already collected: FutureResult
[13:17:33.993] result() for ClusterFuture ... done
[13:17:33.993] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:33.994] - nx: 2
[13:17:33.994] - relay: TRUE
[13:17:33.994] - stdout: TRUE
[13:17:33.994] - signal: TRUE
[13:17:33.994] - resignal: FALSE
[13:17:33.994] - force: TRUE
[13:17:33.994] - relayed: [n=2] FALSE, FALSE
[13:17:33.994] - queued futures: [n=2] FALSE, FALSE
[13:17:33.994]  - until=1
[13:17:33.994]  - relaying element #1
[13:17:33.994] result() for ClusterFuture ...
[13:17:33.994] - result already collected: FutureResult
[13:17:33.995] result() for ClusterFuture ... done
[13:17:33.995] result() for ClusterFuture ...
[13:17:33.995] - result already collected: FutureResult
[13:17:33.995] result() for ClusterFuture ... done
[13:17:33.995] result() for ClusterFuture ...
[13:17:33.995] - result already collected: FutureResult
[13:17:33.995] result() for ClusterFuture ... done
[13:17:33.995] result() for ClusterFuture ...
[13:17:33.995] - result already collected: FutureResult
[13:17:33.995] result() for ClusterFuture ... done
[13:17:33.995] - relayed: [n=2] TRUE, FALSE
[13:17:33.996] - queued futures: [n=2] TRUE, FALSE
[13:17:33.996] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:33.996]  length: 1 (resolved future 1)
[13:17:34.058] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.059] - Validating connection of MultisessionFuture
[13:17:34.059] - received message: FutureResult
[13:17:34.059] - Received FutureResult
[13:17:34.059] - Erased future from FutureRegistry
[13:17:34.059] result() for ClusterFuture ...
[13:17:34.059] - result already collected: FutureResult
[13:17:34.059] result() for ClusterFuture ... done
[13:17:34.060] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.060] Future #2
[13:17:34.060] result() for ClusterFuture ...
[13:17:34.060] - result already collected: FutureResult
[13:17:34.060] result() for ClusterFuture ... done
[13:17:34.060] result() for ClusterFuture ...
[13:17:34.060] - result already collected: FutureResult
[13:17:34.060] result() for ClusterFuture ... done
[13:17:34.060] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:34.060] - nx: 2
[13:17:34.060] - relay: TRUE
[13:17:34.061] - stdout: TRUE
[13:17:34.061] - signal: TRUE
[13:17:34.061] - resignal: FALSE
[13:17:34.061] - force: TRUE
[13:17:34.061] - relayed: [n=2] TRUE, FALSE
[13:17:34.061] - queued futures: [n=2] TRUE, FALSE
[13:17:34.061]  - until=2
[13:17:34.061]  - relaying element #2
[13:17:34.061] result() for ClusterFuture ...
[13:17:34.061] - result already collected: FutureResult
[13:17:34.061] result() for ClusterFuture ... done
[13:17:34.062] result() for ClusterFuture ...
[13:17:34.062] - result already collected: FutureResult
[13:17:34.062] result() for ClusterFuture ... done
[13:17:34.062] result() for ClusterFuture ...
[13:17:34.062] - result already collected: FutureResult
[13:17:34.062] result() for ClusterFuture ... done
[13:17:34.062] result() for ClusterFuture ...
[13:17:34.062] - result already collected: FutureResult
[13:17:34.062] result() for ClusterFuture ... done
[13:17:34.062] - relayed: [n=2] TRUE, TRUE
[13:17:34.062] - queued futures: [n=2] TRUE, TRUE
[13:17:34.063] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:34.063]  length: 0 (resolved future 2)
[13:17:34.063] Relaying remaining futures
[13:17:34.063] signalConditionsASAP(NULL, pos=0) ...
[13:17:34.063] - nx: 2
[13:17:34.063] - relay: TRUE
[13:17:34.063] - stdout: TRUE
[13:17:34.063] - signal: TRUE
[13:17:34.063] - resignal: FALSE
[13:17:34.063] - force: TRUE
[13:17:34.063] - relayed: [n=2] TRUE, TRUE
[13:17:34.063] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:34.064] - relayed: [n=2] TRUE, TRUE
[13:17:34.064] - queued futures: [n=2] TRUE, TRUE
[13:17:34.064] signalConditionsASAP(NULL, pos=0) ... done
[13:17:34.064] resolve() on list ... DONE
[13:17:34.064] result() for ClusterFuture ...
[13:17:34.064] - result already collected: FutureResult
[13:17:34.064] result() for ClusterFuture ... done
[13:17:34.064] result() for ClusterFuture ...
[13:17:34.064] - result already collected: FutureResult
[13:17:34.064] result() for ClusterFuture ... done
[13:17:34.065] result() for ClusterFuture ...
[13:17:34.065] - result already collected: FutureResult
[13:17:34.065] result() for ClusterFuture ... done
[13:17:34.065] result() for ClusterFuture ...
[13:17:34.065] - result already collected: FutureResult
[13:17:34.065] result() for ClusterFuture ... done
[13:17:34.065]  - Number of value chunks collected: 2
[13:17:34.065] Resolving 2 futures (chunks) ... DONE
[13:17:34.065] Reducing values from 2 chunks ...
[13:17:34.065]  - Number of values collected after concatenation: 3
[13:17:34.065]  - Number of values expected: 3
[13:17:34.066] Reducing values from 2 chunks ... DONE
[13:17:34.066] future_lapply() ... DONE
[13:17:34.066] future_lapply() ...
[13:17:34.070] Number of chunks: 2
[13:17:34.070] getGlobalsAndPackagesXApply() ...
[13:17:34.071]  - future.globals: TRUE
[13:17:34.071] getGlobalsAndPackages() ...
[13:17:34.071] Searching for globals...
[13:17:34.072] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:34.072] Searching for globals ... DONE
[13:17:34.072] Resolving globals: FALSE
[13:17:34.072] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:34.073] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:34.073] - globals: [1] ‘FUN’
[13:17:34.073] - packages: [1] ‘stats’
[13:17:34.073] getGlobalsAndPackages() ... DONE
[13:17:34.073]  - globals found/used: [n=1] ‘FUN’
[13:17:34.073]  - needed namespaces: [n=1] ‘stats’
[13:17:34.074] Finding globals ... DONE
[13:17:34.074]  - use_args: TRUE
[13:17:34.074]  - Getting '...' globals ...
[13:17:34.074] resolve() on list ...
[13:17:34.074]  recursive: 0
[13:17:34.074]  length: 1
[13:17:34.074]  elements: ‘...’
[13:17:34.074]  length: 0 (resolved future 1)
[13:17:34.074] resolve() on list ... DONE
[13:17:34.075]    - '...' content: [n=1] ‘probs’
[13:17:34.075] List of 1
[13:17:34.075]  $ ...:List of 1
[13:17:34.075]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:34.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:34.075]  - attr(*, "where")=List of 1
[13:17:34.075]   ..$ ...:<environment: 0x55be3da1fa40> 
[13:17:34.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:34.075]  - attr(*, "resolved")= logi TRUE
[13:17:34.075]  - attr(*, "total_size")= num NA
[13:17:34.078]  - Getting '...' globals ... DONE
[13:17:34.078] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:34.078] List of 2
[13:17:34.078]  $ ...future.FUN:function (x, ...)  
[13:17:34.078]  $ ...          :List of 1
[13:17:34.078]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:17:34.078]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:34.078]  - attr(*, "where")=List of 2
[13:17:34.078]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:34.078]   ..$ ...          :<environment: 0x55be3da1fa40> 
[13:17:34.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:34.078]  - attr(*, "resolved")= logi FALSE
[13:17:34.078]  - attr(*, "total_size")= num 1328
[13:17:34.081] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:34.081] getGlobalsAndPackagesXApply() ... DONE
[13:17:34.081] Number of futures (= number of chunks): 2
[13:17:34.082] Launching 2 futures (chunks) ...
[13:17:34.082] Chunk #1 of 2 ...
[13:17:34.082]  - Finding globals in 'X' for chunk #1 ...
[13:17:34.082] getGlobalsAndPackages() ...
[13:17:34.082] Searching for globals...
[13:17:34.082] 
[13:17:34.082] Searching for globals ... DONE
[13:17:34.082] - globals: [0] <none>
[13:17:34.083] getGlobalsAndPackages() ... DONE
[13:17:34.083]    + additional globals found: [n=0] 
[13:17:34.083]    + additional namespaces needed: [n=0] 
[13:17:34.083]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:34.083]  - seeds: <none>
[13:17:34.083] getGlobalsAndPackages() ...
[13:17:34.083] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.083] Resolving globals: FALSE
[13:17:34.083] Tweak future expression to call with '...' arguments ...
[13:17:34.083] {
[13:17:34.083]     do.call(function(...) {
[13:17:34.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.083]             on.exit(options(oopts), add = TRUE)
[13:17:34.083]         }
[13:17:34.083]         {
[13:17:34.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.083]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.083]             })
[13:17:34.083]         }
[13:17:34.083]     }, args = future.call.arguments)
[13:17:34.083] }
[13:17:34.084] Tweak future expression to call with '...' arguments ... DONE
[13:17:34.084] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.084] - packages: [1] ‘stats’
[13:17:34.084] getGlobalsAndPackages() ... DONE
[13:17:34.085] run() for ‘Future’ ...
[13:17:34.085] - state: ‘created’
[13:17:34.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:34.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:34.099]   - Field: ‘node’
[13:17:34.100]   - Field: ‘label’
[13:17:34.100]   - Field: ‘local’
[13:17:34.100]   - Field: ‘owner’
[13:17:34.100]   - Field: ‘envir’
[13:17:34.100]   - Field: ‘workers’
[13:17:34.100]   - Field: ‘packages’
[13:17:34.100]   - Field: ‘gc’
[13:17:34.100]   - Field: ‘conditions’
[13:17:34.100]   - Field: ‘persistent’
[13:17:34.100]   - Field: ‘expr’
[13:17:34.101]   - Field: ‘uuid’
[13:17:34.101]   - Field: ‘seed’
[13:17:34.101]   - Field: ‘version’
[13:17:34.101]   - Field: ‘result’
[13:17:34.101]   - Field: ‘asynchronous’
[13:17:34.101]   - Field: ‘calls’
[13:17:34.101]   - Field: ‘globals’
[13:17:34.101]   - Field: ‘stdout’
[13:17:34.101]   - Field: ‘earlySignal’
[13:17:34.101]   - Field: ‘lazy’
[13:17:34.101]   - Field: ‘state’
[13:17:34.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:34.102] - Launch lazy future ...
[13:17:34.102] Packages needed by the future expression (n = 1): ‘stats’
[13:17:34.102] Packages needed by future strategies (n = 0): <none>
[13:17:34.103] {
[13:17:34.103]     {
[13:17:34.103]         {
[13:17:34.103]             ...future.startTime <- base::Sys.time()
[13:17:34.103]             {
[13:17:34.103]                 {
[13:17:34.103]                   {
[13:17:34.103]                     {
[13:17:34.103]                       {
[13:17:34.103]                         base::local({
[13:17:34.103]                           has_future <- base::requireNamespace("future", 
[13:17:34.103]                             quietly = TRUE)
[13:17:34.103]                           if (has_future) {
[13:17:34.103]                             ns <- base::getNamespace("future")
[13:17:34.103]                             version <- ns[[".package"]][["version"]]
[13:17:34.103]                             if (is.null(version)) 
[13:17:34.103]                               version <- utils::packageVersion("future")
[13:17:34.103]                           }
[13:17:34.103]                           else {
[13:17:34.103]                             version <- NULL
[13:17:34.103]                           }
[13:17:34.103]                           if (!has_future || version < "1.8.0") {
[13:17:34.103]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:34.103]                               "", base::R.version$version.string), 
[13:17:34.103]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:34.103]                                 base::R.version$platform, 8 * 
[13:17:34.103]                                   base::.Machine$sizeof.pointer), 
[13:17:34.103]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:34.103]                                 "release", "version")], collapse = " "), 
[13:17:34.103]                               hostname = base::Sys.info()[["nodename"]])
[13:17:34.103]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:34.103]                               info)
[13:17:34.103]                             info <- base::paste(info, collapse = "; ")
[13:17:34.103]                             if (!has_future) {
[13:17:34.103]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:34.103]                                 info)
[13:17:34.103]                             }
[13:17:34.103]                             else {
[13:17:34.103]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:34.103]                                 info, version)
[13:17:34.103]                             }
[13:17:34.103]                             base::stop(msg)
[13:17:34.103]                           }
[13:17:34.103]                         })
[13:17:34.103]                       }
[13:17:34.103]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:34.103]                       base::options(mc.cores = 1L)
[13:17:34.103]                     }
[13:17:34.103]                     base::local({
[13:17:34.103]                       for (pkg in "stats") {
[13:17:34.103]                         base::loadNamespace(pkg)
[13:17:34.103]                         base::library(pkg, character.only = TRUE)
[13:17:34.103]                       }
[13:17:34.103]                     })
[13:17:34.103]                   }
[13:17:34.103]                   options(future.plan = NULL)
[13:17:34.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:34.103]                 }
[13:17:34.103]                 ...future.workdir <- getwd()
[13:17:34.103]             }
[13:17:34.103]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:34.103]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:34.103]         }
[13:17:34.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:34.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:34.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:34.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:34.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:34.103]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:34.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:34.103]             base::names(...future.oldOptions))
[13:17:34.103]     }
[13:17:34.103]     if (FALSE) {
[13:17:34.103]     }
[13:17:34.103]     else {
[13:17:34.103]         if (TRUE) {
[13:17:34.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:34.103]                 open = "w")
[13:17:34.103]         }
[13:17:34.103]         else {
[13:17:34.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:34.103]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:34.103]         }
[13:17:34.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:34.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:34.103]             base::sink(type = "output", split = FALSE)
[13:17:34.103]             base::close(...future.stdout)
[13:17:34.103]         }, add = TRUE)
[13:17:34.103]     }
[13:17:34.103]     ...future.frame <- base::sys.nframe()
[13:17:34.103]     ...future.conditions <- base::list()
[13:17:34.103]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:34.103]     if (FALSE) {
[13:17:34.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:34.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:34.103]     }
[13:17:34.103]     ...future.result <- base::tryCatch({
[13:17:34.103]         base::withCallingHandlers({
[13:17:34.103]             ...future.value <- base::withVisible(base::local({
[13:17:34.103]                 ...future.makeSendCondition <- local({
[13:17:34.103]                   sendCondition <- NULL
[13:17:34.103]                   function(frame = 1L) {
[13:17:34.103]                     if (is.function(sendCondition)) 
[13:17:34.103]                       return(sendCondition)
[13:17:34.103]                     ns <- getNamespace("parallel")
[13:17:34.103]                     if (exists("sendData", mode = "function", 
[13:17:34.103]                       envir = ns)) {
[13:17:34.103]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:34.103]                         envir = ns)
[13:17:34.103]                       envir <- sys.frame(frame)
[13:17:34.103]                       master <- NULL
[13:17:34.103]                       while (!identical(envir, .GlobalEnv) && 
[13:17:34.103]                         !identical(envir, emptyenv())) {
[13:17:34.103]                         if (exists("master", mode = "list", envir = envir, 
[13:17:34.103]                           inherits = FALSE)) {
[13:17:34.103]                           master <- get("master", mode = "list", 
[13:17:34.103]                             envir = envir, inherits = FALSE)
[13:17:34.103]                           if (inherits(master, c("SOCKnode", 
[13:17:34.103]                             "SOCK0node"))) {
[13:17:34.103]                             sendCondition <<- function(cond) {
[13:17:34.103]                               data <- list(type = "VALUE", value = cond, 
[13:17:34.103]                                 success = TRUE)
[13:17:34.103]                               parallel_sendData(master, data)
[13:17:34.103]                             }
[13:17:34.103]                             return(sendCondition)
[13:17:34.103]                           }
[13:17:34.103]                         }
[13:17:34.103]                         frame <- frame + 1L
[13:17:34.103]                         envir <- sys.frame(frame)
[13:17:34.103]                       }
[13:17:34.103]                     }
[13:17:34.103]                     sendCondition <<- function(cond) NULL
[13:17:34.103]                   }
[13:17:34.103]                 })
[13:17:34.103]                 withCallingHandlers({
[13:17:34.103]                   {
[13:17:34.103]                     do.call(function(...) {
[13:17:34.103]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.103]                       if (!identical(...future.globals.maxSize.org, 
[13:17:34.103]                         ...future.globals.maxSize)) {
[13:17:34.103]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.103]                         on.exit(options(oopts), add = TRUE)
[13:17:34.103]                       }
[13:17:34.103]                       {
[13:17:34.103]                         lapply(seq_along(...future.elements_ii), 
[13:17:34.103]                           FUN = function(jj) {
[13:17:34.103]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.103]                             ...future.FUN(...future.X_jj, ...)
[13:17:34.103]                           })
[13:17:34.103]                       }
[13:17:34.103]                     }, args = future.call.arguments)
[13:17:34.103]                   }
[13:17:34.103]                 }, immediateCondition = function(cond) {
[13:17:34.103]                   sendCondition <- ...future.makeSendCondition()
[13:17:34.103]                   sendCondition(cond)
[13:17:34.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.103]                   {
[13:17:34.103]                     inherits <- base::inherits
[13:17:34.103]                     invokeRestart <- base::invokeRestart
[13:17:34.103]                     is.null <- base::is.null
[13:17:34.103]                     muffled <- FALSE
[13:17:34.103]                     if (inherits(cond, "message")) {
[13:17:34.103]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:34.103]                       if (muffled) 
[13:17:34.103]                         invokeRestart("muffleMessage")
[13:17:34.103]                     }
[13:17:34.103]                     else if (inherits(cond, "warning")) {
[13:17:34.103]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:34.103]                       if (muffled) 
[13:17:34.103]                         invokeRestart("muffleWarning")
[13:17:34.103]                     }
[13:17:34.103]                     else if (inherits(cond, "condition")) {
[13:17:34.103]                       if (!is.null(pattern)) {
[13:17:34.103]                         computeRestarts <- base::computeRestarts
[13:17:34.103]                         grepl <- base::grepl
[13:17:34.103]                         restarts <- computeRestarts(cond)
[13:17:34.103]                         for (restart in restarts) {
[13:17:34.103]                           name <- restart$name
[13:17:34.103]                           if (is.null(name)) 
[13:17:34.103]                             next
[13:17:34.103]                           if (!grepl(pattern, name)) 
[13:17:34.103]                             next
[13:17:34.103]                           invokeRestart(restart)
[13:17:34.103]                           muffled <- TRUE
[13:17:34.103]                           break
[13:17:34.103]                         }
[13:17:34.103]                       }
[13:17:34.103]                     }
[13:17:34.103]                     invisible(muffled)
[13:17:34.103]                   }
[13:17:34.103]                   muffleCondition(cond)
[13:17:34.103]                 })
[13:17:34.103]             }))
[13:17:34.103]             future::FutureResult(value = ...future.value$value, 
[13:17:34.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.103]                   ...future.rng), globalenv = if (FALSE) 
[13:17:34.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:34.103]                     ...future.globalenv.names))
[13:17:34.103]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:34.103]         }, condition = base::local({
[13:17:34.103]             c <- base::c
[13:17:34.103]             inherits <- base::inherits
[13:17:34.103]             invokeRestart <- base::invokeRestart
[13:17:34.103]             length <- base::length
[13:17:34.103]             list <- base::list
[13:17:34.103]             seq.int <- base::seq.int
[13:17:34.103]             signalCondition <- base::signalCondition
[13:17:34.103]             sys.calls <- base::sys.calls
[13:17:34.103]             `[[` <- base::`[[`
[13:17:34.103]             `+` <- base::`+`
[13:17:34.103]             `<<-` <- base::`<<-`
[13:17:34.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:34.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:34.103]                   3L)]
[13:17:34.103]             }
[13:17:34.103]             function(cond) {
[13:17:34.103]                 is_error <- inherits(cond, "error")
[13:17:34.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:34.103]                   NULL)
[13:17:34.103]                 if (is_error) {
[13:17:34.103]                   sessionInformation <- function() {
[13:17:34.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:34.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:34.103]                       search = base::search(), system = base::Sys.info())
[13:17:34.103]                   }
[13:17:34.103]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:34.103]                     cond$call), session = sessionInformation(), 
[13:17:34.103]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:34.103]                   signalCondition(cond)
[13:17:34.103]                 }
[13:17:34.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:34.103]                 "immediateCondition"))) {
[13:17:34.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:34.103]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:34.103]                   if (TRUE && !signal) {
[13:17:34.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.103]                     {
[13:17:34.103]                       inherits <- base::inherits
[13:17:34.103]                       invokeRestart <- base::invokeRestart
[13:17:34.103]                       is.null <- base::is.null
[13:17:34.103]                       muffled <- FALSE
[13:17:34.103]                       if (inherits(cond, "message")) {
[13:17:34.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.103]                         if (muffled) 
[13:17:34.103]                           invokeRestart("muffleMessage")
[13:17:34.103]                       }
[13:17:34.103]                       else if (inherits(cond, "warning")) {
[13:17:34.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.103]                         if (muffled) 
[13:17:34.103]                           invokeRestart("muffleWarning")
[13:17:34.103]                       }
[13:17:34.103]                       else if (inherits(cond, "condition")) {
[13:17:34.103]                         if (!is.null(pattern)) {
[13:17:34.103]                           computeRestarts <- base::computeRestarts
[13:17:34.103]                           grepl <- base::grepl
[13:17:34.103]                           restarts <- computeRestarts(cond)
[13:17:34.103]                           for (restart in restarts) {
[13:17:34.103]                             name <- restart$name
[13:17:34.103]                             if (is.null(name)) 
[13:17:34.103]                               next
[13:17:34.103]                             if (!grepl(pattern, name)) 
[13:17:34.103]                               next
[13:17:34.103]                             invokeRestart(restart)
[13:17:34.103]                             muffled <- TRUE
[13:17:34.103]                             break
[13:17:34.103]                           }
[13:17:34.103]                         }
[13:17:34.103]                       }
[13:17:34.103]                       invisible(muffled)
[13:17:34.103]                     }
[13:17:34.103]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.103]                   }
[13:17:34.103]                 }
[13:17:34.103]                 else {
[13:17:34.103]                   if (TRUE) {
[13:17:34.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.103]                     {
[13:17:34.103]                       inherits <- base::inherits
[13:17:34.103]                       invokeRestart <- base::invokeRestart
[13:17:34.103]                       is.null <- base::is.null
[13:17:34.103]                       muffled <- FALSE
[13:17:34.103]                       if (inherits(cond, "message")) {
[13:17:34.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.103]                         if (muffled) 
[13:17:34.103]                           invokeRestart("muffleMessage")
[13:17:34.103]                       }
[13:17:34.103]                       else if (inherits(cond, "warning")) {
[13:17:34.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.103]                         if (muffled) 
[13:17:34.103]                           invokeRestart("muffleWarning")
[13:17:34.103]                       }
[13:17:34.103]                       else if (inherits(cond, "condition")) {
[13:17:34.103]                         if (!is.null(pattern)) {
[13:17:34.103]                           computeRestarts <- base::computeRestarts
[13:17:34.103]                           grepl <- base::grepl
[13:17:34.103]                           restarts <- computeRestarts(cond)
[13:17:34.103]                           for (restart in restarts) {
[13:17:34.103]                             name <- restart$name
[13:17:34.103]                             if (is.null(name)) 
[13:17:34.103]                               next
[13:17:34.103]                             if (!grepl(pattern, name)) 
[13:17:34.103]                               next
[13:17:34.103]                             invokeRestart(restart)
[13:17:34.103]                             muffled <- TRUE
[13:17:34.103]                             break
[13:17:34.103]                           }
[13:17:34.103]                         }
[13:17:34.103]                       }
[13:17:34.103]                       invisible(muffled)
[13:17:34.103]                     }
[13:17:34.103]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.103]                   }
[13:17:34.103]                 }
[13:17:34.103]             }
[13:17:34.103]         }))
[13:17:34.103]     }, error = function(ex) {
[13:17:34.103]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:34.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.103]                 ...future.rng), started = ...future.startTime, 
[13:17:34.103]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:34.103]             version = "1.8"), class = "FutureResult")
[13:17:34.103]     }, finally = {
[13:17:34.103]         if (!identical(...future.workdir, getwd())) 
[13:17:34.103]             setwd(...future.workdir)
[13:17:34.103]         {
[13:17:34.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:34.103]                 ...future.oldOptions$nwarnings <- NULL
[13:17:34.103]             }
[13:17:34.103]             base::options(...future.oldOptions)
[13:17:34.103]             if (.Platform$OS.type == "windows") {
[13:17:34.103]                 old_names <- names(...future.oldEnvVars)
[13:17:34.103]                 envs <- base::Sys.getenv()
[13:17:34.103]                 names <- names(envs)
[13:17:34.103]                 common <- intersect(names, old_names)
[13:17:34.103]                 added <- setdiff(names, old_names)
[13:17:34.103]                 removed <- setdiff(old_names, names)
[13:17:34.103]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:34.103]                   envs[common]]
[13:17:34.103]                 NAMES <- toupper(changed)
[13:17:34.103]                 args <- list()
[13:17:34.103]                 for (kk in seq_along(NAMES)) {
[13:17:34.103]                   name <- changed[[kk]]
[13:17:34.103]                   NAME <- NAMES[[kk]]
[13:17:34.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.103]                     next
[13:17:34.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.103]                 }
[13:17:34.103]                 NAMES <- toupper(added)
[13:17:34.103]                 for (kk in seq_along(NAMES)) {
[13:17:34.103]                   name <- added[[kk]]
[13:17:34.103]                   NAME <- NAMES[[kk]]
[13:17:34.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.103]                     next
[13:17:34.103]                   args[[name]] <- ""
[13:17:34.103]                 }
[13:17:34.103]                 NAMES <- toupper(removed)
[13:17:34.103]                 for (kk in seq_along(NAMES)) {
[13:17:34.103]                   name <- removed[[kk]]
[13:17:34.103]                   NAME <- NAMES[[kk]]
[13:17:34.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.103]                     next
[13:17:34.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.103]                 }
[13:17:34.103]                 if (length(args) > 0) 
[13:17:34.103]                   base::do.call(base::Sys.setenv, args = args)
[13:17:34.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:34.103]             }
[13:17:34.103]             else {
[13:17:34.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:34.103]             }
[13:17:34.103]             {
[13:17:34.103]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:34.103]                   0L) {
[13:17:34.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:34.103]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:34.103]                   base::options(opts)
[13:17:34.103]                 }
[13:17:34.103]                 {
[13:17:34.103]                   {
[13:17:34.103]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:34.103]                     NULL
[13:17:34.103]                   }
[13:17:34.103]                   options(future.plan = NULL)
[13:17:34.103]                   if (is.na(NA_character_)) 
[13:17:34.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:34.103]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:34.103]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:34.103]                     envir = parent.frame()) 
[13:17:34.103]                   {
[13:17:34.103]                     if (is.function(workers)) 
[13:17:34.103]                       workers <- workers()
[13:17:34.103]                     workers <- structure(as.integer(workers), 
[13:17:34.103]                       class = class(workers))
[13:17:34.103]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:34.103]                       workers >= 1)
[13:17:34.103]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:34.103]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:34.103]                     }
[13:17:34.103]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:34.103]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:34.103]                       envir = envir)
[13:17:34.103]                     if (!future$lazy) 
[13:17:34.103]                       future <- run(future)
[13:17:34.103]                     invisible(future)
[13:17:34.103]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:34.103]                 }
[13:17:34.103]             }
[13:17:34.103]         }
[13:17:34.103]     })
[13:17:34.103]     if (TRUE) {
[13:17:34.103]         base::sink(type = "output", split = FALSE)
[13:17:34.103]         if (TRUE) {
[13:17:34.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:34.103]         }
[13:17:34.103]         else {
[13:17:34.103]             ...future.result["stdout"] <- base::list(NULL)
[13:17:34.103]         }
[13:17:34.103]         base::close(...future.stdout)
[13:17:34.103]         ...future.stdout <- NULL
[13:17:34.103]     }
[13:17:34.103]     ...future.result$conditions <- ...future.conditions
[13:17:34.103]     ...future.result$finished <- base::Sys.time()
[13:17:34.103]     ...future.result
[13:17:34.103] }
[13:17:34.106] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[13:17:34.106] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:17:34.106] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:17:34.106] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[13:17:34.107] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[13:17:34.107] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:17:34.107] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:17:34.107] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:34.107] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.108] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:34.108] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.108] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[13:17:34.108] MultisessionFuture started
[13:17:34.109] - Launch lazy future ... done
[13:17:34.109] run() for ‘MultisessionFuture’ ... done
[13:17:34.109] Created future:
[13:17:34.109] MultisessionFuture:
[13:17:34.109] Label: ‘future_eapply-1’
[13:17:34.109] Expression:
[13:17:34.109] {
[13:17:34.109]     do.call(function(...) {
[13:17:34.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.109]             on.exit(options(oopts), add = TRUE)
[13:17:34.109]         }
[13:17:34.109]         {
[13:17:34.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.109]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.109]             })
[13:17:34.109]         }
[13:17:34.109]     }, args = future.call.arguments)
[13:17:34.109] }
[13:17:34.109] Lazy evaluation: FALSE
[13:17:34.109] Asynchronous evaluation: TRUE
[13:17:34.109] Local evaluation: TRUE
[13:17:34.109] Environment: R_GlobalEnv
[13:17:34.109] Capture standard output: TRUE
[13:17:34.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:34.109] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:34.109] Packages: 1 packages (‘stats’)
[13:17:34.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:34.109] Resolved: FALSE
[13:17:34.109] Value: <not collected>
[13:17:34.109] Conditions captured: <none>
[13:17:34.109] Early signaling: FALSE
[13:17:34.109] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:34.109] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.120] Chunk #1 of 2 ... DONE
[13:17:34.121] Chunk #2 of 2 ...
[13:17:34.121]  - Finding globals in 'X' for chunk #2 ...
[13:17:34.121] getGlobalsAndPackages() ...
[13:17:34.121] Searching for globals...
[13:17:34.121] 
[13:17:34.121] Searching for globals ... DONE
[13:17:34.121] - globals: [0] <none>
[13:17:34.121] getGlobalsAndPackages() ... DONE
[13:17:34.122]    + additional globals found: [n=0] 
[13:17:34.122]    + additional namespaces needed: [n=0] 
[13:17:34.122]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:34.122]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:34.122]  - seeds: <none>
[13:17:34.122] getGlobalsAndPackages() ...
[13:17:34.122] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.122] Resolving globals: FALSE
[13:17:34.122] Tweak future expression to call with '...' arguments ...
[13:17:34.123] {
[13:17:34.123]     do.call(function(...) {
[13:17:34.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.123]             on.exit(options(oopts), add = TRUE)
[13:17:34.123]         }
[13:17:34.123]         {
[13:17:34.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.123]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.123]             })
[13:17:34.123]         }
[13:17:34.123]     }, args = future.call.arguments)
[13:17:34.123] }
[13:17:34.123] Tweak future expression to call with '...' arguments ... DONE
[13:17:34.123] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.123] - packages: [1] ‘stats’
[13:17:34.123] getGlobalsAndPackages() ... DONE
[13:17:34.124] run() for ‘Future’ ...
[13:17:34.124] - state: ‘created’
[13:17:34.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:34.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:34.139]   - Field: ‘node’
[13:17:34.139]   - Field: ‘label’
[13:17:34.139]   - Field: ‘local’
[13:17:34.139]   - Field: ‘owner’
[13:17:34.139]   - Field: ‘envir’
[13:17:34.139]   - Field: ‘workers’
[13:17:34.140]   - Field: ‘packages’
[13:17:34.140]   - Field: ‘gc’
[13:17:34.140]   - Field: ‘conditions’
[13:17:34.140]   - Field: ‘persistent’
[13:17:34.140]   - Field: ‘expr’
[13:17:34.140]   - Field: ‘uuid’
[13:17:34.140]   - Field: ‘seed’
[13:17:34.140]   - Field: ‘version’
[13:17:34.140]   - Field: ‘result’
[13:17:34.140]   - Field: ‘asynchronous’
[13:17:34.141]   - Field: ‘calls’
[13:17:34.141]   - Field: ‘globals’
[13:17:34.141]   - Field: ‘stdout’
[13:17:34.141]   - Field: ‘earlySignal’
[13:17:34.141]   - Field: ‘lazy’
[13:17:34.141]   - Field: ‘state’
[13:17:34.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:34.141] - Launch lazy future ...
[13:17:34.141] Packages needed by the future expression (n = 1): ‘stats’
[13:17:34.142] Packages needed by future strategies (n = 0): <none>
[13:17:34.142] {
[13:17:34.142]     {
[13:17:34.142]         {
[13:17:34.142]             ...future.startTime <- base::Sys.time()
[13:17:34.142]             {
[13:17:34.142]                 {
[13:17:34.142]                   {
[13:17:34.142]                     {
[13:17:34.142]                       {
[13:17:34.142]                         base::local({
[13:17:34.142]                           has_future <- base::requireNamespace("future", 
[13:17:34.142]                             quietly = TRUE)
[13:17:34.142]                           if (has_future) {
[13:17:34.142]                             ns <- base::getNamespace("future")
[13:17:34.142]                             version <- ns[[".package"]][["version"]]
[13:17:34.142]                             if (is.null(version)) 
[13:17:34.142]                               version <- utils::packageVersion("future")
[13:17:34.142]                           }
[13:17:34.142]                           else {
[13:17:34.142]                             version <- NULL
[13:17:34.142]                           }
[13:17:34.142]                           if (!has_future || version < "1.8.0") {
[13:17:34.142]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:34.142]                               "", base::R.version$version.string), 
[13:17:34.142]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:34.142]                                 base::R.version$platform, 8 * 
[13:17:34.142]                                   base::.Machine$sizeof.pointer), 
[13:17:34.142]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:34.142]                                 "release", "version")], collapse = " "), 
[13:17:34.142]                               hostname = base::Sys.info()[["nodename"]])
[13:17:34.142]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:34.142]                               info)
[13:17:34.142]                             info <- base::paste(info, collapse = "; ")
[13:17:34.142]                             if (!has_future) {
[13:17:34.142]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:34.142]                                 info)
[13:17:34.142]                             }
[13:17:34.142]                             else {
[13:17:34.142]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:34.142]                                 info, version)
[13:17:34.142]                             }
[13:17:34.142]                             base::stop(msg)
[13:17:34.142]                           }
[13:17:34.142]                         })
[13:17:34.142]                       }
[13:17:34.142]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:34.142]                       base::options(mc.cores = 1L)
[13:17:34.142]                     }
[13:17:34.142]                     base::local({
[13:17:34.142]                       for (pkg in "stats") {
[13:17:34.142]                         base::loadNamespace(pkg)
[13:17:34.142]                         base::library(pkg, character.only = TRUE)
[13:17:34.142]                       }
[13:17:34.142]                     })
[13:17:34.142]                   }
[13:17:34.142]                   options(future.plan = NULL)
[13:17:34.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:34.142]                 }
[13:17:34.142]                 ...future.workdir <- getwd()
[13:17:34.142]             }
[13:17:34.142]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:34.142]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:34.142]         }
[13:17:34.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:34.142]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:34.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:34.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:34.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:34.142]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:34.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:34.142]             base::names(...future.oldOptions))
[13:17:34.142]     }
[13:17:34.142]     if (FALSE) {
[13:17:34.142]     }
[13:17:34.142]     else {
[13:17:34.142]         if (TRUE) {
[13:17:34.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:34.142]                 open = "w")
[13:17:34.142]         }
[13:17:34.142]         else {
[13:17:34.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:34.142]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:34.142]         }
[13:17:34.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:34.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:34.142]             base::sink(type = "output", split = FALSE)
[13:17:34.142]             base::close(...future.stdout)
[13:17:34.142]         }, add = TRUE)
[13:17:34.142]     }
[13:17:34.142]     ...future.frame <- base::sys.nframe()
[13:17:34.142]     ...future.conditions <- base::list()
[13:17:34.142]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:34.142]     if (FALSE) {
[13:17:34.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:34.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:34.142]     }
[13:17:34.142]     ...future.result <- base::tryCatch({
[13:17:34.142]         base::withCallingHandlers({
[13:17:34.142]             ...future.value <- base::withVisible(base::local({
[13:17:34.142]                 ...future.makeSendCondition <- local({
[13:17:34.142]                   sendCondition <- NULL
[13:17:34.142]                   function(frame = 1L) {
[13:17:34.142]                     if (is.function(sendCondition)) 
[13:17:34.142]                       return(sendCondition)
[13:17:34.142]                     ns <- getNamespace("parallel")
[13:17:34.142]                     if (exists("sendData", mode = "function", 
[13:17:34.142]                       envir = ns)) {
[13:17:34.142]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:34.142]                         envir = ns)
[13:17:34.142]                       envir <- sys.frame(frame)
[13:17:34.142]                       master <- NULL
[13:17:34.142]                       while (!identical(envir, .GlobalEnv) && 
[13:17:34.142]                         !identical(envir, emptyenv())) {
[13:17:34.142]                         if (exists("master", mode = "list", envir = envir, 
[13:17:34.142]                           inherits = FALSE)) {
[13:17:34.142]                           master <- get("master", mode = "list", 
[13:17:34.142]                             envir = envir, inherits = FALSE)
[13:17:34.142]                           if (inherits(master, c("SOCKnode", 
[13:17:34.142]                             "SOCK0node"))) {
[13:17:34.142]                             sendCondition <<- function(cond) {
[13:17:34.142]                               data <- list(type = "VALUE", value = cond, 
[13:17:34.142]                                 success = TRUE)
[13:17:34.142]                               parallel_sendData(master, data)
[13:17:34.142]                             }
[13:17:34.142]                             return(sendCondition)
[13:17:34.142]                           }
[13:17:34.142]                         }
[13:17:34.142]                         frame <- frame + 1L
[13:17:34.142]                         envir <- sys.frame(frame)
[13:17:34.142]                       }
[13:17:34.142]                     }
[13:17:34.142]                     sendCondition <<- function(cond) NULL
[13:17:34.142]                   }
[13:17:34.142]                 })
[13:17:34.142]                 withCallingHandlers({
[13:17:34.142]                   {
[13:17:34.142]                     do.call(function(...) {
[13:17:34.142]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.142]                       if (!identical(...future.globals.maxSize.org, 
[13:17:34.142]                         ...future.globals.maxSize)) {
[13:17:34.142]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.142]                         on.exit(options(oopts), add = TRUE)
[13:17:34.142]                       }
[13:17:34.142]                       {
[13:17:34.142]                         lapply(seq_along(...future.elements_ii), 
[13:17:34.142]                           FUN = function(jj) {
[13:17:34.142]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.142]                             ...future.FUN(...future.X_jj, ...)
[13:17:34.142]                           })
[13:17:34.142]                       }
[13:17:34.142]                     }, args = future.call.arguments)
[13:17:34.142]                   }
[13:17:34.142]                 }, immediateCondition = function(cond) {
[13:17:34.142]                   sendCondition <- ...future.makeSendCondition()
[13:17:34.142]                   sendCondition(cond)
[13:17:34.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.142]                   {
[13:17:34.142]                     inherits <- base::inherits
[13:17:34.142]                     invokeRestart <- base::invokeRestart
[13:17:34.142]                     is.null <- base::is.null
[13:17:34.142]                     muffled <- FALSE
[13:17:34.142]                     if (inherits(cond, "message")) {
[13:17:34.142]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:34.142]                       if (muffled) 
[13:17:34.142]                         invokeRestart("muffleMessage")
[13:17:34.142]                     }
[13:17:34.142]                     else if (inherits(cond, "warning")) {
[13:17:34.142]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:34.142]                       if (muffled) 
[13:17:34.142]                         invokeRestart("muffleWarning")
[13:17:34.142]                     }
[13:17:34.142]                     else if (inherits(cond, "condition")) {
[13:17:34.142]                       if (!is.null(pattern)) {
[13:17:34.142]                         computeRestarts <- base::computeRestarts
[13:17:34.142]                         grepl <- base::grepl
[13:17:34.142]                         restarts <- computeRestarts(cond)
[13:17:34.142]                         for (restart in restarts) {
[13:17:34.142]                           name <- restart$name
[13:17:34.142]                           if (is.null(name)) 
[13:17:34.142]                             next
[13:17:34.142]                           if (!grepl(pattern, name)) 
[13:17:34.142]                             next
[13:17:34.142]                           invokeRestart(restart)
[13:17:34.142]                           muffled <- TRUE
[13:17:34.142]                           break
[13:17:34.142]                         }
[13:17:34.142]                       }
[13:17:34.142]                     }
[13:17:34.142]                     invisible(muffled)
[13:17:34.142]                   }
[13:17:34.142]                   muffleCondition(cond)
[13:17:34.142]                 })
[13:17:34.142]             }))
[13:17:34.142]             future::FutureResult(value = ...future.value$value, 
[13:17:34.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.142]                   ...future.rng), globalenv = if (FALSE) 
[13:17:34.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:34.142]                     ...future.globalenv.names))
[13:17:34.142]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:34.142]         }, condition = base::local({
[13:17:34.142]             c <- base::c
[13:17:34.142]             inherits <- base::inherits
[13:17:34.142]             invokeRestart <- base::invokeRestart
[13:17:34.142]             length <- base::length
[13:17:34.142]             list <- base::list
[13:17:34.142]             seq.int <- base::seq.int
[13:17:34.142]             signalCondition <- base::signalCondition
[13:17:34.142]             sys.calls <- base::sys.calls
[13:17:34.142]             `[[` <- base::`[[`
[13:17:34.142]             `+` <- base::`+`
[13:17:34.142]             `<<-` <- base::`<<-`
[13:17:34.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:34.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:34.142]                   3L)]
[13:17:34.142]             }
[13:17:34.142]             function(cond) {
[13:17:34.142]                 is_error <- inherits(cond, "error")
[13:17:34.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:34.142]                   NULL)
[13:17:34.142]                 if (is_error) {
[13:17:34.142]                   sessionInformation <- function() {
[13:17:34.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:34.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:34.142]                       search = base::search(), system = base::Sys.info())
[13:17:34.142]                   }
[13:17:34.142]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:34.142]                     cond$call), session = sessionInformation(), 
[13:17:34.142]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:34.142]                   signalCondition(cond)
[13:17:34.142]                 }
[13:17:34.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:34.142]                 "immediateCondition"))) {
[13:17:34.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:34.142]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:34.142]                   if (TRUE && !signal) {
[13:17:34.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.142]                     {
[13:17:34.142]                       inherits <- base::inherits
[13:17:34.142]                       invokeRestart <- base::invokeRestart
[13:17:34.142]                       is.null <- base::is.null
[13:17:34.142]                       muffled <- FALSE
[13:17:34.142]                       if (inherits(cond, "message")) {
[13:17:34.142]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.142]                         if (muffled) 
[13:17:34.142]                           invokeRestart("muffleMessage")
[13:17:34.142]                       }
[13:17:34.142]                       else if (inherits(cond, "warning")) {
[13:17:34.142]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.142]                         if (muffled) 
[13:17:34.142]                           invokeRestart("muffleWarning")
[13:17:34.142]                       }
[13:17:34.142]                       else if (inherits(cond, "condition")) {
[13:17:34.142]                         if (!is.null(pattern)) {
[13:17:34.142]                           computeRestarts <- base::computeRestarts
[13:17:34.142]                           grepl <- base::grepl
[13:17:34.142]                           restarts <- computeRestarts(cond)
[13:17:34.142]                           for (restart in restarts) {
[13:17:34.142]                             name <- restart$name
[13:17:34.142]                             if (is.null(name)) 
[13:17:34.142]                               next
[13:17:34.142]                             if (!grepl(pattern, name)) 
[13:17:34.142]                               next
[13:17:34.142]                             invokeRestart(restart)
[13:17:34.142]                             muffled <- TRUE
[13:17:34.142]                             break
[13:17:34.142]                           }
[13:17:34.142]                         }
[13:17:34.142]                       }
[13:17:34.142]                       invisible(muffled)
[13:17:34.142]                     }
[13:17:34.142]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.142]                   }
[13:17:34.142]                 }
[13:17:34.142]                 else {
[13:17:34.142]                   if (TRUE) {
[13:17:34.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.142]                     {
[13:17:34.142]                       inherits <- base::inherits
[13:17:34.142]                       invokeRestart <- base::invokeRestart
[13:17:34.142]                       is.null <- base::is.null
[13:17:34.142]                       muffled <- FALSE
[13:17:34.142]                       if (inherits(cond, "message")) {
[13:17:34.142]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.142]                         if (muffled) 
[13:17:34.142]                           invokeRestart("muffleMessage")
[13:17:34.142]                       }
[13:17:34.142]                       else if (inherits(cond, "warning")) {
[13:17:34.142]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.142]                         if (muffled) 
[13:17:34.142]                           invokeRestart("muffleWarning")
[13:17:34.142]                       }
[13:17:34.142]                       else if (inherits(cond, "condition")) {
[13:17:34.142]                         if (!is.null(pattern)) {
[13:17:34.142]                           computeRestarts <- base::computeRestarts
[13:17:34.142]                           grepl <- base::grepl
[13:17:34.142]                           restarts <- computeRestarts(cond)
[13:17:34.142]                           for (restart in restarts) {
[13:17:34.142]                             name <- restart$name
[13:17:34.142]                             if (is.null(name)) 
[13:17:34.142]                               next
[13:17:34.142]                             if (!grepl(pattern, name)) 
[13:17:34.142]                               next
[13:17:34.142]                             invokeRestart(restart)
[13:17:34.142]                             muffled <- TRUE
[13:17:34.142]                             break
[13:17:34.142]                           }
[13:17:34.142]                         }
[13:17:34.142]                       }
[13:17:34.142]                       invisible(muffled)
[13:17:34.142]                     }
[13:17:34.142]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.142]                   }
[13:17:34.142]                 }
[13:17:34.142]             }
[13:17:34.142]         }))
[13:17:34.142]     }, error = function(ex) {
[13:17:34.142]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:34.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.142]                 ...future.rng), started = ...future.startTime, 
[13:17:34.142]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:34.142]             version = "1.8"), class = "FutureResult")
[13:17:34.142]     }, finally = {
[13:17:34.142]         if (!identical(...future.workdir, getwd())) 
[13:17:34.142]             setwd(...future.workdir)
[13:17:34.142]         {
[13:17:34.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:34.142]                 ...future.oldOptions$nwarnings <- NULL
[13:17:34.142]             }
[13:17:34.142]             base::options(...future.oldOptions)
[13:17:34.142]             if (.Platform$OS.type == "windows") {
[13:17:34.142]                 old_names <- names(...future.oldEnvVars)
[13:17:34.142]                 envs <- base::Sys.getenv()
[13:17:34.142]                 names <- names(envs)
[13:17:34.142]                 common <- intersect(names, old_names)
[13:17:34.142]                 added <- setdiff(names, old_names)
[13:17:34.142]                 removed <- setdiff(old_names, names)
[13:17:34.142]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:34.142]                   envs[common]]
[13:17:34.142]                 NAMES <- toupper(changed)
[13:17:34.142]                 args <- list()
[13:17:34.142]                 for (kk in seq_along(NAMES)) {
[13:17:34.142]                   name <- changed[[kk]]
[13:17:34.142]                   NAME <- NAMES[[kk]]
[13:17:34.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.142]                     next
[13:17:34.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.142]                 }
[13:17:34.142]                 NAMES <- toupper(added)
[13:17:34.142]                 for (kk in seq_along(NAMES)) {
[13:17:34.142]                   name <- added[[kk]]
[13:17:34.142]                   NAME <- NAMES[[kk]]
[13:17:34.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.142]                     next
[13:17:34.142]                   args[[name]] <- ""
[13:17:34.142]                 }
[13:17:34.142]                 NAMES <- toupper(removed)
[13:17:34.142]                 for (kk in seq_along(NAMES)) {
[13:17:34.142]                   name <- removed[[kk]]
[13:17:34.142]                   NAME <- NAMES[[kk]]
[13:17:34.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.142]                     next
[13:17:34.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.142]                 }
[13:17:34.142]                 if (length(args) > 0) 
[13:17:34.142]                   base::do.call(base::Sys.setenv, args = args)
[13:17:34.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:34.142]             }
[13:17:34.142]             else {
[13:17:34.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:34.142]             }
[13:17:34.142]             {
[13:17:34.142]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:34.142]                   0L) {
[13:17:34.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:34.142]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:34.142]                   base::options(opts)
[13:17:34.142]                 }
[13:17:34.142]                 {
[13:17:34.142]                   {
[13:17:34.142]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:34.142]                     NULL
[13:17:34.142]                   }
[13:17:34.142]                   options(future.plan = NULL)
[13:17:34.142]                   if (is.na(NA_character_)) 
[13:17:34.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:34.142]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:34.142]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:34.142]                     envir = parent.frame()) 
[13:17:34.142]                   {
[13:17:34.142]                     if (is.function(workers)) 
[13:17:34.142]                       workers <- workers()
[13:17:34.142]                     workers <- structure(as.integer(workers), 
[13:17:34.142]                       class = class(workers))
[13:17:34.142]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:34.142]                       workers >= 1)
[13:17:34.142]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:34.142]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:34.142]                     }
[13:17:34.142]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:34.142]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:34.142]                       envir = envir)
[13:17:34.142]                     if (!future$lazy) 
[13:17:34.142]                       future <- run(future)
[13:17:34.142]                     invisible(future)
[13:17:34.142]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:34.142]                 }
[13:17:34.142]             }
[13:17:34.142]         }
[13:17:34.142]     })
[13:17:34.142]     if (TRUE) {
[13:17:34.142]         base::sink(type = "output", split = FALSE)
[13:17:34.142]         if (TRUE) {
[13:17:34.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:34.142]         }
[13:17:34.142]         else {
[13:17:34.142]             ...future.result["stdout"] <- base::list(NULL)
[13:17:34.142]         }
[13:17:34.142]         base::close(...future.stdout)
[13:17:34.142]         ...future.stdout <- NULL
[13:17:34.142]     }
[13:17:34.142]     ...future.result$conditions <- ...future.conditions
[13:17:34.142]     ...future.result$finished <- base::Sys.time()
[13:17:34.142]     ...future.result
[13:17:34.142] }
[13:17:34.145] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[13:17:34.145] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:17:34.146] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:17:34.146] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[13:17:34.146] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[13:17:34.146] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:17:34.147] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:17:34.147] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:34.147] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:34.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.147] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[13:17:34.148] MultisessionFuture started
[13:17:34.148] - Launch lazy future ... done
[13:17:34.148] run() for ‘MultisessionFuture’ ... done
[13:17:34.148] Created future:
[13:17:34.148] MultisessionFuture:
[13:17:34.148] Label: ‘future_eapply-2’
[13:17:34.148] Expression:
[13:17:34.148] {
[13:17:34.148]     do.call(function(...) {
[13:17:34.148]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.148]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.148]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.148]             on.exit(options(oopts), add = TRUE)
[13:17:34.148]         }
[13:17:34.148]         {
[13:17:34.148]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.148]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.148]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.148]             })
[13:17:34.148]         }
[13:17:34.148]     }, args = future.call.arguments)
[13:17:34.148] }
[13:17:34.148] Lazy evaluation: FALSE
[13:17:34.148] Asynchronous evaluation: TRUE
[13:17:34.148] Local evaluation: TRUE
[13:17:34.148] Environment: R_GlobalEnv
[13:17:34.148] Capture standard output: TRUE
[13:17:34.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:34.148] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:34.148] Packages: 1 packages (‘stats’)
[13:17:34.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:34.148] Resolved: FALSE
[13:17:34.148] Value: <not collected>
[13:17:34.148] Conditions captured: <none>
[13:17:34.148] Early signaling: FALSE
[13:17:34.148] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:34.148] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.160] Chunk #2 of 2 ... DONE
[13:17:34.160] Launching 2 futures (chunks) ... DONE
[13:17:34.160] Resolving 2 futures (chunks) ...
[13:17:34.160] resolve() on list ...
[13:17:34.160]  recursive: 0
[13:17:34.161]  length: 2
[13:17:34.161] 
[13:17:34.161] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.161] - Validating connection of MultisessionFuture
[13:17:34.162] - received message: FutureResult
[13:17:34.162] - Received FutureResult
[13:17:34.162] - Erased future from FutureRegistry
[13:17:34.162] result() for ClusterFuture ...
[13:17:34.162] - result already collected: FutureResult
[13:17:34.162] result() for ClusterFuture ... done
[13:17:34.162] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.162] Future #1
[13:17:34.162] result() for ClusterFuture ...
[13:17:34.162] - result already collected: FutureResult
[13:17:34.162] result() for ClusterFuture ... done
[13:17:34.163] result() for ClusterFuture ...
[13:17:34.163] - result already collected: FutureResult
[13:17:34.163] result() for ClusterFuture ... done
[13:17:34.163] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:34.163] - nx: 2
[13:17:34.163] - relay: TRUE
[13:17:34.163] - stdout: TRUE
[13:17:34.163] - signal: TRUE
[13:17:34.163] - resignal: FALSE
[13:17:34.163] - force: TRUE
[13:17:34.163] - relayed: [n=2] FALSE, FALSE
[13:17:34.164] - queued futures: [n=2] FALSE, FALSE
[13:17:34.164]  - until=1
[13:17:34.164]  - relaying element #1
[13:17:34.164] result() for ClusterFuture ...
[13:17:34.164] - result already collected: FutureResult
[13:17:34.164] result() for ClusterFuture ... done
[13:17:34.164] result() for ClusterFuture ...
[13:17:34.164] - result already collected: FutureResult
[13:17:34.164] result() for ClusterFuture ... done
[13:17:34.164] result() for ClusterFuture ...
[13:17:34.164] - result already collected: FutureResult
[13:17:34.165] result() for ClusterFuture ... done
[13:17:34.165] result() for ClusterFuture ...
[13:17:34.165] - result already collected: FutureResult
[13:17:34.165] result() for ClusterFuture ... done
[13:17:34.165] - relayed: [n=2] TRUE, FALSE
[13:17:34.165] - queued futures: [n=2] TRUE, FALSE
[13:17:34.165] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:34.165]  length: 1 (resolved future 1)
[13:17:34.195] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.195] - Validating connection of MultisessionFuture
[13:17:34.195] - received message: FutureResult
[13:17:34.196] - Received FutureResult
[13:17:34.196] - Erased future from FutureRegistry
[13:17:34.196] result() for ClusterFuture ...
[13:17:34.196] - result already collected: FutureResult
[13:17:34.196] result() for ClusterFuture ... done
[13:17:34.196] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.196] Future #2
[13:17:34.196] result() for ClusterFuture ...
[13:17:34.196] - result already collected: FutureResult
[13:17:34.196] result() for ClusterFuture ... done
[13:17:34.197] result() for ClusterFuture ...
[13:17:34.197] - result already collected: FutureResult
[13:17:34.197] result() for ClusterFuture ... done
[13:17:34.197] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:34.197] - nx: 2
[13:17:34.197] - relay: TRUE
[13:17:34.197] - stdout: TRUE
[13:17:34.197] - signal: TRUE
[13:17:34.197] - resignal: FALSE
[13:17:34.197] - force: TRUE
[13:17:34.197] - relayed: [n=2] TRUE, FALSE
[13:17:34.198] - queued futures: [n=2] TRUE, FALSE
[13:17:34.198]  - until=2
[13:17:34.198]  - relaying element #2
[13:17:34.198] result() for ClusterFuture ...
[13:17:34.198] - result already collected: FutureResult
[13:17:34.198] result() for ClusterFuture ... done
[13:17:34.198] result() for ClusterFuture ...
[13:17:34.198] - result already collected: FutureResult
[13:17:34.198] result() for ClusterFuture ... done
[13:17:34.198] result() for ClusterFuture ...
[13:17:34.198] - result already collected: FutureResult
[13:17:34.199] result() for ClusterFuture ... done
[13:17:34.199] result() for ClusterFuture ...
[13:17:34.199] - result already collected: FutureResult
[13:17:34.199] result() for ClusterFuture ... done
[13:17:34.199] - relayed: [n=2] TRUE, TRUE
[13:17:34.199] - queued futures: [n=2] TRUE, TRUE
[13:17:34.199] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:34.199]  length: 0 (resolved future 2)
[13:17:34.199] Relaying remaining futures
[13:17:34.199] signalConditionsASAP(NULL, pos=0) ...
[13:17:34.199] - nx: 2
[13:17:34.200] - relay: TRUE
[13:17:34.200] - stdout: TRUE
[13:17:34.200] - signal: TRUE
[13:17:34.200] - resignal: FALSE
[13:17:34.200] - force: TRUE
[13:17:34.200] - relayed: [n=2] TRUE, TRUE
[13:17:34.200] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:34.200] - relayed: [n=2] TRUE, TRUE
[13:17:34.200] - queued futures: [n=2] TRUE, TRUE
[13:17:34.200] signalConditionsASAP(NULL, pos=0) ... done
[13:17:34.200] resolve() on list ... DONE
[13:17:34.201] result() for ClusterFuture ...
[13:17:34.201] - result already collected: FutureResult
[13:17:34.201] result() for ClusterFuture ... done
[13:17:34.201] result() for ClusterFuture ...
[13:17:34.201] - result already collected: FutureResult
[13:17:34.201] result() for ClusterFuture ... done
[13:17:34.201] result() for ClusterFuture ...
[13:17:34.201] - result already collected: FutureResult
[13:17:34.201] result() for ClusterFuture ... done
[13:17:34.201] result() for ClusterFuture ...
[13:17:34.201] - result already collected: FutureResult
[13:17:34.202] result() for ClusterFuture ... done
[13:17:34.202]  - Number of value chunks collected: 2
[13:17:34.202] Resolving 2 futures (chunks) ... DONE
[13:17:34.202] Reducing values from 2 chunks ...
[13:17:34.202]  - Number of values collected after concatenation: 3
[13:17:34.202]  - Number of values expected: 3
[13:17:34.202] Reducing values from 2 chunks ... DONE
[13:17:34.202] future_lapply() ... DONE
[13:17:34.203] future_lapply() ...
[13:17:34.207] Number of chunks: 2
[13:17:34.207] getGlobalsAndPackagesXApply() ...
[13:17:34.207]  - future.globals: TRUE
[13:17:34.207] getGlobalsAndPackages() ...
[13:17:34.207] Searching for globals...
[13:17:34.208] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:34.209] Searching for globals ... DONE
[13:17:34.209] Resolving globals: FALSE
[13:17:34.209] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:34.209] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:34.210] - globals: [1] ‘FUN’
[13:17:34.210] - packages: [1] ‘stats’
[13:17:34.210] getGlobalsAndPackages() ... DONE
[13:17:34.210]  - globals found/used: [n=1] ‘FUN’
[13:17:34.210]  - needed namespaces: [n=1] ‘stats’
[13:17:34.210] Finding globals ... DONE
[13:17:34.210]  - use_args: TRUE
[13:17:34.210]  - Getting '...' globals ...
[13:17:34.211] resolve() on list ...
[13:17:34.211]  recursive: 0
[13:17:34.211]  length: 1
[13:17:34.211]  elements: ‘...’
[13:17:34.211]  length: 0 (resolved future 1)
[13:17:34.211] resolve() on list ... DONE
[13:17:34.211]    - '...' content: [n=0] 
[13:17:34.211] List of 1
[13:17:34.211]  $ ...: list()
[13:17:34.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:34.211]  - attr(*, "where")=List of 1
[13:17:34.211]   ..$ ...:<environment: 0x55be3fe7c850> 
[13:17:34.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:34.211]  - attr(*, "resolved")= logi TRUE
[13:17:34.211]  - attr(*, "total_size")= num NA
[13:17:34.216]  - Getting '...' globals ... DONE
[13:17:34.216] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:34.216] List of 2
[13:17:34.216]  $ ...future.FUN:function (x, ...)  
[13:17:34.216]  $ ...          : list()
[13:17:34.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:34.216]  - attr(*, "where")=List of 2
[13:17:34.216]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:34.216]   ..$ ...          :<environment: 0x55be3fe7c850> 
[13:17:34.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:34.216]  - attr(*, "resolved")= logi FALSE
[13:17:34.216]  - attr(*, "total_size")= num 1248
[13:17:34.219] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:34.219] getGlobalsAndPackagesXApply() ... DONE
[13:17:34.219] Number of futures (= number of chunks): 2
[13:17:34.219] Launching 2 futures (chunks) ...
[13:17:34.219] Chunk #1 of 2 ...
[13:17:34.219]  - Finding globals in 'X' for chunk #1 ...
[13:17:34.219] getGlobalsAndPackages() ...
[13:17:34.219] Searching for globals...
[13:17:34.220] 
[13:17:34.220] Searching for globals ... DONE
[13:17:34.220] - globals: [0] <none>
[13:17:34.220] getGlobalsAndPackages() ... DONE
[13:17:34.220]    + additional globals found: [n=0] 
[13:17:34.220]    + additional namespaces needed: [n=0] 
[13:17:34.220]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:34.220]  - seeds: <none>
[13:17:34.220] getGlobalsAndPackages() ...
[13:17:34.220] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.220] Resolving globals: FALSE
[13:17:34.221] Tweak future expression to call with '...' arguments ...
[13:17:34.221] {
[13:17:34.221]     do.call(function(...) {
[13:17:34.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.221]             on.exit(options(oopts), add = TRUE)
[13:17:34.221]         }
[13:17:34.221]         {
[13:17:34.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.221]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.221]             })
[13:17:34.221]         }
[13:17:34.221]     }, args = future.call.arguments)
[13:17:34.221] }
[13:17:34.221] Tweak future expression to call with '...' arguments ... DONE
[13:17:34.221] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.221] - packages: [1] ‘stats’
[13:17:34.222] getGlobalsAndPackages() ... DONE
[13:17:34.222] run() for ‘Future’ ...
[13:17:34.222] - state: ‘created’
[13:17:34.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:34.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:34.237]   - Field: ‘node’
[13:17:34.237]   - Field: ‘label’
[13:17:34.237]   - Field: ‘local’
[13:17:34.237]   - Field: ‘owner’
[13:17:34.237]   - Field: ‘envir’
[13:17:34.237]   - Field: ‘workers’
[13:17:34.237]   - Field: ‘packages’
[13:17:34.237]   - Field: ‘gc’
[13:17:34.237]   - Field: ‘conditions’
[13:17:34.238]   - Field: ‘persistent’
[13:17:34.238]   - Field: ‘expr’
[13:17:34.238]   - Field: ‘uuid’
[13:17:34.238]   - Field: ‘seed’
[13:17:34.238]   - Field: ‘version’
[13:17:34.238]   - Field: ‘result’
[13:17:34.238]   - Field: ‘asynchronous’
[13:17:34.238]   - Field: ‘calls’
[13:17:34.238]   - Field: ‘globals’
[13:17:34.238]   - Field: ‘stdout’
[13:17:34.238]   - Field: ‘earlySignal’
[13:17:34.238]   - Field: ‘lazy’
[13:17:34.239]   - Field: ‘state’
[13:17:34.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:34.239] - Launch lazy future ...
[13:17:34.239] Packages needed by the future expression (n = 1): ‘stats’
[13:17:34.239] Packages needed by future strategies (n = 0): <none>
[13:17:34.240] {
[13:17:34.240]     {
[13:17:34.240]         {
[13:17:34.240]             ...future.startTime <- base::Sys.time()
[13:17:34.240]             {
[13:17:34.240]                 {
[13:17:34.240]                   {
[13:17:34.240]                     {
[13:17:34.240]                       {
[13:17:34.240]                         base::local({
[13:17:34.240]                           has_future <- base::requireNamespace("future", 
[13:17:34.240]                             quietly = TRUE)
[13:17:34.240]                           if (has_future) {
[13:17:34.240]                             ns <- base::getNamespace("future")
[13:17:34.240]                             version <- ns[[".package"]][["version"]]
[13:17:34.240]                             if (is.null(version)) 
[13:17:34.240]                               version <- utils::packageVersion("future")
[13:17:34.240]                           }
[13:17:34.240]                           else {
[13:17:34.240]                             version <- NULL
[13:17:34.240]                           }
[13:17:34.240]                           if (!has_future || version < "1.8.0") {
[13:17:34.240]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:34.240]                               "", base::R.version$version.string), 
[13:17:34.240]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:34.240]                                 base::R.version$platform, 8 * 
[13:17:34.240]                                   base::.Machine$sizeof.pointer), 
[13:17:34.240]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:34.240]                                 "release", "version")], collapse = " "), 
[13:17:34.240]                               hostname = base::Sys.info()[["nodename"]])
[13:17:34.240]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:34.240]                               info)
[13:17:34.240]                             info <- base::paste(info, collapse = "; ")
[13:17:34.240]                             if (!has_future) {
[13:17:34.240]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:34.240]                                 info)
[13:17:34.240]                             }
[13:17:34.240]                             else {
[13:17:34.240]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:34.240]                                 info, version)
[13:17:34.240]                             }
[13:17:34.240]                             base::stop(msg)
[13:17:34.240]                           }
[13:17:34.240]                         })
[13:17:34.240]                       }
[13:17:34.240]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:34.240]                       base::options(mc.cores = 1L)
[13:17:34.240]                     }
[13:17:34.240]                     base::local({
[13:17:34.240]                       for (pkg in "stats") {
[13:17:34.240]                         base::loadNamespace(pkg)
[13:17:34.240]                         base::library(pkg, character.only = TRUE)
[13:17:34.240]                       }
[13:17:34.240]                     })
[13:17:34.240]                   }
[13:17:34.240]                   options(future.plan = NULL)
[13:17:34.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:34.240]                 }
[13:17:34.240]                 ...future.workdir <- getwd()
[13:17:34.240]             }
[13:17:34.240]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:34.240]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:34.240]         }
[13:17:34.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:34.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:34.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:34.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:34.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:34.240]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:34.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:34.240]             base::names(...future.oldOptions))
[13:17:34.240]     }
[13:17:34.240]     if (FALSE) {
[13:17:34.240]     }
[13:17:34.240]     else {
[13:17:34.240]         if (TRUE) {
[13:17:34.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:34.240]                 open = "w")
[13:17:34.240]         }
[13:17:34.240]         else {
[13:17:34.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:34.240]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:34.240]         }
[13:17:34.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:34.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:34.240]             base::sink(type = "output", split = FALSE)
[13:17:34.240]             base::close(...future.stdout)
[13:17:34.240]         }, add = TRUE)
[13:17:34.240]     }
[13:17:34.240]     ...future.frame <- base::sys.nframe()
[13:17:34.240]     ...future.conditions <- base::list()
[13:17:34.240]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:34.240]     if (FALSE) {
[13:17:34.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:34.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:34.240]     }
[13:17:34.240]     ...future.result <- base::tryCatch({
[13:17:34.240]         base::withCallingHandlers({
[13:17:34.240]             ...future.value <- base::withVisible(base::local({
[13:17:34.240]                 ...future.makeSendCondition <- local({
[13:17:34.240]                   sendCondition <- NULL
[13:17:34.240]                   function(frame = 1L) {
[13:17:34.240]                     if (is.function(sendCondition)) 
[13:17:34.240]                       return(sendCondition)
[13:17:34.240]                     ns <- getNamespace("parallel")
[13:17:34.240]                     if (exists("sendData", mode = "function", 
[13:17:34.240]                       envir = ns)) {
[13:17:34.240]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:34.240]                         envir = ns)
[13:17:34.240]                       envir <- sys.frame(frame)
[13:17:34.240]                       master <- NULL
[13:17:34.240]                       while (!identical(envir, .GlobalEnv) && 
[13:17:34.240]                         !identical(envir, emptyenv())) {
[13:17:34.240]                         if (exists("master", mode = "list", envir = envir, 
[13:17:34.240]                           inherits = FALSE)) {
[13:17:34.240]                           master <- get("master", mode = "list", 
[13:17:34.240]                             envir = envir, inherits = FALSE)
[13:17:34.240]                           if (inherits(master, c("SOCKnode", 
[13:17:34.240]                             "SOCK0node"))) {
[13:17:34.240]                             sendCondition <<- function(cond) {
[13:17:34.240]                               data <- list(type = "VALUE", value = cond, 
[13:17:34.240]                                 success = TRUE)
[13:17:34.240]                               parallel_sendData(master, data)
[13:17:34.240]                             }
[13:17:34.240]                             return(sendCondition)
[13:17:34.240]                           }
[13:17:34.240]                         }
[13:17:34.240]                         frame <- frame + 1L
[13:17:34.240]                         envir <- sys.frame(frame)
[13:17:34.240]                       }
[13:17:34.240]                     }
[13:17:34.240]                     sendCondition <<- function(cond) NULL
[13:17:34.240]                   }
[13:17:34.240]                 })
[13:17:34.240]                 withCallingHandlers({
[13:17:34.240]                   {
[13:17:34.240]                     do.call(function(...) {
[13:17:34.240]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.240]                       if (!identical(...future.globals.maxSize.org, 
[13:17:34.240]                         ...future.globals.maxSize)) {
[13:17:34.240]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.240]                         on.exit(options(oopts), add = TRUE)
[13:17:34.240]                       }
[13:17:34.240]                       {
[13:17:34.240]                         lapply(seq_along(...future.elements_ii), 
[13:17:34.240]                           FUN = function(jj) {
[13:17:34.240]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.240]                             ...future.FUN(...future.X_jj, ...)
[13:17:34.240]                           })
[13:17:34.240]                       }
[13:17:34.240]                     }, args = future.call.arguments)
[13:17:34.240]                   }
[13:17:34.240]                 }, immediateCondition = function(cond) {
[13:17:34.240]                   sendCondition <- ...future.makeSendCondition()
[13:17:34.240]                   sendCondition(cond)
[13:17:34.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.240]                   {
[13:17:34.240]                     inherits <- base::inherits
[13:17:34.240]                     invokeRestart <- base::invokeRestart
[13:17:34.240]                     is.null <- base::is.null
[13:17:34.240]                     muffled <- FALSE
[13:17:34.240]                     if (inherits(cond, "message")) {
[13:17:34.240]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:34.240]                       if (muffled) 
[13:17:34.240]                         invokeRestart("muffleMessage")
[13:17:34.240]                     }
[13:17:34.240]                     else if (inherits(cond, "warning")) {
[13:17:34.240]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:34.240]                       if (muffled) 
[13:17:34.240]                         invokeRestart("muffleWarning")
[13:17:34.240]                     }
[13:17:34.240]                     else if (inherits(cond, "condition")) {
[13:17:34.240]                       if (!is.null(pattern)) {
[13:17:34.240]                         computeRestarts <- base::computeRestarts
[13:17:34.240]                         grepl <- base::grepl
[13:17:34.240]                         restarts <- computeRestarts(cond)
[13:17:34.240]                         for (restart in restarts) {
[13:17:34.240]                           name <- restart$name
[13:17:34.240]                           if (is.null(name)) 
[13:17:34.240]                             next
[13:17:34.240]                           if (!grepl(pattern, name)) 
[13:17:34.240]                             next
[13:17:34.240]                           invokeRestart(restart)
[13:17:34.240]                           muffled <- TRUE
[13:17:34.240]                           break
[13:17:34.240]                         }
[13:17:34.240]                       }
[13:17:34.240]                     }
[13:17:34.240]                     invisible(muffled)
[13:17:34.240]                   }
[13:17:34.240]                   muffleCondition(cond)
[13:17:34.240]                 })
[13:17:34.240]             }))
[13:17:34.240]             future::FutureResult(value = ...future.value$value, 
[13:17:34.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.240]                   ...future.rng), globalenv = if (FALSE) 
[13:17:34.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:34.240]                     ...future.globalenv.names))
[13:17:34.240]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:34.240]         }, condition = base::local({
[13:17:34.240]             c <- base::c
[13:17:34.240]             inherits <- base::inherits
[13:17:34.240]             invokeRestart <- base::invokeRestart
[13:17:34.240]             length <- base::length
[13:17:34.240]             list <- base::list
[13:17:34.240]             seq.int <- base::seq.int
[13:17:34.240]             signalCondition <- base::signalCondition
[13:17:34.240]             sys.calls <- base::sys.calls
[13:17:34.240]             `[[` <- base::`[[`
[13:17:34.240]             `+` <- base::`+`
[13:17:34.240]             `<<-` <- base::`<<-`
[13:17:34.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:34.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:34.240]                   3L)]
[13:17:34.240]             }
[13:17:34.240]             function(cond) {
[13:17:34.240]                 is_error <- inherits(cond, "error")
[13:17:34.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:34.240]                   NULL)
[13:17:34.240]                 if (is_error) {
[13:17:34.240]                   sessionInformation <- function() {
[13:17:34.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:34.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:34.240]                       search = base::search(), system = base::Sys.info())
[13:17:34.240]                   }
[13:17:34.240]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:34.240]                     cond$call), session = sessionInformation(), 
[13:17:34.240]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:34.240]                   signalCondition(cond)
[13:17:34.240]                 }
[13:17:34.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:34.240]                 "immediateCondition"))) {
[13:17:34.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:34.240]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:34.240]                   if (TRUE && !signal) {
[13:17:34.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.240]                     {
[13:17:34.240]                       inherits <- base::inherits
[13:17:34.240]                       invokeRestart <- base::invokeRestart
[13:17:34.240]                       is.null <- base::is.null
[13:17:34.240]                       muffled <- FALSE
[13:17:34.240]                       if (inherits(cond, "message")) {
[13:17:34.240]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.240]                         if (muffled) 
[13:17:34.240]                           invokeRestart("muffleMessage")
[13:17:34.240]                       }
[13:17:34.240]                       else if (inherits(cond, "warning")) {
[13:17:34.240]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.240]                         if (muffled) 
[13:17:34.240]                           invokeRestart("muffleWarning")
[13:17:34.240]                       }
[13:17:34.240]                       else if (inherits(cond, "condition")) {
[13:17:34.240]                         if (!is.null(pattern)) {
[13:17:34.240]                           computeRestarts <- base::computeRestarts
[13:17:34.240]                           grepl <- base::grepl
[13:17:34.240]                           restarts <- computeRestarts(cond)
[13:17:34.240]                           for (restart in restarts) {
[13:17:34.240]                             name <- restart$name
[13:17:34.240]                             if (is.null(name)) 
[13:17:34.240]                               next
[13:17:34.240]                             if (!grepl(pattern, name)) 
[13:17:34.240]                               next
[13:17:34.240]                             invokeRestart(restart)
[13:17:34.240]                             muffled <- TRUE
[13:17:34.240]                             break
[13:17:34.240]                           }
[13:17:34.240]                         }
[13:17:34.240]                       }
[13:17:34.240]                       invisible(muffled)
[13:17:34.240]                     }
[13:17:34.240]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.240]                   }
[13:17:34.240]                 }
[13:17:34.240]                 else {
[13:17:34.240]                   if (TRUE) {
[13:17:34.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.240]                     {
[13:17:34.240]                       inherits <- base::inherits
[13:17:34.240]                       invokeRestart <- base::invokeRestart
[13:17:34.240]                       is.null <- base::is.null
[13:17:34.240]                       muffled <- FALSE
[13:17:34.240]                       if (inherits(cond, "message")) {
[13:17:34.240]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.240]                         if (muffled) 
[13:17:34.240]                           invokeRestart("muffleMessage")
[13:17:34.240]                       }
[13:17:34.240]                       else if (inherits(cond, "warning")) {
[13:17:34.240]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.240]                         if (muffled) 
[13:17:34.240]                           invokeRestart("muffleWarning")
[13:17:34.240]                       }
[13:17:34.240]                       else if (inherits(cond, "condition")) {
[13:17:34.240]                         if (!is.null(pattern)) {
[13:17:34.240]                           computeRestarts <- base::computeRestarts
[13:17:34.240]                           grepl <- base::grepl
[13:17:34.240]                           restarts <- computeRestarts(cond)
[13:17:34.240]                           for (restart in restarts) {
[13:17:34.240]                             name <- restart$name
[13:17:34.240]                             if (is.null(name)) 
[13:17:34.240]                               next
[13:17:34.240]                             if (!grepl(pattern, name)) 
[13:17:34.240]                               next
[13:17:34.240]                             invokeRestart(restart)
[13:17:34.240]                             muffled <- TRUE
[13:17:34.240]                             break
[13:17:34.240]                           }
[13:17:34.240]                         }
[13:17:34.240]                       }
[13:17:34.240]                       invisible(muffled)
[13:17:34.240]                     }
[13:17:34.240]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.240]                   }
[13:17:34.240]                 }
[13:17:34.240]             }
[13:17:34.240]         }))
[13:17:34.240]     }, error = function(ex) {
[13:17:34.240]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:34.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.240]                 ...future.rng), started = ...future.startTime, 
[13:17:34.240]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:34.240]             version = "1.8"), class = "FutureResult")
[13:17:34.240]     }, finally = {
[13:17:34.240]         if (!identical(...future.workdir, getwd())) 
[13:17:34.240]             setwd(...future.workdir)
[13:17:34.240]         {
[13:17:34.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:34.240]                 ...future.oldOptions$nwarnings <- NULL
[13:17:34.240]             }
[13:17:34.240]             base::options(...future.oldOptions)
[13:17:34.240]             if (.Platform$OS.type == "windows") {
[13:17:34.240]                 old_names <- names(...future.oldEnvVars)
[13:17:34.240]                 envs <- base::Sys.getenv()
[13:17:34.240]                 names <- names(envs)
[13:17:34.240]                 common <- intersect(names, old_names)
[13:17:34.240]                 added <- setdiff(names, old_names)
[13:17:34.240]                 removed <- setdiff(old_names, names)
[13:17:34.240]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:34.240]                   envs[common]]
[13:17:34.240]                 NAMES <- toupper(changed)
[13:17:34.240]                 args <- list()
[13:17:34.240]                 for (kk in seq_along(NAMES)) {
[13:17:34.240]                   name <- changed[[kk]]
[13:17:34.240]                   NAME <- NAMES[[kk]]
[13:17:34.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.240]                     next
[13:17:34.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.240]                 }
[13:17:34.240]                 NAMES <- toupper(added)
[13:17:34.240]                 for (kk in seq_along(NAMES)) {
[13:17:34.240]                   name <- added[[kk]]
[13:17:34.240]                   NAME <- NAMES[[kk]]
[13:17:34.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.240]                     next
[13:17:34.240]                   args[[name]] <- ""
[13:17:34.240]                 }
[13:17:34.240]                 NAMES <- toupper(removed)
[13:17:34.240]                 for (kk in seq_along(NAMES)) {
[13:17:34.240]                   name <- removed[[kk]]
[13:17:34.240]                   NAME <- NAMES[[kk]]
[13:17:34.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.240]                     next
[13:17:34.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.240]                 }
[13:17:34.240]                 if (length(args) > 0) 
[13:17:34.240]                   base::do.call(base::Sys.setenv, args = args)
[13:17:34.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:34.240]             }
[13:17:34.240]             else {
[13:17:34.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:34.240]             }
[13:17:34.240]             {
[13:17:34.240]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:34.240]                   0L) {
[13:17:34.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:34.240]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:34.240]                   base::options(opts)
[13:17:34.240]                 }
[13:17:34.240]                 {
[13:17:34.240]                   {
[13:17:34.240]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:34.240]                     NULL
[13:17:34.240]                   }
[13:17:34.240]                   options(future.plan = NULL)
[13:17:34.240]                   if (is.na(NA_character_)) 
[13:17:34.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:34.240]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:34.240]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:34.240]                     envir = parent.frame()) 
[13:17:34.240]                   {
[13:17:34.240]                     if (is.function(workers)) 
[13:17:34.240]                       workers <- workers()
[13:17:34.240]                     workers <- structure(as.integer(workers), 
[13:17:34.240]                       class = class(workers))
[13:17:34.240]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:34.240]                       workers >= 1)
[13:17:34.240]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:34.240]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:34.240]                     }
[13:17:34.240]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:34.240]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:34.240]                       envir = envir)
[13:17:34.240]                     if (!future$lazy) 
[13:17:34.240]                       future <- run(future)
[13:17:34.240]                     invisible(future)
[13:17:34.240]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:34.240]                 }
[13:17:34.240]             }
[13:17:34.240]         }
[13:17:34.240]     })
[13:17:34.240]     if (TRUE) {
[13:17:34.240]         base::sink(type = "output", split = FALSE)
[13:17:34.240]         if (TRUE) {
[13:17:34.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:34.240]         }
[13:17:34.240]         else {
[13:17:34.240]             ...future.result["stdout"] <- base::list(NULL)
[13:17:34.240]         }
[13:17:34.240]         base::close(...future.stdout)
[13:17:34.240]         ...future.stdout <- NULL
[13:17:34.240]     }
[13:17:34.240]     ...future.result$conditions <- ...future.conditions
[13:17:34.240]     ...future.result$finished <- base::Sys.time()
[13:17:34.240]     ...future.result
[13:17:34.240] }
[13:17:34.242] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[13:17:34.243] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:17:34.243] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:17:34.243] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:34.244] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.244] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:17:34.244] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:17:34.244] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:34.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.245] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:34.245] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.245] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[13:17:34.246] MultisessionFuture started
[13:17:34.246] - Launch lazy future ... done
[13:17:34.246] run() for ‘MultisessionFuture’ ... done
[13:17:34.246] Created future:
[13:17:34.246] MultisessionFuture:
[13:17:34.246] Label: ‘future_eapply-1’
[13:17:34.246] Expression:
[13:17:34.246] {
[13:17:34.246]     do.call(function(...) {
[13:17:34.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.246]             on.exit(options(oopts), add = TRUE)
[13:17:34.246]         }
[13:17:34.246]         {
[13:17:34.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.246]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.246]             })
[13:17:34.246]         }
[13:17:34.246]     }, args = future.call.arguments)
[13:17:34.246] }
[13:17:34.246] Lazy evaluation: FALSE
[13:17:34.246] Asynchronous evaluation: TRUE
[13:17:34.246] Local evaluation: TRUE
[13:17:34.246] Environment: R_GlobalEnv
[13:17:34.246] Capture standard output: TRUE
[13:17:34.246] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:34.246] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:34.246] Packages: 1 packages (‘stats’)
[13:17:34.246] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:34.246] Resolved: FALSE
[13:17:34.246] Value: <not collected>
[13:17:34.246] Conditions captured: <none>
[13:17:34.246] Early signaling: FALSE
[13:17:34.246] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:34.246] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.258] Chunk #1 of 2 ... DONE
[13:17:34.258] Chunk #2 of 2 ...
[13:17:34.258]  - Finding globals in 'X' for chunk #2 ...
[13:17:34.258] getGlobalsAndPackages() ...
[13:17:34.258] Searching for globals...
[13:17:34.258] 
[13:17:34.259] Searching for globals ... DONE
[13:17:34.259] - globals: [0] <none>
[13:17:34.259] getGlobalsAndPackages() ... DONE
[13:17:34.259]    + additional globals found: [n=0] 
[13:17:34.259]    + additional namespaces needed: [n=0] 
[13:17:34.259]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:34.259]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:34.259]  - seeds: <none>
[13:17:34.259] getGlobalsAndPackages() ...
[13:17:34.259] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.260] Resolving globals: FALSE
[13:17:34.260] Tweak future expression to call with '...' arguments ...
[13:17:34.260] {
[13:17:34.260]     do.call(function(...) {
[13:17:34.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.260]             on.exit(options(oopts), add = TRUE)
[13:17:34.260]         }
[13:17:34.260]         {
[13:17:34.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.260]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.260]             })
[13:17:34.260]         }
[13:17:34.260]     }, args = future.call.arguments)
[13:17:34.260] }
[13:17:34.260] Tweak future expression to call with '...' arguments ... DONE
[13:17:34.260] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.261] - packages: [1] ‘stats’
[13:17:34.261] getGlobalsAndPackages() ... DONE
[13:17:34.261] run() for ‘Future’ ...
[13:17:34.261] - state: ‘created’
[13:17:34.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:34.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:34.277]   - Field: ‘node’
[13:17:34.277]   - Field: ‘label’
[13:17:34.278]   - Field: ‘local’
[13:17:34.278]   - Field: ‘owner’
[13:17:34.278]   - Field: ‘envir’
[13:17:34.278]   - Field: ‘workers’
[13:17:34.278]   - Field: ‘packages’
[13:17:34.278]   - Field: ‘gc’
[13:17:34.278]   - Field: ‘conditions’
[13:17:34.278]   - Field: ‘persistent’
[13:17:34.278]   - Field: ‘expr’
[13:17:34.278]   - Field: ‘uuid’
[13:17:34.279]   - Field: ‘seed’
[13:17:34.279]   - Field: ‘version’
[13:17:34.279]   - Field: ‘result’
[13:17:34.279]   - Field: ‘asynchronous’
[13:17:34.279]   - Field: ‘calls’
[13:17:34.279]   - Field: ‘globals’
[13:17:34.279]   - Field: ‘stdout’
[13:17:34.279]   - Field: ‘earlySignal’
[13:17:34.279]   - Field: ‘lazy’
[13:17:34.279]   - Field: ‘state’
[13:17:34.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:34.280] - Launch lazy future ...
[13:17:34.280] Packages needed by the future expression (n = 1): ‘stats’
[13:17:34.280] Packages needed by future strategies (n = 0): <none>
[13:17:34.280] {
[13:17:34.280]     {
[13:17:34.280]         {
[13:17:34.280]             ...future.startTime <- base::Sys.time()
[13:17:34.280]             {
[13:17:34.280]                 {
[13:17:34.280]                   {
[13:17:34.280]                     {
[13:17:34.280]                       {
[13:17:34.280]                         base::local({
[13:17:34.280]                           has_future <- base::requireNamespace("future", 
[13:17:34.280]                             quietly = TRUE)
[13:17:34.280]                           if (has_future) {
[13:17:34.280]                             ns <- base::getNamespace("future")
[13:17:34.280]                             version <- ns[[".package"]][["version"]]
[13:17:34.280]                             if (is.null(version)) 
[13:17:34.280]                               version <- utils::packageVersion("future")
[13:17:34.280]                           }
[13:17:34.280]                           else {
[13:17:34.280]                             version <- NULL
[13:17:34.280]                           }
[13:17:34.280]                           if (!has_future || version < "1.8.0") {
[13:17:34.280]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:34.280]                               "", base::R.version$version.string), 
[13:17:34.280]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:34.280]                                 base::R.version$platform, 8 * 
[13:17:34.280]                                   base::.Machine$sizeof.pointer), 
[13:17:34.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:34.280]                                 "release", "version")], collapse = " "), 
[13:17:34.280]                               hostname = base::Sys.info()[["nodename"]])
[13:17:34.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:34.280]                               info)
[13:17:34.280]                             info <- base::paste(info, collapse = "; ")
[13:17:34.280]                             if (!has_future) {
[13:17:34.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:34.280]                                 info)
[13:17:34.280]                             }
[13:17:34.280]                             else {
[13:17:34.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:34.280]                                 info, version)
[13:17:34.280]                             }
[13:17:34.280]                             base::stop(msg)
[13:17:34.280]                           }
[13:17:34.280]                         })
[13:17:34.280]                       }
[13:17:34.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:34.280]                       base::options(mc.cores = 1L)
[13:17:34.280]                     }
[13:17:34.280]                     base::local({
[13:17:34.280]                       for (pkg in "stats") {
[13:17:34.280]                         base::loadNamespace(pkg)
[13:17:34.280]                         base::library(pkg, character.only = TRUE)
[13:17:34.280]                       }
[13:17:34.280]                     })
[13:17:34.280]                   }
[13:17:34.280]                   options(future.plan = NULL)
[13:17:34.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:34.280]                 }
[13:17:34.280]                 ...future.workdir <- getwd()
[13:17:34.280]             }
[13:17:34.280]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:34.280]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:34.280]         }
[13:17:34.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:34.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:34.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:34.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:34.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:34.280]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:34.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:34.280]             base::names(...future.oldOptions))
[13:17:34.280]     }
[13:17:34.280]     if (FALSE) {
[13:17:34.280]     }
[13:17:34.280]     else {
[13:17:34.280]         if (TRUE) {
[13:17:34.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:34.280]                 open = "w")
[13:17:34.280]         }
[13:17:34.280]         else {
[13:17:34.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:34.280]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:34.280]         }
[13:17:34.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:34.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:34.280]             base::sink(type = "output", split = FALSE)
[13:17:34.280]             base::close(...future.stdout)
[13:17:34.280]         }, add = TRUE)
[13:17:34.280]     }
[13:17:34.280]     ...future.frame <- base::sys.nframe()
[13:17:34.280]     ...future.conditions <- base::list()
[13:17:34.280]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:34.280]     if (FALSE) {
[13:17:34.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:34.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:34.280]     }
[13:17:34.280]     ...future.result <- base::tryCatch({
[13:17:34.280]         base::withCallingHandlers({
[13:17:34.280]             ...future.value <- base::withVisible(base::local({
[13:17:34.280]                 ...future.makeSendCondition <- local({
[13:17:34.280]                   sendCondition <- NULL
[13:17:34.280]                   function(frame = 1L) {
[13:17:34.280]                     if (is.function(sendCondition)) 
[13:17:34.280]                       return(sendCondition)
[13:17:34.280]                     ns <- getNamespace("parallel")
[13:17:34.280]                     if (exists("sendData", mode = "function", 
[13:17:34.280]                       envir = ns)) {
[13:17:34.280]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:34.280]                         envir = ns)
[13:17:34.280]                       envir <- sys.frame(frame)
[13:17:34.280]                       master <- NULL
[13:17:34.280]                       while (!identical(envir, .GlobalEnv) && 
[13:17:34.280]                         !identical(envir, emptyenv())) {
[13:17:34.280]                         if (exists("master", mode = "list", envir = envir, 
[13:17:34.280]                           inherits = FALSE)) {
[13:17:34.280]                           master <- get("master", mode = "list", 
[13:17:34.280]                             envir = envir, inherits = FALSE)
[13:17:34.280]                           if (inherits(master, c("SOCKnode", 
[13:17:34.280]                             "SOCK0node"))) {
[13:17:34.280]                             sendCondition <<- function(cond) {
[13:17:34.280]                               data <- list(type = "VALUE", value = cond, 
[13:17:34.280]                                 success = TRUE)
[13:17:34.280]                               parallel_sendData(master, data)
[13:17:34.280]                             }
[13:17:34.280]                             return(sendCondition)
[13:17:34.280]                           }
[13:17:34.280]                         }
[13:17:34.280]                         frame <- frame + 1L
[13:17:34.280]                         envir <- sys.frame(frame)
[13:17:34.280]                       }
[13:17:34.280]                     }
[13:17:34.280]                     sendCondition <<- function(cond) NULL
[13:17:34.280]                   }
[13:17:34.280]                 })
[13:17:34.280]                 withCallingHandlers({
[13:17:34.280]                   {
[13:17:34.280]                     do.call(function(...) {
[13:17:34.280]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.280]                       if (!identical(...future.globals.maxSize.org, 
[13:17:34.280]                         ...future.globals.maxSize)) {
[13:17:34.280]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.280]                         on.exit(options(oopts), add = TRUE)
[13:17:34.280]                       }
[13:17:34.280]                       {
[13:17:34.280]                         lapply(seq_along(...future.elements_ii), 
[13:17:34.280]                           FUN = function(jj) {
[13:17:34.280]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.280]                             ...future.FUN(...future.X_jj, ...)
[13:17:34.280]                           })
[13:17:34.280]                       }
[13:17:34.280]                     }, args = future.call.arguments)
[13:17:34.280]                   }
[13:17:34.280]                 }, immediateCondition = function(cond) {
[13:17:34.280]                   sendCondition <- ...future.makeSendCondition()
[13:17:34.280]                   sendCondition(cond)
[13:17:34.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.280]                   {
[13:17:34.280]                     inherits <- base::inherits
[13:17:34.280]                     invokeRestart <- base::invokeRestart
[13:17:34.280]                     is.null <- base::is.null
[13:17:34.280]                     muffled <- FALSE
[13:17:34.280]                     if (inherits(cond, "message")) {
[13:17:34.280]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:34.280]                       if (muffled) 
[13:17:34.280]                         invokeRestart("muffleMessage")
[13:17:34.280]                     }
[13:17:34.280]                     else if (inherits(cond, "warning")) {
[13:17:34.280]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:34.280]                       if (muffled) 
[13:17:34.280]                         invokeRestart("muffleWarning")
[13:17:34.280]                     }
[13:17:34.280]                     else if (inherits(cond, "condition")) {
[13:17:34.280]                       if (!is.null(pattern)) {
[13:17:34.280]                         computeRestarts <- base::computeRestarts
[13:17:34.280]                         grepl <- base::grepl
[13:17:34.280]                         restarts <- computeRestarts(cond)
[13:17:34.280]                         for (restart in restarts) {
[13:17:34.280]                           name <- restart$name
[13:17:34.280]                           if (is.null(name)) 
[13:17:34.280]                             next
[13:17:34.280]                           if (!grepl(pattern, name)) 
[13:17:34.280]                             next
[13:17:34.280]                           invokeRestart(restart)
[13:17:34.280]                           muffled <- TRUE
[13:17:34.280]                           break
[13:17:34.280]                         }
[13:17:34.280]                       }
[13:17:34.280]                     }
[13:17:34.280]                     invisible(muffled)
[13:17:34.280]                   }
[13:17:34.280]                   muffleCondition(cond)
[13:17:34.280]                 })
[13:17:34.280]             }))
[13:17:34.280]             future::FutureResult(value = ...future.value$value, 
[13:17:34.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.280]                   ...future.rng), globalenv = if (FALSE) 
[13:17:34.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:34.280]                     ...future.globalenv.names))
[13:17:34.280]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:34.280]         }, condition = base::local({
[13:17:34.280]             c <- base::c
[13:17:34.280]             inherits <- base::inherits
[13:17:34.280]             invokeRestart <- base::invokeRestart
[13:17:34.280]             length <- base::length
[13:17:34.280]             list <- base::list
[13:17:34.280]             seq.int <- base::seq.int
[13:17:34.280]             signalCondition <- base::signalCondition
[13:17:34.280]             sys.calls <- base::sys.calls
[13:17:34.280]             `[[` <- base::`[[`
[13:17:34.280]             `+` <- base::`+`
[13:17:34.280]             `<<-` <- base::`<<-`
[13:17:34.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:34.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:34.280]                   3L)]
[13:17:34.280]             }
[13:17:34.280]             function(cond) {
[13:17:34.280]                 is_error <- inherits(cond, "error")
[13:17:34.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:34.280]                   NULL)
[13:17:34.280]                 if (is_error) {
[13:17:34.280]                   sessionInformation <- function() {
[13:17:34.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:34.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:34.280]                       search = base::search(), system = base::Sys.info())
[13:17:34.280]                   }
[13:17:34.280]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:34.280]                     cond$call), session = sessionInformation(), 
[13:17:34.280]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:34.280]                   signalCondition(cond)
[13:17:34.280]                 }
[13:17:34.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:34.280]                 "immediateCondition"))) {
[13:17:34.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:34.280]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:34.280]                   if (TRUE && !signal) {
[13:17:34.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.280]                     {
[13:17:34.280]                       inherits <- base::inherits
[13:17:34.280]                       invokeRestart <- base::invokeRestart
[13:17:34.280]                       is.null <- base::is.null
[13:17:34.280]                       muffled <- FALSE
[13:17:34.280]                       if (inherits(cond, "message")) {
[13:17:34.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.280]                         if (muffled) 
[13:17:34.280]                           invokeRestart("muffleMessage")
[13:17:34.280]                       }
[13:17:34.280]                       else if (inherits(cond, "warning")) {
[13:17:34.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.280]                         if (muffled) 
[13:17:34.280]                           invokeRestart("muffleWarning")
[13:17:34.280]                       }
[13:17:34.280]                       else if (inherits(cond, "condition")) {
[13:17:34.280]                         if (!is.null(pattern)) {
[13:17:34.280]                           computeRestarts <- base::computeRestarts
[13:17:34.280]                           grepl <- base::grepl
[13:17:34.280]                           restarts <- computeRestarts(cond)
[13:17:34.280]                           for (restart in restarts) {
[13:17:34.280]                             name <- restart$name
[13:17:34.280]                             if (is.null(name)) 
[13:17:34.280]                               next
[13:17:34.280]                             if (!grepl(pattern, name)) 
[13:17:34.280]                               next
[13:17:34.280]                             invokeRestart(restart)
[13:17:34.280]                             muffled <- TRUE
[13:17:34.280]                             break
[13:17:34.280]                           }
[13:17:34.280]                         }
[13:17:34.280]                       }
[13:17:34.280]                       invisible(muffled)
[13:17:34.280]                     }
[13:17:34.280]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.280]                   }
[13:17:34.280]                 }
[13:17:34.280]                 else {
[13:17:34.280]                   if (TRUE) {
[13:17:34.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.280]                     {
[13:17:34.280]                       inherits <- base::inherits
[13:17:34.280]                       invokeRestart <- base::invokeRestart
[13:17:34.280]                       is.null <- base::is.null
[13:17:34.280]                       muffled <- FALSE
[13:17:34.280]                       if (inherits(cond, "message")) {
[13:17:34.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.280]                         if (muffled) 
[13:17:34.280]                           invokeRestart("muffleMessage")
[13:17:34.280]                       }
[13:17:34.280]                       else if (inherits(cond, "warning")) {
[13:17:34.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.280]                         if (muffled) 
[13:17:34.280]                           invokeRestart("muffleWarning")
[13:17:34.280]                       }
[13:17:34.280]                       else if (inherits(cond, "condition")) {
[13:17:34.280]                         if (!is.null(pattern)) {
[13:17:34.280]                           computeRestarts <- base::computeRestarts
[13:17:34.280]                           grepl <- base::grepl
[13:17:34.280]                           restarts <- computeRestarts(cond)
[13:17:34.280]                           for (restart in restarts) {
[13:17:34.280]                             name <- restart$name
[13:17:34.280]                             if (is.null(name)) 
[13:17:34.280]                               next
[13:17:34.280]                             if (!grepl(pattern, name)) 
[13:17:34.280]                               next
[13:17:34.280]                             invokeRestart(restart)
[13:17:34.280]                             muffled <- TRUE
[13:17:34.280]                             break
[13:17:34.280]                           }
[13:17:34.280]                         }
[13:17:34.280]                       }
[13:17:34.280]                       invisible(muffled)
[13:17:34.280]                     }
[13:17:34.280]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.280]                   }
[13:17:34.280]                 }
[13:17:34.280]             }
[13:17:34.280]         }))
[13:17:34.280]     }, error = function(ex) {
[13:17:34.280]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:34.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.280]                 ...future.rng), started = ...future.startTime, 
[13:17:34.280]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:34.280]             version = "1.8"), class = "FutureResult")
[13:17:34.280]     }, finally = {
[13:17:34.280]         if (!identical(...future.workdir, getwd())) 
[13:17:34.280]             setwd(...future.workdir)
[13:17:34.280]         {
[13:17:34.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:34.280]                 ...future.oldOptions$nwarnings <- NULL
[13:17:34.280]             }
[13:17:34.280]             base::options(...future.oldOptions)
[13:17:34.280]             if (.Platform$OS.type == "windows") {
[13:17:34.280]                 old_names <- names(...future.oldEnvVars)
[13:17:34.280]                 envs <- base::Sys.getenv()
[13:17:34.280]                 names <- names(envs)
[13:17:34.280]                 common <- intersect(names, old_names)
[13:17:34.280]                 added <- setdiff(names, old_names)
[13:17:34.280]                 removed <- setdiff(old_names, names)
[13:17:34.280]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:34.280]                   envs[common]]
[13:17:34.280]                 NAMES <- toupper(changed)
[13:17:34.280]                 args <- list()
[13:17:34.280]                 for (kk in seq_along(NAMES)) {
[13:17:34.280]                   name <- changed[[kk]]
[13:17:34.280]                   NAME <- NAMES[[kk]]
[13:17:34.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.280]                     next
[13:17:34.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.280]                 }
[13:17:34.280]                 NAMES <- toupper(added)
[13:17:34.280]                 for (kk in seq_along(NAMES)) {
[13:17:34.280]                   name <- added[[kk]]
[13:17:34.280]                   NAME <- NAMES[[kk]]
[13:17:34.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.280]                     next
[13:17:34.280]                   args[[name]] <- ""
[13:17:34.280]                 }
[13:17:34.280]                 NAMES <- toupper(removed)
[13:17:34.280]                 for (kk in seq_along(NAMES)) {
[13:17:34.280]                   name <- removed[[kk]]
[13:17:34.280]                   NAME <- NAMES[[kk]]
[13:17:34.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.280]                     next
[13:17:34.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.280]                 }
[13:17:34.280]                 if (length(args) > 0) 
[13:17:34.280]                   base::do.call(base::Sys.setenv, args = args)
[13:17:34.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:34.280]             }
[13:17:34.280]             else {
[13:17:34.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:34.280]             }
[13:17:34.280]             {
[13:17:34.280]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:34.280]                   0L) {
[13:17:34.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:34.280]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:34.280]                   base::options(opts)
[13:17:34.280]                 }
[13:17:34.280]                 {
[13:17:34.280]                   {
[13:17:34.280]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:34.280]                     NULL
[13:17:34.280]                   }
[13:17:34.280]                   options(future.plan = NULL)
[13:17:34.280]                   if (is.na(NA_character_)) 
[13:17:34.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:34.280]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:34.280]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:34.280]                     envir = parent.frame()) 
[13:17:34.280]                   {
[13:17:34.280]                     if (is.function(workers)) 
[13:17:34.280]                       workers <- workers()
[13:17:34.280]                     workers <- structure(as.integer(workers), 
[13:17:34.280]                       class = class(workers))
[13:17:34.280]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:34.280]                       workers >= 1)
[13:17:34.280]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:34.280]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:34.280]                     }
[13:17:34.280]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:34.280]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:34.280]                       envir = envir)
[13:17:34.280]                     if (!future$lazy) 
[13:17:34.280]                       future <- run(future)
[13:17:34.280]                     invisible(future)
[13:17:34.280]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:34.280]                 }
[13:17:34.280]             }
[13:17:34.280]         }
[13:17:34.280]     })
[13:17:34.280]     if (TRUE) {
[13:17:34.280]         base::sink(type = "output", split = FALSE)
[13:17:34.280]         if (TRUE) {
[13:17:34.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:34.280]         }
[13:17:34.280]         else {
[13:17:34.280]             ...future.result["stdout"] <- base::list(NULL)
[13:17:34.280]         }
[13:17:34.280]         base::close(...future.stdout)
[13:17:34.280]         ...future.stdout <- NULL
[13:17:34.280]     }
[13:17:34.280]     ...future.result$conditions <- ...future.conditions
[13:17:34.280]     ...future.result$finished <- base::Sys.time()
[13:17:34.280]     ...future.result
[13:17:34.280] }
[13:17:34.283] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[13:17:34.283] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:17:34.284] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:17:34.284] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:34.284] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.285] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:17:34.285] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:17:34.285] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:34.285] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.286] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:34.286] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.286] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[13:17:34.287] MultisessionFuture started
[13:17:34.287] - Launch lazy future ... done
[13:17:34.287] run() for ‘MultisessionFuture’ ... done
[13:17:34.287] Created future:
[13:17:34.287] MultisessionFuture:
[13:17:34.287] Label: ‘future_eapply-2’
[13:17:34.287] Expression:
[13:17:34.287] {
[13:17:34.287]     do.call(function(...) {
[13:17:34.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.287]             on.exit(options(oopts), add = TRUE)
[13:17:34.287]         }
[13:17:34.287]         {
[13:17:34.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.287]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.287]             })
[13:17:34.287]         }
[13:17:34.287]     }, args = future.call.arguments)
[13:17:34.287] }
[13:17:34.287] Lazy evaluation: FALSE
[13:17:34.287] Asynchronous evaluation: TRUE
[13:17:34.287] Local evaluation: TRUE
[13:17:34.287] Environment: R_GlobalEnv
[13:17:34.287] Capture standard output: TRUE
[13:17:34.287] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:34.287] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:34.287] Packages: 1 packages (‘stats’)
[13:17:34.287] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:34.287] Resolved: FALSE
[13:17:34.287] Value: <not collected>
[13:17:34.287] Conditions captured: <none>
[13:17:34.287] Early signaling: FALSE
[13:17:34.287] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:34.287] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.299] Chunk #2 of 2 ... DONE
[13:17:34.299] Launching 2 futures (chunks) ... DONE
[13:17:34.299] Resolving 2 futures (chunks) ...
[13:17:34.299] resolve() on list ...
[13:17:34.299]  recursive: 0
[13:17:34.299]  length: 2
[13:17:34.299] 
[13:17:34.300] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.300] - Validating connection of MultisessionFuture
[13:17:34.300] - received message: FutureResult
[13:17:34.300] - Received FutureResult
[13:17:34.300] - Erased future from FutureRegistry
[13:17:34.301] result() for ClusterFuture ...
[13:17:34.301] - result already collected: FutureResult
[13:17:34.301] result() for ClusterFuture ... done
[13:17:34.301] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.301] Future #1
[13:17:34.301] result() for ClusterFuture ...
[13:17:34.301] - result already collected: FutureResult
[13:17:34.301] result() for ClusterFuture ... done
[13:17:34.301] result() for ClusterFuture ...
[13:17:34.301] - result already collected: FutureResult
[13:17:34.301] result() for ClusterFuture ... done
[13:17:34.302] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:34.302] - nx: 2
[13:17:34.302] - relay: TRUE
[13:17:34.302] - stdout: TRUE
[13:17:34.302] - signal: TRUE
[13:17:34.302] - resignal: FALSE
[13:17:34.302] - force: TRUE
[13:17:34.302] - relayed: [n=2] FALSE, FALSE
[13:17:34.302] - queued futures: [n=2] FALSE, FALSE
[13:17:34.302]  - until=1
[13:17:34.302]  - relaying element #1
[13:17:34.302] result() for ClusterFuture ...
[13:17:34.303] - result already collected: FutureResult
[13:17:34.303] result() for ClusterFuture ... done
[13:17:34.303] result() for ClusterFuture ...
[13:17:34.303] - result already collected: FutureResult
[13:17:34.303] result() for ClusterFuture ... done
[13:17:34.303] result() for ClusterFuture ...
[13:17:34.303] - result already collected: FutureResult
[13:17:34.303] result() for ClusterFuture ... done
[13:17:34.303] result() for ClusterFuture ...
[13:17:34.303] - result already collected: FutureResult
[13:17:34.303] result() for ClusterFuture ... done
[13:17:34.304] - relayed: [n=2] TRUE, FALSE
[13:17:34.304] - queued futures: [n=2] TRUE, FALSE
[13:17:34.304] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:34.304]  length: 1 (resolved future 1)
[13:17:34.335] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.335] - Validating connection of MultisessionFuture
[13:17:34.335] - received message: FutureResult
[13:17:34.335] - Received FutureResult
[13:17:34.335] - Erased future from FutureRegistry
[13:17:34.335] result() for ClusterFuture ...
[13:17:34.335] - result already collected: FutureResult
[13:17:34.336] result() for ClusterFuture ... done
[13:17:34.336] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.336] Future #2
[13:17:34.336] result() for ClusterFuture ...
[13:17:34.336] - result already collected: FutureResult
[13:17:34.336] result() for ClusterFuture ... done
[13:17:34.336] result() for ClusterFuture ...
[13:17:34.336] - result already collected: FutureResult
[13:17:34.336] result() for ClusterFuture ... done
[13:17:34.336] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:34.337] - nx: 2
[13:17:34.337] - relay: TRUE
[13:17:34.337] - stdout: TRUE
[13:17:34.337] - signal: TRUE
[13:17:34.337] - resignal: FALSE
[13:17:34.337] - force: TRUE
[13:17:34.337] - relayed: [n=2] TRUE, FALSE
[13:17:34.337] - queued futures: [n=2] TRUE, FALSE
[13:17:34.337]  - until=2
[13:17:34.337]  - relaying element #2
[13:17:34.337] result() for ClusterFuture ...
[13:17:34.338] - result already collected: FutureResult
[13:17:34.338] result() for ClusterFuture ... done
[13:17:34.338] result() for ClusterFuture ...
[13:17:34.338] - result already collected: FutureResult
[13:17:34.338] result() for ClusterFuture ... done
[13:17:34.338] result() for ClusterFuture ...
[13:17:34.338] - result already collected: FutureResult
[13:17:34.338] result() for ClusterFuture ... done
[13:17:34.338] result() for ClusterFuture ...
[13:17:34.338] - result already collected: FutureResult
[13:17:34.338] result() for ClusterFuture ... done
[13:17:34.339] - relayed: [n=2] TRUE, TRUE
[13:17:34.339] - queued futures: [n=2] TRUE, TRUE
[13:17:34.339] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:34.339]  length: 0 (resolved future 2)
[13:17:34.339] Relaying remaining futures
[13:17:34.339] signalConditionsASAP(NULL, pos=0) ...
[13:17:34.339] - nx: 2
[13:17:34.339] - relay: TRUE
[13:17:34.339] - stdout: TRUE
[13:17:34.339] - signal: TRUE
[13:17:34.339] - resignal: FALSE
[13:17:34.340] - force: TRUE
[13:17:34.340] - relayed: [n=2] TRUE, TRUE
[13:17:34.340] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:34.340] - relayed: [n=2] TRUE, TRUE
[13:17:34.340] - queued futures: [n=2] TRUE, TRUE
[13:17:34.340] signalConditionsASAP(NULL, pos=0) ... done
[13:17:34.340] resolve() on list ... DONE
[13:17:34.340] result() for ClusterFuture ...
[13:17:34.340] - result already collected: FutureResult
[13:17:34.340] result() for ClusterFuture ... done
[13:17:34.340] result() for ClusterFuture ...
[13:17:34.341] - result already collected: FutureResult
[13:17:34.341] result() for ClusterFuture ... done
[13:17:34.341] result() for ClusterFuture ...
[13:17:34.341] - result already collected: FutureResult
[13:17:34.341] result() for ClusterFuture ... done
[13:17:34.341] result() for ClusterFuture ...
[13:17:34.341] - result already collected: FutureResult
[13:17:34.341] result() for ClusterFuture ... done
[13:17:34.341]  - Number of value chunks collected: 2
[13:17:34.341] Resolving 2 futures (chunks) ... DONE
[13:17:34.341] Reducing values from 2 chunks ...
[13:17:34.342]  - Number of values collected after concatenation: 3
[13:17:34.342]  - Number of values expected: 3
[13:17:34.342] Reducing values from 2 chunks ... DONE
[13:17:34.342] future_lapply() ... DONE
[13:17:34.342] future_lapply() ...
[13:17:34.346] Number of chunks: 2
[13:17:34.346] getGlobalsAndPackagesXApply() ...
[13:17:34.346]  - future.globals: TRUE
[13:17:34.347] getGlobalsAndPackages() ...
[13:17:34.347] Searching for globals...
[13:17:34.348] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:34.348] Searching for globals ... DONE
[13:17:34.348] Resolving globals: FALSE
[13:17:34.348] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:34.349] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:34.349] - globals: [1] ‘FUN’
[13:17:34.349] - packages: [1] ‘stats’
[13:17:34.349] getGlobalsAndPackages() ... DONE
[13:17:34.349]  - globals found/used: [n=1] ‘FUN’
[13:17:34.349]  - needed namespaces: [n=1] ‘stats’
[13:17:34.349] Finding globals ... DONE
[13:17:34.350]  - use_args: TRUE
[13:17:34.350]  - Getting '...' globals ...
[13:17:34.350] resolve() on list ...
[13:17:34.350]  recursive: 0
[13:17:34.350]  length: 1
[13:17:34.350]  elements: ‘...’
[13:17:34.350]  length: 0 (resolved future 1)
[13:17:34.350] resolve() on list ... DONE
[13:17:34.350]    - '...' content: [n=0] 
[13:17:34.351] List of 1
[13:17:34.351]  $ ...: list()
[13:17:34.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:34.351]  - attr(*, "where")=List of 1
[13:17:34.351]   ..$ ...:<environment: 0x55be3f0b14a0> 
[13:17:34.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:34.351]  - attr(*, "resolved")= logi TRUE
[13:17:34.351]  - attr(*, "total_size")= num NA
[13:17:34.353]  - Getting '...' globals ... DONE
[13:17:34.353] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:34.353] List of 2
[13:17:34.353]  $ ...future.FUN:function (x, ...)  
[13:17:34.353]  $ ...          : list()
[13:17:34.353]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:34.353]  - attr(*, "where")=List of 2
[13:17:34.353]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:34.353]   ..$ ...          :<environment: 0x55be3f0b14a0> 
[13:17:34.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:34.353]  - attr(*, "resolved")= logi FALSE
[13:17:34.353]  - attr(*, "total_size")= num 1248
[13:17:34.356] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:34.356] getGlobalsAndPackagesXApply() ... DONE
[13:17:34.356] Number of futures (= number of chunks): 2
[13:17:34.356] Launching 2 futures (chunks) ...
[13:17:34.357] Chunk #1 of 2 ...
[13:17:34.357]  - Finding globals in 'X' for chunk #1 ...
[13:17:34.357] getGlobalsAndPackages() ...
[13:17:34.357] Searching for globals...
[13:17:34.357] 
[13:17:34.357] Searching for globals ... DONE
[13:17:34.357] - globals: [0] <none>
[13:17:34.357] getGlobalsAndPackages() ... DONE
[13:17:34.358]    + additional globals found: [n=0] 
[13:17:34.358]    + additional namespaces needed: [n=0] 
[13:17:34.358]  - Finding globals in 'X' for chunk #1 ... DONE
[13:17:34.358]  - seeds: <none>
[13:17:34.358] getGlobalsAndPackages() ...
[13:17:34.358] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.358] Resolving globals: FALSE
[13:17:34.358] Tweak future expression to call with '...' arguments ...
[13:17:34.358] {
[13:17:34.358]     do.call(function(...) {
[13:17:34.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.358]             on.exit(options(oopts), add = TRUE)
[13:17:34.358]         }
[13:17:34.358]         {
[13:17:34.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.358]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.358]             })
[13:17:34.358]         }
[13:17:34.358]     }, args = future.call.arguments)
[13:17:34.358] }
[13:17:34.359] Tweak future expression to call with '...' arguments ... DONE
[13:17:34.359] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.359] - packages: [1] ‘stats’
[13:17:34.359] getGlobalsAndPackages() ... DONE
[13:17:34.359] run() for ‘Future’ ...
[13:17:34.360] - state: ‘created’
[13:17:34.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:34.374] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:34.374]   - Field: ‘node’
[13:17:34.375]   - Field: ‘label’
[13:17:34.375]   - Field: ‘local’
[13:17:34.375]   - Field: ‘owner’
[13:17:34.375]   - Field: ‘envir’
[13:17:34.375]   - Field: ‘workers’
[13:17:34.375]   - Field: ‘packages’
[13:17:34.375]   - Field: ‘gc’
[13:17:34.375]   - Field: ‘conditions’
[13:17:34.375]   - Field: ‘persistent’
[13:17:34.375]   - Field: ‘expr’
[13:17:34.376]   - Field: ‘uuid’
[13:17:34.376]   - Field: ‘seed’
[13:17:34.376]   - Field: ‘version’
[13:17:34.376]   - Field: ‘result’
[13:17:34.376]   - Field: ‘asynchronous’
[13:17:34.376]   - Field: ‘calls’
[13:17:34.376]   - Field: ‘globals’
[13:17:34.376]   - Field: ‘stdout’
[13:17:34.376]   - Field: ‘earlySignal’
[13:17:34.376]   - Field: ‘lazy’
[13:17:34.376]   - Field: ‘state’
[13:17:34.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:34.377] - Launch lazy future ...
[13:17:34.377] Packages needed by the future expression (n = 1): ‘stats’
[13:17:34.377] Packages needed by future strategies (n = 0): <none>
[13:17:34.378] {
[13:17:34.378]     {
[13:17:34.378]         {
[13:17:34.378]             ...future.startTime <- base::Sys.time()
[13:17:34.378]             {
[13:17:34.378]                 {
[13:17:34.378]                   {
[13:17:34.378]                     {
[13:17:34.378]                       {
[13:17:34.378]                         base::local({
[13:17:34.378]                           has_future <- base::requireNamespace("future", 
[13:17:34.378]                             quietly = TRUE)
[13:17:34.378]                           if (has_future) {
[13:17:34.378]                             ns <- base::getNamespace("future")
[13:17:34.378]                             version <- ns[[".package"]][["version"]]
[13:17:34.378]                             if (is.null(version)) 
[13:17:34.378]                               version <- utils::packageVersion("future")
[13:17:34.378]                           }
[13:17:34.378]                           else {
[13:17:34.378]                             version <- NULL
[13:17:34.378]                           }
[13:17:34.378]                           if (!has_future || version < "1.8.0") {
[13:17:34.378]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:34.378]                               "", base::R.version$version.string), 
[13:17:34.378]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:34.378]                                 base::R.version$platform, 8 * 
[13:17:34.378]                                   base::.Machine$sizeof.pointer), 
[13:17:34.378]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:34.378]                                 "release", "version")], collapse = " "), 
[13:17:34.378]                               hostname = base::Sys.info()[["nodename"]])
[13:17:34.378]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:34.378]                               info)
[13:17:34.378]                             info <- base::paste(info, collapse = "; ")
[13:17:34.378]                             if (!has_future) {
[13:17:34.378]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:34.378]                                 info)
[13:17:34.378]                             }
[13:17:34.378]                             else {
[13:17:34.378]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:34.378]                                 info, version)
[13:17:34.378]                             }
[13:17:34.378]                             base::stop(msg)
[13:17:34.378]                           }
[13:17:34.378]                         })
[13:17:34.378]                       }
[13:17:34.378]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:34.378]                       base::options(mc.cores = 1L)
[13:17:34.378]                     }
[13:17:34.378]                     base::local({
[13:17:34.378]                       for (pkg in "stats") {
[13:17:34.378]                         base::loadNamespace(pkg)
[13:17:34.378]                         base::library(pkg, character.only = TRUE)
[13:17:34.378]                       }
[13:17:34.378]                     })
[13:17:34.378]                   }
[13:17:34.378]                   options(future.plan = NULL)
[13:17:34.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:34.378]                 }
[13:17:34.378]                 ...future.workdir <- getwd()
[13:17:34.378]             }
[13:17:34.378]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:34.378]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:34.378]         }
[13:17:34.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:34.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:34.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:34.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:34.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:34.378]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:34.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:34.378]             base::names(...future.oldOptions))
[13:17:34.378]     }
[13:17:34.378]     if (FALSE) {
[13:17:34.378]     }
[13:17:34.378]     else {
[13:17:34.378]         if (TRUE) {
[13:17:34.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:34.378]                 open = "w")
[13:17:34.378]         }
[13:17:34.378]         else {
[13:17:34.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:34.378]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:34.378]         }
[13:17:34.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:34.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:34.378]             base::sink(type = "output", split = FALSE)
[13:17:34.378]             base::close(...future.stdout)
[13:17:34.378]         }, add = TRUE)
[13:17:34.378]     }
[13:17:34.378]     ...future.frame <- base::sys.nframe()
[13:17:34.378]     ...future.conditions <- base::list()
[13:17:34.378]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:34.378]     if (FALSE) {
[13:17:34.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:34.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:34.378]     }
[13:17:34.378]     ...future.result <- base::tryCatch({
[13:17:34.378]         base::withCallingHandlers({
[13:17:34.378]             ...future.value <- base::withVisible(base::local({
[13:17:34.378]                 ...future.makeSendCondition <- local({
[13:17:34.378]                   sendCondition <- NULL
[13:17:34.378]                   function(frame = 1L) {
[13:17:34.378]                     if (is.function(sendCondition)) 
[13:17:34.378]                       return(sendCondition)
[13:17:34.378]                     ns <- getNamespace("parallel")
[13:17:34.378]                     if (exists("sendData", mode = "function", 
[13:17:34.378]                       envir = ns)) {
[13:17:34.378]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:34.378]                         envir = ns)
[13:17:34.378]                       envir <- sys.frame(frame)
[13:17:34.378]                       master <- NULL
[13:17:34.378]                       while (!identical(envir, .GlobalEnv) && 
[13:17:34.378]                         !identical(envir, emptyenv())) {
[13:17:34.378]                         if (exists("master", mode = "list", envir = envir, 
[13:17:34.378]                           inherits = FALSE)) {
[13:17:34.378]                           master <- get("master", mode = "list", 
[13:17:34.378]                             envir = envir, inherits = FALSE)
[13:17:34.378]                           if (inherits(master, c("SOCKnode", 
[13:17:34.378]                             "SOCK0node"))) {
[13:17:34.378]                             sendCondition <<- function(cond) {
[13:17:34.378]                               data <- list(type = "VALUE", value = cond, 
[13:17:34.378]                                 success = TRUE)
[13:17:34.378]                               parallel_sendData(master, data)
[13:17:34.378]                             }
[13:17:34.378]                             return(sendCondition)
[13:17:34.378]                           }
[13:17:34.378]                         }
[13:17:34.378]                         frame <- frame + 1L
[13:17:34.378]                         envir <- sys.frame(frame)
[13:17:34.378]                       }
[13:17:34.378]                     }
[13:17:34.378]                     sendCondition <<- function(cond) NULL
[13:17:34.378]                   }
[13:17:34.378]                 })
[13:17:34.378]                 withCallingHandlers({
[13:17:34.378]                   {
[13:17:34.378]                     do.call(function(...) {
[13:17:34.378]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.378]                       if (!identical(...future.globals.maxSize.org, 
[13:17:34.378]                         ...future.globals.maxSize)) {
[13:17:34.378]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.378]                         on.exit(options(oopts), add = TRUE)
[13:17:34.378]                       }
[13:17:34.378]                       {
[13:17:34.378]                         lapply(seq_along(...future.elements_ii), 
[13:17:34.378]                           FUN = function(jj) {
[13:17:34.378]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.378]                             ...future.FUN(...future.X_jj, ...)
[13:17:34.378]                           })
[13:17:34.378]                       }
[13:17:34.378]                     }, args = future.call.arguments)
[13:17:34.378]                   }
[13:17:34.378]                 }, immediateCondition = function(cond) {
[13:17:34.378]                   sendCondition <- ...future.makeSendCondition()
[13:17:34.378]                   sendCondition(cond)
[13:17:34.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.378]                   {
[13:17:34.378]                     inherits <- base::inherits
[13:17:34.378]                     invokeRestart <- base::invokeRestart
[13:17:34.378]                     is.null <- base::is.null
[13:17:34.378]                     muffled <- FALSE
[13:17:34.378]                     if (inherits(cond, "message")) {
[13:17:34.378]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:34.378]                       if (muffled) 
[13:17:34.378]                         invokeRestart("muffleMessage")
[13:17:34.378]                     }
[13:17:34.378]                     else if (inherits(cond, "warning")) {
[13:17:34.378]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:34.378]                       if (muffled) 
[13:17:34.378]                         invokeRestart("muffleWarning")
[13:17:34.378]                     }
[13:17:34.378]                     else if (inherits(cond, "condition")) {
[13:17:34.378]                       if (!is.null(pattern)) {
[13:17:34.378]                         computeRestarts <- base::computeRestarts
[13:17:34.378]                         grepl <- base::grepl
[13:17:34.378]                         restarts <- computeRestarts(cond)
[13:17:34.378]                         for (restart in restarts) {
[13:17:34.378]                           name <- restart$name
[13:17:34.378]                           if (is.null(name)) 
[13:17:34.378]                             next
[13:17:34.378]                           if (!grepl(pattern, name)) 
[13:17:34.378]                             next
[13:17:34.378]                           invokeRestart(restart)
[13:17:34.378]                           muffled <- TRUE
[13:17:34.378]                           break
[13:17:34.378]                         }
[13:17:34.378]                       }
[13:17:34.378]                     }
[13:17:34.378]                     invisible(muffled)
[13:17:34.378]                   }
[13:17:34.378]                   muffleCondition(cond)
[13:17:34.378]                 })
[13:17:34.378]             }))
[13:17:34.378]             future::FutureResult(value = ...future.value$value, 
[13:17:34.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.378]                   ...future.rng), globalenv = if (FALSE) 
[13:17:34.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:34.378]                     ...future.globalenv.names))
[13:17:34.378]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:34.378]         }, condition = base::local({
[13:17:34.378]             c <- base::c
[13:17:34.378]             inherits <- base::inherits
[13:17:34.378]             invokeRestart <- base::invokeRestart
[13:17:34.378]             length <- base::length
[13:17:34.378]             list <- base::list
[13:17:34.378]             seq.int <- base::seq.int
[13:17:34.378]             signalCondition <- base::signalCondition
[13:17:34.378]             sys.calls <- base::sys.calls
[13:17:34.378]             `[[` <- base::`[[`
[13:17:34.378]             `+` <- base::`+`
[13:17:34.378]             `<<-` <- base::`<<-`
[13:17:34.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:34.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:34.378]                   3L)]
[13:17:34.378]             }
[13:17:34.378]             function(cond) {
[13:17:34.378]                 is_error <- inherits(cond, "error")
[13:17:34.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:34.378]                   NULL)
[13:17:34.378]                 if (is_error) {
[13:17:34.378]                   sessionInformation <- function() {
[13:17:34.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:34.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:34.378]                       search = base::search(), system = base::Sys.info())
[13:17:34.378]                   }
[13:17:34.378]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:34.378]                     cond$call), session = sessionInformation(), 
[13:17:34.378]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:34.378]                   signalCondition(cond)
[13:17:34.378]                 }
[13:17:34.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:34.378]                 "immediateCondition"))) {
[13:17:34.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:34.378]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:34.378]                   if (TRUE && !signal) {
[13:17:34.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.378]                     {
[13:17:34.378]                       inherits <- base::inherits
[13:17:34.378]                       invokeRestart <- base::invokeRestart
[13:17:34.378]                       is.null <- base::is.null
[13:17:34.378]                       muffled <- FALSE
[13:17:34.378]                       if (inherits(cond, "message")) {
[13:17:34.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.378]                         if (muffled) 
[13:17:34.378]                           invokeRestart("muffleMessage")
[13:17:34.378]                       }
[13:17:34.378]                       else if (inherits(cond, "warning")) {
[13:17:34.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.378]                         if (muffled) 
[13:17:34.378]                           invokeRestart("muffleWarning")
[13:17:34.378]                       }
[13:17:34.378]                       else if (inherits(cond, "condition")) {
[13:17:34.378]                         if (!is.null(pattern)) {
[13:17:34.378]                           computeRestarts <- base::computeRestarts
[13:17:34.378]                           grepl <- base::grepl
[13:17:34.378]                           restarts <- computeRestarts(cond)
[13:17:34.378]                           for (restart in restarts) {
[13:17:34.378]                             name <- restart$name
[13:17:34.378]                             if (is.null(name)) 
[13:17:34.378]                               next
[13:17:34.378]                             if (!grepl(pattern, name)) 
[13:17:34.378]                               next
[13:17:34.378]                             invokeRestart(restart)
[13:17:34.378]                             muffled <- TRUE
[13:17:34.378]                             break
[13:17:34.378]                           }
[13:17:34.378]                         }
[13:17:34.378]                       }
[13:17:34.378]                       invisible(muffled)
[13:17:34.378]                     }
[13:17:34.378]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.378]                   }
[13:17:34.378]                 }
[13:17:34.378]                 else {
[13:17:34.378]                   if (TRUE) {
[13:17:34.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.378]                     {
[13:17:34.378]                       inherits <- base::inherits
[13:17:34.378]                       invokeRestart <- base::invokeRestart
[13:17:34.378]                       is.null <- base::is.null
[13:17:34.378]                       muffled <- FALSE
[13:17:34.378]                       if (inherits(cond, "message")) {
[13:17:34.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.378]                         if (muffled) 
[13:17:34.378]                           invokeRestart("muffleMessage")
[13:17:34.378]                       }
[13:17:34.378]                       else if (inherits(cond, "warning")) {
[13:17:34.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.378]                         if (muffled) 
[13:17:34.378]                           invokeRestart("muffleWarning")
[13:17:34.378]                       }
[13:17:34.378]                       else if (inherits(cond, "condition")) {
[13:17:34.378]                         if (!is.null(pattern)) {
[13:17:34.378]                           computeRestarts <- base::computeRestarts
[13:17:34.378]                           grepl <- base::grepl
[13:17:34.378]                           restarts <- computeRestarts(cond)
[13:17:34.378]                           for (restart in restarts) {
[13:17:34.378]                             name <- restart$name
[13:17:34.378]                             if (is.null(name)) 
[13:17:34.378]                               next
[13:17:34.378]                             if (!grepl(pattern, name)) 
[13:17:34.378]                               next
[13:17:34.378]                             invokeRestart(restart)
[13:17:34.378]                             muffled <- TRUE
[13:17:34.378]                             break
[13:17:34.378]                           }
[13:17:34.378]                         }
[13:17:34.378]                       }
[13:17:34.378]                       invisible(muffled)
[13:17:34.378]                     }
[13:17:34.378]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.378]                   }
[13:17:34.378]                 }
[13:17:34.378]             }
[13:17:34.378]         }))
[13:17:34.378]     }, error = function(ex) {
[13:17:34.378]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:34.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.378]                 ...future.rng), started = ...future.startTime, 
[13:17:34.378]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:34.378]             version = "1.8"), class = "FutureResult")
[13:17:34.378]     }, finally = {
[13:17:34.378]         if (!identical(...future.workdir, getwd())) 
[13:17:34.378]             setwd(...future.workdir)
[13:17:34.378]         {
[13:17:34.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:34.378]                 ...future.oldOptions$nwarnings <- NULL
[13:17:34.378]             }
[13:17:34.378]             base::options(...future.oldOptions)
[13:17:34.378]             if (.Platform$OS.type == "windows") {
[13:17:34.378]                 old_names <- names(...future.oldEnvVars)
[13:17:34.378]                 envs <- base::Sys.getenv()
[13:17:34.378]                 names <- names(envs)
[13:17:34.378]                 common <- intersect(names, old_names)
[13:17:34.378]                 added <- setdiff(names, old_names)
[13:17:34.378]                 removed <- setdiff(old_names, names)
[13:17:34.378]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:34.378]                   envs[common]]
[13:17:34.378]                 NAMES <- toupper(changed)
[13:17:34.378]                 args <- list()
[13:17:34.378]                 for (kk in seq_along(NAMES)) {
[13:17:34.378]                   name <- changed[[kk]]
[13:17:34.378]                   NAME <- NAMES[[kk]]
[13:17:34.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.378]                     next
[13:17:34.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.378]                 }
[13:17:34.378]                 NAMES <- toupper(added)
[13:17:34.378]                 for (kk in seq_along(NAMES)) {
[13:17:34.378]                   name <- added[[kk]]
[13:17:34.378]                   NAME <- NAMES[[kk]]
[13:17:34.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.378]                     next
[13:17:34.378]                   args[[name]] <- ""
[13:17:34.378]                 }
[13:17:34.378]                 NAMES <- toupper(removed)
[13:17:34.378]                 for (kk in seq_along(NAMES)) {
[13:17:34.378]                   name <- removed[[kk]]
[13:17:34.378]                   NAME <- NAMES[[kk]]
[13:17:34.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.378]                     next
[13:17:34.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.378]                 }
[13:17:34.378]                 if (length(args) > 0) 
[13:17:34.378]                   base::do.call(base::Sys.setenv, args = args)
[13:17:34.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:34.378]             }
[13:17:34.378]             else {
[13:17:34.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:34.378]             }
[13:17:34.378]             {
[13:17:34.378]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:34.378]                   0L) {
[13:17:34.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:34.378]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:34.378]                   base::options(opts)
[13:17:34.378]                 }
[13:17:34.378]                 {
[13:17:34.378]                   {
[13:17:34.378]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:34.378]                     NULL
[13:17:34.378]                   }
[13:17:34.378]                   options(future.plan = NULL)
[13:17:34.378]                   if (is.na(NA_character_)) 
[13:17:34.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:34.378]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:34.378]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:34.378]                     envir = parent.frame()) 
[13:17:34.378]                   {
[13:17:34.378]                     if (is.function(workers)) 
[13:17:34.378]                       workers <- workers()
[13:17:34.378]                     workers <- structure(as.integer(workers), 
[13:17:34.378]                       class = class(workers))
[13:17:34.378]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:34.378]                       workers >= 1)
[13:17:34.378]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:34.378]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:34.378]                     }
[13:17:34.378]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:34.378]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:34.378]                       envir = envir)
[13:17:34.378]                     if (!future$lazy) 
[13:17:34.378]                       future <- run(future)
[13:17:34.378]                     invisible(future)
[13:17:34.378]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:34.378]                 }
[13:17:34.378]             }
[13:17:34.378]         }
[13:17:34.378]     })
[13:17:34.378]     if (TRUE) {
[13:17:34.378]         base::sink(type = "output", split = FALSE)
[13:17:34.378]         if (TRUE) {
[13:17:34.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:34.378]         }
[13:17:34.378]         else {
[13:17:34.378]             ...future.result["stdout"] <- base::list(NULL)
[13:17:34.378]         }
[13:17:34.378]         base::close(...future.stdout)
[13:17:34.378]         ...future.stdout <- NULL
[13:17:34.378]     }
[13:17:34.378]     ...future.result$conditions <- ...future.conditions
[13:17:34.378]     ...future.result$finished <- base::Sys.time()
[13:17:34.378]     ...future.result
[13:17:34.378] }
[13:17:34.381] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[13:17:34.381] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:17:34.381] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:17:34.381] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:34.382] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.382] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:17:34.382] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:17:34.382] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:34.383] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:34.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:34.383] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[13:17:34.384] MultisessionFuture started
[13:17:34.384] - Launch lazy future ... done
[13:17:34.384] run() for ‘MultisessionFuture’ ... done
[13:17:34.384] Created future:
[13:17:34.385] MultisessionFuture:
[13:17:34.385] Label: ‘future_eapply-1’
[13:17:34.385] Expression:
[13:17:34.385] {
[13:17:34.385]     do.call(function(...) {
[13:17:34.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.385]             on.exit(options(oopts), add = TRUE)
[13:17:34.385]         }
[13:17:34.385]         {
[13:17:34.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.385]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.385]             })
[13:17:34.385]         }
[13:17:34.385]     }, args = future.call.arguments)
[13:17:34.385] }
[13:17:34.385] Lazy evaluation: FALSE
[13:17:34.385] Asynchronous evaluation: TRUE
[13:17:34.385] Local evaluation: TRUE
[13:17:34.385] Environment: R_GlobalEnv
[13:17:34.385] Capture standard output: TRUE
[13:17:34.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:34.385] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:34.385] Packages: 1 packages (‘stats’)
[13:17:34.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:34.385] Resolved: FALSE
[13:17:34.385] Value: <not collected>
[13:17:34.385] Conditions captured: <none>
[13:17:34.385] Early signaling: FALSE
[13:17:34.385] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:34.385] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.396] Chunk #1 of 2 ... DONE
[13:17:34.396] Chunk #2 of 2 ...
[13:17:34.396]  - Finding globals in 'X' for chunk #2 ...
[13:17:34.397] getGlobalsAndPackages() ...
[13:17:34.397] Searching for globals...
[13:17:34.397] 
[13:17:34.397] Searching for globals ... DONE
[13:17:34.397] - globals: [0] <none>
[13:17:34.397] getGlobalsAndPackages() ... DONE
[13:17:34.397]    + additional globals found: [n=0] 
[13:17:34.397]    + additional namespaces needed: [n=0] 
[13:17:34.398]  - Finding globals in 'X' for chunk #2 ... DONE
[13:17:34.398]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:17:34.398]  - seeds: <none>
[13:17:34.398] getGlobalsAndPackages() ...
[13:17:34.398] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.398] Resolving globals: FALSE
[13:17:34.398] Tweak future expression to call with '...' arguments ...
[13:17:34.398] {
[13:17:34.398]     do.call(function(...) {
[13:17:34.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.398]             on.exit(options(oopts), add = TRUE)
[13:17:34.398]         }
[13:17:34.398]         {
[13:17:34.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.398]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.398]             })
[13:17:34.398]         }
[13:17:34.398]     }, args = future.call.arguments)
[13:17:34.398] }
[13:17:34.399] Tweak future expression to call with '...' arguments ... DONE
[13:17:34.399] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:34.399] - packages: [1] ‘stats’
[13:17:34.399] getGlobalsAndPackages() ... DONE
[13:17:34.400] run() for ‘Future’ ...
[13:17:34.400] - state: ‘created’
[13:17:34.400] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:34.417] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:34.418]   - Field: ‘node’
[13:17:34.418]   - Field: ‘label’
[13:17:34.418]   - Field: ‘local’
[13:17:34.418]   - Field: ‘owner’
[13:17:34.418]   - Field: ‘envir’
[13:17:34.418]   - Field: ‘workers’
[13:17:34.418]   - Field: ‘packages’
[13:17:34.418]   - Field: ‘gc’
[13:17:34.418]   - Field: ‘conditions’
[13:17:34.419]   - Field: ‘persistent’
[13:17:34.419]   - Field: ‘expr’
[13:17:34.419]   - Field: ‘uuid’
[13:17:34.419]   - Field: ‘seed’
[13:17:34.419]   - Field: ‘version’
[13:17:34.419]   - Field: ‘result’
[13:17:34.419]   - Field: ‘asynchronous’
[13:17:34.419]   - Field: ‘calls’
[13:17:34.419]   - Field: ‘globals’
[13:17:34.419]   - Field: ‘stdout’
[13:17:34.419]   - Field: ‘earlySignal’
[13:17:34.420]   - Field: ‘lazy’
[13:17:34.420]   - Field: ‘state’
[13:17:34.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:34.420] - Launch lazy future ...
[13:17:34.420] Packages needed by the future expression (n = 1): ‘stats’
[13:17:34.420] Packages needed by future strategies (n = 0): <none>
[13:17:34.421] {
[13:17:34.421]     {
[13:17:34.421]         {
[13:17:34.421]             ...future.startTime <- base::Sys.time()
[13:17:34.421]             {
[13:17:34.421]                 {
[13:17:34.421]                   {
[13:17:34.421]                     {
[13:17:34.421]                       {
[13:17:34.421]                         base::local({
[13:17:34.421]                           has_future <- base::requireNamespace("future", 
[13:17:34.421]                             quietly = TRUE)
[13:17:34.421]                           if (has_future) {
[13:17:34.421]                             ns <- base::getNamespace("future")
[13:17:34.421]                             version <- ns[[".package"]][["version"]]
[13:17:34.421]                             if (is.null(version)) 
[13:17:34.421]                               version <- utils::packageVersion("future")
[13:17:34.421]                           }
[13:17:34.421]                           else {
[13:17:34.421]                             version <- NULL
[13:17:34.421]                           }
[13:17:34.421]                           if (!has_future || version < "1.8.0") {
[13:17:34.421]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:34.421]                               "", base::R.version$version.string), 
[13:17:34.421]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:34.421]                                 base::R.version$platform, 8 * 
[13:17:34.421]                                   base::.Machine$sizeof.pointer), 
[13:17:34.421]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:34.421]                                 "release", "version")], collapse = " "), 
[13:17:34.421]                               hostname = base::Sys.info()[["nodename"]])
[13:17:34.421]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:34.421]                               info)
[13:17:34.421]                             info <- base::paste(info, collapse = "; ")
[13:17:34.421]                             if (!has_future) {
[13:17:34.421]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:34.421]                                 info)
[13:17:34.421]                             }
[13:17:34.421]                             else {
[13:17:34.421]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:34.421]                                 info, version)
[13:17:34.421]                             }
[13:17:34.421]                             base::stop(msg)
[13:17:34.421]                           }
[13:17:34.421]                         })
[13:17:34.421]                       }
[13:17:34.421]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:34.421]                       base::options(mc.cores = 1L)
[13:17:34.421]                     }
[13:17:34.421]                     base::local({
[13:17:34.421]                       for (pkg in "stats") {
[13:17:34.421]                         base::loadNamespace(pkg)
[13:17:34.421]                         base::library(pkg, character.only = TRUE)
[13:17:34.421]                       }
[13:17:34.421]                     })
[13:17:34.421]                   }
[13:17:34.421]                   options(future.plan = NULL)
[13:17:34.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:34.421]                 }
[13:17:34.421]                 ...future.workdir <- getwd()
[13:17:34.421]             }
[13:17:34.421]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:34.421]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:34.421]         }
[13:17:34.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:34.421]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:17:34.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:34.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:34.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:34.421]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:34.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:34.421]             base::names(...future.oldOptions))
[13:17:34.421]     }
[13:17:34.421]     if (FALSE) {
[13:17:34.421]     }
[13:17:34.421]     else {
[13:17:34.421]         if (TRUE) {
[13:17:34.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:34.421]                 open = "w")
[13:17:34.421]         }
[13:17:34.421]         else {
[13:17:34.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:34.421]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:34.421]         }
[13:17:34.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:34.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:34.421]             base::sink(type = "output", split = FALSE)
[13:17:34.421]             base::close(...future.stdout)
[13:17:34.421]         }, add = TRUE)
[13:17:34.421]     }
[13:17:34.421]     ...future.frame <- base::sys.nframe()
[13:17:34.421]     ...future.conditions <- base::list()
[13:17:34.421]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:34.421]     if (FALSE) {
[13:17:34.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:34.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:34.421]     }
[13:17:34.421]     ...future.result <- base::tryCatch({
[13:17:34.421]         base::withCallingHandlers({
[13:17:34.421]             ...future.value <- base::withVisible(base::local({
[13:17:34.421]                 ...future.makeSendCondition <- local({
[13:17:34.421]                   sendCondition <- NULL
[13:17:34.421]                   function(frame = 1L) {
[13:17:34.421]                     if (is.function(sendCondition)) 
[13:17:34.421]                       return(sendCondition)
[13:17:34.421]                     ns <- getNamespace("parallel")
[13:17:34.421]                     if (exists("sendData", mode = "function", 
[13:17:34.421]                       envir = ns)) {
[13:17:34.421]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:34.421]                         envir = ns)
[13:17:34.421]                       envir <- sys.frame(frame)
[13:17:34.421]                       master <- NULL
[13:17:34.421]                       while (!identical(envir, .GlobalEnv) && 
[13:17:34.421]                         !identical(envir, emptyenv())) {
[13:17:34.421]                         if (exists("master", mode = "list", envir = envir, 
[13:17:34.421]                           inherits = FALSE)) {
[13:17:34.421]                           master <- get("master", mode = "list", 
[13:17:34.421]                             envir = envir, inherits = FALSE)
[13:17:34.421]                           if (inherits(master, c("SOCKnode", 
[13:17:34.421]                             "SOCK0node"))) {
[13:17:34.421]                             sendCondition <<- function(cond) {
[13:17:34.421]                               data <- list(type = "VALUE", value = cond, 
[13:17:34.421]                                 success = TRUE)
[13:17:34.421]                               parallel_sendData(master, data)
[13:17:34.421]                             }
[13:17:34.421]                             return(sendCondition)
[13:17:34.421]                           }
[13:17:34.421]                         }
[13:17:34.421]                         frame <- frame + 1L
[13:17:34.421]                         envir <- sys.frame(frame)
[13:17:34.421]                       }
[13:17:34.421]                     }
[13:17:34.421]                     sendCondition <<- function(cond) NULL
[13:17:34.421]                   }
[13:17:34.421]                 })
[13:17:34.421]                 withCallingHandlers({
[13:17:34.421]                   {
[13:17:34.421]                     do.call(function(...) {
[13:17:34.421]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.421]                       if (!identical(...future.globals.maxSize.org, 
[13:17:34.421]                         ...future.globals.maxSize)) {
[13:17:34.421]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.421]                         on.exit(options(oopts), add = TRUE)
[13:17:34.421]                       }
[13:17:34.421]                       {
[13:17:34.421]                         lapply(seq_along(...future.elements_ii), 
[13:17:34.421]                           FUN = function(jj) {
[13:17:34.421]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.421]                             ...future.FUN(...future.X_jj, ...)
[13:17:34.421]                           })
[13:17:34.421]                       }
[13:17:34.421]                     }, args = future.call.arguments)
[13:17:34.421]                   }
[13:17:34.421]                 }, immediateCondition = function(cond) {
[13:17:34.421]                   sendCondition <- ...future.makeSendCondition()
[13:17:34.421]                   sendCondition(cond)
[13:17:34.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.421]                   {
[13:17:34.421]                     inherits <- base::inherits
[13:17:34.421]                     invokeRestart <- base::invokeRestart
[13:17:34.421]                     is.null <- base::is.null
[13:17:34.421]                     muffled <- FALSE
[13:17:34.421]                     if (inherits(cond, "message")) {
[13:17:34.421]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:34.421]                       if (muffled) 
[13:17:34.421]                         invokeRestart("muffleMessage")
[13:17:34.421]                     }
[13:17:34.421]                     else if (inherits(cond, "warning")) {
[13:17:34.421]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:34.421]                       if (muffled) 
[13:17:34.421]                         invokeRestart("muffleWarning")
[13:17:34.421]                     }
[13:17:34.421]                     else if (inherits(cond, "condition")) {
[13:17:34.421]                       if (!is.null(pattern)) {
[13:17:34.421]                         computeRestarts <- base::computeRestarts
[13:17:34.421]                         grepl <- base::grepl
[13:17:34.421]                         restarts <- computeRestarts(cond)
[13:17:34.421]                         for (restart in restarts) {
[13:17:34.421]                           name <- restart$name
[13:17:34.421]                           if (is.null(name)) 
[13:17:34.421]                             next
[13:17:34.421]                           if (!grepl(pattern, name)) 
[13:17:34.421]                             next
[13:17:34.421]                           invokeRestart(restart)
[13:17:34.421]                           muffled <- TRUE
[13:17:34.421]                           break
[13:17:34.421]                         }
[13:17:34.421]                       }
[13:17:34.421]                     }
[13:17:34.421]                     invisible(muffled)
[13:17:34.421]                   }
[13:17:34.421]                   muffleCondition(cond)
[13:17:34.421]                 })
[13:17:34.421]             }))
[13:17:34.421]             future::FutureResult(value = ...future.value$value, 
[13:17:34.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.421]                   ...future.rng), globalenv = if (FALSE) 
[13:17:34.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:34.421]                     ...future.globalenv.names))
[13:17:34.421]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:34.421]         }, condition = base::local({
[13:17:34.421]             c <- base::c
[13:17:34.421]             inherits <- base::inherits
[13:17:34.421]             invokeRestart <- base::invokeRestart
[13:17:34.421]             length <- base::length
[13:17:34.421]             list <- base::list
[13:17:34.421]             seq.int <- base::seq.int
[13:17:34.421]             signalCondition <- base::signalCondition
[13:17:34.421]             sys.calls <- base::sys.calls
[13:17:34.421]             `[[` <- base::`[[`
[13:17:34.421]             `+` <- base::`+`
[13:17:34.421]             `<<-` <- base::`<<-`
[13:17:34.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:34.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:34.421]                   3L)]
[13:17:34.421]             }
[13:17:34.421]             function(cond) {
[13:17:34.421]                 is_error <- inherits(cond, "error")
[13:17:34.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:34.421]                   NULL)
[13:17:34.421]                 if (is_error) {
[13:17:34.421]                   sessionInformation <- function() {
[13:17:34.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:34.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:34.421]                       search = base::search(), system = base::Sys.info())
[13:17:34.421]                   }
[13:17:34.421]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:34.421]                     cond$call), session = sessionInformation(), 
[13:17:34.421]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:34.421]                   signalCondition(cond)
[13:17:34.421]                 }
[13:17:34.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:34.421]                 "immediateCondition"))) {
[13:17:34.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:34.421]                   ...future.conditions[[length(...future.conditions) + 
[13:17:34.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:34.421]                   if (TRUE && !signal) {
[13:17:34.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.421]                     {
[13:17:34.421]                       inherits <- base::inherits
[13:17:34.421]                       invokeRestart <- base::invokeRestart
[13:17:34.421]                       is.null <- base::is.null
[13:17:34.421]                       muffled <- FALSE
[13:17:34.421]                       if (inherits(cond, "message")) {
[13:17:34.421]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.421]                         if (muffled) 
[13:17:34.421]                           invokeRestart("muffleMessage")
[13:17:34.421]                       }
[13:17:34.421]                       else if (inherits(cond, "warning")) {
[13:17:34.421]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.421]                         if (muffled) 
[13:17:34.421]                           invokeRestart("muffleWarning")
[13:17:34.421]                       }
[13:17:34.421]                       else if (inherits(cond, "condition")) {
[13:17:34.421]                         if (!is.null(pattern)) {
[13:17:34.421]                           computeRestarts <- base::computeRestarts
[13:17:34.421]                           grepl <- base::grepl
[13:17:34.421]                           restarts <- computeRestarts(cond)
[13:17:34.421]                           for (restart in restarts) {
[13:17:34.421]                             name <- restart$name
[13:17:34.421]                             if (is.null(name)) 
[13:17:34.421]                               next
[13:17:34.421]                             if (!grepl(pattern, name)) 
[13:17:34.421]                               next
[13:17:34.421]                             invokeRestart(restart)
[13:17:34.421]                             muffled <- TRUE
[13:17:34.421]                             break
[13:17:34.421]                           }
[13:17:34.421]                         }
[13:17:34.421]                       }
[13:17:34.421]                       invisible(muffled)
[13:17:34.421]                     }
[13:17:34.421]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.421]                   }
[13:17:34.421]                 }
[13:17:34.421]                 else {
[13:17:34.421]                   if (TRUE) {
[13:17:34.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:34.421]                     {
[13:17:34.421]                       inherits <- base::inherits
[13:17:34.421]                       invokeRestart <- base::invokeRestart
[13:17:34.421]                       is.null <- base::is.null
[13:17:34.421]                       muffled <- FALSE
[13:17:34.421]                       if (inherits(cond, "message")) {
[13:17:34.421]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:34.421]                         if (muffled) 
[13:17:34.421]                           invokeRestart("muffleMessage")
[13:17:34.421]                       }
[13:17:34.421]                       else if (inherits(cond, "warning")) {
[13:17:34.421]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:34.421]                         if (muffled) 
[13:17:34.421]                           invokeRestart("muffleWarning")
[13:17:34.421]                       }
[13:17:34.421]                       else if (inherits(cond, "condition")) {
[13:17:34.421]                         if (!is.null(pattern)) {
[13:17:34.421]                           computeRestarts <- base::computeRestarts
[13:17:34.421]                           grepl <- base::grepl
[13:17:34.421]                           restarts <- computeRestarts(cond)
[13:17:34.421]                           for (restart in restarts) {
[13:17:34.421]                             name <- restart$name
[13:17:34.421]                             if (is.null(name)) 
[13:17:34.421]                               next
[13:17:34.421]                             if (!grepl(pattern, name)) 
[13:17:34.421]                               next
[13:17:34.421]                             invokeRestart(restart)
[13:17:34.421]                             muffled <- TRUE
[13:17:34.421]                             break
[13:17:34.421]                           }
[13:17:34.421]                         }
[13:17:34.421]                       }
[13:17:34.421]                       invisible(muffled)
[13:17:34.421]                     }
[13:17:34.421]                     muffleCondition(cond, pattern = "^muffle")
[13:17:34.421]                   }
[13:17:34.421]                 }
[13:17:34.421]             }
[13:17:34.421]         }))
[13:17:34.421]     }, error = function(ex) {
[13:17:34.421]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:34.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:34.421]                 ...future.rng), started = ...future.startTime, 
[13:17:34.421]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:34.421]             version = "1.8"), class = "FutureResult")
[13:17:34.421]     }, finally = {
[13:17:34.421]         if (!identical(...future.workdir, getwd())) 
[13:17:34.421]             setwd(...future.workdir)
[13:17:34.421]         {
[13:17:34.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:34.421]                 ...future.oldOptions$nwarnings <- NULL
[13:17:34.421]             }
[13:17:34.421]             base::options(...future.oldOptions)
[13:17:34.421]             if (.Platform$OS.type == "windows") {
[13:17:34.421]                 old_names <- names(...future.oldEnvVars)
[13:17:34.421]                 envs <- base::Sys.getenv()
[13:17:34.421]                 names <- names(envs)
[13:17:34.421]                 common <- intersect(names, old_names)
[13:17:34.421]                 added <- setdiff(names, old_names)
[13:17:34.421]                 removed <- setdiff(old_names, names)
[13:17:34.421]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:34.421]                   envs[common]]
[13:17:34.421]                 NAMES <- toupper(changed)
[13:17:34.421]                 args <- list()
[13:17:34.421]                 for (kk in seq_along(NAMES)) {
[13:17:34.421]                   name <- changed[[kk]]
[13:17:34.421]                   NAME <- NAMES[[kk]]
[13:17:34.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.421]                     next
[13:17:34.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.421]                 }
[13:17:34.421]                 NAMES <- toupper(added)
[13:17:34.421]                 for (kk in seq_along(NAMES)) {
[13:17:34.421]                   name <- added[[kk]]
[13:17:34.421]                   NAME <- NAMES[[kk]]
[13:17:34.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.421]                     next
[13:17:34.421]                   args[[name]] <- ""
[13:17:34.421]                 }
[13:17:34.421]                 NAMES <- toupper(removed)
[13:17:34.421]                 for (kk in seq_along(NAMES)) {
[13:17:34.421]                   name <- removed[[kk]]
[13:17:34.421]                   NAME <- NAMES[[kk]]
[13:17:34.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:34.421]                     next
[13:17:34.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:34.421]                 }
[13:17:34.421]                 if (length(args) > 0) 
[13:17:34.421]                   base::do.call(base::Sys.setenv, args = args)
[13:17:34.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:34.421]             }
[13:17:34.421]             else {
[13:17:34.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:34.421]             }
[13:17:34.421]             {
[13:17:34.421]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:34.421]                   0L) {
[13:17:34.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:34.421]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:34.421]                   base::options(opts)
[13:17:34.421]                 }
[13:17:34.421]                 {
[13:17:34.421]                   {
[13:17:34.421]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:34.421]                     NULL
[13:17:34.421]                   }
[13:17:34.421]                   options(future.plan = NULL)
[13:17:34.421]                   if (is.na(NA_character_)) 
[13:17:34.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:34.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:34.421]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:34.421]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:34.421]                     envir = parent.frame()) 
[13:17:34.421]                   {
[13:17:34.421]                     if (is.function(workers)) 
[13:17:34.421]                       workers <- workers()
[13:17:34.421]                     workers <- structure(as.integer(workers), 
[13:17:34.421]                       class = class(workers))
[13:17:34.421]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:34.421]                       workers >= 1)
[13:17:34.421]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:34.421]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:34.421]                     }
[13:17:34.421]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:34.421]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:34.421]                       envir = envir)
[13:17:34.421]                     if (!future$lazy) 
[13:17:34.421]                       future <- run(future)
[13:17:34.421]                     invisible(future)
[13:17:34.421]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:34.421]                 }
[13:17:34.421]             }
[13:17:34.421]         }
[13:17:34.421]     })
[13:17:34.421]     if (TRUE) {
[13:17:34.421]         base::sink(type = "output", split = FALSE)
[13:17:34.421]         if (TRUE) {
[13:17:34.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:34.421]         }
[13:17:34.421]         else {
[13:17:34.421]             ...future.result["stdout"] <- base::list(NULL)
[13:17:34.421]         }
[13:17:34.421]         base::close(...future.stdout)
[13:17:34.421]         ...future.stdout <- NULL
[13:17:34.421]     }
[13:17:34.421]     ...future.result$conditions <- ...future.conditions
[13:17:34.421]     ...future.result$finished <- base::Sys.time()
[13:17:34.421]     ...future.result
[13:17:34.421] }
[13:17:34.424] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[13:17:34.424] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:17:34.424] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:17:34.424] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:34.425] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.425] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:17:34.425] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:17:34.426] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:34.426] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.426] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:34.426] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:34.426] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[13:17:34.427] MultisessionFuture started
[13:17:34.427] - Launch lazy future ... done
[13:17:34.427] run() for ‘MultisessionFuture’ ... done
[13:17:34.427] Created future:
[13:17:34.427] MultisessionFuture:
[13:17:34.427] Label: ‘future_eapply-2’
[13:17:34.427] Expression:
[13:17:34.427] {
[13:17:34.427]     do.call(function(...) {
[13:17:34.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:34.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:34.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:34.427]             on.exit(options(oopts), add = TRUE)
[13:17:34.427]         }
[13:17:34.427]         {
[13:17:34.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:34.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:34.427]                 ...future.FUN(...future.X_jj, ...)
[13:17:34.427]             })
[13:17:34.427]         }
[13:17:34.427]     }, args = future.call.arguments)
[13:17:34.427] }
[13:17:34.427] Lazy evaluation: FALSE
[13:17:34.427] Asynchronous evaluation: TRUE
[13:17:34.427] Local evaluation: TRUE
[13:17:34.427] Environment: R_GlobalEnv
[13:17:34.427] Capture standard output: TRUE
[13:17:34.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:34.427] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:34.427] Packages: 1 packages (‘stats’)
[13:17:34.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:34.427] Resolved: FALSE
[13:17:34.427] Value: <not collected>
[13:17:34.427] Conditions captured: <none>
[13:17:34.427] Early signaling: FALSE
[13:17:34.427] Owner process: 06cf4623-c5ee-a5d8-c016-f093d4af854e
[13:17:34.427] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:34.439] Chunk #2 of 2 ... DONE
[13:17:34.439] Launching 2 futures (chunks) ... DONE
[13:17:34.439] Resolving 2 futures (chunks) ...
[13:17:34.440] resolve() on list ...
[13:17:34.440]  recursive: 0
[13:17:34.440]  length: 2
[13:17:34.440] 
[13:17:34.440] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.440] - Validating connection of MultisessionFuture
[13:17:34.441] - received message: FutureResult
[13:17:34.441] - Received FutureResult
[13:17:34.441] - Erased future from FutureRegistry
[13:17:34.441] result() for ClusterFuture ...
[13:17:34.441] - result already collected: FutureResult
[13:17:34.441] result() for ClusterFuture ... done
[13:17:34.441] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.441] Future #1
[13:17:34.441] result() for ClusterFuture ...
[13:17:34.442] - result already collected: FutureResult
[13:17:34.442] result() for ClusterFuture ... done
[13:17:34.442] result() for ClusterFuture ...
[13:17:34.442] - result already collected: FutureResult
[13:17:34.442] result() for ClusterFuture ... done
[13:17:34.442] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:34.442] - nx: 2
[13:17:34.442] - relay: TRUE
[13:17:34.442] - stdout: TRUE
[13:17:34.442] - signal: TRUE
[13:17:34.442] - resignal: FALSE
[13:17:34.443] - force: TRUE
[13:17:34.443] - relayed: [n=2] FALSE, FALSE
[13:17:34.443] - queued futures: [n=2] FALSE, FALSE
[13:17:34.443]  - until=1
[13:17:34.443]  - relaying element #1
[13:17:34.443] result() for ClusterFuture ...
[13:17:34.443] - result already collected: FutureResult
[13:17:34.443] result() for ClusterFuture ... done
[13:17:34.443] result() for ClusterFuture ...
[13:17:34.443] - result already collected: FutureResult
[13:17:34.443] result() for ClusterFuture ... done
[13:17:34.444] result() for ClusterFuture ...
[13:17:34.444] - result already collected: FutureResult
[13:17:34.444] result() for ClusterFuture ... done
[13:17:34.444] result() for ClusterFuture ...
[13:17:34.444] - result already collected: FutureResult
[13:17:34.444] result() for ClusterFuture ... done
[13:17:34.444] - relayed: [n=2] TRUE, FALSE
[13:17:34.444] - queued futures: [n=2] TRUE, FALSE
[13:17:34.444] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:34.444]  length: 1 (resolved future 1)
[13:17:34.474] receiveMessageFromWorker() for ClusterFuture ...
[13:17:34.474] - Validating connection of MultisessionFuture
[13:17:34.475] - received message: FutureResult
[13:17:34.475] - Received FutureResult
[13:17:34.475] - Erased future from FutureRegistry
[13:17:34.475] result() for ClusterFuture ...
[13:17:34.475] - result already collected: FutureResult
[13:17:34.475] result() for ClusterFuture ... done
[13:17:34.475] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:34.476] Future #2
[13:17:34.476] result() for ClusterFuture ...
[13:17:34.476] - result already collected: FutureResult
[13:17:34.476] result() for ClusterFuture ... done
[13:17:34.476] result() for ClusterFuture ...
[13:17:34.476] - result already collected: FutureResult
[13:17:34.476] result() for ClusterFuture ... done
[13:17:34.476] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:34.476] - nx: 2
[13:17:34.476] - relay: TRUE
[13:17:34.477] - stdout: TRUE
[13:17:34.477] - signal: TRUE
[13:17:34.477] - resignal: FALSE
[13:17:34.477] - force: TRUE
[13:17:34.477] - relayed: [n=2] TRUE, FALSE
[13:17:34.477] - queued futures: [n=2] TRUE, FALSE
[13:17:34.477]  - until=2
[13:17:34.477]  - relaying element #2
[13:17:34.477] result() for ClusterFuture ...
[13:17:34.477] - result already collected: FutureResult
[13:17:34.478] result() for ClusterFuture ... done
[13:17:34.478] result() for ClusterFuture ...
[13:17:34.478] - result already collected: FutureResult
[13:17:34.478] result() for ClusterFuture ... done
[13:17:34.478] result() for ClusterFuture ...
[13:17:34.478] - result already collected: FutureResult
[13:17:34.478] result() for ClusterFuture ... done
[13:17:34.478] result() for ClusterFuture ...
[13:17:34.478] - result already collected: FutureResult
[13:17:34.478] result() for ClusterFuture ... done
[13:17:34.478] - relayed: [n=2] TRUE, TRUE
[13:17:34.479] - queued futures: [n=2] TRUE, TRUE
[13:17:34.479] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:34.479]  length: 0 (resolved future 2)
[13:17:34.479] Relaying remaining futures
[13:17:34.479] signalConditionsASAP(NULL, pos=0) ...
[13:17:34.479] - nx: 2
[13:17:34.479] - relay: TRUE
[13:17:34.479] - stdout: TRUE
[13:17:34.479] - signal: TRUE
[13:17:34.479] - resignal: FALSE
[13:17:34.479] - force: TRUE
[13:17:34.480] - relayed: [n=2] TRUE, TRUE
[13:17:34.480] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:34.480] - relayed: [n=2] TRUE, TRUE
[13:17:34.480] - queued futures: [n=2] TRUE, TRUE
[13:17:34.480] signalConditionsASAP(NULL, pos=0) ... done
[13:17:34.480] resolve() on list ... DONE
[13:17:34.480] result() for ClusterFuture ...
[13:17:34.480] - result already collected: FutureResult
[13:17:34.480] result() for ClusterFuture ... done
[13:17:34.480] result() for ClusterFuture ...
[13:17:34.481] - result already collected: FutureResult
[13:17:34.481] result() for ClusterFuture ... done
[13:17:34.481] result() for ClusterFuture ...
[13:17:34.481] - result already collected: FutureResult
[13:17:34.481] result() for ClusterFuture ... done
[13:17:34.481] result() for ClusterFuture ...
[13:17:34.481] - result already collected: FutureResult
[13:17:34.481] result() for ClusterFuture ... done
[13:17:34.481]  - Number of value chunks collected: 2
[13:17:34.481] Resolving 2 futures (chunks) ... DONE
[13:17:34.482] Reducing values from 2 chunks ...
[13:17:34.482]  - Number of values collected after concatenation: 3
[13:17:34.482]  - Number of values expected: 3
[13:17:34.482] Reducing values from 2 chunks ... DONE
[13:17:34.482] future_lapply() ... DONE
[13:17:34.482] plan(): Setting new future strategy stack:
[13:17:34.482] List of future strategies:
[13:17:34.482] 1. sequential:
[13:17:34.482]    - args: function (..., envir = parent.frame())
[13:17:34.482]    - tweaked: FALSE
[13:17:34.482]    - call: plan(sequential)
[13:17:34.483] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[13:17:34.484] plan(): Setting new future strategy stack:
[13:17:34.484] List of future strategies:
[13:17:34.484] 1. FutureStrategy:
[13:17:34.484]    - args: function (..., envir = parent.frame())
[13:17:34.484]    - tweaked: FALSE
[13:17:34.484]    - call: future::plan(oplan)
[13:17:34.485] plan(): nbrOfWorkers() = 1
> 
