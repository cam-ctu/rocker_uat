
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:09:26.986] plan(): Setting new future strategy stack:
[16:09:26.986] List of future strategies:
[16:09:26.986] 1. sequential:
[16:09:26.986]    - args: function (..., envir = parent.frame())
[16:09:26.986]    - tweaked: FALSE
[16:09:26.986]    - call: future::plan("sequential")
[16:09:26.996] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:09:27.054] plan(): Setting new future strategy stack:
[16:09:27.054] List of future strategies:
[16:09:27.054] 1. sequential:
[16:09:27.054]    - args: function (..., envir = parent.frame())
[16:09:27.054]    - tweaked: FALSE
[16:09:27.054]    - call: plan(strategy)
[16:09:27.064] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[16:09:27.065] getGlobalsAndPackagesXApply() ...
[16:09:27.065]  - future.globals: TRUE
[16:09:27.066] getGlobalsAndPackages() ...
[16:09:27.066] Searching for globals...
[16:09:27.106] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:09:27.106] Searching for globals ... DONE
[16:09:27.106] Resolving globals: FALSE
[16:09:27.109] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:09:27.109] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:09:27.109] - globals: [1] ‘FUN’
[16:09:27.109] 
[16:09:27.109] getGlobalsAndPackages() ... DONE
[16:09:27.110]  - globals found/used: [n=1] ‘FUN’
[16:09:27.110]  - needed namespaces: [n=0] 
[16:09:27.110] Finding globals ... DONE
[16:09:27.110]  - use_args: TRUE
[16:09:27.110]  - Getting '...' globals ...
[16:09:27.111] resolve() on list ...
[16:09:27.111]  recursive: 0
[16:09:27.111]  length: 1
[16:09:27.111]  elements: ‘...’
[16:09:27.111]  length: 0 (resolved future 1)
[16:09:27.111] resolve() on list ... DONE
[16:09:27.112]    - '...' content: [n=0] 
[16:09:27.112] List of 1
[16:09:27.112]  $ ...: list()
[16:09:27.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.112]  - attr(*, "where")=List of 1
[16:09:27.112]   ..$ ...:<environment: 0x5633ac862a38> 
[16:09:27.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.112]  - attr(*, "resolved")= logi TRUE
[16:09:27.112]  - attr(*, "total_size")= num NA
[16:09:27.116]  - Getting '...' globals ... DONE
[16:09:27.117] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.117] List of 2
[16:09:27.117]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.117]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.117]  $ ...          : list()
[16:09:27.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.117]  - attr(*, "where")=List of 2
[16:09:27.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.117]   ..$ ...          :<environment: 0x5633ac862a38> 
[16:09:27.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.117]  - attr(*, "resolved")= logi FALSE
[16:09:27.117]  - attr(*, "total_size")= num 354224
[16:09:27.119] Packages to be attached in all futures: [n=0] 
[16:09:27.119] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.120] future_lapply() ...
[16:09:27.154] Number of chunks: 1
[16:09:27.154] getGlobalsAndPackagesXApply() ...
[16:09:27.154]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.154]  - use_args: TRUE
[16:09:27.154] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.154] List of 2
[16:09:27.154]  $ ...          : list()
[16:09:27.154]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.154]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.154]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.154]  - attr(*, "where")=List of 2
[16:09:27.154]   ..$ ...          :<environment: 0x5633ac862a38> 
[16:09:27.154]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.154]  - attr(*, "resolved")= logi FALSE
[16:09:27.154]  - attr(*, "total_size")= num NA
[16:09:27.158] Packages to be attached in all futures: [n=0] 
[16:09:27.158] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.158] Number of futures (= number of chunks): 1
[16:09:27.158] Launching 1 futures (chunks) ...
[16:09:27.158] Chunk #1 of 1 ...
[16:09:27.159]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.159]  - seeds: <none>
[16:09:27.159] getGlobalsAndPackages() ...
[16:09:27.159] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.159] Resolving globals: FALSE
[16:09:27.159] Tweak future expression to call with '...' arguments ...
[16:09:27.160] {
[16:09:27.160]     do.call(function(...) {
[16:09:27.160]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.160]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.160]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.160]             on.exit(options(oopts), add = TRUE)
[16:09:27.160]         }
[16:09:27.160]         {
[16:09:27.160]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.160]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.160]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.160]             })
[16:09:27.160]         }
[16:09:27.160]     }, args = future.call.arguments)
[16:09:27.160] }
[16:09:27.160] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.160] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.160] 
[16:09:27.160] getGlobalsAndPackages() ... DONE
[16:09:27.161] run() for ‘Future’ ...
[16:09:27.161] - state: ‘created’
[16:09:27.162] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.162] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.162] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.162]   - Field: ‘label’
[16:09:27.162]   - Field: ‘local’
[16:09:27.162]   - Field: ‘owner’
[16:09:27.162]   - Field: ‘envir’
[16:09:27.162]   - Field: ‘packages’
[16:09:27.163]   - Field: ‘gc’
[16:09:27.163]   - Field: ‘conditions’
[16:09:27.163]   - Field: ‘expr’
[16:09:27.163]   - Field: ‘uuid’
[16:09:27.163]   - Field: ‘seed’
[16:09:27.163]   - Field: ‘version’
[16:09:27.163]   - Field: ‘result’
[16:09:27.163]   - Field: ‘asynchronous’
[16:09:27.163]   - Field: ‘calls’
[16:09:27.163]   - Field: ‘globals’
[16:09:27.163]   - Field: ‘stdout’
[16:09:27.164]   - Field: ‘earlySignal’
[16:09:27.164]   - Field: ‘lazy’
[16:09:27.164]   - Field: ‘state’
[16:09:27.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.164] - Launch lazy future ...
[16:09:27.165] Packages needed by the future expression (n = 0): <none>
[16:09:27.165] Packages needed by future strategies (n = 0): <none>
[16:09:27.166] {
[16:09:27.166]     {
[16:09:27.166]         {
[16:09:27.166]             ...future.startTime <- base::Sys.time()
[16:09:27.166]             {
[16:09:27.166]                 {
[16:09:27.166]                   {
[16:09:27.166]                     base::local({
[16:09:27.166]                       has_future <- base::requireNamespace("future", 
[16:09:27.166]                         quietly = TRUE)
[16:09:27.166]                       if (has_future) {
[16:09:27.166]                         ns <- base::getNamespace("future")
[16:09:27.166]                         version <- ns[[".package"]][["version"]]
[16:09:27.166]                         if (is.null(version)) 
[16:09:27.166]                           version <- utils::packageVersion("future")
[16:09:27.166]                       }
[16:09:27.166]                       else {
[16:09:27.166]                         version <- NULL
[16:09:27.166]                       }
[16:09:27.166]                       if (!has_future || version < "1.8.0") {
[16:09:27.166]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.166]                           "", base::R.version$version.string), 
[16:09:27.166]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.166]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.166]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.166]                             "release", "version")], collapse = " "), 
[16:09:27.166]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.166]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.166]                           info)
[16:09:27.166]                         info <- base::paste(info, collapse = "; ")
[16:09:27.166]                         if (!has_future) {
[16:09:27.166]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.166]                             info)
[16:09:27.166]                         }
[16:09:27.166]                         else {
[16:09:27.166]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.166]                             info, version)
[16:09:27.166]                         }
[16:09:27.166]                         base::stop(msg)
[16:09:27.166]                       }
[16:09:27.166]                     })
[16:09:27.166]                   }
[16:09:27.166]                   options(future.plan = NULL)
[16:09:27.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.166]                 }
[16:09:27.166]                 ...future.workdir <- getwd()
[16:09:27.166]             }
[16:09:27.166]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.166]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.166]         }
[16:09:27.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.166]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.166]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.166]             base::names(...future.oldOptions))
[16:09:27.166]     }
[16:09:27.166]     if (FALSE) {
[16:09:27.166]     }
[16:09:27.166]     else {
[16:09:27.166]         if (TRUE) {
[16:09:27.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.166]                 open = "w")
[16:09:27.166]         }
[16:09:27.166]         else {
[16:09:27.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.166]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.166]         }
[16:09:27.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.166]             base::sink(type = "output", split = FALSE)
[16:09:27.166]             base::close(...future.stdout)
[16:09:27.166]         }, add = TRUE)
[16:09:27.166]     }
[16:09:27.166]     ...future.frame <- base::sys.nframe()
[16:09:27.166]     ...future.conditions <- base::list()
[16:09:27.166]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.166]     if (FALSE) {
[16:09:27.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.166]     }
[16:09:27.166]     ...future.result <- base::tryCatch({
[16:09:27.166]         base::withCallingHandlers({
[16:09:27.166]             ...future.value <- base::withVisible(base::local({
[16:09:27.166]                 do.call(function(...) {
[16:09:27.166]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.166]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.166]                     ...future.globals.maxSize)) {
[16:09:27.166]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.166]                     on.exit(options(oopts), add = TRUE)
[16:09:27.166]                   }
[16:09:27.166]                   {
[16:09:27.166]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.166]                       FUN = function(jj) {
[16:09:27.166]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.166]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.166]                       })
[16:09:27.166]                   }
[16:09:27.166]                 }, args = future.call.arguments)
[16:09:27.166]             }))
[16:09:27.166]             future::FutureResult(value = ...future.value$value, 
[16:09:27.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.166]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.166]                     ...future.globalenv.names))
[16:09:27.166]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.166]         }, condition = base::local({
[16:09:27.166]             c <- base::c
[16:09:27.166]             inherits <- base::inherits
[16:09:27.166]             invokeRestart <- base::invokeRestart
[16:09:27.166]             length <- base::length
[16:09:27.166]             list <- base::list
[16:09:27.166]             seq.int <- base::seq.int
[16:09:27.166]             signalCondition <- base::signalCondition
[16:09:27.166]             sys.calls <- base::sys.calls
[16:09:27.166]             `[[` <- base::`[[`
[16:09:27.166]             `+` <- base::`+`
[16:09:27.166]             `<<-` <- base::`<<-`
[16:09:27.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.166]                   3L)]
[16:09:27.166]             }
[16:09:27.166]             function(cond) {
[16:09:27.166]                 is_error <- inherits(cond, "error")
[16:09:27.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.166]                   NULL)
[16:09:27.166]                 if (is_error) {
[16:09:27.166]                   sessionInformation <- function() {
[16:09:27.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.166]                       search = base::search(), system = base::Sys.info())
[16:09:27.166]                   }
[16:09:27.166]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.166]                     cond$call), session = sessionInformation(), 
[16:09:27.166]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.166]                   signalCondition(cond)
[16:09:27.166]                 }
[16:09:27.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.166]                 "immediateCondition"))) {
[16:09:27.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.166]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.166]                   if (TRUE && !signal) {
[16:09:27.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.166]                     {
[16:09:27.166]                       inherits <- base::inherits
[16:09:27.166]                       invokeRestart <- base::invokeRestart
[16:09:27.166]                       is.null <- base::is.null
[16:09:27.166]                       muffled <- FALSE
[16:09:27.166]                       if (inherits(cond, "message")) {
[16:09:27.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.166]                         if (muffled) 
[16:09:27.166]                           invokeRestart("muffleMessage")
[16:09:27.166]                       }
[16:09:27.166]                       else if (inherits(cond, "warning")) {
[16:09:27.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.166]                         if (muffled) 
[16:09:27.166]                           invokeRestart("muffleWarning")
[16:09:27.166]                       }
[16:09:27.166]                       else if (inherits(cond, "condition")) {
[16:09:27.166]                         if (!is.null(pattern)) {
[16:09:27.166]                           computeRestarts <- base::computeRestarts
[16:09:27.166]                           grepl <- base::grepl
[16:09:27.166]                           restarts <- computeRestarts(cond)
[16:09:27.166]                           for (restart in restarts) {
[16:09:27.166]                             name <- restart$name
[16:09:27.166]                             if (is.null(name)) 
[16:09:27.166]                               next
[16:09:27.166]                             if (!grepl(pattern, name)) 
[16:09:27.166]                               next
[16:09:27.166]                             invokeRestart(restart)
[16:09:27.166]                             muffled <- TRUE
[16:09:27.166]                             break
[16:09:27.166]                           }
[16:09:27.166]                         }
[16:09:27.166]                       }
[16:09:27.166]                       invisible(muffled)
[16:09:27.166]                     }
[16:09:27.166]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.166]                   }
[16:09:27.166]                 }
[16:09:27.166]                 else {
[16:09:27.166]                   if (TRUE) {
[16:09:27.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.166]                     {
[16:09:27.166]                       inherits <- base::inherits
[16:09:27.166]                       invokeRestart <- base::invokeRestart
[16:09:27.166]                       is.null <- base::is.null
[16:09:27.166]                       muffled <- FALSE
[16:09:27.166]                       if (inherits(cond, "message")) {
[16:09:27.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.166]                         if (muffled) 
[16:09:27.166]                           invokeRestart("muffleMessage")
[16:09:27.166]                       }
[16:09:27.166]                       else if (inherits(cond, "warning")) {
[16:09:27.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.166]                         if (muffled) 
[16:09:27.166]                           invokeRestart("muffleWarning")
[16:09:27.166]                       }
[16:09:27.166]                       else if (inherits(cond, "condition")) {
[16:09:27.166]                         if (!is.null(pattern)) {
[16:09:27.166]                           computeRestarts <- base::computeRestarts
[16:09:27.166]                           grepl <- base::grepl
[16:09:27.166]                           restarts <- computeRestarts(cond)
[16:09:27.166]                           for (restart in restarts) {
[16:09:27.166]                             name <- restart$name
[16:09:27.166]                             if (is.null(name)) 
[16:09:27.166]                               next
[16:09:27.166]                             if (!grepl(pattern, name)) 
[16:09:27.166]                               next
[16:09:27.166]                             invokeRestart(restart)
[16:09:27.166]                             muffled <- TRUE
[16:09:27.166]                             break
[16:09:27.166]                           }
[16:09:27.166]                         }
[16:09:27.166]                       }
[16:09:27.166]                       invisible(muffled)
[16:09:27.166]                     }
[16:09:27.166]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.166]                   }
[16:09:27.166]                 }
[16:09:27.166]             }
[16:09:27.166]         }))
[16:09:27.166]     }, error = function(ex) {
[16:09:27.166]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.166]                 ...future.rng), started = ...future.startTime, 
[16:09:27.166]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.166]             version = "1.8"), class = "FutureResult")
[16:09:27.166]     }, finally = {
[16:09:27.166]         if (!identical(...future.workdir, getwd())) 
[16:09:27.166]             setwd(...future.workdir)
[16:09:27.166]         {
[16:09:27.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.166]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.166]             }
[16:09:27.166]             base::options(...future.oldOptions)
[16:09:27.166]             if (.Platform$OS.type == "windows") {
[16:09:27.166]                 old_names <- names(...future.oldEnvVars)
[16:09:27.166]                 envs <- base::Sys.getenv()
[16:09:27.166]                 names <- names(envs)
[16:09:27.166]                 common <- intersect(names, old_names)
[16:09:27.166]                 added <- setdiff(names, old_names)
[16:09:27.166]                 removed <- setdiff(old_names, names)
[16:09:27.166]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.166]                   envs[common]]
[16:09:27.166]                 NAMES <- toupper(changed)
[16:09:27.166]                 args <- list()
[16:09:27.166]                 for (kk in seq_along(NAMES)) {
[16:09:27.166]                   name <- changed[[kk]]
[16:09:27.166]                   NAME <- NAMES[[kk]]
[16:09:27.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.166]                     next
[16:09:27.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.166]                 }
[16:09:27.166]                 NAMES <- toupper(added)
[16:09:27.166]                 for (kk in seq_along(NAMES)) {
[16:09:27.166]                   name <- added[[kk]]
[16:09:27.166]                   NAME <- NAMES[[kk]]
[16:09:27.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.166]                     next
[16:09:27.166]                   args[[name]] <- ""
[16:09:27.166]                 }
[16:09:27.166]                 NAMES <- toupper(removed)
[16:09:27.166]                 for (kk in seq_along(NAMES)) {
[16:09:27.166]                   name <- removed[[kk]]
[16:09:27.166]                   NAME <- NAMES[[kk]]
[16:09:27.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.166]                     next
[16:09:27.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.166]                 }
[16:09:27.166]                 if (length(args) > 0) 
[16:09:27.166]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.166]             }
[16:09:27.166]             else {
[16:09:27.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.166]             }
[16:09:27.166]             {
[16:09:27.166]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.166]                   0L) {
[16:09:27.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.166]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.166]                   base::options(opts)
[16:09:27.166]                 }
[16:09:27.166]                 {
[16:09:27.166]                   {
[16:09:27.166]                     NULL
[16:09:27.166]                     RNGkind("Mersenne-Twister")
[16:09:27.166]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.166]                       inherits = FALSE)
[16:09:27.166]                   }
[16:09:27.166]                   options(future.plan = NULL)
[16:09:27.166]                   if (is.na(NA_character_)) 
[16:09:27.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.166]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.166]                   {
[16:09:27.166]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.166]                     if (!future$lazy) 
[16:09:27.166]                       future <- run(future)
[16:09:27.166]                     invisible(future)
[16:09:27.166]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.166]                 }
[16:09:27.166]             }
[16:09:27.166]         }
[16:09:27.166]     })
[16:09:27.166]     if (TRUE) {
[16:09:27.166]         base::sink(type = "output", split = FALSE)
[16:09:27.166]         if (TRUE) {
[16:09:27.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.166]         }
[16:09:27.166]         else {
[16:09:27.166]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.166]         }
[16:09:27.166]         base::close(...future.stdout)
[16:09:27.166]         ...future.stdout <- NULL
[16:09:27.166]     }
[16:09:27.166]     ...future.result$conditions <- ...future.conditions
[16:09:27.166]     ...future.result$finished <- base::Sys.time()
[16:09:27.166]     ...future.result
[16:09:27.166] }
[16:09:27.168] assign_globals() ...
[16:09:27.168] List of 5
[16:09:27.168]  $ future.call.arguments    : list()
[16:09:27.168]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.168]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.168]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.168]  $ ...future.elements_ii    :List of 2
[16:09:27.168]   ..$ : num [1:4] 1 3 1 7
[16:09:27.168]   ..$ : num [1:4] 2 4 6 8
[16:09:27.168]  $ ...future.seeds_ii       : NULL
[16:09:27.168]  $ ...future.globals.maxSize: num Inf
[16:09:27.168]  - attr(*, "resolved")= logi FALSE
[16:09:27.168]  - attr(*, "total_size")= num NA
[16:09:27.168]  - attr(*, "where")=List of 5
[16:09:27.168]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.168]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.168]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.168]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.168]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.168]  - attr(*, "already-done")= logi TRUE
[16:09:27.174] - copied ‘future.call.arguments’ to environment
[16:09:27.174] - copied ‘...future.FUN’ to environment
[16:09:27.174] - copied ‘...future.elements_ii’ to environment
[16:09:27.174] - copied ‘...future.seeds_ii’ to environment
[16:09:27.174] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.175] assign_globals() ... done
[16:09:27.175] plan(): Setting new future strategy stack:
[16:09:27.175] List of future strategies:
[16:09:27.175] 1. sequential:
[16:09:27.175]    - args: function (..., envir = parent.frame())
[16:09:27.175]    - tweaked: FALSE
[16:09:27.175]    - call: NULL
[16:09:27.175] plan(): nbrOfWorkers() = 1
[16:09:27.177] plan(): Setting new future strategy stack:
[16:09:27.177] List of future strategies:
[16:09:27.177] 1. sequential:
[16:09:27.177]    - args: function (..., envir = parent.frame())
[16:09:27.177]    - tweaked: FALSE
[16:09:27.177]    - call: plan(strategy)
[16:09:27.177] plan(): nbrOfWorkers() = 1
[16:09:27.177] SequentialFuture started (and completed)
[16:09:27.178] - Launch lazy future ... done
[16:09:27.178] run() for ‘SequentialFuture’ ... done
[16:09:27.178] Created future:
[16:09:27.178] SequentialFuture:
[16:09:27.178] Label: ‘future_apply-1’
[16:09:27.178] Expression:
[16:09:27.178] {
[16:09:27.178]     do.call(function(...) {
[16:09:27.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.178]             on.exit(options(oopts), add = TRUE)
[16:09:27.178]         }
[16:09:27.178]         {
[16:09:27.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.178]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.178]             })
[16:09:27.178]         }
[16:09:27.178]     }, args = future.call.arguments)
[16:09:27.178] }
[16:09:27.178] Lazy evaluation: FALSE
[16:09:27.178] Asynchronous evaluation: FALSE
[16:09:27.178] Local evaluation: TRUE
[16:09:27.178] Environment: R_GlobalEnv
[16:09:27.178] Capture standard output: TRUE
[16:09:27.178] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.178] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.178] Packages: <none>
[16:09:27.178] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.178] Resolved: TRUE
[16:09:27.178] Value: 2.21 KiB of class ‘list’
[16:09:27.178] Early signaling: FALSE
[16:09:27.178] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.178] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.180] Chunk #1 of 1 ... DONE
[16:09:27.180] Launching 1 futures (chunks) ... DONE
[16:09:27.180] Resolving 1 futures (chunks) ...
[16:09:27.180] resolve() on list ...
[16:09:27.180]  recursive: 0
[16:09:27.180]  length: 1
[16:09:27.180] 
[16:09:27.181] resolved() for ‘SequentialFuture’ ...
[16:09:27.181] - state: ‘finished’
[16:09:27.181] - run: TRUE
[16:09:27.181] - result: ‘FutureResult’
[16:09:27.181] resolved() for ‘SequentialFuture’ ... done
[16:09:27.181] Future #1
[16:09:27.181] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.182] - nx: 1
[16:09:27.182] - relay: TRUE
[16:09:27.182] - stdout: TRUE
[16:09:27.182] - signal: TRUE
[16:09:27.182] - resignal: FALSE
[16:09:27.182] - force: TRUE
[16:09:27.182] - relayed: [n=1] FALSE
[16:09:27.182] - queued futures: [n=1] FALSE
[16:09:27.182]  - until=1
[16:09:27.182]  - relaying element #1
[16:09:27.183] - relayed: [n=1] TRUE
[16:09:27.183] - queued futures: [n=1] TRUE
[16:09:27.183] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.183]  length: 0 (resolved future 1)
[16:09:27.183] Relaying remaining futures
[16:09:27.183] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.183] - nx: 1
[16:09:27.183] - relay: TRUE
[16:09:27.183] - stdout: TRUE
[16:09:27.183] - signal: TRUE
[16:09:27.184] - resignal: FALSE
[16:09:27.184] - force: TRUE
[16:09:27.184] - relayed: [n=1] TRUE
[16:09:27.184] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.184] - relayed: [n=1] TRUE
[16:09:27.184] - queued futures: [n=1] TRUE
[16:09:27.184] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.184] resolve() on list ... DONE
[16:09:27.184]  - Number of value chunks collected: 1
[16:09:27.184] Resolving 1 futures (chunks) ... DONE
[16:09:27.185] Reducing values from 1 chunks ...
[16:09:27.185]  - Number of values collected after concatenation: 2
[16:09:27.185]  - Number of values expected: 2
[16:09:27.185] Reducing values from 1 chunks ... DONE
[16:09:27.185] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:09:27.186] getGlobalsAndPackagesXApply() ...
[16:09:27.186]  - future.globals: TRUE
[16:09:27.186] getGlobalsAndPackages() ...
[16:09:27.186] Searching for globals...
[16:09:27.220] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:09:27.220] Searching for globals ... DONE
[16:09:27.220] Resolving globals: FALSE
[16:09:27.222] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:09:27.222] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:09:27.222] - globals: [1] ‘FUN’
[16:09:27.222] 
[16:09:27.222] getGlobalsAndPackages() ... DONE
[16:09:27.223]  - globals found/used: [n=1] ‘FUN’
[16:09:27.223]  - needed namespaces: [n=0] 
[16:09:27.223] Finding globals ... DONE
[16:09:27.223]  - use_args: TRUE
[16:09:27.223]  - Getting '...' globals ...
[16:09:27.223] resolve() on list ...
[16:09:27.223]  recursive: 0
[16:09:27.223]  length: 1
[16:09:27.223]  elements: ‘...’
[16:09:27.224]  length: 0 (resolved future 1)
[16:09:27.224] resolve() on list ... DONE
[16:09:27.224]    - '...' content: [n=0] 
[16:09:27.224] List of 1
[16:09:27.224]  $ ...: list()
[16:09:27.224]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.224]  - attr(*, "where")=List of 1
[16:09:27.224]   ..$ ...:<environment: 0x5633ac242888> 
[16:09:27.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.224]  - attr(*, "resolved")= logi TRUE
[16:09:27.224]  - attr(*, "total_size")= num NA
[16:09:27.226]  - Getting '...' globals ... DONE
[16:09:27.226] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.227] List of 2
[16:09:27.227]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.227]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.227]  $ ...          : list()
[16:09:27.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.227]  - attr(*, "where")=List of 2
[16:09:27.227]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.227]   ..$ ...          :<environment: 0x5633ac242888> 
[16:09:27.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.227]  - attr(*, "resolved")= logi FALSE
[16:09:27.227]  - attr(*, "total_size")= num 354224
[16:09:27.229] Packages to be attached in all futures: [n=0] 
[16:09:27.229] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.230] future_lapply() ...
[16:09:27.261] Number of chunks: 1
[16:09:27.261] getGlobalsAndPackagesXApply() ...
[16:09:27.261]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.261]  - use_args: TRUE
[16:09:27.261] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.262] List of 2
[16:09:27.262]  $ ...          : list()
[16:09:27.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.262]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.262]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.262]  - attr(*, "where")=List of 2
[16:09:27.262]   ..$ ...          :<environment: 0x5633ac242888> 
[16:09:27.262]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.262]  - attr(*, "resolved")= logi FALSE
[16:09:27.262]  - attr(*, "total_size")= num NA
[16:09:27.265] Packages to be attached in all futures: [n=0] 
[16:09:27.265] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.265] Number of futures (= number of chunks): 1
[16:09:27.265] Launching 1 futures (chunks) ...
[16:09:27.265] Chunk #1 of 1 ...
[16:09:27.265]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.265]  - seeds: <none>
[16:09:27.266] getGlobalsAndPackages() ...
[16:09:27.266] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.266] Resolving globals: FALSE
[16:09:27.266] Tweak future expression to call with '...' arguments ...
[16:09:27.266] {
[16:09:27.266]     do.call(function(...) {
[16:09:27.266]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.266]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.266]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.266]             on.exit(options(oopts), add = TRUE)
[16:09:27.266]         }
[16:09:27.266]         {
[16:09:27.266]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.266]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.266]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.266]             })
[16:09:27.266]         }
[16:09:27.266]     }, args = future.call.arguments)
[16:09:27.266] }
[16:09:27.266] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.267] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.267] 
[16:09:27.267] getGlobalsAndPackages() ... DONE
[16:09:27.267] run() for ‘Future’ ...
[16:09:27.267] - state: ‘created’
[16:09:27.267] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.268] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.268]   - Field: ‘label’
[16:09:27.268]   - Field: ‘local’
[16:09:27.268]   - Field: ‘owner’
[16:09:27.268]   - Field: ‘envir’
[16:09:27.268]   - Field: ‘packages’
[16:09:27.268]   - Field: ‘gc’
[16:09:27.268]   - Field: ‘conditions’
[16:09:27.268]   - Field: ‘expr’
[16:09:27.269]   - Field: ‘uuid’
[16:09:27.269]   - Field: ‘seed’
[16:09:27.270]   - Field: ‘version’
[16:09:27.270]   - Field: ‘result’
[16:09:27.270]   - Field: ‘asynchronous’
[16:09:27.270]   - Field: ‘calls’
[16:09:27.270]   - Field: ‘globals’
[16:09:27.270]   - Field: ‘stdout’
[16:09:27.270]   - Field: ‘earlySignal’
[16:09:27.270]   - Field: ‘lazy’
[16:09:27.270]   - Field: ‘state’
[16:09:27.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.270] - Launch lazy future ...
[16:09:27.271] Packages needed by the future expression (n = 0): <none>
[16:09:27.271] Packages needed by future strategies (n = 0): <none>
[16:09:27.271] {
[16:09:27.271]     {
[16:09:27.271]         {
[16:09:27.271]             ...future.startTime <- base::Sys.time()
[16:09:27.271]             {
[16:09:27.271]                 {
[16:09:27.271]                   {
[16:09:27.271]                     base::local({
[16:09:27.271]                       has_future <- base::requireNamespace("future", 
[16:09:27.271]                         quietly = TRUE)
[16:09:27.271]                       if (has_future) {
[16:09:27.271]                         ns <- base::getNamespace("future")
[16:09:27.271]                         version <- ns[[".package"]][["version"]]
[16:09:27.271]                         if (is.null(version)) 
[16:09:27.271]                           version <- utils::packageVersion("future")
[16:09:27.271]                       }
[16:09:27.271]                       else {
[16:09:27.271]                         version <- NULL
[16:09:27.271]                       }
[16:09:27.271]                       if (!has_future || version < "1.8.0") {
[16:09:27.271]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.271]                           "", base::R.version$version.string), 
[16:09:27.271]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.271]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.271]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.271]                             "release", "version")], collapse = " "), 
[16:09:27.271]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.271]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.271]                           info)
[16:09:27.271]                         info <- base::paste(info, collapse = "; ")
[16:09:27.271]                         if (!has_future) {
[16:09:27.271]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.271]                             info)
[16:09:27.271]                         }
[16:09:27.271]                         else {
[16:09:27.271]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.271]                             info, version)
[16:09:27.271]                         }
[16:09:27.271]                         base::stop(msg)
[16:09:27.271]                       }
[16:09:27.271]                     })
[16:09:27.271]                   }
[16:09:27.271]                   options(future.plan = NULL)
[16:09:27.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.271]                 }
[16:09:27.271]                 ...future.workdir <- getwd()
[16:09:27.271]             }
[16:09:27.271]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.271]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.271]         }
[16:09:27.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.271]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.271]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.271]             base::names(...future.oldOptions))
[16:09:27.271]     }
[16:09:27.271]     if (FALSE) {
[16:09:27.271]     }
[16:09:27.271]     else {
[16:09:27.271]         if (TRUE) {
[16:09:27.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.271]                 open = "w")
[16:09:27.271]         }
[16:09:27.271]         else {
[16:09:27.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.271]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.271]         }
[16:09:27.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.271]             base::sink(type = "output", split = FALSE)
[16:09:27.271]             base::close(...future.stdout)
[16:09:27.271]         }, add = TRUE)
[16:09:27.271]     }
[16:09:27.271]     ...future.frame <- base::sys.nframe()
[16:09:27.271]     ...future.conditions <- base::list()
[16:09:27.271]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.271]     if (FALSE) {
[16:09:27.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.271]     }
[16:09:27.271]     ...future.result <- base::tryCatch({
[16:09:27.271]         base::withCallingHandlers({
[16:09:27.271]             ...future.value <- base::withVisible(base::local({
[16:09:27.271]                 do.call(function(...) {
[16:09:27.271]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.271]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.271]                     ...future.globals.maxSize)) {
[16:09:27.271]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.271]                     on.exit(options(oopts), add = TRUE)
[16:09:27.271]                   }
[16:09:27.271]                   {
[16:09:27.271]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.271]                       FUN = function(jj) {
[16:09:27.271]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.271]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.271]                       })
[16:09:27.271]                   }
[16:09:27.271]                 }, args = future.call.arguments)
[16:09:27.271]             }))
[16:09:27.271]             future::FutureResult(value = ...future.value$value, 
[16:09:27.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.271]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.271]                     ...future.globalenv.names))
[16:09:27.271]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.271]         }, condition = base::local({
[16:09:27.271]             c <- base::c
[16:09:27.271]             inherits <- base::inherits
[16:09:27.271]             invokeRestart <- base::invokeRestart
[16:09:27.271]             length <- base::length
[16:09:27.271]             list <- base::list
[16:09:27.271]             seq.int <- base::seq.int
[16:09:27.271]             signalCondition <- base::signalCondition
[16:09:27.271]             sys.calls <- base::sys.calls
[16:09:27.271]             `[[` <- base::`[[`
[16:09:27.271]             `+` <- base::`+`
[16:09:27.271]             `<<-` <- base::`<<-`
[16:09:27.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.271]                   3L)]
[16:09:27.271]             }
[16:09:27.271]             function(cond) {
[16:09:27.271]                 is_error <- inherits(cond, "error")
[16:09:27.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.271]                   NULL)
[16:09:27.271]                 if (is_error) {
[16:09:27.271]                   sessionInformation <- function() {
[16:09:27.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.271]                       search = base::search(), system = base::Sys.info())
[16:09:27.271]                   }
[16:09:27.271]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.271]                     cond$call), session = sessionInformation(), 
[16:09:27.271]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.271]                   signalCondition(cond)
[16:09:27.271]                 }
[16:09:27.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.271]                 "immediateCondition"))) {
[16:09:27.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.271]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.271]                   if (TRUE && !signal) {
[16:09:27.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.271]                     {
[16:09:27.271]                       inherits <- base::inherits
[16:09:27.271]                       invokeRestart <- base::invokeRestart
[16:09:27.271]                       is.null <- base::is.null
[16:09:27.271]                       muffled <- FALSE
[16:09:27.271]                       if (inherits(cond, "message")) {
[16:09:27.271]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.271]                         if (muffled) 
[16:09:27.271]                           invokeRestart("muffleMessage")
[16:09:27.271]                       }
[16:09:27.271]                       else if (inherits(cond, "warning")) {
[16:09:27.271]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.271]                         if (muffled) 
[16:09:27.271]                           invokeRestart("muffleWarning")
[16:09:27.271]                       }
[16:09:27.271]                       else if (inherits(cond, "condition")) {
[16:09:27.271]                         if (!is.null(pattern)) {
[16:09:27.271]                           computeRestarts <- base::computeRestarts
[16:09:27.271]                           grepl <- base::grepl
[16:09:27.271]                           restarts <- computeRestarts(cond)
[16:09:27.271]                           for (restart in restarts) {
[16:09:27.271]                             name <- restart$name
[16:09:27.271]                             if (is.null(name)) 
[16:09:27.271]                               next
[16:09:27.271]                             if (!grepl(pattern, name)) 
[16:09:27.271]                               next
[16:09:27.271]                             invokeRestart(restart)
[16:09:27.271]                             muffled <- TRUE
[16:09:27.271]                             break
[16:09:27.271]                           }
[16:09:27.271]                         }
[16:09:27.271]                       }
[16:09:27.271]                       invisible(muffled)
[16:09:27.271]                     }
[16:09:27.271]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.271]                   }
[16:09:27.271]                 }
[16:09:27.271]                 else {
[16:09:27.271]                   if (TRUE) {
[16:09:27.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.271]                     {
[16:09:27.271]                       inherits <- base::inherits
[16:09:27.271]                       invokeRestart <- base::invokeRestart
[16:09:27.271]                       is.null <- base::is.null
[16:09:27.271]                       muffled <- FALSE
[16:09:27.271]                       if (inherits(cond, "message")) {
[16:09:27.271]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.271]                         if (muffled) 
[16:09:27.271]                           invokeRestart("muffleMessage")
[16:09:27.271]                       }
[16:09:27.271]                       else if (inherits(cond, "warning")) {
[16:09:27.271]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.271]                         if (muffled) 
[16:09:27.271]                           invokeRestart("muffleWarning")
[16:09:27.271]                       }
[16:09:27.271]                       else if (inherits(cond, "condition")) {
[16:09:27.271]                         if (!is.null(pattern)) {
[16:09:27.271]                           computeRestarts <- base::computeRestarts
[16:09:27.271]                           grepl <- base::grepl
[16:09:27.271]                           restarts <- computeRestarts(cond)
[16:09:27.271]                           for (restart in restarts) {
[16:09:27.271]                             name <- restart$name
[16:09:27.271]                             if (is.null(name)) 
[16:09:27.271]                               next
[16:09:27.271]                             if (!grepl(pattern, name)) 
[16:09:27.271]                               next
[16:09:27.271]                             invokeRestart(restart)
[16:09:27.271]                             muffled <- TRUE
[16:09:27.271]                             break
[16:09:27.271]                           }
[16:09:27.271]                         }
[16:09:27.271]                       }
[16:09:27.271]                       invisible(muffled)
[16:09:27.271]                     }
[16:09:27.271]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.271]                   }
[16:09:27.271]                 }
[16:09:27.271]             }
[16:09:27.271]         }))
[16:09:27.271]     }, error = function(ex) {
[16:09:27.271]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.271]                 ...future.rng), started = ...future.startTime, 
[16:09:27.271]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.271]             version = "1.8"), class = "FutureResult")
[16:09:27.271]     }, finally = {
[16:09:27.271]         if (!identical(...future.workdir, getwd())) 
[16:09:27.271]             setwd(...future.workdir)
[16:09:27.271]         {
[16:09:27.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.271]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.271]             }
[16:09:27.271]             base::options(...future.oldOptions)
[16:09:27.271]             if (.Platform$OS.type == "windows") {
[16:09:27.271]                 old_names <- names(...future.oldEnvVars)
[16:09:27.271]                 envs <- base::Sys.getenv()
[16:09:27.271]                 names <- names(envs)
[16:09:27.271]                 common <- intersect(names, old_names)
[16:09:27.271]                 added <- setdiff(names, old_names)
[16:09:27.271]                 removed <- setdiff(old_names, names)
[16:09:27.271]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.271]                   envs[common]]
[16:09:27.271]                 NAMES <- toupper(changed)
[16:09:27.271]                 args <- list()
[16:09:27.271]                 for (kk in seq_along(NAMES)) {
[16:09:27.271]                   name <- changed[[kk]]
[16:09:27.271]                   NAME <- NAMES[[kk]]
[16:09:27.271]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.271]                     next
[16:09:27.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.271]                 }
[16:09:27.271]                 NAMES <- toupper(added)
[16:09:27.271]                 for (kk in seq_along(NAMES)) {
[16:09:27.271]                   name <- added[[kk]]
[16:09:27.271]                   NAME <- NAMES[[kk]]
[16:09:27.271]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.271]                     next
[16:09:27.271]                   args[[name]] <- ""
[16:09:27.271]                 }
[16:09:27.271]                 NAMES <- toupper(removed)
[16:09:27.271]                 for (kk in seq_along(NAMES)) {
[16:09:27.271]                   name <- removed[[kk]]
[16:09:27.271]                   NAME <- NAMES[[kk]]
[16:09:27.271]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.271]                     next
[16:09:27.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.271]                 }
[16:09:27.271]                 if (length(args) > 0) 
[16:09:27.271]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.271]             }
[16:09:27.271]             else {
[16:09:27.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.271]             }
[16:09:27.271]             {
[16:09:27.271]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.271]                   0L) {
[16:09:27.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.271]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.271]                   base::options(opts)
[16:09:27.271]                 }
[16:09:27.271]                 {
[16:09:27.271]                   {
[16:09:27.271]                     NULL
[16:09:27.271]                     RNGkind("Mersenne-Twister")
[16:09:27.271]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.271]                       inherits = FALSE)
[16:09:27.271]                   }
[16:09:27.271]                   options(future.plan = NULL)
[16:09:27.271]                   if (is.na(NA_character_)) 
[16:09:27.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.271]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.271]                   {
[16:09:27.271]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.271]                     if (!future$lazy) 
[16:09:27.271]                       future <- run(future)
[16:09:27.271]                     invisible(future)
[16:09:27.271]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.271]                 }
[16:09:27.271]             }
[16:09:27.271]         }
[16:09:27.271]     })
[16:09:27.271]     if (TRUE) {
[16:09:27.271]         base::sink(type = "output", split = FALSE)
[16:09:27.271]         if (TRUE) {
[16:09:27.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.271]         }
[16:09:27.271]         else {
[16:09:27.271]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.271]         }
[16:09:27.271]         base::close(...future.stdout)
[16:09:27.271]         ...future.stdout <- NULL
[16:09:27.271]     }
[16:09:27.271]     ...future.result$conditions <- ...future.conditions
[16:09:27.271]     ...future.result$finished <- base::Sys.time()
[16:09:27.271]     ...future.result
[16:09:27.271] }
[16:09:27.273] assign_globals() ...
[16:09:27.273] List of 5
[16:09:27.273]  $ future.call.arguments    : list()
[16:09:27.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.273]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.273]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.273]  $ ...future.elements_ii    :List of 2
[16:09:27.273]   ..$ : num [1:4] 1 3 1 7
[16:09:27.273]   ..$ : num [1:4] 2 4 6 8
[16:09:27.273]  $ ...future.seeds_ii       : NULL
[16:09:27.273]  $ ...future.globals.maxSize: num Inf
[16:09:27.273]  - attr(*, "resolved")= logi FALSE
[16:09:27.273]  - attr(*, "total_size")= num NA
[16:09:27.273]  - attr(*, "where")=List of 5
[16:09:27.273]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.273]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.273]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.273]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.273]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.273]  - attr(*, "already-done")= logi TRUE
[16:09:27.278] - copied ‘future.call.arguments’ to environment
[16:09:27.278] - copied ‘...future.FUN’ to environment
[16:09:27.278] - copied ‘...future.elements_ii’ to environment
[16:09:27.278] - copied ‘...future.seeds_ii’ to environment
[16:09:27.278] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.278] assign_globals() ... done
[16:09:27.278] plan(): Setting new future strategy stack:
[16:09:27.279] List of future strategies:
[16:09:27.279] 1. sequential:
[16:09:27.279]    - args: function (..., envir = parent.frame())
[16:09:27.279]    - tweaked: FALSE
[16:09:27.279]    - call: NULL
[16:09:27.279] plan(): nbrOfWorkers() = 1
[16:09:27.280] plan(): Setting new future strategy stack:
[16:09:27.280] List of future strategies:
[16:09:27.280] 1. sequential:
[16:09:27.280]    - args: function (..., envir = parent.frame())
[16:09:27.280]    - tweaked: FALSE
[16:09:27.280]    - call: plan(strategy)
[16:09:27.280] plan(): nbrOfWorkers() = 1
[16:09:27.280] SequentialFuture started (and completed)
[16:09:27.281] - Launch lazy future ... done
[16:09:27.281] run() for ‘SequentialFuture’ ... done
[16:09:27.281] Created future:
[16:09:27.281] SequentialFuture:
[16:09:27.281] Label: ‘future_apply-1’
[16:09:27.281] Expression:
[16:09:27.281] {
[16:09:27.281]     do.call(function(...) {
[16:09:27.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.281]             on.exit(options(oopts), add = TRUE)
[16:09:27.281]         }
[16:09:27.281]         {
[16:09:27.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.281]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.281]             })
[16:09:27.281]         }
[16:09:27.281]     }, args = future.call.arguments)
[16:09:27.281] }
[16:09:27.281] Lazy evaluation: FALSE
[16:09:27.281] Asynchronous evaluation: FALSE
[16:09:27.281] Local evaluation: TRUE
[16:09:27.281] Environment: R_GlobalEnv
[16:09:27.281] Capture standard output: TRUE
[16:09:27.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.281] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.281] Packages: <none>
[16:09:27.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.281] Resolved: TRUE
[16:09:27.281] Value: 2.21 KiB of class ‘list’
[16:09:27.281] Early signaling: FALSE
[16:09:27.281] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.281] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.282] Chunk #1 of 1 ... DONE
[16:09:27.282] Launching 1 futures (chunks) ... DONE
[16:09:27.282] Resolving 1 futures (chunks) ...
[16:09:27.282] resolve() on list ...
[16:09:27.282]  recursive: 0
[16:09:27.282]  length: 1
[16:09:27.282] 
[16:09:27.282] resolved() for ‘SequentialFuture’ ...
[16:09:27.283] - state: ‘finished’
[16:09:27.283] - run: TRUE
[16:09:27.283] - result: ‘FutureResult’
[16:09:27.283] resolved() for ‘SequentialFuture’ ... done
[16:09:27.283] Future #1
[16:09:27.283] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.283] - nx: 1
[16:09:27.283] - relay: TRUE
[16:09:27.283] - stdout: TRUE
[16:09:27.283] - signal: TRUE
[16:09:27.283] - resignal: FALSE
[16:09:27.284] - force: TRUE
[16:09:27.284] - relayed: [n=1] FALSE
[16:09:27.284] - queued futures: [n=1] FALSE
[16:09:27.284]  - until=1
[16:09:27.284]  - relaying element #1
[16:09:27.284] - relayed: [n=1] TRUE
[16:09:27.284] - queued futures: [n=1] TRUE
[16:09:27.284] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.284]  length: 0 (resolved future 1)
[16:09:27.284] Relaying remaining futures
[16:09:27.285] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.285] - nx: 1
[16:09:27.285] - relay: TRUE
[16:09:27.285] - stdout: TRUE
[16:09:27.285] - signal: TRUE
[16:09:27.285] - resignal: FALSE
[16:09:27.285] - force: TRUE
[16:09:27.285] - relayed: [n=1] TRUE
[16:09:27.285] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.285] - relayed: [n=1] TRUE
[16:09:27.285] - queued futures: [n=1] TRUE
[16:09:27.285] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.286] resolve() on list ... DONE
[16:09:27.286]  - Number of value chunks collected: 1
[16:09:27.286] Resolving 1 futures (chunks) ... DONE
[16:09:27.286] Reducing values from 1 chunks ...
[16:09:27.286]  - Number of values collected after concatenation: 2
[16:09:27.286]  - Number of values expected: 2
[16:09:27.286] Reducing values from 1 chunks ... DONE
[16:09:27.286] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:09:27.289] getGlobalsAndPackagesXApply() ...
[16:09:27.289]  - future.globals: TRUE
[16:09:27.289] getGlobalsAndPackages() ...
[16:09:27.289] Searching for globals...
[16:09:27.290] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:27.290] Searching for globals ... DONE
[16:09:27.290] Resolving globals: FALSE
[16:09:27.290] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:27.291] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:27.291] - globals: [1] ‘FUN’
[16:09:27.291] - packages: [1] ‘stats’
[16:09:27.291] getGlobalsAndPackages() ... DONE
[16:09:27.291]  - globals found/used: [n=1] ‘FUN’
[16:09:27.291]  - needed namespaces: [n=1] ‘stats’
[16:09:27.291] Finding globals ... DONE
[16:09:27.291]  - use_args: TRUE
[16:09:27.292]  - Getting '...' globals ...
[16:09:27.292] resolve() on list ...
[16:09:27.292]  recursive: 0
[16:09:27.292]  length: 1
[16:09:27.292]  elements: ‘...’
[16:09:27.292]  length: 0 (resolved future 1)
[16:09:27.292] resolve() on list ... DONE
[16:09:27.292]    - '...' content: [n=0] 
[16:09:27.293] List of 1
[16:09:27.293]  $ ...: list()
[16:09:27.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.293]  - attr(*, "where")=List of 1
[16:09:27.293]   ..$ ...:<environment: 0x5633ac699dc0> 
[16:09:27.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.293]  - attr(*, "resolved")= logi TRUE
[16:09:27.293]  - attr(*, "total_size")= num NA
[16:09:27.296]  - Getting '...' globals ... DONE
[16:09:27.296] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.296] List of 2
[16:09:27.296]  $ ...future.FUN:function (x, ...)  
[16:09:27.296]  $ ...          : list()
[16:09:27.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.296]  - attr(*, "where")=List of 2
[16:09:27.296]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.296]   ..$ ...          :<environment: 0x5633ac699dc0> 
[16:09:27.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.296]  - attr(*, "resolved")= logi FALSE
[16:09:27.296]  - attr(*, "total_size")= num 1248
[16:09:27.299] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:27.299] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.299] future_lapply() ...
[16:09:27.300] Number of chunks: 1
[16:09:27.300] getGlobalsAndPackagesXApply() ...
[16:09:27.300]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.300]  - use_args: TRUE
[16:09:27.300] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.300] List of 2
[16:09:27.300]  $ ...          : list()
[16:09:27.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.300]  $ ...future.FUN:function (x, ...)  
[16:09:27.300]  - attr(*, "where")=List of 2
[16:09:27.300]   ..$ ...          :<environment: 0x5633ac699dc0> 
[16:09:27.300]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:09:27.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.300]  - attr(*, "resolved")= logi FALSE
[16:09:27.300]  - attr(*, "total_size")= num NA
[16:09:27.303] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:27.303] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.303] Number of futures (= number of chunks): 1
[16:09:27.303] Launching 1 futures (chunks) ...
[16:09:27.303] Chunk #1 of 1 ...
[16:09:27.303]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.304]  - seeds: <none>
[16:09:27.304] getGlobalsAndPackages() ...
[16:09:27.304] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.304] Resolving globals: FALSE
[16:09:27.304] Tweak future expression to call with '...' arguments ...
[16:09:27.304] {
[16:09:27.304]     do.call(function(...) {
[16:09:27.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.304]             on.exit(options(oopts), add = TRUE)
[16:09:27.304]         }
[16:09:27.304]         {
[16:09:27.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.304]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.304]             })
[16:09:27.304]         }
[16:09:27.304]     }, args = future.call.arguments)
[16:09:27.304] }
[16:09:27.304] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.305] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.305] - packages: [1] ‘stats’
[16:09:27.305] getGlobalsAndPackages() ... DONE
[16:09:27.305] run() for ‘Future’ ...
[16:09:27.305] - state: ‘created’
[16:09:27.305] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.306]   - Field: ‘label’
[16:09:27.306]   - Field: ‘local’
[16:09:27.306]   - Field: ‘owner’
[16:09:27.306]   - Field: ‘envir’
[16:09:27.306]   - Field: ‘packages’
[16:09:27.306]   - Field: ‘gc’
[16:09:27.306]   - Field: ‘conditions’
[16:09:27.307]   - Field: ‘expr’
[16:09:27.307]   - Field: ‘uuid’
[16:09:27.307]   - Field: ‘seed’
[16:09:27.307]   - Field: ‘version’
[16:09:27.307]   - Field: ‘result’
[16:09:27.307]   - Field: ‘asynchronous’
[16:09:27.307]   - Field: ‘calls’
[16:09:27.307]   - Field: ‘globals’
[16:09:27.307]   - Field: ‘stdout’
[16:09:27.307]   - Field: ‘earlySignal’
[16:09:27.307]   - Field: ‘lazy’
[16:09:27.308]   - Field: ‘state’
[16:09:27.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.308] - Launch lazy future ...
[16:09:27.308] Packages needed by the future expression (n = 1): ‘stats’
[16:09:27.308] Packages needed by future strategies (n = 0): <none>
[16:09:27.309] {
[16:09:27.309]     {
[16:09:27.309]         {
[16:09:27.309]             ...future.startTime <- base::Sys.time()
[16:09:27.309]             {
[16:09:27.309]                 {
[16:09:27.309]                   {
[16:09:27.309]                     {
[16:09:27.309]                       base::local({
[16:09:27.309]                         has_future <- base::requireNamespace("future", 
[16:09:27.309]                           quietly = TRUE)
[16:09:27.309]                         if (has_future) {
[16:09:27.309]                           ns <- base::getNamespace("future")
[16:09:27.309]                           version <- ns[[".package"]][["version"]]
[16:09:27.309]                           if (is.null(version)) 
[16:09:27.309]                             version <- utils::packageVersion("future")
[16:09:27.309]                         }
[16:09:27.309]                         else {
[16:09:27.309]                           version <- NULL
[16:09:27.309]                         }
[16:09:27.309]                         if (!has_future || version < "1.8.0") {
[16:09:27.309]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.309]                             "", base::R.version$version.string), 
[16:09:27.309]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:27.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.309]                               "release", "version")], collapse = " "), 
[16:09:27.309]                             hostname = base::Sys.info()[["nodename"]])
[16:09:27.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.309]                             info)
[16:09:27.309]                           info <- base::paste(info, collapse = "; ")
[16:09:27.309]                           if (!has_future) {
[16:09:27.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.309]                               info)
[16:09:27.309]                           }
[16:09:27.309]                           else {
[16:09:27.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.309]                               info, version)
[16:09:27.309]                           }
[16:09:27.309]                           base::stop(msg)
[16:09:27.309]                         }
[16:09:27.309]                       })
[16:09:27.309]                     }
[16:09:27.309]                     base::local({
[16:09:27.309]                       for (pkg in "stats") {
[16:09:27.309]                         base::loadNamespace(pkg)
[16:09:27.309]                         base::library(pkg, character.only = TRUE)
[16:09:27.309]                       }
[16:09:27.309]                     })
[16:09:27.309]                   }
[16:09:27.309]                   options(future.plan = NULL)
[16:09:27.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.309]                 }
[16:09:27.309]                 ...future.workdir <- getwd()
[16:09:27.309]             }
[16:09:27.309]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.309]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.309]         }
[16:09:27.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.309]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.309]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.309]             base::names(...future.oldOptions))
[16:09:27.309]     }
[16:09:27.309]     if (FALSE) {
[16:09:27.309]     }
[16:09:27.309]     else {
[16:09:27.309]         if (TRUE) {
[16:09:27.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.309]                 open = "w")
[16:09:27.309]         }
[16:09:27.309]         else {
[16:09:27.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.309]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.309]         }
[16:09:27.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.309]             base::sink(type = "output", split = FALSE)
[16:09:27.309]             base::close(...future.stdout)
[16:09:27.309]         }, add = TRUE)
[16:09:27.309]     }
[16:09:27.309]     ...future.frame <- base::sys.nframe()
[16:09:27.309]     ...future.conditions <- base::list()
[16:09:27.309]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.309]     if (FALSE) {
[16:09:27.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.309]     }
[16:09:27.309]     ...future.result <- base::tryCatch({
[16:09:27.309]         base::withCallingHandlers({
[16:09:27.309]             ...future.value <- base::withVisible(base::local({
[16:09:27.309]                 do.call(function(...) {
[16:09:27.309]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.309]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.309]                     ...future.globals.maxSize)) {
[16:09:27.309]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.309]                     on.exit(options(oopts), add = TRUE)
[16:09:27.309]                   }
[16:09:27.309]                   {
[16:09:27.309]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.309]                       FUN = function(jj) {
[16:09:27.309]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.309]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.309]                       })
[16:09:27.309]                   }
[16:09:27.309]                 }, args = future.call.arguments)
[16:09:27.309]             }))
[16:09:27.309]             future::FutureResult(value = ...future.value$value, 
[16:09:27.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.309]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.309]                     ...future.globalenv.names))
[16:09:27.309]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.309]         }, condition = base::local({
[16:09:27.309]             c <- base::c
[16:09:27.309]             inherits <- base::inherits
[16:09:27.309]             invokeRestart <- base::invokeRestart
[16:09:27.309]             length <- base::length
[16:09:27.309]             list <- base::list
[16:09:27.309]             seq.int <- base::seq.int
[16:09:27.309]             signalCondition <- base::signalCondition
[16:09:27.309]             sys.calls <- base::sys.calls
[16:09:27.309]             `[[` <- base::`[[`
[16:09:27.309]             `+` <- base::`+`
[16:09:27.309]             `<<-` <- base::`<<-`
[16:09:27.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.309]                   3L)]
[16:09:27.309]             }
[16:09:27.309]             function(cond) {
[16:09:27.309]                 is_error <- inherits(cond, "error")
[16:09:27.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.309]                   NULL)
[16:09:27.309]                 if (is_error) {
[16:09:27.309]                   sessionInformation <- function() {
[16:09:27.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.309]                       search = base::search(), system = base::Sys.info())
[16:09:27.309]                   }
[16:09:27.309]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.309]                     cond$call), session = sessionInformation(), 
[16:09:27.309]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.309]                   signalCondition(cond)
[16:09:27.309]                 }
[16:09:27.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.309]                 "immediateCondition"))) {
[16:09:27.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.309]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.309]                   if (TRUE && !signal) {
[16:09:27.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.309]                     {
[16:09:27.309]                       inherits <- base::inherits
[16:09:27.309]                       invokeRestart <- base::invokeRestart
[16:09:27.309]                       is.null <- base::is.null
[16:09:27.309]                       muffled <- FALSE
[16:09:27.309]                       if (inherits(cond, "message")) {
[16:09:27.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.309]                         if (muffled) 
[16:09:27.309]                           invokeRestart("muffleMessage")
[16:09:27.309]                       }
[16:09:27.309]                       else if (inherits(cond, "warning")) {
[16:09:27.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.309]                         if (muffled) 
[16:09:27.309]                           invokeRestart("muffleWarning")
[16:09:27.309]                       }
[16:09:27.309]                       else if (inherits(cond, "condition")) {
[16:09:27.309]                         if (!is.null(pattern)) {
[16:09:27.309]                           computeRestarts <- base::computeRestarts
[16:09:27.309]                           grepl <- base::grepl
[16:09:27.309]                           restarts <- computeRestarts(cond)
[16:09:27.309]                           for (restart in restarts) {
[16:09:27.309]                             name <- restart$name
[16:09:27.309]                             if (is.null(name)) 
[16:09:27.309]                               next
[16:09:27.309]                             if (!grepl(pattern, name)) 
[16:09:27.309]                               next
[16:09:27.309]                             invokeRestart(restart)
[16:09:27.309]                             muffled <- TRUE
[16:09:27.309]                             break
[16:09:27.309]                           }
[16:09:27.309]                         }
[16:09:27.309]                       }
[16:09:27.309]                       invisible(muffled)
[16:09:27.309]                     }
[16:09:27.309]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.309]                   }
[16:09:27.309]                 }
[16:09:27.309]                 else {
[16:09:27.309]                   if (TRUE) {
[16:09:27.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.309]                     {
[16:09:27.309]                       inherits <- base::inherits
[16:09:27.309]                       invokeRestart <- base::invokeRestart
[16:09:27.309]                       is.null <- base::is.null
[16:09:27.309]                       muffled <- FALSE
[16:09:27.309]                       if (inherits(cond, "message")) {
[16:09:27.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.309]                         if (muffled) 
[16:09:27.309]                           invokeRestart("muffleMessage")
[16:09:27.309]                       }
[16:09:27.309]                       else if (inherits(cond, "warning")) {
[16:09:27.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.309]                         if (muffled) 
[16:09:27.309]                           invokeRestart("muffleWarning")
[16:09:27.309]                       }
[16:09:27.309]                       else if (inherits(cond, "condition")) {
[16:09:27.309]                         if (!is.null(pattern)) {
[16:09:27.309]                           computeRestarts <- base::computeRestarts
[16:09:27.309]                           grepl <- base::grepl
[16:09:27.309]                           restarts <- computeRestarts(cond)
[16:09:27.309]                           for (restart in restarts) {
[16:09:27.309]                             name <- restart$name
[16:09:27.309]                             if (is.null(name)) 
[16:09:27.309]                               next
[16:09:27.309]                             if (!grepl(pattern, name)) 
[16:09:27.309]                               next
[16:09:27.309]                             invokeRestart(restart)
[16:09:27.309]                             muffled <- TRUE
[16:09:27.309]                             break
[16:09:27.309]                           }
[16:09:27.309]                         }
[16:09:27.309]                       }
[16:09:27.309]                       invisible(muffled)
[16:09:27.309]                     }
[16:09:27.309]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.309]                   }
[16:09:27.309]                 }
[16:09:27.309]             }
[16:09:27.309]         }))
[16:09:27.309]     }, error = function(ex) {
[16:09:27.309]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.309]                 ...future.rng), started = ...future.startTime, 
[16:09:27.309]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.309]             version = "1.8"), class = "FutureResult")
[16:09:27.309]     }, finally = {
[16:09:27.309]         if (!identical(...future.workdir, getwd())) 
[16:09:27.309]             setwd(...future.workdir)
[16:09:27.309]         {
[16:09:27.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.309]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.309]             }
[16:09:27.309]             base::options(...future.oldOptions)
[16:09:27.309]             if (.Platform$OS.type == "windows") {
[16:09:27.309]                 old_names <- names(...future.oldEnvVars)
[16:09:27.309]                 envs <- base::Sys.getenv()
[16:09:27.309]                 names <- names(envs)
[16:09:27.309]                 common <- intersect(names, old_names)
[16:09:27.309]                 added <- setdiff(names, old_names)
[16:09:27.309]                 removed <- setdiff(old_names, names)
[16:09:27.309]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.309]                   envs[common]]
[16:09:27.309]                 NAMES <- toupper(changed)
[16:09:27.309]                 args <- list()
[16:09:27.309]                 for (kk in seq_along(NAMES)) {
[16:09:27.309]                   name <- changed[[kk]]
[16:09:27.309]                   NAME <- NAMES[[kk]]
[16:09:27.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.309]                     next
[16:09:27.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.309]                 }
[16:09:27.309]                 NAMES <- toupper(added)
[16:09:27.309]                 for (kk in seq_along(NAMES)) {
[16:09:27.309]                   name <- added[[kk]]
[16:09:27.309]                   NAME <- NAMES[[kk]]
[16:09:27.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.309]                     next
[16:09:27.309]                   args[[name]] <- ""
[16:09:27.309]                 }
[16:09:27.309]                 NAMES <- toupper(removed)
[16:09:27.309]                 for (kk in seq_along(NAMES)) {
[16:09:27.309]                   name <- removed[[kk]]
[16:09:27.309]                   NAME <- NAMES[[kk]]
[16:09:27.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.309]                     next
[16:09:27.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.309]                 }
[16:09:27.309]                 if (length(args) > 0) 
[16:09:27.309]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.309]             }
[16:09:27.309]             else {
[16:09:27.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.309]             }
[16:09:27.309]             {
[16:09:27.309]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.309]                   0L) {
[16:09:27.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.309]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.309]                   base::options(opts)
[16:09:27.309]                 }
[16:09:27.309]                 {
[16:09:27.309]                   {
[16:09:27.309]                     NULL
[16:09:27.309]                     RNGkind("Mersenne-Twister")
[16:09:27.309]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.309]                       inherits = FALSE)
[16:09:27.309]                   }
[16:09:27.309]                   options(future.plan = NULL)
[16:09:27.309]                   if (is.na(NA_character_)) 
[16:09:27.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.309]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.309]                   {
[16:09:27.309]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.309]                     if (!future$lazy) 
[16:09:27.309]                       future <- run(future)
[16:09:27.309]                     invisible(future)
[16:09:27.309]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.309]                 }
[16:09:27.309]             }
[16:09:27.309]         }
[16:09:27.309]     })
[16:09:27.309]     if (TRUE) {
[16:09:27.309]         base::sink(type = "output", split = FALSE)
[16:09:27.309]         if (TRUE) {
[16:09:27.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.309]         }
[16:09:27.309]         else {
[16:09:27.309]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.309]         }
[16:09:27.309]         base::close(...future.stdout)
[16:09:27.309]         ...future.stdout <- NULL
[16:09:27.309]     }
[16:09:27.309]     ...future.result$conditions <- ...future.conditions
[16:09:27.309]     ...future.result$finished <- base::Sys.time()
[16:09:27.309]     ...future.result
[16:09:27.309] }
[16:09:27.310] assign_globals() ...
[16:09:27.310] List of 5
[16:09:27.310]  $ future.call.arguments    : list()
[16:09:27.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.310]  $ ...future.FUN            :function (x, ...)  
[16:09:27.310]  $ ...future.elements_ii    :List of 2
[16:09:27.310]   ..$ : num [1:4] 1 3 1 7
[16:09:27.310]   ..$ : num [1:4] 2 4 6 8
[16:09:27.310]  $ ...future.seeds_ii       : NULL
[16:09:27.310]  $ ...future.globals.maxSize: num Inf
[16:09:27.310]  - attr(*, "resolved")= logi FALSE
[16:09:27.310]  - attr(*, "total_size")= num NA
[16:09:27.310]  - attr(*, "where")=List of 5
[16:09:27.310]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.310]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.310]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.310]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.310]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.310]  - attr(*, "already-done")= logi TRUE
[16:09:27.316] - copied ‘future.call.arguments’ to environment
[16:09:27.317] - copied ‘...future.FUN’ to environment
[16:09:27.317] - copied ‘...future.elements_ii’ to environment
[16:09:27.317] - copied ‘...future.seeds_ii’ to environment
[16:09:27.317] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.317] assign_globals() ... done
[16:09:27.317] plan(): Setting new future strategy stack:
[16:09:27.317] List of future strategies:
[16:09:27.317] 1. sequential:
[16:09:27.317]    - args: function (..., envir = parent.frame())
[16:09:27.317]    - tweaked: FALSE
[16:09:27.317]    - call: NULL
[16:09:27.318] plan(): nbrOfWorkers() = 1
[16:09:27.319] plan(): Setting new future strategy stack:
[16:09:27.319] List of future strategies:
[16:09:27.319] 1. sequential:
[16:09:27.319]    - args: function (..., envir = parent.frame())
[16:09:27.319]    - tweaked: FALSE
[16:09:27.319]    - call: plan(strategy)
[16:09:27.319] plan(): nbrOfWorkers() = 1
[16:09:27.319] SequentialFuture started (and completed)
[16:09:27.320] - Launch lazy future ... done
[16:09:27.320] run() for ‘SequentialFuture’ ... done
[16:09:27.320] Created future:
[16:09:27.320] SequentialFuture:
[16:09:27.320] Label: ‘future_apply-1’
[16:09:27.320] Expression:
[16:09:27.320] {
[16:09:27.320]     do.call(function(...) {
[16:09:27.320]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.320]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.320]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.320]             on.exit(options(oopts), add = TRUE)
[16:09:27.320]         }
[16:09:27.320]         {
[16:09:27.320]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.320]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.320]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.320]             })
[16:09:27.320]         }
[16:09:27.320]     }, args = future.call.arguments)
[16:09:27.320] }
[16:09:27.320] Lazy evaluation: FALSE
[16:09:27.320] Asynchronous evaluation: FALSE
[16:09:27.320] Local evaluation: TRUE
[16:09:27.320] Environment: R_GlobalEnv
[16:09:27.320] Capture standard output: TRUE
[16:09:27.320] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.320] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.320] Packages: 1 packages (‘stats’)
[16:09:27.320] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.320] Resolved: TRUE
[16:09:27.320] Value: 1.14 KiB of class ‘list’
[16:09:27.320] Early signaling: FALSE
[16:09:27.320] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.320] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.321] Chunk #1 of 1 ... DONE
[16:09:27.321] Launching 1 futures (chunks) ... DONE
[16:09:27.321] Resolving 1 futures (chunks) ...
[16:09:27.321] resolve() on list ...
[16:09:27.321]  recursive: 0
[16:09:27.321]  length: 1
[16:09:27.321] 
[16:09:27.322] resolved() for ‘SequentialFuture’ ...
[16:09:27.322] - state: ‘finished’
[16:09:27.322] - run: TRUE
[16:09:27.322] - result: ‘FutureResult’
[16:09:27.322] resolved() for ‘SequentialFuture’ ... done
[16:09:27.322] Future #1
[16:09:27.322] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.322] - nx: 1
[16:09:27.322] - relay: TRUE
[16:09:27.322] - stdout: TRUE
[16:09:27.322] - signal: TRUE
[16:09:27.323] - resignal: FALSE
[16:09:27.323] - force: TRUE
[16:09:27.323] - relayed: [n=1] FALSE
[16:09:27.323] - queued futures: [n=1] FALSE
[16:09:27.323]  - until=1
[16:09:27.323]  - relaying element #1
[16:09:27.323] - relayed: [n=1] TRUE
[16:09:27.323] - queued futures: [n=1] TRUE
[16:09:27.323] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.323]  length: 0 (resolved future 1)
[16:09:27.324] Relaying remaining futures
[16:09:27.324] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.324] - nx: 1
[16:09:27.324] - relay: TRUE
[16:09:27.324] - stdout: TRUE
[16:09:27.324] - signal: TRUE
[16:09:27.324] - resignal: FALSE
[16:09:27.324] - force: TRUE
[16:09:27.324] - relayed: [n=1] TRUE
[16:09:27.324] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.324] - relayed: [n=1] TRUE
[16:09:27.324] - queued futures: [n=1] TRUE
[16:09:27.325] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.325] resolve() on list ... DONE
[16:09:27.325]  - Number of value chunks collected: 1
[16:09:27.325] Resolving 1 futures (chunks) ... DONE
[16:09:27.325] Reducing values from 1 chunks ...
[16:09:27.325]  - Number of values collected after concatenation: 2
[16:09:27.325]  - Number of values expected: 2
[16:09:27.325] Reducing values from 1 chunks ... DONE
[16:09:27.325] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:09:27.326] getGlobalsAndPackagesXApply() ...
[16:09:27.326]  - future.globals: TRUE
[16:09:27.326] getGlobalsAndPackages() ...
[16:09:27.326] Searching for globals...
[16:09:27.327] - globals found: [1] ‘FUN’
[16:09:27.327] Searching for globals ... DONE
[16:09:27.328] Resolving globals: FALSE
[16:09:27.328] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:27.328] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:27.328] - globals: [1] ‘FUN’
[16:09:27.328] 
[16:09:27.328] getGlobalsAndPackages() ... DONE
[16:09:27.329]  - globals found/used: [n=1] ‘FUN’
[16:09:27.329]  - needed namespaces: [n=0] 
[16:09:27.329] Finding globals ... DONE
[16:09:27.329]  - use_args: TRUE
[16:09:27.329]  - Getting '...' globals ...
[16:09:27.329] resolve() on list ...
[16:09:27.329]  recursive: 0
[16:09:27.329]  length: 1
[16:09:27.330]  elements: ‘...’
[16:09:27.330]  length: 0 (resolved future 1)
[16:09:27.330] resolve() on list ... DONE
[16:09:27.330]    - '...' content: [n=0] 
[16:09:27.330] List of 1
[16:09:27.330]  $ ...: list()
[16:09:27.330]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.330]  - attr(*, "where")=List of 1
[16:09:27.330]   ..$ ...:<environment: 0x5633abe5dd10> 
[16:09:27.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.330]  - attr(*, "resolved")= logi TRUE
[16:09:27.330]  - attr(*, "total_size")= num NA
[16:09:27.333]  - Getting '...' globals ... DONE
[16:09:27.333] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.333] List of 2
[16:09:27.333]  $ ...future.FUN:function (x)  
[16:09:27.333]  $ ...          : list()
[16:09:27.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.333]  - attr(*, "where")=List of 2
[16:09:27.333]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.333]   ..$ ...          :<environment: 0x5633abe5dd10> 
[16:09:27.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.333]  - attr(*, "resolved")= logi FALSE
[16:09:27.333]  - attr(*, "total_size")= num 848
[16:09:27.336] Packages to be attached in all futures: [n=0] 
[16:09:27.336] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.336] future_lapply() ...
[16:09:27.336] Number of chunks: 1
[16:09:27.337] getGlobalsAndPackagesXApply() ...
[16:09:27.337]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.337]  - use_args: TRUE
[16:09:27.337] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.337] List of 2
[16:09:27.337]  $ ...          : list()
[16:09:27.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.337]  $ ...future.FUN:function (x)  
[16:09:27.337]  - attr(*, "where")=List of 2
[16:09:27.337]   ..$ ...          :<environment: 0x5633abe5dd10> 
[16:09:27.337]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.337]  - attr(*, "resolved")= logi FALSE
[16:09:27.337]  - attr(*, "total_size")= num NA
[16:09:27.342] Packages to be attached in all futures: [n=0] 
[16:09:27.342] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.342] Number of futures (= number of chunks): 1
[16:09:27.343] Launching 1 futures (chunks) ...
[16:09:27.343] Chunk #1 of 1 ...
[16:09:27.343]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.343]  - seeds: <none>
[16:09:27.343] getGlobalsAndPackages() ...
[16:09:27.343] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.343] Resolving globals: FALSE
[16:09:27.343] Tweak future expression to call with '...' arguments ...
[16:09:27.344] {
[16:09:27.344]     do.call(function(...) {
[16:09:27.344]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.344]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.344]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.344]             on.exit(options(oopts), add = TRUE)
[16:09:27.344]         }
[16:09:27.344]         {
[16:09:27.344]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.344]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.344]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.344]             })
[16:09:27.344]         }
[16:09:27.344]     }, args = future.call.arguments)
[16:09:27.344] }
[16:09:27.344] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.344] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.344] 
[16:09:27.344] getGlobalsAndPackages() ... DONE
[16:09:27.345] run() for ‘Future’ ...
[16:09:27.345] - state: ‘created’
[16:09:27.345] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.345] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.345] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.345]   - Field: ‘label’
[16:09:27.346]   - Field: ‘local’
[16:09:27.346]   - Field: ‘owner’
[16:09:27.346]   - Field: ‘envir’
[16:09:27.346]   - Field: ‘packages’
[16:09:27.346]   - Field: ‘gc’
[16:09:27.346]   - Field: ‘conditions’
[16:09:27.346]   - Field: ‘expr’
[16:09:27.346]   - Field: ‘uuid’
[16:09:27.346]   - Field: ‘seed’
[16:09:27.346]   - Field: ‘version’
[16:09:27.347]   - Field: ‘result’
[16:09:27.347]   - Field: ‘asynchronous’
[16:09:27.347]   - Field: ‘calls’
[16:09:27.347]   - Field: ‘globals’
[16:09:27.347]   - Field: ‘stdout’
[16:09:27.347]   - Field: ‘earlySignal’
[16:09:27.347]   - Field: ‘lazy’
[16:09:27.347]   - Field: ‘state’
[16:09:27.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.347] - Launch lazy future ...
[16:09:27.348] Packages needed by the future expression (n = 0): <none>
[16:09:27.348] Packages needed by future strategies (n = 0): <none>
[16:09:27.348] {
[16:09:27.348]     {
[16:09:27.348]         {
[16:09:27.348]             ...future.startTime <- base::Sys.time()
[16:09:27.348]             {
[16:09:27.348]                 {
[16:09:27.348]                   {
[16:09:27.348]                     base::local({
[16:09:27.348]                       has_future <- base::requireNamespace("future", 
[16:09:27.348]                         quietly = TRUE)
[16:09:27.348]                       if (has_future) {
[16:09:27.348]                         ns <- base::getNamespace("future")
[16:09:27.348]                         version <- ns[[".package"]][["version"]]
[16:09:27.348]                         if (is.null(version)) 
[16:09:27.348]                           version <- utils::packageVersion("future")
[16:09:27.348]                       }
[16:09:27.348]                       else {
[16:09:27.348]                         version <- NULL
[16:09:27.348]                       }
[16:09:27.348]                       if (!has_future || version < "1.8.0") {
[16:09:27.348]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.348]                           "", base::R.version$version.string), 
[16:09:27.348]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.348]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.348]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.348]                             "release", "version")], collapse = " "), 
[16:09:27.348]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.348]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.348]                           info)
[16:09:27.348]                         info <- base::paste(info, collapse = "; ")
[16:09:27.348]                         if (!has_future) {
[16:09:27.348]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.348]                             info)
[16:09:27.348]                         }
[16:09:27.348]                         else {
[16:09:27.348]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.348]                             info, version)
[16:09:27.348]                         }
[16:09:27.348]                         base::stop(msg)
[16:09:27.348]                       }
[16:09:27.348]                     })
[16:09:27.348]                   }
[16:09:27.348]                   options(future.plan = NULL)
[16:09:27.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.348]                 }
[16:09:27.348]                 ...future.workdir <- getwd()
[16:09:27.348]             }
[16:09:27.348]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.348]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.348]         }
[16:09:27.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.348]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.348]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.348]             base::names(...future.oldOptions))
[16:09:27.348]     }
[16:09:27.348]     if (FALSE) {
[16:09:27.348]     }
[16:09:27.348]     else {
[16:09:27.348]         if (TRUE) {
[16:09:27.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.348]                 open = "w")
[16:09:27.348]         }
[16:09:27.348]         else {
[16:09:27.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.348]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.348]         }
[16:09:27.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.348]             base::sink(type = "output", split = FALSE)
[16:09:27.348]             base::close(...future.stdout)
[16:09:27.348]         }, add = TRUE)
[16:09:27.348]     }
[16:09:27.348]     ...future.frame <- base::sys.nframe()
[16:09:27.348]     ...future.conditions <- base::list()
[16:09:27.348]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.348]     if (FALSE) {
[16:09:27.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.348]     }
[16:09:27.348]     ...future.result <- base::tryCatch({
[16:09:27.348]         base::withCallingHandlers({
[16:09:27.348]             ...future.value <- base::withVisible(base::local({
[16:09:27.348]                 do.call(function(...) {
[16:09:27.348]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.348]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.348]                     ...future.globals.maxSize)) {
[16:09:27.348]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.348]                     on.exit(options(oopts), add = TRUE)
[16:09:27.348]                   }
[16:09:27.348]                   {
[16:09:27.348]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.348]                       FUN = function(jj) {
[16:09:27.348]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.348]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.348]                       })
[16:09:27.348]                   }
[16:09:27.348]                 }, args = future.call.arguments)
[16:09:27.348]             }))
[16:09:27.348]             future::FutureResult(value = ...future.value$value, 
[16:09:27.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.348]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.348]                     ...future.globalenv.names))
[16:09:27.348]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.348]         }, condition = base::local({
[16:09:27.348]             c <- base::c
[16:09:27.348]             inherits <- base::inherits
[16:09:27.348]             invokeRestart <- base::invokeRestart
[16:09:27.348]             length <- base::length
[16:09:27.348]             list <- base::list
[16:09:27.348]             seq.int <- base::seq.int
[16:09:27.348]             signalCondition <- base::signalCondition
[16:09:27.348]             sys.calls <- base::sys.calls
[16:09:27.348]             `[[` <- base::`[[`
[16:09:27.348]             `+` <- base::`+`
[16:09:27.348]             `<<-` <- base::`<<-`
[16:09:27.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.348]                   3L)]
[16:09:27.348]             }
[16:09:27.348]             function(cond) {
[16:09:27.348]                 is_error <- inherits(cond, "error")
[16:09:27.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.348]                   NULL)
[16:09:27.348]                 if (is_error) {
[16:09:27.348]                   sessionInformation <- function() {
[16:09:27.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.348]                       search = base::search(), system = base::Sys.info())
[16:09:27.348]                   }
[16:09:27.348]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.348]                     cond$call), session = sessionInformation(), 
[16:09:27.348]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.348]                   signalCondition(cond)
[16:09:27.348]                 }
[16:09:27.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.348]                 "immediateCondition"))) {
[16:09:27.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.348]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.348]                   if (TRUE && !signal) {
[16:09:27.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.348]                     {
[16:09:27.348]                       inherits <- base::inherits
[16:09:27.348]                       invokeRestart <- base::invokeRestart
[16:09:27.348]                       is.null <- base::is.null
[16:09:27.348]                       muffled <- FALSE
[16:09:27.348]                       if (inherits(cond, "message")) {
[16:09:27.348]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.348]                         if (muffled) 
[16:09:27.348]                           invokeRestart("muffleMessage")
[16:09:27.348]                       }
[16:09:27.348]                       else if (inherits(cond, "warning")) {
[16:09:27.348]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.348]                         if (muffled) 
[16:09:27.348]                           invokeRestart("muffleWarning")
[16:09:27.348]                       }
[16:09:27.348]                       else if (inherits(cond, "condition")) {
[16:09:27.348]                         if (!is.null(pattern)) {
[16:09:27.348]                           computeRestarts <- base::computeRestarts
[16:09:27.348]                           grepl <- base::grepl
[16:09:27.348]                           restarts <- computeRestarts(cond)
[16:09:27.348]                           for (restart in restarts) {
[16:09:27.348]                             name <- restart$name
[16:09:27.348]                             if (is.null(name)) 
[16:09:27.348]                               next
[16:09:27.348]                             if (!grepl(pattern, name)) 
[16:09:27.348]                               next
[16:09:27.348]                             invokeRestart(restart)
[16:09:27.348]                             muffled <- TRUE
[16:09:27.348]                             break
[16:09:27.348]                           }
[16:09:27.348]                         }
[16:09:27.348]                       }
[16:09:27.348]                       invisible(muffled)
[16:09:27.348]                     }
[16:09:27.348]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.348]                   }
[16:09:27.348]                 }
[16:09:27.348]                 else {
[16:09:27.348]                   if (TRUE) {
[16:09:27.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.348]                     {
[16:09:27.348]                       inherits <- base::inherits
[16:09:27.348]                       invokeRestart <- base::invokeRestart
[16:09:27.348]                       is.null <- base::is.null
[16:09:27.348]                       muffled <- FALSE
[16:09:27.348]                       if (inherits(cond, "message")) {
[16:09:27.348]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.348]                         if (muffled) 
[16:09:27.348]                           invokeRestart("muffleMessage")
[16:09:27.348]                       }
[16:09:27.348]                       else if (inherits(cond, "warning")) {
[16:09:27.348]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.348]                         if (muffled) 
[16:09:27.348]                           invokeRestart("muffleWarning")
[16:09:27.348]                       }
[16:09:27.348]                       else if (inherits(cond, "condition")) {
[16:09:27.348]                         if (!is.null(pattern)) {
[16:09:27.348]                           computeRestarts <- base::computeRestarts
[16:09:27.348]                           grepl <- base::grepl
[16:09:27.348]                           restarts <- computeRestarts(cond)
[16:09:27.348]                           for (restart in restarts) {
[16:09:27.348]                             name <- restart$name
[16:09:27.348]                             if (is.null(name)) 
[16:09:27.348]                               next
[16:09:27.348]                             if (!grepl(pattern, name)) 
[16:09:27.348]                               next
[16:09:27.348]                             invokeRestart(restart)
[16:09:27.348]                             muffled <- TRUE
[16:09:27.348]                             break
[16:09:27.348]                           }
[16:09:27.348]                         }
[16:09:27.348]                       }
[16:09:27.348]                       invisible(muffled)
[16:09:27.348]                     }
[16:09:27.348]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.348]                   }
[16:09:27.348]                 }
[16:09:27.348]             }
[16:09:27.348]         }))
[16:09:27.348]     }, error = function(ex) {
[16:09:27.348]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.348]                 ...future.rng), started = ...future.startTime, 
[16:09:27.348]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.348]             version = "1.8"), class = "FutureResult")
[16:09:27.348]     }, finally = {
[16:09:27.348]         if (!identical(...future.workdir, getwd())) 
[16:09:27.348]             setwd(...future.workdir)
[16:09:27.348]         {
[16:09:27.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.348]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.348]             }
[16:09:27.348]             base::options(...future.oldOptions)
[16:09:27.348]             if (.Platform$OS.type == "windows") {
[16:09:27.348]                 old_names <- names(...future.oldEnvVars)
[16:09:27.348]                 envs <- base::Sys.getenv()
[16:09:27.348]                 names <- names(envs)
[16:09:27.348]                 common <- intersect(names, old_names)
[16:09:27.348]                 added <- setdiff(names, old_names)
[16:09:27.348]                 removed <- setdiff(old_names, names)
[16:09:27.348]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.348]                   envs[common]]
[16:09:27.348]                 NAMES <- toupper(changed)
[16:09:27.348]                 args <- list()
[16:09:27.348]                 for (kk in seq_along(NAMES)) {
[16:09:27.348]                   name <- changed[[kk]]
[16:09:27.348]                   NAME <- NAMES[[kk]]
[16:09:27.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.348]                     next
[16:09:27.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.348]                 }
[16:09:27.348]                 NAMES <- toupper(added)
[16:09:27.348]                 for (kk in seq_along(NAMES)) {
[16:09:27.348]                   name <- added[[kk]]
[16:09:27.348]                   NAME <- NAMES[[kk]]
[16:09:27.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.348]                     next
[16:09:27.348]                   args[[name]] <- ""
[16:09:27.348]                 }
[16:09:27.348]                 NAMES <- toupper(removed)
[16:09:27.348]                 for (kk in seq_along(NAMES)) {
[16:09:27.348]                   name <- removed[[kk]]
[16:09:27.348]                   NAME <- NAMES[[kk]]
[16:09:27.348]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.348]                     next
[16:09:27.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.348]                 }
[16:09:27.348]                 if (length(args) > 0) 
[16:09:27.348]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.348]             }
[16:09:27.348]             else {
[16:09:27.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.348]             }
[16:09:27.348]             {
[16:09:27.348]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.348]                   0L) {
[16:09:27.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.348]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.348]                   base::options(opts)
[16:09:27.348]                 }
[16:09:27.348]                 {
[16:09:27.348]                   {
[16:09:27.348]                     NULL
[16:09:27.348]                     RNGkind("Mersenne-Twister")
[16:09:27.348]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.348]                       inherits = FALSE)
[16:09:27.348]                   }
[16:09:27.348]                   options(future.plan = NULL)
[16:09:27.348]                   if (is.na(NA_character_)) 
[16:09:27.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.348]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.348]                   {
[16:09:27.348]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.348]                     if (!future$lazy) 
[16:09:27.348]                       future <- run(future)
[16:09:27.348]                     invisible(future)
[16:09:27.348]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.348]                 }
[16:09:27.348]             }
[16:09:27.348]         }
[16:09:27.348]     })
[16:09:27.348]     if (TRUE) {
[16:09:27.348]         base::sink(type = "output", split = FALSE)
[16:09:27.348]         if (TRUE) {
[16:09:27.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.348]         }
[16:09:27.348]         else {
[16:09:27.348]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.348]         }
[16:09:27.348]         base::close(...future.stdout)
[16:09:27.348]         ...future.stdout <- NULL
[16:09:27.348]     }
[16:09:27.348]     ...future.result$conditions <- ...future.conditions
[16:09:27.348]     ...future.result$finished <- base::Sys.time()
[16:09:27.348]     ...future.result
[16:09:27.348] }
[16:09:27.350] assign_globals() ...
[16:09:27.350] List of 5
[16:09:27.350]  $ future.call.arguments    : list()
[16:09:27.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.350]  $ ...future.FUN            :function (x)  
[16:09:27.350]  $ ...future.elements_ii    :List of 2
[16:09:27.350]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:27.350]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:27.350]  $ ...future.seeds_ii       : NULL
[16:09:27.350]  $ ...future.globals.maxSize: num Inf
[16:09:27.350]  - attr(*, "resolved")= logi FALSE
[16:09:27.350]  - attr(*, "total_size")= num NA
[16:09:27.350]  - attr(*, "where")=List of 5
[16:09:27.350]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.350]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.350]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.350]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.350]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.350]  - attr(*, "already-done")= logi TRUE
[16:09:27.355] - copied ‘future.call.arguments’ to environment
[16:09:27.355] - copied ‘...future.FUN’ to environment
[16:09:27.355] - copied ‘...future.elements_ii’ to environment
[16:09:27.355] - copied ‘...future.seeds_ii’ to environment
[16:09:27.355] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.356] assign_globals() ... done
[16:09:27.356] plan(): Setting new future strategy stack:
[16:09:27.356] List of future strategies:
[16:09:27.356] 1. sequential:
[16:09:27.356]    - args: function (..., envir = parent.frame())
[16:09:27.356]    - tweaked: FALSE
[16:09:27.356]    - call: NULL
[16:09:27.356] plan(): nbrOfWorkers() = 1
[16:09:27.357] plan(): Setting new future strategy stack:
[16:09:27.357] List of future strategies:
[16:09:27.357] 1. sequential:
[16:09:27.357]    - args: function (..., envir = parent.frame())
[16:09:27.357]    - tweaked: FALSE
[16:09:27.357]    - call: plan(strategy)
[16:09:27.358] plan(): nbrOfWorkers() = 1
[16:09:27.358] SequentialFuture started (and completed)
[16:09:27.358] - Launch lazy future ... done
[16:09:27.358] run() for ‘SequentialFuture’ ... done
[16:09:27.358] Created future:
[16:09:27.358] SequentialFuture:
[16:09:27.358] Label: ‘future_apply-1’
[16:09:27.358] Expression:
[16:09:27.358] {
[16:09:27.358]     do.call(function(...) {
[16:09:27.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.358]             on.exit(options(oopts), add = TRUE)
[16:09:27.358]         }
[16:09:27.358]         {
[16:09:27.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.358]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.358]             })
[16:09:27.358]         }
[16:09:27.358]     }, args = future.call.arguments)
[16:09:27.358] }
[16:09:27.358] Lazy evaluation: FALSE
[16:09:27.358] Asynchronous evaluation: FALSE
[16:09:27.358] Local evaluation: TRUE
[16:09:27.358] Environment: R_GlobalEnv
[16:09:27.358] Capture standard output: TRUE
[16:09:27.358] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.358] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.358] Packages: <none>
[16:09:27.358] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.358] Resolved: TRUE
[16:09:27.358] Value: 224 bytes of class ‘list’
[16:09:27.358] Early signaling: FALSE
[16:09:27.358] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.358] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.359] Chunk #1 of 1 ... DONE
[16:09:27.359] Launching 1 futures (chunks) ... DONE
[16:09:27.360] Resolving 1 futures (chunks) ...
[16:09:27.360] resolve() on list ...
[16:09:27.360]  recursive: 0
[16:09:27.360]  length: 1
[16:09:27.360] 
[16:09:27.360] resolved() for ‘SequentialFuture’ ...
[16:09:27.360] - state: ‘finished’
[16:09:27.360] - run: TRUE
[16:09:27.360] - result: ‘FutureResult’
[16:09:27.360] resolved() for ‘SequentialFuture’ ... done
[16:09:27.361] Future #1
[16:09:27.361] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.361] - nx: 1
[16:09:27.361] - relay: TRUE
[16:09:27.361] - stdout: TRUE
[16:09:27.361] - signal: TRUE
[16:09:27.361] - resignal: FALSE
[16:09:27.361] - force: TRUE
[16:09:27.361] - relayed: [n=1] FALSE
[16:09:27.361] - queued futures: [n=1] FALSE
[16:09:27.361]  - until=1
[16:09:27.362]  - relaying element #1
[16:09:27.362] - relayed: [n=1] TRUE
[16:09:27.362] - queued futures: [n=1] TRUE
[16:09:27.362] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.362]  length: 0 (resolved future 1)
[16:09:27.364] Relaying remaining futures
[16:09:27.364] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.364] - nx: 1
[16:09:27.364] - relay: TRUE
[16:09:27.364] - stdout: TRUE
[16:09:27.364] - signal: TRUE
[16:09:27.364] - resignal: FALSE
[16:09:27.364] - force: TRUE
[16:09:27.365] - relayed: [n=1] TRUE
[16:09:27.365] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.365] - relayed: [n=1] TRUE
[16:09:27.365] - queued futures: [n=1] TRUE
[16:09:27.365] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.365] resolve() on list ... DONE
[16:09:27.365]  - Number of value chunks collected: 1
[16:09:27.365] Resolving 1 futures (chunks) ... DONE
[16:09:27.365] Reducing values from 1 chunks ...
[16:09:27.365]  - Number of values collected after concatenation: 2
[16:09:27.366]  - Number of values expected: 2
[16:09:27.366] Reducing values from 1 chunks ... DONE
[16:09:27.366] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:09:27.366] getGlobalsAndPackagesXApply() ...
[16:09:27.366]  - future.globals: TRUE
[16:09:27.366] getGlobalsAndPackages() ...
[16:09:27.366] Searching for globals...
[16:09:27.367] - globals found: [1] ‘FUN’
[16:09:27.368] Searching for globals ... DONE
[16:09:27.368] Resolving globals: FALSE
[16:09:27.368] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:27.368] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:27.368] - globals: [1] ‘FUN’
[16:09:27.369] 
[16:09:27.369] getGlobalsAndPackages() ... DONE
[16:09:27.369]  - globals found/used: [n=1] ‘FUN’
[16:09:27.369]  - needed namespaces: [n=0] 
[16:09:27.369] Finding globals ... DONE
[16:09:27.369]  - use_args: TRUE
[16:09:27.369]  - Getting '...' globals ...
[16:09:27.369] resolve() on list ...
[16:09:27.370]  recursive: 0
[16:09:27.370]  length: 1
[16:09:27.370]  elements: ‘...’
[16:09:27.370]  length: 0 (resolved future 1)
[16:09:27.370] resolve() on list ... DONE
[16:09:27.370]    - '...' content: [n=0] 
[16:09:27.370] List of 1
[16:09:27.370]  $ ...: list()
[16:09:27.370]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.370]  - attr(*, "where")=List of 1
[16:09:27.370]   ..$ ...:<environment: 0x5633aaf98b58> 
[16:09:27.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.370]  - attr(*, "resolved")= logi TRUE
[16:09:27.370]  - attr(*, "total_size")= num NA
[16:09:27.373]  - Getting '...' globals ... DONE
[16:09:27.373] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.373] List of 2
[16:09:27.373]  $ ...future.FUN:function (x)  
[16:09:27.373]  $ ...          : list()
[16:09:27.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.373]  - attr(*, "where")=List of 2
[16:09:27.373]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.373]   ..$ ...          :<environment: 0x5633aaf98b58> 
[16:09:27.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.373]  - attr(*, "resolved")= logi FALSE
[16:09:27.373]  - attr(*, "total_size")= num 848
[16:09:27.376] Packages to be attached in all futures: [n=0] 
[16:09:27.376] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.376] future_lapply() ...
[16:09:27.376] Number of chunks: 1
[16:09:27.377] getGlobalsAndPackagesXApply() ...
[16:09:27.377]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.377]  - use_args: TRUE
[16:09:27.377] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.377] List of 2
[16:09:27.377]  $ ...          : list()
[16:09:27.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.377]  $ ...future.FUN:function (x)  
[16:09:27.377]  - attr(*, "where")=List of 2
[16:09:27.377]   ..$ ...          :<environment: 0x5633aaf98b58> 
[16:09:27.377]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.377]  - attr(*, "resolved")= logi FALSE
[16:09:27.377]  - attr(*, "total_size")= num NA
[16:09:27.380] Packages to be attached in all futures: [n=0] 
[16:09:27.381] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.381] Number of futures (= number of chunks): 1
[16:09:27.381] Launching 1 futures (chunks) ...
[16:09:27.381] Chunk #1 of 1 ...
[16:09:27.381]  - Adjusted option 'future.globals.maxSize': Inf -> 6 * Inf = Inf (bytes)
[16:09:27.381]  - seeds: <none>
[16:09:27.381] getGlobalsAndPackages() ...
[16:09:27.381] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.381] Resolving globals: FALSE
[16:09:27.382] Tweak future expression to call with '...' arguments ...
[16:09:27.382] {
[16:09:27.382]     do.call(function(...) {
[16:09:27.382]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.382]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.382]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.382]             on.exit(options(oopts), add = TRUE)
[16:09:27.382]         }
[16:09:27.382]         {
[16:09:27.382]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.382]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.382]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.382]             })
[16:09:27.382]         }
[16:09:27.382]     }, args = future.call.arguments)
[16:09:27.382] }
[16:09:27.382] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.382] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.382] 
[16:09:27.383] getGlobalsAndPackages() ... DONE
[16:09:27.383] run() for ‘Future’ ...
[16:09:27.383] - state: ‘created’
[16:09:27.383] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.383] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.384]   - Field: ‘label’
[16:09:27.384]   - Field: ‘local’
[16:09:27.384]   - Field: ‘owner’
[16:09:27.384]   - Field: ‘envir’
[16:09:27.384]   - Field: ‘packages’
[16:09:27.384]   - Field: ‘gc’
[16:09:27.384]   - Field: ‘conditions’
[16:09:27.384]   - Field: ‘expr’
[16:09:27.384]   - Field: ‘uuid’
[16:09:27.384]   - Field: ‘seed’
[16:09:27.385]   - Field: ‘version’
[16:09:27.385]   - Field: ‘result’
[16:09:27.385]   - Field: ‘asynchronous’
[16:09:27.385]   - Field: ‘calls’
[16:09:27.385]   - Field: ‘globals’
[16:09:27.385]   - Field: ‘stdout’
[16:09:27.386]   - Field: ‘earlySignal’
[16:09:27.386]   - Field: ‘lazy’
[16:09:27.387]   - Field: ‘state’
[16:09:27.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.387] - Launch lazy future ...
[16:09:27.387] Packages needed by the future expression (n = 0): <none>
[16:09:27.387] Packages needed by future strategies (n = 0): <none>
[16:09:27.387] {
[16:09:27.387]     {
[16:09:27.387]         {
[16:09:27.387]             ...future.startTime <- base::Sys.time()
[16:09:27.387]             {
[16:09:27.387]                 {
[16:09:27.387]                   {
[16:09:27.387]                     base::local({
[16:09:27.387]                       has_future <- base::requireNamespace("future", 
[16:09:27.387]                         quietly = TRUE)
[16:09:27.387]                       if (has_future) {
[16:09:27.387]                         ns <- base::getNamespace("future")
[16:09:27.387]                         version <- ns[[".package"]][["version"]]
[16:09:27.387]                         if (is.null(version)) 
[16:09:27.387]                           version <- utils::packageVersion("future")
[16:09:27.387]                       }
[16:09:27.387]                       else {
[16:09:27.387]                         version <- NULL
[16:09:27.387]                       }
[16:09:27.387]                       if (!has_future || version < "1.8.0") {
[16:09:27.387]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.387]                           "", base::R.version$version.string), 
[16:09:27.387]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.387]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.387]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.387]                             "release", "version")], collapse = " "), 
[16:09:27.387]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.387]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.387]                           info)
[16:09:27.387]                         info <- base::paste(info, collapse = "; ")
[16:09:27.387]                         if (!has_future) {
[16:09:27.387]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.387]                             info)
[16:09:27.387]                         }
[16:09:27.387]                         else {
[16:09:27.387]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.387]                             info, version)
[16:09:27.387]                         }
[16:09:27.387]                         base::stop(msg)
[16:09:27.387]                       }
[16:09:27.387]                     })
[16:09:27.387]                   }
[16:09:27.387]                   options(future.plan = NULL)
[16:09:27.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.387]                 }
[16:09:27.387]                 ...future.workdir <- getwd()
[16:09:27.387]             }
[16:09:27.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.387]         }
[16:09:27.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.387]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.387]             base::names(...future.oldOptions))
[16:09:27.387]     }
[16:09:27.387]     if (FALSE) {
[16:09:27.387]     }
[16:09:27.387]     else {
[16:09:27.387]         if (TRUE) {
[16:09:27.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.387]                 open = "w")
[16:09:27.387]         }
[16:09:27.387]         else {
[16:09:27.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.387]         }
[16:09:27.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.387]             base::sink(type = "output", split = FALSE)
[16:09:27.387]             base::close(...future.stdout)
[16:09:27.387]         }, add = TRUE)
[16:09:27.387]     }
[16:09:27.387]     ...future.frame <- base::sys.nframe()
[16:09:27.387]     ...future.conditions <- base::list()
[16:09:27.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.387]     if (FALSE) {
[16:09:27.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.387]     }
[16:09:27.387]     ...future.result <- base::tryCatch({
[16:09:27.387]         base::withCallingHandlers({
[16:09:27.387]             ...future.value <- base::withVisible(base::local({
[16:09:27.387]                 do.call(function(...) {
[16:09:27.387]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.387]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.387]                     ...future.globals.maxSize)) {
[16:09:27.387]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.387]                     on.exit(options(oopts), add = TRUE)
[16:09:27.387]                   }
[16:09:27.387]                   {
[16:09:27.387]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.387]                       FUN = function(jj) {
[16:09:27.387]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.387]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.387]                       })
[16:09:27.387]                   }
[16:09:27.387]                 }, args = future.call.arguments)
[16:09:27.387]             }))
[16:09:27.387]             future::FutureResult(value = ...future.value$value, 
[16:09:27.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.387]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.387]                     ...future.globalenv.names))
[16:09:27.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.387]         }, condition = base::local({
[16:09:27.387]             c <- base::c
[16:09:27.387]             inherits <- base::inherits
[16:09:27.387]             invokeRestart <- base::invokeRestart
[16:09:27.387]             length <- base::length
[16:09:27.387]             list <- base::list
[16:09:27.387]             seq.int <- base::seq.int
[16:09:27.387]             signalCondition <- base::signalCondition
[16:09:27.387]             sys.calls <- base::sys.calls
[16:09:27.387]             `[[` <- base::`[[`
[16:09:27.387]             `+` <- base::`+`
[16:09:27.387]             `<<-` <- base::`<<-`
[16:09:27.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.387]                   3L)]
[16:09:27.387]             }
[16:09:27.387]             function(cond) {
[16:09:27.387]                 is_error <- inherits(cond, "error")
[16:09:27.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.387]                   NULL)
[16:09:27.387]                 if (is_error) {
[16:09:27.387]                   sessionInformation <- function() {
[16:09:27.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.387]                       search = base::search(), system = base::Sys.info())
[16:09:27.387]                   }
[16:09:27.387]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.387]                     cond$call), session = sessionInformation(), 
[16:09:27.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.387]                   signalCondition(cond)
[16:09:27.387]                 }
[16:09:27.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.387]                 "immediateCondition"))) {
[16:09:27.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.387]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.387]                   if (TRUE && !signal) {
[16:09:27.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.387]                     {
[16:09:27.387]                       inherits <- base::inherits
[16:09:27.387]                       invokeRestart <- base::invokeRestart
[16:09:27.387]                       is.null <- base::is.null
[16:09:27.387]                       muffled <- FALSE
[16:09:27.387]                       if (inherits(cond, "message")) {
[16:09:27.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.387]                         if (muffled) 
[16:09:27.387]                           invokeRestart("muffleMessage")
[16:09:27.387]                       }
[16:09:27.387]                       else if (inherits(cond, "warning")) {
[16:09:27.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.387]                         if (muffled) 
[16:09:27.387]                           invokeRestart("muffleWarning")
[16:09:27.387]                       }
[16:09:27.387]                       else if (inherits(cond, "condition")) {
[16:09:27.387]                         if (!is.null(pattern)) {
[16:09:27.387]                           computeRestarts <- base::computeRestarts
[16:09:27.387]                           grepl <- base::grepl
[16:09:27.387]                           restarts <- computeRestarts(cond)
[16:09:27.387]                           for (restart in restarts) {
[16:09:27.387]                             name <- restart$name
[16:09:27.387]                             if (is.null(name)) 
[16:09:27.387]                               next
[16:09:27.387]                             if (!grepl(pattern, name)) 
[16:09:27.387]                               next
[16:09:27.387]                             invokeRestart(restart)
[16:09:27.387]                             muffled <- TRUE
[16:09:27.387]                             break
[16:09:27.387]                           }
[16:09:27.387]                         }
[16:09:27.387]                       }
[16:09:27.387]                       invisible(muffled)
[16:09:27.387]                     }
[16:09:27.387]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.387]                   }
[16:09:27.387]                 }
[16:09:27.387]                 else {
[16:09:27.387]                   if (TRUE) {
[16:09:27.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.387]                     {
[16:09:27.387]                       inherits <- base::inherits
[16:09:27.387]                       invokeRestart <- base::invokeRestart
[16:09:27.387]                       is.null <- base::is.null
[16:09:27.387]                       muffled <- FALSE
[16:09:27.387]                       if (inherits(cond, "message")) {
[16:09:27.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.387]                         if (muffled) 
[16:09:27.387]                           invokeRestart("muffleMessage")
[16:09:27.387]                       }
[16:09:27.387]                       else if (inherits(cond, "warning")) {
[16:09:27.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.387]                         if (muffled) 
[16:09:27.387]                           invokeRestart("muffleWarning")
[16:09:27.387]                       }
[16:09:27.387]                       else if (inherits(cond, "condition")) {
[16:09:27.387]                         if (!is.null(pattern)) {
[16:09:27.387]                           computeRestarts <- base::computeRestarts
[16:09:27.387]                           grepl <- base::grepl
[16:09:27.387]                           restarts <- computeRestarts(cond)
[16:09:27.387]                           for (restart in restarts) {
[16:09:27.387]                             name <- restart$name
[16:09:27.387]                             if (is.null(name)) 
[16:09:27.387]                               next
[16:09:27.387]                             if (!grepl(pattern, name)) 
[16:09:27.387]                               next
[16:09:27.387]                             invokeRestart(restart)
[16:09:27.387]                             muffled <- TRUE
[16:09:27.387]                             break
[16:09:27.387]                           }
[16:09:27.387]                         }
[16:09:27.387]                       }
[16:09:27.387]                       invisible(muffled)
[16:09:27.387]                     }
[16:09:27.387]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.387]                   }
[16:09:27.387]                 }
[16:09:27.387]             }
[16:09:27.387]         }))
[16:09:27.387]     }, error = function(ex) {
[16:09:27.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.387]                 ...future.rng), started = ...future.startTime, 
[16:09:27.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.387]             version = "1.8"), class = "FutureResult")
[16:09:27.387]     }, finally = {
[16:09:27.387]         if (!identical(...future.workdir, getwd())) 
[16:09:27.387]             setwd(...future.workdir)
[16:09:27.387]         {
[16:09:27.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.387]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.387]             }
[16:09:27.387]             base::options(...future.oldOptions)
[16:09:27.387]             if (.Platform$OS.type == "windows") {
[16:09:27.387]                 old_names <- names(...future.oldEnvVars)
[16:09:27.387]                 envs <- base::Sys.getenv()
[16:09:27.387]                 names <- names(envs)
[16:09:27.387]                 common <- intersect(names, old_names)
[16:09:27.387]                 added <- setdiff(names, old_names)
[16:09:27.387]                 removed <- setdiff(old_names, names)
[16:09:27.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.387]                   envs[common]]
[16:09:27.387]                 NAMES <- toupper(changed)
[16:09:27.387]                 args <- list()
[16:09:27.387]                 for (kk in seq_along(NAMES)) {
[16:09:27.387]                   name <- changed[[kk]]
[16:09:27.387]                   NAME <- NAMES[[kk]]
[16:09:27.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.387]                     next
[16:09:27.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.387]                 }
[16:09:27.387]                 NAMES <- toupper(added)
[16:09:27.387]                 for (kk in seq_along(NAMES)) {
[16:09:27.387]                   name <- added[[kk]]
[16:09:27.387]                   NAME <- NAMES[[kk]]
[16:09:27.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.387]                     next
[16:09:27.387]                   args[[name]] <- ""
[16:09:27.387]                 }
[16:09:27.387]                 NAMES <- toupper(removed)
[16:09:27.387]                 for (kk in seq_along(NAMES)) {
[16:09:27.387]                   name <- removed[[kk]]
[16:09:27.387]                   NAME <- NAMES[[kk]]
[16:09:27.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.387]                     next
[16:09:27.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.387]                 }
[16:09:27.387]                 if (length(args) > 0) 
[16:09:27.387]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.387]             }
[16:09:27.387]             else {
[16:09:27.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.387]             }
[16:09:27.387]             {
[16:09:27.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.387]                   0L) {
[16:09:27.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.387]                   base::options(opts)
[16:09:27.387]                 }
[16:09:27.387]                 {
[16:09:27.387]                   {
[16:09:27.387]                     NULL
[16:09:27.387]                     RNGkind("Mersenne-Twister")
[16:09:27.387]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.387]                       inherits = FALSE)
[16:09:27.387]                   }
[16:09:27.387]                   options(future.plan = NULL)
[16:09:27.387]                   if (is.na(NA_character_)) 
[16:09:27.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.387]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.387]                   {
[16:09:27.387]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.387]                     if (!future$lazy) 
[16:09:27.387]                       future <- run(future)
[16:09:27.387]                     invisible(future)
[16:09:27.387]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.387]                 }
[16:09:27.387]             }
[16:09:27.387]         }
[16:09:27.387]     })
[16:09:27.387]     if (TRUE) {
[16:09:27.387]         base::sink(type = "output", split = FALSE)
[16:09:27.387]         if (TRUE) {
[16:09:27.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.387]         }
[16:09:27.387]         else {
[16:09:27.387]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.387]         }
[16:09:27.387]         base::close(...future.stdout)
[16:09:27.387]         ...future.stdout <- NULL
[16:09:27.387]     }
[16:09:27.387]     ...future.result$conditions <- ...future.conditions
[16:09:27.387]     ...future.result$finished <- base::Sys.time()
[16:09:27.387]     ...future.result
[16:09:27.387] }
[16:09:27.389] assign_globals() ...
[16:09:27.389] List of 5
[16:09:27.389]  $ future.call.arguments    : list()
[16:09:27.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.389]  $ ...future.FUN            :function (x)  
[16:09:27.389]  $ ...future.elements_ii    :List of 6
[16:09:27.389]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:27.389]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:27.389]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:27.389]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:27.389]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:27.389]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:27.389]  $ ...future.seeds_ii       : NULL
[16:09:27.389]  $ ...future.globals.maxSize: num Inf
[16:09:27.389]  - attr(*, "resolved")= logi FALSE
[16:09:27.389]  - attr(*, "total_size")= num NA
[16:09:27.389]  - attr(*, "where")=List of 5
[16:09:27.389]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.389]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.389]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.389]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.389]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.389]  - attr(*, "already-done")= logi TRUE
[16:09:27.396] - copied ‘future.call.arguments’ to environment
[16:09:27.396] - copied ‘...future.FUN’ to environment
[16:09:27.396] - copied ‘...future.elements_ii’ to environment
[16:09:27.396] - copied ‘...future.seeds_ii’ to environment
[16:09:27.396] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.396] assign_globals() ... done
[16:09:27.396] plan(): Setting new future strategy stack:
[16:09:27.396] List of future strategies:
[16:09:27.396] 1. sequential:
[16:09:27.396]    - args: function (..., envir = parent.frame())
[16:09:27.396]    - tweaked: FALSE
[16:09:27.396]    - call: NULL
[16:09:27.397] plan(): nbrOfWorkers() = 1
[16:09:27.398] plan(): Setting new future strategy stack:
[16:09:27.398] List of future strategies:
[16:09:27.398] 1. sequential:
[16:09:27.398]    - args: function (..., envir = parent.frame())
[16:09:27.398]    - tweaked: FALSE
[16:09:27.398]    - call: plan(strategy)
[16:09:27.398] plan(): nbrOfWorkers() = 1
[16:09:27.398] SequentialFuture started (and completed)
[16:09:27.398] - Launch lazy future ... done
[16:09:27.398] run() for ‘SequentialFuture’ ... done
[16:09:27.399] Created future:
[16:09:27.399] SequentialFuture:
[16:09:27.399] Label: ‘future_apply-1’
[16:09:27.399] Expression:
[16:09:27.399] {
[16:09:27.399]     do.call(function(...) {
[16:09:27.399]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.399]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.399]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.399]             on.exit(options(oopts), add = TRUE)
[16:09:27.399]         }
[16:09:27.399]         {
[16:09:27.399]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.399]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.399]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.399]             })
[16:09:27.399]         }
[16:09:27.399]     }, args = future.call.arguments)
[16:09:27.399] }
[16:09:27.399] Lazy evaluation: FALSE
[16:09:27.399] Asynchronous evaluation: FALSE
[16:09:27.399] Local evaluation: TRUE
[16:09:27.399] Environment: R_GlobalEnv
[16:09:27.399] Capture standard output: TRUE
[16:09:27.399] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.399] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.399] Packages: <none>
[16:09:27.399] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.399] Resolved: TRUE
[16:09:27.399] Value: 672 bytes of class ‘list’
[16:09:27.399] Early signaling: FALSE
[16:09:27.399] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.399] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.400] Chunk #1 of 1 ... DONE
[16:09:27.400] Launching 1 futures (chunks) ... DONE
[16:09:27.400] Resolving 1 futures (chunks) ...
[16:09:27.400] resolve() on list ...
[16:09:27.400]  recursive: 0
[16:09:27.400]  length: 1
[16:09:27.400] 
[16:09:27.400] resolved() for ‘SequentialFuture’ ...
[16:09:27.400] - state: ‘finished’
[16:09:27.400] - run: TRUE
[16:09:27.401] - result: ‘FutureResult’
[16:09:27.401] resolved() for ‘SequentialFuture’ ... done
[16:09:27.401] Future #1
[16:09:27.401] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.401] - nx: 1
[16:09:27.401] - relay: TRUE
[16:09:27.401] - stdout: TRUE
[16:09:27.401] - signal: TRUE
[16:09:27.401] - resignal: FALSE
[16:09:27.401] - force: TRUE
[16:09:27.401] - relayed: [n=1] FALSE
[16:09:27.402] - queued futures: [n=1] FALSE
[16:09:27.402]  - until=1
[16:09:27.402]  - relaying element #1
[16:09:27.402] - relayed: [n=1] TRUE
[16:09:27.402] - queued futures: [n=1] TRUE
[16:09:27.402] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.402]  length: 0 (resolved future 1)
[16:09:27.402] Relaying remaining futures
[16:09:27.402] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.403] - nx: 1
[16:09:27.403] - relay: TRUE
[16:09:27.403] - stdout: TRUE
[16:09:27.403] - signal: TRUE
[16:09:27.403] - resignal: FALSE
[16:09:27.403] - force: TRUE
[16:09:27.403] - relayed: [n=1] TRUE
[16:09:27.403] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.403] - relayed: [n=1] TRUE
[16:09:27.403] - queued futures: [n=1] TRUE
[16:09:27.403] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.403] resolve() on list ... DONE
[16:09:27.404]  - Number of value chunks collected: 1
[16:09:27.404] Resolving 1 futures (chunks) ... DONE
[16:09:27.404] Reducing values from 1 chunks ...
[16:09:27.404]  - Number of values collected after concatenation: 6
[16:09:27.404]  - Number of values expected: 6
[16:09:27.404] Reducing values from 1 chunks ... DONE
[16:09:27.404] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:09:27.405] getGlobalsAndPackagesXApply() ...
[16:09:27.405]  - future.globals: TRUE
[16:09:27.405] getGlobalsAndPackages() ...
[16:09:27.405] Searching for globals...
[16:09:27.406] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:09:27.406] Searching for globals ... DONE
[16:09:27.406] Resolving globals: FALSE
[16:09:27.407] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:09:27.407] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:09:27.407] - globals: [1] ‘FUN’
[16:09:27.407] 
[16:09:27.407] getGlobalsAndPackages() ... DONE
[16:09:27.407]  - globals found/used: [n=1] ‘FUN’
[16:09:27.408]  - needed namespaces: [n=0] 
[16:09:27.408] Finding globals ... DONE
[16:09:27.408]  - use_args: TRUE
[16:09:27.408]  - Getting '...' globals ...
[16:09:27.409] resolve() on list ...
[16:09:27.409]  recursive: 0
[16:09:27.409]  length: 1
[16:09:27.409]  elements: ‘...’
[16:09:27.410]  length: 0 (resolved future 1)
[16:09:27.410] resolve() on list ... DONE
[16:09:27.410]    - '...' content: [n=0] 
[16:09:27.410] List of 1
[16:09:27.410]  $ ...: list()
[16:09:27.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.410]  - attr(*, "where")=List of 1
[16:09:27.410]   ..$ ...:<environment: 0x5633ac6f3620> 
[16:09:27.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.410]  - attr(*, "resolved")= logi TRUE
[16:09:27.410]  - attr(*, "total_size")= num NA
[16:09:27.412]  - Getting '...' globals ... DONE
[16:09:27.412] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.413] List of 2
[16:09:27.413]  $ ...future.FUN:function (x)  
[16:09:27.413]  $ ...          : list()
[16:09:27.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.413]  - attr(*, "where")=List of 2
[16:09:27.413]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.413]   ..$ ...          :<environment: 0x5633ac6f3620> 
[16:09:27.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.413]  - attr(*, "resolved")= logi FALSE
[16:09:27.413]  - attr(*, "total_size")= num 1768
[16:09:27.415] Packages to be attached in all futures: [n=0] 
[16:09:27.415] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.415] future_lapply() ...
[16:09:27.416] Number of chunks: 1
[16:09:27.416] getGlobalsAndPackagesXApply() ...
[16:09:27.416]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.416]  - use_args: TRUE
[16:09:27.416] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.416] List of 2
[16:09:27.416]  $ ...          : list()
[16:09:27.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.416]  $ ...future.FUN:function (x)  
[16:09:27.416]  - attr(*, "where")=List of 2
[16:09:27.416]   ..$ ...          :<environment: 0x5633ac6f3620> 
[16:09:27.416]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:09:27.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.416]  - attr(*, "resolved")= logi FALSE
[16:09:27.416]  - attr(*, "total_size")= num NA
[16:09:27.419] Packages to be attached in all futures: [n=0] 
[16:09:27.419] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.419] Number of futures (= number of chunks): 1
[16:09:27.419] Launching 1 futures (chunks) ...
[16:09:27.420] Chunk #1 of 1 ...
[16:09:27.420]  - Adjusted option 'future.globals.maxSize': Inf -> 6 * Inf = Inf (bytes)
[16:09:27.420]  - seeds: <none>
[16:09:27.420] getGlobalsAndPackages() ...
[16:09:27.420] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.420] Resolving globals: FALSE
[16:09:27.420] Tweak future expression to call with '...' arguments ...
[16:09:27.420] {
[16:09:27.420]     do.call(function(...) {
[16:09:27.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.420]             on.exit(options(oopts), add = TRUE)
[16:09:27.420]         }
[16:09:27.420]         {
[16:09:27.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.420]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.420]             })
[16:09:27.420]         }
[16:09:27.420]     }, args = future.call.arguments)
[16:09:27.420] }
[16:09:27.421] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.421] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.421] 
[16:09:27.421] getGlobalsAndPackages() ... DONE
[16:09:27.421] run() for ‘Future’ ...
[16:09:27.421] - state: ‘created’
[16:09:27.422] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.422] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.422]   - Field: ‘label’
[16:09:27.422]   - Field: ‘local’
[16:09:27.422]   - Field: ‘owner’
[16:09:27.422]   - Field: ‘envir’
[16:09:27.422]   - Field: ‘packages’
[16:09:27.423]   - Field: ‘gc’
[16:09:27.423]   - Field: ‘conditions’
[16:09:27.423]   - Field: ‘expr’
[16:09:27.423]   - Field: ‘uuid’
[16:09:27.423]   - Field: ‘seed’
[16:09:27.423]   - Field: ‘version’
[16:09:27.423]   - Field: ‘result’
[16:09:27.423]   - Field: ‘asynchronous’
[16:09:27.423]   - Field: ‘calls’
[16:09:27.423]   - Field: ‘globals’
[16:09:27.423]   - Field: ‘stdout’
[16:09:27.423]   - Field: ‘earlySignal’
[16:09:27.424]   - Field: ‘lazy’
[16:09:27.424]   - Field: ‘state’
[16:09:27.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.424] - Launch lazy future ...
[16:09:27.424] Packages needed by the future expression (n = 0): <none>
[16:09:27.424] Packages needed by future strategies (n = 0): <none>
[16:09:27.425] {
[16:09:27.425]     {
[16:09:27.425]         {
[16:09:27.425]             ...future.startTime <- base::Sys.time()
[16:09:27.425]             {
[16:09:27.425]                 {
[16:09:27.425]                   {
[16:09:27.425]                     base::local({
[16:09:27.425]                       has_future <- base::requireNamespace("future", 
[16:09:27.425]                         quietly = TRUE)
[16:09:27.425]                       if (has_future) {
[16:09:27.425]                         ns <- base::getNamespace("future")
[16:09:27.425]                         version <- ns[[".package"]][["version"]]
[16:09:27.425]                         if (is.null(version)) 
[16:09:27.425]                           version <- utils::packageVersion("future")
[16:09:27.425]                       }
[16:09:27.425]                       else {
[16:09:27.425]                         version <- NULL
[16:09:27.425]                       }
[16:09:27.425]                       if (!has_future || version < "1.8.0") {
[16:09:27.425]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.425]                           "", base::R.version$version.string), 
[16:09:27.425]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.425]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.425]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.425]                             "release", "version")], collapse = " "), 
[16:09:27.425]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.425]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.425]                           info)
[16:09:27.425]                         info <- base::paste(info, collapse = "; ")
[16:09:27.425]                         if (!has_future) {
[16:09:27.425]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.425]                             info)
[16:09:27.425]                         }
[16:09:27.425]                         else {
[16:09:27.425]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.425]                             info, version)
[16:09:27.425]                         }
[16:09:27.425]                         base::stop(msg)
[16:09:27.425]                       }
[16:09:27.425]                     })
[16:09:27.425]                   }
[16:09:27.425]                   options(future.plan = NULL)
[16:09:27.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.425]                 }
[16:09:27.425]                 ...future.workdir <- getwd()
[16:09:27.425]             }
[16:09:27.425]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.425]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.425]         }
[16:09:27.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.425]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.425]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.425]             base::names(...future.oldOptions))
[16:09:27.425]     }
[16:09:27.425]     if (FALSE) {
[16:09:27.425]     }
[16:09:27.425]     else {
[16:09:27.425]         if (TRUE) {
[16:09:27.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.425]                 open = "w")
[16:09:27.425]         }
[16:09:27.425]         else {
[16:09:27.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.425]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.425]         }
[16:09:27.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.425]             base::sink(type = "output", split = FALSE)
[16:09:27.425]             base::close(...future.stdout)
[16:09:27.425]         }, add = TRUE)
[16:09:27.425]     }
[16:09:27.425]     ...future.frame <- base::sys.nframe()
[16:09:27.425]     ...future.conditions <- base::list()
[16:09:27.425]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.425]     if (FALSE) {
[16:09:27.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.425]     }
[16:09:27.425]     ...future.result <- base::tryCatch({
[16:09:27.425]         base::withCallingHandlers({
[16:09:27.425]             ...future.value <- base::withVisible(base::local({
[16:09:27.425]                 do.call(function(...) {
[16:09:27.425]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.425]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.425]                     ...future.globals.maxSize)) {
[16:09:27.425]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.425]                     on.exit(options(oopts), add = TRUE)
[16:09:27.425]                   }
[16:09:27.425]                   {
[16:09:27.425]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.425]                       FUN = function(jj) {
[16:09:27.425]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.425]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.425]                       })
[16:09:27.425]                   }
[16:09:27.425]                 }, args = future.call.arguments)
[16:09:27.425]             }))
[16:09:27.425]             future::FutureResult(value = ...future.value$value, 
[16:09:27.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.425]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.425]                     ...future.globalenv.names))
[16:09:27.425]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.425]         }, condition = base::local({
[16:09:27.425]             c <- base::c
[16:09:27.425]             inherits <- base::inherits
[16:09:27.425]             invokeRestart <- base::invokeRestart
[16:09:27.425]             length <- base::length
[16:09:27.425]             list <- base::list
[16:09:27.425]             seq.int <- base::seq.int
[16:09:27.425]             signalCondition <- base::signalCondition
[16:09:27.425]             sys.calls <- base::sys.calls
[16:09:27.425]             `[[` <- base::`[[`
[16:09:27.425]             `+` <- base::`+`
[16:09:27.425]             `<<-` <- base::`<<-`
[16:09:27.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.425]                   3L)]
[16:09:27.425]             }
[16:09:27.425]             function(cond) {
[16:09:27.425]                 is_error <- inherits(cond, "error")
[16:09:27.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.425]                   NULL)
[16:09:27.425]                 if (is_error) {
[16:09:27.425]                   sessionInformation <- function() {
[16:09:27.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.425]                       search = base::search(), system = base::Sys.info())
[16:09:27.425]                   }
[16:09:27.425]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.425]                     cond$call), session = sessionInformation(), 
[16:09:27.425]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.425]                   signalCondition(cond)
[16:09:27.425]                 }
[16:09:27.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.425]                 "immediateCondition"))) {
[16:09:27.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.425]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.425]                   if (TRUE && !signal) {
[16:09:27.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.425]                     {
[16:09:27.425]                       inherits <- base::inherits
[16:09:27.425]                       invokeRestart <- base::invokeRestart
[16:09:27.425]                       is.null <- base::is.null
[16:09:27.425]                       muffled <- FALSE
[16:09:27.425]                       if (inherits(cond, "message")) {
[16:09:27.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.425]                         if (muffled) 
[16:09:27.425]                           invokeRestart("muffleMessage")
[16:09:27.425]                       }
[16:09:27.425]                       else if (inherits(cond, "warning")) {
[16:09:27.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.425]                         if (muffled) 
[16:09:27.425]                           invokeRestart("muffleWarning")
[16:09:27.425]                       }
[16:09:27.425]                       else if (inherits(cond, "condition")) {
[16:09:27.425]                         if (!is.null(pattern)) {
[16:09:27.425]                           computeRestarts <- base::computeRestarts
[16:09:27.425]                           grepl <- base::grepl
[16:09:27.425]                           restarts <- computeRestarts(cond)
[16:09:27.425]                           for (restart in restarts) {
[16:09:27.425]                             name <- restart$name
[16:09:27.425]                             if (is.null(name)) 
[16:09:27.425]                               next
[16:09:27.425]                             if (!grepl(pattern, name)) 
[16:09:27.425]                               next
[16:09:27.425]                             invokeRestart(restart)
[16:09:27.425]                             muffled <- TRUE
[16:09:27.425]                             break
[16:09:27.425]                           }
[16:09:27.425]                         }
[16:09:27.425]                       }
[16:09:27.425]                       invisible(muffled)
[16:09:27.425]                     }
[16:09:27.425]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.425]                   }
[16:09:27.425]                 }
[16:09:27.425]                 else {
[16:09:27.425]                   if (TRUE) {
[16:09:27.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.425]                     {
[16:09:27.425]                       inherits <- base::inherits
[16:09:27.425]                       invokeRestart <- base::invokeRestart
[16:09:27.425]                       is.null <- base::is.null
[16:09:27.425]                       muffled <- FALSE
[16:09:27.425]                       if (inherits(cond, "message")) {
[16:09:27.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.425]                         if (muffled) 
[16:09:27.425]                           invokeRestart("muffleMessage")
[16:09:27.425]                       }
[16:09:27.425]                       else if (inherits(cond, "warning")) {
[16:09:27.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.425]                         if (muffled) 
[16:09:27.425]                           invokeRestart("muffleWarning")
[16:09:27.425]                       }
[16:09:27.425]                       else if (inherits(cond, "condition")) {
[16:09:27.425]                         if (!is.null(pattern)) {
[16:09:27.425]                           computeRestarts <- base::computeRestarts
[16:09:27.425]                           grepl <- base::grepl
[16:09:27.425]                           restarts <- computeRestarts(cond)
[16:09:27.425]                           for (restart in restarts) {
[16:09:27.425]                             name <- restart$name
[16:09:27.425]                             if (is.null(name)) 
[16:09:27.425]                               next
[16:09:27.425]                             if (!grepl(pattern, name)) 
[16:09:27.425]                               next
[16:09:27.425]                             invokeRestart(restart)
[16:09:27.425]                             muffled <- TRUE
[16:09:27.425]                             break
[16:09:27.425]                           }
[16:09:27.425]                         }
[16:09:27.425]                       }
[16:09:27.425]                       invisible(muffled)
[16:09:27.425]                     }
[16:09:27.425]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.425]                   }
[16:09:27.425]                 }
[16:09:27.425]             }
[16:09:27.425]         }))
[16:09:27.425]     }, error = function(ex) {
[16:09:27.425]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.425]                 ...future.rng), started = ...future.startTime, 
[16:09:27.425]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.425]             version = "1.8"), class = "FutureResult")
[16:09:27.425]     }, finally = {
[16:09:27.425]         if (!identical(...future.workdir, getwd())) 
[16:09:27.425]             setwd(...future.workdir)
[16:09:27.425]         {
[16:09:27.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.425]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.425]             }
[16:09:27.425]             base::options(...future.oldOptions)
[16:09:27.425]             if (.Platform$OS.type == "windows") {
[16:09:27.425]                 old_names <- names(...future.oldEnvVars)
[16:09:27.425]                 envs <- base::Sys.getenv()
[16:09:27.425]                 names <- names(envs)
[16:09:27.425]                 common <- intersect(names, old_names)
[16:09:27.425]                 added <- setdiff(names, old_names)
[16:09:27.425]                 removed <- setdiff(old_names, names)
[16:09:27.425]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.425]                   envs[common]]
[16:09:27.425]                 NAMES <- toupper(changed)
[16:09:27.425]                 args <- list()
[16:09:27.425]                 for (kk in seq_along(NAMES)) {
[16:09:27.425]                   name <- changed[[kk]]
[16:09:27.425]                   NAME <- NAMES[[kk]]
[16:09:27.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.425]                     next
[16:09:27.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.425]                 }
[16:09:27.425]                 NAMES <- toupper(added)
[16:09:27.425]                 for (kk in seq_along(NAMES)) {
[16:09:27.425]                   name <- added[[kk]]
[16:09:27.425]                   NAME <- NAMES[[kk]]
[16:09:27.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.425]                     next
[16:09:27.425]                   args[[name]] <- ""
[16:09:27.425]                 }
[16:09:27.425]                 NAMES <- toupper(removed)
[16:09:27.425]                 for (kk in seq_along(NAMES)) {
[16:09:27.425]                   name <- removed[[kk]]
[16:09:27.425]                   NAME <- NAMES[[kk]]
[16:09:27.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.425]                     next
[16:09:27.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.425]                 }
[16:09:27.425]                 if (length(args) > 0) 
[16:09:27.425]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.425]             }
[16:09:27.425]             else {
[16:09:27.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.425]             }
[16:09:27.425]             {
[16:09:27.425]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.425]                   0L) {
[16:09:27.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.425]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.425]                   base::options(opts)
[16:09:27.425]                 }
[16:09:27.425]                 {
[16:09:27.425]                   {
[16:09:27.425]                     NULL
[16:09:27.425]                     RNGkind("Mersenne-Twister")
[16:09:27.425]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.425]                       inherits = FALSE)
[16:09:27.425]                   }
[16:09:27.425]                   options(future.plan = NULL)
[16:09:27.425]                   if (is.na(NA_character_)) 
[16:09:27.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.425]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.425]                   {
[16:09:27.425]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.425]                     if (!future$lazy) 
[16:09:27.425]                       future <- run(future)
[16:09:27.425]                     invisible(future)
[16:09:27.425]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.425]                 }
[16:09:27.425]             }
[16:09:27.425]         }
[16:09:27.425]     })
[16:09:27.425]     if (TRUE) {
[16:09:27.425]         base::sink(type = "output", split = FALSE)
[16:09:27.425]         if (TRUE) {
[16:09:27.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.425]         }
[16:09:27.425]         else {
[16:09:27.425]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.425]         }
[16:09:27.425]         base::close(...future.stdout)
[16:09:27.425]         ...future.stdout <- NULL
[16:09:27.425]     }
[16:09:27.425]     ...future.result$conditions <- ...future.conditions
[16:09:27.425]     ...future.result$finished <- base::Sys.time()
[16:09:27.425]     ...future.result
[16:09:27.425] }
[16:09:27.426] assign_globals() ...
[16:09:27.426] List of 5
[16:09:27.426]  $ future.call.arguments    : list()
[16:09:27.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.426]  $ ...future.FUN            :function (x)  
[16:09:27.426]  $ ...future.elements_ii    :List of 6
[16:09:27.426]   ..$ : int [1:4] 1 7 13 19
[16:09:27.426]   ..$ : int [1:4] 2 8 14 20
[16:09:27.426]   ..$ : int [1:4] 3 9 15 21
[16:09:27.426]   ..$ : int [1:4] 4 10 16 22
[16:09:27.426]   ..$ : int [1:4] 5 11 17 23
[16:09:27.426]   ..$ : int [1:4] 6 12 18 24
[16:09:27.426]  $ ...future.seeds_ii       : NULL
[16:09:27.426]  $ ...future.globals.maxSize: num Inf
[16:09:27.426]  - attr(*, "resolved")= logi FALSE
[16:09:27.426]  - attr(*, "total_size")= num NA
[16:09:27.426]  - attr(*, "where")=List of 5
[16:09:27.426]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.426]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.426]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.426]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.426]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.426]  - attr(*, "already-done")= logi TRUE
[16:09:27.455] - copied ‘future.call.arguments’ to environment
[16:09:27.455] - reassign environment for ‘...future.FUN’
[16:09:27.456] - copied ‘...future.FUN’ to environment
[16:09:27.456] - copied ‘...future.elements_ii’ to environment
[16:09:27.456] - copied ‘...future.seeds_ii’ to environment
[16:09:27.456] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.456] assign_globals() ... done
[16:09:27.456] plan(): Setting new future strategy stack:
[16:09:27.456] List of future strategies:
[16:09:27.456] 1. sequential:
[16:09:27.456]    - args: function (..., envir = parent.frame())
[16:09:27.456]    - tweaked: FALSE
[16:09:27.456]    - call: NULL
[16:09:27.457] plan(): nbrOfWorkers() = 1
[16:09:27.457] plan(): Setting new future strategy stack:
[16:09:27.458] List of future strategies:
[16:09:27.458] 1. sequential:
[16:09:27.458]    - args: function (..., envir = parent.frame())
[16:09:27.458]    - tweaked: FALSE
[16:09:27.458]    - call: plan(strategy)
[16:09:27.458] plan(): nbrOfWorkers() = 1
[16:09:27.458] SequentialFuture started (and completed)
[16:09:27.458] - Launch lazy future ... done
[16:09:27.458] run() for ‘SequentialFuture’ ... done
[16:09:27.458] Created future:
[16:09:27.458] SequentialFuture:
[16:09:27.458] Label: ‘future_apply-1’
[16:09:27.458] Expression:
[16:09:27.458] {
[16:09:27.458]     do.call(function(...) {
[16:09:27.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.458]             on.exit(options(oopts), add = TRUE)
[16:09:27.458]         }
[16:09:27.458]         {
[16:09:27.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.458]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.458]             })
[16:09:27.458]         }
[16:09:27.458]     }, args = future.call.arguments)
[16:09:27.458] }
[16:09:27.458] Lazy evaluation: FALSE
[16:09:27.458] Asynchronous evaluation: FALSE
[16:09:27.458] Local evaluation: TRUE
[16:09:27.458] Environment: R_GlobalEnv
[16:09:27.458] Capture standard output: TRUE
[16:09:27.458] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.458] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.458] Packages: <none>
[16:09:27.458] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.458] Resolved: TRUE
[16:09:27.458] Value: 1.03 KiB of class ‘list’
[16:09:27.458] Early signaling: FALSE
[16:09:27.458] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.458] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.459] Chunk #1 of 1 ... DONE
[16:09:27.460] Launching 1 futures (chunks) ... DONE
[16:09:27.460] Resolving 1 futures (chunks) ...
[16:09:27.460] resolve() on list ...
[16:09:27.460]  recursive: 0
[16:09:27.460]  length: 1
[16:09:27.460] 
[16:09:27.460] resolved() for ‘SequentialFuture’ ...
[16:09:27.460] - state: ‘finished’
[16:09:27.460] - run: TRUE
[16:09:27.460] - result: ‘FutureResult’
[16:09:27.461] resolved() for ‘SequentialFuture’ ... done
[16:09:27.461] Future #1
[16:09:27.461] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.461] - nx: 1
[16:09:27.461] - relay: TRUE
[16:09:27.461] - stdout: TRUE
[16:09:27.461] - signal: TRUE
[16:09:27.461] - resignal: FALSE
[16:09:27.461] - force: TRUE
[16:09:27.461] - relayed: [n=1] FALSE
[16:09:27.461] - queued futures: [n=1] FALSE
[16:09:27.462]  - until=1
[16:09:27.462]  - relaying element #1
[16:09:27.462] - relayed: [n=1] TRUE
[16:09:27.462] - queued futures: [n=1] TRUE
[16:09:27.462] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.462]  length: 0 (resolved future 1)
[16:09:27.462] Relaying remaining futures
[16:09:27.462] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.462] - nx: 1
[16:09:27.462] - relay: TRUE
[16:09:27.462] - stdout: TRUE
[16:09:27.463] - signal: TRUE
[16:09:27.463] - resignal: FALSE
[16:09:27.463] - force: TRUE
[16:09:27.463] - relayed: [n=1] TRUE
[16:09:27.463] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.463] - relayed: [n=1] TRUE
[16:09:27.463] - queued futures: [n=1] TRUE
[16:09:27.463] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.463] resolve() on list ... DONE
[16:09:27.463]  - Number of value chunks collected: 1
[16:09:27.464] Resolving 1 futures (chunks) ... DONE
[16:09:27.464] Reducing values from 1 chunks ...
[16:09:27.464]  - Number of values collected after concatenation: 6
[16:09:27.464]  - Number of values expected: 6
[16:09:27.464] Reducing values from 1 chunks ... DONE
[16:09:27.464] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:09:27.464] getGlobalsAndPackagesXApply() ...
[16:09:27.464]  - future.globals: TRUE
[16:09:27.464] getGlobalsAndPackages() ...
[16:09:27.465] Searching for globals...
[16:09:27.465] - globals found: [1] ‘FUN’
[16:09:27.466] Searching for globals ... DONE
[16:09:27.466] Resolving globals: FALSE
[16:09:27.466] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:27.466] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:27.466] - globals: [1] ‘FUN’
[16:09:27.467] 
[16:09:27.467] getGlobalsAndPackages() ... DONE
[16:09:27.467]  - globals found/used: [n=1] ‘FUN’
[16:09:27.467]  - needed namespaces: [n=0] 
[16:09:27.467] Finding globals ... DONE
[16:09:27.467]  - use_args: TRUE
[16:09:27.467]  - Getting '...' globals ...
[16:09:27.467] resolve() on list ...
[16:09:27.467]  recursive: 0
[16:09:27.468]  length: 1
[16:09:27.468]  elements: ‘...’
[16:09:27.468]  length: 0 (resolved future 1)
[16:09:27.468] resolve() on list ... DONE
[16:09:27.468]    - '...' content: [n=0] 
[16:09:27.468] List of 1
[16:09:27.468]  $ ...: list()
[16:09:27.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.468]  - attr(*, "where")=List of 1
[16:09:27.468]   ..$ ...:<environment: 0x5633abf59848> 
[16:09:27.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.468]  - attr(*, "resolved")= logi TRUE
[16:09:27.468]  - attr(*, "total_size")= num NA
[16:09:27.470]  - Getting '...' globals ... DONE
[16:09:27.471] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.471] List of 2
[16:09:27.471]  $ ...future.FUN:function (x)  
[16:09:27.471]  $ ...          : list()
[16:09:27.471]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.471]  - attr(*, "where")=List of 2
[16:09:27.471]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.471]   ..$ ...          :<environment: 0x5633abf59848> 
[16:09:27.471]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.471]  - attr(*, "resolved")= logi FALSE
[16:09:27.471]  - attr(*, "total_size")= num 848
[16:09:27.473] Packages to be attached in all futures: [n=0] 
[16:09:27.473] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.474] future_lapply() ...
[16:09:27.475] Number of chunks: 1
[16:09:27.475] getGlobalsAndPackagesXApply() ...
[16:09:27.475]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.475]  - use_args: TRUE
[16:09:27.475] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.475] List of 2
[16:09:27.475]  $ ...          : list()
[16:09:27.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.475]  $ ...future.FUN:function (x)  
[16:09:27.475]  - attr(*, "where")=List of 2
[16:09:27.475]   ..$ ...          :<environment: 0x5633abf59848> 
[16:09:27.475]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.475]  - attr(*, "resolved")= logi FALSE
[16:09:27.475]  - attr(*, "total_size")= num NA
[16:09:27.478] Packages to be attached in all futures: [n=0] 
[16:09:27.478] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.479] Number of futures (= number of chunks): 1
[16:09:27.479] Launching 1 futures (chunks) ...
[16:09:27.479] Chunk #1 of 1 ...
[16:09:27.479]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.479]  - seeds: <none>
[16:09:27.479] getGlobalsAndPackages() ...
[16:09:27.479] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.479] Resolving globals: FALSE
[16:09:27.479] Tweak future expression to call with '...' arguments ...
[16:09:27.480] {
[16:09:27.480]     do.call(function(...) {
[16:09:27.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.480]             on.exit(options(oopts), add = TRUE)
[16:09:27.480]         }
[16:09:27.480]         {
[16:09:27.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.480]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.480]             })
[16:09:27.480]         }
[16:09:27.480]     }, args = future.call.arguments)
[16:09:27.480] }
[16:09:27.480] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.480] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.480] 
[16:09:27.480] getGlobalsAndPackages() ... DONE
[16:09:27.481] run() for ‘Future’ ...
[16:09:27.481] - state: ‘created’
[16:09:27.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.481]   - Field: ‘label’
[16:09:27.481]   - Field: ‘local’
[16:09:27.482]   - Field: ‘owner’
[16:09:27.482]   - Field: ‘envir’
[16:09:27.482]   - Field: ‘packages’
[16:09:27.482]   - Field: ‘gc’
[16:09:27.482]   - Field: ‘conditions’
[16:09:27.482]   - Field: ‘expr’
[16:09:27.482]   - Field: ‘uuid’
[16:09:27.482]   - Field: ‘seed’
[16:09:27.482]   - Field: ‘version’
[16:09:27.482]   - Field: ‘result’
[16:09:27.482]   - Field: ‘asynchronous’
[16:09:27.482]   - Field: ‘calls’
[16:09:27.483]   - Field: ‘globals’
[16:09:27.483]   - Field: ‘stdout’
[16:09:27.483]   - Field: ‘earlySignal’
[16:09:27.483]   - Field: ‘lazy’
[16:09:27.483]   - Field: ‘state’
[16:09:27.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.483] - Launch lazy future ...
[16:09:27.483] Packages needed by the future expression (n = 0): <none>
[16:09:27.483] Packages needed by future strategies (n = 0): <none>
[16:09:27.484] {
[16:09:27.484]     {
[16:09:27.484]         {
[16:09:27.484]             ...future.startTime <- base::Sys.time()
[16:09:27.484]             {
[16:09:27.484]                 {
[16:09:27.484]                   {
[16:09:27.484]                     base::local({
[16:09:27.484]                       has_future <- base::requireNamespace("future", 
[16:09:27.484]                         quietly = TRUE)
[16:09:27.484]                       if (has_future) {
[16:09:27.484]                         ns <- base::getNamespace("future")
[16:09:27.484]                         version <- ns[[".package"]][["version"]]
[16:09:27.484]                         if (is.null(version)) 
[16:09:27.484]                           version <- utils::packageVersion("future")
[16:09:27.484]                       }
[16:09:27.484]                       else {
[16:09:27.484]                         version <- NULL
[16:09:27.484]                       }
[16:09:27.484]                       if (!has_future || version < "1.8.0") {
[16:09:27.484]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.484]                           "", base::R.version$version.string), 
[16:09:27.484]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.484]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.484]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.484]                             "release", "version")], collapse = " "), 
[16:09:27.484]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.484]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.484]                           info)
[16:09:27.484]                         info <- base::paste(info, collapse = "; ")
[16:09:27.484]                         if (!has_future) {
[16:09:27.484]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.484]                             info)
[16:09:27.484]                         }
[16:09:27.484]                         else {
[16:09:27.484]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.484]                             info, version)
[16:09:27.484]                         }
[16:09:27.484]                         base::stop(msg)
[16:09:27.484]                       }
[16:09:27.484]                     })
[16:09:27.484]                   }
[16:09:27.484]                   options(future.plan = NULL)
[16:09:27.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.484]                 }
[16:09:27.484]                 ...future.workdir <- getwd()
[16:09:27.484]             }
[16:09:27.484]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.484]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.484]         }
[16:09:27.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.484]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.484]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.484]             base::names(...future.oldOptions))
[16:09:27.484]     }
[16:09:27.484]     if (FALSE) {
[16:09:27.484]     }
[16:09:27.484]     else {
[16:09:27.484]         if (TRUE) {
[16:09:27.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.484]                 open = "w")
[16:09:27.484]         }
[16:09:27.484]         else {
[16:09:27.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.484]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.484]         }
[16:09:27.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.484]             base::sink(type = "output", split = FALSE)
[16:09:27.484]             base::close(...future.stdout)
[16:09:27.484]         }, add = TRUE)
[16:09:27.484]     }
[16:09:27.484]     ...future.frame <- base::sys.nframe()
[16:09:27.484]     ...future.conditions <- base::list()
[16:09:27.484]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.484]     if (FALSE) {
[16:09:27.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.484]     }
[16:09:27.484]     ...future.result <- base::tryCatch({
[16:09:27.484]         base::withCallingHandlers({
[16:09:27.484]             ...future.value <- base::withVisible(base::local({
[16:09:27.484]                 do.call(function(...) {
[16:09:27.484]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.484]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.484]                     ...future.globals.maxSize)) {
[16:09:27.484]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.484]                     on.exit(options(oopts), add = TRUE)
[16:09:27.484]                   }
[16:09:27.484]                   {
[16:09:27.484]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.484]                       FUN = function(jj) {
[16:09:27.484]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.484]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.484]                       })
[16:09:27.484]                   }
[16:09:27.484]                 }, args = future.call.arguments)
[16:09:27.484]             }))
[16:09:27.484]             future::FutureResult(value = ...future.value$value, 
[16:09:27.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.484]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.484]                     ...future.globalenv.names))
[16:09:27.484]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.484]         }, condition = base::local({
[16:09:27.484]             c <- base::c
[16:09:27.484]             inherits <- base::inherits
[16:09:27.484]             invokeRestart <- base::invokeRestart
[16:09:27.484]             length <- base::length
[16:09:27.484]             list <- base::list
[16:09:27.484]             seq.int <- base::seq.int
[16:09:27.484]             signalCondition <- base::signalCondition
[16:09:27.484]             sys.calls <- base::sys.calls
[16:09:27.484]             `[[` <- base::`[[`
[16:09:27.484]             `+` <- base::`+`
[16:09:27.484]             `<<-` <- base::`<<-`
[16:09:27.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.484]                   3L)]
[16:09:27.484]             }
[16:09:27.484]             function(cond) {
[16:09:27.484]                 is_error <- inherits(cond, "error")
[16:09:27.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.484]                   NULL)
[16:09:27.484]                 if (is_error) {
[16:09:27.484]                   sessionInformation <- function() {
[16:09:27.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.484]                       search = base::search(), system = base::Sys.info())
[16:09:27.484]                   }
[16:09:27.484]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.484]                     cond$call), session = sessionInformation(), 
[16:09:27.484]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.484]                   signalCondition(cond)
[16:09:27.484]                 }
[16:09:27.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.484]                 "immediateCondition"))) {
[16:09:27.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.484]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.484]                   if (TRUE && !signal) {
[16:09:27.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.484]                     {
[16:09:27.484]                       inherits <- base::inherits
[16:09:27.484]                       invokeRestart <- base::invokeRestart
[16:09:27.484]                       is.null <- base::is.null
[16:09:27.484]                       muffled <- FALSE
[16:09:27.484]                       if (inherits(cond, "message")) {
[16:09:27.484]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.484]                         if (muffled) 
[16:09:27.484]                           invokeRestart("muffleMessage")
[16:09:27.484]                       }
[16:09:27.484]                       else if (inherits(cond, "warning")) {
[16:09:27.484]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.484]                         if (muffled) 
[16:09:27.484]                           invokeRestart("muffleWarning")
[16:09:27.484]                       }
[16:09:27.484]                       else if (inherits(cond, "condition")) {
[16:09:27.484]                         if (!is.null(pattern)) {
[16:09:27.484]                           computeRestarts <- base::computeRestarts
[16:09:27.484]                           grepl <- base::grepl
[16:09:27.484]                           restarts <- computeRestarts(cond)
[16:09:27.484]                           for (restart in restarts) {
[16:09:27.484]                             name <- restart$name
[16:09:27.484]                             if (is.null(name)) 
[16:09:27.484]                               next
[16:09:27.484]                             if (!grepl(pattern, name)) 
[16:09:27.484]                               next
[16:09:27.484]                             invokeRestart(restart)
[16:09:27.484]                             muffled <- TRUE
[16:09:27.484]                             break
[16:09:27.484]                           }
[16:09:27.484]                         }
[16:09:27.484]                       }
[16:09:27.484]                       invisible(muffled)
[16:09:27.484]                     }
[16:09:27.484]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.484]                   }
[16:09:27.484]                 }
[16:09:27.484]                 else {
[16:09:27.484]                   if (TRUE) {
[16:09:27.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.484]                     {
[16:09:27.484]                       inherits <- base::inherits
[16:09:27.484]                       invokeRestart <- base::invokeRestart
[16:09:27.484]                       is.null <- base::is.null
[16:09:27.484]                       muffled <- FALSE
[16:09:27.484]                       if (inherits(cond, "message")) {
[16:09:27.484]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.484]                         if (muffled) 
[16:09:27.484]                           invokeRestart("muffleMessage")
[16:09:27.484]                       }
[16:09:27.484]                       else if (inherits(cond, "warning")) {
[16:09:27.484]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.484]                         if (muffled) 
[16:09:27.484]                           invokeRestart("muffleWarning")
[16:09:27.484]                       }
[16:09:27.484]                       else if (inherits(cond, "condition")) {
[16:09:27.484]                         if (!is.null(pattern)) {
[16:09:27.484]                           computeRestarts <- base::computeRestarts
[16:09:27.484]                           grepl <- base::grepl
[16:09:27.484]                           restarts <- computeRestarts(cond)
[16:09:27.484]                           for (restart in restarts) {
[16:09:27.484]                             name <- restart$name
[16:09:27.484]                             if (is.null(name)) 
[16:09:27.484]                               next
[16:09:27.484]                             if (!grepl(pattern, name)) 
[16:09:27.484]                               next
[16:09:27.484]                             invokeRestart(restart)
[16:09:27.484]                             muffled <- TRUE
[16:09:27.484]                             break
[16:09:27.484]                           }
[16:09:27.484]                         }
[16:09:27.484]                       }
[16:09:27.484]                       invisible(muffled)
[16:09:27.484]                     }
[16:09:27.484]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.484]                   }
[16:09:27.484]                 }
[16:09:27.484]             }
[16:09:27.484]         }))
[16:09:27.484]     }, error = function(ex) {
[16:09:27.484]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.484]                 ...future.rng), started = ...future.startTime, 
[16:09:27.484]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.484]             version = "1.8"), class = "FutureResult")
[16:09:27.484]     }, finally = {
[16:09:27.484]         if (!identical(...future.workdir, getwd())) 
[16:09:27.484]             setwd(...future.workdir)
[16:09:27.484]         {
[16:09:27.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.484]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.484]             }
[16:09:27.484]             base::options(...future.oldOptions)
[16:09:27.484]             if (.Platform$OS.type == "windows") {
[16:09:27.484]                 old_names <- names(...future.oldEnvVars)
[16:09:27.484]                 envs <- base::Sys.getenv()
[16:09:27.484]                 names <- names(envs)
[16:09:27.484]                 common <- intersect(names, old_names)
[16:09:27.484]                 added <- setdiff(names, old_names)
[16:09:27.484]                 removed <- setdiff(old_names, names)
[16:09:27.484]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.484]                   envs[common]]
[16:09:27.484]                 NAMES <- toupper(changed)
[16:09:27.484]                 args <- list()
[16:09:27.484]                 for (kk in seq_along(NAMES)) {
[16:09:27.484]                   name <- changed[[kk]]
[16:09:27.484]                   NAME <- NAMES[[kk]]
[16:09:27.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.484]                     next
[16:09:27.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.484]                 }
[16:09:27.484]                 NAMES <- toupper(added)
[16:09:27.484]                 for (kk in seq_along(NAMES)) {
[16:09:27.484]                   name <- added[[kk]]
[16:09:27.484]                   NAME <- NAMES[[kk]]
[16:09:27.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.484]                     next
[16:09:27.484]                   args[[name]] <- ""
[16:09:27.484]                 }
[16:09:27.484]                 NAMES <- toupper(removed)
[16:09:27.484]                 for (kk in seq_along(NAMES)) {
[16:09:27.484]                   name <- removed[[kk]]
[16:09:27.484]                   NAME <- NAMES[[kk]]
[16:09:27.484]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.484]                     next
[16:09:27.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.484]                 }
[16:09:27.484]                 if (length(args) > 0) 
[16:09:27.484]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.484]             }
[16:09:27.484]             else {
[16:09:27.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.484]             }
[16:09:27.484]             {
[16:09:27.484]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.484]                   0L) {
[16:09:27.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.484]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.484]                   base::options(opts)
[16:09:27.484]                 }
[16:09:27.484]                 {
[16:09:27.484]                   {
[16:09:27.484]                     NULL
[16:09:27.484]                     RNGkind("Mersenne-Twister")
[16:09:27.484]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.484]                       inherits = FALSE)
[16:09:27.484]                   }
[16:09:27.484]                   options(future.plan = NULL)
[16:09:27.484]                   if (is.na(NA_character_)) 
[16:09:27.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.484]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.484]                   {
[16:09:27.484]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.484]                     if (!future$lazy) 
[16:09:27.484]                       future <- run(future)
[16:09:27.484]                     invisible(future)
[16:09:27.484]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.484]                 }
[16:09:27.484]             }
[16:09:27.484]         }
[16:09:27.484]     })
[16:09:27.484]     if (TRUE) {
[16:09:27.484]         base::sink(type = "output", split = FALSE)
[16:09:27.484]         if (TRUE) {
[16:09:27.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.484]         }
[16:09:27.484]         else {
[16:09:27.484]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.484]         }
[16:09:27.484]         base::close(...future.stdout)
[16:09:27.484]         ...future.stdout <- NULL
[16:09:27.484]     }
[16:09:27.484]     ...future.result$conditions <- ...future.conditions
[16:09:27.484]     ...future.result$finished <- base::Sys.time()
[16:09:27.484]     ...future.result
[16:09:27.484] }
[16:09:27.485] assign_globals() ...
[16:09:27.486] List of 5
[16:09:27.486]  $ future.call.arguments    : list()
[16:09:27.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.486]  $ ...future.FUN            :function (x)  
[16:09:27.486]  $ ...future.elements_ii    :List of 2
[16:09:27.486]   ..$ : int 1
[16:09:27.486]   ..$ : int 2
[16:09:27.486]  $ ...future.seeds_ii       : NULL
[16:09:27.486]  $ ...future.globals.maxSize: num Inf
[16:09:27.486]  - attr(*, "resolved")= logi FALSE
[16:09:27.486]  - attr(*, "total_size")= num NA
[16:09:27.486]  - attr(*, "where")=List of 5
[16:09:27.486]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.486]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.486]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.486]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.486]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.486]  - attr(*, "already-done")= logi TRUE
[16:09:27.490] - copied ‘future.call.arguments’ to environment
[16:09:27.490] - copied ‘...future.FUN’ to environment
[16:09:27.491] - copied ‘...future.elements_ii’ to environment
[16:09:27.491] - copied ‘...future.seeds_ii’ to environment
[16:09:27.491] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.491] assign_globals() ... done
[16:09:27.491] plan(): Setting new future strategy stack:
[16:09:27.491] List of future strategies:
[16:09:27.491] 1. sequential:
[16:09:27.491]    - args: function (..., envir = parent.frame())
[16:09:27.491]    - tweaked: FALSE
[16:09:27.491]    - call: NULL
[16:09:27.491] plan(): nbrOfWorkers() = 1
[16:09:27.492] plan(): Setting new future strategy stack:
[16:09:27.492] List of future strategies:
[16:09:27.492] 1. sequential:
[16:09:27.492]    - args: function (..., envir = parent.frame())
[16:09:27.492]    - tweaked: FALSE
[16:09:27.492]    - call: plan(strategy)
[16:09:27.493] plan(): nbrOfWorkers() = 1
[16:09:27.493] SequentialFuture started (and completed)
[16:09:27.493] - Launch lazy future ... done
[16:09:27.493] run() for ‘SequentialFuture’ ... done
[16:09:27.493] Created future:
[16:09:27.493] SequentialFuture:
[16:09:27.493] Label: ‘future_apply-1’
[16:09:27.493] Expression:
[16:09:27.493] {
[16:09:27.493]     do.call(function(...) {
[16:09:27.493]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.493]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.493]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.493]             on.exit(options(oopts), add = TRUE)
[16:09:27.493]         }
[16:09:27.493]         {
[16:09:27.493]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.493]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.493]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.493]             })
[16:09:27.493]         }
[16:09:27.493]     }, args = future.call.arguments)
[16:09:27.493] }
[16:09:27.493] Lazy evaluation: FALSE
[16:09:27.493] Asynchronous evaluation: FALSE
[16:09:27.493] Local evaluation: TRUE
[16:09:27.493] Environment: R_GlobalEnv
[16:09:27.493] Capture standard output: TRUE
[16:09:27.493] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.493] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.493] Packages: <none>
[16:09:27.493] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.493] Resolved: TRUE
[16:09:27.493] Value: 112 bytes of class ‘list’
[16:09:27.493] Early signaling: FALSE
[16:09:27.493] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.493] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.494] Chunk #1 of 1 ... DONE
[16:09:27.494] Launching 1 futures (chunks) ... DONE
[16:09:27.494] Resolving 1 futures (chunks) ...
[16:09:27.495] resolve() on list ...
[16:09:27.495]  recursive: 0
[16:09:27.495]  length: 1
[16:09:27.495] 
[16:09:27.495] resolved() for ‘SequentialFuture’ ...
[16:09:27.495] - state: ‘finished’
[16:09:27.495] - run: TRUE
[16:09:27.495] - result: ‘FutureResult’
[16:09:27.495] resolved() for ‘SequentialFuture’ ... done
[16:09:27.495] Future #1
[16:09:27.495] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.496] - nx: 1
[16:09:27.496] - relay: TRUE
[16:09:27.496] - stdout: TRUE
[16:09:27.496] - signal: TRUE
[16:09:27.496] - resignal: FALSE
[16:09:27.496] - force: TRUE
[16:09:27.496] - relayed: [n=1] FALSE
[16:09:27.496] - queued futures: [n=1] FALSE
[16:09:27.496]  - until=1
[16:09:27.496]  - relaying element #1
[16:09:27.497] - relayed: [n=1] TRUE
[16:09:27.497] - queued futures: [n=1] TRUE
[16:09:27.497] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.497]  length: 0 (resolved future 1)
[16:09:27.497] Relaying remaining futures
[16:09:27.497] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.497] - nx: 1
[16:09:27.497] - relay: TRUE
[16:09:27.497] - stdout: TRUE
[16:09:27.497] - signal: TRUE
[16:09:27.497] - resignal: FALSE
[16:09:27.498] - force: TRUE
[16:09:27.498] - relayed: [n=1] TRUE
[16:09:27.499] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.499] - relayed: [n=1] TRUE
[16:09:27.499] - queued futures: [n=1] TRUE
[16:09:27.499] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.499] resolve() on list ... DONE
[16:09:27.499]  - Number of value chunks collected: 1
[16:09:27.499] Resolving 1 futures (chunks) ... DONE
[16:09:27.499] Reducing values from 1 chunks ...
[16:09:27.499]  - Number of values collected after concatenation: 2
[16:09:27.499]  - Number of values expected: 2
[16:09:27.500] Reducing values from 1 chunks ... DONE
[16:09:27.500] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:09:27.500] getGlobalsAndPackagesXApply() ...
[16:09:27.500]  - future.globals: TRUE
[16:09:27.500] getGlobalsAndPackages() ...
[16:09:27.500] Searching for globals...
[16:09:27.501] - globals found: [1] ‘FUN’
[16:09:27.501] Searching for globals ... DONE
[16:09:27.501] Resolving globals: FALSE
[16:09:27.502] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:27.502] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:27.502] - globals: [1] ‘FUN’
[16:09:27.502] 
[16:09:27.502] getGlobalsAndPackages() ... DONE
[16:09:27.502]  - globals found/used: [n=1] ‘FUN’
[16:09:27.502]  - needed namespaces: [n=0] 
[16:09:27.502] Finding globals ... DONE
[16:09:27.503]  - use_args: TRUE
[16:09:27.503]  - Getting '...' globals ...
[16:09:27.503] resolve() on list ...
[16:09:27.503]  recursive: 0
[16:09:27.503]  length: 1
[16:09:27.503]  elements: ‘...’
[16:09:27.503]  length: 0 (resolved future 1)
[16:09:27.503] resolve() on list ... DONE
[16:09:27.503]    - '...' content: [n=0] 
[16:09:27.504] List of 1
[16:09:27.504]  $ ...: list()
[16:09:27.504]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.504]  - attr(*, "where")=List of 1
[16:09:27.504]   ..$ ...:<environment: 0x5633abacfe68> 
[16:09:27.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.504]  - attr(*, "resolved")= logi TRUE
[16:09:27.504]  - attr(*, "total_size")= num NA
[16:09:27.506]  - Getting '...' globals ... DONE
[16:09:27.506] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.506] List of 2
[16:09:27.506]  $ ...future.FUN:function (x)  
[16:09:27.506]  $ ...          : list()
[16:09:27.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.506]  - attr(*, "where")=List of 2
[16:09:27.506]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.506]   ..$ ...          :<environment: 0x5633abacfe68> 
[16:09:27.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.506]  - attr(*, "resolved")= logi FALSE
[16:09:27.506]  - attr(*, "total_size")= num 848
[16:09:27.509] Packages to be attached in all futures: [n=0] 
[16:09:27.509] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.509] future_lapply() ...
[16:09:27.510] Number of chunks: 1
[16:09:27.510] getGlobalsAndPackagesXApply() ...
[16:09:27.510]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.510]  - use_args: TRUE
[16:09:27.510] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.510] List of 2
[16:09:27.510]  $ ...          : list()
[16:09:27.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.510]  $ ...future.FUN:function (x)  
[16:09:27.510]  - attr(*, "where")=List of 2
[16:09:27.510]   ..$ ...          :<environment: 0x5633abacfe68> 
[16:09:27.510]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.510]  - attr(*, "resolved")= logi FALSE
[16:09:27.510]  - attr(*, "total_size")= num NA
[16:09:27.513] Packages to be attached in all futures: [n=0] 
[16:09:27.513] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.514] Number of futures (= number of chunks): 1
[16:09:27.514] Launching 1 futures (chunks) ...
[16:09:27.514] Chunk #1 of 1 ...
[16:09:27.514]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.514]  - seeds: <none>
[16:09:27.514] getGlobalsAndPackages() ...
[16:09:27.514] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.514] Resolving globals: FALSE
[16:09:27.514] Tweak future expression to call with '...' arguments ...
[16:09:27.515] {
[16:09:27.515]     do.call(function(...) {
[16:09:27.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.515]             on.exit(options(oopts), add = TRUE)
[16:09:27.515]         }
[16:09:27.515]         {
[16:09:27.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.515]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.515]             })
[16:09:27.515]         }
[16:09:27.515]     }, args = future.call.arguments)
[16:09:27.515] }
[16:09:27.515] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.515] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.515] 
[16:09:27.515] getGlobalsAndPackages() ... DONE
[16:09:27.516] run() for ‘Future’ ...
[16:09:27.516] - state: ‘created’
[16:09:27.516] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.516] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.516] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.516]   - Field: ‘label’
[16:09:27.516]   - Field: ‘local’
[16:09:27.517]   - Field: ‘owner’
[16:09:27.517]   - Field: ‘envir’
[16:09:27.517]   - Field: ‘packages’
[16:09:27.517]   - Field: ‘gc’
[16:09:27.517]   - Field: ‘conditions’
[16:09:27.517]   - Field: ‘expr’
[16:09:27.517]   - Field: ‘uuid’
[16:09:27.517]   - Field: ‘seed’
[16:09:27.517]   - Field: ‘version’
[16:09:27.517]   - Field: ‘result’
[16:09:27.517]   - Field: ‘asynchronous’
[16:09:27.518]   - Field: ‘calls’
[16:09:27.518]   - Field: ‘globals’
[16:09:27.518]   - Field: ‘stdout’
[16:09:27.518]   - Field: ‘earlySignal’
[16:09:27.518]   - Field: ‘lazy’
[16:09:27.518]   - Field: ‘state’
[16:09:27.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.518] - Launch lazy future ...
[16:09:27.518] Packages needed by the future expression (n = 0): <none>
[16:09:27.518] Packages needed by future strategies (n = 0): <none>
[16:09:27.519] {
[16:09:27.519]     {
[16:09:27.519]         {
[16:09:27.519]             ...future.startTime <- base::Sys.time()
[16:09:27.519]             {
[16:09:27.519]                 {
[16:09:27.519]                   {
[16:09:27.519]                     base::local({
[16:09:27.519]                       has_future <- base::requireNamespace("future", 
[16:09:27.519]                         quietly = TRUE)
[16:09:27.519]                       if (has_future) {
[16:09:27.519]                         ns <- base::getNamespace("future")
[16:09:27.519]                         version <- ns[[".package"]][["version"]]
[16:09:27.519]                         if (is.null(version)) 
[16:09:27.519]                           version <- utils::packageVersion("future")
[16:09:27.519]                       }
[16:09:27.519]                       else {
[16:09:27.519]                         version <- NULL
[16:09:27.519]                       }
[16:09:27.519]                       if (!has_future || version < "1.8.0") {
[16:09:27.519]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.519]                           "", base::R.version$version.string), 
[16:09:27.519]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.519]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.519]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.519]                             "release", "version")], collapse = " "), 
[16:09:27.519]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.519]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.519]                           info)
[16:09:27.519]                         info <- base::paste(info, collapse = "; ")
[16:09:27.519]                         if (!has_future) {
[16:09:27.519]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.519]                             info)
[16:09:27.519]                         }
[16:09:27.519]                         else {
[16:09:27.519]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.519]                             info, version)
[16:09:27.519]                         }
[16:09:27.519]                         base::stop(msg)
[16:09:27.519]                       }
[16:09:27.519]                     })
[16:09:27.519]                   }
[16:09:27.519]                   options(future.plan = NULL)
[16:09:27.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.519]                 }
[16:09:27.519]                 ...future.workdir <- getwd()
[16:09:27.519]             }
[16:09:27.519]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.519]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.519]         }
[16:09:27.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.519]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.519]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.519]             base::names(...future.oldOptions))
[16:09:27.519]     }
[16:09:27.519]     if (FALSE) {
[16:09:27.519]     }
[16:09:27.519]     else {
[16:09:27.519]         if (TRUE) {
[16:09:27.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.519]                 open = "w")
[16:09:27.519]         }
[16:09:27.519]         else {
[16:09:27.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.519]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.519]         }
[16:09:27.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.519]             base::sink(type = "output", split = FALSE)
[16:09:27.519]             base::close(...future.stdout)
[16:09:27.519]         }, add = TRUE)
[16:09:27.519]     }
[16:09:27.519]     ...future.frame <- base::sys.nframe()
[16:09:27.519]     ...future.conditions <- base::list()
[16:09:27.519]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.519]     if (FALSE) {
[16:09:27.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.519]     }
[16:09:27.519]     ...future.result <- base::tryCatch({
[16:09:27.519]         base::withCallingHandlers({
[16:09:27.519]             ...future.value <- base::withVisible(base::local({
[16:09:27.519]                 do.call(function(...) {
[16:09:27.519]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.519]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.519]                     ...future.globals.maxSize)) {
[16:09:27.519]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.519]                     on.exit(options(oopts), add = TRUE)
[16:09:27.519]                   }
[16:09:27.519]                   {
[16:09:27.519]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.519]                       FUN = function(jj) {
[16:09:27.519]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.519]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.519]                       })
[16:09:27.519]                   }
[16:09:27.519]                 }, args = future.call.arguments)
[16:09:27.519]             }))
[16:09:27.519]             future::FutureResult(value = ...future.value$value, 
[16:09:27.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.519]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.519]                     ...future.globalenv.names))
[16:09:27.519]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.519]         }, condition = base::local({
[16:09:27.519]             c <- base::c
[16:09:27.519]             inherits <- base::inherits
[16:09:27.519]             invokeRestart <- base::invokeRestart
[16:09:27.519]             length <- base::length
[16:09:27.519]             list <- base::list
[16:09:27.519]             seq.int <- base::seq.int
[16:09:27.519]             signalCondition <- base::signalCondition
[16:09:27.519]             sys.calls <- base::sys.calls
[16:09:27.519]             `[[` <- base::`[[`
[16:09:27.519]             `+` <- base::`+`
[16:09:27.519]             `<<-` <- base::`<<-`
[16:09:27.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.519]                   3L)]
[16:09:27.519]             }
[16:09:27.519]             function(cond) {
[16:09:27.519]                 is_error <- inherits(cond, "error")
[16:09:27.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.519]                   NULL)
[16:09:27.519]                 if (is_error) {
[16:09:27.519]                   sessionInformation <- function() {
[16:09:27.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.519]                       search = base::search(), system = base::Sys.info())
[16:09:27.519]                   }
[16:09:27.519]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.519]                     cond$call), session = sessionInformation(), 
[16:09:27.519]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.519]                   signalCondition(cond)
[16:09:27.519]                 }
[16:09:27.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.519]                 "immediateCondition"))) {
[16:09:27.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.519]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.519]                   if (TRUE && !signal) {
[16:09:27.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.519]                     {
[16:09:27.519]                       inherits <- base::inherits
[16:09:27.519]                       invokeRestart <- base::invokeRestart
[16:09:27.519]                       is.null <- base::is.null
[16:09:27.519]                       muffled <- FALSE
[16:09:27.519]                       if (inherits(cond, "message")) {
[16:09:27.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.519]                         if (muffled) 
[16:09:27.519]                           invokeRestart("muffleMessage")
[16:09:27.519]                       }
[16:09:27.519]                       else if (inherits(cond, "warning")) {
[16:09:27.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.519]                         if (muffled) 
[16:09:27.519]                           invokeRestart("muffleWarning")
[16:09:27.519]                       }
[16:09:27.519]                       else if (inherits(cond, "condition")) {
[16:09:27.519]                         if (!is.null(pattern)) {
[16:09:27.519]                           computeRestarts <- base::computeRestarts
[16:09:27.519]                           grepl <- base::grepl
[16:09:27.519]                           restarts <- computeRestarts(cond)
[16:09:27.519]                           for (restart in restarts) {
[16:09:27.519]                             name <- restart$name
[16:09:27.519]                             if (is.null(name)) 
[16:09:27.519]                               next
[16:09:27.519]                             if (!grepl(pattern, name)) 
[16:09:27.519]                               next
[16:09:27.519]                             invokeRestart(restart)
[16:09:27.519]                             muffled <- TRUE
[16:09:27.519]                             break
[16:09:27.519]                           }
[16:09:27.519]                         }
[16:09:27.519]                       }
[16:09:27.519]                       invisible(muffled)
[16:09:27.519]                     }
[16:09:27.519]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.519]                   }
[16:09:27.519]                 }
[16:09:27.519]                 else {
[16:09:27.519]                   if (TRUE) {
[16:09:27.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.519]                     {
[16:09:27.519]                       inherits <- base::inherits
[16:09:27.519]                       invokeRestart <- base::invokeRestart
[16:09:27.519]                       is.null <- base::is.null
[16:09:27.519]                       muffled <- FALSE
[16:09:27.519]                       if (inherits(cond, "message")) {
[16:09:27.519]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.519]                         if (muffled) 
[16:09:27.519]                           invokeRestart("muffleMessage")
[16:09:27.519]                       }
[16:09:27.519]                       else if (inherits(cond, "warning")) {
[16:09:27.519]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.519]                         if (muffled) 
[16:09:27.519]                           invokeRestart("muffleWarning")
[16:09:27.519]                       }
[16:09:27.519]                       else if (inherits(cond, "condition")) {
[16:09:27.519]                         if (!is.null(pattern)) {
[16:09:27.519]                           computeRestarts <- base::computeRestarts
[16:09:27.519]                           grepl <- base::grepl
[16:09:27.519]                           restarts <- computeRestarts(cond)
[16:09:27.519]                           for (restart in restarts) {
[16:09:27.519]                             name <- restart$name
[16:09:27.519]                             if (is.null(name)) 
[16:09:27.519]                               next
[16:09:27.519]                             if (!grepl(pattern, name)) 
[16:09:27.519]                               next
[16:09:27.519]                             invokeRestart(restart)
[16:09:27.519]                             muffled <- TRUE
[16:09:27.519]                             break
[16:09:27.519]                           }
[16:09:27.519]                         }
[16:09:27.519]                       }
[16:09:27.519]                       invisible(muffled)
[16:09:27.519]                     }
[16:09:27.519]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.519]                   }
[16:09:27.519]                 }
[16:09:27.519]             }
[16:09:27.519]         }))
[16:09:27.519]     }, error = function(ex) {
[16:09:27.519]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.519]                 ...future.rng), started = ...future.startTime, 
[16:09:27.519]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.519]             version = "1.8"), class = "FutureResult")
[16:09:27.519]     }, finally = {
[16:09:27.519]         if (!identical(...future.workdir, getwd())) 
[16:09:27.519]             setwd(...future.workdir)
[16:09:27.519]         {
[16:09:27.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.519]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.519]             }
[16:09:27.519]             base::options(...future.oldOptions)
[16:09:27.519]             if (.Platform$OS.type == "windows") {
[16:09:27.519]                 old_names <- names(...future.oldEnvVars)
[16:09:27.519]                 envs <- base::Sys.getenv()
[16:09:27.519]                 names <- names(envs)
[16:09:27.519]                 common <- intersect(names, old_names)
[16:09:27.519]                 added <- setdiff(names, old_names)
[16:09:27.519]                 removed <- setdiff(old_names, names)
[16:09:27.519]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.519]                   envs[common]]
[16:09:27.519]                 NAMES <- toupper(changed)
[16:09:27.519]                 args <- list()
[16:09:27.519]                 for (kk in seq_along(NAMES)) {
[16:09:27.519]                   name <- changed[[kk]]
[16:09:27.519]                   NAME <- NAMES[[kk]]
[16:09:27.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.519]                     next
[16:09:27.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.519]                 }
[16:09:27.519]                 NAMES <- toupper(added)
[16:09:27.519]                 for (kk in seq_along(NAMES)) {
[16:09:27.519]                   name <- added[[kk]]
[16:09:27.519]                   NAME <- NAMES[[kk]]
[16:09:27.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.519]                     next
[16:09:27.519]                   args[[name]] <- ""
[16:09:27.519]                 }
[16:09:27.519]                 NAMES <- toupper(removed)
[16:09:27.519]                 for (kk in seq_along(NAMES)) {
[16:09:27.519]                   name <- removed[[kk]]
[16:09:27.519]                   NAME <- NAMES[[kk]]
[16:09:27.519]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.519]                     next
[16:09:27.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.519]                 }
[16:09:27.519]                 if (length(args) > 0) 
[16:09:27.519]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.519]             }
[16:09:27.519]             else {
[16:09:27.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.519]             }
[16:09:27.519]             {
[16:09:27.519]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.519]                   0L) {
[16:09:27.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.519]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.519]                   base::options(opts)
[16:09:27.519]                 }
[16:09:27.519]                 {
[16:09:27.519]                   {
[16:09:27.519]                     NULL
[16:09:27.519]                     RNGkind("Mersenne-Twister")
[16:09:27.519]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.519]                       inherits = FALSE)
[16:09:27.519]                   }
[16:09:27.519]                   options(future.plan = NULL)
[16:09:27.519]                   if (is.na(NA_character_)) 
[16:09:27.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.519]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.519]                   {
[16:09:27.519]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.519]                     if (!future$lazy) 
[16:09:27.519]                       future <- run(future)
[16:09:27.519]                     invisible(future)
[16:09:27.519]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.519]                 }
[16:09:27.519]             }
[16:09:27.519]         }
[16:09:27.519]     })
[16:09:27.519]     if (TRUE) {
[16:09:27.519]         base::sink(type = "output", split = FALSE)
[16:09:27.519]         if (TRUE) {
[16:09:27.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.519]         }
[16:09:27.519]         else {
[16:09:27.519]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.519]         }
[16:09:27.519]         base::close(...future.stdout)
[16:09:27.519]         ...future.stdout <- NULL
[16:09:27.519]     }
[16:09:27.519]     ...future.result$conditions <- ...future.conditions
[16:09:27.519]     ...future.result$finished <- base::Sys.time()
[16:09:27.519]     ...future.result
[16:09:27.519] }
[16:09:27.521] assign_globals() ...
[16:09:27.521] List of 5
[16:09:27.521]  $ future.call.arguments    : list()
[16:09:27.521]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.521]  $ ...future.FUN            :function (x)  
[16:09:27.521]  $ ...future.elements_ii    :List of 2
[16:09:27.521]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:09:27.521]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:09:27.521]  $ ...future.seeds_ii       : NULL
[16:09:27.521]  $ ...future.globals.maxSize: num Inf
[16:09:27.521]  - attr(*, "resolved")= logi FALSE
[16:09:27.521]  - attr(*, "total_size")= num NA
[16:09:27.521]  - attr(*, "where")=List of 5
[16:09:27.521]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.521]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.521]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.521]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.521]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.521]  - attr(*, "already-done")= logi TRUE
[16:09:27.527] - copied ‘future.call.arguments’ to environment
[16:09:27.527] - copied ‘...future.FUN’ to environment
[16:09:27.527] - copied ‘...future.elements_ii’ to environment
[16:09:27.527] - copied ‘...future.seeds_ii’ to environment
[16:09:27.527] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.528] assign_globals() ... done
[16:09:27.528] plan(): Setting new future strategy stack:
[16:09:27.528] List of future strategies:
[16:09:27.528] 1. sequential:
[16:09:27.528]    - args: function (..., envir = parent.frame())
[16:09:27.528]    - tweaked: FALSE
[16:09:27.528]    - call: NULL
[16:09:27.528] plan(): nbrOfWorkers() = 1
[16:09:27.529] plan(): Setting new future strategy stack:
[16:09:27.529] List of future strategies:
[16:09:27.529] 1. sequential:
[16:09:27.529]    - args: function (..., envir = parent.frame())
[16:09:27.529]    - tweaked: FALSE
[16:09:27.529]    - call: plan(strategy)
[16:09:27.529] plan(): nbrOfWorkers() = 1
[16:09:27.530] SequentialFuture started (and completed)
[16:09:27.530] - Launch lazy future ... done
[16:09:27.530] run() for ‘SequentialFuture’ ... done
[16:09:27.530] Created future:
[16:09:27.530] SequentialFuture:
[16:09:27.530] Label: ‘future_apply-1’
[16:09:27.530] Expression:
[16:09:27.530] {
[16:09:27.530]     do.call(function(...) {
[16:09:27.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.530]             on.exit(options(oopts), add = TRUE)
[16:09:27.530]         }
[16:09:27.530]         {
[16:09:27.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.530]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.530]             })
[16:09:27.530]         }
[16:09:27.530]     }, args = future.call.arguments)
[16:09:27.530] }
[16:09:27.530] Lazy evaluation: FALSE
[16:09:27.530] Asynchronous evaluation: FALSE
[16:09:27.530] Local evaluation: TRUE
[16:09:27.530] Environment: R_GlobalEnv
[16:09:27.530] Capture standard output: TRUE
[16:09:27.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.530] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.530] Packages: <none>
[16:09:27.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.530] Resolved: TRUE
[16:09:27.530] Value: 496 bytes of class ‘list’
[16:09:27.530] Early signaling: FALSE
[16:09:27.530] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.530] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.531] Chunk #1 of 1 ... DONE
[16:09:27.531] Launching 1 futures (chunks) ... DONE
[16:09:27.531] Resolving 1 futures (chunks) ...
[16:09:27.531] resolve() on list ...
[16:09:27.531]  recursive: 0
[16:09:27.532]  length: 1
[16:09:27.532] 
[16:09:27.532] resolved() for ‘SequentialFuture’ ...
[16:09:27.532] - state: ‘finished’
[16:09:27.532] - run: TRUE
[16:09:27.532] - result: ‘FutureResult’
[16:09:27.532] resolved() for ‘SequentialFuture’ ... done
[16:09:27.532] Future #1
[16:09:27.532] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.533] - nx: 1
[16:09:27.533] - relay: TRUE
[16:09:27.533] - stdout: TRUE
[16:09:27.533] - signal: TRUE
[16:09:27.533] - resignal: FALSE
[16:09:27.533] - force: TRUE
[16:09:27.533] - relayed: [n=1] FALSE
[16:09:27.533] - queued futures: [n=1] FALSE
[16:09:27.533]  - until=1
[16:09:27.533]  - relaying element #1
[16:09:27.533] - relayed: [n=1] TRUE
[16:09:27.534] - queued futures: [n=1] TRUE
[16:09:27.534] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.534]  length: 0 (resolved future 1)
[16:09:27.534] Relaying remaining futures
[16:09:27.534] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.534] - nx: 1
[16:09:27.534] - relay: TRUE
[16:09:27.534] - stdout: TRUE
[16:09:27.534] - signal: TRUE
[16:09:27.534] - resignal: FALSE
[16:09:27.534] - force: TRUE
[16:09:27.535] - relayed: [n=1] TRUE
[16:09:27.535] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.535] - relayed: [n=1] TRUE
[16:09:27.535] - queued futures: [n=1] TRUE
[16:09:27.535] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.535] resolve() on list ... DONE
[16:09:27.535]  - Number of value chunks collected: 1
[16:09:27.535] Resolving 1 futures (chunks) ... DONE
[16:09:27.535] Reducing values from 1 chunks ...
[16:09:27.535]  - Number of values collected after concatenation: 2
[16:09:27.535]  - Number of values expected: 2
[16:09:27.536] Reducing values from 1 chunks ... DONE
[16:09:27.536] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:09:27.536] getGlobalsAndPackagesXApply() ...
[16:09:27.536]  - future.globals: TRUE
[16:09:27.536] getGlobalsAndPackages() ...
[16:09:27.536] Searching for globals...
[16:09:27.539] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:09:27.539] Searching for globals ... DONE
[16:09:27.539] Resolving globals: FALSE
[16:09:27.539] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:09:27.540] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:09:27.540] - globals: [1] ‘FUN’
[16:09:27.540] 
[16:09:27.540] getGlobalsAndPackages() ... DONE
[16:09:27.540]  - globals found/used: [n=1] ‘FUN’
[16:09:27.540]  - needed namespaces: [n=0] 
[16:09:27.540] Finding globals ... DONE
[16:09:27.541]  - use_args: TRUE
[16:09:27.541]  - Getting '...' globals ...
[16:09:27.541] resolve() on list ...
[16:09:27.541]  recursive: 0
[16:09:27.541]  length: 1
[16:09:27.541]  elements: ‘...’
[16:09:27.541]  length: 0 (resolved future 1)
[16:09:27.541] resolve() on list ... DONE
[16:09:27.541]    - '...' content: [n=0] 
[16:09:27.542] List of 1
[16:09:27.542]  $ ...: list()
[16:09:27.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.542]  - attr(*, "where")=List of 1
[16:09:27.542]   ..$ ...:<environment: 0x5633ac242108> 
[16:09:27.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.542]  - attr(*, "resolved")= logi TRUE
[16:09:27.542]  - attr(*, "total_size")= num NA
[16:09:27.545]  - Getting '...' globals ... DONE
[16:09:27.545] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.546] List of 2
[16:09:27.546]  $ ...future.FUN:function (x)  
[16:09:27.546]  $ ...          : list()
[16:09:27.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.546]  - attr(*, "where")=List of 2
[16:09:27.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.546]   ..$ ...          :<environment: 0x5633ac242108> 
[16:09:27.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.546]  - attr(*, "resolved")= logi FALSE
[16:09:27.546]  - attr(*, "total_size")= num 9888
[16:09:27.548] Packages to be attached in all futures: [n=0] 
[16:09:27.548] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.549] future_lapply() ...
[16:09:27.550] Number of chunks: 1
[16:09:27.550] getGlobalsAndPackagesXApply() ...
[16:09:27.550]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.550]  - use_args: TRUE
[16:09:27.550] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.551] List of 2
[16:09:27.551]  $ ...          : list()
[16:09:27.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.551]  $ ...future.FUN:function (x)  
[16:09:27.551]  - attr(*, "where")=List of 2
[16:09:27.551]   ..$ ...          :<environment: 0x5633ac242108> 
[16:09:27.551]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:09:27.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.551]  - attr(*, "resolved")= logi FALSE
[16:09:27.551]  - attr(*, "total_size")= num NA
[16:09:27.553] Packages to be attached in all futures: [n=0] 
[16:09:27.553] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.554] Number of futures (= number of chunks): 1
[16:09:27.554] Launching 1 futures (chunks) ...
[16:09:27.554] Chunk #1 of 1 ...
[16:09:27.554]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.554]  - seeds: <none>
[16:09:27.554] getGlobalsAndPackages() ...
[16:09:27.554] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.554] Resolving globals: FALSE
[16:09:27.554] Tweak future expression to call with '...' arguments ...
[16:09:27.555] {
[16:09:27.555]     do.call(function(...) {
[16:09:27.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.555]             on.exit(options(oopts), add = TRUE)
[16:09:27.555]         }
[16:09:27.555]         {
[16:09:27.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.555]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.555]             })
[16:09:27.555]         }
[16:09:27.555]     }, args = future.call.arguments)
[16:09:27.555] }
[16:09:27.555] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.555] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.555] 
[16:09:27.555] getGlobalsAndPackages() ... DONE
[16:09:27.556] run() for ‘Future’ ...
[16:09:27.556] - state: ‘created’
[16:09:27.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.556] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.556]   - Field: ‘label’
[16:09:27.556]   - Field: ‘local’
[16:09:27.557]   - Field: ‘owner’
[16:09:27.557]   - Field: ‘envir’
[16:09:27.557]   - Field: ‘packages’
[16:09:27.557]   - Field: ‘gc’
[16:09:27.557]   - Field: ‘conditions’
[16:09:27.557]   - Field: ‘expr’
[16:09:27.557]   - Field: ‘uuid’
[16:09:27.557]   - Field: ‘seed’
[16:09:27.557]   - Field: ‘version’
[16:09:27.557]   - Field: ‘result’
[16:09:27.557]   - Field: ‘asynchronous’
[16:09:27.558]   - Field: ‘calls’
[16:09:27.558]   - Field: ‘globals’
[16:09:27.558]   - Field: ‘stdout’
[16:09:27.558]   - Field: ‘earlySignal’
[16:09:27.558]   - Field: ‘lazy’
[16:09:27.558]   - Field: ‘state’
[16:09:27.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.558] - Launch lazy future ...
[16:09:27.558] Packages needed by the future expression (n = 0): <none>
[16:09:27.558] Packages needed by future strategies (n = 0): <none>
[16:09:27.559] {
[16:09:27.559]     {
[16:09:27.559]         {
[16:09:27.559]             ...future.startTime <- base::Sys.time()
[16:09:27.559]             {
[16:09:27.559]                 {
[16:09:27.559]                   {
[16:09:27.559]                     base::local({
[16:09:27.559]                       has_future <- base::requireNamespace("future", 
[16:09:27.559]                         quietly = TRUE)
[16:09:27.559]                       if (has_future) {
[16:09:27.559]                         ns <- base::getNamespace("future")
[16:09:27.559]                         version <- ns[[".package"]][["version"]]
[16:09:27.559]                         if (is.null(version)) 
[16:09:27.559]                           version <- utils::packageVersion("future")
[16:09:27.559]                       }
[16:09:27.559]                       else {
[16:09:27.559]                         version <- NULL
[16:09:27.559]                       }
[16:09:27.559]                       if (!has_future || version < "1.8.0") {
[16:09:27.559]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.559]                           "", base::R.version$version.string), 
[16:09:27.559]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.559]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.559]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.559]                             "release", "version")], collapse = " "), 
[16:09:27.559]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.559]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.559]                           info)
[16:09:27.559]                         info <- base::paste(info, collapse = "; ")
[16:09:27.559]                         if (!has_future) {
[16:09:27.559]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.559]                             info)
[16:09:27.559]                         }
[16:09:27.559]                         else {
[16:09:27.559]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.559]                             info, version)
[16:09:27.559]                         }
[16:09:27.559]                         base::stop(msg)
[16:09:27.559]                       }
[16:09:27.559]                     })
[16:09:27.559]                   }
[16:09:27.559]                   options(future.plan = NULL)
[16:09:27.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.559]                 }
[16:09:27.559]                 ...future.workdir <- getwd()
[16:09:27.559]             }
[16:09:27.559]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.559]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.559]         }
[16:09:27.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.559]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.559]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.559]             base::names(...future.oldOptions))
[16:09:27.559]     }
[16:09:27.559]     if (FALSE) {
[16:09:27.559]     }
[16:09:27.559]     else {
[16:09:27.559]         if (TRUE) {
[16:09:27.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.559]                 open = "w")
[16:09:27.559]         }
[16:09:27.559]         else {
[16:09:27.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.559]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.559]         }
[16:09:27.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.559]             base::sink(type = "output", split = FALSE)
[16:09:27.559]             base::close(...future.stdout)
[16:09:27.559]         }, add = TRUE)
[16:09:27.559]     }
[16:09:27.559]     ...future.frame <- base::sys.nframe()
[16:09:27.559]     ...future.conditions <- base::list()
[16:09:27.559]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.559]     if (FALSE) {
[16:09:27.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.559]     }
[16:09:27.559]     ...future.result <- base::tryCatch({
[16:09:27.559]         base::withCallingHandlers({
[16:09:27.559]             ...future.value <- base::withVisible(base::local({
[16:09:27.559]                 do.call(function(...) {
[16:09:27.559]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.559]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.559]                     ...future.globals.maxSize)) {
[16:09:27.559]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.559]                     on.exit(options(oopts), add = TRUE)
[16:09:27.559]                   }
[16:09:27.559]                   {
[16:09:27.559]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.559]                       FUN = function(jj) {
[16:09:27.559]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.559]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.559]                       })
[16:09:27.559]                   }
[16:09:27.559]                 }, args = future.call.arguments)
[16:09:27.559]             }))
[16:09:27.559]             future::FutureResult(value = ...future.value$value, 
[16:09:27.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.559]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.559]                     ...future.globalenv.names))
[16:09:27.559]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.559]         }, condition = base::local({
[16:09:27.559]             c <- base::c
[16:09:27.559]             inherits <- base::inherits
[16:09:27.559]             invokeRestart <- base::invokeRestart
[16:09:27.559]             length <- base::length
[16:09:27.559]             list <- base::list
[16:09:27.559]             seq.int <- base::seq.int
[16:09:27.559]             signalCondition <- base::signalCondition
[16:09:27.559]             sys.calls <- base::sys.calls
[16:09:27.559]             `[[` <- base::`[[`
[16:09:27.559]             `+` <- base::`+`
[16:09:27.559]             `<<-` <- base::`<<-`
[16:09:27.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.559]                   3L)]
[16:09:27.559]             }
[16:09:27.559]             function(cond) {
[16:09:27.559]                 is_error <- inherits(cond, "error")
[16:09:27.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.559]                   NULL)
[16:09:27.559]                 if (is_error) {
[16:09:27.559]                   sessionInformation <- function() {
[16:09:27.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.559]                       search = base::search(), system = base::Sys.info())
[16:09:27.559]                   }
[16:09:27.559]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.559]                     cond$call), session = sessionInformation(), 
[16:09:27.559]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.559]                   signalCondition(cond)
[16:09:27.559]                 }
[16:09:27.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.559]                 "immediateCondition"))) {
[16:09:27.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.559]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.559]                   if (TRUE && !signal) {
[16:09:27.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.559]                     {
[16:09:27.559]                       inherits <- base::inherits
[16:09:27.559]                       invokeRestart <- base::invokeRestart
[16:09:27.559]                       is.null <- base::is.null
[16:09:27.559]                       muffled <- FALSE
[16:09:27.559]                       if (inherits(cond, "message")) {
[16:09:27.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.559]                         if (muffled) 
[16:09:27.559]                           invokeRestart("muffleMessage")
[16:09:27.559]                       }
[16:09:27.559]                       else if (inherits(cond, "warning")) {
[16:09:27.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.559]                         if (muffled) 
[16:09:27.559]                           invokeRestart("muffleWarning")
[16:09:27.559]                       }
[16:09:27.559]                       else if (inherits(cond, "condition")) {
[16:09:27.559]                         if (!is.null(pattern)) {
[16:09:27.559]                           computeRestarts <- base::computeRestarts
[16:09:27.559]                           grepl <- base::grepl
[16:09:27.559]                           restarts <- computeRestarts(cond)
[16:09:27.559]                           for (restart in restarts) {
[16:09:27.559]                             name <- restart$name
[16:09:27.559]                             if (is.null(name)) 
[16:09:27.559]                               next
[16:09:27.559]                             if (!grepl(pattern, name)) 
[16:09:27.559]                               next
[16:09:27.559]                             invokeRestart(restart)
[16:09:27.559]                             muffled <- TRUE
[16:09:27.559]                             break
[16:09:27.559]                           }
[16:09:27.559]                         }
[16:09:27.559]                       }
[16:09:27.559]                       invisible(muffled)
[16:09:27.559]                     }
[16:09:27.559]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.559]                   }
[16:09:27.559]                 }
[16:09:27.559]                 else {
[16:09:27.559]                   if (TRUE) {
[16:09:27.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.559]                     {
[16:09:27.559]                       inherits <- base::inherits
[16:09:27.559]                       invokeRestart <- base::invokeRestart
[16:09:27.559]                       is.null <- base::is.null
[16:09:27.559]                       muffled <- FALSE
[16:09:27.559]                       if (inherits(cond, "message")) {
[16:09:27.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.559]                         if (muffled) 
[16:09:27.559]                           invokeRestart("muffleMessage")
[16:09:27.559]                       }
[16:09:27.559]                       else if (inherits(cond, "warning")) {
[16:09:27.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.559]                         if (muffled) 
[16:09:27.559]                           invokeRestart("muffleWarning")
[16:09:27.559]                       }
[16:09:27.559]                       else if (inherits(cond, "condition")) {
[16:09:27.559]                         if (!is.null(pattern)) {
[16:09:27.559]                           computeRestarts <- base::computeRestarts
[16:09:27.559]                           grepl <- base::grepl
[16:09:27.559]                           restarts <- computeRestarts(cond)
[16:09:27.559]                           for (restart in restarts) {
[16:09:27.559]                             name <- restart$name
[16:09:27.559]                             if (is.null(name)) 
[16:09:27.559]                               next
[16:09:27.559]                             if (!grepl(pattern, name)) 
[16:09:27.559]                               next
[16:09:27.559]                             invokeRestart(restart)
[16:09:27.559]                             muffled <- TRUE
[16:09:27.559]                             break
[16:09:27.559]                           }
[16:09:27.559]                         }
[16:09:27.559]                       }
[16:09:27.559]                       invisible(muffled)
[16:09:27.559]                     }
[16:09:27.559]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.559]                   }
[16:09:27.559]                 }
[16:09:27.559]             }
[16:09:27.559]         }))
[16:09:27.559]     }, error = function(ex) {
[16:09:27.559]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.559]                 ...future.rng), started = ...future.startTime, 
[16:09:27.559]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.559]             version = "1.8"), class = "FutureResult")
[16:09:27.559]     }, finally = {
[16:09:27.559]         if (!identical(...future.workdir, getwd())) 
[16:09:27.559]             setwd(...future.workdir)
[16:09:27.559]         {
[16:09:27.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.559]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.559]             }
[16:09:27.559]             base::options(...future.oldOptions)
[16:09:27.559]             if (.Platform$OS.type == "windows") {
[16:09:27.559]                 old_names <- names(...future.oldEnvVars)
[16:09:27.559]                 envs <- base::Sys.getenv()
[16:09:27.559]                 names <- names(envs)
[16:09:27.559]                 common <- intersect(names, old_names)
[16:09:27.559]                 added <- setdiff(names, old_names)
[16:09:27.559]                 removed <- setdiff(old_names, names)
[16:09:27.559]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.559]                   envs[common]]
[16:09:27.559]                 NAMES <- toupper(changed)
[16:09:27.559]                 args <- list()
[16:09:27.559]                 for (kk in seq_along(NAMES)) {
[16:09:27.559]                   name <- changed[[kk]]
[16:09:27.559]                   NAME <- NAMES[[kk]]
[16:09:27.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.559]                     next
[16:09:27.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.559]                 }
[16:09:27.559]                 NAMES <- toupper(added)
[16:09:27.559]                 for (kk in seq_along(NAMES)) {
[16:09:27.559]                   name <- added[[kk]]
[16:09:27.559]                   NAME <- NAMES[[kk]]
[16:09:27.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.559]                     next
[16:09:27.559]                   args[[name]] <- ""
[16:09:27.559]                 }
[16:09:27.559]                 NAMES <- toupper(removed)
[16:09:27.559]                 for (kk in seq_along(NAMES)) {
[16:09:27.559]                   name <- removed[[kk]]
[16:09:27.559]                   NAME <- NAMES[[kk]]
[16:09:27.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.559]                     next
[16:09:27.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.559]                 }
[16:09:27.559]                 if (length(args) > 0) 
[16:09:27.559]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.559]             }
[16:09:27.559]             else {
[16:09:27.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.559]             }
[16:09:27.559]             {
[16:09:27.559]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.559]                   0L) {
[16:09:27.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.559]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.559]                   base::options(opts)
[16:09:27.559]                 }
[16:09:27.559]                 {
[16:09:27.559]                   {
[16:09:27.559]                     NULL
[16:09:27.559]                     RNGkind("Mersenne-Twister")
[16:09:27.559]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:09:27.559]                       inherits = FALSE)
[16:09:27.559]                   }
[16:09:27.559]                   options(future.plan = NULL)
[16:09:27.559]                   if (is.na(NA_character_)) 
[16:09:27.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.559]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.559]                   {
[16:09:27.559]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.559]                     if (!future$lazy) 
[16:09:27.559]                       future <- run(future)
[16:09:27.559]                     invisible(future)
[16:09:27.559]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.559]                 }
[16:09:27.559]             }
[16:09:27.559]         }
[16:09:27.559]     })
[16:09:27.559]     if (TRUE) {
[16:09:27.559]         base::sink(type = "output", split = FALSE)
[16:09:27.559]         if (TRUE) {
[16:09:27.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.559]         }
[16:09:27.559]         else {
[16:09:27.559]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.559]         }
[16:09:27.559]         base::close(...future.stdout)
[16:09:27.559]         ...future.stdout <- NULL
[16:09:27.559]     }
[16:09:27.559]     ...future.result$conditions <- ...future.conditions
[16:09:27.559]     ...future.result$finished <- base::Sys.time()
[16:09:27.559]     ...future.result
[16:09:27.559] }
[16:09:27.561] assign_globals() ...
[16:09:27.561] List of 5
[16:09:27.561]  $ future.call.arguments    : list()
[16:09:27.561]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.561]  $ ...future.FUN            :function (x)  
[16:09:27.561]  $ ...future.elements_ii    :List of 2
[16:09:27.561]   ..$ : int [1:2] 1 3
[16:09:27.561]   ..$ : int [1:2] 2 4
[16:09:27.561]  $ ...future.seeds_ii       : NULL
[16:09:27.561]  $ ...future.globals.maxSize: num Inf
[16:09:27.561]  - attr(*, "resolved")= logi FALSE
[16:09:27.561]  - attr(*, "total_size")= num NA
[16:09:27.561]  - attr(*, "where")=List of 5
[16:09:27.561]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.561]  - attr(*, "already-done")= logi TRUE
[16:09:27.566] - copied ‘future.call.arguments’ to environment
[16:09:27.566] - reassign environment for ‘...future.FUN’
[16:09:27.566] - copied ‘...future.FUN’ to environment
[16:09:27.566] - copied ‘...future.elements_ii’ to environment
[16:09:27.566] - copied ‘...future.seeds_ii’ to environment
[16:09:27.566] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.566] assign_globals() ... done
[16:09:27.567] plan(): Setting new future strategy stack:
[16:09:27.567] List of future strategies:
[16:09:27.567] 1. sequential:
[16:09:27.567]    - args: function (..., envir = parent.frame())
[16:09:27.567]    - tweaked: FALSE
[16:09:27.567]    - call: NULL
[16:09:27.568] plan(): nbrOfWorkers() = 1
[16:09:27.569] plan(): Setting new future strategy stack:
[16:09:27.569] List of future strategies:
[16:09:27.569] 1. sequential:
[16:09:27.569]    - args: function (..., envir = parent.frame())
[16:09:27.569]    - tweaked: FALSE
[16:09:27.569]    - call: plan(strategy)
[16:09:27.570] plan(): nbrOfWorkers() = 1
[16:09:27.570] SequentialFuture started (and completed)
[16:09:27.570] - Launch lazy future ... done
[16:09:27.570] run() for ‘SequentialFuture’ ... done
[16:09:27.570] Created future:
[16:09:27.570] SequentialFuture:
[16:09:27.570] Label: ‘future_apply-1’
[16:09:27.570] Expression:
[16:09:27.570] {
[16:09:27.570]     do.call(function(...) {
[16:09:27.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.570]             on.exit(options(oopts), add = TRUE)
[16:09:27.570]         }
[16:09:27.570]         {
[16:09:27.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.570]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.570]             })
[16:09:27.570]         }
[16:09:27.570]     }, args = future.call.arguments)
[16:09:27.570] }
[16:09:27.570] Lazy evaluation: FALSE
[16:09:27.570] Asynchronous evaluation: FALSE
[16:09:27.570] Local evaluation: TRUE
[16:09:27.570] Environment: R_GlobalEnv
[16:09:27.570] Capture standard output: TRUE
[16:09:27.570] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.570] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.570] Packages: <none>
[16:09:27.570] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.570] Resolved: TRUE
[16:09:27.570] Value: 400 bytes of class ‘list’
[16:09:27.570] Early signaling: FALSE
[16:09:27.570] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.570] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.571] Chunk #1 of 1 ... DONE
[16:09:27.571] Launching 1 futures (chunks) ... DONE
[16:09:27.571] Resolving 1 futures (chunks) ...
[16:09:27.571] resolve() on list ...
[16:09:27.572]  recursive: 0
[16:09:27.572]  length: 1
[16:09:27.572] 
[16:09:27.572] resolved() for ‘SequentialFuture’ ...
[16:09:27.572] - state: ‘finished’
[16:09:27.572] - run: TRUE
[16:09:27.572] - result: ‘FutureResult’
[16:09:27.572] resolved() for ‘SequentialFuture’ ... done
[16:09:27.572] Future #1
[16:09:27.573] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.573] - nx: 1
[16:09:27.573] - relay: TRUE
[16:09:27.573] - stdout: TRUE
[16:09:27.573] - signal: TRUE
[16:09:27.573] - resignal: FALSE
[16:09:27.573] - force: TRUE
[16:09:27.573] - relayed: [n=1] FALSE
[16:09:27.573] - queued futures: [n=1] FALSE
[16:09:27.573]  - until=1
[16:09:27.573]  - relaying element #1
[16:09:27.574] - relayed: [n=1] TRUE
[16:09:27.574] - queued futures: [n=1] TRUE
[16:09:27.574] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.574]  length: 0 (resolved future 1)
[16:09:27.574] Relaying remaining futures
[16:09:27.574] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.574] - nx: 1
[16:09:27.574] - relay: TRUE
[16:09:27.574] - stdout: TRUE
[16:09:27.574] - signal: TRUE
[16:09:27.575] - resignal: FALSE
[16:09:27.575] - force: TRUE
[16:09:27.575] - relayed: [n=1] TRUE
[16:09:27.575] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.575] - relayed: [n=1] TRUE
[16:09:27.575] - queued futures: [n=1] TRUE
[16:09:27.575] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.575] resolve() on list ... DONE
[16:09:27.575]  - Number of value chunks collected: 1
[16:09:27.575] Resolving 1 futures (chunks) ... DONE
[16:09:27.576] Reducing values from 1 chunks ...
[16:09:27.576]  - Number of values collected after concatenation: 2
[16:09:27.576]  - Number of values expected: 2
[16:09:27.576] Reducing values from 1 chunks ... DONE
[16:09:27.576] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:09:27.576] getGlobalsAndPackagesXApply() ...
[16:09:27.576]  - future.globals: TRUE
[16:09:27.576] getGlobalsAndPackages() ...
[16:09:27.577] Searching for globals...
[16:09:27.579] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:09:27.579] Searching for globals ... DONE
[16:09:27.579] Resolving globals: FALSE
[16:09:27.580] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:09:27.580] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:09:27.581] - globals: [1] ‘FUN’
[16:09:27.581] 
[16:09:27.581] getGlobalsAndPackages() ... DONE
[16:09:27.581]  - globals found/used: [n=1] ‘FUN’
[16:09:27.581]  - needed namespaces: [n=0] 
[16:09:27.581] Finding globals ... DONE
[16:09:27.581]  - use_args: TRUE
[16:09:27.581]  - Getting '...' globals ...
[16:09:27.581] resolve() on list ...
[16:09:27.582]  recursive: 0
[16:09:27.582]  length: 1
[16:09:27.582]  elements: ‘...’
[16:09:27.582]  length: 0 (resolved future 1)
[16:09:27.582] resolve() on list ... DONE
[16:09:27.582]    - '...' content: [n=0] 
[16:09:27.582] List of 1
[16:09:27.582]  $ ...: list()
[16:09:27.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.582]  - attr(*, "where")=List of 1
[16:09:27.582]   ..$ ...:<environment: 0x5633aa311518> 
[16:09:27.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.582]  - attr(*, "resolved")= logi TRUE
[16:09:27.582]  - attr(*, "total_size")= num NA
[16:09:27.584]  - Getting '...' globals ... DONE
[16:09:27.585] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.585] List of 2
[16:09:27.585]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:09:27.585]  $ ...          : list()
[16:09:27.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.585]  - attr(*, "where")=List of 2
[16:09:27.585]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.585]   ..$ ...          :<environment: 0x5633aa311518> 
[16:09:27.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.585]  - attr(*, "resolved")= logi FALSE
[16:09:27.585]  - attr(*, "total_size")= num 36296
[16:09:27.587] Packages to be attached in all futures: [n=0] 
[16:09:27.587] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.588] future_lapply() ...
[16:09:27.591] Generating random seeds ...
[16:09:27.591] Generating random seed streams for 2 elements ...
[16:09:27.591] Generating random seed streams for 2 elements ... DONE
[16:09:27.591] Generating random seeds ... DONE
[16:09:27.591] Will set RNG state on exit: 10407, -1236761944, 1053858011, -1578269260, -1889422913, -719729957, -84025547
[16:09:27.592] Number of chunks: 1
[16:09:27.592] getGlobalsAndPackagesXApply() ...
[16:09:27.592]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.592]  - use_args: TRUE
[16:09:27.592] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.592] List of 2
[16:09:27.592]  $ ...          : list()
[16:09:27.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.592]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:09:27.592]  - attr(*, "where")=List of 2
[16:09:27.592]   ..$ ...          :<environment: 0x5633aa311518> 
[16:09:27.592]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.592]  - attr(*, "resolved")= logi FALSE
[16:09:27.592]  - attr(*, "total_size")= num NA
[16:09:27.595] Packages to be attached in all futures: [n=0] 
[16:09:27.595] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.596] Number of futures (= number of chunks): 1
[16:09:27.596] Launching 1 futures (chunks) ...
[16:09:27.596] Chunk #1 of 1 ...
[16:09:27.596]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:09:27.596]  - seeds: [2] <seeds>
[16:09:27.596] getGlobalsAndPackages() ...
[16:09:27.596] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.596] Resolving globals: FALSE
[16:09:27.597] Tweak future expression to call with '...' arguments ...
[16:09:27.597] {
[16:09:27.597]     do.call(function(...) {
[16:09:27.597]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.597]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.597]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.597]             on.exit(options(oopts), add = TRUE)
[16:09:27.597]         }
[16:09:27.597]         {
[16:09:27.597]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.597]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.597]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:27.597]                   envir = globalenv(), inherits = FALSE)
[16:09:27.597]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.597]             })
[16:09:27.597]         }
[16:09:27.597]     }, args = future.call.arguments)
[16:09:27.597] }
[16:09:27.597] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.597] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.597] 
[16:09:27.597] getGlobalsAndPackages() ... DONE
[16:09:27.598] run() for ‘Future’ ...
[16:09:27.598] - state: ‘created’
[16:09:27.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:09:27.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:09:27.598]   - Field: ‘label’
[16:09:27.599]   - Field: ‘local’
[16:09:27.599]   - Field: ‘owner’
[16:09:27.599]   - Field: ‘envir’
[16:09:27.599]   - Field: ‘packages’
[16:09:27.599]   - Field: ‘gc’
[16:09:27.599]   - Field: ‘conditions’
[16:09:27.599]   - Field: ‘expr’
[16:09:27.599]   - Field: ‘uuid’
[16:09:27.599]   - Field: ‘seed’
[16:09:27.599]   - Field: ‘version’
[16:09:27.599]   - Field: ‘result’
[16:09:27.600]   - Field: ‘asynchronous’
[16:09:27.600]   - Field: ‘calls’
[16:09:27.600]   - Field: ‘globals’
[16:09:27.600]   - Field: ‘stdout’
[16:09:27.600]   - Field: ‘earlySignal’
[16:09:27.600]   - Field: ‘lazy’
[16:09:27.600]   - Field: ‘state’
[16:09:27.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:09:27.600] - Launch lazy future ...
[16:09:27.601] Packages needed by the future expression (n = 0): <none>
[16:09:27.601] Packages needed by future strategies (n = 0): <none>
[16:09:27.601] {
[16:09:27.601]     {
[16:09:27.601]         {
[16:09:27.601]             ...future.startTime <- base::Sys.time()
[16:09:27.601]             {
[16:09:27.601]                 {
[16:09:27.601]                   {
[16:09:27.601]                     base::local({
[16:09:27.601]                       has_future <- base::requireNamespace("future", 
[16:09:27.601]                         quietly = TRUE)
[16:09:27.601]                       if (has_future) {
[16:09:27.601]                         ns <- base::getNamespace("future")
[16:09:27.601]                         version <- ns[[".package"]][["version"]]
[16:09:27.601]                         if (is.null(version)) 
[16:09:27.601]                           version <- utils::packageVersion("future")
[16:09:27.601]                       }
[16:09:27.601]                       else {
[16:09:27.601]                         version <- NULL
[16:09:27.601]                       }
[16:09:27.601]                       if (!has_future || version < "1.8.0") {
[16:09:27.601]                         info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.601]                           "", base::R.version$version.string), 
[16:09:27.601]                           platform = base::sprintf("%s (%s-bit)", 
[16:09:27.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.601]                             "release", "version")], collapse = " "), 
[16:09:27.601]                           hostname = base::Sys.info()[["nodename"]])
[16:09:27.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.601]                           info)
[16:09:27.601]                         info <- base::paste(info, collapse = "; ")
[16:09:27.601]                         if (!has_future) {
[16:09:27.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.601]                             info)
[16:09:27.601]                         }
[16:09:27.601]                         else {
[16:09:27.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.601]                             info, version)
[16:09:27.601]                         }
[16:09:27.601]                         base::stop(msg)
[16:09:27.601]                       }
[16:09:27.601]                     })
[16:09:27.601]                   }
[16:09:27.601]                   options(future.plan = NULL)
[16:09:27.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.601]                 }
[16:09:27.601]                 ...future.workdir <- getwd()
[16:09:27.601]             }
[16:09:27.601]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.601]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.601]         }
[16:09:27.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.601]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.601]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.601]             base::names(...future.oldOptions))
[16:09:27.601]     }
[16:09:27.601]     if (FALSE) {
[16:09:27.601]     }
[16:09:27.601]     else {
[16:09:27.601]         if (TRUE) {
[16:09:27.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.601]                 open = "w")
[16:09:27.601]         }
[16:09:27.601]         else {
[16:09:27.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.601]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.601]         }
[16:09:27.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.601]             base::sink(type = "output", split = FALSE)
[16:09:27.601]             base::close(...future.stdout)
[16:09:27.601]         }, add = TRUE)
[16:09:27.601]     }
[16:09:27.601]     ...future.frame <- base::sys.nframe()
[16:09:27.601]     ...future.conditions <- base::list()
[16:09:27.601]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.601]     if (FALSE) {
[16:09:27.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.601]     }
[16:09:27.601]     ...future.result <- base::tryCatch({
[16:09:27.601]         base::withCallingHandlers({
[16:09:27.601]             ...future.value <- base::withVisible(base::local({
[16:09:27.601]                 do.call(function(...) {
[16:09:27.601]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.601]                   if (!identical(...future.globals.maxSize.org, 
[16:09:27.601]                     ...future.globals.maxSize)) {
[16:09:27.601]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.601]                     on.exit(options(oopts), add = TRUE)
[16:09:27.601]                   }
[16:09:27.601]                   {
[16:09:27.601]                     lapply(seq_along(...future.elements_ii), 
[16:09:27.601]                       FUN = function(jj) {
[16:09:27.601]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.601]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:27.601]                           envir = globalenv(), inherits = FALSE)
[16:09:27.601]                         ...future.FUN(...future.X_jj, ...)
[16:09:27.601]                       })
[16:09:27.601]                   }
[16:09:27.601]                 }, args = future.call.arguments)
[16:09:27.601]             }))
[16:09:27.601]             future::FutureResult(value = ...future.value$value, 
[16:09:27.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.601]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.601]                     ...future.globalenv.names))
[16:09:27.601]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.601]         }, condition = base::local({
[16:09:27.601]             c <- base::c
[16:09:27.601]             inherits <- base::inherits
[16:09:27.601]             invokeRestart <- base::invokeRestart
[16:09:27.601]             length <- base::length
[16:09:27.601]             list <- base::list
[16:09:27.601]             seq.int <- base::seq.int
[16:09:27.601]             signalCondition <- base::signalCondition
[16:09:27.601]             sys.calls <- base::sys.calls
[16:09:27.601]             `[[` <- base::`[[`
[16:09:27.601]             `+` <- base::`+`
[16:09:27.601]             `<<-` <- base::`<<-`
[16:09:27.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.601]                   3L)]
[16:09:27.601]             }
[16:09:27.601]             function(cond) {
[16:09:27.601]                 is_error <- inherits(cond, "error")
[16:09:27.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.601]                   NULL)
[16:09:27.601]                 if (is_error) {
[16:09:27.601]                   sessionInformation <- function() {
[16:09:27.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.601]                       search = base::search(), system = base::Sys.info())
[16:09:27.601]                   }
[16:09:27.601]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.601]                     cond$call), session = sessionInformation(), 
[16:09:27.601]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.601]                   signalCondition(cond)
[16:09:27.601]                 }
[16:09:27.601]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[16:09:27.601]                   signal <- TRUE && inherits(cond, character(0))
[16:09:27.601]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.601]                   if (TRUE && !signal) {
[16:09:27.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.601]                     {
[16:09:27.601]                       inherits <- base::inherits
[16:09:27.601]                       invokeRestart <- base::invokeRestart
[16:09:27.601]                       is.null <- base::is.null
[16:09:27.601]                       muffled <- FALSE
[16:09:27.601]                       if (inherits(cond, "message")) {
[16:09:27.601]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.601]                         if (muffled) 
[16:09:27.601]                           invokeRestart("muffleMessage")
[16:09:27.601]                       }
[16:09:27.601]                       else if (inherits(cond, "warning")) {
[16:09:27.601]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.601]                         if (muffled) 
[16:09:27.601]                           invokeRestart("muffleWarning")
[16:09:27.601]                       }
[16:09:27.601]                       else if (inherits(cond, "condition")) {
[16:09:27.601]                         if (!is.null(pattern)) {
[16:09:27.601]                           computeRestarts <- base::computeRestarts
[16:09:27.601]                           grepl <- base::grepl
[16:09:27.601]                           restarts <- computeRestarts(cond)
[16:09:27.601]                           for (restart in restarts) {
[16:09:27.601]                             name <- restart$name
[16:09:27.601]                             if (is.null(name)) 
[16:09:27.601]                               next
[16:09:27.601]                             if (!grepl(pattern, name)) 
[16:09:27.601]                               next
[16:09:27.601]                             invokeRestart(restart)
[16:09:27.601]                             muffled <- TRUE
[16:09:27.601]                             break
[16:09:27.601]                           }
[16:09:27.601]                         }
[16:09:27.601]                       }
[16:09:27.601]                       invisible(muffled)
[16:09:27.601]                     }
[16:09:27.601]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.601]                   }
[16:09:27.601]                 }
[16:09:27.601]                 else {
[16:09:27.601]                   if (FALSE) {
[16:09:27.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.601]                     {
[16:09:27.601]                       inherits <- base::inherits
[16:09:27.601]                       invokeRestart <- base::invokeRestart
[16:09:27.601]                       is.null <- base::is.null
[16:09:27.601]                       muffled <- FALSE
[16:09:27.601]                       if (inherits(cond, "message")) {
[16:09:27.601]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.601]                         if (muffled) 
[16:09:27.601]                           invokeRestart("muffleMessage")
[16:09:27.601]                       }
[16:09:27.601]                       else if (inherits(cond, "warning")) {
[16:09:27.601]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.601]                         if (muffled) 
[16:09:27.601]                           invokeRestart("muffleWarning")
[16:09:27.601]                       }
[16:09:27.601]                       else if (inherits(cond, "condition")) {
[16:09:27.601]                         if (!is.null(pattern)) {
[16:09:27.601]                           computeRestarts <- base::computeRestarts
[16:09:27.601]                           grepl <- base::grepl
[16:09:27.601]                           restarts <- computeRestarts(cond)
[16:09:27.601]                           for (restart in restarts) {
[16:09:27.601]                             name <- restart$name
[16:09:27.601]                             if (is.null(name)) 
[16:09:27.601]                               next
[16:09:27.601]                             if (!grepl(pattern, name)) 
[16:09:27.601]                               next
[16:09:27.601]                             invokeRestart(restart)
[16:09:27.601]                             muffled <- TRUE
[16:09:27.601]                             break
[16:09:27.601]                           }
[16:09:27.601]                         }
[16:09:27.601]                       }
[16:09:27.601]                       invisible(muffled)
[16:09:27.601]                     }
[16:09:27.601]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.601]                   }
[16:09:27.601]                 }
[16:09:27.601]             }
[16:09:27.601]         }))
[16:09:27.601]     }, error = function(ex) {
[16:09:27.601]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.601]                 ...future.rng), started = ...future.startTime, 
[16:09:27.601]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.601]             version = "1.8"), class = "FutureResult")
[16:09:27.601]     }, finally = {
[16:09:27.601]         if (!identical(...future.workdir, getwd())) 
[16:09:27.601]             setwd(...future.workdir)
[16:09:27.601]         {
[16:09:27.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.601]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.601]             }
[16:09:27.601]             base::options(...future.oldOptions)
[16:09:27.601]             if (.Platform$OS.type == "windows") {
[16:09:27.601]                 old_names <- names(...future.oldEnvVars)
[16:09:27.601]                 envs <- base::Sys.getenv()
[16:09:27.601]                 names <- names(envs)
[16:09:27.601]                 common <- intersect(names, old_names)
[16:09:27.601]                 added <- setdiff(names, old_names)
[16:09:27.601]                 removed <- setdiff(old_names, names)
[16:09:27.601]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.601]                   envs[common]]
[16:09:27.601]                 NAMES <- toupper(changed)
[16:09:27.601]                 args <- list()
[16:09:27.601]                 for (kk in seq_along(NAMES)) {
[16:09:27.601]                   name <- changed[[kk]]
[16:09:27.601]                   NAME <- NAMES[[kk]]
[16:09:27.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.601]                     next
[16:09:27.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.601]                 }
[16:09:27.601]                 NAMES <- toupper(added)
[16:09:27.601]                 for (kk in seq_along(NAMES)) {
[16:09:27.601]                   name <- added[[kk]]
[16:09:27.601]                   NAME <- NAMES[[kk]]
[16:09:27.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.601]                     next
[16:09:27.601]                   args[[name]] <- ""
[16:09:27.601]                 }
[16:09:27.601]                 NAMES <- toupper(removed)
[16:09:27.601]                 for (kk in seq_along(NAMES)) {
[16:09:27.601]                   name <- removed[[kk]]
[16:09:27.601]                   NAME <- NAMES[[kk]]
[16:09:27.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.601]                     next
[16:09:27.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.601]                 }
[16:09:27.601]                 if (length(args) > 0) 
[16:09:27.601]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.601]             }
[16:09:27.601]             else {
[16:09:27.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.601]             }
[16:09:27.601]             {
[16:09:27.601]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.601]                   0L) {
[16:09:27.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.601]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.601]                   base::options(opts)
[16:09:27.601]                 }
[16:09:27.601]                 {
[16:09:27.601]                   {
[16:09:27.601]                     base::assign(".Random.seed", c(10407L, -1236761944L, 
[16:09:27.601]                     1053858011L, -1578269260L, -1889422913L, 
[16:09:27.601]                     -719729957L, -84025547L), envir = base::globalenv(), 
[16:09:27.601]                       inherits = FALSE)
[16:09:27.601]                     NULL
[16:09:27.601]                   }
[16:09:27.601]                   options(future.plan = NULL)
[16:09:27.601]                   if (is.na(NA_character_)) 
[16:09:27.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.601]                   future::plan(list(function (..., envir = parent.frame()) 
[16:09:27.601]                   {
[16:09:27.601]                     future <- SequentialFuture(..., envir = envir)
[16:09:27.601]                     if (!future$lazy) 
[16:09:27.601]                       future <- run(future)
[16:09:27.601]                     invisible(future)
[16:09:27.601]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.601]                 }
[16:09:27.601]             }
[16:09:27.601]         }
[16:09:27.601]     })
[16:09:27.601]     if (TRUE) {
[16:09:27.601]         base::sink(type = "output", split = FALSE)
[16:09:27.601]         if (TRUE) {
[16:09:27.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.601]         }
[16:09:27.601]         else {
[16:09:27.601]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.601]         }
[16:09:27.601]         base::close(...future.stdout)
[16:09:27.601]         ...future.stdout <- NULL
[16:09:27.601]     }
[16:09:27.601]     ...future.result$conditions <- ...future.conditions
[16:09:27.601]     ...future.result$finished <- base::Sys.time()
[16:09:27.601]     ...future.result
[16:09:27.601] }
[16:09:27.603] assign_globals() ...
[16:09:27.603] List of 5
[16:09:27.603]  $ future.call.arguments    : list()
[16:09:27.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.603]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:09:27.603]  $ ...future.elements_ii    :List of 2
[16:09:27.603]   ..$ : int [1:2] 1 3
[16:09:27.603]   ..$ : int [1:2] 2 4
[16:09:27.603]  $ ...future.seeds_ii       :List of 2
[16:09:27.603]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:09:27.603]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:09:27.603]  $ ...future.globals.maxSize: num Inf
[16:09:27.603]  - attr(*, "resolved")= logi FALSE
[16:09:27.603]  - attr(*, "total_size")= num NA
[16:09:27.603]  - attr(*, "where")=List of 5
[16:09:27.603]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.603]  - attr(*, "already-done")= logi TRUE
[16:09:27.608] - copied ‘future.call.arguments’ to environment
[16:09:27.608] - copied ‘...future.FUN’ to environment
[16:09:27.608] - copied ‘...future.elements_ii’ to environment
[16:09:27.609] - copied ‘...future.seeds_ii’ to environment
[16:09:27.609] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.609] assign_globals() ... done
[16:09:27.609] plan(): Setting new future strategy stack:
[16:09:27.609] List of future strategies:
[16:09:27.609] 1. sequential:
[16:09:27.609]    - args: function (..., envir = parent.frame())
[16:09:27.609]    - tweaked: FALSE
[16:09:27.609]    - call: NULL
[16:09:27.609] plan(): nbrOfWorkers() = 1
[16:09:27.610] plan(): Setting new future strategy stack:
[16:09:27.610] List of future strategies:
[16:09:27.610] 1. sequential:
[16:09:27.610]    - args: function (..., envir = parent.frame())
[16:09:27.610]    - tweaked: FALSE
[16:09:27.610]    - call: plan(strategy)
[16:09:27.611] plan(): nbrOfWorkers() = 1
[16:09:27.611] SequentialFuture started (and completed)
[16:09:27.611] - Launch lazy future ... done
[16:09:27.611] run() for ‘SequentialFuture’ ... done
[16:09:27.611] Created future:
[16:09:27.611] SequentialFuture:
[16:09:27.611] Label: ‘future_apply-1’
[16:09:27.611] Expression:
[16:09:27.611] {
[16:09:27.611]     do.call(function(...) {
[16:09:27.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.611]             on.exit(options(oopts), add = TRUE)
[16:09:27.611]         }
[16:09:27.611]         {
[16:09:27.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.611]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:27.611]                   envir = globalenv(), inherits = FALSE)
[16:09:27.611]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.611]             })
[16:09:27.611]         }
[16:09:27.611]     }, args = future.call.arguments)
[16:09:27.611] }
[16:09:27.611] Lazy evaluation: FALSE
[16:09:27.611] Asynchronous evaluation: FALSE
[16:09:27.611] Local evaluation: TRUE
[16:09:27.611] Environment: R_GlobalEnv
[16:09:27.611] Capture standard output: TRUE
[16:09:27.611] Capture condition classes: <none>
[16:09:27.611] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:27.611] Packages: <none>
[16:09:27.611] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:09:27.611] Resolved: TRUE
[16:09:27.611] Value: 112 bytes of class ‘list’
[16:09:27.611] Early signaling: FALSE
[16:09:27.611] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.611] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:09:27.612] Chunk #1 of 1 ... DONE
[16:09:27.612] Launching 1 futures (chunks) ... DONE
[16:09:27.612] Resolving 1 futures (chunks) ...
[16:09:27.612] resolve() on list ...
[16:09:27.613]  recursive: 0
[16:09:27.613]  length: 1
[16:09:27.613] 
[16:09:27.613] resolved() for ‘SequentialFuture’ ...
[16:09:27.614] - state: ‘finished’
[16:09:27.614] - run: TRUE
[16:09:27.614] - result: ‘FutureResult’
[16:09:27.614] resolved() for ‘SequentialFuture’ ... done
[16:09:27.614] Future #1
[16:09:27.615] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:09:27.615] - nx: 1
[16:09:27.615] - relay: TRUE
[16:09:27.615] - stdout: TRUE
[16:09:27.615] - signal: TRUE
[16:09:27.615] - resignal: FALSE
[16:09:27.615] - force: TRUE
[16:09:27.615] - relayed: [n=1] FALSE
[16:09:27.615] - queued futures: [n=1] FALSE
[16:09:27.615]  - until=1
[16:09:27.615]  - relaying element #1
[16:09:27.616] - relayed: [n=1] TRUE
[16:09:27.616] - queued futures: [n=1] TRUE
[16:09:27.616] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:09:27.616]  length: 0 (resolved future 1)
[16:09:27.616] Relaying remaining futures
[16:09:27.616] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.616] - nx: 1
[16:09:27.616] - relay: TRUE
[16:09:27.616] - stdout: TRUE
[16:09:27.616] - signal: TRUE
[16:09:27.616] - resignal: FALSE
[16:09:27.617] - force: TRUE
[16:09:27.617] - relayed: [n=1] TRUE
[16:09:27.617] - queued futures: [n=1] TRUE
 - flush all
[16:09:27.617] - relayed: [n=1] TRUE
[16:09:27.617] - queued futures: [n=1] TRUE
[16:09:27.617] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.617] resolve() on list ... DONE
[16:09:27.617]  - Number of value chunks collected: 1
[16:09:27.617] Resolving 1 futures (chunks) ... DONE
[16:09:27.617] Reducing values from 1 chunks ...
[16:09:27.618]  - Number of values collected after concatenation: 2
[16:09:27.618]  - Number of values expected: 2
[16:09:27.618] Reducing values from 1 chunks ... DONE
[16:09:27.618] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:09:27.618] plan(): Setting new future strategy stack:
[16:09:27.618] List of future strategies:
[16:09:27.618] 1. sequential:
[16:09:27.618]    - args: function (..., envir = parent.frame())
[16:09:27.618]    - tweaked: FALSE
[16:09:27.618]    - call: plan(sequential)
[16:09:27.619] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:09:27.619] plan(): Setting new future strategy stack:
[16:09:27.619] List of future strategies:
[16:09:27.619] 1. multicore:
[16:09:27.619]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:27.619]    - tweaked: FALSE
[16:09:27.619]    - call: plan(strategy)
[16:09:27.623] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:09:27.623] getGlobalsAndPackagesXApply() ...
[16:09:27.623]  - future.globals: TRUE
[16:09:27.624] getGlobalsAndPackages() ...
[16:09:27.624] Searching for globals...
[16:09:27.658] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:09:27.658] Searching for globals ... DONE
[16:09:27.658] Resolving globals: FALSE
[16:09:27.660] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:09:27.660] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:09:27.660] - globals: [1] ‘FUN’
[16:09:27.660] 
[16:09:27.661] getGlobalsAndPackages() ... DONE
[16:09:27.661]  - globals found/used: [n=1] ‘FUN’
[16:09:27.661]  - needed namespaces: [n=0] 
[16:09:27.661] Finding globals ... DONE
[16:09:27.661]  - use_args: TRUE
[16:09:27.661]  - Getting '...' globals ...
[16:09:27.661] resolve() on list ...
[16:09:27.661]  recursive: 0
[16:09:27.661]  length: 1
[16:09:27.662]  elements: ‘...’
[16:09:27.662]  length: 0 (resolved future 1)
[16:09:27.662] resolve() on list ... DONE
[16:09:27.662]    - '...' content: [n=0] 
[16:09:27.662] List of 1
[16:09:27.662]  $ ...: list()
[16:09:27.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.662]  - attr(*, "where")=List of 1
[16:09:27.662]   ..$ ...:<environment: 0x5633aa3da080> 
[16:09:27.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.662]  - attr(*, "resolved")= logi TRUE
[16:09:27.662]  - attr(*, "total_size")= num NA
[16:09:27.664]  - Getting '...' globals ... DONE
[16:09:27.665] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.665] List of 2
[16:09:27.665]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.665]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.665]  $ ...          : list()
[16:09:27.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.665]  - attr(*, "where")=List of 2
[16:09:27.665]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.665]   ..$ ...          :<environment: 0x5633aa3da080> 
[16:09:27.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.665]  - attr(*, "resolved")= logi FALSE
[16:09:27.665]  - attr(*, "total_size")= num 354224
[16:09:27.667] Packages to be attached in all futures: [n=0] 
[16:09:27.667] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.671] future_lapply() ...
[16:09:27.706] Number of chunks: 2
[16:09:27.706] getGlobalsAndPackagesXApply() ...
[16:09:27.706]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.707]  - use_args: TRUE
[16:09:27.707] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.707] List of 2
[16:09:27.707]  $ ...          : list()
[16:09:27.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.707]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.707]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.707]  - attr(*, "where")=List of 2
[16:09:27.707]   ..$ ...          :<environment: 0x5633aa3da080> 
[16:09:27.707]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.707]  - attr(*, "resolved")= logi FALSE
[16:09:27.707]  - attr(*, "total_size")= num NA
[16:09:27.710] Packages to be attached in all futures: [n=0] 
[16:09:27.710] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.710] Number of futures (= number of chunks): 2
[16:09:27.711] Launching 2 futures (chunks) ...
[16:09:27.711] Chunk #1 of 2 ...
[16:09:27.711]  - seeds: <none>
[16:09:27.711] getGlobalsAndPackages() ...
[16:09:27.711] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.711] Resolving globals: FALSE
[16:09:27.712] Tweak future expression to call with '...' arguments ...
[16:09:27.712] {
[16:09:27.712]     do.call(function(...) {
[16:09:27.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.712]             on.exit(options(oopts), add = TRUE)
[16:09:27.712]         }
[16:09:27.712]         {
[16:09:27.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.712]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.712]             })
[16:09:27.712]         }
[16:09:27.712]     }, args = future.call.arguments)
[16:09:27.712] }
[16:09:27.713] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.713] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.713] 
[16:09:27.713] getGlobalsAndPackages() ... DONE
[16:09:27.714] run() for ‘Future’ ...
[16:09:27.714] - state: ‘created’
[16:09:27.714] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:27.717] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.718] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:27.718]   - Field: ‘label’
[16:09:27.718]   - Field: ‘local’
[16:09:27.718]   - Field: ‘owner’
[16:09:27.718]   - Field: ‘envir’
[16:09:27.718]   - Field: ‘workers’
[16:09:27.718]   - Field: ‘packages’
[16:09:27.718]   - Field: ‘gc’
[16:09:27.718]   - Field: ‘job’
[16:09:27.719]   - Field: ‘conditions’
[16:09:27.719]   - Field: ‘expr’
[16:09:27.719]   - Field: ‘uuid’
[16:09:27.719]   - Field: ‘seed’
[16:09:27.719]   - Field: ‘version’
[16:09:27.719]   - Field: ‘result’
[16:09:27.719]   - Field: ‘asynchronous’
[16:09:27.719]   - Field: ‘calls’
[16:09:27.719]   - Field: ‘globals’
[16:09:27.719]   - Field: ‘stdout’
[16:09:27.719]   - Field: ‘earlySignal’
[16:09:27.720]   - Field: ‘lazy’
[16:09:27.720]   - Field: ‘state’
[16:09:27.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:27.720] - Launch lazy future ...
[16:09:27.721] Packages needed by the future expression (n = 0): <none>
[16:09:27.721] Packages needed by future strategies (n = 0): <none>
[16:09:27.722] {
[16:09:27.722]     {
[16:09:27.722]         {
[16:09:27.722]             ...future.startTime <- base::Sys.time()
[16:09:27.722]             {
[16:09:27.722]                 {
[16:09:27.722]                   {
[16:09:27.722]                     {
[16:09:27.722]                       base::local({
[16:09:27.722]                         has_future <- base::requireNamespace("future", 
[16:09:27.722]                           quietly = TRUE)
[16:09:27.722]                         if (has_future) {
[16:09:27.722]                           ns <- base::getNamespace("future")
[16:09:27.722]                           version <- ns[[".package"]][["version"]]
[16:09:27.722]                           if (is.null(version)) 
[16:09:27.722]                             version <- utils::packageVersion("future")
[16:09:27.722]                         }
[16:09:27.722]                         else {
[16:09:27.722]                           version <- NULL
[16:09:27.722]                         }
[16:09:27.722]                         if (!has_future || version < "1.8.0") {
[16:09:27.722]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.722]                             "", base::R.version$version.string), 
[16:09:27.722]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:27.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.722]                               "release", "version")], collapse = " "), 
[16:09:27.722]                             hostname = base::Sys.info()[["nodename"]])
[16:09:27.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.722]                             info)
[16:09:27.722]                           info <- base::paste(info, collapse = "; ")
[16:09:27.722]                           if (!has_future) {
[16:09:27.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.722]                               info)
[16:09:27.722]                           }
[16:09:27.722]                           else {
[16:09:27.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.722]                               info, version)
[16:09:27.722]                           }
[16:09:27.722]                           base::stop(msg)
[16:09:27.722]                         }
[16:09:27.722]                       })
[16:09:27.722]                     }
[16:09:27.722]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:27.722]                     base::options(mc.cores = 1L)
[16:09:27.722]                   }
[16:09:27.722]                   options(future.plan = NULL)
[16:09:27.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.722]                 }
[16:09:27.722]                 ...future.workdir <- getwd()
[16:09:27.722]             }
[16:09:27.722]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.722]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.722]         }
[16:09:27.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.722]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.722]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.722]             base::names(...future.oldOptions))
[16:09:27.722]     }
[16:09:27.722]     if (FALSE) {
[16:09:27.722]     }
[16:09:27.722]     else {
[16:09:27.722]         if (TRUE) {
[16:09:27.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.722]                 open = "w")
[16:09:27.722]         }
[16:09:27.722]         else {
[16:09:27.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.722]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.722]         }
[16:09:27.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.722]             base::sink(type = "output", split = FALSE)
[16:09:27.722]             base::close(...future.stdout)
[16:09:27.722]         }, add = TRUE)
[16:09:27.722]     }
[16:09:27.722]     ...future.frame <- base::sys.nframe()
[16:09:27.722]     ...future.conditions <- base::list()
[16:09:27.722]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.722]     if (FALSE) {
[16:09:27.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.722]     }
[16:09:27.722]     ...future.result <- base::tryCatch({
[16:09:27.722]         base::withCallingHandlers({
[16:09:27.722]             ...future.value <- base::withVisible(base::local({
[16:09:27.722]                 withCallingHandlers({
[16:09:27.722]                   {
[16:09:27.722]                     do.call(function(...) {
[16:09:27.722]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.722]                       if (!identical(...future.globals.maxSize.org, 
[16:09:27.722]                         ...future.globals.maxSize)) {
[16:09:27.722]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.722]                         on.exit(options(oopts), add = TRUE)
[16:09:27.722]                       }
[16:09:27.722]                       {
[16:09:27.722]                         lapply(seq_along(...future.elements_ii), 
[16:09:27.722]                           FUN = function(jj) {
[16:09:27.722]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.722]                             ...future.FUN(...future.X_jj, ...)
[16:09:27.722]                           })
[16:09:27.722]                       }
[16:09:27.722]                     }, args = future.call.arguments)
[16:09:27.722]                   }
[16:09:27.722]                 }, immediateCondition = function(cond) {
[16:09:27.722]                   save_rds <- function (object, pathname, ...) 
[16:09:27.722]                   {
[16:09:27.722]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:27.722]                     if (file_test("-f", pathname_tmp)) {
[16:09:27.722]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.722]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:27.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.722]                         fi_tmp[["mtime"]])
[16:09:27.722]                     }
[16:09:27.722]                     tryCatch({
[16:09:27.722]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:27.722]                     }, error = function(ex) {
[16:09:27.722]                       msg <- conditionMessage(ex)
[16:09:27.722]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.722]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:27.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.722]                         fi_tmp[["mtime"]], msg)
[16:09:27.722]                       ex$message <- msg
[16:09:27.722]                       stop(ex)
[16:09:27.722]                     })
[16:09:27.722]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:27.722]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:27.722]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:27.722]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.722]                       fi <- file.info(pathname)
[16:09:27.722]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:27.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.722]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:27.722]                         fi[["size"]], fi[["mtime"]])
[16:09:27.722]                       stop(msg)
[16:09:27.722]                     }
[16:09:27.722]                     invisible(pathname)
[16:09:27.722]                   }
[16:09:27.722]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:27.722]                     rootPath = tempdir()) 
[16:09:27.722]                   {
[16:09:27.722]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:27.722]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:27.722]                       tmpdir = path, fileext = ".rds")
[16:09:27.722]                     save_rds(obj, file)
[16:09:27.722]                   }
[16:09:27.722]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:27.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.722]                   {
[16:09:27.722]                     inherits <- base::inherits
[16:09:27.722]                     invokeRestart <- base::invokeRestart
[16:09:27.722]                     is.null <- base::is.null
[16:09:27.722]                     muffled <- FALSE
[16:09:27.722]                     if (inherits(cond, "message")) {
[16:09:27.722]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:27.722]                       if (muffled) 
[16:09:27.722]                         invokeRestart("muffleMessage")
[16:09:27.722]                     }
[16:09:27.722]                     else if (inherits(cond, "warning")) {
[16:09:27.722]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:27.722]                       if (muffled) 
[16:09:27.722]                         invokeRestart("muffleWarning")
[16:09:27.722]                     }
[16:09:27.722]                     else if (inherits(cond, "condition")) {
[16:09:27.722]                       if (!is.null(pattern)) {
[16:09:27.722]                         computeRestarts <- base::computeRestarts
[16:09:27.722]                         grepl <- base::grepl
[16:09:27.722]                         restarts <- computeRestarts(cond)
[16:09:27.722]                         for (restart in restarts) {
[16:09:27.722]                           name <- restart$name
[16:09:27.722]                           if (is.null(name)) 
[16:09:27.722]                             next
[16:09:27.722]                           if (!grepl(pattern, name)) 
[16:09:27.722]                             next
[16:09:27.722]                           invokeRestart(restart)
[16:09:27.722]                           muffled <- TRUE
[16:09:27.722]                           break
[16:09:27.722]                         }
[16:09:27.722]                       }
[16:09:27.722]                     }
[16:09:27.722]                     invisible(muffled)
[16:09:27.722]                   }
[16:09:27.722]                   muffleCondition(cond)
[16:09:27.722]                 })
[16:09:27.722]             }))
[16:09:27.722]             future::FutureResult(value = ...future.value$value, 
[16:09:27.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.722]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.722]                     ...future.globalenv.names))
[16:09:27.722]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.722]         }, condition = base::local({
[16:09:27.722]             c <- base::c
[16:09:27.722]             inherits <- base::inherits
[16:09:27.722]             invokeRestart <- base::invokeRestart
[16:09:27.722]             length <- base::length
[16:09:27.722]             list <- base::list
[16:09:27.722]             seq.int <- base::seq.int
[16:09:27.722]             signalCondition <- base::signalCondition
[16:09:27.722]             sys.calls <- base::sys.calls
[16:09:27.722]             `[[` <- base::`[[`
[16:09:27.722]             `+` <- base::`+`
[16:09:27.722]             `<<-` <- base::`<<-`
[16:09:27.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.722]                   3L)]
[16:09:27.722]             }
[16:09:27.722]             function(cond) {
[16:09:27.722]                 is_error <- inherits(cond, "error")
[16:09:27.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.722]                   NULL)
[16:09:27.722]                 if (is_error) {
[16:09:27.722]                   sessionInformation <- function() {
[16:09:27.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.722]                       search = base::search(), system = base::Sys.info())
[16:09:27.722]                   }
[16:09:27.722]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.722]                     cond$call), session = sessionInformation(), 
[16:09:27.722]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.722]                   signalCondition(cond)
[16:09:27.722]                 }
[16:09:27.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.722]                 "immediateCondition"))) {
[16:09:27.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.722]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.722]                   if (TRUE && !signal) {
[16:09:27.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.722]                     {
[16:09:27.722]                       inherits <- base::inherits
[16:09:27.722]                       invokeRestart <- base::invokeRestart
[16:09:27.722]                       is.null <- base::is.null
[16:09:27.722]                       muffled <- FALSE
[16:09:27.722]                       if (inherits(cond, "message")) {
[16:09:27.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.722]                         if (muffled) 
[16:09:27.722]                           invokeRestart("muffleMessage")
[16:09:27.722]                       }
[16:09:27.722]                       else if (inherits(cond, "warning")) {
[16:09:27.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.722]                         if (muffled) 
[16:09:27.722]                           invokeRestart("muffleWarning")
[16:09:27.722]                       }
[16:09:27.722]                       else if (inherits(cond, "condition")) {
[16:09:27.722]                         if (!is.null(pattern)) {
[16:09:27.722]                           computeRestarts <- base::computeRestarts
[16:09:27.722]                           grepl <- base::grepl
[16:09:27.722]                           restarts <- computeRestarts(cond)
[16:09:27.722]                           for (restart in restarts) {
[16:09:27.722]                             name <- restart$name
[16:09:27.722]                             if (is.null(name)) 
[16:09:27.722]                               next
[16:09:27.722]                             if (!grepl(pattern, name)) 
[16:09:27.722]                               next
[16:09:27.722]                             invokeRestart(restart)
[16:09:27.722]                             muffled <- TRUE
[16:09:27.722]                             break
[16:09:27.722]                           }
[16:09:27.722]                         }
[16:09:27.722]                       }
[16:09:27.722]                       invisible(muffled)
[16:09:27.722]                     }
[16:09:27.722]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.722]                   }
[16:09:27.722]                 }
[16:09:27.722]                 else {
[16:09:27.722]                   if (TRUE) {
[16:09:27.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.722]                     {
[16:09:27.722]                       inherits <- base::inherits
[16:09:27.722]                       invokeRestart <- base::invokeRestart
[16:09:27.722]                       is.null <- base::is.null
[16:09:27.722]                       muffled <- FALSE
[16:09:27.722]                       if (inherits(cond, "message")) {
[16:09:27.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.722]                         if (muffled) 
[16:09:27.722]                           invokeRestart("muffleMessage")
[16:09:27.722]                       }
[16:09:27.722]                       else if (inherits(cond, "warning")) {
[16:09:27.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.722]                         if (muffled) 
[16:09:27.722]                           invokeRestart("muffleWarning")
[16:09:27.722]                       }
[16:09:27.722]                       else if (inherits(cond, "condition")) {
[16:09:27.722]                         if (!is.null(pattern)) {
[16:09:27.722]                           computeRestarts <- base::computeRestarts
[16:09:27.722]                           grepl <- base::grepl
[16:09:27.722]                           restarts <- computeRestarts(cond)
[16:09:27.722]                           for (restart in restarts) {
[16:09:27.722]                             name <- restart$name
[16:09:27.722]                             if (is.null(name)) 
[16:09:27.722]                               next
[16:09:27.722]                             if (!grepl(pattern, name)) 
[16:09:27.722]                               next
[16:09:27.722]                             invokeRestart(restart)
[16:09:27.722]                             muffled <- TRUE
[16:09:27.722]                             break
[16:09:27.722]                           }
[16:09:27.722]                         }
[16:09:27.722]                       }
[16:09:27.722]                       invisible(muffled)
[16:09:27.722]                     }
[16:09:27.722]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.722]                   }
[16:09:27.722]                 }
[16:09:27.722]             }
[16:09:27.722]         }))
[16:09:27.722]     }, error = function(ex) {
[16:09:27.722]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.722]                 ...future.rng), started = ...future.startTime, 
[16:09:27.722]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.722]             version = "1.8"), class = "FutureResult")
[16:09:27.722]     }, finally = {
[16:09:27.722]         if (!identical(...future.workdir, getwd())) 
[16:09:27.722]             setwd(...future.workdir)
[16:09:27.722]         {
[16:09:27.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.722]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.722]             }
[16:09:27.722]             base::options(...future.oldOptions)
[16:09:27.722]             if (.Platform$OS.type == "windows") {
[16:09:27.722]                 old_names <- names(...future.oldEnvVars)
[16:09:27.722]                 envs <- base::Sys.getenv()
[16:09:27.722]                 names <- names(envs)
[16:09:27.722]                 common <- intersect(names, old_names)
[16:09:27.722]                 added <- setdiff(names, old_names)
[16:09:27.722]                 removed <- setdiff(old_names, names)
[16:09:27.722]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.722]                   envs[common]]
[16:09:27.722]                 NAMES <- toupper(changed)
[16:09:27.722]                 args <- list()
[16:09:27.722]                 for (kk in seq_along(NAMES)) {
[16:09:27.722]                   name <- changed[[kk]]
[16:09:27.722]                   NAME <- NAMES[[kk]]
[16:09:27.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.722]                     next
[16:09:27.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.722]                 }
[16:09:27.722]                 NAMES <- toupper(added)
[16:09:27.722]                 for (kk in seq_along(NAMES)) {
[16:09:27.722]                   name <- added[[kk]]
[16:09:27.722]                   NAME <- NAMES[[kk]]
[16:09:27.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.722]                     next
[16:09:27.722]                   args[[name]] <- ""
[16:09:27.722]                 }
[16:09:27.722]                 NAMES <- toupper(removed)
[16:09:27.722]                 for (kk in seq_along(NAMES)) {
[16:09:27.722]                   name <- removed[[kk]]
[16:09:27.722]                   NAME <- NAMES[[kk]]
[16:09:27.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.722]                     next
[16:09:27.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.722]                 }
[16:09:27.722]                 if (length(args) > 0) 
[16:09:27.722]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.722]             }
[16:09:27.722]             else {
[16:09:27.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.722]             }
[16:09:27.722]             {
[16:09:27.722]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.722]                   0L) {
[16:09:27.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.722]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.722]                   base::options(opts)
[16:09:27.722]                 }
[16:09:27.722]                 {
[16:09:27.722]                   {
[16:09:27.722]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:27.722]                     NULL
[16:09:27.722]                   }
[16:09:27.722]                   options(future.plan = NULL)
[16:09:27.722]                   if (is.na(NA_character_)) 
[16:09:27.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.722]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:27.722]                     envir = parent.frame()) 
[16:09:27.722]                   {
[16:09:27.722]                     default_workers <- missing(workers)
[16:09:27.722]                     if (is.function(workers)) 
[16:09:27.722]                       workers <- workers()
[16:09:27.722]                     workers <- structure(as.integer(workers), 
[16:09:27.722]                       class = class(workers))
[16:09:27.722]                     stop_if_not(is.finite(workers), workers >= 
[16:09:27.722]                       1L)
[16:09:27.722]                     if ((workers == 1L && !inherits(workers, 
[16:09:27.722]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:27.722]                       if (default_workers) 
[16:09:27.722]                         supportsMulticore(warn = TRUE)
[16:09:27.722]                       return(sequential(..., envir = envir))
[16:09:27.722]                     }
[16:09:27.722]                     oopts <- options(mc.cores = workers)
[16:09:27.722]                     on.exit(options(oopts))
[16:09:27.722]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:27.722]                       envir = envir)
[16:09:27.722]                     if (!future$lazy) 
[16:09:27.722]                       future <- run(future)
[16:09:27.722]                     invisible(future)
[16:09:27.722]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.722]                 }
[16:09:27.722]             }
[16:09:27.722]         }
[16:09:27.722]     })
[16:09:27.722]     if (TRUE) {
[16:09:27.722]         base::sink(type = "output", split = FALSE)
[16:09:27.722]         if (TRUE) {
[16:09:27.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.722]         }
[16:09:27.722]         else {
[16:09:27.722]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.722]         }
[16:09:27.722]         base::close(...future.stdout)
[16:09:27.722]         ...future.stdout <- NULL
[16:09:27.722]     }
[16:09:27.722]     ...future.result$conditions <- ...future.conditions
[16:09:27.722]     ...future.result$finished <- base::Sys.time()
[16:09:27.722]     ...future.result
[16:09:27.722] }
[16:09:27.724] assign_globals() ...
[16:09:27.724] List of 5
[16:09:27.724]  $ future.call.arguments    : list()
[16:09:27.724]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.724]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.724]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.724]  $ ...future.elements_ii    :List of 1
[16:09:27.724]   ..$ : num [1:4] 1 3 1 7
[16:09:27.724]  $ ...future.seeds_ii       : NULL
[16:09:27.724]  $ ...future.globals.maxSize: NULL
[16:09:27.724]  - attr(*, "where")=List of 5
[16:09:27.724]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.724]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.724]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.724]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.724]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.724]  - attr(*, "resolved")= logi FALSE
[16:09:27.724]  - attr(*, "total_size")= num NA
[16:09:27.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.724]  - attr(*, "already-done")= logi TRUE
[16:09:27.729] - copied ‘future.call.arguments’ to environment
[16:09:27.729] - copied ‘...future.FUN’ to environment
[16:09:27.729] - copied ‘...future.elements_ii’ to environment
[16:09:27.729] - copied ‘...future.seeds_ii’ to environment
[16:09:27.729] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.729] assign_globals() ... done
[16:09:27.730] requestCore(): workers = 2
[16:09:27.733] MulticoreFuture started
[16:09:27.733] - Launch lazy future ... done
[16:09:27.734] plan(): Setting new future strategy stack:
[16:09:27.734] run() for ‘MulticoreFuture’ ... done
[16:09:27.734] Created future:
[16:09:27.734] List of future strategies:
[16:09:27.734] 1. sequential:
[16:09:27.734]    - args: function (..., envir = parent.frame())
[16:09:27.734]    - tweaked: FALSE
[16:09:27.734]    - call: NULL
[16:09:27.735] plan(): nbrOfWorkers() = 1
[16:09:27.737] plan(): Setting new future strategy stack:
[16:09:27.737] List of future strategies:
[16:09:27.737] 1. multicore:
[16:09:27.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:27.737]    - tweaked: FALSE
[16:09:27.737]    - call: plan(strategy)
[16:09:27.743] plan(): nbrOfWorkers() = 2
[16:09:27.734] MulticoreFuture:
[16:09:27.734] Label: ‘future_apply-1’
[16:09:27.734] Expression:
[16:09:27.734] {
[16:09:27.734]     do.call(function(...) {
[16:09:27.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.734]             on.exit(options(oopts), add = TRUE)
[16:09:27.734]         }
[16:09:27.734]         {
[16:09:27.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.734]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.734]             })
[16:09:27.734]         }
[16:09:27.734]     }, args = future.call.arguments)
[16:09:27.734] }
[16:09:27.734] Lazy evaluation: FALSE
[16:09:27.734] Asynchronous evaluation: TRUE
[16:09:27.734] Local evaluation: TRUE
[16:09:27.734] Environment: R_GlobalEnv
[16:09:27.734] Capture standard output: TRUE
[16:09:27.734] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.734] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:27.734] Packages: <none>
[16:09:27.734] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.734] Resolved: TRUE
[16:09:27.734] Value: <not collected>
[16:09:27.734] Conditions captured: <none>
[16:09:27.734] Early signaling: FALSE
[16:09:27.734] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.734] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.744] Chunk #1 of 2 ... DONE
[16:09:27.744] Chunk #2 of 2 ...
[16:09:27.744]  - seeds: <none>
[16:09:27.745] getGlobalsAndPackages() ...
[16:09:27.745] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.745] Resolving globals: FALSE
[16:09:27.745] Tweak future expression to call with '...' arguments ...
[16:09:27.745] {
[16:09:27.745]     do.call(function(...) {
[16:09:27.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.745]             on.exit(options(oopts), add = TRUE)
[16:09:27.745]         }
[16:09:27.745]         {
[16:09:27.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.745]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.745]             })
[16:09:27.745]         }
[16:09:27.745]     }, args = future.call.arguments)
[16:09:27.745] }
[16:09:27.745] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.746] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.746] 
[16:09:27.746] getGlobalsAndPackages() ... DONE
[16:09:27.747] run() for ‘Future’ ...
[16:09:27.747] - state: ‘created’
[16:09:27.747] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:27.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:27.752]   - Field: ‘label’
[16:09:27.752]   - Field: ‘local’
[16:09:27.752]   - Field: ‘owner’
[16:09:27.752]   - Field: ‘envir’
[16:09:27.753]   - Field: ‘workers’
[16:09:27.753]   - Field: ‘packages’
[16:09:27.753]   - Field: ‘gc’
[16:09:27.753]   - Field: ‘job’
[16:09:27.753]   - Field: ‘conditions’
[16:09:27.753]   - Field: ‘expr’
[16:09:27.753]   - Field: ‘uuid’
[16:09:27.754]   - Field: ‘seed’
[16:09:27.754]   - Field: ‘version’
[16:09:27.754]   - Field: ‘result’
[16:09:27.754]   - Field: ‘asynchronous’
[16:09:27.754]   - Field: ‘calls’
[16:09:27.754]   - Field: ‘globals’
[16:09:27.754]   - Field: ‘stdout’
[16:09:27.755]   - Field: ‘earlySignal’
[16:09:27.755]   - Field: ‘lazy’
[16:09:27.755]   - Field: ‘state’
[16:09:27.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:27.755] - Launch lazy future ...
[16:09:27.756] Packages needed by the future expression (n = 0): <none>
[16:09:27.756] Packages needed by future strategies (n = 0): <none>
[16:09:27.760] {
[16:09:27.760]     {
[16:09:27.760]         {
[16:09:27.760]             ...future.startTime <- base::Sys.time()
[16:09:27.760]             {
[16:09:27.760]                 {
[16:09:27.760]                   {
[16:09:27.760]                     {
[16:09:27.760]                       base::local({
[16:09:27.760]                         has_future <- base::requireNamespace("future", 
[16:09:27.760]                           quietly = TRUE)
[16:09:27.760]                         if (has_future) {
[16:09:27.760]                           ns <- base::getNamespace("future")
[16:09:27.760]                           version <- ns[[".package"]][["version"]]
[16:09:27.760]                           if (is.null(version)) 
[16:09:27.760]                             version <- utils::packageVersion("future")
[16:09:27.760]                         }
[16:09:27.760]                         else {
[16:09:27.760]                           version <- NULL
[16:09:27.760]                         }
[16:09:27.760]                         if (!has_future || version < "1.8.0") {
[16:09:27.760]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.760]                             "", base::R.version$version.string), 
[16:09:27.760]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:27.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.760]                               "release", "version")], collapse = " "), 
[16:09:27.760]                             hostname = base::Sys.info()[["nodename"]])
[16:09:27.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.760]                             info)
[16:09:27.760]                           info <- base::paste(info, collapse = "; ")
[16:09:27.760]                           if (!has_future) {
[16:09:27.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.760]                               info)
[16:09:27.760]                           }
[16:09:27.760]                           else {
[16:09:27.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.760]                               info, version)
[16:09:27.760]                           }
[16:09:27.760]                           base::stop(msg)
[16:09:27.760]                         }
[16:09:27.760]                       })
[16:09:27.760]                     }
[16:09:27.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:27.760]                     base::options(mc.cores = 1L)
[16:09:27.760]                   }
[16:09:27.760]                   options(future.plan = NULL)
[16:09:27.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.760]                 }
[16:09:27.760]                 ...future.workdir <- getwd()
[16:09:27.760]             }
[16:09:27.760]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.760]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.760]         }
[16:09:27.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.760]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.760]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.760]             base::names(...future.oldOptions))
[16:09:27.760]     }
[16:09:27.760]     if (FALSE) {
[16:09:27.760]     }
[16:09:27.760]     else {
[16:09:27.760]         if (TRUE) {
[16:09:27.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.760]                 open = "w")
[16:09:27.760]         }
[16:09:27.760]         else {
[16:09:27.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.760]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.760]         }
[16:09:27.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.760]             base::sink(type = "output", split = FALSE)
[16:09:27.760]             base::close(...future.stdout)
[16:09:27.760]         }, add = TRUE)
[16:09:27.760]     }
[16:09:27.760]     ...future.frame <- base::sys.nframe()
[16:09:27.760]     ...future.conditions <- base::list()
[16:09:27.760]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.760]     if (FALSE) {
[16:09:27.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.760]     }
[16:09:27.760]     ...future.result <- base::tryCatch({
[16:09:27.760]         base::withCallingHandlers({
[16:09:27.760]             ...future.value <- base::withVisible(base::local({
[16:09:27.760]                 withCallingHandlers({
[16:09:27.760]                   {
[16:09:27.760]                     do.call(function(...) {
[16:09:27.760]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.760]                       if (!identical(...future.globals.maxSize.org, 
[16:09:27.760]                         ...future.globals.maxSize)) {
[16:09:27.760]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.760]                         on.exit(options(oopts), add = TRUE)
[16:09:27.760]                       }
[16:09:27.760]                       {
[16:09:27.760]                         lapply(seq_along(...future.elements_ii), 
[16:09:27.760]                           FUN = function(jj) {
[16:09:27.760]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.760]                             ...future.FUN(...future.X_jj, ...)
[16:09:27.760]                           })
[16:09:27.760]                       }
[16:09:27.760]                     }, args = future.call.arguments)
[16:09:27.760]                   }
[16:09:27.760]                 }, immediateCondition = function(cond) {
[16:09:27.760]                   save_rds <- function (object, pathname, ...) 
[16:09:27.760]                   {
[16:09:27.760]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:27.760]                     if (file_test("-f", pathname_tmp)) {
[16:09:27.760]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.760]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:27.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.760]                         fi_tmp[["mtime"]])
[16:09:27.760]                     }
[16:09:27.760]                     tryCatch({
[16:09:27.760]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:27.760]                     }, error = function(ex) {
[16:09:27.760]                       msg <- conditionMessage(ex)
[16:09:27.760]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.760]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:27.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.760]                         fi_tmp[["mtime"]], msg)
[16:09:27.760]                       ex$message <- msg
[16:09:27.760]                       stop(ex)
[16:09:27.760]                     })
[16:09:27.760]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:27.760]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:27.760]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:27.760]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.760]                       fi <- file.info(pathname)
[16:09:27.760]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:27.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.760]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:27.760]                         fi[["size"]], fi[["mtime"]])
[16:09:27.760]                       stop(msg)
[16:09:27.760]                     }
[16:09:27.760]                     invisible(pathname)
[16:09:27.760]                   }
[16:09:27.760]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:27.760]                     rootPath = tempdir()) 
[16:09:27.760]                   {
[16:09:27.760]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:27.760]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:27.760]                       tmpdir = path, fileext = ".rds")
[16:09:27.760]                     save_rds(obj, file)
[16:09:27.760]                   }
[16:09:27.760]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:27.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.760]                   {
[16:09:27.760]                     inherits <- base::inherits
[16:09:27.760]                     invokeRestart <- base::invokeRestart
[16:09:27.760]                     is.null <- base::is.null
[16:09:27.760]                     muffled <- FALSE
[16:09:27.760]                     if (inherits(cond, "message")) {
[16:09:27.760]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:27.760]                       if (muffled) 
[16:09:27.760]                         invokeRestart("muffleMessage")
[16:09:27.760]                     }
[16:09:27.760]                     else if (inherits(cond, "warning")) {
[16:09:27.760]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:27.760]                       if (muffled) 
[16:09:27.760]                         invokeRestart("muffleWarning")
[16:09:27.760]                     }
[16:09:27.760]                     else if (inherits(cond, "condition")) {
[16:09:27.760]                       if (!is.null(pattern)) {
[16:09:27.760]                         computeRestarts <- base::computeRestarts
[16:09:27.760]                         grepl <- base::grepl
[16:09:27.760]                         restarts <- computeRestarts(cond)
[16:09:27.760]                         for (restart in restarts) {
[16:09:27.760]                           name <- restart$name
[16:09:27.760]                           if (is.null(name)) 
[16:09:27.760]                             next
[16:09:27.760]                           if (!grepl(pattern, name)) 
[16:09:27.760]                             next
[16:09:27.760]                           invokeRestart(restart)
[16:09:27.760]                           muffled <- TRUE
[16:09:27.760]                           break
[16:09:27.760]                         }
[16:09:27.760]                       }
[16:09:27.760]                     }
[16:09:27.760]                     invisible(muffled)
[16:09:27.760]                   }
[16:09:27.760]                   muffleCondition(cond)
[16:09:27.760]                 })
[16:09:27.760]             }))
[16:09:27.760]             future::FutureResult(value = ...future.value$value, 
[16:09:27.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.760]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.760]                     ...future.globalenv.names))
[16:09:27.760]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.760]         }, condition = base::local({
[16:09:27.760]             c <- base::c
[16:09:27.760]             inherits <- base::inherits
[16:09:27.760]             invokeRestart <- base::invokeRestart
[16:09:27.760]             length <- base::length
[16:09:27.760]             list <- base::list
[16:09:27.760]             seq.int <- base::seq.int
[16:09:27.760]             signalCondition <- base::signalCondition
[16:09:27.760]             sys.calls <- base::sys.calls
[16:09:27.760]             `[[` <- base::`[[`
[16:09:27.760]             `+` <- base::`+`
[16:09:27.760]             `<<-` <- base::`<<-`
[16:09:27.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.760]                   3L)]
[16:09:27.760]             }
[16:09:27.760]             function(cond) {
[16:09:27.760]                 is_error <- inherits(cond, "error")
[16:09:27.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.760]                   NULL)
[16:09:27.760]                 if (is_error) {
[16:09:27.760]                   sessionInformation <- function() {
[16:09:27.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.760]                       search = base::search(), system = base::Sys.info())
[16:09:27.760]                   }
[16:09:27.760]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.760]                     cond$call), session = sessionInformation(), 
[16:09:27.760]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.760]                   signalCondition(cond)
[16:09:27.760]                 }
[16:09:27.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.760]                 "immediateCondition"))) {
[16:09:27.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.760]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.760]                   if (TRUE && !signal) {
[16:09:27.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.760]                     {
[16:09:27.760]                       inherits <- base::inherits
[16:09:27.760]                       invokeRestart <- base::invokeRestart
[16:09:27.760]                       is.null <- base::is.null
[16:09:27.760]                       muffled <- FALSE
[16:09:27.760]                       if (inherits(cond, "message")) {
[16:09:27.760]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.760]                         if (muffled) 
[16:09:27.760]                           invokeRestart("muffleMessage")
[16:09:27.760]                       }
[16:09:27.760]                       else if (inherits(cond, "warning")) {
[16:09:27.760]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.760]                         if (muffled) 
[16:09:27.760]                           invokeRestart("muffleWarning")
[16:09:27.760]                       }
[16:09:27.760]                       else if (inherits(cond, "condition")) {
[16:09:27.760]                         if (!is.null(pattern)) {
[16:09:27.760]                           computeRestarts <- base::computeRestarts
[16:09:27.760]                           grepl <- base::grepl
[16:09:27.760]                           restarts <- computeRestarts(cond)
[16:09:27.760]                           for (restart in restarts) {
[16:09:27.760]                             name <- restart$name
[16:09:27.760]                             if (is.null(name)) 
[16:09:27.760]                               next
[16:09:27.760]                             if (!grepl(pattern, name)) 
[16:09:27.760]                               next
[16:09:27.760]                             invokeRestart(restart)
[16:09:27.760]                             muffled <- TRUE
[16:09:27.760]                             break
[16:09:27.760]                           }
[16:09:27.760]                         }
[16:09:27.760]                       }
[16:09:27.760]                       invisible(muffled)
[16:09:27.760]                     }
[16:09:27.760]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.760]                   }
[16:09:27.760]                 }
[16:09:27.760]                 else {
[16:09:27.760]                   if (TRUE) {
[16:09:27.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.760]                     {
[16:09:27.760]                       inherits <- base::inherits
[16:09:27.760]                       invokeRestart <- base::invokeRestart
[16:09:27.760]                       is.null <- base::is.null
[16:09:27.760]                       muffled <- FALSE
[16:09:27.760]                       if (inherits(cond, "message")) {
[16:09:27.760]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.760]                         if (muffled) 
[16:09:27.760]                           invokeRestart("muffleMessage")
[16:09:27.760]                       }
[16:09:27.760]                       else if (inherits(cond, "warning")) {
[16:09:27.760]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.760]                         if (muffled) 
[16:09:27.760]                           invokeRestart("muffleWarning")
[16:09:27.760]                       }
[16:09:27.760]                       else if (inherits(cond, "condition")) {
[16:09:27.760]                         if (!is.null(pattern)) {
[16:09:27.760]                           computeRestarts <- base::computeRestarts
[16:09:27.760]                           grepl <- base::grepl
[16:09:27.760]                           restarts <- computeRestarts(cond)
[16:09:27.760]                           for (restart in restarts) {
[16:09:27.760]                             name <- restart$name
[16:09:27.760]                             if (is.null(name)) 
[16:09:27.760]                               next
[16:09:27.760]                             if (!grepl(pattern, name)) 
[16:09:27.760]                               next
[16:09:27.760]                             invokeRestart(restart)
[16:09:27.760]                             muffled <- TRUE
[16:09:27.760]                             break
[16:09:27.760]                           }
[16:09:27.760]                         }
[16:09:27.760]                       }
[16:09:27.760]                       invisible(muffled)
[16:09:27.760]                     }
[16:09:27.760]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.760]                   }
[16:09:27.760]                 }
[16:09:27.760]             }
[16:09:27.760]         }))
[16:09:27.760]     }, error = function(ex) {
[16:09:27.760]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.760]                 ...future.rng), started = ...future.startTime, 
[16:09:27.760]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.760]             version = "1.8"), class = "FutureResult")
[16:09:27.760]     }, finally = {
[16:09:27.760]         if (!identical(...future.workdir, getwd())) 
[16:09:27.760]             setwd(...future.workdir)
[16:09:27.760]         {
[16:09:27.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.760]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.760]             }
[16:09:27.760]             base::options(...future.oldOptions)
[16:09:27.760]             if (.Platform$OS.type == "windows") {
[16:09:27.760]                 old_names <- names(...future.oldEnvVars)
[16:09:27.760]                 envs <- base::Sys.getenv()
[16:09:27.760]                 names <- names(envs)
[16:09:27.760]                 common <- intersect(names, old_names)
[16:09:27.760]                 added <- setdiff(names, old_names)
[16:09:27.760]                 removed <- setdiff(old_names, names)
[16:09:27.760]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.760]                   envs[common]]
[16:09:27.760]                 NAMES <- toupper(changed)
[16:09:27.760]                 args <- list()
[16:09:27.760]                 for (kk in seq_along(NAMES)) {
[16:09:27.760]                   name <- changed[[kk]]
[16:09:27.760]                   NAME <- NAMES[[kk]]
[16:09:27.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.760]                     next
[16:09:27.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.760]                 }
[16:09:27.760]                 NAMES <- toupper(added)
[16:09:27.760]                 for (kk in seq_along(NAMES)) {
[16:09:27.760]                   name <- added[[kk]]
[16:09:27.760]                   NAME <- NAMES[[kk]]
[16:09:27.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.760]                     next
[16:09:27.760]                   args[[name]] <- ""
[16:09:27.760]                 }
[16:09:27.760]                 NAMES <- toupper(removed)
[16:09:27.760]                 for (kk in seq_along(NAMES)) {
[16:09:27.760]                   name <- removed[[kk]]
[16:09:27.760]                   NAME <- NAMES[[kk]]
[16:09:27.760]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.760]                     next
[16:09:27.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.760]                 }
[16:09:27.760]                 if (length(args) > 0) 
[16:09:27.760]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.760]             }
[16:09:27.760]             else {
[16:09:27.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.760]             }
[16:09:27.760]             {
[16:09:27.760]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.760]                   0L) {
[16:09:27.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.760]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.760]                   base::options(opts)
[16:09:27.760]                 }
[16:09:27.760]                 {
[16:09:27.760]                   {
[16:09:27.760]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:27.760]                     NULL
[16:09:27.760]                   }
[16:09:27.760]                   options(future.plan = NULL)
[16:09:27.760]                   if (is.na(NA_character_)) 
[16:09:27.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.760]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:27.760]                     envir = parent.frame()) 
[16:09:27.760]                   {
[16:09:27.760]                     default_workers <- missing(workers)
[16:09:27.760]                     if (is.function(workers)) 
[16:09:27.760]                       workers <- workers()
[16:09:27.760]                     workers <- structure(as.integer(workers), 
[16:09:27.760]                       class = class(workers))
[16:09:27.760]                     stop_if_not(is.finite(workers), workers >= 
[16:09:27.760]                       1L)
[16:09:27.760]                     if ((workers == 1L && !inherits(workers, 
[16:09:27.760]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:27.760]                       if (default_workers) 
[16:09:27.760]                         supportsMulticore(warn = TRUE)
[16:09:27.760]                       return(sequential(..., envir = envir))
[16:09:27.760]                     }
[16:09:27.760]                     oopts <- options(mc.cores = workers)
[16:09:27.760]                     on.exit(options(oopts))
[16:09:27.760]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:27.760]                       envir = envir)
[16:09:27.760]                     if (!future$lazy) 
[16:09:27.760]                       future <- run(future)
[16:09:27.760]                     invisible(future)
[16:09:27.760]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.760]                 }
[16:09:27.760]             }
[16:09:27.760]         }
[16:09:27.760]     })
[16:09:27.760]     if (TRUE) {
[16:09:27.760]         base::sink(type = "output", split = FALSE)
[16:09:27.760]         if (TRUE) {
[16:09:27.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.760]         }
[16:09:27.760]         else {
[16:09:27.760]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.760]         }
[16:09:27.760]         base::close(...future.stdout)
[16:09:27.760]         ...future.stdout <- NULL
[16:09:27.760]     }
[16:09:27.760]     ...future.result$conditions <- ...future.conditions
[16:09:27.760]     ...future.result$finished <- base::Sys.time()
[16:09:27.760]     ...future.result
[16:09:27.760] }
[16:09:27.763] assign_globals() ...
[16:09:27.763] List of 5
[16:09:27.763]  $ future.call.arguments    : list()
[16:09:27.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.763]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.763]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.763]  $ ...future.elements_ii    :List of 1
[16:09:27.763]   ..$ : num [1:4] 2 4 6 8
[16:09:27.763]  $ ...future.seeds_ii       : NULL
[16:09:27.763]  $ ...future.globals.maxSize: NULL
[16:09:27.763]  - attr(*, "where")=List of 5
[16:09:27.763]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.763]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.763]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.763]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.763]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.763]  - attr(*, "resolved")= logi FALSE
[16:09:27.763]  - attr(*, "total_size")= num NA
[16:09:27.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.763]  - attr(*, "already-done")= logi TRUE
[16:09:27.772] - copied ‘future.call.arguments’ to environment
[16:09:27.772] - copied ‘...future.FUN’ to environment
[16:09:27.772] - copied ‘...future.elements_ii’ to environment
[16:09:27.773] - copied ‘...future.seeds_ii’ to environment
[16:09:27.773] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.773] assign_globals() ... done
[16:09:27.773] requestCore(): workers = 2
[16:09:27.778] MulticoreFuture started
[16:09:27.779] - Launch lazy future ... done
[16:09:27.779] run() for ‘MulticoreFuture’ ... done
[16:09:27.779] Created future:
[16:09:27.780] plan(): Setting new future strategy stack:
[16:09:27.780] List of future strategies:
[16:09:27.780] 1. sequential:
[16:09:27.780]    - args: function (..., envir = parent.frame())
[16:09:27.780]    - tweaked: FALSE
[16:09:27.780]    - call: NULL
[16:09:27.781] plan(): nbrOfWorkers() = 1
[16:09:27.783] plan(): Setting new future strategy stack:
[16:09:27.783] List of future strategies:
[16:09:27.783] 1. multicore:
[16:09:27.783]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:27.783]    - tweaked: FALSE
[16:09:27.783]    - call: plan(strategy)
[16:09:27.788] plan(): nbrOfWorkers() = 2
[16:09:27.779] MulticoreFuture:
[16:09:27.779] Label: ‘future_apply-2’
[16:09:27.779] Expression:
[16:09:27.779] {
[16:09:27.779]     do.call(function(...) {
[16:09:27.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.779]             on.exit(options(oopts), add = TRUE)
[16:09:27.779]         }
[16:09:27.779]         {
[16:09:27.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.779]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.779]             })
[16:09:27.779]         }
[16:09:27.779]     }, args = future.call.arguments)
[16:09:27.779] }
[16:09:27.779] Lazy evaluation: FALSE
[16:09:27.779] Asynchronous evaluation: TRUE
[16:09:27.779] Local evaluation: TRUE
[16:09:27.779] Environment: R_GlobalEnv
[16:09:27.779] Capture standard output: TRUE
[16:09:27.779] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.779] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:27.779] Packages: <none>
[16:09:27.779] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.779] Resolved: TRUE
[16:09:27.779] Value: <not collected>
[16:09:27.779] Conditions captured: <none>
[16:09:27.779] Early signaling: FALSE
[16:09:27.779] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.779] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.789] Chunk #2 of 2 ... DONE
[16:09:27.790] Launching 2 futures (chunks) ... DONE
[16:09:27.790] Resolving 2 futures (chunks) ...
[16:09:27.790] resolve() on list ...
[16:09:27.790]  recursive: 0
[16:09:27.790]  length: 2
[16:09:27.790] 
[16:09:27.791] Future #1
[16:09:27.793] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:27.793] - nx: 2
[16:09:27.793] - relay: TRUE
[16:09:27.793] - stdout: TRUE
[16:09:27.794] - signal: TRUE
[16:09:27.794] - resignal: FALSE
[16:09:27.794] - force: TRUE
[16:09:27.794] - relayed: [n=2] FALSE, FALSE
[16:09:27.794] - queued futures: [n=2] FALSE, FALSE
[16:09:27.794]  - until=1
[16:09:27.794]  - relaying element #1
[16:09:27.795] - relayed: [n=2] TRUE, FALSE
[16:09:27.795] - queued futures: [n=2] TRUE, FALSE
[16:09:27.795] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:27.795]  length: 1 (resolved future 1)
[16:09:27.796] Future #2
[16:09:27.796] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:27.797] - nx: 2
[16:09:27.797] - relay: TRUE
[16:09:27.797] - stdout: TRUE
[16:09:27.797] - signal: TRUE
[16:09:27.797] - resignal: FALSE
[16:09:27.797] - force: TRUE
[16:09:27.797] - relayed: [n=2] TRUE, FALSE
[16:09:27.797] - queued futures: [n=2] TRUE, FALSE
[16:09:27.798]  - until=2
[16:09:27.798]  - relaying element #2
[16:09:27.798] - relayed: [n=2] TRUE, TRUE
[16:09:27.798] - queued futures: [n=2] TRUE, TRUE
[16:09:27.798] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:27.798]  length: 0 (resolved future 2)
[16:09:27.798] Relaying remaining futures
[16:09:27.799] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.799] - nx: 2
[16:09:27.799] - relay: TRUE
[16:09:27.799] - stdout: TRUE
[16:09:27.799] - signal: TRUE
[16:09:27.799] - resignal: FALSE
[16:09:27.799] - force: TRUE
[16:09:27.799] - relayed: [n=2] TRUE, TRUE
[16:09:27.799] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:27.800] - relayed: [n=2] TRUE, TRUE
[16:09:27.800] - queued futures: [n=2] TRUE, TRUE
[16:09:27.800] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.800] resolve() on list ... DONE
[16:09:27.800]  - Number of value chunks collected: 2
[16:09:27.800] Resolving 2 futures (chunks) ... DONE
[16:09:27.800] Reducing values from 2 chunks ...
[16:09:27.801]  - Number of values collected after concatenation: 2
[16:09:27.801]  - Number of values expected: 2
[16:09:27.801] Reducing values from 2 chunks ... DONE
[16:09:27.801] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:09:27.801] getGlobalsAndPackagesXApply() ...
[16:09:27.802]  - future.globals: TRUE
[16:09:27.802] getGlobalsAndPackages() ...
[16:09:27.802] Searching for globals...
[16:09:27.844] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:09:27.844] Searching for globals ... DONE
[16:09:27.845] Resolving globals: FALSE
[16:09:27.846] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:09:27.847] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:09:27.847] - globals: [1] ‘FUN’
[16:09:27.847] 
[16:09:27.847] getGlobalsAndPackages() ... DONE
[16:09:27.847]  - globals found/used: [n=1] ‘FUN’
[16:09:27.847]  - needed namespaces: [n=0] 
[16:09:27.847] Finding globals ... DONE
[16:09:27.847]  - use_args: TRUE
[16:09:27.847]  - Getting '...' globals ...
[16:09:27.848] resolve() on list ...
[16:09:27.848]  recursive: 0
[16:09:27.848]  length: 1
[16:09:27.848]  elements: ‘...’
[16:09:27.848]  length: 0 (resolved future 1)
[16:09:27.848] resolve() on list ... DONE
[16:09:27.848]    - '...' content: [n=0] 
[16:09:27.848] List of 1
[16:09:27.848]  $ ...: list()
[16:09:27.848]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.848]  - attr(*, "where")=List of 1
[16:09:27.848]   ..$ ...:<environment: 0x5633ac737280> 
[16:09:27.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.848]  - attr(*, "resolved")= logi TRUE
[16:09:27.848]  - attr(*, "total_size")= num NA
[16:09:27.851]  - Getting '...' globals ... DONE
[16:09:27.851] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:27.851] List of 2
[16:09:27.851]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.851]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.851]  $ ...          : list()
[16:09:27.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.851]  - attr(*, "where")=List of 2
[16:09:27.851]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:27.851]   ..$ ...          :<environment: 0x5633ac737280> 
[16:09:27.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.851]  - attr(*, "resolved")= logi FALSE
[16:09:27.851]  - attr(*, "total_size")= num 354224
[16:09:27.854] Packages to be attached in all futures: [n=0] 
[16:09:27.854] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.858] future_lapply() ...
[16:09:27.897] Number of chunks: 2
[16:09:27.897] getGlobalsAndPackagesXApply() ...
[16:09:27.897]  - future.globals: <name-value list> with names ‘list()’
[16:09:27.898]  - use_args: TRUE
[16:09:27.898] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:27.898] List of 2
[16:09:27.898]  $ ...          : list()
[16:09:27.898]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.898]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.898]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.898]  - attr(*, "where")=List of 2
[16:09:27.898]   ..$ ...          :<environment: 0x5633ac737280> 
[16:09:27.898]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:27.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.898]  - attr(*, "resolved")= logi FALSE
[16:09:27.898]  - attr(*, "total_size")= num NA
[16:09:27.902] Packages to be attached in all futures: [n=0] 
[16:09:27.902] getGlobalsAndPackagesXApply() ... DONE
[16:09:27.902] Number of futures (= number of chunks): 2
[16:09:27.902] Launching 2 futures (chunks) ...
[16:09:27.902] Chunk #1 of 2 ...
[16:09:27.902]  - seeds: <none>
[16:09:27.902] getGlobalsAndPackages() ...
[16:09:27.903] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.903] Resolving globals: FALSE
[16:09:27.903] Tweak future expression to call with '...' arguments ...
[16:09:27.903] {
[16:09:27.903]     do.call(function(...) {
[16:09:27.903]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.903]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.903]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.903]             on.exit(options(oopts), add = TRUE)
[16:09:27.903]         }
[16:09:27.903]         {
[16:09:27.903]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.903]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.903]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.903]             })
[16:09:27.903]         }
[16:09:27.903]     }, args = future.call.arguments)
[16:09:27.903] }
[16:09:27.903] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.904] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.904] 
[16:09:27.904] getGlobalsAndPackages() ... DONE
[16:09:27.906] run() for ‘Future’ ...
[16:09:27.906] - state: ‘created’
[16:09:27.906] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:27.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:27.910]   - Field: ‘label’
[16:09:27.910]   - Field: ‘local’
[16:09:27.910]   - Field: ‘owner’
[16:09:27.911]   - Field: ‘envir’
[16:09:27.911]   - Field: ‘workers’
[16:09:27.911]   - Field: ‘packages’
[16:09:27.911]   - Field: ‘gc’
[16:09:27.911]   - Field: ‘job’
[16:09:27.911]   - Field: ‘conditions’
[16:09:27.911]   - Field: ‘expr’
[16:09:27.911]   - Field: ‘uuid’
[16:09:27.911]   - Field: ‘seed’
[16:09:27.911]   - Field: ‘version’
[16:09:27.912]   - Field: ‘result’
[16:09:27.912]   - Field: ‘asynchronous’
[16:09:27.912]   - Field: ‘calls’
[16:09:27.912]   - Field: ‘globals’
[16:09:27.912]   - Field: ‘stdout’
[16:09:27.912]   - Field: ‘earlySignal’
[16:09:27.912]   - Field: ‘lazy’
[16:09:27.912]   - Field: ‘state’
[16:09:27.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:27.913] - Launch lazy future ...
[16:09:27.913] Packages needed by the future expression (n = 0): <none>
[16:09:27.913] Packages needed by future strategies (n = 0): <none>
[16:09:27.913] {
[16:09:27.913]     {
[16:09:27.913]         {
[16:09:27.913]             ...future.startTime <- base::Sys.time()
[16:09:27.913]             {
[16:09:27.913]                 {
[16:09:27.913]                   {
[16:09:27.913]                     {
[16:09:27.913]                       base::local({
[16:09:27.913]                         has_future <- base::requireNamespace("future", 
[16:09:27.913]                           quietly = TRUE)
[16:09:27.913]                         if (has_future) {
[16:09:27.913]                           ns <- base::getNamespace("future")
[16:09:27.913]                           version <- ns[[".package"]][["version"]]
[16:09:27.913]                           if (is.null(version)) 
[16:09:27.913]                             version <- utils::packageVersion("future")
[16:09:27.913]                         }
[16:09:27.913]                         else {
[16:09:27.913]                           version <- NULL
[16:09:27.913]                         }
[16:09:27.913]                         if (!has_future || version < "1.8.0") {
[16:09:27.913]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.913]                             "", base::R.version$version.string), 
[16:09:27.913]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:27.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.913]                               "release", "version")], collapse = " "), 
[16:09:27.913]                             hostname = base::Sys.info()[["nodename"]])
[16:09:27.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.913]                             info)
[16:09:27.913]                           info <- base::paste(info, collapse = "; ")
[16:09:27.913]                           if (!has_future) {
[16:09:27.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.913]                               info)
[16:09:27.913]                           }
[16:09:27.913]                           else {
[16:09:27.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.913]                               info, version)
[16:09:27.913]                           }
[16:09:27.913]                           base::stop(msg)
[16:09:27.913]                         }
[16:09:27.913]                       })
[16:09:27.913]                     }
[16:09:27.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:27.913]                     base::options(mc.cores = 1L)
[16:09:27.913]                   }
[16:09:27.913]                   options(future.plan = NULL)
[16:09:27.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.913]                 }
[16:09:27.913]                 ...future.workdir <- getwd()
[16:09:27.913]             }
[16:09:27.913]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.913]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.913]         }
[16:09:27.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.913]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.913]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.913]             base::names(...future.oldOptions))
[16:09:27.913]     }
[16:09:27.913]     if (FALSE) {
[16:09:27.913]     }
[16:09:27.913]     else {
[16:09:27.913]         if (TRUE) {
[16:09:27.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.913]                 open = "w")
[16:09:27.913]         }
[16:09:27.913]         else {
[16:09:27.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.913]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.913]         }
[16:09:27.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.913]             base::sink(type = "output", split = FALSE)
[16:09:27.913]             base::close(...future.stdout)
[16:09:27.913]         }, add = TRUE)
[16:09:27.913]     }
[16:09:27.913]     ...future.frame <- base::sys.nframe()
[16:09:27.913]     ...future.conditions <- base::list()
[16:09:27.913]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.913]     if (FALSE) {
[16:09:27.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.913]     }
[16:09:27.913]     ...future.result <- base::tryCatch({
[16:09:27.913]         base::withCallingHandlers({
[16:09:27.913]             ...future.value <- base::withVisible(base::local({
[16:09:27.913]                 withCallingHandlers({
[16:09:27.913]                   {
[16:09:27.913]                     do.call(function(...) {
[16:09:27.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.913]                       if (!identical(...future.globals.maxSize.org, 
[16:09:27.913]                         ...future.globals.maxSize)) {
[16:09:27.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.913]                         on.exit(options(oopts), add = TRUE)
[16:09:27.913]                       }
[16:09:27.913]                       {
[16:09:27.913]                         lapply(seq_along(...future.elements_ii), 
[16:09:27.913]                           FUN = function(jj) {
[16:09:27.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.913]                             ...future.FUN(...future.X_jj, ...)
[16:09:27.913]                           })
[16:09:27.913]                       }
[16:09:27.913]                     }, args = future.call.arguments)
[16:09:27.913]                   }
[16:09:27.913]                 }, immediateCondition = function(cond) {
[16:09:27.913]                   save_rds <- function (object, pathname, ...) 
[16:09:27.913]                   {
[16:09:27.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:27.913]                     if (file_test("-f", pathname_tmp)) {
[16:09:27.913]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:27.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.913]                         fi_tmp[["mtime"]])
[16:09:27.913]                     }
[16:09:27.913]                     tryCatch({
[16:09:27.913]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:27.913]                     }, error = function(ex) {
[16:09:27.913]                       msg <- conditionMessage(ex)
[16:09:27.913]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:27.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.913]                         fi_tmp[["mtime"]], msg)
[16:09:27.913]                       ex$message <- msg
[16:09:27.913]                       stop(ex)
[16:09:27.913]                     })
[16:09:27.913]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:27.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:27.913]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:27.913]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.913]                       fi <- file.info(pathname)
[16:09:27.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:27.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:27.913]                         fi[["size"]], fi[["mtime"]])
[16:09:27.913]                       stop(msg)
[16:09:27.913]                     }
[16:09:27.913]                     invisible(pathname)
[16:09:27.913]                   }
[16:09:27.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:27.913]                     rootPath = tempdir()) 
[16:09:27.913]                   {
[16:09:27.913]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:27.913]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:27.913]                       tmpdir = path, fileext = ".rds")
[16:09:27.913]                     save_rds(obj, file)
[16:09:27.913]                   }
[16:09:27.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:27.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.913]                   {
[16:09:27.913]                     inherits <- base::inherits
[16:09:27.913]                     invokeRestart <- base::invokeRestart
[16:09:27.913]                     is.null <- base::is.null
[16:09:27.913]                     muffled <- FALSE
[16:09:27.913]                     if (inherits(cond, "message")) {
[16:09:27.913]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:27.913]                       if (muffled) 
[16:09:27.913]                         invokeRestart("muffleMessage")
[16:09:27.913]                     }
[16:09:27.913]                     else if (inherits(cond, "warning")) {
[16:09:27.913]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:27.913]                       if (muffled) 
[16:09:27.913]                         invokeRestart("muffleWarning")
[16:09:27.913]                     }
[16:09:27.913]                     else if (inherits(cond, "condition")) {
[16:09:27.913]                       if (!is.null(pattern)) {
[16:09:27.913]                         computeRestarts <- base::computeRestarts
[16:09:27.913]                         grepl <- base::grepl
[16:09:27.913]                         restarts <- computeRestarts(cond)
[16:09:27.913]                         for (restart in restarts) {
[16:09:27.913]                           name <- restart$name
[16:09:27.913]                           if (is.null(name)) 
[16:09:27.913]                             next
[16:09:27.913]                           if (!grepl(pattern, name)) 
[16:09:27.913]                             next
[16:09:27.913]                           invokeRestart(restart)
[16:09:27.913]                           muffled <- TRUE
[16:09:27.913]                           break
[16:09:27.913]                         }
[16:09:27.913]                       }
[16:09:27.913]                     }
[16:09:27.913]                     invisible(muffled)
[16:09:27.913]                   }
[16:09:27.913]                   muffleCondition(cond)
[16:09:27.913]                 })
[16:09:27.913]             }))
[16:09:27.913]             future::FutureResult(value = ...future.value$value, 
[16:09:27.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.913]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.913]                     ...future.globalenv.names))
[16:09:27.913]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.913]         }, condition = base::local({
[16:09:27.913]             c <- base::c
[16:09:27.913]             inherits <- base::inherits
[16:09:27.913]             invokeRestart <- base::invokeRestart
[16:09:27.913]             length <- base::length
[16:09:27.913]             list <- base::list
[16:09:27.913]             seq.int <- base::seq.int
[16:09:27.913]             signalCondition <- base::signalCondition
[16:09:27.913]             sys.calls <- base::sys.calls
[16:09:27.913]             `[[` <- base::`[[`
[16:09:27.913]             `+` <- base::`+`
[16:09:27.913]             `<<-` <- base::`<<-`
[16:09:27.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.913]                   3L)]
[16:09:27.913]             }
[16:09:27.913]             function(cond) {
[16:09:27.913]                 is_error <- inherits(cond, "error")
[16:09:27.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.913]                   NULL)
[16:09:27.913]                 if (is_error) {
[16:09:27.913]                   sessionInformation <- function() {
[16:09:27.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.913]                       search = base::search(), system = base::Sys.info())
[16:09:27.913]                   }
[16:09:27.913]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.913]                     cond$call), session = sessionInformation(), 
[16:09:27.913]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.913]                   signalCondition(cond)
[16:09:27.913]                 }
[16:09:27.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.913]                 "immediateCondition"))) {
[16:09:27.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.913]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.913]                   if (TRUE && !signal) {
[16:09:27.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.913]                     {
[16:09:27.913]                       inherits <- base::inherits
[16:09:27.913]                       invokeRestart <- base::invokeRestart
[16:09:27.913]                       is.null <- base::is.null
[16:09:27.913]                       muffled <- FALSE
[16:09:27.913]                       if (inherits(cond, "message")) {
[16:09:27.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.913]                         if (muffled) 
[16:09:27.913]                           invokeRestart("muffleMessage")
[16:09:27.913]                       }
[16:09:27.913]                       else if (inherits(cond, "warning")) {
[16:09:27.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.913]                         if (muffled) 
[16:09:27.913]                           invokeRestart("muffleWarning")
[16:09:27.913]                       }
[16:09:27.913]                       else if (inherits(cond, "condition")) {
[16:09:27.913]                         if (!is.null(pattern)) {
[16:09:27.913]                           computeRestarts <- base::computeRestarts
[16:09:27.913]                           grepl <- base::grepl
[16:09:27.913]                           restarts <- computeRestarts(cond)
[16:09:27.913]                           for (restart in restarts) {
[16:09:27.913]                             name <- restart$name
[16:09:27.913]                             if (is.null(name)) 
[16:09:27.913]                               next
[16:09:27.913]                             if (!grepl(pattern, name)) 
[16:09:27.913]                               next
[16:09:27.913]                             invokeRestart(restart)
[16:09:27.913]                             muffled <- TRUE
[16:09:27.913]                             break
[16:09:27.913]                           }
[16:09:27.913]                         }
[16:09:27.913]                       }
[16:09:27.913]                       invisible(muffled)
[16:09:27.913]                     }
[16:09:27.913]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.913]                   }
[16:09:27.913]                 }
[16:09:27.913]                 else {
[16:09:27.913]                   if (TRUE) {
[16:09:27.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.913]                     {
[16:09:27.913]                       inherits <- base::inherits
[16:09:27.913]                       invokeRestart <- base::invokeRestart
[16:09:27.913]                       is.null <- base::is.null
[16:09:27.913]                       muffled <- FALSE
[16:09:27.913]                       if (inherits(cond, "message")) {
[16:09:27.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.913]                         if (muffled) 
[16:09:27.913]                           invokeRestart("muffleMessage")
[16:09:27.913]                       }
[16:09:27.913]                       else if (inherits(cond, "warning")) {
[16:09:27.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.913]                         if (muffled) 
[16:09:27.913]                           invokeRestart("muffleWarning")
[16:09:27.913]                       }
[16:09:27.913]                       else if (inherits(cond, "condition")) {
[16:09:27.913]                         if (!is.null(pattern)) {
[16:09:27.913]                           computeRestarts <- base::computeRestarts
[16:09:27.913]                           grepl <- base::grepl
[16:09:27.913]                           restarts <- computeRestarts(cond)
[16:09:27.913]                           for (restart in restarts) {
[16:09:27.913]                             name <- restart$name
[16:09:27.913]                             if (is.null(name)) 
[16:09:27.913]                               next
[16:09:27.913]                             if (!grepl(pattern, name)) 
[16:09:27.913]                               next
[16:09:27.913]                             invokeRestart(restart)
[16:09:27.913]                             muffled <- TRUE
[16:09:27.913]                             break
[16:09:27.913]                           }
[16:09:27.913]                         }
[16:09:27.913]                       }
[16:09:27.913]                       invisible(muffled)
[16:09:27.913]                     }
[16:09:27.913]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.913]                   }
[16:09:27.913]                 }
[16:09:27.913]             }
[16:09:27.913]         }))
[16:09:27.913]     }, error = function(ex) {
[16:09:27.913]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.913]                 ...future.rng), started = ...future.startTime, 
[16:09:27.913]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.913]             version = "1.8"), class = "FutureResult")
[16:09:27.913]     }, finally = {
[16:09:27.913]         if (!identical(...future.workdir, getwd())) 
[16:09:27.913]             setwd(...future.workdir)
[16:09:27.913]         {
[16:09:27.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.913]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.913]             }
[16:09:27.913]             base::options(...future.oldOptions)
[16:09:27.913]             if (.Platform$OS.type == "windows") {
[16:09:27.913]                 old_names <- names(...future.oldEnvVars)
[16:09:27.913]                 envs <- base::Sys.getenv()
[16:09:27.913]                 names <- names(envs)
[16:09:27.913]                 common <- intersect(names, old_names)
[16:09:27.913]                 added <- setdiff(names, old_names)
[16:09:27.913]                 removed <- setdiff(old_names, names)
[16:09:27.913]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.913]                   envs[common]]
[16:09:27.913]                 NAMES <- toupper(changed)
[16:09:27.913]                 args <- list()
[16:09:27.913]                 for (kk in seq_along(NAMES)) {
[16:09:27.913]                   name <- changed[[kk]]
[16:09:27.913]                   NAME <- NAMES[[kk]]
[16:09:27.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.913]                     next
[16:09:27.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.913]                 }
[16:09:27.913]                 NAMES <- toupper(added)
[16:09:27.913]                 for (kk in seq_along(NAMES)) {
[16:09:27.913]                   name <- added[[kk]]
[16:09:27.913]                   NAME <- NAMES[[kk]]
[16:09:27.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.913]                     next
[16:09:27.913]                   args[[name]] <- ""
[16:09:27.913]                 }
[16:09:27.913]                 NAMES <- toupper(removed)
[16:09:27.913]                 for (kk in seq_along(NAMES)) {
[16:09:27.913]                   name <- removed[[kk]]
[16:09:27.913]                   NAME <- NAMES[[kk]]
[16:09:27.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.913]                     next
[16:09:27.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.913]                 }
[16:09:27.913]                 if (length(args) > 0) 
[16:09:27.913]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.913]             }
[16:09:27.913]             else {
[16:09:27.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.913]             }
[16:09:27.913]             {
[16:09:27.913]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.913]                   0L) {
[16:09:27.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.913]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.913]                   base::options(opts)
[16:09:27.913]                 }
[16:09:27.913]                 {
[16:09:27.913]                   {
[16:09:27.913]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:27.913]                     NULL
[16:09:27.913]                   }
[16:09:27.913]                   options(future.plan = NULL)
[16:09:27.913]                   if (is.na(NA_character_)) 
[16:09:27.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.913]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:27.913]                     envir = parent.frame()) 
[16:09:27.913]                   {
[16:09:27.913]                     default_workers <- missing(workers)
[16:09:27.913]                     if (is.function(workers)) 
[16:09:27.913]                       workers <- workers()
[16:09:27.913]                     workers <- structure(as.integer(workers), 
[16:09:27.913]                       class = class(workers))
[16:09:27.913]                     stop_if_not(is.finite(workers), workers >= 
[16:09:27.913]                       1L)
[16:09:27.913]                     if ((workers == 1L && !inherits(workers, 
[16:09:27.913]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:27.913]                       if (default_workers) 
[16:09:27.913]                         supportsMulticore(warn = TRUE)
[16:09:27.913]                       return(sequential(..., envir = envir))
[16:09:27.913]                     }
[16:09:27.913]                     oopts <- options(mc.cores = workers)
[16:09:27.913]                     on.exit(options(oopts))
[16:09:27.913]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:27.913]                       envir = envir)
[16:09:27.913]                     if (!future$lazy) 
[16:09:27.913]                       future <- run(future)
[16:09:27.913]                     invisible(future)
[16:09:27.913]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.913]                 }
[16:09:27.913]             }
[16:09:27.913]         }
[16:09:27.913]     })
[16:09:27.913]     if (TRUE) {
[16:09:27.913]         base::sink(type = "output", split = FALSE)
[16:09:27.913]         if (TRUE) {
[16:09:27.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.913]         }
[16:09:27.913]         else {
[16:09:27.913]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.913]         }
[16:09:27.913]         base::close(...future.stdout)
[16:09:27.913]         ...future.stdout <- NULL
[16:09:27.913]     }
[16:09:27.913]     ...future.result$conditions <- ...future.conditions
[16:09:27.913]     ...future.result$finished <- base::Sys.time()
[16:09:27.913]     ...future.result
[16:09:27.913] }
[16:09:27.916] assign_globals() ...
[16:09:27.916] List of 5
[16:09:27.916]  $ future.call.arguments    : list()
[16:09:27.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.916]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.916]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.916]  $ ...future.elements_ii    :List of 1
[16:09:27.916]   ..$ : num [1:4] 1 3 1 7
[16:09:27.916]  $ ...future.seeds_ii       : NULL
[16:09:27.916]  $ ...future.globals.maxSize: NULL
[16:09:27.916]  - attr(*, "where")=List of 5
[16:09:27.916]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.916]  - attr(*, "resolved")= logi FALSE
[16:09:27.916]  - attr(*, "total_size")= num NA
[16:09:27.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.916]  - attr(*, "already-done")= logi TRUE
[16:09:27.921] - copied ‘future.call.arguments’ to environment
[16:09:27.921] - copied ‘...future.FUN’ to environment
[16:09:27.921] - copied ‘...future.elements_ii’ to environment
[16:09:27.921] - copied ‘...future.seeds_ii’ to environment
[16:09:27.921] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.921] assign_globals() ... done
[16:09:27.922] requestCore(): workers = 2
[16:09:27.924] MulticoreFuture started
[16:09:27.924] - Launch lazy future ... done
[16:09:27.924] run() for ‘MulticoreFuture’ ... done
[16:09:27.925] Created future:
[16:09:27.925] plan(): Setting new future strategy stack:
[16:09:27.925] List of future strategies:
[16:09:27.925] 1. sequential:
[16:09:27.925]    - args: function (..., envir = parent.frame())
[16:09:27.925]    - tweaked: FALSE
[16:09:27.925]    - call: NULL
[16:09:27.926] plan(): nbrOfWorkers() = 1
[16:09:27.929] plan(): Setting new future strategy stack:
[16:09:27.929] List of future strategies:
[16:09:27.929] 1. multicore:
[16:09:27.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:27.929]    - tweaked: FALSE
[16:09:27.929]    - call: plan(strategy)
[16:09:27.934] plan(): nbrOfWorkers() = 2
[16:09:27.925] MulticoreFuture:
[16:09:27.925] Label: ‘future_apply-1’
[16:09:27.925] Expression:
[16:09:27.925] {
[16:09:27.925]     do.call(function(...) {
[16:09:27.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.925]             on.exit(options(oopts), add = TRUE)
[16:09:27.925]         }
[16:09:27.925]         {
[16:09:27.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.925]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.925]             })
[16:09:27.925]         }
[16:09:27.925]     }, args = future.call.arguments)
[16:09:27.925] }
[16:09:27.925] Lazy evaluation: FALSE
[16:09:27.925] Asynchronous evaluation: TRUE
[16:09:27.925] Local evaluation: TRUE
[16:09:27.925] Environment: R_GlobalEnv
[16:09:27.925] Capture standard output: TRUE
[16:09:27.925] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.925] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:27.925] Packages: <none>
[16:09:27.925] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.925] Resolved: TRUE
[16:09:27.925] Value: <not collected>
[16:09:27.925] Conditions captured: <none>
[16:09:27.925] Early signaling: FALSE
[16:09:27.925] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.925] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.935] Chunk #1 of 2 ... DONE
[16:09:27.935] Chunk #2 of 2 ...
[16:09:27.936]  - seeds: <none>
[16:09:27.936] getGlobalsAndPackages() ...
[16:09:27.936] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.936] Resolving globals: FALSE
[16:09:27.936] Tweak future expression to call with '...' arguments ...
[16:09:27.936] {
[16:09:27.936]     do.call(function(...) {
[16:09:27.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.936]             on.exit(options(oopts), add = TRUE)
[16:09:27.936]         }
[16:09:27.936]         {
[16:09:27.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.936]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.936]             })
[16:09:27.936]         }
[16:09:27.936]     }, args = future.call.arguments)
[16:09:27.936] }
[16:09:27.937] Tweak future expression to call with '...' arguments ... DONE
[16:09:27.937] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:27.938] 
[16:09:27.938] getGlobalsAndPackages() ... DONE
[16:09:27.938] run() for ‘Future’ ...
[16:09:27.938] - state: ‘created’
[16:09:27.939] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:27.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:27.944]   - Field: ‘label’
[16:09:27.944]   - Field: ‘local’
[16:09:27.945]   - Field: ‘owner’
[16:09:27.945]   - Field: ‘envir’
[16:09:27.945]   - Field: ‘workers’
[16:09:27.945]   - Field: ‘packages’
[16:09:27.945]   - Field: ‘gc’
[16:09:27.945]   - Field: ‘job’
[16:09:27.946]   - Field: ‘conditions’
[16:09:27.946]   - Field: ‘expr’
[16:09:27.946]   - Field: ‘uuid’
[16:09:27.946]   - Field: ‘seed’
[16:09:27.946]   - Field: ‘version’
[16:09:27.946]   - Field: ‘result’
[16:09:27.946]   - Field: ‘asynchronous’
[16:09:27.947]   - Field: ‘calls’
[16:09:27.947]   - Field: ‘globals’
[16:09:27.947]   - Field: ‘stdout’
[16:09:27.947]   - Field: ‘earlySignal’
[16:09:27.947]   - Field: ‘lazy’
[16:09:27.947]   - Field: ‘state’
[16:09:27.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:27.948] - Launch lazy future ...
[16:09:27.948] Packages needed by the future expression (n = 0): <none>
[16:09:27.948] Packages needed by future strategies (n = 0): <none>
[16:09:27.949] {
[16:09:27.949]     {
[16:09:27.949]         {
[16:09:27.949]             ...future.startTime <- base::Sys.time()
[16:09:27.949]             {
[16:09:27.949]                 {
[16:09:27.949]                   {
[16:09:27.949]                     {
[16:09:27.949]                       base::local({
[16:09:27.949]                         has_future <- base::requireNamespace("future", 
[16:09:27.949]                           quietly = TRUE)
[16:09:27.949]                         if (has_future) {
[16:09:27.949]                           ns <- base::getNamespace("future")
[16:09:27.949]                           version <- ns[[".package"]][["version"]]
[16:09:27.949]                           if (is.null(version)) 
[16:09:27.949]                             version <- utils::packageVersion("future")
[16:09:27.949]                         }
[16:09:27.949]                         else {
[16:09:27.949]                           version <- NULL
[16:09:27.949]                         }
[16:09:27.949]                         if (!has_future || version < "1.8.0") {
[16:09:27.949]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:27.949]                             "", base::R.version$version.string), 
[16:09:27.949]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:27.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:27.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:27.949]                               "release", "version")], collapse = " "), 
[16:09:27.949]                             hostname = base::Sys.info()[["nodename"]])
[16:09:27.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:27.949]                             info)
[16:09:27.949]                           info <- base::paste(info, collapse = "; ")
[16:09:27.949]                           if (!has_future) {
[16:09:27.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:27.949]                               info)
[16:09:27.949]                           }
[16:09:27.949]                           else {
[16:09:27.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:27.949]                               info, version)
[16:09:27.949]                           }
[16:09:27.949]                           base::stop(msg)
[16:09:27.949]                         }
[16:09:27.949]                       })
[16:09:27.949]                     }
[16:09:27.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:27.949]                     base::options(mc.cores = 1L)
[16:09:27.949]                   }
[16:09:27.949]                   options(future.plan = NULL)
[16:09:27.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:27.949]                 }
[16:09:27.949]                 ...future.workdir <- getwd()
[16:09:27.949]             }
[16:09:27.949]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:27.949]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:27.949]         }
[16:09:27.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:27.949]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:27.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:27.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:27.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:27.949]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:27.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:27.949]             base::names(...future.oldOptions))
[16:09:27.949]     }
[16:09:27.949]     if (FALSE) {
[16:09:27.949]     }
[16:09:27.949]     else {
[16:09:27.949]         if (TRUE) {
[16:09:27.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:27.949]                 open = "w")
[16:09:27.949]         }
[16:09:27.949]         else {
[16:09:27.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:27.949]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:27.949]         }
[16:09:27.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:27.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:27.949]             base::sink(type = "output", split = FALSE)
[16:09:27.949]             base::close(...future.stdout)
[16:09:27.949]         }, add = TRUE)
[16:09:27.949]     }
[16:09:27.949]     ...future.frame <- base::sys.nframe()
[16:09:27.949]     ...future.conditions <- base::list()
[16:09:27.949]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:27.949]     if (FALSE) {
[16:09:27.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:27.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:27.949]     }
[16:09:27.949]     ...future.result <- base::tryCatch({
[16:09:27.949]         base::withCallingHandlers({
[16:09:27.949]             ...future.value <- base::withVisible(base::local({
[16:09:27.949]                 withCallingHandlers({
[16:09:27.949]                   {
[16:09:27.949]                     do.call(function(...) {
[16:09:27.949]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.949]                       if (!identical(...future.globals.maxSize.org, 
[16:09:27.949]                         ...future.globals.maxSize)) {
[16:09:27.949]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.949]                         on.exit(options(oopts), add = TRUE)
[16:09:27.949]                       }
[16:09:27.949]                       {
[16:09:27.949]                         lapply(seq_along(...future.elements_ii), 
[16:09:27.949]                           FUN = function(jj) {
[16:09:27.949]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.949]                             ...future.FUN(...future.X_jj, ...)
[16:09:27.949]                           })
[16:09:27.949]                       }
[16:09:27.949]                     }, args = future.call.arguments)
[16:09:27.949]                   }
[16:09:27.949]                 }, immediateCondition = function(cond) {
[16:09:27.949]                   save_rds <- function (object, pathname, ...) 
[16:09:27.949]                   {
[16:09:27.949]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:27.949]                     if (file_test("-f", pathname_tmp)) {
[16:09:27.949]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.949]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:27.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.949]                         fi_tmp[["mtime"]])
[16:09:27.949]                     }
[16:09:27.949]                     tryCatch({
[16:09:27.949]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:27.949]                     }, error = function(ex) {
[16:09:27.949]                       msg <- conditionMessage(ex)
[16:09:27.949]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.949]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:27.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.949]                         fi_tmp[["mtime"]], msg)
[16:09:27.949]                       ex$message <- msg
[16:09:27.949]                       stop(ex)
[16:09:27.949]                     })
[16:09:27.949]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:27.949]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:27.949]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:27.949]                       fi_tmp <- file.info(pathname_tmp)
[16:09:27.949]                       fi <- file.info(pathname)
[16:09:27.949]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:27.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:27.949]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:27.949]                         fi[["size"]], fi[["mtime"]])
[16:09:27.949]                       stop(msg)
[16:09:27.949]                     }
[16:09:27.949]                     invisible(pathname)
[16:09:27.949]                   }
[16:09:27.949]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:27.949]                     rootPath = tempdir()) 
[16:09:27.949]                   {
[16:09:27.949]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:27.949]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:27.949]                       tmpdir = path, fileext = ".rds")
[16:09:27.949]                     save_rds(obj, file)
[16:09:27.949]                   }
[16:09:27.949]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:27.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.949]                   {
[16:09:27.949]                     inherits <- base::inherits
[16:09:27.949]                     invokeRestart <- base::invokeRestart
[16:09:27.949]                     is.null <- base::is.null
[16:09:27.949]                     muffled <- FALSE
[16:09:27.949]                     if (inherits(cond, "message")) {
[16:09:27.949]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:27.949]                       if (muffled) 
[16:09:27.949]                         invokeRestart("muffleMessage")
[16:09:27.949]                     }
[16:09:27.949]                     else if (inherits(cond, "warning")) {
[16:09:27.949]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:27.949]                       if (muffled) 
[16:09:27.949]                         invokeRestart("muffleWarning")
[16:09:27.949]                     }
[16:09:27.949]                     else if (inherits(cond, "condition")) {
[16:09:27.949]                       if (!is.null(pattern)) {
[16:09:27.949]                         computeRestarts <- base::computeRestarts
[16:09:27.949]                         grepl <- base::grepl
[16:09:27.949]                         restarts <- computeRestarts(cond)
[16:09:27.949]                         for (restart in restarts) {
[16:09:27.949]                           name <- restart$name
[16:09:27.949]                           if (is.null(name)) 
[16:09:27.949]                             next
[16:09:27.949]                           if (!grepl(pattern, name)) 
[16:09:27.949]                             next
[16:09:27.949]                           invokeRestart(restart)
[16:09:27.949]                           muffled <- TRUE
[16:09:27.949]                           break
[16:09:27.949]                         }
[16:09:27.949]                       }
[16:09:27.949]                     }
[16:09:27.949]                     invisible(muffled)
[16:09:27.949]                   }
[16:09:27.949]                   muffleCondition(cond)
[16:09:27.949]                 })
[16:09:27.949]             }))
[16:09:27.949]             future::FutureResult(value = ...future.value$value, 
[16:09:27.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.949]                   ...future.rng), globalenv = if (FALSE) 
[16:09:27.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:27.949]                     ...future.globalenv.names))
[16:09:27.949]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:27.949]         }, condition = base::local({
[16:09:27.949]             c <- base::c
[16:09:27.949]             inherits <- base::inherits
[16:09:27.949]             invokeRestart <- base::invokeRestart
[16:09:27.949]             length <- base::length
[16:09:27.949]             list <- base::list
[16:09:27.949]             seq.int <- base::seq.int
[16:09:27.949]             signalCondition <- base::signalCondition
[16:09:27.949]             sys.calls <- base::sys.calls
[16:09:27.949]             `[[` <- base::`[[`
[16:09:27.949]             `+` <- base::`+`
[16:09:27.949]             `<<-` <- base::`<<-`
[16:09:27.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:27.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:27.949]                   3L)]
[16:09:27.949]             }
[16:09:27.949]             function(cond) {
[16:09:27.949]                 is_error <- inherits(cond, "error")
[16:09:27.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:27.949]                   NULL)
[16:09:27.949]                 if (is_error) {
[16:09:27.949]                   sessionInformation <- function() {
[16:09:27.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:27.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:27.949]                       search = base::search(), system = base::Sys.info())
[16:09:27.949]                   }
[16:09:27.949]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:27.949]                     cond$call), session = sessionInformation(), 
[16:09:27.949]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:27.949]                   signalCondition(cond)
[16:09:27.949]                 }
[16:09:27.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:27.949]                 "immediateCondition"))) {
[16:09:27.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:27.949]                   ...future.conditions[[length(...future.conditions) + 
[16:09:27.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:27.949]                   if (TRUE && !signal) {
[16:09:27.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.949]                     {
[16:09:27.949]                       inherits <- base::inherits
[16:09:27.949]                       invokeRestart <- base::invokeRestart
[16:09:27.949]                       is.null <- base::is.null
[16:09:27.949]                       muffled <- FALSE
[16:09:27.949]                       if (inherits(cond, "message")) {
[16:09:27.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.949]                         if (muffled) 
[16:09:27.949]                           invokeRestart("muffleMessage")
[16:09:27.949]                       }
[16:09:27.949]                       else if (inherits(cond, "warning")) {
[16:09:27.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.949]                         if (muffled) 
[16:09:27.949]                           invokeRestart("muffleWarning")
[16:09:27.949]                       }
[16:09:27.949]                       else if (inherits(cond, "condition")) {
[16:09:27.949]                         if (!is.null(pattern)) {
[16:09:27.949]                           computeRestarts <- base::computeRestarts
[16:09:27.949]                           grepl <- base::grepl
[16:09:27.949]                           restarts <- computeRestarts(cond)
[16:09:27.949]                           for (restart in restarts) {
[16:09:27.949]                             name <- restart$name
[16:09:27.949]                             if (is.null(name)) 
[16:09:27.949]                               next
[16:09:27.949]                             if (!grepl(pattern, name)) 
[16:09:27.949]                               next
[16:09:27.949]                             invokeRestart(restart)
[16:09:27.949]                             muffled <- TRUE
[16:09:27.949]                             break
[16:09:27.949]                           }
[16:09:27.949]                         }
[16:09:27.949]                       }
[16:09:27.949]                       invisible(muffled)
[16:09:27.949]                     }
[16:09:27.949]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.949]                   }
[16:09:27.949]                 }
[16:09:27.949]                 else {
[16:09:27.949]                   if (TRUE) {
[16:09:27.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:27.949]                     {
[16:09:27.949]                       inherits <- base::inherits
[16:09:27.949]                       invokeRestart <- base::invokeRestart
[16:09:27.949]                       is.null <- base::is.null
[16:09:27.949]                       muffled <- FALSE
[16:09:27.949]                       if (inherits(cond, "message")) {
[16:09:27.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:27.949]                         if (muffled) 
[16:09:27.949]                           invokeRestart("muffleMessage")
[16:09:27.949]                       }
[16:09:27.949]                       else if (inherits(cond, "warning")) {
[16:09:27.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:27.949]                         if (muffled) 
[16:09:27.949]                           invokeRestart("muffleWarning")
[16:09:27.949]                       }
[16:09:27.949]                       else if (inherits(cond, "condition")) {
[16:09:27.949]                         if (!is.null(pattern)) {
[16:09:27.949]                           computeRestarts <- base::computeRestarts
[16:09:27.949]                           grepl <- base::grepl
[16:09:27.949]                           restarts <- computeRestarts(cond)
[16:09:27.949]                           for (restart in restarts) {
[16:09:27.949]                             name <- restart$name
[16:09:27.949]                             if (is.null(name)) 
[16:09:27.949]                               next
[16:09:27.949]                             if (!grepl(pattern, name)) 
[16:09:27.949]                               next
[16:09:27.949]                             invokeRestart(restart)
[16:09:27.949]                             muffled <- TRUE
[16:09:27.949]                             break
[16:09:27.949]                           }
[16:09:27.949]                         }
[16:09:27.949]                       }
[16:09:27.949]                       invisible(muffled)
[16:09:27.949]                     }
[16:09:27.949]                     muffleCondition(cond, pattern = "^muffle")
[16:09:27.949]                   }
[16:09:27.949]                 }
[16:09:27.949]             }
[16:09:27.949]         }))
[16:09:27.949]     }, error = function(ex) {
[16:09:27.949]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:27.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:27.949]                 ...future.rng), started = ...future.startTime, 
[16:09:27.949]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:27.949]             version = "1.8"), class = "FutureResult")
[16:09:27.949]     }, finally = {
[16:09:27.949]         if (!identical(...future.workdir, getwd())) 
[16:09:27.949]             setwd(...future.workdir)
[16:09:27.949]         {
[16:09:27.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:27.949]                 ...future.oldOptions$nwarnings <- NULL
[16:09:27.949]             }
[16:09:27.949]             base::options(...future.oldOptions)
[16:09:27.949]             if (.Platform$OS.type == "windows") {
[16:09:27.949]                 old_names <- names(...future.oldEnvVars)
[16:09:27.949]                 envs <- base::Sys.getenv()
[16:09:27.949]                 names <- names(envs)
[16:09:27.949]                 common <- intersect(names, old_names)
[16:09:27.949]                 added <- setdiff(names, old_names)
[16:09:27.949]                 removed <- setdiff(old_names, names)
[16:09:27.949]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:27.949]                   envs[common]]
[16:09:27.949]                 NAMES <- toupper(changed)
[16:09:27.949]                 args <- list()
[16:09:27.949]                 for (kk in seq_along(NAMES)) {
[16:09:27.949]                   name <- changed[[kk]]
[16:09:27.949]                   NAME <- NAMES[[kk]]
[16:09:27.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.949]                     next
[16:09:27.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.949]                 }
[16:09:27.949]                 NAMES <- toupper(added)
[16:09:27.949]                 for (kk in seq_along(NAMES)) {
[16:09:27.949]                   name <- added[[kk]]
[16:09:27.949]                   NAME <- NAMES[[kk]]
[16:09:27.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.949]                     next
[16:09:27.949]                   args[[name]] <- ""
[16:09:27.949]                 }
[16:09:27.949]                 NAMES <- toupper(removed)
[16:09:27.949]                 for (kk in seq_along(NAMES)) {
[16:09:27.949]                   name <- removed[[kk]]
[16:09:27.949]                   NAME <- NAMES[[kk]]
[16:09:27.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:27.949]                     next
[16:09:27.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:27.949]                 }
[16:09:27.949]                 if (length(args) > 0) 
[16:09:27.949]                   base::do.call(base::Sys.setenv, args = args)
[16:09:27.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:27.949]             }
[16:09:27.949]             else {
[16:09:27.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:27.949]             }
[16:09:27.949]             {
[16:09:27.949]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:27.949]                   0L) {
[16:09:27.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:27.949]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:27.949]                   base::options(opts)
[16:09:27.949]                 }
[16:09:27.949]                 {
[16:09:27.949]                   {
[16:09:27.949]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:27.949]                     NULL
[16:09:27.949]                   }
[16:09:27.949]                   options(future.plan = NULL)
[16:09:27.949]                   if (is.na(NA_character_)) 
[16:09:27.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:27.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:27.949]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:27.949]                     envir = parent.frame()) 
[16:09:27.949]                   {
[16:09:27.949]                     default_workers <- missing(workers)
[16:09:27.949]                     if (is.function(workers)) 
[16:09:27.949]                       workers <- workers()
[16:09:27.949]                     workers <- structure(as.integer(workers), 
[16:09:27.949]                       class = class(workers))
[16:09:27.949]                     stop_if_not(is.finite(workers), workers >= 
[16:09:27.949]                       1L)
[16:09:27.949]                     if ((workers == 1L && !inherits(workers, 
[16:09:27.949]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:27.949]                       if (default_workers) 
[16:09:27.949]                         supportsMulticore(warn = TRUE)
[16:09:27.949]                       return(sequential(..., envir = envir))
[16:09:27.949]                     }
[16:09:27.949]                     oopts <- options(mc.cores = workers)
[16:09:27.949]                     on.exit(options(oopts))
[16:09:27.949]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:27.949]                       envir = envir)
[16:09:27.949]                     if (!future$lazy) 
[16:09:27.949]                       future <- run(future)
[16:09:27.949]                     invisible(future)
[16:09:27.949]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:27.949]                 }
[16:09:27.949]             }
[16:09:27.949]         }
[16:09:27.949]     })
[16:09:27.949]     if (TRUE) {
[16:09:27.949]         base::sink(type = "output", split = FALSE)
[16:09:27.949]         if (TRUE) {
[16:09:27.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:27.949]         }
[16:09:27.949]         else {
[16:09:27.949]             ...future.result["stdout"] <- base::list(NULL)
[16:09:27.949]         }
[16:09:27.949]         base::close(...future.stdout)
[16:09:27.949]         ...future.stdout <- NULL
[16:09:27.949]     }
[16:09:27.949]     ...future.result$conditions <- ...future.conditions
[16:09:27.949]     ...future.result$finished <- base::Sys.time()
[16:09:27.949]     ...future.result
[16:09:27.949] }
[16:09:27.953] assign_globals() ...
[16:09:27.953] List of 5
[16:09:27.953]  $ future.call.arguments    : list()
[16:09:27.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:27.953]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:27.953]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:27.953]  $ ...future.elements_ii    :List of 1
[16:09:27.953]   ..$ : num [1:4] 2 4 6 8
[16:09:27.953]  $ ...future.seeds_ii       : NULL
[16:09:27.953]  $ ...future.globals.maxSize: NULL
[16:09:27.953]  - attr(*, "where")=List of 5
[16:09:27.953]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:27.953]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:27.953]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:27.953]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:27.953]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:27.953]  - attr(*, "resolved")= logi FALSE
[16:09:27.953]  - attr(*, "total_size")= num NA
[16:09:27.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:27.953]  - attr(*, "already-done")= logi TRUE
[16:09:27.967] - copied ‘future.call.arguments’ to environment
[16:09:27.968] - copied ‘...future.FUN’ to environment
[16:09:27.968] - copied ‘...future.elements_ii’ to environment
[16:09:27.968] - copied ‘...future.seeds_ii’ to environment
[16:09:27.968] - copied ‘...future.globals.maxSize’ to environment
[16:09:27.968] assign_globals() ... done
[16:09:27.968] requestCore(): workers = 2
[16:09:27.971] MulticoreFuture started
[16:09:27.972] - Launch lazy future ... done
[16:09:27.972] run() for ‘MulticoreFuture’ ... done
[16:09:27.972] Created future:
[16:09:27.973] plan(): Setting new future strategy stack:
[16:09:27.973] List of future strategies:
[16:09:27.973] 1. sequential:
[16:09:27.973]    - args: function (..., envir = parent.frame())
[16:09:27.973]    - tweaked: FALSE
[16:09:27.973]    - call: NULL
[16:09:27.974] plan(): nbrOfWorkers() = 1
[16:09:27.976] plan(): Setting new future strategy stack:
[16:09:27.977] List of future strategies:
[16:09:27.977] 1. multicore:
[16:09:27.977]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:27.977]    - tweaked: FALSE
[16:09:27.977]    - call: plan(strategy)
[16:09:27.982] plan(): nbrOfWorkers() = 2
[16:09:27.972] MulticoreFuture:
[16:09:27.972] Label: ‘future_apply-2’
[16:09:27.972] Expression:
[16:09:27.972] {
[16:09:27.972]     do.call(function(...) {
[16:09:27.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:27.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:27.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:27.972]             on.exit(options(oopts), add = TRUE)
[16:09:27.972]         }
[16:09:27.972]         {
[16:09:27.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:27.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:27.972]                 ...future.FUN(...future.X_jj, ...)
[16:09:27.972]             })
[16:09:27.972]         }
[16:09:27.972]     }, args = future.call.arguments)
[16:09:27.972] }
[16:09:27.972] Lazy evaluation: FALSE
[16:09:27.972] Asynchronous evaluation: TRUE
[16:09:27.972] Local evaluation: TRUE
[16:09:27.972] Environment: R_GlobalEnv
[16:09:27.972] Capture standard output: TRUE
[16:09:27.972] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:27.972] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:27.972] Packages: <none>
[16:09:27.972] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:27.972] Resolved: TRUE
[16:09:27.972] Value: <not collected>
[16:09:27.972] Conditions captured: <none>
[16:09:27.972] Early signaling: FALSE
[16:09:27.972] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:27.972] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:27.983] Chunk #2 of 2 ... DONE
[16:09:27.983] Launching 2 futures (chunks) ... DONE
[16:09:27.983] Resolving 2 futures (chunks) ...
[16:09:27.984] resolve() on list ...
[16:09:27.984]  recursive: 0
[16:09:27.984]  length: 2
[16:09:27.984] 
[16:09:27.984] Future #1
[16:09:27.985] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:27.986] - nx: 2
[16:09:27.986] - relay: TRUE
[16:09:27.986] - stdout: TRUE
[16:09:27.986] - signal: TRUE
[16:09:27.986] - resignal: FALSE
[16:09:27.986] - force: TRUE
[16:09:27.986] - relayed: [n=2] FALSE, FALSE
[16:09:27.987] - queued futures: [n=2] FALSE, FALSE
[16:09:27.987]  - until=1
[16:09:27.987]  - relaying element #1
[16:09:27.987] - relayed: [n=2] TRUE, FALSE
[16:09:27.987] - queued futures: [n=2] TRUE, FALSE
[16:09:27.988] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:27.988]  length: 1 (resolved future 1)
[16:09:27.988] Future #2
[16:09:27.989] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:27.989] - nx: 2
[16:09:27.989] - relay: TRUE
[16:09:27.989] - stdout: TRUE
[16:09:27.989] - signal: TRUE
[16:09:27.990] - resignal: FALSE
[16:09:27.990] - force: TRUE
[16:09:27.990] - relayed: [n=2] TRUE, FALSE
[16:09:27.990] - queued futures: [n=2] TRUE, FALSE
[16:09:27.990]  - until=2
[16:09:27.990]  - relaying element #2
[16:09:27.990] - relayed: [n=2] TRUE, TRUE
[16:09:27.991] - queued futures: [n=2] TRUE, TRUE
[16:09:27.991] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:27.991]  length: 0 (resolved future 2)
[16:09:27.991] Relaying remaining futures
[16:09:27.991] signalConditionsASAP(NULL, pos=0) ...
[16:09:27.991] - nx: 2
[16:09:27.991] - relay: TRUE
[16:09:27.991] - stdout: TRUE
[16:09:27.991] - signal: TRUE
[16:09:27.992] - resignal: FALSE
[16:09:27.992] - force: TRUE
[16:09:27.992] - relayed: [n=2] TRUE, TRUE
[16:09:27.992] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:27.992] - relayed: [n=2] TRUE, TRUE
[16:09:27.992] - queued futures: [n=2] TRUE, TRUE
[16:09:27.992] signalConditionsASAP(NULL, pos=0) ... done
[16:09:27.993] resolve() on list ... DONE
[16:09:27.993]  - Number of value chunks collected: 2
[16:09:27.993] Resolving 2 futures (chunks) ... DONE
[16:09:27.993] Reducing values from 2 chunks ...
[16:09:27.993]  - Number of values collected after concatenation: 2
[16:09:27.993]  - Number of values expected: 2
[16:09:27.993] Reducing values from 2 chunks ... DONE
[16:09:27.993] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:09:27.995] getGlobalsAndPackagesXApply() ...
[16:09:27.995]  - future.globals: TRUE
[16:09:27.995] getGlobalsAndPackages() ...
[16:09:27.995] Searching for globals...
[16:09:27.996] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:27.997] Searching for globals ... DONE
[16:09:27.997] Resolving globals: FALSE
[16:09:27.997] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:27.998] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:27.998] - globals: [1] ‘FUN’
[16:09:27.998] - packages: [1] ‘stats’
[16:09:27.998] getGlobalsAndPackages() ... DONE
[16:09:27.998]  - globals found/used: [n=1] ‘FUN’
[16:09:27.998]  - needed namespaces: [n=1] ‘stats’
[16:09:27.998] Finding globals ... DONE
[16:09:27.999]  - use_args: TRUE
[16:09:27.999]  - Getting '...' globals ...
[16:09:27.999] resolve() on list ...
[16:09:27.999]  recursive: 0
[16:09:27.999]  length: 1
[16:09:27.999]  elements: ‘...’
[16:09:27.999]  length: 0 (resolved future 1)
[16:09:28.000] resolve() on list ... DONE
[16:09:28.000]    - '...' content: [n=0] 
[16:09:28.000] List of 1
[16:09:28.000]  $ ...: list()
[16:09:28.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.000]  - attr(*, "where")=List of 1
[16:09:28.000]   ..$ ...:<environment: 0x5633ac3da4f8> 
[16:09:28.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.000]  - attr(*, "resolved")= logi TRUE
[16:09:28.000]  - attr(*, "total_size")= num NA
[16:09:28.008]  - Getting '...' globals ... DONE
[16:09:28.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.008] List of 2
[16:09:28.008]  $ ...future.FUN:function (x, ...)  
[16:09:28.008]  $ ...          : list()
[16:09:28.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.008]  - attr(*, "where")=List of 2
[16:09:28.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.008]   ..$ ...          :<environment: 0x5633ac3da4f8> 
[16:09:28.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.008]  - attr(*, "resolved")= logi FALSE
[16:09:28.008]  - attr(*, "total_size")= num 1248
[16:09:28.011] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:28.011] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.016] future_lapply() ...
[16:09:28.020] Number of chunks: 2
[16:09:28.020] getGlobalsAndPackagesXApply() ...
[16:09:28.020]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.020]  - use_args: TRUE
[16:09:28.021] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.021] List of 2
[16:09:28.021]  $ ...          : list()
[16:09:28.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.021]  $ ...future.FUN:function (x, ...)  
[16:09:28.021]  - attr(*, "where")=List of 2
[16:09:28.021]   ..$ ...          :<environment: 0x5633ac3da4f8> 
[16:09:28.021]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:09:28.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.021]  - attr(*, "resolved")= logi FALSE
[16:09:28.021]  - attr(*, "total_size")= num NA
[16:09:28.023] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:28.024] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.024] Number of futures (= number of chunks): 2
[16:09:28.024] Launching 2 futures (chunks) ...
[16:09:28.024] Chunk #1 of 2 ...
[16:09:28.024]  - seeds: <none>
[16:09:28.024] getGlobalsAndPackages() ...
[16:09:28.024] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.024] Resolving globals: FALSE
[16:09:28.025] Tweak future expression to call with '...' arguments ...
[16:09:28.025] {
[16:09:28.025]     do.call(function(...) {
[16:09:28.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.025]             on.exit(options(oopts), add = TRUE)
[16:09:28.025]         }
[16:09:28.025]         {
[16:09:28.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.025]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.025]             })
[16:09:28.025]         }
[16:09:28.025]     }, args = future.call.arguments)
[16:09:28.025] }
[16:09:28.025] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.025] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.026] - packages: [1] ‘stats’
[16:09:28.026] getGlobalsAndPackages() ... DONE
[16:09:28.026] run() for ‘Future’ ...
[16:09:28.026] - state: ‘created’
[16:09:28.026] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.030] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.030] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.030]   - Field: ‘label’
[16:09:28.030]   - Field: ‘local’
[16:09:28.030]   - Field: ‘owner’
[16:09:28.030]   - Field: ‘envir’
[16:09:28.030]   - Field: ‘workers’
[16:09:28.030]   - Field: ‘packages’
[16:09:28.031]   - Field: ‘gc’
[16:09:28.031]   - Field: ‘job’
[16:09:28.031]   - Field: ‘conditions’
[16:09:28.031]   - Field: ‘expr’
[16:09:28.031]   - Field: ‘uuid’
[16:09:28.031]   - Field: ‘seed’
[16:09:28.031]   - Field: ‘version’
[16:09:28.031]   - Field: ‘result’
[16:09:28.031]   - Field: ‘asynchronous’
[16:09:28.031]   - Field: ‘calls’
[16:09:28.032]   - Field: ‘globals’
[16:09:28.032]   - Field: ‘stdout’
[16:09:28.032]   - Field: ‘earlySignal’
[16:09:28.032]   - Field: ‘lazy’
[16:09:28.032]   - Field: ‘state’
[16:09:28.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.032] - Launch lazy future ...
[16:09:28.032] Packages needed by the future expression (n = 1): ‘stats’
[16:09:28.033] Packages needed by future strategies (n = 0): <none>
[16:09:28.033] {
[16:09:28.033]     {
[16:09:28.033]         {
[16:09:28.033]             ...future.startTime <- base::Sys.time()
[16:09:28.033]             {
[16:09:28.033]                 {
[16:09:28.033]                   {
[16:09:28.033]                     {
[16:09:28.033]                       {
[16:09:28.033]                         base::local({
[16:09:28.033]                           has_future <- base::requireNamespace("future", 
[16:09:28.033]                             quietly = TRUE)
[16:09:28.033]                           if (has_future) {
[16:09:28.033]                             ns <- base::getNamespace("future")
[16:09:28.033]                             version <- ns[[".package"]][["version"]]
[16:09:28.033]                             if (is.null(version)) 
[16:09:28.033]                               version <- utils::packageVersion("future")
[16:09:28.033]                           }
[16:09:28.033]                           else {
[16:09:28.033]                             version <- NULL
[16:09:28.033]                           }
[16:09:28.033]                           if (!has_future || version < "1.8.0") {
[16:09:28.033]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.033]                               "", base::R.version$version.string), 
[16:09:28.033]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:28.033]                                 base::R.version$platform, 8 * 
[16:09:28.033]                                   base::.Machine$sizeof.pointer), 
[16:09:28.033]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.033]                                 "release", "version")], collapse = " "), 
[16:09:28.033]                               hostname = base::Sys.info()[["nodename"]])
[16:09:28.033]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.033]                               info)
[16:09:28.033]                             info <- base::paste(info, collapse = "; ")
[16:09:28.033]                             if (!has_future) {
[16:09:28.033]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.033]                                 info)
[16:09:28.033]                             }
[16:09:28.033]                             else {
[16:09:28.033]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.033]                                 info, version)
[16:09:28.033]                             }
[16:09:28.033]                             base::stop(msg)
[16:09:28.033]                           }
[16:09:28.033]                         })
[16:09:28.033]                       }
[16:09:28.033]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.033]                       base::options(mc.cores = 1L)
[16:09:28.033]                     }
[16:09:28.033]                     base::local({
[16:09:28.033]                       for (pkg in "stats") {
[16:09:28.033]                         base::loadNamespace(pkg)
[16:09:28.033]                         base::library(pkg, character.only = TRUE)
[16:09:28.033]                       }
[16:09:28.033]                     })
[16:09:28.033]                   }
[16:09:28.033]                   options(future.plan = NULL)
[16:09:28.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.033]                 }
[16:09:28.033]                 ...future.workdir <- getwd()
[16:09:28.033]             }
[16:09:28.033]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.033]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.033]         }
[16:09:28.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.033]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.033]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.033]             base::names(...future.oldOptions))
[16:09:28.033]     }
[16:09:28.033]     if (FALSE) {
[16:09:28.033]     }
[16:09:28.033]     else {
[16:09:28.033]         if (TRUE) {
[16:09:28.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.033]                 open = "w")
[16:09:28.033]         }
[16:09:28.033]         else {
[16:09:28.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.033]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.033]         }
[16:09:28.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.033]             base::sink(type = "output", split = FALSE)
[16:09:28.033]             base::close(...future.stdout)
[16:09:28.033]         }, add = TRUE)
[16:09:28.033]     }
[16:09:28.033]     ...future.frame <- base::sys.nframe()
[16:09:28.033]     ...future.conditions <- base::list()
[16:09:28.033]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.033]     if (FALSE) {
[16:09:28.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.033]     }
[16:09:28.033]     ...future.result <- base::tryCatch({
[16:09:28.033]         base::withCallingHandlers({
[16:09:28.033]             ...future.value <- base::withVisible(base::local({
[16:09:28.033]                 withCallingHandlers({
[16:09:28.033]                   {
[16:09:28.033]                     do.call(function(...) {
[16:09:28.033]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.033]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.033]                         ...future.globals.maxSize)) {
[16:09:28.033]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.033]                         on.exit(options(oopts), add = TRUE)
[16:09:28.033]                       }
[16:09:28.033]                       {
[16:09:28.033]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.033]                           FUN = function(jj) {
[16:09:28.033]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.033]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.033]                           })
[16:09:28.033]                       }
[16:09:28.033]                     }, args = future.call.arguments)
[16:09:28.033]                   }
[16:09:28.033]                 }, immediateCondition = function(cond) {
[16:09:28.033]                   save_rds <- function (object, pathname, ...) 
[16:09:28.033]                   {
[16:09:28.033]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.033]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.033]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.033]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.033]                         fi_tmp[["mtime"]])
[16:09:28.033]                     }
[16:09:28.033]                     tryCatch({
[16:09:28.033]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.033]                     }, error = function(ex) {
[16:09:28.033]                       msg <- conditionMessage(ex)
[16:09:28.033]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.033]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.033]                         fi_tmp[["mtime"]], msg)
[16:09:28.033]                       ex$message <- msg
[16:09:28.033]                       stop(ex)
[16:09:28.033]                     })
[16:09:28.033]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.033]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.033]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.033]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.033]                       fi <- file.info(pathname)
[16:09:28.033]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.033]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.033]                         fi[["size"]], fi[["mtime"]])
[16:09:28.033]                       stop(msg)
[16:09:28.033]                     }
[16:09:28.033]                     invisible(pathname)
[16:09:28.033]                   }
[16:09:28.033]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.033]                     rootPath = tempdir()) 
[16:09:28.033]                   {
[16:09:28.033]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.033]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.033]                       tmpdir = path, fileext = ".rds")
[16:09:28.033]                     save_rds(obj, file)
[16:09:28.033]                   }
[16:09:28.033]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.033]                   {
[16:09:28.033]                     inherits <- base::inherits
[16:09:28.033]                     invokeRestart <- base::invokeRestart
[16:09:28.033]                     is.null <- base::is.null
[16:09:28.033]                     muffled <- FALSE
[16:09:28.033]                     if (inherits(cond, "message")) {
[16:09:28.033]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.033]                       if (muffled) 
[16:09:28.033]                         invokeRestart("muffleMessage")
[16:09:28.033]                     }
[16:09:28.033]                     else if (inherits(cond, "warning")) {
[16:09:28.033]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.033]                       if (muffled) 
[16:09:28.033]                         invokeRestart("muffleWarning")
[16:09:28.033]                     }
[16:09:28.033]                     else if (inherits(cond, "condition")) {
[16:09:28.033]                       if (!is.null(pattern)) {
[16:09:28.033]                         computeRestarts <- base::computeRestarts
[16:09:28.033]                         grepl <- base::grepl
[16:09:28.033]                         restarts <- computeRestarts(cond)
[16:09:28.033]                         for (restart in restarts) {
[16:09:28.033]                           name <- restart$name
[16:09:28.033]                           if (is.null(name)) 
[16:09:28.033]                             next
[16:09:28.033]                           if (!grepl(pattern, name)) 
[16:09:28.033]                             next
[16:09:28.033]                           invokeRestart(restart)
[16:09:28.033]                           muffled <- TRUE
[16:09:28.033]                           break
[16:09:28.033]                         }
[16:09:28.033]                       }
[16:09:28.033]                     }
[16:09:28.033]                     invisible(muffled)
[16:09:28.033]                   }
[16:09:28.033]                   muffleCondition(cond)
[16:09:28.033]                 })
[16:09:28.033]             }))
[16:09:28.033]             future::FutureResult(value = ...future.value$value, 
[16:09:28.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.033]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.033]                     ...future.globalenv.names))
[16:09:28.033]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.033]         }, condition = base::local({
[16:09:28.033]             c <- base::c
[16:09:28.033]             inherits <- base::inherits
[16:09:28.033]             invokeRestart <- base::invokeRestart
[16:09:28.033]             length <- base::length
[16:09:28.033]             list <- base::list
[16:09:28.033]             seq.int <- base::seq.int
[16:09:28.033]             signalCondition <- base::signalCondition
[16:09:28.033]             sys.calls <- base::sys.calls
[16:09:28.033]             `[[` <- base::`[[`
[16:09:28.033]             `+` <- base::`+`
[16:09:28.033]             `<<-` <- base::`<<-`
[16:09:28.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.033]                   3L)]
[16:09:28.033]             }
[16:09:28.033]             function(cond) {
[16:09:28.033]                 is_error <- inherits(cond, "error")
[16:09:28.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.033]                   NULL)
[16:09:28.033]                 if (is_error) {
[16:09:28.033]                   sessionInformation <- function() {
[16:09:28.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.033]                       search = base::search(), system = base::Sys.info())
[16:09:28.033]                   }
[16:09:28.033]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.033]                     cond$call), session = sessionInformation(), 
[16:09:28.033]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.033]                   signalCondition(cond)
[16:09:28.033]                 }
[16:09:28.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.033]                 "immediateCondition"))) {
[16:09:28.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.033]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.033]                   if (TRUE && !signal) {
[16:09:28.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.033]                     {
[16:09:28.033]                       inherits <- base::inherits
[16:09:28.033]                       invokeRestart <- base::invokeRestart
[16:09:28.033]                       is.null <- base::is.null
[16:09:28.033]                       muffled <- FALSE
[16:09:28.033]                       if (inherits(cond, "message")) {
[16:09:28.033]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.033]                         if (muffled) 
[16:09:28.033]                           invokeRestart("muffleMessage")
[16:09:28.033]                       }
[16:09:28.033]                       else if (inherits(cond, "warning")) {
[16:09:28.033]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.033]                         if (muffled) 
[16:09:28.033]                           invokeRestart("muffleWarning")
[16:09:28.033]                       }
[16:09:28.033]                       else if (inherits(cond, "condition")) {
[16:09:28.033]                         if (!is.null(pattern)) {
[16:09:28.033]                           computeRestarts <- base::computeRestarts
[16:09:28.033]                           grepl <- base::grepl
[16:09:28.033]                           restarts <- computeRestarts(cond)
[16:09:28.033]                           for (restart in restarts) {
[16:09:28.033]                             name <- restart$name
[16:09:28.033]                             if (is.null(name)) 
[16:09:28.033]                               next
[16:09:28.033]                             if (!grepl(pattern, name)) 
[16:09:28.033]                               next
[16:09:28.033]                             invokeRestart(restart)
[16:09:28.033]                             muffled <- TRUE
[16:09:28.033]                             break
[16:09:28.033]                           }
[16:09:28.033]                         }
[16:09:28.033]                       }
[16:09:28.033]                       invisible(muffled)
[16:09:28.033]                     }
[16:09:28.033]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.033]                   }
[16:09:28.033]                 }
[16:09:28.033]                 else {
[16:09:28.033]                   if (TRUE) {
[16:09:28.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.033]                     {
[16:09:28.033]                       inherits <- base::inherits
[16:09:28.033]                       invokeRestart <- base::invokeRestart
[16:09:28.033]                       is.null <- base::is.null
[16:09:28.033]                       muffled <- FALSE
[16:09:28.033]                       if (inherits(cond, "message")) {
[16:09:28.033]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.033]                         if (muffled) 
[16:09:28.033]                           invokeRestart("muffleMessage")
[16:09:28.033]                       }
[16:09:28.033]                       else if (inherits(cond, "warning")) {
[16:09:28.033]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.033]                         if (muffled) 
[16:09:28.033]                           invokeRestart("muffleWarning")
[16:09:28.033]                       }
[16:09:28.033]                       else if (inherits(cond, "condition")) {
[16:09:28.033]                         if (!is.null(pattern)) {
[16:09:28.033]                           computeRestarts <- base::computeRestarts
[16:09:28.033]                           grepl <- base::grepl
[16:09:28.033]                           restarts <- computeRestarts(cond)
[16:09:28.033]                           for (restart in restarts) {
[16:09:28.033]                             name <- restart$name
[16:09:28.033]                             if (is.null(name)) 
[16:09:28.033]                               next
[16:09:28.033]                             if (!grepl(pattern, name)) 
[16:09:28.033]                               next
[16:09:28.033]                             invokeRestart(restart)
[16:09:28.033]                             muffled <- TRUE
[16:09:28.033]                             break
[16:09:28.033]                           }
[16:09:28.033]                         }
[16:09:28.033]                       }
[16:09:28.033]                       invisible(muffled)
[16:09:28.033]                     }
[16:09:28.033]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.033]                   }
[16:09:28.033]                 }
[16:09:28.033]             }
[16:09:28.033]         }))
[16:09:28.033]     }, error = function(ex) {
[16:09:28.033]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.033]                 ...future.rng), started = ...future.startTime, 
[16:09:28.033]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.033]             version = "1.8"), class = "FutureResult")
[16:09:28.033]     }, finally = {
[16:09:28.033]         if (!identical(...future.workdir, getwd())) 
[16:09:28.033]             setwd(...future.workdir)
[16:09:28.033]         {
[16:09:28.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.033]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.033]             }
[16:09:28.033]             base::options(...future.oldOptions)
[16:09:28.033]             if (.Platform$OS.type == "windows") {
[16:09:28.033]                 old_names <- names(...future.oldEnvVars)
[16:09:28.033]                 envs <- base::Sys.getenv()
[16:09:28.033]                 names <- names(envs)
[16:09:28.033]                 common <- intersect(names, old_names)
[16:09:28.033]                 added <- setdiff(names, old_names)
[16:09:28.033]                 removed <- setdiff(old_names, names)
[16:09:28.033]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.033]                   envs[common]]
[16:09:28.033]                 NAMES <- toupper(changed)
[16:09:28.033]                 args <- list()
[16:09:28.033]                 for (kk in seq_along(NAMES)) {
[16:09:28.033]                   name <- changed[[kk]]
[16:09:28.033]                   NAME <- NAMES[[kk]]
[16:09:28.033]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.033]                     next
[16:09:28.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.033]                 }
[16:09:28.033]                 NAMES <- toupper(added)
[16:09:28.033]                 for (kk in seq_along(NAMES)) {
[16:09:28.033]                   name <- added[[kk]]
[16:09:28.033]                   NAME <- NAMES[[kk]]
[16:09:28.033]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.033]                     next
[16:09:28.033]                   args[[name]] <- ""
[16:09:28.033]                 }
[16:09:28.033]                 NAMES <- toupper(removed)
[16:09:28.033]                 for (kk in seq_along(NAMES)) {
[16:09:28.033]                   name <- removed[[kk]]
[16:09:28.033]                   NAME <- NAMES[[kk]]
[16:09:28.033]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.033]                     next
[16:09:28.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.033]                 }
[16:09:28.033]                 if (length(args) > 0) 
[16:09:28.033]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.033]             }
[16:09:28.033]             else {
[16:09:28.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.033]             }
[16:09:28.033]             {
[16:09:28.033]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.033]                   0L) {
[16:09:28.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.033]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.033]                   base::options(opts)
[16:09:28.033]                 }
[16:09:28.033]                 {
[16:09:28.033]                   {
[16:09:28.033]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.033]                     NULL
[16:09:28.033]                   }
[16:09:28.033]                   options(future.plan = NULL)
[16:09:28.033]                   if (is.na(NA_character_)) 
[16:09:28.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.033]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.033]                     envir = parent.frame()) 
[16:09:28.033]                   {
[16:09:28.033]                     default_workers <- missing(workers)
[16:09:28.033]                     if (is.function(workers)) 
[16:09:28.033]                       workers <- workers()
[16:09:28.033]                     workers <- structure(as.integer(workers), 
[16:09:28.033]                       class = class(workers))
[16:09:28.033]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.033]                       1L)
[16:09:28.033]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.033]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.033]                       if (default_workers) 
[16:09:28.033]                         supportsMulticore(warn = TRUE)
[16:09:28.033]                       return(sequential(..., envir = envir))
[16:09:28.033]                     }
[16:09:28.033]                     oopts <- options(mc.cores = workers)
[16:09:28.033]                     on.exit(options(oopts))
[16:09:28.033]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.033]                       envir = envir)
[16:09:28.033]                     if (!future$lazy) 
[16:09:28.033]                       future <- run(future)
[16:09:28.033]                     invisible(future)
[16:09:28.033]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.033]                 }
[16:09:28.033]             }
[16:09:28.033]         }
[16:09:28.033]     })
[16:09:28.033]     if (TRUE) {
[16:09:28.033]         base::sink(type = "output", split = FALSE)
[16:09:28.033]         if (TRUE) {
[16:09:28.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.033]         }
[16:09:28.033]         else {
[16:09:28.033]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.033]         }
[16:09:28.033]         base::close(...future.stdout)
[16:09:28.033]         ...future.stdout <- NULL
[16:09:28.033]     }
[16:09:28.033]     ...future.result$conditions <- ...future.conditions
[16:09:28.033]     ...future.result$finished <- base::Sys.time()
[16:09:28.033]     ...future.result
[16:09:28.033] }
[16:09:28.036] assign_globals() ...
[16:09:28.036] List of 5
[16:09:28.036]  $ future.call.arguments    : list()
[16:09:28.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.036]  $ ...future.FUN            :function (x, ...)  
[16:09:28.036]  $ ...future.elements_ii    :List of 1
[16:09:28.036]   ..$ : num [1:4] 1 3 1 7
[16:09:28.036]  $ ...future.seeds_ii       : NULL
[16:09:28.036]  $ ...future.globals.maxSize: NULL
[16:09:28.036]  - attr(*, "where")=List of 5
[16:09:28.036]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.036]  - attr(*, "resolved")= logi FALSE
[16:09:28.036]  - attr(*, "total_size")= num NA
[16:09:28.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.036]  - attr(*, "already-done")= logi TRUE
[16:09:28.043] - copied ‘future.call.arguments’ to environment
[16:09:28.043] - copied ‘...future.FUN’ to environment
[16:09:28.043] - copied ‘...future.elements_ii’ to environment
[16:09:28.043] - copied ‘...future.seeds_ii’ to environment
[16:09:28.043] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.043] assign_globals() ... done
[16:09:28.043] requestCore(): workers = 2
[16:09:28.045] MulticoreFuture started
[16:09:28.046] - Launch lazy future ... done
[16:09:28.046] run() for ‘MulticoreFuture’ ... done
[16:09:28.047] Created future:
[16:09:28.047] plan(): Setting new future strategy stack:
[16:09:28.047] List of future strategies:
[16:09:28.047] 1. sequential:
[16:09:28.047]    - args: function (..., envir = parent.frame())
[16:09:28.047]    - tweaked: FALSE
[16:09:28.047]    - call: NULL
[16:09:28.048] plan(): nbrOfWorkers() = 1
[16:09:28.051] plan(): Setting new future strategy stack:
[16:09:28.051] List of future strategies:
[16:09:28.051] 1. multicore:
[16:09:28.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.051]    - tweaked: FALSE
[16:09:28.051]    - call: plan(strategy)
[16:09:28.057] plan(): nbrOfWorkers() = 2
[16:09:28.047] MulticoreFuture:
[16:09:28.047] Label: ‘future_apply-1’
[16:09:28.047] Expression:
[16:09:28.047] {
[16:09:28.047]     do.call(function(...) {
[16:09:28.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.047]             on.exit(options(oopts), add = TRUE)
[16:09:28.047]         }
[16:09:28.047]         {
[16:09:28.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.047]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.047]             })
[16:09:28.047]         }
[16:09:28.047]     }, args = future.call.arguments)
[16:09:28.047] }
[16:09:28.047] Lazy evaluation: FALSE
[16:09:28.047] Asynchronous evaluation: TRUE
[16:09:28.047] Local evaluation: TRUE
[16:09:28.047] Environment: R_GlobalEnv
[16:09:28.047] Capture standard output: TRUE
[16:09:28.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.047] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.047] Packages: 1 packages (‘stats’)
[16:09:28.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.047] Resolved: TRUE
[16:09:28.047] Value: <not collected>
[16:09:28.047] Conditions captured: <none>
[16:09:28.047] Early signaling: FALSE
[16:09:28.047] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.047] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.058] Chunk #1 of 2 ... DONE
[16:09:28.058] Chunk #2 of 2 ...
[16:09:28.059]  - seeds: <none>
[16:09:28.059] getGlobalsAndPackages() ...
[16:09:28.059] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.059] Resolving globals: FALSE
[16:09:28.059] Tweak future expression to call with '...' arguments ...
[16:09:28.059] {
[16:09:28.059]     do.call(function(...) {
[16:09:28.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.059]             on.exit(options(oopts), add = TRUE)
[16:09:28.059]         }
[16:09:28.059]         {
[16:09:28.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.059]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.059]             })
[16:09:28.059]         }
[16:09:28.059]     }, args = future.call.arguments)
[16:09:28.059] }
[16:09:28.060] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.061] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.061] - packages: [1] ‘stats’
[16:09:28.061] getGlobalsAndPackages() ... DONE
[16:09:28.061] run() for ‘Future’ ...
[16:09:28.062] - state: ‘created’
[16:09:28.062] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.067] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.067]   - Field: ‘label’
[16:09:28.067]   - Field: ‘local’
[16:09:28.067]   - Field: ‘owner’
[16:09:28.067]   - Field: ‘envir’
[16:09:28.068]   - Field: ‘workers’
[16:09:28.068]   - Field: ‘packages’
[16:09:28.068]   - Field: ‘gc’
[16:09:28.068]   - Field: ‘job’
[16:09:28.068]   - Field: ‘conditions’
[16:09:28.068]   - Field: ‘expr’
[16:09:28.069]   - Field: ‘uuid’
[16:09:28.069]   - Field: ‘seed’
[16:09:28.069]   - Field: ‘version’
[16:09:28.069]   - Field: ‘result’
[16:09:28.069]   - Field: ‘asynchronous’
[16:09:28.069]   - Field: ‘calls’
[16:09:28.069]   - Field: ‘globals’
[16:09:28.070]   - Field: ‘stdout’
[16:09:28.070]   - Field: ‘earlySignal’
[16:09:28.070]   - Field: ‘lazy’
[16:09:28.070]   - Field: ‘state’
[16:09:28.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.070] - Launch lazy future ...
[16:09:28.071] Packages needed by the future expression (n = 1): ‘stats’
[16:09:28.071] Packages needed by future strategies (n = 0): <none>
[16:09:28.072] {
[16:09:28.072]     {
[16:09:28.072]         {
[16:09:28.072]             ...future.startTime <- base::Sys.time()
[16:09:28.072]             {
[16:09:28.072]                 {
[16:09:28.072]                   {
[16:09:28.072]                     {
[16:09:28.072]                       {
[16:09:28.072]                         base::local({
[16:09:28.072]                           has_future <- base::requireNamespace("future", 
[16:09:28.072]                             quietly = TRUE)
[16:09:28.072]                           if (has_future) {
[16:09:28.072]                             ns <- base::getNamespace("future")
[16:09:28.072]                             version <- ns[[".package"]][["version"]]
[16:09:28.072]                             if (is.null(version)) 
[16:09:28.072]                               version <- utils::packageVersion("future")
[16:09:28.072]                           }
[16:09:28.072]                           else {
[16:09:28.072]                             version <- NULL
[16:09:28.072]                           }
[16:09:28.072]                           if (!has_future || version < "1.8.0") {
[16:09:28.072]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.072]                               "", base::R.version$version.string), 
[16:09:28.072]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:28.072]                                 base::R.version$platform, 8 * 
[16:09:28.072]                                   base::.Machine$sizeof.pointer), 
[16:09:28.072]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.072]                                 "release", "version")], collapse = " "), 
[16:09:28.072]                               hostname = base::Sys.info()[["nodename"]])
[16:09:28.072]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.072]                               info)
[16:09:28.072]                             info <- base::paste(info, collapse = "; ")
[16:09:28.072]                             if (!has_future) {
[16:09:28.072]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.072]                                 info)
[16:09:28.072]                             }
[16:09:28.072]                             else {
[16:09:28.072]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.072]                                 info, version)
[16:09:28.072]                             }
[16:09:28.072]                             base::stop(msg)
[16:09:28.072]                           }
[16:09:28.072]                         })
[16:09:28.072]                       }
[16:09:28.072]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.072]                       base::options(mc.cores = 1L)
[16:09:28.072]                     }
[16:09:28.072]                     base::local({
[16:09:28.072]                       for (pkg in "stats") {
[16:09:28.072]                         base::loadNamespace(pkg)
[16:09:28.072]                         base::library(pkg, character.only = TRUE)
[16:09:28.072]                       }
[16:09:28.072]                     })
[16:09:28.072]                   }
[16:09:28.072]                   options(future.plan = NULL)
[16:09:28.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.072]                 }
[16:09:28.072]                 ...future.workdir <- getwd()
[16:09:28.072]             }
[16:09:28.072]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.072]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.072]         }
[16:09:28.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.072]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.072]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.072]             base::names(...future.oldOptions))
[16:09:28.072]     }
[16:09:28.072]     if (FALSE) {
[16:09:28.072]     }
[16:09:28.072]     else {
[16:09:28.072]         if (TRUE) {
[16:09:28.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.072]                 open = "w")
[16:09:28.072]         }
[16:09:28.072]         else {
[16:09:28.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.072]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.072]         }
[16:09:28.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.072]             base::sink(type = "output", split = FALSE)
[16:09:28.072]             base::close(...future.stdout)
[16:09:28.072]         }, add = TRUE)
[16:09:28.072]     }
[16:09:28.072]     ...future.frame <- base::sys.nframe()
[16:09:28.072]     ...future.conditions <- base::list()
[16:09:28.072]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.072]     if (FALSE) {
[16:09:28.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.072]     }
[16:09:28.072]     ...future.result <- base::tryCatch({
[16:09:28.072]         base::withCallingHandlers({
[16:09:28.072]             ...future.value <- base::withVisible(base::local({
[16:09:28.072]                 withCallingHandlers({
[16:09:28.072]                   {
[16:09:28.072]                     do.call(function(...) {
[16:09:28.072]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.072]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.072]                         ...future.globals.maxSize)) {
[16:09:28.072]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.072]                         on.exit(options(oopts), add = TRUE)
[16:09:28.072]                       }
[16:09:28.072]                       {
[16:09:28.072]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.072]                           FUN = function(jj) {
[16:09:28.072]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.072]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.072]                           })
[16:09:28.072]                       }
[16:09:28.072]                     }, args = future.call.arguments)
[16:09:28.072]                   }
[16:09:28.072]                 }, immediateCondition = function(cond) {
[16:09:28.072]                   save_rds <- function (object, pathname, ...) 
[16:09:28.072]                   {
[16:09:28.072]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.072]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.072]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.072]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.072]                         fi_tmp[["mtime"]])
[16:09:28.072]                     }
[16:09:28.072]                     tryCatch({
[16:09:28.072]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.072]                     }, error = function(ex) {
[16:09:28.072]                       msg <- conditionMessage(ex)
[16:09:28.072]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.072]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.072]                         fi_tmp[["mtime"]], msg)
[16:09:28.072]                       ex$message <- msg
[16:09:28.072]                       stop(ex)
[16:09:28.072]                     })
[16:09:28.072]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.072]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.072]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.072]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.072]                       fi <- file.info(pathname)
[16:09:28.072]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.072]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.072]                         fi[["size"]], fi[["mtime"]])
[16:09:28.072]                       stop(msg)
[16:09:28.072]                     }
[16:09:28.072]                     invisible(pathname)
[16:09:28.072]                   }
[16:09:28.072]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.072]                     rootPath = tempdir()) 
[16:09:28.072]                   {
[16:09:28.072]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.072]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.072]                       tmpdir = path, fileext = ".rds")
[16:09:28.072]                     save_rds(obj, file)
[16:09:28.072]                   }
[16:09:28.072]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.072]                   {
[16:09:28.072]                     inherits <- base::inherits
[16:09:28.072]                     invokeRestart <- base::invokeRestart
[16:09:28.072]                     is.null <- base::is.null
[16:09:28.072]                     muffled <- FALSE
[16:09:28.072]                     if (inherits(cond, "message")) {
[16:09:28.072]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.072]                       if (muffled) 
[16:09:28.072]                         invokeRestart("muffleMessage")
[16:09:28.072]                     }
[16:09:28.072]                     else if (inherits(cond, "warning")) {
[16:09:28.072]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.072]                       if (muffled) 
[16:09:28.072]                         invokeRestart("muffleWarning")
[16:09:28.072]                     }
[16:09:28.072]                     else if (inherits(cond, "condition")) {
[16:09:28.072]                       if (!is.null(pattern)) {
[16:09:28.072]                         computeRestarts <- base::computeRestarts
[16:09:28.072]                         grepl <- base::grepl
[16:09:28.072]                         restarts <- computeRestarts(cond)
[16:09:28.072]                         for (restart in restarts) {
[16:09:28.072]                           name <- restart$name
[16:09:28.072]                           if (is.null(name)) 
[16:09:28.072]                             next
[16:09:28.072]                           if (!grepl(pattern, name)) 
[16:09:28.072]                             next
[16:09:28.072]                           invokeRestart(restart)
[16:09:28.072]                           muffled <- TRUE
[16:09:28.072]                           break
[16:09:28.072]                         }
[16:09:28.072]                       }
[16:09:28.072]                     }
[16:09:28.072]                     invisible(muffled)
[16:09:28.072]                   }
[16:09:28.072]                   muffleCondition(cond)
[16:09:28.072]                 })
[16:09:28.072]             }))
[16:09:28.072]             future::FutureResult(value = ...future.value$value, 
[16:09:28.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.072]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.072]                     ...future.globalenv.names))
[16:09:28.072]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.072]         }, condition = base::local({
[16:09:28.072]             c <- base::c
[16:09:28.072]             inherits <- base::inherits
[16:09:28.072]             invokeRestart <- base::invokeRestart
[16:09:28.072]             length <- base::length
[16:09:28.072]             list <- base::list
[16:09:28.072]             seq.int <- base::seq.int
[16:09:28.072]             signalCondition <- base::signalCondition
[16:09:28.072]             sys.calls <- base::sys.calls
[16:09:28.072]             `[[` <- base::`[[`
[16:09:28.072]             `+` <- base::`+`
[16:09:28.072]             `<<-` <- base::`<<-`
[16:09:28.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.072]                   3L)]
[16:09:28.072]             }
[16:09:28.072]             function(cond) {
[16:09:28.072]                 is_error <- inherits(cond, "error")
[16:09:28.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.072]                   NULL)
[16:09:28.072]                 if (is_error) {
[16:09:28.072]                   sessionInformation <- function() {
[16:09:28.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.072]                       search = base::search(), system = base::Sys.info())
[16:09:28.072]                   }
[16:09:28.072]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.072]                     cond$call), session = sessionInformation(), 
[16:09:28.072]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.072]                   signalCondition(cond)
[16:09:28.072]                 }
[16:09:28.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.072]                 "immediateCondition"))) {
[16:09:28.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.072]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.072]                   if (TRUE && !signal) {
[16:09:28.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.072]                     {
[16:09:28.072]                       inherits <- base::inherits
[16:09:28.072]                       invokeRestart <- base::invokeRestart
[16:09:28.072]                       is.null <- base::is.null
[16:09:28.072]                       muffled <- FALSE
[16:09:28.072]                       if (inherits(cond, "message")) {
[16:09:28.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.072]                         if (muffled) 
[16:09:28.072]                           invokeRestart("muffleMessage")
[16:09:28.072]                       }
[16:09:28.072]                       else if (inherits(cond, "warning")) {
[16:09:28.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.072]                         if (muffled) 
[16:09:28.072]                           invokeRestart("muffleWarning")
[16:09:28.072]                       }
[16:09:28.072]                       else if (inherits(cond, "condition")) {
[16:09:28.072]                         if (!is.null(pattern)) {
[16:09:28.072]                           computeRestarts <- base::computeRestarts
[16:09:28.072]                           grepl <- base::grepl
[16:09:28.072]                           restarts <- computeRestarts(cond)
[16:09:28.072]                           for (restart in restarts) {
[16:09:28.072]                             name <- restart$name
[16:09:28.072]                             if (is.null(name)) 
[16:09:28.072]                               next
[16:09:28.072]                             if (!grepl(pattern, name)) 
[16:09:28.072]                               next
[16:09:28.072]                             invokeRestart(restart)
[16:09:28.072]                             muffled <- TRUE
[16:09:28.072]                             break
[16:09:28.072]                           }
[16:09:28.072]                         }
[16:09:28.072]                       }
[16:09:28.072]                       invisible(muffled)
[16:09:28.072]                     }
[16:09:28.072]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.072]                   }
[16:09:28.072]                 }
[16:09:28.072]                 else {
[16:09:28.072]                   if (TRUE) {
[16:09:28.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.072]                     {
[16:09:28.072]                       inherits <- base::inherits
[16:09:28.072]                       invokeRestart <- base::invokeRestart
[16:09:28.072]                       is.null <- base::is.null
[16:09:28.072]                       muffled <- FALSE
[16:09:28.072]                       if (inherits(cond, "message")) {
[16:09:28.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.072]                         if (muffled) 
[16:09:28.072]                           invokeRestart("muffleMessage")
[16:09:28.072]                       }
[16:09:28.072]                       else if (inherits(cond, "warning")) {
[16:09:28.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.072]                         if (muffled) 
[16:09:28.072]                           invokeRestart("muffleWarning")
[16:09:28.072]                       }
[16:09:28.072]                       else if (inherits(cond, "condition")) {
[16:09:28.072]                         if (!is.null(pattern)) {
[16:09:28.072]                           computeRestarts <- base::computeRestarts
[16:09:28.072]                           grepl <- base::grepl
[16:09:28.072]                           restarts <- computeRestarts(cond)
[16:09:28.072]                           for (restart in restarts) {
[16:09:28.072]                             name <- restart$name
[16:09:28.072]                             if (is.null(name)) 
[16:09:28.072]                               next
[16:09:28.072]                             if (!grepl(pattern, name)) 
[16:09:28.072]                               next
[16:09:28.072]                             invokeRestart(restart)
[16:09:28.072]                             muffled <- TRUE
[16:09:28.072]                             break
[16:09:28.072]                           }
[16:09:28.072]                         }
[16:09:28.072]                       }
[16:09:28.072]                       invisible(muffled)
[16:09:28.072]                     }
[16:09:28.072]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.072]                   }
[16:09:28.072]                 }
[16:09:28.072]             }
[16:09:28.072]         }))
[16:09:28.072]     }, error = function(ex) {
[16:09:28.072]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.072]                 ...future.rng), started = ...future.startTime, 
[16:09:28.072]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.072]             version = "1.8"), class = "FutureResult")
[16:09:28.072]     }, finally = {
[16:09:28.072]         if (!identical(...future.workdir, getwd())) 
[16:09:28.072]             setwd(...future.workdir)
[16:09:28.072]         {
[16:09:28.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.072]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.072]             }
[16:09:28.072]             base::options(...future.oldOptions)
[16:09:28.072]             if (.Platform$OS.type == "windows") {
[16:09:28.072]                 old_names <- names(...future.oldEnvVars)
[16:09:28.072]                 envs <- base::Sys.getenv()
[16:09:28.072]                 names <- names(envs)
[16:09:28.072]                 common <- intersect(names, old_names)
[16:09:28.072]                 added <- setdiff(names, old_names)
[16:09:28.072]                 removed <- setdiff(old_names, names)
[16:09:28.072]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.072]                   envs[common]]
[16:09:28.072]                 NAMES <- toupper(changed)
[16:09:28.072]                 args <- list()
[16:09:28.072]                 for (kk in seq_along(NAMES)) {
[16:09:28.072]                   name <- changed[[kk]]
[16:09:28.072]                   NAME <- NAMES[[kk]]
[16:09:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.072]                     next
[16:09:28.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.072]                 }
[16:09:28.072]                 NAMES <- toupper(added)
[16:09:28.072]                 for (kk in seq_along(NAMES)) {
[16:09:28.072]                   name <- added[[kk]]
[16:09:28.072]                   NAME <- NAMES[[kk]]
[16:09:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.072]                     next
[16:09:28.072]                   args[[name]] <- ""
[16:09:28.072]                 }
[16:09:28.072]                 NAMES <- toupper(removed)
[16:09:28.072]                 for (kk in seq_along(NAMES)) {
[16:09:28.072]                   name <- removed[[kk]]
[16:09:28.072]                   NAME <- NAMES[[kk]]
[16:09:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.072]                     next
[16:09:28.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.072]                 }
[16:09:28.072]                 if (length(args) > 0) 
[16:09:28.072]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.072]             }
[16:09:28.072]             else {
[16:09:28.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.072]             }
[16:09:28.072]             {
[16:09:28.072]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.072]                   0L) {
[16:09:28.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.072]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.072]                   base::options(opts)
[16:09:28.072]                 }
[16:09:28.072]                 {
[16:09:28.072]                   {
[16:09:28.072]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.072]                     NULL
[16:09:28.072]                   }
[16:09:28.072]                   options(future.plan = NULL)
[16:09:28.072]                   if (is.na(NA_character_)) 
[16:09:28.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.072]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.072]                     envir = parent.frame()) 
[16:09:28.072]                   {
[16:09:28.072]                     default_workers <- missing(workers)
[16:09:28.072]                     if (is.function(workers)) 
[16:09:28.072]                       workers <- workers()
[16:09:28.072]                     workers <- structure(as.integer(workers), 
[16:09:28.072]                       class = class(workers))
[16:09:28.072]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.072]                       1L)
[16:09:28.072]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.072]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.072]                       if (default_workers) 
[16:09:28.072]                         supportsMulticore(warn = TRUE)
[16:09:28.072]                       return(sequential(..., envir = envir))
[16:09:28.072]                     }
[16:09:28.072]                     oopts <- options(mc.cores = workers)
[16:09:28.072]                     on.exit(options(oopts))
[16:09:28.072]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.072]                       envir = envir)
[16:09:28.072]                     if (!future$lazy) 
[16:09:28.072]                       future <- run(future)
[16:09:28.072]                     invisible(future)
[16:09:28.072]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.072]                 }
[16:09:28.072]             }
[16:09:28.072]         }
[16:09:28.072]     })
[16:09:28.072]     if (TRUE) {
[16:09:28.072]         base::sink(type = "output", split = FALSE)
[16:09:28.072]         if (TRUE) {
[16:09:28.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.072]         }
[16:09:28.072]         else {
[16:09:28.072]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.072]         }
[16:09:28.072]         base::close(...future.stdout)
[16:09:28.072]         ...future.stdout <- NULL
[16:09:28.072]     }
[16:09:28.072]     ...future.result$conditions <- ...future.conditions
[16:09:28.072]     ...future.result$finished <- base::Sys.time()
[16:09:28.072]     ...future.result
[16:09:28.072] }
[16:09:28.075] assign_globals() ...
[16:09:28.076] List of 5
[16:09:28.076]  $ future.call.arguments    : list()
[16:09:28.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.076]  $ ...future.FUN            :function (x, ...)  
[16:09:28.076]  $ ...future.elements_ii    :List of 1
[16:09:28.076]   ..$ : num [1:4] 2 4 6 8
[16:09:28.076]  $ ...future.seeds_ii       : NULL
[16:09:28.076]  $ ...future.globals.maxSize: NULL
[16:09:28.076]  - attr(*, "where")=List of 5
[16:09:28.076]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.076]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.076]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.076]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.076]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.076]  - attr(*, "resolved")= logi FALSE
[16:09:28.076]  - attr(*, "total_size")= num NA
[16:09:28.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.076]  - attr(*, "already-done")= logi TRUE
[16:09:28.083] - copied ‘future.call.arguments’ to environment
[16:09:28.083] - copied ‘...future.FUN’ to environment
[16:09:28.083] - copied ‘...future.elements_ii’ to environment
[16:09:28.083] - copied ‘...future.seeds_ii’ to environment
[16:09:28.084] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.084] assign_globals() ... done
[16:09:28.084] requestCore(): workers = 2
[16:09:28.086] MulticoreFuture started
[16:09:28.087] - Launch lazy future ... done
[16:09:28.087] run() for ‘MulticoreFuture’ ... done
[16:09:28.087] Created future:
[16:09:28.088] plan(): Setting new future strategy stack:
[16:09:28.088] List of future strategies:
[16:09:28.088] 1. sequential:
[16:09:28.088]    - args: function (..., envir = parent.frame())
[16:09:28.088]    - tweaked: FALSE
[16:09:28.088]    - call: NULL
[16:09:28.089] plan(): nbrOfWorkers() = 1
[16:09:28.091] plan(): Setting new future strategy stack:
[16:09:28.092] List of future strategies:
[16:09:28.092] 1. multicore:
[16:09:28.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.092]    - tweaked: FALSE
[16:09:28.092]    - call: plan(strategy)
[16:09:28.087] MulticoreFuture:
[16:09:28.087] Label: ‘future_apply-2’
[16:09:28.087] Expression:
[16:09:28.087] {
[16:09:28.087]     do.call(function(...) {
[16:09:28.087]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.087]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.087]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.087]             on.exit(options(oopts), add = TRUE)
[16:09:28.087]         }
[16:09:28.087]         {
[16:09:28.087]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.087]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.087]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.087]             })
[16:09:28.087]         }
[16:09:28.087]     }, args = future.call.arguments)
[16:09:28.087] }
[16:09:28.087] Lazy evaluation: FALSE
[16:09:28.087] Asynchronous evaluation: TRUE
[16:09:28.087] Local evaluation: TRUE
[16:09:28.087] Environment: R_GlobalEnv
[16:09:28.087] Capture standard output: TRUE
[16:09:28.087] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.087] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.087] Packages: 1 packages (‘stats’)
[16:09:28.087] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.087] Resolved: FALSE
[16:09:28.087] Value: <not collected>
[16:09:28.087] Conditions captured: <none>
[16:09:28.087] Early signaling: FALSE
[16:09:28.087] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.087] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.100] Chunk #2 of 2 ... DONE
[16:09:28.100] Launching 2 futures (chunks) ... DONE
[16:09:28.101] Resolving 2 futures (chunks) ...
[16:09:28.101] resolve() on list ...
[16:09:28.101]  recursive: 0
[16:09:28.101]  length: 2
[16:09:28.103] plan(): nbrOfWorkers() = 2
[16:09:28.102] 
[16:09:28.105] Future #1
[16:09:28.106] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.107] - nx: 2
[16:09:28.107] - relay: TRUE
[16:09:28.107] - stdout: TRUE
[16:09:28.107] - signal: TRUE
[16:09:28.108] - resignal: FALSE
[16:09:28.108] - force: TRUE
[16:09:28.108] - relayed: [n=2] FALSE, FALSE
[16:09:28.108] - queued futures: [n=2] FALSE, FALSE
[16:09:28.109]  - until=1
[16:09:28.109]  - relaying element #1
[16:09:28.109] - relayed: [n=2] TRUE, FALSE
[16:09:28.110] - queued futures: [n=2] TRUE, FALSE
[16:09:28.110] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.110]  length: 1 (resolved future 1)
[16:09:28.111] Future #2
[16:09:28.112] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.112] - nx: 2
[16:09:28.113] - relay: TRUE
[16:09:28.113] - stdout: TRUE
[16:09:28.113] - signal: TRUE
[16:09:28.113] - resignal: FALSE
[16:09:28.113] - force: TRUE
[16:09:28.113] - relayed: [n=2] TRUE, FALSE
[16:09:28.114] - queued futures: [n=2] TRUE, FALSE
[16:09:28.114]  - until=2
[16:09:28.114]  - relaying element #2
[16:09:28.114] - relayed: [n=2] TRUE, TRUE
[16:09:28.114] - queued futures: [n=2] TRUE, TRUE
[16:09:28.115] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.115]  length: 0 (resolved future 2)
[16:09:28.115] Relaying remaining futures
[16:09:28.115] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.115] - nx: 2
[16:09:28.115] - relay: TRUE
[16:09:28.116] - stdout: TRUE
[16:09:28.116] - signal: TRUE
[16:09:28.116] - resignal: FALSE
[16:09:28.116] - force: TRUE
[16:09:28.116] - relayed: [n=2] TRUE, TRUE
[16:09:28.116] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.116] - relayed: [n=2] TRUE, TRUE
[16:09:28.116] - queued futures: [n=2] TRUE, TRUE
[16:09:28.117] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.117] resolve() on list ... DONE
[16:09:28.117]  - Number of value chunks collected: 2
[16:09:28.117] Resolving 2 futures (chunks) ... DONE
[16:09:28.117] Reducing values from 2 chunks ...
[16:09:28.117]  - Number of values collected after concatenation: 2
[16:09:28.117]  - Number of values expected: 2
[16:09:28.118] Reducing values from 2 chunks ... DONE
[16:09:28.118] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:09:28.118] getGlobalsAndPackagesXApply() ...
[16:09:28.118]  - future.globals: TRUE
[16:09:28.119] getGlobalsAndPackages() ...
[16:09:28.119] Searching for globals...
[16:09:28.120] - globals found: [1] ‘FUN’
[16:09:28.120] Searching for globals ... DONE
[16:09:28.120] Resolving globals: FALSE
[16:09:28.121] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:28.121] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:28.121] - globals: [1] ‘FUN’
[16:09:28.121] 
[16:09:28.121] getGlobalsAndPackages() ... DONE
[16:09:28.121]  - globals found/used: [n=1] ‘FUN’
[16:09:28.122]  - needed namespaces: [n=0] 
[16:09:28.122] Finding globals ... DONE
[16:09:28.122]  - use_args: TRUE
[16:09:28.122]  - Getting '...' globals ...
[16:09:28.122] resolve() on list ...
[16:09:28.122]  recursive: 0
[16:09:28.122]  length: 1
[16:09:28.122]  elements: ‘...’
[16:09:28.123]  length: 0 (resolved future 1)
[16:09:28.123] resolve() on list ... DONE
[16:09:28.123]    - '...' content: [n=0] 
[16:09:28.123] List of 1
[16:09:28.123]  $ ...: list()
[16:09:28.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.123]  - attr(*, "where")=List of 1
[16:09:28.123]   ..$ ...:<environment: 0x5633aac43308> 
[16:09:28.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.123]  - attr(*, "resolved")= logi TRUE
[16:09:28.123]  - attr(*, "total_size")= num NA
[16:09:28.126]  - Getting '...' globals ... DONE
[16:09:28.126] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.126] List of 2
[16:09:28.126]  $ ...future.FUN:function (x)  
[16:09:28.126]  $ ...          : list()
[16:09:28.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.126]  - attr(*, "where")=List of 2
[16:09:28.126]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.126]   ..$ ...          :<environment: 0x5633aac43308> 
[16:09:28.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.126]  - attr(*, "resolved")= logi FALSE
[16:09:28.126]  - attr(*, "total_size")= num 848
[16:09:28.129] Packages to be attached in all futures: [n=0] 
[16:09:28.129] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.133] future_lapply() ...
[16:09:28.137] Number of chunks: 2
[16:09:28.137] getGlobalsAndPackagesXApply() ...
[16:09:28.137]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.138]  - use_args: TRUE
[16:09:28.138] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.138] List of 2
[16:09:28.138]  $ ...          : list()
[16:09:28.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.138]  $ ...future.FUN:function (x)  
[16:09:28.138]  - attr(*, "where")=List of 2
[16:09:28.138]   ..$ ...          :<environment: 0x5633aac43308> 
[16:09:28.138]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:28.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.138]  - attr(*, "resolved")= logi FALSE
[16:09:28.138]  - attr(*, "total_size")= num NA
[16:09:28.143] Packages to be attached in all futures: [n=0] 
[16:09:28.143] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.143] Number of futures (= number of chunks): 2
[16:09:28.144] Launching 2 futures (chunks) ...
[16:09:28.144] Chunk #1 of 2 ...
[16:09:28.144]  - seeds: <none>
[16:09:28.144] getGlobalsAndPackages() ...
[16:09:28.144] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.144] Resolving globals: FALSE
[16:09:28.144] Tweak future expression to call with '...' arguments ...
[16:09:28.144] {
[16:09:28.144]     do.call(function(...) {
[16:09:28.144]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.144]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.144]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.144]             on.exit(options(oopts), add = TRUE)
[16:09:28.144]         }
[16:09:28.144]         {
[16:09:28.144]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.144]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.144]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.144]             })
[16:09:28.144]         }
[16:09:28.144]     }, args = future.call.arguments)
[16:09:28.144] }
[16:09:28.145] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.145] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.145] 
[16:09:28.145] getGlobalsAndPackages() ... DONE
[16:09:28.146] run() for ‘Future’ ...
[16:09:28.146] - state: ‘created’
[16:09:28.146] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.150]   - Field: ‘label’
[16:09:28.150]   - Field: ‘local’
[16:09:28.150]   - Field: ‘owner’
[16:09:28.150]   - Field: ‘envir’
[16:09:28.151]   - Field: ‘workers’
[16:09:28.151]   - Field: ‘packages’
[16:09:28.151]   - Field: ‘gc’
[16:09:28.151]   - Field: ‘job’
[16:09:28.151]   - Field: ‘conditions’
[16:09:28.151]   - Field: ‘expr’
[16:09:28.151]   - Field: ‘uuid’
[16:09:28.151]   - Field: ‘seed’
[16:09:28.151]   - Field: ‘version’
[16:09:28.151]   - Field: ‘result’
[16:09:28.151]   - Field: ‘asynchronous’
[16:09:28.152]   - Field: ‘calls’
[16:09:28.152]   - Field: ‘globals’
[16:09:28.152]   - Field: ‘stdout’
[16:09:28.152]   - Field: ‘earlySignal’
[16:09:28.152]   - Field: ‘lazy’
[16:09:28.152]   - Field: ‘state’
[16:09:28.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.152] - Launch lazy future ...
[16:09:28.153] Packages needed by the future expression (n = 0): <none>
[16:09:28.153] Packages needed by future strategies (n = 0): <none>
[16:09:28.153] {
[16:09:28.153]     {
[16:09:28.153]         {
[16:09:28.153]             ...future.startTime <- base::Sys.time()
[16:09:28.153]             {
[16:09:28.153]                 {
[16:09:28.153]                   {
[16:09:28.153]                     {
[16:09:28.153]                       base::local({
[16:09:28.153]                         has_future <- base::requireNamespace("future", 
[16:09:28.153]                           quietly = TRUE)
[16:09:28.153]                         if (has_future) {
[16:09:28.153]                           ns <- base::getNamespace("future")
[16:09:28.153]                           version <- ns[[".package"]][["version"]]
[16:09:28.153]                           if (is.null(version)) 
[16:09:28.153]                             version <- utils::packageVersion("future")
[16:09:28.153]                         }
[16:09:28.153]                         else {
[16:09:28.153]                           version <- NULL
[16:09:28.153]                         }
[16:09:28.153]                         if (!has_future || version < "1.8.0") {
[16:09:28.153]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.153]                             "", base::R.version$version.string), 
[16:09:28.153]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.153]                               "release", "version")], collapse = " "), 
[16:09:28.153]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.153]                             info)
[16:09:28.153]                           info <- base::paste(info, collapse = "; ")
[16:09:28.153]                           if (!has_future) {
[16:09:28.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.153]                               info)
[16:09:28.153]                           }
[16:09:28.153]                           else {
[16:09:28.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.153]                               info, version)
[16:09:28.153]                           }
[16:09:28.153]                           base::stop(msg)
[16:09:28.153]                         }
[16:09:28.153]                       })
[16:09:28.153]                     }
[16:09:28.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.153]                     base::options(mc.cores = 1L)
[16:09:28.153]                   }
[16:09:28.153]                   options(future.plan = NULL)
[16:09:28.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.153]                 }
[16:09:28.153]                 ...future.workdir <- getwd()
[16:09:28.153]             }
[16:09:28.153]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.153]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.153]         }
[16:09:28.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.153]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.153]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.153]             base::names(...future.oldOptions))
[16:09:28.153]     }
[16:09:28.153]     if (FALSE) {
[16:09:28.153]     }
[16:09:28.153]     else {
[16:09:28.153]         if (TRUE) {
[16:09:28.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.153]                 open = "w")
[16:09:28.153]         }
[16:09:28.153]         else {
[16:09:28.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.153]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.153]         }
[16:09:28.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.153]             base::sink(type = "output", split = FALSE)
[16:09:28.153]             base::close(...future.stdout)
[16:09:28.153]         }, add = TRUE)
[16:09:28.153]     }
[16:09:28.153]     ...future.frame <- base::sys.nframe()
[16:09:28.153]     ...future.conditions <- base::list()
[16:09:28.153]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.153]     if (FALSE) {
[16:09:28.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.153]     }
[16:09:28.153]     ...future.result <- base::tryCatch({
[16:09:28.153]         base::withCallingHandlers({
[16:09:28.153]             ...future.value <- base::withVisible(base::local({
[16:09:28.153]                 withCallingHandlers({
[16:09:28.153]                   {
[16:09:28.153]                     do.call(function(...) {
[16:09:28.153]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.153]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.153]                         ...future.globals.maxSize)) {
[16:09:28.153]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.153]                         on.exit(options(oopts), add = TRUE)
[16:09:28.153]                       }
[16:09:28.153]                       {
[16:09:28.153]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.153]                           FUN = function(jj) {
[16:09:28.153]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.153]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.153]                           })
[16:09:28.153]                       }
[16:09:28.153]                     }, args = future.call.arguments)
[16:09:28.153]                   }
[16:09:28.153]                 }, immediateCondition = function(cond) {
[16:09:28.153]                   save_rds <- function (object, pathname, ...) 
[16:09:28.153]                   {
[16:09:28.153]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.153]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.153]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.153]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.153]                         fi_tmp[["mtime"]])
[16:09:28.153]                     }
[16:09:28.153]                     tryCatch({
[16:09:28.153]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.153]                     }, error = function(ex) {
[16:09:28.153]                       msg <- conditionMessage(ex)
[16:09:28.153]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.153]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.153]                         fi_tmp[["mtime"]], msg)
[16:09:28.153]                       ex$message <- msg
[16:09:28.153]                       stop(ex)
[16:09:28.153]                     })
[16:09:28.153]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.153]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.153]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.153]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.153]                       fi <- file.info(pathname)
[16:09:28.153]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.153]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.153]                         fi[["size"]], fi[["mtime"]])
[16:09:28.153]                       stop(msg)
[16:09:28.153]                     }
[16:09:28.153]                     invisible(pathname)
[16:09:28.153]                   }
[16:09:28.153]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.153]                     rootPath = tempdir()) 
[16:09:28.153]                   {
[16:09:28.153]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.153]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.153]                       tmpdir = path, fileext = ".rds")
[16:09:28.153]                     save_rds(obj, file)
[16:09:28.153]                   }
[16:09:28.153]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.153]                   {
[16:09:28.153]                     inherits <- base::inherits
[16:09:28.153]                     invokeRestart <- base::invokeRestart
[16:09:28.153]                     is.null <- base::is.null
[16:09:28.153]                     muffled <- FALSE
[16:09:28.153]                     if (inherits(cond, "message")) {
[16:09:28.153]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.153]                       if (muffled) 
[16:09:28.153]                         invokeRestart("muffleMessage")
[16:09:28.153]                     }
[16:09:28.153]                     else if (inherits(cond, "warning")) {
[16:09:28.153]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.153]                       if (muffled) 
[16:09:28.153]                         invokeRestart("muffleWarning")
[16:09:28.153]                     }
[16:09:28.153]                     else if (inherits(cond, "condition")) {
[16:09:28.153]                       if (!is.null(pattern)) {
[16:09:28.153]                         computeRestarts <- base::computeRestarts
[16:09:28.153]                         grepl <- base::grepl
[16:09:28.153]                         restarts <- computeRestarts(cond)
[16:09:28.153]                         for (restart in restarts) {
[16:09:28.153]                           name <- restart$name
[16:09:28.153]                           if (is.null(name)) 
[16:09:28.153]                             next
[16:09:28.153]                           if (!grepl(pattern, name)) 
[16:09:28.153]                             next
[16:09:28.153]                           invokeRestart(restart)
[16:09:28.153]                           muffled <- TRUE
[16:09:28.153]                           break
[16:09:28.153]                         }
[16:09:28.153]                       }
[16:09:28.153]                     }
[16:09:28.153]                     invisible(muffled)
[16:09:28.153]                   }
[16:09:28.153]                   muffleCondition(cond)
[16:09:28.153]                 })
[16:09:28.153]             }))
[16:09:28.153]             future::FutureResult(value = ...future.value$value, 
[16:09:28.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.153]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.153]                     ...future.globalenv.names))
[16:09:28.153]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.153]         }, condition = base::local({
[16:09:28.153]             c <- base::c
[16:09:28.153]             inherits <- base::inherits
[16:09:28.153]             invokeRestart <- base::invokeRestart
[16:09:28.153]             length <- base::length
[16:09:28.153]             list <- base::list
[16:09:28.153]             seq.int <- base::seq.int
[16:09:28.153]             signalCondition <- base::signalCondition
[16:09:28.153]             sys.calls <- base::sys.calls
[16:09:28.153]             `[[` <- base::`[[`
[16:09:28.153]             `+` <- base::`+`
[16:09:28.153]             `<<-` <- base::`<<-`
[16:09:28.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.153]                   3L)]
[16:09:28.153]             }
[16:09:28.153]             function(cond) {
[16:09:28.153]                 is_error <- inherits(cond, "error")
[16:09:28.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.153]                   NULL)
[16:09:28.153]                 if (is_error) {
[16:09:28.153]                   sessionInformation <- function() {
[16:09:28.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.153]                       search = base::search(), system = base::Sys.info())
[16:09:28.153]                   }
[16:09:28.153]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.153]                     cond$call), session = sessionInformation(), 
[16:09:28.153]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.153]                   signalCondition(cond)
[16:09:28.153]                 }
[16:09:28.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.153]                 "immediateCondition"))) {
[16:09:28.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.153]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.153]                   if (TRUE && !signal) {
[16:09:28.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.153]                     {
[16:09:28.153]                       inherits <- base::inherits
[16:09:28.153]                       invokeRestart <- base::invokeRestart
[16:09:28.153]                       is.null <- base::is.null
[16:09:28.153]                       muffled <- FALSE
[16:09:28.153]                       if (inherits(cond, "message")) {
[16:09:28.153]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.153]                         if (muffled) 
[16:09:28.153]                           invokeRestart("muffleMessage")
[16:09:28.153]                       }
[16:09:28.153]                       else if (inherits(cond, "warning")) {
[16:09:28.153]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.153]                         if (muffled) 
[16:09:28.153]                           invokeRestart("muffleWarning")
[16:09:28.153]                       }
[16:09:28.153]                       else if (inherits(cond, "condition")) {
[16:09:28.153]                         if (!is.null(pattern)) {
[16:09:28.153]                           computeRestarts <- base::computeRestarts
[16:09:28.153]                           grepl <- base::grepl
[16:09:28.153]                           restarts <- computeRestarts(cond)
[16:09:28.153]                           for (restart in restarts) {
[16:09:28.153]                             name <- restart$name
[16:09:28.153]                             if (is.null(name)) 
[16:09:28.153]                               next
[16:09:28.153]                             if (!grepl(pattern, name)) 
[16:09:28.153]                               next
[16:09:28.153]                             invokeRestart(restart)
[16:09:28.153]                             muffled <- TRUE
[16:09:28.153]                             break
[16:09:28.153]                           }
[16:09:28.153]                         }
[16:09:28.153]                       }
[16:09:28.153]                       invisible(muffled)
[16:09:28.153]                     }
[16:09:28.153]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.153]                   }
[16:09:28.153]                 }
[16:09:28.153]                 else {
[16:09:28.153]                   if (TRUE) {
[16:09:28.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.153]                     {
[16:09:28.153]                       inherits <- base::inherits
[16:09:28.153]                       invokeRestart <- base::invokeRestart
[16:09:28.153]                       is.null <- base::is.null
[16:09:28.153]                       muffled <- FALSE
[16:09:28.153]                       if (inherits(cond, "message")) {
[16:09:28.153]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.153]                         if (muffled) 
[16:09:28.153]                           invokeRestart("muffleMessage")
[16:09:28.153]                       }
[16:09:28.153]                       else if (inherits(cond, "warning")) {
[16:09:28.153]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.153]                         if (muffled) 
[16:09:28.153]                           invokeRestart("muffleWarning")
[16:09:28.153]                       }
[16:09:28.153]                       else if (inherits(cond, "condition")) {
[16:09:28.153]                         if (!is.null(pattern)) {
[16:09:28.153]                           computeRestarts <- base::computeRestarts
[16:09:28.153]                           grepl <- base::grepl
[16:09:28.153]                           restarts <- computeRestarts(cond)
[16:09:28.153]                           for (restart in restarts) {
[16:09:28.153]                             name <- restart$name
[16:09:28.153]                             if (is.null(name)) 
[16:09:28.153]                               next
[16:09:28.153]                             if (!grepl(pattern, name)) 
[16:09:28.153]                               next
[16:09:28.153]                             invokeRestart(restart)
[16:09:28.153]                             muffled <- TRUE
[16:09:28.153]                             break
[16:09:28.153]                           }
[16:09:28.153]                         }
[16:09:28.153]                       }
[16:09:28.153]                       invisible(muffled)
[16:09:28.153]                     }
[16:09:28.153]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.153]                   }
[16:09:28.153]                 }
[16:09:28.153]             }
[16:09:28.153]         }))
[16:09:28.153]     }, error = function(ex) {
[16:09:28.153]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.153]                 ...future.rng), started = ...future.startTime, 
[16:09:28.153]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.153]             version = "1.8"), class = "FutureResult")
[16:09:28.153]     }, finally = {
[16:09:28.153]         if (!identical(...future.workdir, getwd())) 
[16:09:28.153]             setwd(...future.workdir)
[16:09:28.153]         {
[16:09:28.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.153]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.153]             }
[16:09:28.153]             base::options(...future.oldOptions)
[16:09:28.153]             if (.Platform$OS.type == "windows") {
[16:09:28.153]                 old_names <- names(...future.oldEnvVars)
[16:09:28.153]                 envs <- base::Sys.getenv()
[16:09:28.153]                 names <- names(envs)
[16:09:28.153]                 common <- intersect(names, old_names)
[16:09:28.153]                 added <- setdiff(names, old_names)
[16:09:28.153]                 removed <- setdiff(old_names, names)
[16:09:28.153]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.153]                   envs[common]]
[16:09:28.153]                 NAMES <- toupper(changed)
[16:09:28.153]                 args <- list()
[16:09:28.153]                 for (kk in seq_along(NAMES)) {
[16:09:28.153]                   name <- changed[[kk]]
[16:09:28.153]                   NAME <- NAMES[[kk]]
[16:09:28.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.153]                     next
[16:09:28.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.153]                 }
[16:09:28.153]                 NAMES <- toupper(added)
[16:09:28.153]                 for (kk in seq_along(NAMES)) {
[16:09:28.153]                   name <- added[[kk]]
[16:09:28.153]                   NAME <- NAMES[[kk]]
[16:09:28.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.153]                     next
[16:09:28.153]                   args[[name]] <- ""
[16:09:28.153]                 }
[16:09:28.153]                 NAMES <- toupper(removed)
[16:09:28.153]                 for (kk in seq_along(NAMES)) {
[16:09:28.153]                   name <- removed[[kk]]
[16:09:28.153]                   NAME <- NAMES[[kk]]
[16:09:28.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.153]                     next
[16:09:28.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.153]                 }
[16:09:28.153]                 if (length(args) > 0) 
[16:09:28.153]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.153]             }
[16:09:28.153]             else {
[16:09:28.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.153]             }
[16:09:28.153]             {
[16:09:28.153]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.153]                   0L) {
[16:09:28.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.153]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.153]                   base::options(opts)
[16:09:28.153]                 }
[16:09:28.153]                 {
[16:09:28.153]                   {
[16:09:28.153]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.153]                     NULL
[16:09:28.153]                   }
[16:09:28.153]                   options(future.plan = NULL)
[16:09:28.153]                   if (is.na(NA_character_)) 
[16:09:28.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.153]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.153]                     envir = parent.frame()) 
[16:09:28.153]                   {
[16:09:28.153]                     default_workers <- missing(workers)
[16:09:28.153]                     if (is.function(workers)) 
[16:09:28.153]                       workers <- workers()
[16:09:28.153]                     workers <- structure(as.integer(workers), 
[16:09:28.153]                       class = class(workers))
[16:09:28.153]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.153]                       1L)
[16:09:28.153]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.153]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.153]                       if (default_workers) 
[16:09:28.153]                         supportsMulticore(warn = TRUE)
[16:09:28.153]                       return(sequential(..., envir = envir))
[16:09:28.153]                     }
[16:09:28.153]                     oopts <- options(mc.cores = workers)
[16:09:28.153]                     on.exit(options(oopts))
[16:09:28.153]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.153]                       envir = envir)
[16:09:28.153]                     if (!future$lazy) 
[16:09:28.153]                       future <- run(future)
[16:09:28.153]                     invisible(future)
[16:09:28.153]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.153]                 }
[16:09:28.153]             }
[16:09:28.153]         }
[16:09:28.153]     })
[16:09:28.153]     if (TRUE) {
[16:09:28.153]         base::sink(type = "output", split = FALSE)
[16:09:28.153]         if (TRUE) {
[16:09:28.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.153]         }
[16:09:28.153]         else {
[16:09:28.153]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.153]         }
[16:09:28.153]         base::close(...future.stdout)
[16:09:28.153]         ...future.stdout <- NULL
[16:09:28.153]     }
[16:09:28.153]     ...future.result$conditions <- ...future.conditions
[16:09:28.153]     ...future.result$finished <- base::Sys.time()
[16:09:28.153]     ...future.result
[16:09:28.153] }
[16:09:28.156] assign_globals() ...
[16:09:28.156] List of 5
[16:09:28.156]  $ future.call.arguments    : list()
[16:09:28.156]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.156]  $ ...future.FUN            :function (x)  
[16:09:28.156]  $ ...future.elements_ii    :List of 1
[16:09:28.156]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:28.156]  $ ...future.seeds_ii       : NULL
[16:09:28.156]  $ ...future.globals.maxSize: NULL
[16:09:28.156]  - attr(*, "where")=List of 5
[16:09:28.156]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.156]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.156]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.156]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.156]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.156]  - attr(*, "resolved")= logi FALSE
[16:09:28.156]  - attr(*, "total_size")= num NA
[16:09:28.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.156]  - attr(*, "already-done")= logi TRUE
[16:09:28.161] - copied ‘future.call.arguments’ to environment
[16:09:28.161] - copied ‘...future.FUN’ to environment
[16:09:28.161] - copied ‘...future.elements_ii’ to environment
[16:09:28.161] - copied ‘...future.seeds_ii’ to environment
[16:09:28.161] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.161] assign_globals() ... done
[16:09:28.161] requestCore(): workers = 2
[16:09:28.163] MulticoreFuture started
[16:09:28.164] - Launch lazy future ... done
[16:09:28.164] run() for ‘MulticoreFuture’ ... done
[16:09:28.164] Created future:
[16:09:28.164] plan(): Setting new future strategy stack:
[16:09:28.165] List of future strategies:
[16:09:28.165] 1. sequential:
[16:09:28.165]    - args: function (..., envir = parent.frame())
[16:09:28.165]    - tweaked: FALSE
[16:09:28.165]    - call: NULL
[16:09:28.166] plan(): nbrOfWorkers() = 1
[16:09:28.168] plan(): Setting new future strategy stack:
[16:09:28.168] List of future strategies:
[16:09:28.168] 1. multicore:
[16:09:28.168]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.168]    - tweaked: FALSE
[16:09:28.168]    - call: plan(strategy)
[16:09:28.173] plan(): nbrOfWorkers() = 2
[16:09:28.164] MulticoreFuture:
[16:09:28.164] Label: ‘future_apply-1’
[16:09:28.164] Expression:
[16:09:28.164] {
[16:09:28.164]     do.call(function(...) {
[16:09:28.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.164]             on.exit(options(oopts), add = TRUE)
[16:09:28.164]         }
[16:09:28.164]         {
[16:09:28.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.164]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.164]             })
[16:09:28.164]         }
[16:09:28.164]     }, args = future.call.arguments)
[16:09:28.164] }
[16:09:28.164] Lazy evaluation: FALSE
[16:09:28.164] Asynchronous evaluation: TRUE
[16:09:28.164] Local evaluation: TRUE
[16:09:28.164] Environment: R_GlobalEnv
[16:09:28.164] Capture standard output: TRUE
[16:09:28.164] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.164] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.164] Packages: <none>
[16:09:28.164] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.164] Resolved: TRUE
[16:09:28.164] Value: <not collected>
[16:09:28.164] Conditions captured: <none>
[16:09:28.164] Early signaling: FALSE
[16:09:28.164] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.164] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.175] Chunk #1 of 2 ... DONE
[16:09:28.175] Chunk #2 of 2 ...
[16:09:28.175]  - seeds: <none>
[16:09:28.175] getGlobalsAndPackages() ...
[16:09:28.175] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.176] Resolving globals: FALSE
[16:09:28.176] Tweak future expression to call with '...' arguments ...
[16:09:28.176] {
[16:09:28.176]     do.call(function(...) {
[16:09:28.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.176]             on.exit(options(oopts), add = TRUE)
[16:09:28.176]         }
[16:09:28.176]         {
[16:09:28.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.176]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.176]             })
[16:09:28.176]         }
[16:09:28.176]     }, args = future.call.arguments)
[16:09:28.176] }
[16:09:28.176] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.177] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.177] 
[16:09:28.177] getGlobalsAndPackages() ... DONE
[16:09:28.178] run() for ‘Future’ ...
[16:09:28.178] - state: ‘created’
[16:09:28.178] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.183] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.183]   - Field: ‘label’
[16:09:28.183]   - Field: ‘local’
[16:09:28.187]   - Field: ‘owner’
[16:09:28.187]   - Field: ‘envir’
[16:09:28.187]   - Field: ‘workers’
[16:09:28.188]   - Field: ‘packages’
[16:09:28.188]   - Field: ‘gc’
[16:09:28.188]   - Field: ‘job’
[16:09:28.189]   - Field: ‘conditions’
[16:09:28.189]   - Field: ‘expr’
[16:09:28.189]   - Field: ‘uuid’
[16:09:28.189]   - Field: ‘seed’
[16:09:28.190]   - Field: ‘version’
[16:09:28.190]   - Field: ‘result’
[16:09:28.190]   - Field: ‘asynchronous’
[16:09:28.190]   - Field: ‘calls’
[16:09:28.191]   - Field: ‘globals’
[16:09:28.191]   - Field: ‘stdout’
[16:09:28.191]   - Field: ‘earlySignal’
[16:09:28.192]   - Field: ‘lazy’
[16:09:28.192]   - Field: ‘state’
[16:09:28.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.192] - Launch lazy future ...
[16:09:28.193] Packages needed by the future expression (n = 0): <none>
[16:09:28.193] Packages needed by future strategies (n = 0): <none>
[16:09:28.194] {
[16:09:28.194]     {
[16:09:28.194]         {
[16:09:28.194]             ...future.startTime <- base::Sys.time()
[16:09:28.194]             {
[16:09:28.194]                 {
[16:09:28.194]                   {
[16:09:28.194]                     {
[16:09:28.194]                       base::local({
[16:09:28.194]                         has_future <- base::requireNamespace("future", 
[16:09:28.194]                           quietly = TRUE)
[16:09:28.194]                         if (has_future) {
[16:09:28.194]                           ns <- base::getNamespace("future")
[16:09:28.194]                           version <- ns[[".package"]][["version"]]
[16:09:28.194]                           if (is.null(version)) 
[16:09:28.194]                             version <- utils::packageVersion("future")
[16:09:28.194]                         }
[16:09:28.194]                         else {
[16:09:28.194]                           version <- NULL
[16:09:28.194]                         }
[16:09:28.194]                         if (!has_future || version < "1.8.0") {
[16:09:28.194]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.194]                             "", base::R.version$version.string), 
[16:09:28.194]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.194]                               "release", "version")], collapse = " "), 
[16:09:28.194]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.194]                             info)
[16:09:28.194]                           info <- base::paste(info, collapse = "; ")
[16:09:28.194]                           if (!has_future) {
[16:09:28.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.194]                               info)
[16:09:28.194]                           }
[16:09:28.194]                           else {
[16:09:28.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.194]                               info, version)
[16:09:28.194]                           }
[16:09:28.194]                           base::stop(msg)
[16:09:28.194]                         }
[16:09:28.194]                       })
[16:09:28.194]                     }
[16:09:28.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.194]                     base::options(mc.cores = 1L)
[16:09:28.194]                   }
[16:09:28.194]                   options(future.plan = NULL)
[16:09:28.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.194]                 }
[16:09:28.194]                 ...future.workdir <- getwd()
[16:09:28.194]             }
[16:09:28.194]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.194]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.194]         }
[16:09:28.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.194]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.194]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.194]             base::names(...future.oldOptions))
[16:09:28.194]     }
[16:09:28.194]     if (FALSE) {
[16:09:28.194]     }
[16:09:28.194]     else {
[16:09:28.194]         if (TRUE) {
[16:09:28.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.194]                 open = "w")
[16:09:28.194]         }
[16:09:28.194]         else {
[16:09:28.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.194]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.194]         }
[16:09:28.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.194]             base::sink(type = "output", split = FALSE)
[16:09:28.194]             base::close(...future.stdout)
[16:09:28.194]         }, add = TRUE)
[16:09:28.194]     }
[16:09:28.194]     ...future.frame <- base::sys.nframe()
[16:09:28.194]     ...future.conditions <- base::list()
[16:09:28.194]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.194]     if (FALSE) {
[16:09:28.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.194]     }
[16:09:28.194]     ...future.result <- base::tryCatch({
[16:09:28.194]         base::withCallingHandlers({
[16:09:28.194]             ...future.value <- base::withVisible(base::local({
[16:09:28.194]                 withCallingHandlers({
[16:09:28.194]                   {
[16:09:28.194]                     do.call(function(...) {
[16:09:28.194]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.194]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.194]                         ...future.globals.maxSize)) {
[16:09:28.194]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.194]                         on.exit(options(oopts), add = TRUE)
[16:09:28.194]                       }
[16:09:28.194]                       {
[16:09:28.194]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.194]                           FUN = function(jj) {
[16:09:28.194]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.194]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.194]                           })
[16:09:28.194]                       }
[16:09:28.194]                     }, args = future.call.arguments)
[16:09:28.194]                   }
[16:09:28.194]                 }, immediateCondition = function(cond) {
[16:09:28.194]                   save_rds <- function (object, pathname, ...) 
[16:09:28.194]                   {
[16:09:28.194]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.194]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.194]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.194]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.194]                         fi_tmp[["mtime"]])
[16:09:28.194]                     }
[16:09:28.194]                     tryCatch({
[16:09:28.194]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.194]                     }, error = function(ex) {
[16:09:28.194]                       msg <- conditionMessage(ex)
[16:09:28.194]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.194]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.194]                         fi_tmp[["mtime"]], msg)
[16:09:28.194]                       ex$message <- msg
[16:09:28.194]                       stop(ex)
[16:09:28.194]                     })
[16:09:28.194]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.194]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.194]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.194]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.194]                       fi <- file.info(pathname)
[16:09:28.194]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.194]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.194]                         fi[["size"]], fi[["mtime"]])
[16:09:28.194]                       stop(msg)
[16:09:28.194]                     }
[16:09:28.194]                     invisible(pathname)
[16:09:28.194]                   }
[16:09:28.194]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.194]                     rootPath = tempdir()) 
[16:09:28.194]                   {
[16:09:28.194]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.194]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.194]                       tmpdir = path, fileext = ".rds")
[16:09:28.194]                     save_rds(obj, file)
[16:09:28.194]                   }
[16:09:28.194]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.194]                   {
[16:09:28.194]                     inherits <- base::inherits
[16:09:28.194]                     invokeRestart <- base::invokeRestart
[16:09:28.194]                     is.null <- base::is.null
[16:09:28.194]                     muffled <- FALSE
[16:09:28.194]                     if (inherits(cond, "message")) {
[16:09:28.194]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.194]                       if (muffled) 
[16:09:28.194]                         invokeRestart("muffleMessage")
[16:09:28.194]                     }
[16:09:28.194]                     else if (inherits(cond, "warning")) {
[16:09:28.194]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.194]                       if (muffled) 
[16:09:28.194]                         invokeRestart("muffleWarning")
[16:09:28.194]                     }
[16:09:28.194]                     else if (inherits(cond, "condition")) {
[16:09:28.194]                       if (!is.null(pattern)) {
[16:09:28.194]                         computeRestarts <- base::computeRestarts
[16:09:28.194]                         grepl <- base::grepl
[16:09:28.194]                         restarts <- computeRestarts(cond)
[16:09:28.194]                         for (restart in restarts) {
[16:09:28.194]                           name <- restart$name
[16:09:28.194]                           if (is.null(name)) 
[16:09:28.194]                             next
[16:09:28.194]                           if (!grepl(pattern, name)) 
[16:09:28.194]                             next
[16:09:28.194]                           invokeRestart(restart)
[16:09:28.194]                           muffled <- TRUE
[16:09:28.194]                           break
[16:09:28.194]                         }
[16:09:28.194]                       }
[16:09:28.194]                     }
[16:09:28.194]                     invisible(muffled)
[16:09:28.194]                   }
[16:09:28.194]                   muffleCondition(cond)
[16:09:28.194]                 })
[16:09:28.194]             }))
[16:09:28.194]             future::FutureResult(value = ...future.value$value, 
[16:09:28.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.194]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.194]                     ...future.globalenv.names))
[16:09:28.194]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.194]         }, condition = base::local({
[16:09:28.194]             c <- base::c
[16:09:28.194]             inherits <- base::inherits
[16:09:28.194]             invokeRestart <- base::invokeRestart
[16:09:28.194]             length <- base::length
[16:09:28.194]             list <- base::list
[16:09:28.194]             seq.int <- base::seq.int
[16:09:28.194]             signalCondition <- base::signalCondition
[16:09:28.194]             sys.calls <- base::sys.calls
[16:09:28.194]             `[[` <- base::`[[`
[16:09:28.194]             `+` <- base::`+`
[16:09:28.194]             `<<-` <- base::`<<-`
[16:09:28.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.194]                   3L)]
[16:09:28.194]             }
[16:09:28.194]             function(cond) {
[16:09:28.194]                 is_error <- inherits(cond, "error")
[16:09:28.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.194]                   NULL)
[16:09:28.194]                 if (is_error) {
[16:09:28.194]                   sessionInformation <- function() {
[16:09:28.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.194]                       search = base::search(), system = base::Sys.info())
[16:09:28.194]                   }
[16:09:28.194]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.194]                     cond$call), session = sessionInformation(), 
[16:09:28.194]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.194]                   signalCondition(cond)
[16:09:28.194]                 }
[16:09:28.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.194]                 "immediateCondition"))) {
[16:09:28.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.194]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.194]                   if (TRUE && !signal) {
[16:09:28.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.194]                     {
[16:09:28.194]                       inherits <- base::inherits
[16:09:28.194]                       invokeRestart <- base::invokeRestart
[16:09:28.194]                       is.null <- base::is.null
[16:09:28.194]                       muffled <- FALSE
[16:09:28.194]                       if (inherits(cond, "message")) {
[16:09:28.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.194]                         if (muffled) 
[16:09:28.194]                           invokeRestart("muffleMessage")
[16:09:28.194]                       }
[16:09:28.194]                       else if (inherits(cond, "warning")) {
[16:09:28.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.194]                         if (muffled) 
[16:09:28.194]                           invokeRestart("muffleWarning")
[16:09:28.194]                       }
[16:09:28.194]                       else if (inherits(cond, "condition")) {
[16:09:28.194]                         if (!is.null(pattern)) {
[16:09:28.194]                           computeRestarts <- base::computeRestarts
[16:09:28.194]                           grepl <- base::grepl
[16:09:28.194]                           restarts <- computeRestarts(cond)
[16:09:28.194]                           for (restart in restarts) {
[16:09:28.194]                             name <- restart$name
[16:09:28.194]                             if (is.null(name)) 
[16:09:28.194]                               next
[16:09:28.194]                             if (!grepl(pattern, name)) 
[16:09:28.194]                               next
[16:09:28.194]                             invokeRestart(restart)
[16:09:28.194]                             muffled <- TRUE
[16:09:28.194]                             break
[16:09:28.194]                           }
[16:09:28.194]                         }
[16:09:28.194]                       }
[16:09:28.194]                       invisible(muffled)
[16:09:28.194]                     }
[16:09:28.194]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.194]                   }
[16:09:28.194]                 }
[16:09:28.194]                 else {
[16:09:28.194]                   if (TRUE) {
[16:09:28.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.194]                     {
[16:09:28.194]                       inherits <- base::inherits
[16:09:28.194]                       invokeRestart <- base::invokeRestart
[16:09:28.194]                       is.null <- base::is.null
[16:09:28.194]                       muffled <- FALSE
[16:09:28.194]                       if (inherits(cond, "message")) {
[16:09:28.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.194]                         if (muffled) 
[16:09:28.194]                           invokeRestart("muffleMessage")
[16:09:28.194]                       }
[16:09:28.194]                       else if (inherits(cond, "warning")) {
[16:09:28.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.194]                         if (muffled) 
[16:09:28.194]                           invokeRestart("muffleWarning")
[16:09:28.194]                       }
[16:09:28.194]                       else if (inherits(cond, "condition")) {
[16:09:28.194]                         if (!is.null(pattern)) {
[16:09:28.194]                           computeRestarts <- base::computeRestarts
[16:09:28.194]                           grepl <- base::grepl
[16:09:28.194]                           restarts <- computeRestarts(cond)
[16:09:28.194]                           for (restart in restarts) {
[16:09:28.194]                             name <- restart$name
[16:09:28.194]                             if (is.null(name)) 
[16:09:28.194]                               next
[16:09:28.194]                             if (!grepl(pattern, name)) 
[16:09:28.194]                               next
[16:09:28.194]                             invokeRestart(restart)
[16:09:28.194]                             muffled <- TRUE
[16:09:28.194]                             break
[16:09:28.194]                           }
[16:09:28.194]                         }
[16:09:28.194]                       }
[16:09:28.194]                       invisible(muffled)
[16:09:28.194]                     }
[16:09:28.194]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.194]                   }
[16:09:28.194]                 }
[16:09:28.194]             }
[16:09:28.194]         }))
[16:09:28.194]     }, error = function(ex) {
[16:09:28.194]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.194]                 ...future.rng), started = ...future.startTime, 
[16:09:28.194]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.194]             version = "1.8"), class = "FutureResult")
[16:09:28.194]     }, finally = {
[16:09:28.194]         if (!identical(...future.workdir, getwd())) 
[16:09:28.194]             setwd(...future.workdir)
[16:09:28.194]         {
[16:09:28.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.194]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.194]             }
[16:09:28.194]             base::options(...future.oldOptions)
[16:09:28.194]             if (.Platform$OS.type == "windows") {
[16:09:28.194]                 old_names <- names(...future.oldEnvVars)
[16:09:28.194]                 envs <- base::Sys.getenv()
[16:09:28.194]                 names <- names(envs)
[16:09:28.194]                 common <- intersect(names, old_names)
[16:09:28.194]                 added <- setdiff(names, old_names)
[16:09:28.194]                 removed <- setdiff(old_names, names)
[16:09:28.194]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.194]                   envs[common]]
[16:09:28.194]                 NAMES <- toupper(changed)
[16:09:28.194]                 args <- list()
[16:09:28.194]                 for (kk in seq_along(NAMES)) {
[16:09:28.194]                   name <- changed[[kk]]
[16:09:28.194]                   NAME <- NAMES[[kk]]
[16:09:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.194]                     next
[16:09:28.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.194]                 }
[16:09:28.194]                 NAMES <- toupper(added)
[16:09:28.194]                 for (kk in seq_along(NAMES)) {
[16:09:28.194]                   name <- added[[kk]]
[16:09:28.194]                   NAME <- NAMES[[kk]]
[16:09:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.194]                     next
[16:09:28.194]                   args[[name]] <- ""
[16:09:28.194]                 }
[16:09:28.194]                 NAMES <- toupper(removed)
[16:09:28.194]                 for (kk in seq_along(NAMES)) {
[16:09:28.194]                   name <- removed[[kk]]
[16:09:28.194]                   NAME <- NAMES[[kk]]
[16:09:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.194]                     next
[16:09:28.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.194]                 }
[16:09:28.194]                 if (length(args) > 0) 
[16:09:28.194]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.194]             }
[16:09:28.194]             else {
[16:09:28.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.194]             }
[16:09:28.194]             {
[16:09:28.194]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.194]                   0L) {
[16:09:28.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.194]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.194]                   base::options(opts)
[16:09:28.194]                 }
[16:09:28.194]                 {
[16:09:28.194]                   {
[16:09:28.194]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.194]                     NULL
[16:09:28.194]                   }
[16:09:28.194]                   options(future.plan = NULL)
[16:09:28.194]                   if (is.na(NA_character_)) 
[16:09:28.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.194]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.194]                     envir = parent.frame()) 
[16:09:28.194]                   {
[16:09:28.194]                     default_workers <- missing(workers)
[16:09:28.194]                     if (is.function(workers)) 
[16:09:28.194]                       workers <- workers()
[16:09:28.194]                     workers <- structure(as.integer(workers), 
[16:09:28.194]                       class = class(workers))
[16:09:28.194]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.194]                       1L)
[16:09:28.194]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.194]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.194]                       if (default_workers) 
[16:09:28.194]                         supportsMulticore(warn = TRUE)
[16:09:28.194]                       return(sequential(..., envir = envir))
[16:09:28.194]                     }
[16:09:28.194]                     oopts <- options(mc.cores = workers)
[16:09:28.194]                     on.exit(options(oopts))
[16:09:28.194]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.194]                       envir = envir)
[16:09:28.194]                     if (!future$lazy) 
[16:09:28.194]                       future <- run(future)
[16:09:28.194]                     invisible(future)
[16:09:28.194]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.194]                 }
[16:09:28.194]             }
[16:09:28.194]         }
[16:09:28.194]     })
[16:09:28.194]     if (TRUE) {
[16:09:28.194]         base::sink(type = "output", split = FALSE)
[16:09:28.194]         if (TRUE) {
[16:09:28.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.194]         }
[16:09:28.194]         else {
[16:09:28.194]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.194]         }
[16:09:28.194]         base::close(...future.stdout)
[16:09:28.194]         ...future.stdout <- NULL
[16:09:28.194]     }
[16:09:28.194]     ...future.result$conditions <- ...future.conditions
[16:09:28.194]     ...future.result$finished <- base::Sys.time()
[16:09:28.194]     ...future.result
[16:09:28.194] }
[16:09:28.197] assign_globals() ...
[16:09:28.197] List of 5
[16:09:28.197]  $ future.call.arguments    : list()
[16:09:28.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.197]  $ ...future.FUN            :function (x)  
[16:09:28.197]  $ ...future.elements_ii    :List of 1
[16:09:28.197]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:28.197]  $ ...future.seeds_ii       : NULL
[16:09:28.197]  $ ...future.globals.maxSize: NULL
[16:09:28.197]  - attr(*, "where")=List of 5
[16:09:28.197]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.197]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.197]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.197]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.197]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.197]  - attr(*, "resolved")= logi FALSE
[16:09:28.197]  - attr(*, "total_size")= num NA
[16:09:28.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.197]  - attr(*, "already-done")= logi TRUE
[16:09:28.205] - copied ‘future.call.arguments’ to environment
[16:09:28.205] - copied ‘...future.FUN’ to environment
[16:09:28.205] - copied ‘...future.elements_ii’ to environment
[16:09:28.205] - copied ‘...future.seeds_ii’ to environment
[16:09:28.205] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.205] assign_globals() ... done
[16:09:28.206] requestCore(): workers = 2
[16:09:28.208] MulticoreFuture started
[16:09:28.208] - Launch lazy future ... done
[16:09:28.208] run() for ‘MulticoreFuture’ ... done
[16:09:28.209] Created future:
[16:09:28.209] plan(): Setting new future strategy stack:
[16:09:28.209] List of future strategies:
[16:09:28.209] 1. sequential:
[16:09:28.209]    - args: function (..., envir = parent.frame())
[16:09:28.209]    - tweaked: FALSE
[16:09:28.209]    - call: NULL
[16:09:28.210] plan(): nbrOfWorkers() = 1
[16:09:28.212] plan(): Setting new future strategy stack:
[16:09:28.212] List of future strategies:
[16:09:28.212] 1. multicore:
[16:09:28.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.212]    - tweaked: FALSE
[16:09:28.212]    - call: plan(strategy)
[16:09:28.218] plan(): nbrOfWorkers() = 2
[16:09:28.209] MulticoreFuture:
[16:09:28.209] Label: ‘future_apply-2’
[16:09:28.209] Expression:
[16:09:28.209] {
[16:09:28.209]     do.call(function(...) {
[16:09:28.209]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.209]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.209]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.209]             on.exit(options(oopts), add = TRUE)
[16:09:28.209]         }
[16:09:28.209]         {
[16:09:28.209]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.209]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.209]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.209]             })
[16:09:28.209]         }
[16:09:28.209]     }, args = future.call.arguments)
[16:09:28.209] }
[16:09:28.209] Lazy evaluation: FALSE
[16:09:28.209] Asynchronous evaluation: TRUE
[16:09:28.209] Local evaluation: TRUE
[16:09:28.209] Environment: R_GlobalEnv
[16:09:28.209] Capture standard output: TRUE
[16:09:28.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.209] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.209] Packages: <none>
[16:09:28.209] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.209] Resolved: TRUE
[16:09:28.209] Value: <not collected>
[16:09:28.209] Conditions captured: <none>
[16:09:28.209] Early signaling: FALSE
[16:09:28.209] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.209] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.219] Chunk #2 of 2 ... DONE
[16:09:28.219] Launching 2 futures (chunks) ... DONE
[16:09:28.219] Resolving 2 futures (chunks) ...
[16:09:28.220] resolve() on list ...
[16:09:28.220]  recursive: 0
[16:09:28.220]  length: 2
[16:09:28.220] 
[16:09:28.220] Future #1
[16:09:28.221] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.222] - nx: 2
[16:09:28.222] - relay: TRUE
[16:09:28.222] - stdout: TRUE
[16:09:28.222] - signal: TRUE
[16:09:28.222] - resignal: FALSE
[16:09:28.222] - force: TRUE
[16:09:28.222] - relayed: [n=2] FALSE, FALSE
[16:09:28.223] - queued futures: [n=2] FALSE, FALSE
[16:09:28.223]  - until=1
[16:09:28.223]  - relaying element #1
[16:09:28.223] - relayed: [n=2] TRUE, FALSE
[16:09:28.223] - queued futures: [n=2] TRUE, FALSE
[16:09:28.224] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.224]  length: 1 (resolved future 1)
[16:09:28.224] Future #2
[16:09:28.225] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.225] - nx: 2
[16:09:28.225] - relay: TRUE
[16:09:28.225] - stdout: TRUE
[16:09:28.226] - signal: TRUE
[16:09:28.226] - resignal: FALSE
[16:09:28.226] - force: TRUE
[16:09:28.226] - relayed: [n=2] TRUE, FALSE
[16:09:28.226] - queued futures: [n=2] TRUE, FALSE
[16:09:28.226]  - until=2
[16:09:28.226]  - relaying element #2
[16:09:28.226] - relayed: [n=2] TRUE, TRUE
[16:09:28.227] - queued futures: [n=2] TRUE, TRUE
[16:09:28.227] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.227]  length: 0 (resolved future 2)
[16:09:28.227] Relaying remaining futures
[16:09:28.227] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.227] - nx: 2
[16:09:28.227] - relay: TRUE
[16:09:28.227] - stdout: TRUE
[16:09:28.227] - signal: TRUE
[16:09:28.228] - resignal: FALSE
[16:09:28.228] - force: TRUE
[16:09:28.228] - relayed: [n=2] TRUE, TRUE
[16:09:28.228] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.228] - relayed: [n=2] TRUE, TRUE
[16:09:28.228] - queued futures: [n=2] TRUE, TRUE
[16:09:28.228] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.228] resolve() on list ... DONE
[16:09:28.229]  - Number of value chunks collected: 2
[16:09:28.229] Resolving 2 futures (chunks) ... DONE
[16:09:28.229] Reducing values from 2 chunks ...
[16:09:28.229]  - Number of values collected after concatenation: 2
[16:09:28.229]  - Number of values expected: 2
[16:09:28.229] Reducing values from 2 chunks ... DONE
[16:09:28.229] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:09:28.230] getGlobalsAndPackagesXApply() ...
[16:09:28.230]  - future.globals: TRUE
[16:09:28.230] getGlobalsAndPackages() ...
[16:09:28.230] Searching for globals...
[16:09:28.232] - globals found: [1] ‘FUN’
[16:09:28.232] Searching for globals ... DONE
[16:09:28.232] Resolving globals: FALSE
[16:09:28.232] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:28.233] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:28.233] - globals: [1] ‘FUN’
[16:09:28.233] 
[16:09:28.233] getGlobalsAndPackages() ... DONE
[16:09:28.233]  - globals found/used: [n=1] ‘FUN’
[16:09:28.236]  - needed namespaces: [n=0] 
[16:09:28.236] Finding globals ... DONE
[16:09:28.236]  - use_args: TRUE
[16:09:28.236]  - Getting '...' globals ...
[16:09:28.237] resolve() on list ...
[16:09:28.237]  recursive: 0
[16:09:28.237]  length: 1
[16:09:28.237]  elements: ‘...’
[16:09:28.237]  length: 0 (resolved future 1)
[16:09:28.238] resolve() on list ... DONE
[16:09:28.238]    - '...' content: [n=0] 
[16:09:28.238] List of 1
[16:09:28.238]  $ ...: list()
[16:09:28.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.238]  - attr(*, "where")=List of 1
[16:09:28.238]   ..$ ...:<environment: 0x5633ac5cda48> 
[16:09:28.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.238]  - attr(*, "resolved")= logi TRUE
[16:09:28.238]  - attr(*, "total_size")= num NA
[16:09:28.242]  - Getting '...' globals ... DONE
[16:09:28.242] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.242] List of 2
[16:09:28.242]  $ ...future.FUN:function (x)  
[16:09:28.242]  $ ...          : list()
[16:09:28.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.242]  - attr(*, "where")=List of 2
[16:09:28.242]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.242]   ..$ ...          :<environment: 0x5633ac5cda48> 
[16:09:28.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.242]  - attr(*, "resolved")= logi FALSE
[16:09:28.242]  - attr(*, "total_size")= num 848
[16:09:28.246] Packages to be attached in all futures: [n=0] 
[16:09:28.246] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.250] future_lapply() ...
[16:09:28.253] Number of chunks: 2
[16:09:28.254] getGlobalsAndPackagesXApply() ...
[16:09:28.254]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.254]  - use_args: TRUE
[16:09:28.254] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.254] List of 2
[16:09:28.254]  $ ...          : list()
[16:09:28.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.254]  $ ...future.FUN:function (x)  
[16:09:28.254]  - attr(*, "where")=List of 2
[16:09:28.254]   ..$ ...          :<environment: 0x5633ac5cda48> 
[16:09:28.254]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:28.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.254]  - attr(*, "resolved")= logi FALSE
[16:09:28.254]  - attr(*, "total_size")= num NA
[16:09:28.258] Packages to be attached in all futures: [n=0] 
[16:09:28.258] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.258] Number of futures (= number of chunks): 2
[16:09:28.258] Launching 2 futures (chunks) ...
[16:09:28.258] Chunk #1 of 2 ...
[16:09:28.258]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:28.258]  - seeds: <none>
[16:09:28.258] getGlobalsAndPackages() ...
[16:09:28.259] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.259] Resolving globals: FALSE
[16:09:28.259] Tweak future expression to call with '...' arguments ...
[16:09:28.259] {
[16:09:28.259]     do.call(function(...) {
[16:09:28.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.259]             on.exit(options(oopts), add = TRUE)
[16:09:28.259]         }
[16:09:28.259]         {
[16:09:28.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.259]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.259]             })
[16:09:28.259]         }
[16:09:28.259]     }, args = future.call.arguments)
[16:09:28.259] }
[16:09:28.259] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.260] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.260] 
[16:09:28.260] getGlobalsAndPackages() ... DONE
[16:09:28.260] run() for ‘Future’ ...
[16:09:28.260] - state: ‘created’
[16:09:28.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.264] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.264]   - Field: ‘label’
[16:09:28.264]   - Field: ‘local’
[16:09:28.264]   - Field: ‘owner’
[16:09:28.265]   - Field: ‘envir’
[16:09:28.265]   - Field: ‘workers’
[16:09:28.265]   - Field: ‘packages’
[16:09:28.265]   - Field: ‘gc’
[16:09:28.265]   - Field: ‘job’
[16:09:28.265]   - Field: ‘conditions’
[16:09:28.265]   - Field: ‘expr’
[16:09:28.265]   - Field: ‘uuid’
[16:09:28.265]   - Field: ‘seed’
[16:09:28.265]   - Field: ‘version’
[16:09:28.265]   - Field: ‘result’
[16:09:28.266]   - Field: ‘asynchronous’
[16:09:28.266]   - Field: ‘calls’
[16:09:28.266]   - Field: ‘globals’
[16:09:28.266]   - Field: ‘stdout’
[16:09:28.266]   - Field: ‘earlySignal’
[16:09:28.266]   - Field: ‘lazy’
[16:09:28.266]   - Field: ‘state’
[16:09:28.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.266] - Launch lazy future ...
[16:09:28.268] Packages needed by the future expression (n = 0): <none>
[16:09:28.268] Packages needed by future strategies (n = 0): <none>
[16:09:28.269] {
[16:09:28.269]     {
[16:09:28.269]         {
[16:09:28.269]             ...future.startTime <- base::Sys.time()
[16:09:28.269]             {
[16:09:28.269]                 {
[16:09:28.269]                   {
[16:09:28.269]                     {
[16:09:28.269]                       base::local({
[16:09:28.269]                         has_future <- base::requireNamespace("future", 
[16:09:28.269]                           quietly = TRUE)
[16:09:28.269]                         if (has_future) {
[16:09:28.269]                           ns <- base::getNamespace("future")
[16:09:28.269]                           version <- ns[[".package"]][["version"]]
[16:09:28.269]                           if (is.null(version)) 
[16:09:28.269]                             version <- utils::packageVersion("future")
[16:09:28.269]                         }
[16:09:28.269]                         else {
[16:09:28.269]                           version <- NULL
[16:09:28.269]                         }
[16:09:28.269]                         if (!has_future || version < "1.8.0") {
[16:09:28.269]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.269]                             "", base::R.version$version.string), 
[16:09:28.269]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.269]                               "release", "version")], collapse = " "), 
[16:09:28.269]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.269]                             info)
[16:09:28.269]                           info <- base::paste(info, collapse = "; ")
[16:09:28.269]                           if (!has_future) {
[16:09:28.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.269]                               info)
[16:09:28.269]                           }
[16:09:28.269]                           else {
[16:09:28.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.269]                               info, version)
[16:09:28.269]                           }
[16:09:28.269]                           base::stop(msg)
[16:09:28.269]                         }
[16:09:28.269]                       })
[16:09:28.269]                     }
[16:09:28.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.269]                     base::options(mc.cores = 1L)
[16:09:28.269]                   }
[16:09:28.269]                   options(future.plan = NULL)
[16:09:28.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.269]                 }
[16:09:28.269]                 ...future.workdir <- getwd()
[16:09:28.269]             }
[16:09:28.269]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.269]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.269]         }
[16:09:28.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.269]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.269]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.269]             base::names(...future.oldOptions))
[16:09:28.269]     }
[16:09:28.269]     if (FALSE) {
[16:09:28.269]     }
[16:09:28.269]     else {
[16:09:28.269]         if (TRUE) {
[16:09:28.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.269]                 open = "w")
[16:09:28.269]         }
[16:09:28.269]         else {
[16:09:28.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.269]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.269]         }
[16:09:28.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.269]             base::sink(type = "output", split = FALSE)
[16:09:28.269]             base::close(...future.stdout)
[16:09:28.269]         }, add = TRUE)
[16:09:28.269]     }
[16:09:28.269]     ...future.frame <- base::sys.nframe()
[16:09:28.269]     ...future.conditions <- base::list()
[16:09:28.269]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.269]     if (FALSE) {
[16:09:28.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.269]     }
[16:09:28.269]     ...future.result <- base::tryCatch({
[16:09:28.269]         base::withCallingHandlers({
[16:09:28.269]             ...future.value <- base::withVisible(base::local({
[16:09:28.269]                 withCallingHandlers({
[16:09:28.269]                   {
[16:09:28.269]                     do.call(function(...) {
[16:09:28.269]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.269]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.269]                         ...future.globals.maxSize)) {
[16:09:28.269]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.269]                         on.exit(options(oopts), add = TRUE)
[16:09:28.269]                       }
[16:09:28.269]                       {
[16:09:28.269]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.269]                           FUN = function(jj) {
[16:09:28.269]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.269]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.269]                           })
[16:09:28.269]                       }
[16:09:28.269]                     }, args = future.call.arguments)
[16:09:28.269]                   }
[16:09:28.269]                 }, immediateCondition = function(cond) {
[16:09:28.269]                   save_rds <- function (object, pathname, ...) 
[16:09:28.269]                   {
[16:09:28.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.269]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.269]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.269]                         fi_tmp[["mtime"]])
[16:09:28.269]                     }
[16:09:28.269]                     tryCatch({
[16:09:28.269]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.269]                     }, error = function(ex) {
[16:09:28.269]                       msg <- conditionMessage(ex)
[16:09:28.269]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.269]                         fi_tmp[["mtime"]], msg)
[16:09:28.269]                       ex$message <- msg
[16:09:28.269]                       stop(ex)
[16:09:28.269]                     })
[16:09:28.269]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.269]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.269]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.269]                       fi <- file.info(pathname)
[16:09:28.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.269]                         fi[["size"]], fi[["mtime"]])
[16:09:28.269]                       stop(msg)
[16:09:28.269]                     }
[16:09:28.269]                     invisible(pathname)
[16:09:28.269]                   }
[16:09:28.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.269]                     rootPath = tempdir()) 
[16:09:28.269]                   {
[16:09:28.269]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.269]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.269]                       tmpdir = path, fileext = ".rds")
[16:09:28.269]                     save_rds(obj, file)
[16:09:28.269]                   }
[16:09:28.269]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.269]                   {
[16:09:28.269]                     inherits <- base::inherits
[16:09:28.269]                     invokeRestart <- base::invokeRestart
[16:09:28.269]                     is.null <- base::is.null
[16:09:28.269]                     muffled <- FALSE
[16:09:28.269]                     if (inherits(cond, "message")) {
[16:09:28.269]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.269]                       if (muffled) 
[16:09:28.269]                         invokeRestart("muffleMessage")
[16:09:28.269]                     }
[16:09:28.269]                     else if (inherits(cond, "warning")) {
[16:09:28.269]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.269]                       if (muffled) 
[16:09:28.269]                         invokeRestart("muffleWarning")
[16:09:28.269]                     }
[16:09:28.269]                     else if (inherits(cond, "condition")) {
[16:09:28.269]                       if (!is.null(pattern)) {
[16:09:28.269]                         computeRestarts <- base::computeRestarts
[16:09:28.269]                         grepl <- base::grepl
[16:09:28.269]                         restarts <- computeRestarts(cond)
[16:09:28.269]                         for (restart in restarts) {
[16:09:28.269]                           name <- restart$name
[16:09:28.269]                           if (is.null(name)) 
[16:09:28.269]                             next
[16:09:28.269]                           if (!grepl(pattern, name)) 
[16:09:28.269]                             next
[16:09:28.269]                           invokeRestart(restart)
[16:09:28.269]                           muffled <- TRUE
[16:09:28.269]                           break
[16:09:28.269]                         }
[16:09:28.269]                       }
[16:09:28.269]                     }
[16:09:28.269]                     invisible(muffled)
[16:09:28.269]                   }
[16:09:28.269]                   muffleCondition(cond)
[16:09:28.269]                 })
[16:09:28.269]             }))
[16:09:28.269]             future::FutureResult(value = ...future.value$value, 
[16:09:28.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.269]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.269]                     ...future.globalenv.names))
[16:09:28.269]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.269]         }, condition = base::local({
[16:09:28.269]             c <- base::c
[16:09:28.269]             inherits <- base::inherits
[16:09:28.269]             invokeRestart <- base::invokeRestart
[16:09:28.269]             length <- base::length
[16:09:28.269]             list <- base::list
[16:09:28.269]             seq.int <- base::seq.int
[16:09:28.269]             signalCondition <- base::signalCondition
[16:09:28.269]             sys.calls <- base::sys.calls
[16:09:28.269]             `[[` <- base::`[[`
[16:09:28.269]             `+` <- base::`+`
[16:09:28.269]             `<<-` <- base::`<<-`
[16:09:28.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.269]                   3L)]
[16:09:28.269]             }
[16:09:28.269]             function(cond) {
[16:09:28.269]                 is_error <- inherits(cond, "error")
[16:09:28.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.269]                   NULL)
[16:09:28.269]                 if (is_error) {
[16:09:28.269]                   sessionInformation <- function() {
[16:09:28.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.269]                       search = base::search(), system = base::Sys.info())
[16:09:28.269]                   }
[16:09:28.269]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.269]                     cond$call), session = sessionInformation(), 
[16:09:28.269]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.269]                   signalCondition(cond)
[16:09:28.269]                 }
[16:09:28.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.269]                 "immediateCondition"))) {
[16:09:28.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.269]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.269]                   if (TRUE && !signal) {
[16:09:28.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.269]                     {
[16:09:28.269]                       inherits <- base::inherits
[16:09:28.269]                       invokeRestart <- base::invokeRestart
[16:09:28.269]                       is.null <- base::is.null
[16:09:28.269]                       muffled <- FALSE
[16:09:28.269]                       if (inherits(cond, "message")) {
[16:09:28.269]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.269]                         if (muffled) 
[16:09:28.269]                           invokeRestart("muffleMessage")
[16:09:28.269]                       }
[16:09:28.269]                       else if (inherits(cond, "warning")) {
[16:09:28.269]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.269]                         if (muffled) 
[16:09:28.269]                           invokeRestart("muffleWarning")
[16:09:28.269]                       }
[16:09:28.269]                       else if (inherits(cond, "condition")) {
[16:09:28.269]                         if (!is.null(pattern)) {
[16:09:28.269]                           computeRestarts <- base::computeRestarts
[16:09:28.269]                           grepl <- base::grepl
[16:09:28.269]                           restarts <- computeRestarts(cond)
[16:09:28.269]                           for (restart in restarts) {
[16:09:28.269]                             name <- restart$name
[16:09:28.269]                             if (is.null(name)) 
[16:09:28.269]                               next
[16:09:28.269]                             if (!grepl(pattern, name)) 
[16:09:28.269]                               next
[16:09:28.269]                             invokeRestart(restart)
[16:09:28.269]                             muffled <- TRUE
[16:09:28.269]                             break
[16:09:28.269]                           }
[16:09:28.269]                         }
[16:09:28.269]                       }
[16:09:28.269]                       invisible(muffled)
[16:09:28.269]                     }
[16:09:28.269]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.269]                   }
[16:09:28.269]                 }
[16:09:28.269]                 else {
[16:09:28.269]                   if (TRUE) {
[16:09:28.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.269]                     {
[16:09:28.269]                       inherits <- base::inherits
[16:09:28.269]                       invokeRestart <- base::invokeRestart
[16:09:28.269]                       is.null <- base::is.null
[16:09:28.269]                       muffled <- FALSE
[16:09:28.269]                       if (inherits(cond, "message")) {
[16:09:28.269]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.269]                         if (muffled) 
[16:09:28.269]                           invokeRestart("muffleMessage")
[16:09:28.269]                       }
[16:09:28.269]                       else if (inherits(cond, "warning")) {
[16:09:28.269]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.269]                         if (muffled) 
[16:09:28.269]                           invokeRestart("muffleWarning")
[16:09:28.269]                       }
[16:09:28.269]                       else if (inherits(cond, "condition")) {
[16:09:28.269]                         if (!is.null(pattern)) {
[16:09:28.269]                           computeRestarts <- base::computeRestarts
[16:09:28.269]                           grepl <- base::grepl
[16:09:28.269]                           restarts <- computeRestarts(cond)
[16:09:28.269]                           for (restart in restarts) {
[16:09:28.269]                             name <- restart$name
[16:09:28.269]                             if (is.null(name)) 
[16:09:28.269]                               next
[16:09:28.269]                             if (!grepl(pattern, name)) 
[16:09:28.269]                               next
[16:09:28.269]                             invokeRestart(restart)
[16:09:28.269]                             muffled <- TRUE
[16:09:28.269]                             break
[16:09:28.269]                           }
[16:09:28.269]                         }
[16:09:28.269]                       }
[16:09:28.269]                       invisible(muffled)
[16:09:28.269]                     }
[16:09:28.269]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.269]                   }
[16:09:28.269]                 }
[16:09:28.269]             }
[16:09:28.269]         }))
[16:09:28.269]     }, error = function(ex) {
[16:09:28.269]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.269]                 ...future.rng), started = ...future.startTime, 
[16:09:28.269]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.269]             version = "1.8"), class = "FutureResult")
[16:09:28.269]     }, finally = {
[16:09:28.269]         if (!identical(...future.workdir, getwd())) 
[16:09:28.269]             setwd(...future.workdir)
[16:09:28.269]         {
[16:09:28.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.269]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.269]             }
[16:09:28.269]             base::options(...future.oldOptions)
[16:09:28.269]             if (.Platform$OS.type == "windows") {
[16:09:28.269]                 old_names <- names(...future.oldEnvVars)
[16:09:28.269]                 envs <- base::Sys.getenv()
[16:09:28.269]                 names <- names(envs)
[16:09:28.269]                 common <- intersect(names, old_names)
[16:09:28.269]                 added <- setdiff(names, old_names)
[16:09:28.269]                 removed <- setdiff(old_names, names)
[16:09:28.269]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.269]                   envs[common]]
[16:09:28.269]                 NAMES <- toupper(changed)
[16:09:28.269]                 args <- list()
[16:09:28.269]                 for (kk in seq_along(NAMES)) {
[16:09:28.269]                   name <- changed[[kk]]
[16:09:28.269]                   NAME <- NAMES[[kk]]
[16:09:28.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.269]                     next
[16:09:28.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.269]                 }
[16:09:28.269]                 NAMES <- toupper(added)
[16:09:28.269]                 for (kk in seq_along(NAMES)) {
[16:09:28.269]                   name <- added[[kk]]
[16:09:28.269]                   NAME <- NAMES[[kk]]
[16:09:28.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.269]                     next
[16:09:28.269]                   args[[name]] <- ""
[16:09:28.269]                 }
[16:09:28.269]                 NAMES <- toupper(removed)
[16:09:28.269]                 for (kk in seq_along(NAMES)) {
[16:09:28.269]                   name <- removed[[kk]]
[16:09:28.269]                   NAME <- NAMES[[kk]]
[16:09:28.269]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.269]                     next
[16:09:28.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.269]                 }
[16:09:28.269]                 if (length(args) > 0) 
[16:09:28.269]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.269]             }
[16:09:28.269]             else {
[16:09:28.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.269]             }
[16:09:28.269]             {
[16:09:28.269]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.269]                   0L) {
[16:09:28.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.269]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.269]                   base::options(opts)
[16:09:28.269]                 }
[16:09:28.269]                 {
[16:09:28.269]                   {
[16:09:28.269]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.269]                     NULL
[16:09:28.269]                   }
[16:09:28.269]                   options(future.plan = NULL)
[16:09:28.269]                   if (is.na(NA_character_)) 
[16:09:28.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.269]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.269]                     envir = parent.frame()) 
[16:09:28.269]                   {
[16:09:28.269]                     default_workers <- missing(workers)
[16:09:28.269]                     if (is.function(workers)) 
[16:09:28.269]                       workers <- workers()
[16:09:28.269]                     workers <- structure(as.integer(workers), 
[16:09:28.269]                       class = class(workers))
[16:09:28.269]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.269]                       1L)
[16:09:28.269]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.269]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.269]                       if (default_workers) 
[16:09:28.269]                         supportsMulticore(warn = TRUE)
[16:09:28.269]                       return(sequential(..., envir = envir))
[16:09:28.269]                     }
[16:09:28.269]                     oopts <- options(mc.cores = workers)
[16:09:28.269]                     on.exit(options(oopts))
[16:09:28.269]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.269]                       envir = envir)
[16:09:28.269]                     if (!future$lazy) 
[16:09:28.269]                       future <- run(future)
[16:09:28.269]                     invisible(future)
[16:09:28.269]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.269]                 }
[16:09:28.269]             }
[16:09:28.269]         }
[16:09:28.269]     })
[16:09:28.269]     if (TRUE) {
[16:09:28.269]         base::sink(type = "output", split = FALSE)
[16:09:28.269]         if (TRUE) {
[16:09:28.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.269]         }
[16:09:28.269]         else {
[16:09:28.269]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.269]         }
[16:09:28.269]         base::close(...future.stdout)
[16:09:28.269]         ...future.stdout <- NULL
[16:09:28.269]     }
[16:09:28.269]     ...future.result$conditions <- ...future.conditions
[16:09:28.269]     ...future.result$finished <- base::Sys.time()
[16:09:28.269]     ...future.result
[16:09:28.269] }
[16:09:28.271] assign_globals() ...
[16:09:28.271] List of 5
[16:09:28.271]  $ future.call.arguments    : list()
[16:09:28.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.271]  $ ...future.FUN            :function (x)  
[16:09:28.271]  $ ...future.elements_ii    :List of 3
[16:09:28.271]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:28.271]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:28.271]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:28.271]  $ ...future.seeds_ii       : NULL
[16:09:28.271]  $ ...future.globals.maxSize: num Inf
[16:09:28.271]  - attr(*, "resolved")= logi FALSE
[16:09:28.271]  - attr(*, "total_size")= num NA
[16:09:28.271]  - attr(*, "where")=List of 5
[16:09:28.271]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.271]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.271]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.271]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.271]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.271]  - attr(*, "already-done")= logi TRUE
[16:09:28.277] - copied ‘future.call.arguments’ to environment
[16:09:28.277] - copied ‘...future.FUN’ to environment
[16:09:28.277] - copied ‘...future.elements_ii’ to environment
[16:09:28.278] - copied ‘...future.seeds_ii’ to environment
[16:09:28.278] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.278] assign_globals() ... done
[16:09:28.278] requestCore(): workers = 2
[16:09:28.280] MulticoreFuture started
[16:09:28.280] - Launch lazy future ... done
[16:09:28.281] run() for ‘MulticoreFuture’ ... done
[16:09:28.281] Created future:
[16:09:28.281] plan(): Setting new future strategy stack:
[16:09:28.281] List of future strategies:
[16:09:28.281] 1. sequential:
[16:09:28.281]    - args: function (..., envir = parent.frame())
[16:09:28.281]    - tweaked: FALSE
[16:09:28.281]    - call: NULL
[16:09:28.282] plan(): nbrOfWorkers() = 1
[16:09:28.284] plan(): Setting new future strategy stack:
[16:09:28.284] List of future strategies:
[16:09:28.284] 1. multicore:
[16:09:28.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.284]    - tweaked: FALSE
[16:09:28.284]    - call: plan(strategy)
[16:09:28.290] plan(): nbrOfWorkers() = 2
[16:09:28.281] MulticoreFuture:
[16:09:28.281] Label: ‘future_apply-1’
[16:09:28.281] Expression:
[16:09:28.281] {
[16:09:28.281]     do.call(function(...) {
[16:09:28.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.281]             on.exit(options(oopts), add = TRUE)
[16:09:28.281]         }
[16:09:28.281]         {
[16:09:28.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.281]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.281]             })
[16:09:28.281]         }
[16:09:28.281]     }, args = future.call.arguments)
[16:09:28.281] }
[16:09:28.281] Lazy evaluation: FALSE
[16:09:28.281] Asynchronous evaluation: TRUE
[16:09:28.281] Local evaluation: TRUE
[16:09:28.281] Environment: R_GlobalEnv
[16:09:28.281] Capture standard output: TRUE
[16:09:28.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.281] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:28.281] Packages: <none>
[16:09:28.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.281] Resolved: TRUE
[16:09:28.281] Value: <not collected>
[16:09:28.281] Conditions captured: <none>
[16:09:28.281] Early signaling: FALSE
[16:09:28.281] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.281] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.291] Chunk #1 of 2 ... DONE
[16:09:28.291] Chunk #2 of 2 ...
[16:09:28.291]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:28.291]  - seeds: <none>
[16:09:28.291] getGlobalsAndPackages() ...
[16:09:28.292] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.292] Resolving globals: FALSE
[16:09:28.292] Tweak future expression to call with '...' arguments ...
[16:09:28.292] {
[16:09:28.292]     do.call(function(...) {
[16:09:28.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.292]             on.exit(options(oopts), add = TRUE)
[16:09:28.292]         }
[16:09:28.292]         {
[16:09:28.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.292]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.292]             })
[16:09:28.292]         }
[16:09:28.292]     }, args = future.call.arguments)
[16:09:28.292] }
[16:09:28.292] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.293] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.293] 
[16:09:28.293] getGlobalsAndPackages() ... DONE
[16:09:28.294] run() for ‘Future’ ...
[16:09:28.294] - state: ‘created’
[16:09:28.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.299] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.299]   - Field: ‘label’
[16:09:28.299]   - Field: ‘local’
[16:09:28.300]   - Field: ‘owner’
[16:09:28.300]   - Field: ‘envir’
[16:09:28.300]   - Field: ‘workers’
[16:09:28.300]   - Field: ‘packages’
[16:09:28.300]   - Field: ‘gc’
[16:09:28.300]   - Field: ‘job’
[16:09:28.301]   - Field: ‘conditions’
[16:09:28.301]   - Field: ‘expr’
[16:09:28.301]   - Field: ‘uuid’
[16:09:28.301]   - Field: ‘seed’
[16:09:28.301]   - Field: ‘version’
[16:09:28.301]   - Field: ‘result’
[16:09:28.302]   - Field: ‘asynchronous’
[16:09:28.302]   - Field: ‘calls’
[16:09:28.302]   - Field: ‘globals’
[16:09:28.302]   - Field: ‘stdout’
[16:09:28.302]   - Field: ‘earlySignal’
[16:09:28.302]   - Field: ‘lazy’
[16:09:28.302]   - Field: ‘state’
[16:09:28.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.303] - Launch lazy future ...
[16:09:28.303] Packages needed by the future expression (n = 0): <none>
[16:09:28.303] Packages needed by future strategies (n = 0): <none>
[16:09:28.304] {
[16:09:28.304]     {
[16:09:28.304]         {
[16:09:28.304]             ...future.startTime <- base::Sys.time()
[16:09:28.304]             {
[16:09:28.304]                 {
[16:09:28.304]                   {
[16:09:28.304]                     {
[16:09:28.304]                       base::local({
[16:09:28.304]                         has_future <- base::requireNamespace("future", 
[16:09:28.304]                           quietly = TRUE)
[16:09:28.304]                         if (has_future) {
[16:09:28.304]                           ns <- base::getNamespace("future")
[16:09:28.304]                           version <- ns[[".package"]][["version"]]
[16:09:28.304]                           if (is.null(version)) 
[16:09:28.304]                             version <- utils::packageVersion("future")
[16:09:28.304]                         }
[16:09:28.304]                         else {
[16:09:28.304]                           version <- NULL
[16:09:28.304]                         }
[16:09:28.304]                         if (!has_future || version < "1.8.0") {
[16:09:28.304]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.304]                             "", base::R.version$version.string), 
[16:09:28.304]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.304]                               "release", "version")], collapse = " "), 
[16:09:28.304]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.304]                             info)
[16:09:28.304]                           info <- base::paste(info, collapse = "; ")
[16:09:28.304]                           if (!has_future) {
[16:09:28.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.304]                               info)
[16:09:28.304]                           }
[16:09:28.304]                           else {
[16:09:28.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.304]                               info, version)
[16:09:28.304]                           }
[16:09:28.304]                           base::stop(msg)
[16:09:28.304]                         }
[16:09:28.304]                       })
[16:09:28.304]                     }
[16:09:28.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.304]                     base::options(mc.cores = 1L)
[16:09:28.304]                   }
[16:09:28.304]                   options(future.plan = NULL)
[16:09:28.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.304]                 }
[16:09:28.304]                 ...future.workdir <- getwd()
[16:09:28.304]             }
[16:09:28.304]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.304]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.304]         }
[16:09:28.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.304]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.304]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.304]             base::names(...future.oldOptions))
[16:09:28.304]     }
[16:09:28.304]     if (FALSE) {
[16:09:28.304]     }
[16:09:28.304]     else {
[16:09:28.304]         if (TRUE) {
[16:09:28.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.304]                 open = "w")
[16:09:28.304]         }
[16:09:28.304]         else {
[16:09:28.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.304]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.304]         }
[16:09:28.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.304]             base::sink(type = "output", split = FALSE)
[16:09:28.304]             base::close(...future.stdout)
[16:09:28.304]         }, add = TRUE)
[16:09:28.304]     }
[16:09:28.304]     ...future.frame <- base::sys.nframe()
[16:09:28.304]     ...future.conditions <- base::list()
[16:09:28.304]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.304]     if (FALSE) {
[16:09:28.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.304]     }
[16:09:28.304]     ...future.result <- base::tryCatch({
[16:09:28.304]         base::withCallingHandlers({
[16:09:28.304]             ...future.value <- base::withVisible(base::local({
[16:09:28.304]                 withCallingHandlers({
[16:09:28.304]                   {
[16:09:28.304]                     do.call(function(...) {
[16:09:28.304]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.304]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.304]                         ...future.globals.maxSize)) {
[16:09:28.304]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.304]                         on.exit(options(oopts), add = TRUE)
[16:09:28.304]                       }
[16:09:28.304]                       {
[16:09:28.304]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.304]                           FUN = function(jj) {
[16:09:28.304]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.304]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.304]                           })
[16:09:28.304]                       }
[16:09:28.304]                     }, args = future.call.arguments)
[16:09:28.304]                   }
[16:09:28.304]                 }, immediateCondition = function(cond) {
[16:09:28.304]                   save_rds <- function (object, pathname, ...) 
[16:09:28.304]                   {
[16:09:28.304]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.304]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.304]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.304]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.304]                         fi_tmp[["mtime"]])
[16:09:28.304]                     }
[16:09:28.304]                     tryCatch({
[16:09:28.304]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.304]                     }, error = function(ex) {
[16:09:28.304]                       msg <- conditionMessage(ex)
[16:09:28.304]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.304]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.304]                         fi_tmp[["mtime"]], msg)
[16:09:28.304]                       ex$message <- msg
[16:09:28.304]                       stop(ex)
[16:09:28.304]                     })
[16:09:28.304]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.304]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.304]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.304]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.304]                       fi <- file.info(pathname)
[16:09:28.304]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.304]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.304]                         fi[["size"]], fi[["mtime"]])
[16:09:28.304]                       stop(msg)
[16:09:28.304]                     }
[16:09:28.304]                     invisible(pathname)
[16:09:28.304]                   }
[16:09:28.304]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.304]                     rootPath = tempdir()) 
[16:09:28.304]                   {
[16:09:28.304]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.304]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.304]                       tmpdir = path, fileext = ".rds")
[16:09:28.304]                     save_rds(obj, file)
[16:09:28.304]                   }
[16:09:28.304]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.304]                   {
[16:09:28.304]                     inherits <- base::inherits
[16:09:28.304]                     invokeRestart <- base::invokeRestart
[16:09:28.304]                     is.null <- base::is.null
[16:09:28.304]                     muffled <- FALSE
[16:09:28.304]                     if (inherits(cond, "message")) {
[16:09:28.304]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.304]                       if (muffled) 
[16:09:28.304]                         invokeRestart("muffleMessage")
[16:09:28.304]                     }
[16:09:28.304]                     else if (inherits(cond, "warning")) {
[16:09:28.304]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.304]                       if (muffled) 
[16:09:28.304]                         invokeRestart("muffleWarning")
[16:09:28.304]                     }
[16:09:28.304]                     else if (inherits(cond, "condition")) {
[16:09:28.304]                       if (!is.null(pattern)) {
[16:09:28.304]                         computeRestarts <- base::computeRestarts
[16:09:28.304]                         grepl <- base::grepl
[16:09:28.304]                         restarts <- computeRestarts(cond)
[16:09:28.304]                         for (restart in restarts) {
[16:09:28.304]                           name <- restart$name
[16:09:28.304]                           if (is.null(name)) 
[16:09:28.304]                             next
[16:09:28.304]                           if (!grepl(pattern, name)) 
[16:09:28.304]                             next
[16:09:28.304]                           invokeRestart(restart)
[16:09:28.304]                           muffled <- TRUE
[16:09:28.304]                           break
[16:09:28.304]                         }
[16:09:28.304]                       }
[16:09:28.304]                     }
[16:09:28.304]                     invisible(muffled)
[16:09:28.304]                   }
[16:09:28.304]                   muffleCondition(cond)
[16:09:28.304]                 })
[16:09:28.304]             }))
[16:09:28.304]             future::FutureResult(value = ...future.value$value, 
[16:09:28.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.304]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.304]                     ...future.globalenv.names))
[16:09:28.304]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.304]         }, condition = base::local({
[16:09:28.304]             c <- base::c
[16:09:28.304]             inherits <- base::inherits
[16:09:28.304]             invokeRestart <- base::invokeRestart
[16:09:28.304]             length <- base::length
[16:09:28.304]             list <- base::list
[16:09:28.304]             seq.int <- base::seq.int
[16:09:28.304]             signalCondition <- base::signalCondition
[16:09:28.304]             sys.calls <- base::sys.calls
[16:09:28.304]             `[[` <- base::`[[`
[16:09:28.304]             `+` <- base::`+`
[16:09:28.304]             `<<-` <- base::`<<-`
[16:09:28.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.304]                   3L)]
[16:09:28.304]             }
[16:09:28.304]             function(cond) {
[16:09:28.304]                 is_error <- inherits(cond, "error")
[16:09:28.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.304]                   NULL)
[16:09:28.304]                 if (is_error) {
[16:09:28.304]                   sessionInformation <- function() {
[16:09:28.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.304]                       search = base::search(), system = base::Sys.info())
[16:09:28.304]                   }
[16:09:28.304]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.304]                     cond$call), session = sessionInformation(), 
[16:09:28.304]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.304]                   signalCondition(cond)
[16:09:28.304]                 }
[16:09:28.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.304]                 "immediateCondition"))) {
[16:09:28.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.304]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.304]                   if (TRUE && !signal) {
[16:09:28.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.304]                     {
[16:09:28.304]                       inherits <- base::inherits
[16:09:28.304]                       invokeRestart <- base::invokeRestart
[16:09:28.304]                       is.null <- base::is.null
[16:09:28.304]                       muffled <- FALSE
[16:09:28.304]                       if (inherits(cond, "message")) {
[16:09:28.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.304]                         if (muffled) 
[16:09:28.304]                           invokeRestart("muffleMessage")
[16:09:28.304]                       }
[16:09:28.304]                       else if (inherits(cond, "warning")) {
[16:09:28.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.304]                         if (muffled) 
[16:09:28.304]                           invokeRestart("muffleWarning")
[16:09:28.304]                       }
[16:09:28.304]                       else if (inherits(cond, "condition")) {
[16:09:28.304]                         if (!is.null(pattern)) {
[16:09:28.304]                           computeRestarts <- base::computeRestarts
[16:09:28.304]                           grepl <- base::grepl
[16:09:28.304]                           restarts <- computeRestarts(cond)
[16:09:28.304]                           for (restart in restarts) {
[16:09:28.304]                             name <- restart$name
[16:09:28.304]                             if (is.null(name)) 
[16:09:28.304]                               next
[16:09:28.304]                             if (!grepl(pattern, name)) 
[16:09:28.304]                               next
[16:09:28.304]                             invokeRestart(restart)
[16:09:28.304]                             muffled <- TRUE
[16:09:28.304]                             break
[16:09:28.304]                           }
[16:09:28.304]                         }
[16:09:28.304]                       }
[16:09:28.304]                       invisible(muffled)
[16:09:28.304]                     }
[16:09:28.304]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.304]                   }
[16:09:28.304]                 }
[16:09:28.304]                 else {
[16:09:28.304]                   if (TRUE) {
[16:09:28.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.304]                     {
[16:09:28.304]                       inherits <- base::inherits
[16:09:28.304]                       invokeRestart <- base::invokeRestart
[16:09:28.304]                       is.null <- base::is.null
[16:09:28.304]                       muffled <- FALSE
[16:09:28.304]                       if (inherits(cond, "message")) {
[16:09:28.304]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.304]                         if (muffled) 
[16:09:28.304]                           invokeRestart("muffleMessage")
[16:09:28.304]                       }
[16:09:28.304]                       else if (inherits(cond, "warning")) {
[16:09:28.304]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.304]                         if (muffled) 
[16:09:28.304]                           invokeRestart("muffleWarning")
[16:09:28.304]                       }
[16:09:28.304]                       else if (inherits(cond, "condition")) {
[16:09:28.304]                         if (!is.null(pattern)) {
[16:09:28.304]                           computeRestarts <- base::computeRestarts
[16:09:28.304]                           grepl <- base::grepl
[16:09:28.304]                           restarts <- computeRestarts(cond)
[16:09:28.304]                           for (restart in restarts) {
[16:09:28.304]                             name <- restart$name
[16:09:28.304]                             if (is.null(name)) 
[16:09:28.304]                               next
[16:09:28.304]                             if (!grepl(pattern, name)) 
[16:09:28.304]                               next
[16:09:28.304]                             invokeRestart(restart)
[16:09:28.304]                             muffled <- TRUE
[16:09:28.304]                             break
[16:09:28.304]                           }
[16:09:28.304]                         }
[16:09:28.304]                       }
[16:09:28.304]                       invisible(muffled)
[16:09:28.304]                     }
[16:09:28.304]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.304]                   }
[16:09:28.304]                 }
[16:09:28.304]             }
[16:09:28.304]         }))
[16:09:28.304]     }, error = function(ex) {
[16:09:28.304]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.304]                 ...future.rng), started = ...future.startTime, 
[16:09:28.304]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.304]             version = "1.8"), class = "FutureResult")
[16:09:28.304]     }, finally = {
[16:09:28.304]         if (!identical(...future.workdir, getwd())) 
[16:09:28.304]             setwd(...future.workdir)
[16:09:28.304]         {
[16:09:28.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.304]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.304]             }
[16:09:28.304]             base::options(...future.oldOptions)
[16:09:28.304]             if (.Platform$OS.type == "windows") {
[16:09:28.304]                 old_names <- names(...future.oldEnvVars)
[16:09:28.304]                 envs <- base::Sys.getenv()
[16:09:28.304]                 names <- names(envs)
[16:09:28.304]                 common <- intersect(names, old_names)
[16:09:28.304]                 added <- setdiff(names, old_names)
[16:09:28.304]                 removed <- setdiff(old_names, names)
[16:09:28.304]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.304]                   envs[common]]
[16:09:28.304]                 NAMES <- toupper(changed)
[16:09:28.304]                 args <- list()
[16:09:28.304]                 for (kk in seq_along(NAMES)) {
[16:09:28.304]                   name <- changed[[kk]]
[16:09:28.304]                   NAME <- NAMES[[kk]]
[16:09:28.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.304]                     next
[16:09:28.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.304]                 }
[16:09:28.304]                 NAMES <- toupper(added)
[16:09:28.304]                 for (kk in seq_along(NAMES)) {
[16:09:28.304]                   name <- added[[kk]]
[16:09:28.304]                   NAME <- NAMES[[kk]]
[16:09:28.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.304]                     next
[16:09:28.304]                   args[[name]] <- ""
[16:09:28.304]                 }
[16:09:28.304]                 NAMES <- toupper(removed)
[16:09:28.304]                 for (kk in seq_along(NAMES)) {
[16:09:28.304]                   name <- removed[[kk]]
[16:09:28.304]                   NAME <- NAMES[[kk]]
[16:09:28.304]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.304]                     next
[16:09:28.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.304]                 }
[16:09:28.304]                 if (length(args) > 0) 
[16:09:28.304]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.304]             }
[16:09:28.304]             else {
[16:09:28.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.304]             }
[16:09:28.304]             {
[16:09:28.304]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.304]                   0L) {
[16:09:28.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.304]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.304]                   base::options(opts)
[16:09:28.304]                 }
[16:09:28.304]                 {
[16:09:28.304]                   {
[16:09:28.304]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.304]                     NULL
[16:09:28.304]                   }
[16:09:28.304]                   options(future.plan = NULL)
[16:09:28.304]                   if (is.na(NA_character_)) 
[16:09:28.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.304]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.304]                     envir = parent.frame()) 
[16:09:28.304]                   {
[16:09:28.304]                     default_workers <- missing(workers)
[16:09:28.304]                     if (is.function(workers)) 
[16:09:28.304]                       workers <- workers()
[16:09:28.304]                     workers <- structure(as.integer(workers), 
[16:09:28.304]                       class = class(workers))
[16:09:28.304]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.304]                       1L)
[16:09:28.304]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.304]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.304]                       if (default_workers) 
[16:09:28.304]                         supportsMulticore(warn = TRUE)
[16:09:28.304]                       return(sequential(..., envir = envir))
[16:09:28.304]                     }
[16:09:28.304]                     oopts <- options(mc.cores = workers)
[16:09:28.304]                     on.exit(options(oopts))
[16:09:28.304]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.304]                       envir = envir)
[16:09:28.304]                     if (!future$lazy) 
[16:09:28.304]                       future <- run(future)
[16:09:28.304]                     invisible(future)
[16:09:28.304]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.304]                 }
[16:09:28.304]             }
[16:09:28.304]         }
[16:09:28.304]     })
[16:09:28.304]     if (TRUE) {
[16:09:28.304]         base::sink(type = "output", split = FALSE)
[16:09:28.304]         if (TRUE) {
[16:09:28.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.304]         }
[16:09:28.304]         else {
[16:09:28.304]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.304]         }
[16:09:28.304]         base::close(...future.stdout)
[16:09:28.304]         ...future.stdout <- NULL
[16:09:28.304]     }
[16:09:28.304]     ...future.result$conditions <- ...future.conditions
[16:09:28.304]     ...future.result$finished <- base::Sys.time()
[16:09:28.304]     ...future.result
[16:09:28.304] }
[16:09:28.307] assign_globals() ...
[16:09:28.308] List of 5
[16:09:28.308]  $ future.call.arguments    : list()
[16:09:28.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.308]  $ ...future.FUN            :function (x)  
[16:09:28.308]  $ ...future.elements_ii    :List of 3
[16:09:28.308]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:28.308]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:09:28.308]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:09:28.308]  $ ...future.seeds_ii       : NULL
[16:09:28.308]  $ ...future.globals.maxSize: num Inf
[16:09:28.308]  - attr(*, "resolved")= logi FALSE
[16:09:28.308]  - attr(*, "total_size")= num NA
[16:09:28.308]  - attr(*, "where")=List of 5
[16:09:28.308]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.308]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.308]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.308]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.308]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.308]  - attr(*, "already-done")= logi TRUE
[16:09:28.321] - copied ‘future.call.arguments’ to environment
[16:09:28.321] - copied ‘...future.FUN’ to environment
[16:09:28.321] - copied ‘...future.elements_ii’ to environment
[16:09:28.321] - copied ‘...future.seeds_ii’ to environment
[16:09:28.322] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.322] assign_globals() ... done
[16:09:28.322] requestCore(): workers = 2
[16:09:28.324] MulticoreFuture started
[16:09:28.325] - Launch lazy future ... done
[16:09:28.325] run() for ‘MulticoreFuture’ ... done
[16:09:28.325] Created future:
[16:09:28.325] plan(): Setting new future strategy stack:
[16:09:28.326] List of future strategies:
[16:09:28.326] 1. sequential:
[16:09:28.326]    - args: function (..., envir = parent.frame())
[16:09:28.326]    - tweaked: FALSE
[16:09:28.326]    - call: NULL
[16:09:28.327] plan(): nbrOfWorkers() = 1
[16:09:28.329] plan(): Setting new future strategy stack:
[16:09:28.329] List of future strategies:
[16:09:28.329] 1. multicore:
[16:09:28.329]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.329]    - tweaked: FALSE
[16:09:28.329]    - call: plan(strategy)
[16:09:28.335] plan(): nbrOfWorkers() = 2
[16:09:28.326] MulticoreFuture:
[16:09:28.326] Label: ‘future_apply-2’
[16:09:28.326] Expression:
[16:09:28.326] {
[16:09:28.326]     do.call(function(...) {
[16:09:28.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.326]             on.exit(options(oopts), add = TRUE)
[16:09:28.326]         }
[16:09:28.326]         {
[16:09:28.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.326]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.326]             })
[16:09:28.326]         }
[16:09:28.326]     }, args = future.call.arguments)
[16:09:28.326] }
[16:09:28.326] Lazy evaluation: FALSE
[16:09:28.326] Asynchronous evaluation: TRUE
[16:09:28.326] Local evaluation: TRUE
[16:09:28.326] Environment: R_GlobalEnv
[16:09:28.326] Capture standard output: TRUE
[16:09:28.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.326] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:28.326] Packages: <none>
[16:09:28.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.326] Resolved: TRUE
[16:09:28.326] Value: <not collected>
[16:09:28.326] Conditions captured: <none>
[16:09:28.326] Early signaling: FALSE
[16:09:28.326] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.326] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.337] Chunk #2 of 2 ... DONE
[16:09:28.337] Launching 2 futures (chunks) ... DONE
[16:09:28.337] Resolving 2 futures (chunks) ...
[16:09:28.337] resolve() on list ...
[16:09:28.337]  recursive: 0
[16:09:28.338]  length: 2
[16:09:28.338] 
[16:09:28.338] Future #1
[16:09:28.340] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.340] - nx: 2
[16:09:28.340] - relay: TRUE
[16:09:28.340] - stdout: TRUE
[16:09:28.341] - signal: TRUE
[16:09:28.341] - resignal: FALSE
[16:09:28.341] - force: TRUE
[16:09:28.341] - relayed: [n=2] FALSE, FALSE
[16:09:28.342] - queued futures: [n=2] FALSE, FALSE
[16:09:28.342]  - until=1
[16:09:28.342]  - relaying element #1
[16:09:28.343] - relayed: [n=2] TRUE, FALSE
[16:09:28.343] - queued futures: [n=2] TRUE, FALSE
[16:09:28.343] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.343]  length: 1 (resolved future 1)
[16:09:28.344] Future #2
[16:09:28.345] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.345] - nx: 2
[16:09:28.345] - relay: TRUE
[16:09:28.345] - stdout: TRUE
[16:09:28.345] - signal: TRUE
[16:09:28.345] - resignal: FALSE
[16:09:28.345] - force: TRUE
[16:09:28.345] - relayed: [n=2] TRUE, FALSE
[16:09:28.346] - queued futures: [n=2] TRUE, FALSE
[16:09:28.346]  - until=2
[16:09:28.346]  - relaying element #2
[16:09:28.346] - relayed: [n=2] TRUE, TRUE
[16:09:28.346] - queued futures: [n=2] TRUE, TRUE
[16:09:28.346] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.347]  length: 0 (resolved future 2)
[16:09:28.347] Relaying remaining futures
[16:09:28.347] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.347] - nx: 2
[16:09:28.347] - relay: TRUE
[16:09:28.347] - stdout: TRUE
[16:09:28.347] - signal: TRUE
[16:09:28.347] - resignal: FALSE
[16:09:28.347] - force: TRUE
[16:09:28.347] - relayed: [n=2] TRUE, TRUE
[16:09:28.348] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.348] - relayed: [n=2] TRUE, TRUE
[16:09:28.348] - queued futures: [n=2] TRUE, TRUE
[16:09:28.348] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.348] resolve() on list ... DONE
[16:09:28.348]  - Number of value chunks collected: 2
[16:09:28.349] Resolving 2 futures (chunks) ... DONE
[16:09:28.349] Reducing values from 2 chunks ...
[16:09:28.349]  - Number of values collected after concatenation: 6
[16:09:28.349]  - Number of values expected: 6
[16:09:28.349] Reducing values from 2 chunks ... DONE
[16:09:28.349] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:09:28.350] getGlobalsAndPackagesXApply() ...
[16:09:28.350]  - future.globals: TRUE
[16:09:28.350] getGlobalsAndPackages() ...
[16:09:28.350] Searching for globals...
[16:09:28.352] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:09:28.352] Searching for globals ... DONE
[16:09:28.352] Resolving globals: FALSE
[16:09:28.353] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:09:28.353] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:09:28.353] - globals: [1] ‘FUN’
[16:09:28.353] 
[16:09:28.353] getGlobalsAndPackages() ... DONE
[16:09:28.353]  - globals found/used: [n=1] ‘FUN’
[16:09:28.354]  - needed namespaces: [n=0] 
[16:09:28.354] Finding globals ... DONE
[16:09:28.354]  - use_args: TRUE
[16:09:28.354]  - Getting '...' globals ...
[16:09:28.354] resolve() on list ...
[16:09:28.354]  recursive: 0
[16:09:28.355]  length: 1
[16:09:28.355]  elements: ‘...’
[16:09:28.355]  length: 0 (resolved future 1)
[16:09:28.355] resolve() on list ... DONE
[16:09:28.355]    - '...' content: [n=0] 
[16:09:28.355] List of 1
[16:09:28.355]  $ ...: list()
[16:09:28.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.355]  - attr(*, "where")=List of 1
[16:09:28.355]   ..$ ...:<environment: 0x5633abe1b160> 
[16:09:28.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.355]  - attr(*, "resolved")= logi TRUE
[16:09:28.355]  - attr(*, "total_size")= num NA
[16:09:28.358]  - Getting '...' globals ... DONE
[16:09:28.359] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.359] List of 2
[16:09:28.359]  $ ...future.FUN:function (x)  
[16:09:28.359]  $ ...          : list()
[16:09:28.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.359]  - attr(*, "where")=List of 2
[16:09:28.359]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.359]   ..$ ...          :<environment: 0x5633abe1b160> 
[16:09:28.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.359]  - attr(*, "resolved")= logi FALSE
[16:09:28.359]  - attr(*, "total_size")= num 1768
[16:09:28.365] Packages to be attached in all futures: [n=0] 
[16:09:28.365] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.369] future_lapply() ...
[16:09:28.373] Number of chunks: 2
[16:09:28.373] getGlobalsAndPackagesXApply() ...
[16:09:28.373]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.373]  - use_args: TRUE
[16:09:28.374] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.374] List of 2
[16:09:28.374]  $ ...          : list()
[16:09:28.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.374]  $ ...future.FUN:function (x)  
[16:09:28.374]  - attr(*, "where")=List of 2
[16:09:28.374]   ..$ ...          :<environment: 0x5633abe1b160> 
[16:09:28.374]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:09:28.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.374]  - attr(*, "resolved")= logi FALSE
[16:09:28.374]  - attr(*, "total_size")= num NA
[16:09:28.377] Packages to be attached in all futures: [n=0] 
[16:09:28.377] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.377] Number of futures (= number of chunks): 2
[16:09:28.377] Launching 2 futures (chunks) ...
[16:09:28.377] Chunk #1 of 2 ...
[16:09:28.377]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:28.377]  - seeds: <none>
[16:09:28.377] getGlobalsAndPackages() ...
[16:09:28.378] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.378] Resolving globals: FALSE
[16:09:28.378] Tweak future expression to call with '...' arguments ...
[16:09:28.378] {
[16:09:28.378]     do.call(function(...) {
[16:09:28.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.378]             on.exit(options(oopts), add = TRUE)
[16:09:28.378]         }
[16:09:28.378]         {
[16:09:28.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.378]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.378]             })
[16:09:28.378]         }
[16:09:28.378]     }, args = future.call.arguments)
[16:09:28.378] }
[16:09:28.378] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.379] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.379] 
[16:09:28.379] getGlobalsAndPackages() ... DONE
[16:09:28.379] run() for ‘Future’ ...
[16:09:28.379] - state: ‘created’
[16:09:28.379] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.383] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.384]   - Field: ‘label’
[16:09:28.384]   - Field: ‘local’
[16:09:28.384]   - Field: ‘owner’
[16:09:28.384]   - Field: ‘envir’
[16:09:28.384]   - Field: ‘workers’
[16:09:28.384]   - Field: ‘packages’
[16:09:28.384]   - Field: ‘gc’
[16:09:28.384]   - Field: ‘job’
[16:09:28.385]   - Field: ‘conditions’
[16:09:28.385]   - Field: ‘expr’
[16:09:28.385]   - Field: ‘uuid’
[16:09:28.385]   - Field: ‘seed’
[16:09:28.385]   - Field: ‘version’
[16:09:28.385]   - Field: ‘result’
[16:09:28.385]   - Field: ‘asynchronous’
[16:09:28.385]   - Field: ‘calls’
[16:09:28.385]   - Field: ‘globals’
[16:09:28.386]   - Field: ‘stdout’
[16:09:28.386]   - Field: ‘earlySignal’
[16:09:28.386]   - Field: ‘lazy’
[16:09:28.386]   - Field: ‘state’
[16:09:28.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.386] - Launch lazy future ...
[16:09:28.386] Packages needed by the future expression (n = 0): <none>
[16:09:28.386] Packages needed by future strategies (n = 0): <none>
[16:09:28.387] {
[16:09:28.387]     {
[16:09:28.387]         {
[16:09:28.387]             ...future.startTime <- base::Sys.time()
[16:09:28.387]             {
[16:09:28.387]                 {
[16:09:28.387]                   {
[16:09:28.387]                     {
[16:09:28.387]                       base::local({
[16:09:28.387]                         has_future <- base::requireNamespace("future", 
[16:09:28.387]                           quietly = TRUE)
[16:09:28.387]                         if (has_future) {
[16:09:28.387]                           ns <- base::getNamespace("future")
[16:09:28.387]                           version <- ns[[".package"]][["version"]]
[16:09:28.387]                           if (is.null(version)) 
[16:09:28.387]                             version <- utils::packageVersion("future")
[16:09:28.387]                         }
[16:09:28.387]                         else {
[16:09:28.387]                           version <- NULL
[16:09:28.387]                         }
[16:09:28.387]                         if (!has_future || version < "1.8.0") {
[16:09:28.387]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.387]                             "", base::R.version$version.string), 
[16:09:28.387]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.387]                               "release", "version")], collapse = " "), 
[16:09:28.387]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.387]                             info)
[16:09:28.387]                           info <- base::paste(info, collapse = "; ")
[16:09:28.387]                           if (!has_future) {
[16:09:28.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.387]                               info)
[16:09:28.387]                           }
[16:09:28.387]                           else {
[16:09:28.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.387]                               info, version)
[16:09:28.387]                           }
[16:09:28.387]                           base::stop(msg)
[16:09:28.387]                         }
[16:09:28.387]                       })
[16:09:28.387]                     }
[16:09:28.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.387]                     base::options(mc.cores = 1L)
[16:09:28.387]                   }
[16:09:28.387]                   options(future.plan = NULL)
[16:09:28.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.387]                 }
[16:09:28.387]                 ...future.workdir <- getwd()
[16:09:28.387]             }
[16:09:28.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.387]         }
[16:09:28.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.387]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.387]             base::names(...future.oldOptions))
[16:09:28.387]     }
[16:09:28.387]     if (FALSE) {
[16:09:28.387]     }
[16:09:28.387]     else {
[16:09:28.387]         if (TRUE) {
[16:09:28.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.387]                 open = "w")
[16:09:28.387]         }
[16:09:28.387]         else {
[16:09:28.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.387]         }
[16:09:28.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.387]             base::sink(type = "output", split = FALSE)
[16:09:28.387]             base::close(...future.stdout)
[16:09:28.387]         }, add = TRUE)
[16:09:28.387]     }
[16:09:28.387]     ...future.frame <- base::sys.nframe()
[16:09:28.387]     ...future.conditions <- base::list()
[16:09:28.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.387]     if (FALSE) {
[16:09:28.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.387]     }
[16:09:28.387]     ...future.result <- base::tryCatch({
[16:09:28.387]         base::withCallingHandlers({
[16:09:28.387]             ...future.value <- base::withVisible(base::local({
[16:09:28.387]                 withCallingHandlers({
[16:09:28.387]                   {
[16:09:28.387]                     do.call(function(...) {
[16:09:28.387]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.387]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.387]                         ...future.globals.maxSize)) {
[16:09:28.387]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.387]                         on.exit(options(oopts), add = TRUE)
[16:09:28.387]                       }
[16:09:28.387]                       {
[16:09:28.387]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.387]                           FUN = function(jj) {
[16:09:28.387]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.387]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.387]                           })
[16:09:28.387]                       }
[16:09:28.387]                     }, args = future.call.arguments)
[16:09:28.387]                   }
[16:09:28.387]                 }, immediateCondition = function(cond) {
[16:09:28.387]                   save_rds <- function (object, pathname, ...) 
[16:09:28.387]                   {
[16:09:28.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.387]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.387]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.387]                         fi_tmp[["mtime"]])
[16:09:28.387]                     }
[16:09:28.387]                     tryCatch({
[16:09:28.387]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.387]                     }, error = function(ex) {
[16:09:28.387]                       msg <- conditionMessage(ex)
[16:09:28.387]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.387]                         fi_tmp[["mtime"]], msg)
[16:09:28.387]                       ex$message <- msg
[16:09:28.387]                       stop(ex)
[16:09:28.387]                     })
[16:09:28.387]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.387]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.387]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.387]                       fi <- file.info(pathname)
[16:09:28.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.387]                         fi[["size"]], fi[["mtime"]])
[16:09:28.387]                       stop(msg)
[16:09:28.387]                     }
[16:09:28.387]                     invisible(pathname)
[16:09:28.387]                   }
[16:09:28.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.387]                     rootPath = tempdir()) 
[16:09:28.387]                   {
[16:09:28.387]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.387]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.387]                       tmpdir = path, fileext = ".rds")
[16:09:28.387]                     save_rds(obj, file)
[16:09:28.387]                   }
[16:09:28.387]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.387]                   {
[16:09:28.387]                     inherits <- base::inherits
[16:09:28.387]                     invokeRestart <- base::invokeRestart
[16:09:28.387]                     is.null <- base::is.null
[16:09:28.387]                     muffled <- FALSE
[16:09:28.387]                     if (inherits(cond, "message")) {
[16:09:28.387]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.387]                       if (muffled) 
[16:09:28.387]                         invokeRestart("muffleMessage")
[16:09:28.387]                     }
[16:09:28.387]                     else if (inherits(cond, "warning")) {
[16:09:28.387]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.387]                       if (muffled) 
[16:09:28.387]                         invokeRestart("muffleWarning")
[16:09:28.387]                     }
[16:09:28.387]                     else if (inherits(cond, "condition")) {
[16:09:28.387]                       if (!is.null(pattern)) {
[16:09:28.387]                         computeRestarts <- base::computeRestarts
[16:09:28.387]                         grepl <- base::grepl
[16:09:28.387]                         restarts <- computeRestarts(cond)
[16:09:28.387]                         for (restart in restarts) {
[16:09:28.387]                           name <- restart$name
[16:09:28.387]                           if (is.null(name)) 
[16:09:28.387]                             next
[16:09:28.387]                           if (!grepl(pattern, name)) 
[16:09:28.387]                             next
[16:09:28.387]                           invokeRestart(restart)
[16:09:28.387]                           muffled <- TRUE
[16:09:28.387]                           break
[16:09:28.387]                         }
[16:09:28.387]                       }
[16:09:28.387]                     }
[16:09:28.387]                     invisible(muffled)
[16:09:28.387]                   }
[16:09:28.387]                   muffleCondition(cond)
[16:09:28.387]                 })
[16:09:28.387]             }))
[16:09:28.387]             future::FutureResult(value = ...future.value$value, 
[16:09:28.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.387]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.387]                     ...future.globalenv.names))
[16:09:28.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.387]         }, condition = base::local({
[16:09:28.387]             c <- base::c
[16:09:28.387]             inherits <- base::inherits
[16:09:28.387]             invokeRestart <- base::invokeRestart
[16:09:28.387]             length <- base::length
[16:09:28.387]             list <- base::list
[16:09:28.387]             seq.int <- base::seq.int
[16:09:28.387]             signalCondition <- base::signalCondition
[16:09:28.387]             sys.calls <- base::sys.calls
[16:09:28.387]             `[[` <- base::`[[`
[16:09:28.387]             `+` <- base::`+`
[16:09:28.387]             `<<-` <- base::`<<-`
[16:09:28.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.387]                   3L)]
[16:09:28.387]             }
[16:09:28.387]             function(cond) {
[16:09:28.387]                 is_error <- inherits(cond, "error")
[16:09:28.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.387]                   NULL)
[16:09:28.387]                 if (is_error) {
[16:09:28.387]                   sessionInformation <- function() {
[16:09:28.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.387]                       search = base::search(), system = base::Sys.info())
[16:09:28.387]                   }
[16:09:28.387]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.387]                     cond$call), session = sessionInformation(), 
[16:09:28.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.387]                   signalCondition(cond)
[16:09:28.387]                 }
[16:09:28.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.387]                 "immediateCondition"))) {
[16:09:28.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.387]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.387]                   if (TRUE && !signal) {
[16:09:28.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.387]                     {
[16:09:28.387]                       inherits <- base::inherits
[16:09:28.387]                       invokeRestart <- base::invokeRestart
[16:09:28.387]                       is.null <- base::is.null
[16:09:28.387]                       muffled <- FALSE
[16:09:28.387]                       if (inherits(cond, "message")) {
[16:09:28.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.387]                         if (muffled) 
[16:09:28.387]                           invokeRestart("muffleMessage")
[16:09:28.387]                       }
[16:09:28.387]                       else if (inherits(cond, "warning")) {
[16:09:28.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.387]                         if (muffled) 
[16:09:28.387]                           invokeRestart("muffleWarning")
[16:09:28.387]                       }
[16:09:28.387]                       else if (inherits(cond, "condition")) {
[16:09:28.387]                         if (!is.null(pattern)) {
[16:09:28.387]                           computeRestarts <- base::computeRestarts
[16:09:28.387]                           grepl <- base::grepl
[16:09:28.387]                           restarts <- computeRestarts(cond)
[16:09:28.387]                           for (restart in restarts) {
[16:09:28.387]                             name <- restart$name
[16:09:28.387]                             if (is.null(name)) 
[16:09:28.387]                               next
[16:09:28.387]                             if (!grepl(pattern, name)) 
[16:09:28.387]                               next
[16:09:28.387]                             invokeRestart(restart)
[16:09:28.387]                             muffled <- TRUE
[16:09:28.387]                             break
[16:09:28.387]                           }
[16:09:28.387]                         }
[16:09:28.387]                       }
[16:09:28.387]                       invisible(muffled)
[16:09:28.387]                     }
[16:09:28.387]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.387]                   }
[16:09:28.387]                 }
[16:09:28.387]                 else {
[16:09:28.387]                   if (TRUE) {
[16:09:28.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.387]                     {
[16:09:28.387]                       inherits <- base::inherits
[16:09:28.387]                       invokeRestart <- base::invokeRestart
[16:09:28.387]                       is.null <- base::is.null
[16:09:28.387]                       muffled <- FALSE
[16:09:28.387]                       if (inherits(cond, "message")) {
[16:09:28.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.387]                         if (muffled) 
[16:09:28.387]                           invokeRestart("muffleMessage")
[16:09:28.387]                       }
[16:09:28.387]                       else if (inherits(cond, "warning")) {
[16:09:28.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.387]                         if (muffled) 
[16:09:28.387]                           invokeRestart("muffleWarning")
[16:09:28.387]                       }
[16:09:28.387]                       else if (inherits(cond, "condition")) {
[16:09:28.387]                         if (!is.null(pattern)) {
[16:09:28.387]                           computeRestarts <- base::computeRestarts
[16:09:28.387]                           grepl <- base::grepl
[16:09:28.387]                           restarts <- computeRestarts(cond)
[16:09:28.387]                           for (restart in restarts) {
[16:09:28.387]                             name <- restart$name
[16:09:28.387]                             if (is.null(name)) 
[16:09:28.387]                               next
[16:09:28.387]                             if (!grepl(pattern, name)) 
[16:09:28.387]                               next
[16:09:28.387]                             invokeRestart(restart)
[16:09:28.387]                             muffled <- TRUE
[16:09:28.387]                             break
[16:09:28.387]                           }
[16:09:28.387]                         }
[16:09:28.387]                       }
[16:09:28.387]                       invisible(muffled)
[16:09:28.387]                     }
[16:09:28.387]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.387]                   }
[16:09:28.387]                 }
[16:09:28.387]             }
[16:09:28.387]         }))
[16:09:28.387]     }, error = function(ex) {
[16:09:28.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.387]                 ...future.rng), started = ...future.startTime, 
[16:09:28.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.387]             version = "1.8"), class = "FutureResult")
[16:09:28.387]     }, finally = {
[16:09:28.387]         if (!identical(...future.workdir, getwd())) 
[16:09:28.387]             setwd(...future.workdir)
[16:09:28.387]         {
[16:09:28.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.387]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.387]             }
[16:09:28.387]             base::options(...future.oldOptions)
[16:09:28.387]             if (.Platform$OS.type == "windows") {
[16:09:28.387]                 old_names <- names(...future.oldEnvVars)
[16:09:28.387]                 envs <- base::Sys.getenv()
[16:09:28.387]                 names <- names(envs)
[16:09:28.387]                 common <- intersect(names, old_names)
[16:09:28.387]                 added <- setdiff(names, old_names)
[16:09:28.387]                 removed <- setdiff(old_names, names)
[16:09:28.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.387]                   envs[common]]
[16:09:28.387]                 NAMES <- toupper(changed)
[16:09:28.387]                 args <- list()
[16:09:28.387]                 for (kk in seq_along(NAMES)) {
[16:09:28.387]                   name <- changed[[kk]]
[16:09:28.387]                   NAME <- NAMES[[kk]]
[16:09:28.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.387]                     next
[16:09:28.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.387]                 }
[16:09:28.387]                 NAMES <- toupper(added)
[16:09:28.387]                 for (kk in seq_along(NAMES)) {
[16:09:28.387]                   name <- added[[kk]]
[16:09:28.387]                   NAME <- NAMES[[kk]]
[16:09:28.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.387]                     next
[16:09:28.387]                   args[[name]] <- ""
[16:09:28.387]                 }
[16:09:28.387]                 NAMES <- toupper(removed)
[16:09:28.387]                 for (kk in seq_along(NAMES)) {
[16:09:28.387]                   name <- removed[[kk]]
[16:09:28.387]                   NAME <- NAMES[[kk]]
[16:09:28.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.387]                     next
[16:09:28.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.387]                 }
[16:09:28.387]                 if (length(args) > 0) 
[16:09:28.387]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.387]             }
[16:09:28.387]             else {
[16:09:28.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.387]             }
[16:09:28.387]             {
[16:09:28.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.387]                   0L) {
[16:09:28.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.387]                   base::options(opts)
[16:09:28.387]                 }
[16:09:28.387]                 {
[16:09:28.387]                   {
[16:09:28.387]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.387]                     NULL
[16:09:28.387]                   }
[16:09:28.387]                   options(future.plan = NULL)
[16:09:28.387]                   if (is.na(NA_character_)) 
[16:09:28.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.387]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.387]                     envir = parent.frame()) 
[16:09:28.387]                   {
[16:09:28.387]                     default_workers <- missing(workers)
[16:09:28.387]                     if (is.function(workers)) 
[16:09:28.387]                       workers <- workers()
[16:09:28.387]                     workers <- structure(as.integer(workers), 
[16:09:28.387]                       class = class(workers))
[16:09:28.387]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.387]                       1L)
[16:09:28.387]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.387]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.387]                       if (default_workers) 
[16:09:28.387]                         supportsMulticore(warn = TRUE)
[16:09:28.387]                       return(sequential(..., envir = envir))
[16:09:28.387]                     }
[16:09:28.387]                     oopts <- options(mc.cores = workers)
[16:09:28.387]                     on.exit(options(oopts))
[16:09:28.387]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.387]                       envir = envir)
[16:09:28.387]                     if (!future$lazy) 
[16:09:28.387]                       future <- run(future)
[16:09:28.387]                     invisible(future)
[16:09:28.387]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.387]                 }
[16:09:28.387]             }
[16:09:28.387]         }
[16:09:28.387]     })
[16:09:28.387]     if (TRUE) {
[16:09:28.387]         base::sink(type = "output", split = FALSE)
[16:09:28.387]         if (TRUE) {
[16:09:28.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.387]         }
[16:09:28.387]         else {
[16:09:28.387]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.387]         }
[16:09:28.387]         base::close(...future.stdout)
[16:09:28.387]         ...future.stdout <- NULL
[16:09:28.387]     }
[16:09:28.387]     ...future.result$conditions <- ...future.conditions
[16:09:28.387]     ...future.result$finished <- base::Sys.time()
[16:09:28.387]     ...future.result
[16:09:28.387] }
[16:09:28.390] assign_globals() ...
[16:09:28.390] List of 5
[16:09:28.390]  $ future.call.arguments    : list()
[16:09:28.390]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.390]  $ ...future.FUN            :function (x)  
[16:09:28.390]  $ ...future.elements_ii    :List of 3
[16:09:28.390]   ..$ : int [1:4] 1 7 13 19
[16:09:28.390]   ..$ : int [1:4] 2 8 14 20
[16:09:28.390]   ..$ : int [1:4] 3 9 15 21
[16:09:28.390]  $ ...future.seeds_ii       : NULL
[16:09:28.390]  $ ...future.globals.maxSize: num Inf
[16:09:28.390]  - attr(*, "resolved")= logi FALSE
[16:09:28.390]  - attr(*, "total_size")= num NA
[16:09:28.390]  - attr(*, "where")=List of 5
[16:09:28.390]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.390]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.390]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.390]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.390]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.390]  - attr(*, "already-done")= logi TRUE
[16:09:28.398] - copied ‘future.call.arguments’ to environment
[16:09:28.398] - reassign environment for ‘...future.FUN’
[16:09:28.398] - copied ‘...future.FUN’ to environment
[16:09:28.398] - copied ‘...future.elements_ii’ to environment
[16:09:28.398] - copied ‘...future.seeds_ii’ to environment
[16:09:28.398] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.398] assign_globals() ... done
[16:09:28.399] requestCore(): workers = 2
[16:09:28.401] MulticoreFuture started
[16:09:28.401] - Launch lazy future ... done
[16:09:28.402] run() for ‘MulticoreFuture’ ... done
[16:09:28.402] plan(): Setting new future strategy stack:
[16:09:28.402] Created future:
[16:09:28.402] List of future strategies:
[16:09:28.402] 1. sequential:
[16:09:28.402]    - args: function (..., envir = parent.frame())
[16:09:28.402]    - tweaked: FALSE
[16:09:28.402]    - call: NULL
[16:09:28.403] plan(): nbrOfWorkers() = 1
[16:09:28.405] plan(): Setting new future strategy stack:
[16:09:28.406] List of future strategies:
[16:09:28.406] 1. multicore:
[16:09:28.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.406]    - tweaked: FALSE
[16:09:28.406]    - call: plan(strategy)
[16:09:28.412] plan(): nbrOfWorkers() = 2
[16:09:28.402] MulticoreFuture:
[16:09:28.402] Label: ‘future_apply-1’
[16:09:28.402] Expression:
[16:09:28.402] {
[16:09:28.402]     do.call(function(...) {
[16:09:28.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.402]             on.exit(options(oopts), add = TRUE)
[16:09:28.402]         }
[16:09:28.402]         {
[16:09:28.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.402]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.402]             })
[16:09:28.402]         }
[16:09:28.402]     }, args = future.call.arguments)
[16:09:28.402] }
[16:09:28.402] Lazy evaluation: FALSE
[16:09:28.402] Asynchronous evaluation: TRUE
[16:09:28.402] Local evaluation: TRUE
[16:09:28.402] Environment: R_GlobalEnv
[16:09:28.402] Capture standard output: TRUE
[16:09:28.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.402] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:28.402] Packages: <none>
[16:09:28.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.402] Resolved: TRUE
[16:09:28.402] Value: <not collected>
[16:09:28.402] Conditions captured: <none>
[16:09:28.402] Early signaling: FALSE
[16:09:28.402] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.402] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.413] Chunk #1 of 2 ... DONE
[16:09:28.413] Chunk #2 of 2 ...
[16:09:28.414]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:28.414]  - seeds: <none>
[16:09:28.414] getGlobalsAndPackages() ...
[16:09:28.414] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.414] Resolving globals: FALSE
[16:09:28.415] Tweak future expression to call with '...' arguments ...
[16:09:28.415] {
[16:09:28.415]     do.call(function(...) {
[16:09:28.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.415]             on.exit(options(oopts), add = TRUE)
[16:09:28.415]         }
[16:09:28.415]         {
[16:09:28.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.415]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.415]             })
[16:09:28.415]         }
[16:09:28.415]     }, args = future.call.arguments)
[16:09:28.415] }
[16:09:28.415] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.416] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.416] 
[16:09:28.416] getGlobalsAndPackages() ... DONE
[16:09:28.417] run() for ‘Future’ ...
[16:09:28.417] - state: ‘created’
[16:09:28.417] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.422] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.422]   - Field: ‘label’
[16:09:28.422]   - Field: ‘local’
[16:09:28.423]   - Field: ‘owner’
[16:09:28.423]   - Field: ‘envir’
[16:09:28.423]   - Field: ‘workers’
[16:09:28.423]   - Field: ‘packages’
[16:09:28.423]   - Field: ‘gc’
[16:09:28.423]   - Field: ‘job’
[16:09:28.423]   - Field: ‘conditions’
[16:09:28.424]   - Field: ‘expr’
[16:09:28.424]   - Field: ‘uuid’
[16:09:28.424]   - Field: ‘seed’
[16:09:28.424]   - Field: ‘version’
[16:09:28.424]   - Field: ‘result’
[16:09:28.424]   - Field: ‘asynchronous’
[16:09:28.424]   - Field: ‘calls’
[16:09:28.425]   - Field: ‘globals’
[16:09:28.425]   - Field: ‘stdout’
[16:09:28.425]   - Field: ‘earlySignal’
[16:09:28.425]   - Field: ‘lazy’
[16:09:28.425]   - Field: ‘state’
[16:09:28.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.426] - Launch lazy future ...
[16:09:28.426] Packages needed by the future expression (n = 0): <none>
[16:09:28.426] Packages needed by future strategies (n = 0): <none>
[16:09:28.427] {
[16:09:28.427]     {
[16:09:28.427]         {
[16:09:28.427]             ...future.startTime <- base::Sys.time()
[16:09:28.427]             {
[16:09:28.427]                 {
[16:09:28.427]                   {
[16:09:28.427]                     {
[16:09:28.427]                       base::local({
[16:09:28.427]                         has_future <- base::requireNamespace("future", 
[16:09:28.427]                           quietly = TRUE)
[16:09:28.427]                         if (has_future) {
[16:09:28.427]                           ns <- base::getNamespace("future")
[16:09:28.427]                           version <- ns[[".package"]][["version"]]
[16:09:28.427]                           if (is.null(version)) 
[16:09:28.427]                             version <- utils::packageVersion("future")
[16:09:28.427]                         }
[16:09:28.427]                         else {
[16:09:28.427]                           version <- NULL
[16:09:28.427]                         }
[16:09:28.427]                         if (!has_future || version < "1.8.0") {
[16:09:28.427]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.427]                             "", base::R.version$version.string), 
[16:09:28.427]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.427]                               "release", "version")], collapse = " "), 
[16:09:28.427]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.427]                             info)
[16:09:28.427]                           info <- base::paste(info, collapse = "; ")
[16:09:28.427]                           if (!has_future) {
[16:09:28.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.427]                               info)
[16:09:28.427]                           }
[16:09:28.427]                           else {
[16:09:28.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.427]                               info, version)
[16:09:28.427]                           }
[16:09:28.427]                           base::stop(msg)
[16:09:28.427]                         }
[16:09:28.427]                       })
[16:09:28.427]                     }
[16:09:28.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.427]                     base::options(mc.cores = 1L)
[16:09:28.427]                   }
[16:09:28.427]                   options(future.plan = NULL)
[16:09:28.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.427]                 }
[16:09:28.427]                 ...future.workdir <- getwd()
[16:09:28.427]             }
[16:09:28.427]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.427]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.427]         }
[16:09:28.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.427]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.427]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.427]             base::names(...future.oldOptions))
[16:09:28.427]     }
[16:09:28.427]     if (FALSE) {
[16:09:28.427]     }
[16:09:28.427]     else {
[16:09:28.427]         if (TRUE) {
[16:09:28.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.427]                 open = "w")
[16:09:28.427]         }
[16:09:28.427]         else {
[16:09:28.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.427]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.427]         }
[16:09:28.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.427]             base::sink(type = "output", split = FALSE)
[16:09:28.427]             base::close(...future.stdout)
[16:09:28.427]         }, add = TRUE)
[16:09:28.427]     }
[16:09:28.427]     ...future.frame <- base::sys.nframe()
[16:09:28.427]     ...future.conditions <- base::list()
[16:09:28.427]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.427]     if (FALSE) {
[16:09:28.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.427]     }
[16:09:28.427]     ...future.result <- base::tryCatch({
[16:09:28.427]         base::withCallingHandlers({
[16:09:28.427]             ...future.value <- base::withVisible(base::local({
[16:09:28.427]                 withCallingHandlers({
[16:09:28.427]                   {
[16:09:28.427]                     do.call(function(...) {
[16:09:28.427]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.427]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.427]                         ...future.globals.maxSize)) {
[16:09:28.427]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.427]                         on.exit(options(oopts), add = TRUE)
[16:09:28.427]                       }
[16:09:28.427]                       {
[16:09:28.427]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.427]                           FUN = function(jj) {
[16:09:28.427]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.427]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.427]                           })
[16:09:28.427]                       }
[16:09:28.427]                     }, args = future.call.arguments)
[16:09:28.427]                   }
[16:09:28.427]                 }, immediateCondition = function(cond) {
[16:09:28.427]                   save_rds <- function (object, pathname, ...) 
[16:09:28.427]                   {
[16:09:28.427]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.427]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.427]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.427]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.427]                         fi_tmp[["mtime"]])
[16:09:28.427]                     }
[16:09:28.427]                     tryCatch({
[16:09:28.427]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.427]                     }, error = function(ex) {
[16:09:28.427]                       msg <- conditionMessage(ex)
[16:09:28.427]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.427]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.427]                         fi_tmp[["mtime"]], msg)
[16:09:28.427]                       ex$message <- msg
[16:09:28.427]                       stop(ex)
[16:09:28.427]                     })
[16:09:28.427]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.427]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.427]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.427]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.427]                       fi <- file.info(pathname)
[16:09:28.427]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.427]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.427]                         fi[["size"]], fi[["mtime"]])
[16:09:28.427]                       stop(msg)
[16:09:28.427]                     }
[16:09:28.427]                     invisible(pathname)
[16:09:28.427]                   }
[16:09:28.427]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.427]                     rootPath = tempdir()) 
[16:09:28.427]                   {
[16:09:28.427]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.427]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.427]                       tmpdir = path, fileext = ".rds")
[16:09:28.427]                     save_rds(obj, file)
[16:09:28.427]                   }
[16:09:28.427]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.427]                   {
[16:09:28.427]                     inherits <- base::inherits
[16:09:28.427]                     invokeRestart <- base::invokeRestart
[16:09:28.427]                     is.null <- base::is.null
[16:09:28.427]                     muffled <- FALSE
[16:09:28.427]                     if (inherits(cond, "message")) {
[16:09:28.427]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.427]                       if (muffled) 
[16:09:28.427]                         invokeRestart("muffleMessage")
[16:09:28.427]                     }
[16:09:28.427]                     else if (inherits(cond, "warning")) {
[16:09:28.427]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.427]                       if (muffled) 
[16:09:28.427]                         invokeRestart("muffleWarning")
[16:09:28.427]                     }
[16:09:28.427]                     else if (inherits(cond, "condition")) {
[16:09:28.427]                       if (!is.null(pattern)) {
[16:09:28.427]                         computeRestarts <- base::computeRestarts
[16:09:28.427]                         grepl <- base::grepl
[16:09:28.427]                         restarts <- computeRestarts(cond)
[16:09:28.427]                         for (restart in restarts) {
[16:09:28.427]                           name <- restart$name
[16:09:28.427]                           if (is.null(name)) 
[16:09:28.427]                             next
[16:09:28.427]                           if (!grepl(pattern, name)) 
[16:09:28.427]                             next
[16:09:28.427]                           invokeRestart(restart)
[16:09:28.427]                           muffled <- TRUE
[16:09:28.427]                           break
[16:09:28.427]                         }
[16:09:28.427]                       }
[16:09:28.427]                     }
[16:09:28.427]                     invisible(muffled)
[16:09:28.427]                   }
[16:09:28.427]                   muffleCondition(cond)
[16:09:28.427]                 })
[16:09:28.427]             }))
[16:09:28.427]             future::FutureResult(value = ...future.value$value, 
[16:09:28.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.427]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.427]                     ...future.globalenv.names))
[16:09:28.427]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.427]         }, condition = base::local({
[16:09:28.427]             c <- base::c
[16:09:28.427]             inherits <- base::inherits
[16:09:28.427]             invokeRestart <- base::invokeRestart
[16:09:28.427]             length <- base::length
[16:09:28.427]             list <- base::list
[16:09:28.427]             seq.int <- base::seq.int
[16:09:28.427]             signalCondition <- base::signalCondition
[16:09:28.427]             sys.calls <- base::sys.calls
[16:09:28.427]             `[[` <- base::`[[`
[16:09:28.427]             `+` <- base::`+`
[16:09:28.427]             `<<-` <- base::`<<-`
[16:09:28.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.427]                   3L)]
[16:09:28.427]             }
[16:09:28.427]             function(cond) {
[16:09:28.427]                 is_error <- inherits(cond, "error")
[16:09:28.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.427]                   NULL)
[16:09:28.427]                 if (is_error) {
[16:09:28.427]                   sessionInformation <- function() {
[16:09:28.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.427]                       search = base::search(), system = base::Sys.info())
[16:09:28.427]                   }
[16:09:28.427]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.427]                     cond$call), session = sessionInformation(), 
[16:09:28.427]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.427]                   signalCondition(cond)
[16:09:28.427]                 }
[16:09:28.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.427]                 "immediateCondition"))) {
[16:09:28.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.427]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.427]                   if (TRUE && !signal) {
[16:09:28.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.427]                     {
[16:09:28.427]                       inherits <- base::inherits
[16:09:28.427]                       invokeRestart <- base::invokeRestart
[16:09:28.427]                       is.null <- base::is.null
[16:09:28.427]                       muffled <- FALSE
[16:09:28.427]                       if (inherits(cond, "message")) {
[16:09:28.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.427]                         if (muffled) 
[16:09:28.427]                           invokeRestart("muffleMessage")
[16:09:28.427]                       }
[16:09:28.427]                       else if (inherits(cond, "warning")) {
[16:09:28.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.427]                         if (muffled) 
[16:09:28.427]                           invokeRestart("muffleWarning")
[16:09:28.427]                       }
[16:09:28.427]                       else if (inherits(cond, "condition")) {
[16:09:28.427]                         if (!is.null(pattern)) {
[16:09:28.427]                           computeRestarts <- base::computeRestarts
[16:09:28.427]                           grepl <- base::grepl
[16:09:28.427]                           restarts <- computeRestarts(cond)
[16:09:28.427]                           for (restart in restarts) {
[16:09:28.427]                             name <- restart$name
[16:09:28.427]                             if (is.null(name)) 
[16:09:28.427]                               next
[16:09:28.427]                             if (!grepl(pattern, name)) 
[16:09:28.427]                               next
[16:09:28.427]                             invokeRestart(restart)
[16:09:28.427]                             muffled <- TRUE
[16:09:28.427]                             break
[16:09:28.427]                           }
[16:09:28.427]                         }
[16:09:28.427]                       }
[16:09:28.427]                       invisible(muffled)
[16:09:28.427]                     }
[16:09:28.427]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.427]                   }
[16:09:28.427]                 }
[16:09:28.427]                 else {
[16:09:28.427]                   if (TRUE) {
[16:09:28.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.427]                     {
[16:09:28.427]                       inherits <- base::inherits
[16:09:28.427]                       invokeRestart <- base::invokeRestart
[16:09:28.427]                       is.null <- base::is.null
[16:09:28.427]                       muffled <- FALSE
[16:09:28.427]                       if (inherits(cond, "message")) {
[16:09:28.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.427]                         if (muffled) 
[16:09:28.427]                           invokeRestart("muffleMessage")
[16:09:28.427]                       }
[16:09:28.427]                       else if (inherits(cond, "warning")) {
[16:09:28.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.427]                         if (muffled) 
[16:09:28.427]                           invokeRestart("muffleWarning")
[16:09:28.427]                       }
[16:09:28.427]                       else if (inherits(cond, "condition")) {
[16:09:28.427]                         if (!is.null(pattern)) {
[16:09:28.427]                           computeRestarts <- base::computeRestarts
[16:09:28.427]                           grepl <- base::grepl
[16:09:28.427]                           restarts <- computeRestarts(cond)
[16:09:28.427]                           for (restart in restarts) {
[16:09:28.427]                             name <- restart$name
[16:09:28.427]                             if (is.null(name)) 
[16:09:28.427]                               next
[16:09:28.427]                             if (!grepl(pattern, name)) 
[16:09:28.427]                               next
[16:09:28.427]                             invokeRestart(restart)
[16:09:28.427]                             muffled <- TRUE
[16:09:28.427]                             break
[16:09:28.427]                           }
[16:09:28.427]                         }
[16:09:28.427]                       }
[16:09:28.427]                       invisible(muffled)
[16:09:28.427]                     }
[16:09:28.427]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.427]                   }
[16:09:28.427]                 }
[16:09:28.427]             }
[16:09:28.427]         }))
[16:09:28.427]     }, error = function(ex) {
[16:09:28.427]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.427]                 ...future.rng), started = ...future.startTime, 
[16:09:28.427]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.427]             version = "1.8"), class = "FutureResult")
[16:09:28.427]     }, finally = {
[16:09:28.427]         if (!identical(...future.workdir, getwd())) 
[16:09:28.427]             setwd(...future.workdir)
[16:09:28.427]         {
[16:09:28.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.427]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.427]             }
[16:09:28.427]             base::options(...future.oldOptions)
[16:09:28.427]             if (.Platform$OS.type == "windows") {
[16:09:28.427]                 old_names <- names(...future.oldEnvVars)
[16:09:28.427]                 envs <- base::Sys.getenv()
[16:09:28.427]                 names <- names(envs)
[16:09:28.427]                 common <- intersect(names, old_names)
[16:09:28.427]                 added <- setdiff(names, old_names)
[16:09:28.427]                 removed <- setdiff(old_names, names)
[16:09:28.427]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.427]                   envs[common]]
[16:09:28.427]                 NAMES <- toupper(changed)
[16:09:28.427]                 args <- list()
[16:09:28.427]                 for (kk in seq_along(NAMES)) {
[16:09:28.427]                   name <- changed[[kk]]
[16:09:28.427]                   NAME <- NAMES[[kk]]
[16:09:28.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.427]                     next
[16:09:28.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.427]                 }
[16:09:28.427]                 NAMES <- toupper(added)
[16:09:28.427]                 for (kk in seq_along(NAMES)) {
[16:09:28.427]                   name <- added[[kk]]
[16:09:28.427]                   NAME <- NAMES[[kk]]
[16:09:28.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.427]                     next
[16:09:28.427]                   args[[name]] <- ""
[16:09:28.427]                 }
[16:09:28.427]                 NAMES <- toupper(removed)
[16:09:28.427]                 for (kk in seq_along(NAMES)) {
[16:09:28.427]                   name <- removed[[kk]]
[16:09:28.427]                   NAME <- NAMES[[kk]]
[16:09:28.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.427]                     next
[16:09:28.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.427]                 }
[16:09:28.427]                 if (length(args) > 0) 
[16:09:28.427]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.427]             }
[16:09:28.427]             else {
[16:09:28.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.427]             }
[16:09:28.427]             {
[16:09:28.427]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.427]                   0L) {
[16:09:28.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.427]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.427]                   base::options(opts)
[16:09:28.427]                 }
[16:09:28.427]                 {
[16:09:28.427]                   {
[16:09:28.427]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.427]                     NULL
[16:09:28.427]                   }
[16:09:28.427]                   options(future.plan = NULL)
[16:09:28.427]                   if (is.na(NA_character_)) 
[16:09:28.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.427]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.427]                     envir = parent.frame()) 
[16:09:28.427]                   {
[16:09:28.427]                     default_workers <- missing(workers)
[16:09:28.427]                     if (is.function(workers)) 
[16:09:28.427]                       workers <- workers()
[16:09:28.427]                     workers <- structure(as.integer(workers), 
[16:09:28.427]                       class = class(workers))
[16:09:28.427]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.427]                       1L)
[16:09:28.427]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.427]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.427]                       if (default_workers) 
[16:09:28.427]                         supportsMulticore(warn = TRUE)
[16:09:28.427]                       return(sequential(..., envir = envir))
[16:09:28.427]                     }
[16:09:28.427]                     oopts <- options(mc.cores = workers)
[16:09:28.427]                     on.exit(options(oopts))
[16:09:28.427]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.427]                       envir = envir)
[16:09:28.427]                     if (!future$lazy) 
[16:09:28.427]                       future <- run(future)
[16:09:28.427]                     invisible(future)
[16:09:28.427]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.427]                 }
[16:09:28.427]             }
[16:09:28.427]         }
[16:09:28.427]     })
[16:09:28.427]     if (TRUE) {
[16:09:28.427]         base::sink(type = "output", split = FALSE)
[16:09:28.427]         if (TRUE) {
[16:09:28.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.427]         }
[16:09:28.427]         else {
[16:09:28.427]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.427]         }
[16:09:28.427]         base::close(...future.stdout)
[16:09:28.427]         ...future.stdout <- NULL
[16:09:28.427]     }
[16:09:28.427]     ...future.result$conditions <- ...future.conditions
[16:09:28.427]     ...future.result$finished <- base::Sys.time()
[16:09:28.427]     ...future.result
[16:09:28.427] }
[16:09:28.430] assign_globals() ...
[16:09:28.431] List of 5
[16:09:28.431]  $ future.call.arguments    : list()
[16:09:28.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.431]  $ ...future.FUN            :function (x)  
[16:09:28.431]  $ ...future.elements_ii    :List of 3
[16:09:28.431]   ..$ : int [1:4] 4 10 16 22
[16:09:28.431]   ..$ : int [1:4] 5 11 17 23
[16:09:28.431]   ..$ : int [1:4] 6 12 18 24
[16:09:28.431]  $ ...future.seeds_ii       : NULL
[16:09:28.431]  $ ...future.globals.maxSize: num Inf
[16:09:28.431]  - attr(*, "resolved")= logi FALSE
[16:09:28.431]  - attr(*, "total_size")= num NA
[16:09:28.431]  - attr(*, "where")=List of 5
[16:09:28.431]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.431]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.431]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.431]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.431]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.431]  - attr(*, "already-done")= logi TRUE
[16:09:28.439] - copied ‘future.call.arguments’ to environment
[16:09:28.439] - reassign environment for ‘...future.FUN’
[16:09:28.439] - copied ‘...future.FUN’ to environment
[16:09:28.439] - copied ‘...future.elements_ii’ to environment
[16:09:28.439] - copied ‘...future.seeds_ii’ to environment
[16:09:28.440] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.440] assign_globals() ... done
[16:09:28.440] requestCore(): workers = 2
[16:09:28.442] MulticoreFuture started
[16:09:28.442] - Launch lazy future ... done
[16:09:28.443] run() for ‘MulticoreFuture’ ... done
[16:09:28.443] Created future:
[16:09:28.443] plan(): Setting new future strategy stack:
[16:09:28.443] List of future strategies:
[16:09:28.443] 1. sequential:
[16:09:28.443]    - args: function (..., envir = parent.frame())
[16:09:28.443]    - tweaked: FALSE
[16:09:28.443]    - call: NULL
[16:09:28.444] plan(): nbrOfWorkers() = 1
[16:09:28.449] plan(): Setting new future strategy stack:
[16:09:28.450] List of future strategies:
[16:09:28.450] 1. multicore:
[16:09:28.450]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.450]    - tweaked: FALSE
[16:09:28.450]    - call: plan(strategy)
[16:09:28.457] plan(): nbrOfWorkers() = 2
[16:09:28.443] MulticoreFuture:
[16:09:28.443] Label: ‘future_apply-2’
[16:09:28.443] Expression:
[16:09:28.443] {
[16:09:28.443]     do.call(function(...) {
[16:09:28.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.443]             on.exit(options(oopts), add = TRUE)
[16:09:28.443]         }
[16:09:28.443]         {
[16:09:28.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.443]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.443]             })
[16:09:28.443]         }
[16:09:28.443]     }, args = future.call.arguments)
[16:09:28.443] }
[16:09:28.443] Lazy evaluation: FALSE
[16:09:28.443] Asynchronous evaluation: TRUE
[16:09:28.443] Local evaluation: TRUE
[16:09:28.443] Environment: R_GlobalEnv
[16:09:28.443] Capture standard output: TRUE
[16:09:28.443] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.443] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:28.443] Packages: <none>
[16:09:28.443] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.443] Resolved: TRUE
[16:09:28.443] Value: <not collected>
[16:09:28.443] Conditions captured: <none>
[16:09:28.443] Early signaling: FALSE
[16:09:28.443] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.443] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.458] Chunk #2 of 2 ... DONE
[16:09:28.459] Launching 2 futures (chunks) ... DONE
[16:09:28.459] Resolving 2 futures (chunks) ...
[16:09:28.459] resolve() on list ...
[16:09:28.459]  recursive: 0
[16:09:28.460]  length: 2
[16:09:28.460] 
[16:09:28.461] Future #1
[16:09:28.462] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.462] - nx: 2
[16:09:28.463] - relay: TRUE
[16:09:28.463] - stdout: TRUE
[16:09:28.463] - signal: TRUE
[16:09:28.463] - resignal: FALSE
[16:09:28.464] - force: TRUE
[16:09:28.464] - relayed: [n=2] FALSE, FALSE
[16:09:28.464] - queued futures: [n=2] FALSE, FALSE
[16:09:28.465]  - until=1
[16:09:28.465]  - relaying element #1
[16:09:28.466] - relayed: [n=2] TRUE, FALSE
[16:09:28.466] - queued futures: [n=2] TRUE, FALSE
[16:09:28.466] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.466]  length: 1 (resolved future 1)
[16:09:28.466] Future #2
[16:09:28.467] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.467] - nx: 2
[16:09:28.467] - relay: TRUE
[16:09:28.468] - stdout: TRUE
[16:09:28.468] - signal: TRUE
[16:09:28.468] - resignal: FALSE
[16:09:28.468] - force: TRUE
[16:09:28.468] - relayed: [n=2] TRUE, FALSE
[16:09:28.469] - queued futures: [n=2] TRUE, FALSE
[16:09:28.469]  - until=2
[16:09:28.469]  - relaying element #2
[16:09:28.469] - relayed: [n=2] TRUE, TRUE
[16:09:28.469] - queued futures: [n=2] TRUE, TRUE
[16:09:28.469] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.469]  length: 0 (resolved future 2)
[16:09:28.470] Relaying remaining futures
[16:09:28.470] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.470] - nx: 2
[16:09:28.470] - relay: TRUE
[16:09:28.470] - stdout: TRUE
[16:09:28.470] - signal: TRUE
[16:09:28.470] - resignal: FALSE
[16:09:28.470] - force: TRUE
[16:09:28.470] - relayed: [n=2] TRUE, TRUE
[16:09:28.471] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.471] - relayed: [n=2] TRUE, TRUE
[16:09:28.471] - queued futures: [n=2] TRUE, TRUE
[16:09:28.471] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.471] resolve() on list ... DONE
[16:09:28.471]  - Number of value chunks collected: 2
[16:09:28.471] Resolving 2 futures (chunks) ... DONE
[16:09:28.472] Reducing values from 2 chunks ...
[16:09:28.472]  - Number of values collected after concatenation: 6
[16:09:28.472]  - Number of values expected: 6
[16:09:28.472] Reducing values from 2 chunks ... DONE
[16:09:28.472] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:09:28.472] getGlobalsAndPackagesXApply() ...
[16:09:28.473]  - future.globals: TRUE
[16:09:28.473] getGlobalsAndPackages() ...
[16:09:28.473] Searching for globals...
[16:09:28.474] - globals found: [1] ‘FUN’
[16:09:28.474] Searching for globals ... DONE
[16:09:28.474] Resolving globals: FALSE
[16:09:28.475] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:28.475] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:28.475] - globals: [1] ‘FUN’
[16:09:28.475] 
[16:09:28.475] getGlobalsAndPackages() ... DONE
[16:09:28.476]  - globals found/used: [n=1] ‘FUN’
[16:09:28.476]  - needed namespaces: [n=0] 
[16:09:28.476] Finding globals ... DONE
[16:09:28.476]  - use_args: TRUE
[16:09:28.476]  - Getting '...' globals ...
[16:09:28.476] resolve() on list ...
[16:09:28.476]  recursive: 0
[16:09:28.477]  length: 1
[16:09:28.477]  elements: ‘...’
[16:09:28.477]  length: 0 (resolved future 1)
[16:09:28.477] resolve() on list ... DONE
[16:09:28.477]    - '...' content: [n=0] 
[16:09:28.477] List of 1
[16:09:28.477]  $ ...: list()
[16:09:28.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.477]  - attr(*, "where")=List of 1
[16:09:28.477]   ..$ ...:<environment: 0x5633aa61a3b0> 
[16:09:28.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.477]  - attr(*, "resolved")= logi TRUE
[16:09:28.477]  - attr(*, "total_size")= num NA
[16:09:28.480]  - Getting '...' globals ... DONE
[16:09:28.480] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.481] List of 2
[16:09:28.481]  $ ...future.FUN:function (x)  
[16:09:28.481]  $ ...          : list()
[16:09:28.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.481]  - attr(*, "where")=List of 2
[16:09:28.481]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.481]   ..$ ...          :<environment: 0x5633aa61a3b0> 
[16:09:28.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.481]  - attr(*, "resolved")= logi FALSE
[16:09:28.481]  - attr(*, "total_size")= num 848
[16:09:28.483] Packages to be attached in all futures: [n=0] 
[16:09:28.484] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.487] future_lapply() ...
[16:09:28.493] Number of chunks: 2
[16:09:28.494] getGlobalsAndPackagesXApply() ...
[16:09:28.494]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.494]  - use_args: TRUE
[16:09:28.494] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.494] List of 2
[16:09:28.494]  $ ...          : list()
[16:09:28.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.494]  $ ...future.FUN:function (x)  
[16:09:28.494]  - attr(*, "where")=List of 2
[16:09:28.494]   ..$ ...          :<environment: 0x5633aa61a3b0> 
[16:09:28.494]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:28.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.494]  - attr(*, "resolved")= logi FALSE
[16:09:28.494]  - attr(*, "total_size")= num NA
[16:09:28.498] Packages to be attached in all futures: [n=0] 
[16:09:28.498] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.498] Number of futures (= number of chunks): 2
[16:09:28.498] Launching 2 futures (chunks) ...
[16:09:28.498] Chunk #1 of 2 ...
[16:09:28.499]  - seeds: <none>
[16:09:28.499] getGlobalsAndPackages() ...
[16:09:28.499] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.499] Resolving globals: FALSE
[16:09:28.499] Tweak future expression to call with '...' arguments ...
[16:09:28.499] {
[16:09:28.499]     do.call(function(...) {
[16:09:28.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.499]             on.exit(options(oopts), add = TRUE)
[16:09:28.499]         }
[16:09:28.499]         {
[16:09:28.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.499]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.499]             })
[16:09:28.499]         }
[16:09:28.499]     }, args = future.call.arguments)
[16:09:28.499] }
[16:09:28.499] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.500] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.500] 
[16:09:28.500] getGlobalsAndPackages() ... DONE
[16:09:28.501] run() for ‘Future’ ...
[16:09:28.501] - state: ‘created’
[16:09:28.501] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.505] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.505] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.505]   - Field: ‘label’
[16:09:28.505]   - Field: ‘local’
[16:09:28.506]   - Field: ‘owner’
[16:09:28.506]   - Field: ‘envir’
[16:09:28.506]   - Field: ‘workers’
[16:09:28.506]   - Field: ‘packages’
[16:09:28.506]   - Field: ‘gc’
[16:09:28.506]   - Field: ‘job’
[16:09:28.506]   - Field: ‘conditions’
[16:09:28.506]   - Field: ‘expr’
[16:09:28.507]   - Field: ‘uuid’
[16:09:28.507]   - Field: ‘seed’
[16:09:28.507]   - Field: ‘version’
[16:09:28.507]   - Field: ‘result’
[16:09:28.507]   - Field: ‘asynchronous’
[16:09:28.507]   - Field: ‘calls’
[16:09:28.507]   - Field: ‘globals’
[16:09:28.507]   - Field: ‘stdout’
[16:09:28.507]   - Field: ‘earlySignal’
[16:09:28.507]   - Field: ‘lazy’
[16:09:28.508]   - Field: ‘state’
[16:09:28.508] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.508] - Launch lazy future ...
[16:09:28.508] Packages needed by the future expression (n = 0): <none>
[16:09:28.508] Packages needed by future strategies (n = 0): <none>
[16:09:28.509] {
[16:09:28.509]     {
[16:09:28.509]         {
[16:09:28.509]             ...future.startTime <- base::Sys.time()
[16:09:28.509]             {
[16:09:28.509]                 {
[16:09:28.509]                   {
[16:09:28.509]                     {
[16:09:28.509]                       base::local({
[16:09:28.509]                         has_future <- base::requireNamespace("future", 
[16:09:28.509]                           quietly = TRUE)
[16:09:28.509]                         if (has_future) {
[16:09:28.509]                           ns <- base::getNamespace("future")
[16:09:28.509]                           version <- ns[[".package"]][["version"]]
[16:09:28.509]                           if (is.null(version)) 
[16:09:28.509]                             version <- utils::packageVersion("future")
[16:09:28.509]                         }
[16:09:28.509]                         else {
[16:09:28.509]                           version <- NULL
[16:09:28.509]                         }
[16:09:28.509]                         if (!has_future || version < "1.8.0") {
[16:09:28.509]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.509]                             "", base::R.version$version.string), 
[16:09:28.509]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.509]                               "release", "version")], collapse = " "), 
[16:09:28.509]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.509]                             info)
[16:09:28.509]                           info <- base::paste(info, collapse = "; ")
[16:09:28.509]                           if (!has_future) {
[16:09:28.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.509]                               info)
[16:09:28.509]                           }
[16:09:28.509]                           else {
[16:09:28.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.509]                               info, version)
[16:09:28.509]                           }
[16:09:28.509]                           base::stop(msg)
[16:09:28.509]                         }
[16:09:28.509]                       })
[16:09:28.509]                     }
[16:09:28.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.509]                     base::options(mc.cores = 1L)
[16:09:28.509]                   }
[16:09:28.509]                   options(future.plan = NULL)
[16:09:28.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.509]                 }
[16:09:28.509]                 ...future.workdir <- getwd()
[16:09:28.509]             }
[16:09:28.509]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.509]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.509]         }
[16:09:28.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.509]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.509]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.509]             base::names(...future.oldOptions))
[16:09:28.509]     }
[16:09:28.509]     if (FALSE) {
[16:09:28.509]     }
[16:09:28.509]     else {
[16:09:28.509]         if (TRUE) {
[16:09:28.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.509]                 open = "w")
[16:09:28.509]         }
[16:09:28.509]         else {
[16:09:28.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.509]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.509]         }
[16:09:28.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.509]             base::sink(type = "output", split = FALSE)
[16:09:28.509]             base::close(...future.stdout)
[16:09:28.509]         }, add = TRUE)
[16:09:28.509]     }
[16:09:28.509]     ...future.frame <- base::sys.nframe()
[16:09:28.509]     ...future.conditions <- base::list()
[16:09:28.509]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.509]     if (FALSE) {
[16:09:28.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.509]     }
[16:09:28.509]     ...future.result <- base::tryCatch({
[16:09:28.509]         base::withCallingHandlers({
[16:09:28.509]             ...future.value <- base::withVisible(base::local({
[16:09:28.509]                 withCallingHandlers({
[16:09:28.509]                   {
[16:09:28.509]                     do.call(function(...) {
[16:09:28.509]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.509]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.509]                         ...future.globals.maxSize)) {
[16:09:28.509]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.509]                         on.exit(options(oopts), add = TRUE)
[16:09:28.509]                       }
[16:09:28.509]                       {
[16:09:28.509]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.509]                           FUN = function(jj) {
[16:09:28.509]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.509]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.509]                           })
[16:09:28.509]                       }
[16:09:28.509]                     }, args = future.call.arguments)
[16:09:28.509]                   }
[16:09:28.509]                 }, immediateCondition = function(cond) {
[16:09:28.509]                   save_rds <- function (object, pathname, ...) 
[16:09:28.509]                   {
[16:09:28.509]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.509]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.509]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.509]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.509]                         fi_tmp[["mtime"]])
[16:09:28.509]                     }
[16:09:28.509]                     tryCatch({
[16:09:28.509]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.509]                     }, error = function(ex) {
[16:09:28.509]                       msg <- conditionMessage(ex)
[16:09:28.509]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.509]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.509]                         fi_tmp[["mtime"]], msg)
[16:09:28.509]                       ex$message <- msg
[16:09:28.509]                       stop(ex)
[16:09:28.509]                     })
[16:09:28.509]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.509]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.509]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.509]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.509]                       fi <- file.info(pathname)
[16:09:28.509]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.509]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.509]                         fi[["size"]], fi[["mtime"]])
[16:09:28.509]                       stop(msg)
[16:09:28.509]                     }
[16:09:28.509]                     invisible(pathname)
[16:09:28.509]                   }
[16:09:28.509]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.509]                     rootPath = tempdir()) 
[16:09:28.509]                   {
[16:09:28.509]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.509]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.509]                       tmpdir = path, fileext = ".rds")
[16:09:28.509]                     save_rds(obj, file)
[16:09:28.509]                   }
[16:09:28.509]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.509]                   {
[16:09:28.509]                     inherits <- base::inherits
[16:09:28.509]                     invokeRestart <- base::invokeRestart
[16:09:28.509]                     is.null <- base::is.null
[16:09:28.509]                     muffled <- FALSE
[16:09:28.509]                     if (inherits(cond, "message")) {
[16:09:28.509]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.509]                       if (muffled) 
[16:09:28.509]                         invokeRestart("muffleMessage")
[16:09:28.509]                     }
[16:09:28.509]                     else if (inherits(cond, "warning")) {
[16:09:28.509]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.509]                       if (muffled) 
[16:09:28.509]                         invokeRestart("muffleWarning")
[16:09:28.509]                     }
[16:09:28.509]                     else if (inherits(cond, "condition")) {
[16:09:28.509]                       if (!is.null(pattern)) {
[16:09:28.509]                         computeRestarts <- base::computeRestarts
[16:09:28.509]                         grepl <- base::grepl
[16:09:28.509]                         restarts <- computeRestarts(cond)
[16:09:28.509]                         for (restart in restarts) {
[16:09:28.509]                           name <- restart$name
[16:09:28.509]                           if (is.null(name)) 
[16:09:28.509]                             next
[16:09:28.509]                           if (!grepl(pattern, name)) 
[16:09:28.509]                             next
[16:09:28.509]                           invokeRestart(restart)
[16:09:28.509]                           muffled <- TRUE
[16:09:28.509]                           break
[16:09:28.509]                         }
[16:09:28.509]                       }
[16:09:28.509]                     }
[16:09:28.509]                     invisible(muffled)
[16:09:28.509]                   }
[16:09:28.509]                   muffleCondition(cond)
[16:09:28.509]                 })
[16:09:28.509]             }))
[16:09:28.509]             future::FutureResult(value = ...future.value$value, 
[16:09:28.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.509]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.509]                     ...future.globalenv.names))
[16:09:28.509]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.509]         }, condition = base::local({
[16:09:28.509]             c <- base::c
[16:09:28.509]             inherits <- base::inherits
[16:09:28.509]             invokeRestart <- base::invokeRestart
[16:09:28.509]             length <- base::length
[16:09:28.509]             list <- base::list
[16:09:28.509]             seq.int <- base::seq.int
[16:09:28.509]             signalCondition <- base::signalCondition
[16:09:28.509]             sys.calls <- base::sys.calls
[16:09:28.509]             `[[` <- base::`[[`
[16:09:28.509]             `+` <- base::`+`
[16:09:28.509]             `<<-` <- base::`<<-`
[16:09:28.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.509]                   3L)]
[16:09:28.509]             }
[16:09:28.509]             function(cond) {
[16:09:28.509]                 is_error <- inherits(cond, "error")
[16:09:28.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.509]                   NULL)
[16:09:28.509]                 if (is_error) {
[16:09:28.509]                   sessionInformation <- function() {
[16:09:28.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.509]                       search = base::search(), system = base::Sys.info())
[16:09:28.509]                   }
[16:09:28.509]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.509]                     cond$call), session = sessionInformation(), 
[16:09:28.509]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.509]                   signalCondition(cond)
[16:09:28.509]                 }
[16:09:28.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.509]                 "immediateCondition"))) {
[16:09:28.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.509]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.509]                   if (TRUE && !signal) {
[16:09:28.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.509]                     {
[16:09:28.509]                       inherits <- base::inherits
[16:09:28.509]                       invokeRestart <- base::invokeRestart
[16:09:28.509]                       is.null <- base::is.null
[16:09:28.509]                       muffled <- FALSE
[16:09:28.509]                       if (inherits(cond, "message")) {
[16:09:28.509]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.509]                         if (muffled) 
[16:09:28.509]                           invokeRestart("muffleMessage")
[16:09:28.509]                       }
[16:09:28.509]                       else if (inherits(cond, "warning")) {
[16:09:28.509]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.509]                         if (muffled) 
[16:09:28.509]                           invokeRestart("muffleWarning")
[16:09:28.509]                       }
[16:09:28.509]                       else if (inherits(cond, "condition")) {
[16:09:28.509]                         if (!is.null(pattern)) {
[16:09:28.509]                           computeRestarts <- base::computeRestarts
[16:09:28.509]                           grepl <- base::grepl
[16:09:28.509]                           restarts <- computeRestarts(cond)
[16:09:28.509]                           for (restart in restarts) {
[16:09:28.509]                             name <- restart$name
[16:09:28.509]                             if (is.null(name)) 
[16:09:28.509]                               next
[16:09:28.509]                             if (!grepl(pattern, name)) 
[16:09:28.509]                               next
[16:09:28.509]                             invokeRestart(restart)
[16:09:28.509]                             muffled <- TRUE
[16:09:28.509]                             break
[16:09:28.509]                           }
[16:09:28.509]                         }
[16:09:28.509]                       }
[16:09:28.509]                       invisible(muffled)
[16:09:28.509]                     }
[16:09:28.509]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.509]                   }
[16:09:28.509]                 }
[16:09:28.509]                 else {
[16:09:28.509]                   if (TRUE) {
[16:09:28.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.509]                     {
[16:09:28.509]                       inherits <- base::inherits
[16:09:28.509]                       invokeRestart <- base::invokeRestart
[16:09:28.509]                       is.null <- base::is.null
[16:09:28.509]                       muffled <- FALSE
[16:09:28.509]                       if (inherits(cond, "message")) {
[16:09:28.509]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.509]                         if (muffled) 
[16:09:28.509]                           invokeRestart("muffleMessage")
[16:09:28.509]                       }
[16:09:28.509]                       else if (inherits(cond, "warning")) {
[16:09:28.509]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.509]                         if (muffled) 
[16:09:28.509]                           invokeRestart("muffleWarning")
[16:09:28.509]                       }
[16:09:28.509]                       else if (inherits(cond, "condition")) {
[16:09:28.509]                         if (!is.null(pattern)) {
[16:09:28.509]                           computeRestarts <- base::computeRestarts
[16:09:28.509]                           grepl <- base::grepl
[16:09:28.509]                           restarts <- computeRestarts(cond)
[16:09:28.509]                           for (restart in restarts) {
[16:09:28.509]                             name <- restart$name
[16:09:28.509]                             if (is.null(name)) 
[16:09:28.509]                               next
[16:09:28.509]                             if (!grepl(pattern, name)) 
[16:09:28.509]                               next
[16:09:28.509]                             invokeRestart(restart)
[16:09:28.509]                             muffled <- TRUE
[16:09:28.509]                             break
[16:09:28.509]                           }
[16:09:28.509]                         }
[16:09:28.509]                       }
[16:09:28.509]                       invisible(muffled)
[16:09:28.509]                     }
[16:09:28.509]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.509]                   }
[16:09:28.509]                 }
[16:09:28.509]             }
[16:09:28.509]         }))
[16:09:28.509]     }, error = function(ex) {
[16:09:28.509]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.509]                 ...future.rng), started = ...future.startTime, 
[16:09:28.509]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.509]             version = "1.8"), class = "FutureResult")
[16:09:28.509]     }, finally = {
[16:09:28.509]         if (!identical(...future.workdir, getwd())) 
[16:09:28.509]             setwd(...future.workdir)
[16:09:28.509]         {
[16:09:28.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.509]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.509]             }
[16:09:28.509]             base::options(...future.oldOptions)
[16:09:28.509]             if (.Platform$OS.type == "windows") {
[16:09:28.509]                 old_names <- names(...future.oldEnvVars)
[16:09:28.509]                 envs <- base::Sys.getenv()
[16:09:28.509]                 names <- names(envs)
[16:09:28.509]                 common <- intersect(names, old_names)
[16:09:28.509]                 added <- setdiff(names, old_names)
[16:09:28.509]                 removed <- setdiff(old_names, names)
[16:09:28.509]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.509]                   envs[common]]
[16:09:28.509]                 NAMES <- toupper(changed)
[16:09:28.509]                 args <- list()
[16:09:28.509]                 for (kk in seq_along(NAMES)) {
[16:09:28.509]                   name <- changed[[kk]]
[16:09:28.509]                   NAME <- NAMES[[kk]]
[16:09:28.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.509]                     next
[16:09:28.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.509]                 }
[16:09:28.509]                 NAMES <- toupper(added)
[16:09:28.509]                 for (kk in seq_along(NAMES)) {
[16:09:28.509]                   name <- added[[kk]]
[16:09:28.509]                   NAME <- NAMES[[kk]]
[16:09:28.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.509]                     next
[16:09:28.509]                   args[[name]] <- ""
[16:09:28.509]                 }
[16:09:28.509]                 NAMES <- toupper(removed)
[16:09:28.509]                 for (kk in seq_along(NAMES)) {
[16:09:28.509]                   name <- removed[[kk]]
[16:09:28.509]                   NAME <- NAMES[[kk]]
[16:09:28.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.509]                     next
[16:09:28.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.509]                 }
[16:09:28.509]                 if (length(args) > 0) 
[16:09:28.509]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.509]             }
[16:09:28.509]             else {
[16:09:28.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.509]             }
[16:09:28.509]             {
[16:09:28.509]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.509]                   0L) {
[16:09:28.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.509]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.509]                   base::options(opts)
[16:09:28.509]                 }
[16:09:28.509]                 {
[16:09:28.509]                   {
[16:09:28.509]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.509]                     NULL
[16:09:28.509]                   }
[16:09:28.509]                   options(future.plan = NULL)
[16:09:28.509]                   if (is.na(NA_character_)) 
[16:09:28.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.509]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.509]                     envir = parent.frame()) 
[16:09:28.509]                   {
[16:09:28.509]                     default_workers <- missing(workers)
[16:09:28.509]                     if (is.function(workers)) 
[16:09:28.509]                       workers <- workers()
[16:09:28.509]                     workers <- structure(as.integer(workers), 
[16:09:28.509]                       class = class(workers))
[16:09:28.509]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.509]                       1L)
[16:09:28.509]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.509]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.509]                       if (default_workers) 
[16:09:28.509]                         supportsMulticore(warn = TRUE)
[16:09:28.509]                       return(sequential(..., envir = envir))
[16:09:28.509]                     }
[16:09:28.509]                     oopts <- options(mc.cores = workers)
[16:09:28.509]                     on.exit(options(oopts))
[16:09:28.509]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.509]                       envir = envir)
[16:09:28.509]                     if (!future$lazy) 
[16:09:28.509]                       future <- run(future)
[16:09:28.509]                     invisible(future)
[16:09:28.509]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.509]                 }
[16:09:28.509]             }
[16:09:28.509]         }
[16:09:28.509]     })
[16:09:28.509]     if (TRUE) {
[16:09:28.509]         base::sink(type = "output", split = FALSE)
[16:09:28.509]         if (TRUE) {
[16:09:28.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.509]         }
[16:09:28.509]         else {
[16:09:28.509]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.509]         }
[16:09:28.509]         base::close(...future.stdout)
[16:09:28.509]         ...future.stdout <- NULL
[16:09:28.509]     }
[16:09:28.509]     ...future.result$conditions <- ...future.conditions
[16:09:28.509]     ...future.result$finished <- base::Sys.time()
[16:09:28.509]     ...future.result
[16:09:28.509] }
[16:09:28.511] assign_globals() ...
[16:09:28.511] List of 5
[16:09:28.511]  $ future.call.arguments    : list()
[16:09:28.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.511]  $ ...future.FUN            :function (x)  
[16:09:28.511]  $ ...future.elements_ii    :List of 1
[16:09:28.511]   ..$ : int 1
[16:09:28.511]  $ ...future.seeds_ii       : NULL
[16:09:28.511]  $ ...future.globals.maxSize: NULL
[16:09:28.511]  - attr(*, "where")=List of 5
[16:09:28.511]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.511]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.511]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.511]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.511]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.511]  - attr(*, "resolved")= logi FALSE
[16:09:28.511]  - attr(*, "total_size")= num NA
[16:09:28.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.511]  - attr(*, "already-done")= logi TRUE
[16:09:28.516] - copied ‘future.call.arguments’ to environment
[16:09:28.516] - copied ‘...future.FUN’ to environment
[16:09:28.516] - copied ‘...future.elements_ii’ to environment
[16:09:28.516] - copied ‘...future.seeds_ii’ to environment
[16:09:28.516] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.517] assign_globals() ... done
[16:09:28.517] requestCore(): workers = 2
[16:09:28.519] MulticoreFuture started
[16:09:28.519] - Launch lazy future ... done
[16:09:28.519] run() for ‘MulticoreFuture’ ... done
[16:09:28.520] Created future:
[16:09:28.520] plan(): Setting new future strategy stack:
[16:09:28.520] List of future strategies:
[16:09:28.520] 1. sequential:
[16:09:28.520]    - args: function (..., envir = parent.frame())
[16:09:28.520]    - tweaked: FALSE
[16:09:28.520]    - call: NULL
[16:09:28.521] plan(): nbrOfWorkers() = 1
[16:09:28.523] plan(): Setting new future strategy stack:
[16:09:28.527] List of future strategies:
[16:09:28.527] 1. multicore:
[16:09:28.527]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.527]    - tweaked: FALSE
[16:09:28.527]    - call: plan(strategy)
[16:09:28.536] plan(): nbrOfWorkers() = 2
[16:09:28.520] MulticoreFuture:
[16:09:28.520] Label: ‘future_apply-1’
[16:09:28.520] Expression:
[16:09:28.520] {
[16:09:28.520]     do.call(function(...) {
[16:09:28.520]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.520]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.520]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.520]             on.exit(options(oopts), add = TRUE)
[16:09:28.520]         }
[16:09:28.520]         {
[16:09:28.520]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.520]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.520]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.520]             })
[16:09:28.520]         }
[16:09:28.520]     }, args = future.call.arguments)
[16:09:28.520] }
[16:09:28.520] Lazy evaluation: FALSE
[16:09:28.520] Asynchronous evaluation: TRUE
[16:09:28.520] Local evaluation: TRUE
[16:09:28.520] Environment: R_GlobalEnv
[16:09:28.520] Capture standard output: TRUE
[16:09:28.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.520] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.520] Packages: <none>
[16:09:28.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.520] Resolved: FALSE
[16:09:28.520] Value: <not collected>
[16:09:28.520] Conditions captured: <none>
[16:09:28.520] Early signaling: FALSE
[16:09:28.520] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.520] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.537] Chunk #1 of 2 ... DONE
[16:09:28.537] Chunk #2 of 2 ...
[16:09:28.537]  - seeds: <none>
[16:09:28.538] getGlobalsAndPackages() ...
[16:09:28.538] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.538] Resolving globals: FALSE
[16:09:28.538] Tweak future expression to call with '...' arguments ...
[16:09:28.539] {
[16:09:28.539]     do.call(function(...) {
[16:09:28.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.539]             on.exit(options(oopts), add = TRUE)
[16:09:28.539]         }
[16:09:28.539]         {
[16:09:28.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.539]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.539]             })
[16:09:28.539]         }
[16:09:28.539]     }, args = future.call.arguments)
[16:09:28.539] }
[16:09:28.539] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.540] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.540] 
[16:09:28.541] getGlobalsAndPackages() ... DONE
[16:09:28.542] run() for ‘Future’ ...
[16:09:28.542] - state: ‘created’
[16:09:28.542] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.548]   - Field: ‘label’
[16:09:28.549]   - Field: ‘local’
[16:09:28.549]   - Field: ‘owner’
[16:09:28.549]   - Field: ‘envir’
[16:09:28.549]   - Field: ‘workers’
[16:09:28.549]   - Field: ‘packages’
[16:09:28.550]   - Field: ‘gc’
[16:09:28.550]   - Field: ‘job’
[16:09:28.550]   - Field: ‘conditions’
[16:09:28.550]   - Field: ‘expr’
[16:09:28.551]   - Field: ‘uuid’
[16:09:28.551]   - Field: ‘seed’
[16:09:28.551]   - Field: ‘version’
[16:09:28.551]   - Field: ‘result’
[16:09:28.551]   - Field: ‘asynchronous’
[16:09:28.551]   - Field: ‘calls’
[16:09:28.551]   - Field: ‘globals’
[16:09:28.552]   - Field: ‘stdout’
[16:09:28.552]   - Field: ‘earlySignal’
[16:09:28.552]   - Field: ‘lazy’
[16:09:28.552]   - Field: ‘state’
[16:09:28.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.552] - Launch lazy future ...
[16:09:28.553] Packages needed by the future expression (n = 0): <none>
[16:09:28.553] Packages needed by future strategies (n = 0): <none>
[16:09:28.554] {
[16:09:28.554]     {
[16:09:28.554]         {
[16:09:28.554]             ...future.startTime <- base::Sys.time()
[16:09:28.554]             {
[16:09:28.554]                 {
[16:09:28.554]                   {
[16:09:28.554]                     {
[16:09:28.554]                       base::local({
[16:09:28.554]                         has_future <- base::requireNamespace("future", 
[16:09:28.554]                           quietly = TRUE)
[16:09:28.554]                         if (has_future) {
[16:09:28.554]                           ns <- base::getNamespace("future")
[16:09:28.554]                           version <- ns[[".package"]][["version"]]
[16:09:28.554]                           if (is.null(version)) 
[16:09:28.554]                             version <- utils::packageVersion("future")
[16:09:28.554]                         }
[16:09:28.554]                         else {
[16:09:28.554]                           version <- NULL
[16:09:28.554]                         }
[16:09:28.554]                         if (!has_future || version < "1.8.0") {
[16:09:28.554]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.554]                             "", base::R.version$version.string), 
[16:09:28.554]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.554]                               "release", "version")], collapse = " "), 
[16:09:28.554]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.554]                             info)
[16:09:28.554]                           info <- base::paste(info, collapse = "; ")
[16:09:28.554]                           if (!has_future) {
[16:09:28.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.554]                               info)
[16:09:28.554]                           }
[16:09:28.554]                           else {
[16:09:28.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.554]                               info, version)
[16:09:28.554]                           }
[16:09:28.554]                           base::stop(msg)
[16:09:28.554]                         }
[16:09:28.554]                       })
[16:09:28.554]                     }
[16:09:28.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.554]                     base::options(mc.cores = 1L)
[16:09:28.554]                   }
[16:09:28.554]                   options(future.plan = NULL)
[16:09:28.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.554]                 }
[16:09:28.554]                 ...future.workdir <- getwd()
[16:09:28.554]             }
[16:09:28.554]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.554]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.554]         }
[16:09:28.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.554]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.554]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.554]             base::names(...future.oldOptions))
[16:09:28.554]     }
[16:09:28.554]     if (FALSE) {
[16:09:28.554]     }
[16:09:28.554]     else {
[16:09:28.554]         if (TRUE) {
[16:09:28.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.554]                 open = "w")
[16:09:28.554]         }
[16:09:28.554]         else {
[16:09:28.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.554]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.554]         }
[16:09:28.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.554]             base::sink(type = "output", split = FALSE)
[16:09:28.554]             base::close(...future.stdout)
[16:09:28.554]         }, add = TRUE)
[16:09:28.554]     }
[16:09:28.554]     ...future.frame <- base::sys.nframe()
[16:09:28.554]     ...future.conditions <- base::list()
[16:09:28.554]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.554]     if (FALSE) {
[16:09:28.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.554]     }
[16:09:28.554]     ...future.result <- base::tryCatch({
[16:09:28.554]         base::withCallingHandlers({
[16:09:28.554]             ...future.value <- base::withVisible(base::local({
[16:09:28.554]                 withCallingHandlers({
[16:09:28.554]                   {
[16:09:28.554]                     do.call(function(...) {
[16:09:28.554]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.554]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.554]                         ...future.globals.maxSize)) {
[16:09:28.554]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.554]                         on.exit(options(oopts), add = TRUE)
[16:09:28.554]                       }
[16:09:28.554]                       {
[16:09:28.554]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.554]                           FUN = function(jj) {
[16:09:28.554]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.554]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.554]                           })
[16:09:28.554]                       }
[16:09:28.554]                     }, args = future.call.arguments)
[16:09:28.554]                   }
[16:09:28.554]                 }, immediateCondition = function(cond) {
[16:09:28.554]                   save_rds <- function (object, pathname, ...) 
[16:09:28.554]                   {
[16:09:28.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.554]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.554]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.554]                         fi_tmp[["mtime"]])
[16:09:28.554]                     }
[16:09:28.554]                     tryCatch({
[16:09:28.554]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.554]                     }, error = function(ex) {
[16:09:28.554]                       msg <- conditionMessage(ex)
[16:09:28.554]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.554]                         fi_tmp[["mtime"]], msg)
[16:09:28.554]                       ex$message <- msg
[16:09:28.554]                       stop(ex)
[16:09:28.554]                     })
[16:09:28.554]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.554]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.554]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.554]                       fi <- file.info(pathname)
[16:09:28.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.554]                         fi[["size"]], fi[["mtime"]])
[16:09:28.554]                       stop(msg)
[16:09:28.554]                     }
[16:09:28.554]                     invisible(pathname)
[16:09:28.554]                   }
[16:09:28.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.554]                     rootPath = tempdir()) 
[16:09:28.554]                   {
[16:09:28.554]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.554]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.554]                       tmpdir = path, fileext = ".rds")
[16:09:28.554]                     save_rds(obj, file)
[16:09:28.554]                   }
[16:09:28.554]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.554]                   {
[16:09:28.554]                     inherits <- base::inherits
[16:09:28.554]                     invokeRestart <- base::invokeRestart
[16:09:28.554]                     is.null <- base::is.null
[16:09:28.554]                     muffled <- FALSE
[16:09:28.554]                     if (inherits(cond, "message")) {
[16:09:28.554]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.554]                       if (muffled) 
[16:09:28.554]                         invokeRestart("muffleMessage")
[16:09:28.554]                     }
[16:09:28.554]                     else if (inherits(cond, "warning")) {
[16:09:28.554]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.554]                       if (muffled) 
[16:09:28.554]                         invokeRestart("muffleWarning")
[16:09:28.554]                     }
[16:09:28.554]                     else if (inherits(cond, "condition")) {
[16:09:28.554]                       if (!is.null(pattern)) {
[16:09:28.554]                         computeRestarts <- base::computeRestarts
[16:09:28.554]                         grepl <- base::grepl
[16:09:28.554]                         restarts <- computeRestarts(cond)
[16:09:28.554]                         for (restart in restarts) {
[16:09:28.554]                           name <- restart$name
[16:09:28.554]                           if (is.null(name)) 
[16:09:28.554]                             next
[16:09:28.554]                           if (!grepl(pattern, name)) 
[16:09:28.554]                             next
[16:09:28.554]                           invokeRestart(restart)
[16:09:28.554]                           muffled <- TRUE
[16:09:28.554]                           break
[16:09:28.554]                         }
[16:09:28.554]                       }
[16:09:28.554]                     }
[16:09:28.554]                     invisible(muffled)
[16:09:28.554]                   }
[16:09:28.554]                   muffleCondition(cond)
[16:09:28.554]                 })
[16:09:28.554]             }))
[16:09:28.554]             future::FutureResult(value = ...future.value$value, 
[16:09:28.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.554]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.554]                     ...future.globalenv.names))
[16:09:28.554]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.554]         }, condition = base::local({
[16:09:28.554]             c <- base::c
[16:09:28.554]             inherits <- base::inherits
[16:09:28.554]             invokeRestart <- base::invokeRestart
[16:09:28.554]             length <- base::length
[16:09:28.554]             list <- base::list
[16:09:28.554]             seq.int <- base::seq.int
[16:09:28.554]             signalCondition <- base::signalCondition
[16:09:28.554]             sys.calls <- base::sys.calls
[16:09:28.554]             `[[` <- base::`[[`
[16:09:28.554]             `+` <- base::`+`
[16:09:28.554]             `<<-` <- base::`<<-`
[16:09:28.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.554]                   3L)]
[16:09:28.554]             }
[16:09:28.554]             function(cond) {
[16:09:28.554]                 is_error <- inherits(cond, "error")
[16:09:28.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.554]                   NULL)
[16:09:28.554]                 if (is_error) {
[16:09:28.554]                   sessionInformation <- function() {
[16:09:28.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.554]                       search = base::search(), system = base::Sys.info())
[16:09:28.554]                   }
[16:09:28.554]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.554]                     cond$call), session = sessionInformation(), 
[16:09:28.554]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.554]                   signalCondition(cond)
[16:09:28.554]                 }
[16:09:28.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.554]                 "immediateCondition"))) {
[16:09:28.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.554]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.554]                   if (TRUE && !signal) {
[16:09:28.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.554]                     {
[16:09:28.554]                       inherits <- base::inherits
[16:09:28.554]                       invokeRestart <- base::invokeRestart
[16:09:28.554]                       is.null <- base::is.null
[16:09:28.554]                       muffled <- FALSE
[16:09:28.554]                       if (inherits(cond, "message")) {
[16:09:28.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.554]                         if (muffled) 
[16:09:28.554]                           invokeRestart("muffleMessage")
[16:09:28.554]                       }
[16:09:28.554]                       else if (inherits(cond, "warning")) {
[16:09:28.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.554]                         if (muffled) 
[16:09:28.554]                           invokeRestart("muffleWarning")
[16:09:28.554]                       }
[16:09:28.554]                       else if (inherits(cond, "condition")) {
[16:09:28.554]                         if (!is.null(pattern)) {
[16:09:28.554]                           computeRestarts <- base::computeRestarts
[16:09:28.554]                           grepl <- base::grepl
[16:09:28.554]                           restarts <- computeRestarts(cond)
[16:09:28.554]                           for (restart in restarts) {
[16:09:28.554]                             name <- restart$name
[16:09:28.554]                             if (is.null(name)) 
[16:09:28.554]                               next
[16:09:28.554]                             if (!grepl(pattern, name)) 
[16:09:28.554]                               next
[16:09:28.554]                             invokeRestart(restart)
[16:09:28.554]                             muffled <- TRUE
[16:09:28.554]                             break
[16:09:28.554]                           }
[16:09:28.554]                         }
[16:09:28.554]                       }
[16:09:28.554]                       invisible(muffled)
[16:09:28.554]                     }
[16:09:28.554]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.554]                   }
[16:09:28.554]                 }
[16:09:28.554]                 else {
[16:09:28.554]                   if (TRUE) {
[16:09:28.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.554]                     {
[16:09:28.554]                       inherits <- base::inherits
[16:09:28.554]                       invokeRestart <- base::invokeRestart
[16:09:28.554]                       is.null <- base::is.null
[16:09:28.554]                       muffled <- FALSE
[16:09:28.554]                       if (inherits(cond, "message")) {
[16:09:28.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.554]                         if (muffled) 
[16:09:28.554]                           invokeRestart("muffleMessage")
[16:09:28.554]                       }
[16:09:28.554]                       else if (inherits(cond, "warning")) {
[16:09:28.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.554]                         if (muffled) 
[16:09:28.554]                           invokeRestart("muffleWarning")
[16:09:28.554]                       }
[16:09:28.554]                       else if (inherits(cond, "condition")) {
[16:09:28.554]                         if (!is.null(pattern)) {
[16:09:28.554]                           computeRestarts <- base::computeRestarts
[16:09:28.554]                           grepl <- base::grepl
[16:09:28.554]                           restarts <- computeRestarts(cond)
[16:09:28.554]                           for (restart in restarts) {
[16:09:28.554]                             name <- restart$name
[16:09:28.554]                             if (is.null(name)) 
[16:09:28.554]                               next
[16:09:28.554]                             if (!grepl(pattern, name)) 
[16:09:28.554]                               next
[16:09:28.554]                             invokeRestart(restart)
[16:09:28.554]                             muffled <- TRUE
[16:09:28.554]                             break
[16:09:28.554]                           }
[16:09:28.554]                         }
[16:09:28.554]                       }
[16:09:28.554]                       invisible(muffled)
[16:09:28.554]                     }
[16:09:28.554]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.554]                   }
[16:09:28.554]                 }
[16:09:28.554]             }
[16:09:28.554]         }))
[16:09:28.554]     }, error = function(ex) {
[16:09:28.554]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.554]                 ...future.rng), started = ...future.startTime, 
[16:09:28.554]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.554]             version = "1.8"), class = "FutureResult")
[16:09:28.554]     }, finally = {
[16:09:28.554]         if (!identical(...future.workdir, getwd())) 
[16:09:28.554]             setwd(...future.workdir)
[16:09:28.554]         {
[16:09:28.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.554]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.554]             }
[16:09:28.554]             base::options(...future.oldOptions)
[16:09:28.554]             if (.Platform$OS.type == "windows") {
[16:09:28.554]                 old_names <- names(...future.oldEnvVars)
[16:09:28.554]                 envs <- base::Sys.getenv()
[16:09:28.554]                 names <- names(envs)
[16:09:28.554]                 common <- intersect(names, old_names)
[16:09:28.554]                 added <- setdiff(names, old_names)
[16:09:28.554]                 removed <- setdiff(old_names, names)
[16:09:28.554]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.554]                   envs[common]]
[16:09:28.554]                 NAMES <- toupper(changed)
[16:09:28.554]                 args <- list()
[16:09:28.554]                 for (kk in seq_along(NAMES)) {
[16:09:28.554]                   name <- changed[[kk]]
[16:09:28.554]                   NAME <- NAMES[[kk]]
[16:09:28.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.554]                     next
[16:09:28.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.554]                 }
[16:09:28.554]                 NAMES <- toupper(added)
[16:09:28.554]                 for (kk in seq_along(NAMES)) {
[16:09:28.554]                   name <- added[[kk]]
[16:09:28.554]                   NAME <- NAMES[[kk]]
[16:09:28.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.554]                     next
[16:09:28.554]                   args[[name]] <- ""
[16:09:28.554]                 }
[16:09:28.554]                 NAMES <- toupper(removed)
[16:09:28.554]                 for (kk in seq_along(NAMES)) {
[16:09:28.554]                   name <- removed[[kk]]
[16:09:28.554]                   NAME <- NAMES[[kk]]
[16:09:28.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.554]                     next
[16:09:28.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.554]                 }
[16:09:28.554]                 if (length(args) > 0) 
[16:09:28.554]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.554]             }
[16:09:28.554]             else {
[16:09:28.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.554]             }
[16:09:28.554]             {
[16:09:28.554]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.554]                   0L) {
[16:09:28.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.554]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.554]                   base::options(opts)
[16:09:28.554]                 }
[16:09:28.554]                 {
[16:09:28.554]                   {
[16:09:28.554]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.554]                     NULL
[16:09:28.554]                   }
[16:09:28.554]                   options(future.plan = NULL)
[16:09:28.554]                   if (is.na(NA_character_)) 
[16:09:28.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.554]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.554]                     envir = parent.frame()) 
[16:09:28.554]                   {
[16:09:28.554]                     default_workers <- missing(workers)
[16:09:28.554]                     if (is.function(workers)) 
[16:09:28.554]                       workers <- workers()
[16:09:28.554]                     workers <- structure(as.integer(workers), 
[16:09:28.554]                       class = class(workers))
[16:09:28.554]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.554]                       1L)
[16:09:28.554]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.554]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.554]                       if (default_workers) 
[16:09:28.554]                         supportsMulticore(warn = TRUE)
[16:09:28.554]                       return(sequential(..., envir = envir))
[16:09:28.554]                     }
[16:09:28.554]                     oopts <- options(mc.cores = workers)
[16:09:28.554]                     on.exit(options(oopts))
[16:09:28.554]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.554]                       envir = envir)
[16:09:28.554]                     if (!future$lazy) 
[16:09:28.554]                       future <- run(future)
[16:09:28.554]                     invisible(future)
[16:09:28.554]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.554]                 }
[16:09:28.554]             }
[16:09:28.554]         }
[16:09:28.554]     })
[16:09:28.554]     if (TRUE) {
[16:09:28.554]         base::sink(type = "output", split = FALSE)
[16:09:28.554]         if (TRUE) {
[16:09:28.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.554]         }
[16:09:28.554]         else {
[16:09:28.554]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.554]         }
[16:09:28.554]         base::close(...future.stdout)
[16:09:28.554]         ...future.stdout <- NULL
[16:09:28.554]     }
[16:09:28.554]     ...future.result$conditions <- ...future.conditions
[16:09:28.554]     ...future.result$finished <- base::Sys.time()
[16:09:28.554]     ...future.result
[16:09:28.554] }
[16:09:28.557] assign_globals() ...
[16:09:28.557] List of 5
[16:09:28.557]  $ future.call.arguments    : list()
[16:09:28.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.557]  $ ...future.FUN            :function (x)  
[16:09:28.557]  $ ...future.elements_ii    :List of 1
[16:09:28.557]   ..$ : int 2
[16:09:28.557]  $ ...future.seeds_ii       : NULL
[16:09:28.557]  $ ...future.globals.maxSize: NULL
[16:09:28.557]  - attr(*, "where")=List of 5
[16:09:28.557]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.557]  - attr(*, "resolved")= logi FALSE
[16:09:28.557]  - attr(*, "total_size")= num NA
[16:09:28.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.557]  - attr(*, "already-done")= logi TRUE
[16:09:28.563] - copied ‘future.call.arguments’ to environment
[16:09:28.564] - copied ‘...future.FUN’ to environment
[16:09:28.564] - copied ‘...future.elements_ii’ to environment
[16:09:28.564] - copied ‘...future.seeds_ii’ to environment
[16:09:28.564] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.564] assign_globals() ... done
[16:09:28.564] requestCore(): workers = 2
[16:09:28.567] MulticoreFuture started
[16:09:28.567] - Launch lazy future ... done
[16:09:28.567] run() for ‘MulticoreFuture’ ... done
[16:09:28.568] Created future:
[16:09:28.568] plan(): Setting new future strategy stack:
[16:09:28.568] List of future strategies:
[16:09:28.568] 1. sequential:
[16:09:28.568]    - args: function (..., envir = parent.frame())
[16:09:28.568]    - tweaked: FALSE
[16:09:28.568]    - call: NULL
[16:09:28.569] plan(): nbrOfWorkers() = 1
[16:09:28.571] plan(): Setting new future strategy stack:
[16:09:28.571] List of future strategies:
[16:09:28.571] 1. multicore:
[16:09:28.571]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.571]    - tweaked: FALSE
[16:09:28.571]    - call: plan(strategy)
[16:09:28.577] plan(): nbrOfWorkers() = 2
[16:09:28.568] MulticoreFuture:
[16:09:28.568] Label: ‘future_apply-2’
[16:09:28.568] Expression:
[16:09:28.568] {
[16:09:28.568]     do.call(function(...) {
[16:09:28.568]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.568]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.568]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.568]             on.exit(options(oopts), add = TRUE)
[16:09:28.568]         }
[16:09:28.568]         {
[16:09:28.568]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.568]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.568]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.568]             })
[16:09:28.568]         }
[16:09:28.568]     }, args = future.call.arguments)
[16:09:28.568] }
[16:09:28.568] Lazy evaluation: FALSE
[16:09:28.568] Asynchronous evaluation: TRUE
[16:09:28.568] Local evaluation: TRUE
[16:09:28.568] Environment: R_GlobalEnv
[16:09:28.568] Capture standard output: TRUE
[16:09:28.568] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.568] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.568] Packages: <none>
[16:09:28.568] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.568] Resolved: TRUE
[16:09:28.568] Value: <not collected>
[16:09:28.568] Conditions captured: <none>
[16:09:28.568] Early signaling: FALSE
[16:09:28.568] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.568] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.579] Chunk #2 of 2 ... DONE
[16:09:28.579] Launching 2 futures (chunks) ... DONE
[16:09:28.579] Resolving 2 futures (chunks) ...
[16:09:28.579] resolve() on list ...
[16:09:28.579]  recursive: 0
[16:09:28.580]  length: 2
[16:09:28.580] 
[16:09:28.580] Future #1
[16:09:28.581] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.581] - nx: 2
[16:09:28.582] - relay: TRUE
[16:09:28.582] - stdout: TRUE
[16:09:28.582] - signal: TRUE
[16:09:28.582] - resignal: FALSE
[16:09:28.582] - force: TRUE
[16:09:28.582] - relayed: [n=2] FALSE, FALSE
[16:09:28.582] - queued futures: [n=2] FALSE, FALSE
[16:09:28.582]  - until=1
[16:09:28.583]  - relaying element #1
[16:09:28.583] - relayed: [n=2] TRUE, FALSE
[16:09:28.583] - queued futures: [n=2] TRUE, FALSE
[16:09:28.583] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.583]  length: 1 (resolved future 1)
[16:09:28.584] Future #2
[16:09:28.585] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.585] - nx: 2
[16:09:28.585] - relay: TRUE
[16:09:28.585] - stdout: TRUE
[16:09:28.585] - signal: TRUE
[16:09:28.585] - resignal: FALSE
[16:09:28.585] - force: TRUE
[16:09:28.586] - relayed: [n=2] TRUE, FALSE
[16:09:28.586] - queued futures: [n=2] TRUE, FALSE
[16:09:28.586]  - until=2
[16:09:28.586]  - relaying element #2
[16:09:28.586] - relayed: [n=2] TRUE, TRUE
[16:09:28.586] - queued futures: [n=2] TRUE, TRUE
[16:09:28.587] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.587]  length: 0 (resolved future 2)
[16:09:28.589] Relaying remaining futures
[16:09:28.589] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.589] - nx: 2
[16:09:28.590] - relay: TRUE
[16:09:28.590] - stdout: TRUE
[16:09:28.590] - signal: TRUE
[16:09:28.590] - resignal: FALSE
[16:09:28.590] - force: TRUE
[16:09:28.591] - relayed: [n=2] TRUE, TRUE
[16:09:28.591] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.591] - relayed: [n=2] TRUE, TRUE
[16:09:28.591] - queued futures: [n=2] TRUE, TRUE
[16:09:28.591] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.591] resolve() on list ... DONE
[16:09:28.592]  - Number of value chunks collected: 2
[16:09:28.592] Resolving 2 futures (chunks) ... DONE
[16:09:28.592] Reducing values from 2 chunks ...
[16:09:28.592]  - Number of values collected after concatenation: 2
[16:09:28.592]  - Number of values expected: 2
[16:09:28.593] Reducing values from 2 chunks ... DONE
[16:09:28.593] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:09:28.593] getGlobalsAndPackagesXApply() ...
[16:09:28.593]  - future.globals: TRUE
[16:09:28.594] getGlobalsAndPackages() ...
[16:09:28.594] Searching for globals...
[16:09:28.595] - globals found: [1] ‘FUN’
[16:09:28.595] Searching for globals ... DONE
[16:09:28.595] Resolving globals: FALSE
[16:09:28.596] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:28.596] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:28.597] - globals: [1] ‘FUN’
[16:09:28.597] 
[16:09:28.597] getGlobalsAndPackages() ... DONE
[16:09:28.597]  - globals found/used: [n=1] ‘FUN’
[16:09:28.597]  - needed namespaces: [n=0] 
[16:09:28.597] Finding globals ... DONE
[16:09:28.597]  - use_args: TRUE
[16:09:28.598]  - Getting '...' globals ...
[16:09:28.598] resolve() on list ...
[16:09:28.598]  recursive: 0
[16:09:28.598]  length: 1
[16:09:28.598]  elements: ‘...’
[16:09:28.598]  length: 0 (resolved future 1)
[16:09:28.599] resolve() on list ... DONE
[16:09:28.599]    - '...' content: [n=0] 
[16:09:28.599] List of 1
[16:09:28.599]  $ ...: list()
[16:09:28.599]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.599]  - attr(*, "where")=List of 1
[16:09:28.599]   ..$ ...:<environment: 0x5633acb0cae8> 
[16:09:28.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.599]  - attr(*, "resolved")= logi TRUE
[16:09:28.599]  - attr(*, "total_size")= num NA
[16:09:28.602]  - Getting '...' globals ... DONE
[16:09:28.602] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.602] List of 2
[16:09:28.602]  $ ...future.FUN:function (x)  
[16:09:28.602]  $ ...          : list()
[16:09:28.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.602]  - attr(*, "where")=List of 2
[16:09:28.602]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.602]   ..$ ...          :<environment: 0x5633acb0cae8> 
[16:09:28.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.602]  - attr(*, "resolved")= logi FALSE
[16:09:28.602]  - attr(*, "total_size")= num 848
[16:09:28.606] Packages to be attached in all futures: [n=0] 
[16:09:28.606] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.610] future_lapply() ...
[16:09:28.613] Number of chunks: 2
[16:09:28.614] getGlobalsAndPackagesXApply() ...
[16:09:28.614]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.614]  - use_args: TRUE
[16:09:28.614] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.614] List of 2
[16:09:28.614]  $ ...          : list()
[16:09:28.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.614]  $ ...future.FUN:function (x)  
[16:09:28.614]  - attr(*, "where")=List of 2
[16:09:28.614]   ..$ ...          :<environment: 0x5633acb0cae8> 
[16:09:28.614]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:28.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.614]  - attr(*, "resolved")= logi FALSE
[16:09:28.614]  - attr(*, "total_size")= num NA
[16:09:28.618] Packages to be attached in all futures: [n=0] 
[16:09:28.618] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.618] Number of futures (= number of chunks): 2
[16:09:28.619] Launching 2 futures (chunks) ...
[16:09:28.620] Chunk #1 of 2 ...
[16:09:28.620]  - seeds: <none>
[16:09:28.620] getGlobalsAndPackages() ...
[16:09:28.620] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.620] Resolving globals: FALSE
[16:09:28.620] Tweak future expression to call with '...' arguments ...
[16:09:28.620] {
[16:09:28.620]     do.call(function(...) {
[16:09:28.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.620]             on.exit(options(oopts), add = TRUE)
[16:09:28.620]         }
[16:09:28.620]         {
[16:09:28.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.620]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.620]             })
[16:09:28.620]         }
[16:09:28.620]     }, args = future.call.arguments)
[16:09:28.620] }
[16:09:28.621] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.621] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.621] 
[16:09:28.621] getGlobalsAndPackages() ... DONE
[16:09:28.622] run() for ‘Future’ ...
[16:09:28.622] - state: ‘created’
[16:09:28.622] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.626] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.626]   - Field: ‘label’
[16:09:28.626]   - Field: ‘local’
[16:09:28.626]   - Field: ‘owner’
[16:09:28.626]   - Field: ‘envir’
[16:09:28.626]   - Field: ‘workers’
[16:09:28.627]   - Field: ‘packages’
[16:09:28.627]   - Field: ‘gc’
[16:09:28.627]   - Field: ‘job’
[16:09:28.627]   - Field: ‘conditions’
[16:09:28.627]   - Field: ‘expr’
[16:09:28.627]   - Field: ‘uuid’
[16:09:28.627]   - Field: ‘seed’
[16:09:28.627]   - Field: ‘version’
[16:09:28.627]   - Field: ‘result’
[16:09:28.627]   - Field: ‘asynchronous’
[16:09:28.627]   - Field: ‘calls’
[16:09:28.628]   - Field: ‘globals’
[16:09:28.628]   - Field: ‘stdout’
[16:09:28.628]   - Field: ‘earlySignal’
[16:09:28.628]   - Field: ‘lazy’
[16:09:28.628]   - Field: ‘state’
[16:09:28.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.628] - Launch lazy future ...
[16:09:28.628] Packages needed by the future expression (n = 0): <none>
[16:09:28.629] Packages needed by future strategies (n = 0): <none>
[16:09:28.629] {
[16:09:28.629]     {
[16:09:28.629]         {
[16:09:28.629]             ...future.startTime <- base::Sys.time()
[16:09:28.629]             {
[16:09:28.629]                 {
[16:09:28.629]                   {
[16:09:28.629]                     {
[16:09:28.629]                       base::local({
[16:09:28.629]                         has_future <- base::requireNamespace("future", 
[16:09:28.629]                           quietly = TRUE)
[16:09:28.629]                         if (has_future) {
[16:09:28.629]                           ns <- base::getNamespace("future")
[16:09:28.629]                           version <- ns[[".package"]][["version"]]
[16:09:28.629]                           if (is.null(version)) 
[16:09:28.629]                             version <- utils::packageVersion("future")
[16:09:28.629]                         }
[16:09:28.629]                         else {
[16:09:28.629]                           version <- NULL
[16:09:28.629]                         }
[16:09:28.629]                         if (!has_future || version < "1.8.0") {
[16:09:28.629]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.629]                             "", base::R.version$version.string), 
[16:09:28.629]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.629]                               "release", "version")], collapse = " "), 
[16:09:28.629]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.629]                             info)
[16:09:28.629]                           info <- base::paste(info, collapse = "; ")
[16:09:28.629]                           if (!has_future) {
[16:09:28.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.629]                               info)
[16:09:28.629]                           }
[16:09:28.629]                           else {
[16:09:28.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.629]                               info, version)
[16:09:28.629]                           }
[16:09:28.629]                           base::stop(msg)
[16:09:28.629]                         }
[16:09:28.629]                       })
[16:09:28.629]                     }
[16:09:28.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.629]                     base::options(mc.cores = 1L)
[16:09:28.629]                   }
[16:09:28.629]                   options(future.plan = NULL)
[16:09:28.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.629]                 }
[16:09:28.629]                 ...future.workdir <- getwd()
[16:09:28.629]             }
[16:09:28.629]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.629]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.629]         }
[16:09:28.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.629]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.629]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.629]             base::names(...future.oldOptions))
[16:09:28.629]     }
[16:09:28.629]     if (FALSE) {
[16:09:28.629]     }
[16:09:28.629]     else {
[16:09:28.629]         if (TRUE) {
[16:09:28.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.629]                 open = "w")
[16:09:28.629]         }
[16:09:28.629]         else {
[16:09:28.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.629]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.629]         }
[16:09:28.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.629]             base::sink(type = "output", split = FALSE)
[16:09:28.629]             base::close(...future.stdout)
[16:09:28.629]         }, add = TRUE)
[16:09:28.629]     }
[16:09:28.629]     ...future.frame <- base::sys.nframe()
[16:09:28.629]     ...future.conditions <- base::list()
[16:09:28.629]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.629]     if (FALSE) {
[16:09:28.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.629]     }
[16:09:28.629]     ...future.result <- base::tryCatch({
[16:09:28.629]         base::withCallingHandlers({
[16:09:28.629]             ...future.value <- base::withVisible(base::local({
[16:09:28.629]                 withCallingHandlers({
[16:09:28.629]                   {
[16:09:28.629]                     do.call(function(...) {
[16:09:28.629]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.629]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.629]                         ...future.globals.maxSize)) {
[16:09:28.629]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.629]                         on.exit(options(oopts), add = TRUE)
[16:09:28.629]                       }
[16:09:28.629]                       {
[16:09:28.629]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.629]                           FUN = function(jj) {
[16:09:28.629]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.629]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.629]                           })
[16:09:28.629]                       }
[16:09:28.629]                     }, args = future.call.arguments)
[16:09:28.629]                   }
[16:09:28.629]                 }, immediateCondition = function(cond) {
[16:09:28.629]                   save_rds <- function (object, pathname, ...) 
[16:09:28.629]                   {
[16:09:28.629]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.629]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.629]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.629]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.629]                         fi_tmp[["mtime"]])
[16:09:28.629]                     }
[16:09:28.629]                     tryCatch({
[16:09:28.629]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.629]                     }, error = function(ex) {
[16:09:28.629]                       msg <- conditionMessage(ex)
[16:09:28.629]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.629]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.629]                         fi_tmp[["mtime"]], msg)
[16:09:28.629]                       ex$message <- msg
[16:09:28.629]                       stop(ex)
[16:09:28.629]                     })
[16:09:28.629]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.629]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.629]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.629]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.629]                       fi <- file.info(pathname)
[16:09:28.629]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.629]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.629]                         fi[["size"]], fi[["mtime"]])
[16:09:28.629]                       stop(msg)
[16:09:28.629]                     }
[16:09:28.629]                     invisible(pathname)
[16:09:28.629]                   }
[16:09:28.629]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.629]                     rootPath = tempdir()) 
[16:09:28.629]                   {
[16:09:28.629]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.629]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.629]                       tmpdir = path, fileext = ".rds")
[16:09:28.629]                     save_rds(obj, file)
[16:09:28.629]                   }
[16:09:28.629]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.629]                   {
[16:09:28.629]                     inherits <- base::inherits
[16:09:28.629]                     invokeRestart <- base::invokeRestart
[16:09:28.629]                     is.null <- base::is.null
[16:09:28.629]                     muffled <- FALSE
[16:09:28.629]                     if (inherits(cond, "message")) {
[16:09:28.629]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.629]                       if (muffled) 
[16:09:28.629]                         invokeRestart("muffleMessage")
[16:09:28.629]                     }
[16:09:28.629]                     else if (inherits(cond, "warning")) {
[16:09:28.629]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.629]                       if (muffled) 
[16:09:28.629]                         invokeRestart("muffleWarning")
[16:09:28.629]                     }
[16:09:28.629]                     else if (inherits(cond, "condition")) {
[16:09:28.629]                       if (!is.null(pattern)) {
[16:09:28.629]                         computeRestarts <- base::computeRestarts
[16:09:28.629]                         grepl <- base::grepl
[16:09:28.629]                         restarts <- computeRestarts(cond)
[16:09:28.629]                         for (restart in restarts) {
[16:09:28.629]                           name <- restart$name
[16:09:28.629]                           if (is.null(name)) 
[16:09:28.629]                             next
[16:09:28.629]                           if (!grepl(pattern, name)) 
[16:09:28.629]                             next
[16:09:28.629]                           invokeRestart(restart)
[16:09:28.629]                           muffled <- TRUE
[16:09:28.629]                           break
[16:09:28.629]                         }
[16:09:28.629]                       }
[16:09:28.629]                     }
[16:09:28.629]                     invisible(muffled)
[16:09:28.629]                   }
[16:09:28.629]                   muffleCondition(cond)
[16:09:28.629]                 })
[16:09:28.629]             }))
[16:09:28.629]             future::FutureResult(value = ...future.value$value, 
[16:09:28.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.629]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.629]                     ...future.globalenv.names))
[16:09:28.629]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.629]         }, condition = base::local({
[16:09:28.629]             c <- base::c
[16:09:28.629]             inherits <- base::inherits
[16:09:28.629]             invokeRestart <- base::invokeRestart
[16:09:28.629]             length <- base::length
[16:09:28.629]             list <- base::list
[16:09:28.629]             seq.int <- base::seq.int
[16:09:28.629]             signalCondition <- base::signalCondition
[16:09:28.629]             sys.calls <- base::sys.calls
[16:09:28.629]             `[[` <- base::`[[`
[16:09:28.629]             `+` <- base::`+`
[16:09:28.629]             `<<-` <- base::`<<-`
[16:09:28.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.629]                   3L)]
[16:09:28.629]             }
[16:09:28.629]             function(cond) {
[16:09:28.629]                 is_error <- inherits(cond, "error")
[16:09:28.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.629]                   NULL)
[16:09:28.629]                 if (is_error) {
[16:09:28.629]                   sessionInformation <- function() {
[16:09:28.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.629]                       search = base::search(), system = base::Sys.info())
[16:09:28.629]                   }
[16:09:28.629]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.629]                     cond$call), session = sessionInformation(), 
[16:09:28.629]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.629]                   signalCondition(cond)
[16:09:28.629]                 }
[16:09:28.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.629]                 "immediateCondition"))) {
[16:09:28.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.629]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.629]                   if (TRUE && !signal) {
[16:09:28.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.629]                     {
[16:09:28.629]                       inherits <- base::inherits
[16:09:28.629]                       invokeRestart <- base::invokeRestart
[16:09:28.629]                       is.null <- base::is.null
[16:09:28.629]                       muffled <- FALSE
[16:09:28.629]                       if (inherits(cond, "message")) {
[16:09:28.629]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.629]                         if (muffled) 
[16:09:28.629]                           invokeRestart("muffleMessage")
[16:09:28.629]                       }
[16:09:28.629]                       else if (inherits(cond, "warning")) {
[16:09:28.629]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.629]                         if (muffled) 
[16:09:28.629]                           invokeRestart("muffleWarning")
[16:09:28.629]                       }
[16:09:28.629]                       else if (inherits(cond, "condition")) {
[16:09:28.629]                         if (!is.null(pattern)) {
[16:09:28.629]                           computeRestarts <- base::computeRestarts
[16:09:28.629]                           grepl <- base::grepl
[16:09:28.629]                           restarts <- computeRestarts(cond)
[16:09:28.629]                           for (restart in restarts) {
[16:09:28.629]                             name <- restart$name
[16:09:28.629]                             if (is.null(name)) 
[16:09:28.629]                               next
[16:09:28.629]                             if (!grepl(pattern, name)) 
[16:09:28.629]                               next
[16:09:28.629]                             invokeRestart(restart)
[16:09:28.629]                             muffled <- TRUE
[16:09:28.629]                             break
[16:09:28.629]                           }
[16:09:28.629]                         }
[16:09:28.629]                       }
[16:09:28.629]                       invisible(muffled)
[16:09:28.629]                     }
[16:09:28.629]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.629]                   }
[16:09:28.629]                 }
[16:09:28.629]                 else {
[16:09:28.629]                   if (TRUE) {
[16:09:28.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.629]                     {
[16:09:28.629]                       inherits <- base::inherits
[16:09:28.629]                       invokeRestart <- base::invokeRestart
[16:09:28.629]                       is.null <- base::is.null
[16:09:28.629]                       muffled <- FALSE
[16:09:28.629]                       if (inherits(cond, "message")) {
[16:09:28.629]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.629]                         if (muffled) 
[16:09:28.629]                           invokeRestart("muffleMessage")
[16:09:28.629]                       }
[16:09:28.629]                       else if (inherits(cond, "warning")) {
[16:09:28.629]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.629]                         if (muffled) 
[16:09:28.629]                           invokeRestart("muffleWarning")
[16:09:28.629]                       }
[16:09:28.629]                       else if (inherits(cond, "condition")) {
[16:09:28.629]                         if (!is.null(pattern)) {
[16:09:28.629]                           computeRestarts <- base::computeRestarts
[16:09:28.629]                           grepl <- base::grepl
[16:09:28.629]                           restarts <- computeRestarts(cond)
[16:09:28.629]                           for (restart in restarts) {
[16:09:28.629]                             name <- restart$name
[16:09:28.629]                             if (is.null(name)) 
[16:09:28.629]                               next
[16:09:28.629]                             if (!grepl(pattern, name)) 
[16:09:28.629]                               next
[16:09:28.629]                             invokeRestart(restart)
[16:09:28.629]                             muffled <- TRUE
[16:09:28.629]                             break
[16:09:28.629]                           }
[16:09:28.629]                         }
[16:09:28.629]                       }
[16:09:28.629]                       invisible(muffled)
[16:09:28.629]                     }
[16:09:28.629]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.629]                   }
[16:09:28.629]                 }
[16:09:28.629]             }
[16:09:28.629]         }))
[16:09:28.629]     }, error = function(ex) {
[16:09:28.629]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.629]                 ...future.rng), started = ...future.startTime, 
[16:09:28.629]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.629]             version = "1.8"), class = "FutureResult")
[16:09:28.629]     }, finally = {
[16:09:28.629]         if (!identical(...future.workdir, getwd())) 
[16:09:28.629]             setwd(...future.workdir)
[16:09:28.629]         {
[16:09:28.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.629]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.629]             }
[16:09:28.629]             base::options(...future.oldOptions)
[16:09:28.629]             if (.Platform$OS.type == "windows") {
[16:09:28.629]                 old_names <- names(...future.oldEnvVars)
[16:09:28.629]                 envs <- base::Sys.getenv()
[16:09:28.629]                 names <- names(envs)
[16:09:28.629]                 common <- intersect(names, old_names)
[16:09:28.629]                 added <- setdiff(names, old_names)
[16:09:28.629]                 removed <- setdiff(old_names, names)
[16:09:28.629]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.629]                   envs[common]]
[16:09:28.629]                 NAMES <- toupper(changed)
[16:09:28.629]                 args <- list()
[16:09:28.629]                 for (kk in seq_along(NAMES)) {
[16:09:28.629]                   name <- changed[[kk]]
[16:09:28.629]                   NAME <- NAMES[[kk]]
[16:09:28.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.629]                     next
[16:09:28.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.629]                 }
[16:09:28.629]                 NAMES <- toupper(added)
[16:09:28.629]                 for (kk in seq_along(NAMES)) {
[16:09:28.629]                   name <- added[[kk]]
[16:09:28.629]                   NAME <- NAMES[[kk]]
[16:09:28.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.629]                     next
[16:09:28.629]                   args[[name]] <- ""
[16:09:28.629]                 }
[16:09:28.629]                 NAMES <- toupper(removed)
[16:09:28.629]                 for (kk in seq_along(NAMES)) {
[16:09:28.629]                   name <- removed[[kk]]
[16:09:28.629]                   NAME <- NAMES[[kk]]
[16:09:28.629]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.629]                     next
[16:09:28.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.629]                 }
[16:09:28.629]                 if (length(args) > 0) 
[16:09:28.629]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.629]             }
[16:09:28.629]             else {
[16:09:28.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.629]             }
[16:09:28.629]             {
[16:09:28.629]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.629]                   0L) {
[16:09:28.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.629]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.629]                   base::options(opts)
[16:09:28.629]                 }
[16:09:28.629]                 {
[16:09:28.629]                   {
[16:09:28.629]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.629]                     NULL
[16:09:28.629]                   }
[16:09:28.629]                   options(future.plan = NULL)
[16:09:28.629]                   if (is.na(NA_character_)) 
[16:09:28.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.629]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.629]                     envir = parent.frame()) 
[16:09:28.629]                   {
[16:09:28.629]                     default_workers <- missing(workers)
[16:09:28.629]                     if (is.function(workers)) 
[16:09:28.629]                       workers <- workers()
[16:09:28.629]                     workers <- structure(as.integer(workers), 
[16:09:28.629]                       class = class(workers))
[16:09:28.629]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.629]                       1L)
[16:09:28.629]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.629]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.629]                       if (default_workers) 
[16:09:28.629]                         supportsMulticore(warn = TRUE)
[16:09:28.629]                       return(sequential(..., envir = envir))
[16:09:28.629]                     }
[16:09:28.629]                     oopts <- options(mc.cores = workers)
[16:09:28.629]                     on.exit(options(oopts))
[16:09:28.629]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.629]                       envir = envir)
[16:09:28.629]                     if (!future$lazy) 
[16:09:28.629]                       future <- run(future)
[16:09:28.629]                     invisible(future)
[16:09:28.629]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.629]                 }
[16:09:28.629]             }
[16:09:28.629]         }
[16:09:28.629]     })
[16:09:28.629]     if (TRUE) {
[16:09:28.629]         base::sink(type = "output", split = FALSE)
[16:09:28.629]         if (TRUE) {
[16:09:28.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.629]         }
[16:09:28.629]         else {
[16:09:28.629]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.629]         }
[16:09:28.629]         base::close(...future.stdout)
[16:09:28.629]         ...future.stdout <- NULL
[16:09:28.629]     }
[16:09:28.629]     ...future.result$conditions <- ...future.conditions
[16:09:28.629]     ...future.result$finished <- base::Sys.time()
[16:09:28.629]     ...future.result
[16:09:28.629] }
[16:09:28.632] assign_globals() ...
[16:09:28.632] List of 5
[16:09:28.632]  $ future.call.arguments    : list()
[16:09:28.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.632]  $ ...future.FUN            :function (x)  
[16:09:28.632]  $ ...future.elements_ii    :List of 1
[16:09:28.632]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:09:28.632]  $ ...future.seeds_ii       : NULL
[16:09:28.632]  $ ...future.globals.maxSize: NULL
[16:09:28.632]  - attr(*, "where")=List of 5
[16:09:28.632]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.632]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.632]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.632]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.632]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.632]  - attr(*, "resolved")= logi FALSE
[16:09:28.632]  - attr(*, "total_size")= num NA
[16:09:28.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.632]  - attr(*, "already-done")= logi TRUE
[16:09:28.637] - copied ‘future.call.arguments’ to environment
[16:09:28.637] - copied ‘...future.FUN’ to environment
[16:09:28.637] - copied ‘...future.elements_ii’ to environment
[16:09:28.637] - copied ‘...future.seeds_ii’ to environment
[16:09:28.637] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.638] assign_globals() ... done
[16:09:28.638] requestCore(): workers = 2
[16:09:28.640] MulticoreFuture started
[16:09:28.641] - Launch lazy future ... done
[16:09:28.641] run() for ‘MulticoreFuture’ ... done
[16:09:28.642] Created future:
[16:09:28.642] plan(): Setting new future strategy stack:
[16:09:28.642] List of future strategies:
[16:09:28.642] 1. sequential:
[16:09:28.642]    - args: function (..., envir = parent.frame())
[16:09:28.642]    - tweaked: FALSE
[16:09:28.642]    - call: NULL
[16:09:28.643] plan(): nbrOfWorkers() = 1
[16:09:28.645] plan(): Setting new future strategy stack:
[16:09:28.645] List of future strategies:
[16:09:28.645] 1. multicore:
[16:09:28.645]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.645]    - tweaked: FALSE
[16:09:28.645]    - call: plan(strategy)
[16:09:28.651] plan(): nbrOfWorkers() = 2
[16:09:28.642] MulticoreFuture:
[16:09:28.642] Label: ‘future_apply-1’
[16:09:28.642] Expression:
[16:09:28.642] {
[16:09:28.642]     do.call(function(...) {
[16:09:28.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.642]             on.exit(options(oopts), add = TRUE)
[16:09:28.642]         }
[16:09:28.642]         {
[16:09:28.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.642]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.642]             })
[16:09:28.642]         }
[16:09:28.642]     }, args = future.call.arguments)
[16:09:28.642] }
[16:09:28.642] Lazy evaluation: FALSE
[16:09:28.642] Asynchronous evaluation: TRUE
[16:09:28.642] Local evaluation: TRUE
[16:09:28.642] Environment: R_GlobalEnv
[16:09:28.642] Capture standard output: TRUE
[16:09:28.642] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.642] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.642] Packages: <none>
[16:09:28.642] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.642] Resolved: TRUE
[16:09:28.642] Value: <not collected>
[16:09:28.642] Conditions captured: <none>
[16:09:28.642] Early signaling: FALSE
[16:09:28.642] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.642] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.652] Chunk #1 of 2 ... DONE
[16:09:28.652] Chunk #2 of 2 ...
[16:09:28.652]  - seeds: <none>
[16:09:28.652] getGlobalsAndPackages() ...
[16:09:28.653] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.653] Resolving globals: FALSE
[16:09:28.653] Tweak future expression to call with '...' arguments ...
[16:09:28.653] {
[16:09:28.653]     do.call(function(...) {
[16:09:28.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.653]             on.exit(options(oopts), add = TRUE)
[16:09:28.653]         }
[16:09:28.653]         {
[16:09:28.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.653]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.653]             })
[16:09:28.653]         }
[16:09:28.653]     }, args = future.call.arguments)
[16:09:28.653] }
[16:09:28.654] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.654] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.654] 
[16:09:28.655] getGlobalsAndPackages() ... DONE
[16:09:28.655] run() for ‘Future’ ...
[16:09:28.655] - state: ‘created’
[16:09:28.655] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.660] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.661]   - Field: ‘label’
[16:09:28.661]   - Field: ‘local’
[16:09:28.661]   - Field: ‘owner’
[16:09:28.661]   - Field: ‘envir’
[16:09:28.661]   - Field: ‘workers’
[16:09:28.661]   - Field: ‘packages’
[16:09:28.661]   - Field: ‘gc’
[16:09:28.662]   - Field: ‘job’
[16:09:28.662]   - Field: ‘conditions’
[16:09:28.662]   - Field: ‘expr’
[16:09:28.662]   - Field: ‘uuid’
[16:09:28.665]   - Field: ‘seed’
[16:09:28.665]   - Field: ‘version’
[16:09:28.666]   - Field: ‘result’
[16:09:28.666]   - Field: ‘asynchronous’
[16:09:28.667]   - Field: ‘calls’
[16:09:28.667]   - Field: ‘globals’
[16:09:28.667]   - Field: ‘stdout’
[16:09:28.668]   - Field: ‘earlySignal’
[16:09:28.668]   - Field: ‘lazy’
[16:09:28.668]   - Field: ‘state’
[16:09:28.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.669] - Launch lazy future ...
[16:09:28.669] Packages needed by the future expression (n = 0): <none>
[16:09:28.670] Packages needed by future strategies (n = 0): <none>
[16:09:28.671] {
[16:09:28.671]     {
[16:09:28.671]         {
[16:09:28.671]             ...future.startTime <- base::Sys.time()
[16:09:28.671]             {
[16:09:28.671]                 {
[16:09:28.671]                   {
[16:09:28.671]                     {
[16:09:28.671]                       base::local({
[16:09:28.671]                         has_future <- base::requireNamespace("future", 
[16:09:28.671]                           quietly = TRUE)
[16:09:28.671]                         if (has_future) {
[16:09:28.671]                           ns <- base::getNamespace("future")
[16:09:28.671]                           version <- ns[[".package"]][["version"]]
[16:09:28.671]                           if (is.null(version)) 
[16:09:28.671]                             version <- utils::packageVersion("future")
[16:09:28.671]                         }
[16:09:28.671]                         else {
[16:09:28.671]                           version <- NULL
[16:09:28.671]                         }
[16:09:28.671]                         if (!has_future || version < "1.8.0") {
[16:09:28.671]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.671]                             "", base::R.version$version.string), 
[16:09:28.671]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.671]                               "release", "version")], collapse = " "), 
[16:09:28.671]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.671]                             info)
[16:09:28.671]                           info <- base::paste(info, collapse = "; ")
[16:09:28.671]                           if (!has_future) {
[16:09:28.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.671]                               info)
[16:09:28.671]                           }
[16:09:28.671]                           else {
[16:09:28.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.671]                               info, version)
[16:09:28.671]                           }
[16:09:28.671]                           base::stop(msg)
[16:09:28.671]                         }
[16:09:28.671]                       })
[16:09:28.671]                     }
[16:09:28.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.671]                     base::options(mc.cores = 1L)
[16:09:28.671]                   }
[16:09:28.671]                   options(future.plan = NULL)
[16:09:28.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.671]                 }
[16:09:28.671]                 ...future.workdir <- getwd()
[16:09:28.671]             }
[16:09:28.671]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.671]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.671]         }
[16:09:28.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.671]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.671]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.671]             base::names(...future.oldOptions))
[16:09:28.671]     }
[16:09:28.671]     if (FALSE) {
[16:09:28.671]     }
[16:09:28.671]     else {
[16:09:28.671]         if (TRUE) {
[16:09:28.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.671]                 open = "w")
[16:09:28.671]         }
[16:09:28.671]         else {
[16:09:28.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.671]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.671]         }
[16:09:28.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.671]             base::sink(type = "output", split = FALSE)
[16:09:28.671]             base::close(...future.stdout)
[16:09:28.671]         }, add = TRUE)
[16:09:28.671]     }
[16:09:28.671]     ...future.frame <- base::sys.nframe()
[16:09:28.671]     ...future.conditions <- base::list()
[16:09:28.671]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.671]     if (FALSE) {
[16:09:28.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.671]     }
[16:09:28.671]     ...future.result <- base::tryCatch({
[16:09:28.671]         base::withCallingHandlers({
[16:09:28.671]             ...future.value <- base::withVisible(base::local({
[16:09:28.671]                 withCallingHandlers({
[16:09:28.671]                   {
[16:09:28.671]                     do.call(function(...) {
[16:09:28.671]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.671]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.671]                         ...future.globals.maxSize)) {
[16:09:28.671]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.671]                         on.exit(options(oopts), add = TRUE)
[16:09:28.671]                       }
[16:09:28.671]                       {
[16:09:28.671]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.671]                           FUN = function(jj) {
[16:09:28.671]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.671]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.671]                           })
[16:09:28.671]                       }
[16:09:28.671]                     }, args = future.call.arguments)
[16:09:28.671]                   }
[16:09:28.671]                 }, immediateCondition = function(cond) {
[16:09:28.671]                   save_rds <- function (object, pathname, ...) 
[16:09:28.671]                   {
[16:09:28.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.671]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.671]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.671]                         fi_tmp[["mtime"]])
[16:09:28.671]                     }
[16:09:28.671]                     tryCatch({
[16:09:28.671]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.671]                     }, error = function(ex) {
[16:09:28.671]                       msg <- conditionMessage(ex)
[16:09:28.671]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.671]                         fi_tmp[["mtime"]], msg)
[16:09:28.671]                       ex$message <- msg
[16:09:28.671]                       stop(ex)
[16:09:28.671]                     })
[16:09:28.671]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.671]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.671]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.671]                       fi <- file.info(pathname)
[16:09:28.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.671]                         fi[["size"]], fi[["mtime"]])
[16:09:28.671]                       stop(msg)
[16:09:28.671]                     }
[16:09:28.671]                     invisible(pathname)
[16:09:28.671]                   }
[16:09:28.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.671]                     rootPath = tempdir()) 
[16:09:28.671]                   {
[16:09:28.671]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.671]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.671]                       tmpdir = path, fileext = ".rds")
[16:09:28.671]                     save_rds(obj, file)
[16:09:28.671]                   }
[16:09:28.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.671]                   {
[16:09:28.671]                     inherits <- base::inherits
[16:09:28.671]                     invokeRestart <- base::invokeRestart
[16:09:28.671]                     is.null <- base::is.null
[16:09:28.671]                     muffled <- FALSE
[16:09:28.671]                     if (inherits(cond, "message")) {
[16:09:28.671]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.671]                       if (muffled) 
[16:09:28.671]                         invokeRestart("muffleMessage")
[16:09:28.671]                     }
[16:09:28.671]                     else if (inherits(cond, "warning")) {
[16:09:28.671]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.671]                       if (muffled) 
[16:09:28.671]                         invokeRestart("muffleWarning")
[16:09:28.671]                     }
[16:09:28.671]                     else if (inherits(cond, "condition")) {
[16:09:28.671]                       if (!is.null(pattern)) {
[16:09:28.671]                         computeRestarts <- base::computeRestarts
[16:09:28.671]                         grepl <- base::grepl
[16:09:28.671]                         restarts <- computeRestarts(cond)
[16:09:28.671]                         for (restart in restarts) {
[16:09:28.671]                           name <- restart$name
[16:09:28.671]                           if (is.null(name)) 
[16:09:28.671]                             next
[16:09:28.671]                           if (!grepl(pattern, name)) 
[16:09:28.671]                             next
[16:09:28.671]                           invokeRestart(restart)
[16:09:28.671]                           muffled <- TRUE
[16:09:28.671]                           break
[16:09:28.671]                         }
[16:09:28.671]                       }
[16:09:28.671]                     }
[16:09:28.671]                     invisible(muffled)
[16:09:28.671]                   }
[16:09:28.671]                   muffleCondition(cond)
[16:09:28.671]                 })
[16:09:28.671]             }))
[16:09:28.671]             future::FutureResult(value = ...future.value$value, 
[16:09:28.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.671]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.671]                     ...future.globalenv.names))
[16:09:28.671]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.671]         }, condition = base::local({
[16:09:28.671]             c <- base::c
[16:09:28.671]             inherits <- base::inherits
[16:09:28.671]             invokeRestart <- base::invokeRestart
[16:09:28.671]             length <- base::length
[16:09:28.671]             list <- base::list
[16:09:28.671]             seq.int <- base::seq.int
[16:09:28.671]             signalCondition <- base::signalCondition
[16:09:28.671]             sys.calls <- base::sys.calls
[16:09:28.671]             `[[` <- base::`[[`
[16:09:28.671]             `+` <- base::`+`
[16:09:28.671]             `<<-` <- base::`<<-`
[16:09:28.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.671]                   3L)]
[16:09:28.671]             }
[16:09:28.671]             function(cond) {
[16:09:28.671]                 is_error <- inherits(cond, "error")
[16:09:28.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.671]                   NULL)
[16:09:28.671]                 if (is_error) {
[16:09:28.671]                   sessionInformation <- function() {
[16:09:28.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.671]                       search = base::search(), system = base::Sys.info())
[16:09:28.671]                   }
[16:09:28.671]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.671]                     cond$call), session = sessionInformation(), 
[16:09:28.671]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.671]                   signalCondition(cond)
[16:09:28.671]                 }
[16:09:28.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.671]                 "immediateCondition"))) {
[16:09:28.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.671]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.671]                   if (TRUE && !signal) {
[16:09:28.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.671]                     {
[16:09:28.671]                       inherits <- base::inherits
[16:09:28.671]                       invokeRestart <- base::invokeRestart
[16:09:28.671]                       is.null <- base::is.null
[16:09:28.671]                       muffled <- FALSE
[16:09:28.671]                       if (inherits(cond, "message")) {
[16:09:28.671]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.671]                         if (muffled) 
[16:09:28.671]                           invokeRestart("muffleMessage")
[16:09:28.671]                       }
[16:09:28.671]                       else if (inherits(cond, "warning")) {
[16:09:28.671]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.671]                         if (muffled) 
[16:09:28.671]                           invokeRestart("muffleWarning")
[16:09:28.671]                       }
[16:09:28.671]                       else if (inherits(cond, "condition")) {
[16:09:28.671]                         if (!is.null(pattern)) {
[16:09:28.671]                           computeRestarts <- base::computeRestarts
[16:09:28.671]                           grepl <- base::grepl
[16:09:28.671]                           restarts <- computeRestarts(cond)
[16:09:28.671]                           for (restart in restarts) {
[16:09:28.671]                             name <- restart$name
[16:09:28.671]                             if (is.null(name)) 
[16:09:28.671]                               next
[16:09:28.671]                             if (!grepl(pattern, name)) 
[16:09:28.671]                               next
[16:09:28.671]                             invokeRestart(restart)
[16:09:28.671]                             muffled <- TRUE
[16:09:28.671]                             break
[16:09:28.671]                           }
[16:09:28.671]                         }
[16:09:28.671]                       }
[16:09:28.671]                       invisible(muffled)
[16:09:28.671]                     }
[16:09:28.671]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.671]                   }
[16:09:28.671]                 }
[16:09:28.671]                 else {
[16:09:28.671]                   if (TRUE) {
[16:09:28.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.671]                     {
[16:09:28.671]                       inherits <- base::inherits
[16:09:28.671]                       invokeRestart <- base::invokeRestart
[16:09:28.671]                       is.null <- base::is.null
[16:09:28.671]                       muffled <- FALSE
[16:09:28.671]                       if (inherits(cond, "message")) {
[16:09:28.671]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.671]                         if (muffled) 
[16:09:28.671]                           invokeRestart("muffleMessage")
[16:09:28.671]                       }
[16:09:28.671]                       else if (inherits(cond, "warning")) {
[16:09:28.671]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.671]                         if (muffled) 
[16:09:28.671]                           invokeRestart("muffleWarning")
[16:09:28.671]                       }
[16:09:28.671]                       else if (inherits(cond, "condition")) {
[16:09:28.671]                         if (!is.null(pattern)) {
[16:09:28.671]                           computeRestarts <- base::computeRestarts
[16:09:28.671]                           grepl <- base::grepl
[16:09:28.671]                           restarts <- computeRestarts(cond)
[16:09:28.671]                           for (restart in restarts) {
[16:09:28.671]                             name <- restart$name
[16:09:28.671]                             if (is.null(name)) 
[16:09:28.671]                               next
[16:09:28.671]                             if (!grepl(pattern, name)) 
[16:09:28.671]                               next
[16:09:28.671]                             invokeRestart(restart)
[16:09:28.671]                             muffled <- TRUE
[16:09:28.671]                             break
[16:09:28.671]                           }
[16:09:28.671]                         }
[16:09:28.671]                       }
[16:09:28.671]                       invisible(muffled)
[16:09:28.671]                     }
[16:09:28.671]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.671]                   }
[16:09:28.671]                 }
[16:09:28.671]             }
[16:09:28.671]         }))
[16:09:28.671]     }, error = function(ex) {
[16:09:28.671]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.671]                 ...future.rng), started = ...future.startTime, 
[16:09:28.671]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.671]             version = "1.8"), class = "FutureResult")
[16:09:28.671]     }, finally = {
[16:09:28.671]         if (!identical(...future.workdir, getwd())) 
[16:09:28.671]             setwd(...future.workdir)
[16:09:28.671]         {
[16:09:28.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.671]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.671]             }
[16:09:28.671]             base::options(...future.oldOptions)
[16:09:28.671]             if (.Platform$OS.type == "windows") {
[16:09:28.671]                 old_names <- names(...future.oldEnvVars)
[16:09:28.671]                 envs <- base::Sys.getenv()
[16:09:28.671]                 names <- names(envs)
[16:09:28.671]                 common <- intersect(names, old_names)
[16:09:28.671]                 added <- setdiff(names, old_names)
[16:09:28.671]                 removed <- setdiff(old_names, names)
[16:09:28.671]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.671]                   envs[common]]
[16:09:28.671]                 NAMES <- toupper(changed)
[16:09:28.671]                 args <- list()
[16:09:28.671]                 for (kk in seq_along(NAMES)) {
[16:09:28.671]                   name <- changed[[kk]]
[16:09:28.671]                   NAME <- NAMES[[kk]]
[16:09:28.671]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.671]                     next
[16:09:28.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.671]                 }
[16:09:28.671]                 NAMES <- toupper(added)
[16:09:28.671]                 for (kk in seq_along(NAMES)) {
[16:09:28.671]                   name <- added[[kk]]
[16:09:28.671]                   NAME <- NAMES[[kk]]
[16:09:28.671]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.671]                     next
[16:09:28.671]                   args[[name]] <- ""
[16:09:28.671]                 }
[16:09:28.671]                 NAMES <- toupper(removed)
[16:09:28.671]                 for (kk in seq_along(NAMES)) {
[16:09:28.671]                   name <- removed[[kk]]
[16:09:28.671]                   NAME <- NAMES[[kk]]
[16:09:28.671]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.671]                     next
[16:09:28.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.671]                 }
[16:09:28.671]                 if (length(args) > 0) 
[16:09:28.671]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.671]             }
[16:09:28.671]             else {
[16:09:28.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.671]             }
[16:09:28.671]             {
[16:09:28.671]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.671]                   0L) {
[16:09:28.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.671]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.671]                   base::options(opts)
[16:09:28.671]                 }
[16:09:28.671]                 {
[16:09:28.671]                   {
[16:09:28.671]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.671]                     NULL
[16:09:28.671]                   }
[16:09:28.671]                   options(future.plan = NULL)
[16:09:28.671]                   if (is.na(NA_character_)) 
[16:09:28.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.671]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.671]                     envir = parent.frame()) 
[16:09:28.671]                   {
[16:09:28.671]                     default_workers <- missing(workers)
[16:09:28.671]                     if (is.function(workers)) 
[16:09:28.671]                       workers <- workers()
[16:09:28.671]                     workers <- structure(as.integer(workers), 
[16:09:28.671]                       class = class(workers))
[16:09:28.671]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.671]                       1L)
[16:09:28.671]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.671]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.671]                       if (default_workers) 
[16:09:28.671]                         supportsMulticore(warn = TRUE)
[16:09:28.671]                       return(sequential(..., envir = envir))
[16:09:28.671]                     }
[16:09:28.671]                     oopts <- options(mc.cores = workers)
[16:09:28.671]                     on.exit(options(oopts))
[16:09:28.671]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.671]                       envir = envir)
[16:09:28.671]                     if (!future$lazy) 
[16:09:28.671]                       future <- run(future)
[16:09:28.671]                     invisible(future)
[16:09:28.671]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.671]                 }
[16:09:28.671]             }
[16:09:28.671]         }
[16:09:28.671]     })
[16:09:28.671]     if (TRUE) {
[16:09:28.671]         base::sink(type = "output", split = FALSE)
[16:09:28.671]         if (TRUE) {
[16:09:28.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.671]         }
[16:09:28.671]         else {
[16:09:28.671]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.671]         }
[16:09:28.671]         base::close(...future.stdout)
[16:09:28.671]         ...future.stdout <- NULL
[16:09:28.671]     }
[16:09:28.671]     ...future.result$conditions <- ...future.conditions
[16:09:28.671]     ...future.result$finished <- base::Sys.time()
[16:09:28.671]     ...future.result
[16:09:28.671] }
[16:09:28.674] assign_globals() ...
[16:09:28.674] List of 5
[16:09:28.674]  $ future.call.arguments    : list()
[16:09:28.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.674]  $ ...future.FUN            :function (x)  
[16:09:28.674]  $ ...future.elements_ii    :List of 1
[16:09:28.674]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:09:28.674]  $ ...future.seeds_ii       : NULL
[16:09:28.674]  $ ...future.globals.maxSize: NULL
[16:09:28.674]  - attr(*, "where")=List of 5
[16:09:28.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.674]  - attr(*, "resolved")= logi FALSE
[16:09:28.674]  - attr(*, "total_size")= num NA
[16:09:28.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.674]  - attr(*, "already-done")= logi TRUE
[16:09:28.682] - copied ‘future.call.arguments’ to environment
[16:09:28.682] - copied ‘...future.FUN’ to environment
[16:09:28.683] - copied ‘...future.elements_ii’ to environment
[16:09:28.683] - copied ‘...future.seeds_ii’ to environment
[16:09:28.683] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.683] assign_globals() ... done
[16:09:28.683] requestCore(): workers = 2
[16:09:28.686] MulticoreFuture started
[16:09:28.686] - Launch lazy future ... done
[16:09:28.686] run() for ‘MulticoreFuture’ ... done
[16:09:28.686] Created future:
[16:09:28.687] plan(): Setting new future strategy stack:
[16:09:28.687] List of future strategies:
[16:09:28.687] 1. sequential:
[16:09:28.687]    - args: function (..., envir = parent.frame())
[16:09:28.687]    - tweaked: FALSE
[16:09:28.687]    - call: NULL
[16:09:28.688] plan(): nbrOfWorkers() = 1
[16:09:28.690] plan(): Setting new future strategy stack:
[16:09:28.690] List of future strategies:
[16:09:28.690] 1. multicore:
[16:09:28.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.690]    - tweaked: FALSE
[16:09:28.690]    - call: plan(strategy)
[16:09:28.695] plan(): nbrOfWorkers() = 2
[16:09:28.687] MulticoreFuture:
[16:09:28.687] Label: ‘future_apply-2’
[16:09:28.687] Expression:
[16:09:28.687] {
[16:09:28.687]     do.call(function(...) {
[16:09:28.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.687]             on.exit(options(oopts), add = TRUE)
[16:09:28.687]         }
[16:09:28.687]         {
[16:09:28.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.687]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.687]             })
[16:09:28.687]         }
[16:09:28.687]     }, args = future.call.arguments)
[16:09:28.687] }
[16:09:28.687] Lazy evaluation: FALSE
[16:09:28.687] Asynchronous evaluation: TRUE
[16:09:28.687] Local evaluation: TRUE
[16:09:28.687] Environment: R_GlobalEnv
[16:09:28.687] Capture standard output: TRUE
[16:09:28.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.687] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.687] Packages: <none>
[16:09:28.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.687] Resolved: TRUE
[16:09:28.687] Value: <not collected>
[16:09:28.687] Conditions captured: <none>
[16:09:28.687] Early signaling: FALSE
[16:09:28.687] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.687] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.697] Chunk #2 of 2 ... DONE
[16:09:28.697] Launching 2 futures (chunks) ... DONE
[16:09:28.697] Resolving 2 futures (chunks) ...
[16:09:28.697] resolve() on list ...
[16:09:28.697]  recursive: 0
[16:09:28.697]  length: 2
[16:09:28.698] 
[16:09:28.698] Future #1
[16:09:28.699] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.699] - nx: 2
[16:09:28.699] - relay: TRUE
[16:09:28.699] - stdout: TRUE
[16:09:28.700] - signal: TRUE
[16:09:28.700] - resignal: FALSE
[16:09:28.700] - force: TRUE
[16:09:28.700] - relayed: [n=2] FALSE, FALSE
[16:09:28.700] - queued futures: [n=2] FALSE, FALSE
[16:09:28.700]  - until=1
[16:09:28.700]  - relaying element #1
[16:09:28.701] - relayed: [n=2] TRUE, FALSE
[16:09:28.701] - queued futures: [n=2] TRUE, FALSE
[16:09:28.701] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.701]  length: 1 (resolved future 1)
[16:09:28.702] Future #2
[16:09:28.702] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.703] - nx: 2
[16:09:28.703] - relay: TRUE
[16:09:28.703] - stdout: TRUE
[16:09:28.703] - signal: TRUE
[16:09:28.703] - resignal: FALSE
[16:09:28.703] - force: TRUE
[16:09:28.703] - relayed: [n=2] TRUE, FALSE
[16:09:28.703] - queued futures: [n=2] TRUE, FALSE
[16:09:28.704]  - until=2
[16:09:28.704]  - relaying element #2
[16:09:28.704] - relayed: [n=2] TRUE, TRUE
[16:09:28.704] - queued futures: [n=2] TRUE, TRUE
[16:09:28.704] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.704]  length: 0 (resolved future 2)
[16:09:28.705] Relaying remaining futures
[16:09:28.705] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.705] - nx: 2
[16:09:28.705] - relay: TRUE
[16:09:28.705] - stdout: TRUE
[16:09:28.705] - signal: TRUE
[16:09:28.705] - resignal: FALSE
[16:09:28.705] - force: TRUE
[16:09:28.705] - relayed: [n=2] TRUE, TRUE
[16:09:28.705] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.706] - relayed: [n=2] TRUE, TRUE
[16:09:28.706] - queued futures: [n=2] TRUE, TRUE
[16:09:28.706] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.706] resolve() on list ... DONE
[16:09:28.706]  - Number of value chunks collected: 2
[16:09:28.706] Resolving 2 futures (chunks) ... DONE
[16:09:28.706] Reducing values from 2 chunks ...
[16:09:28.707]  - Number of values collected after concatenation: 2
[16:09:28.707]  - Number of values expected: 2
[16:09:28.707] Reducing values from 2 chunks ... DONE
[16:09:28.707] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:09:28.707] getGlobalsAndPackagesXApply() ...
[16:09:28.708]  - future.globals: TRUE
[16:09:28.708] getGlobalsAndPackages() ...
[16:09:28.708] Searching for globals...
[16:09:28.714] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:09:28.714] Searching for globals ... DONE
[16:09:28.715] Resolving globals: FALSE
[16:09:28.715] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:09:28.716] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:09:28.716] - globals: [1] ‘FUN’
[16:09:28.716] 
[16:09:28.716] getGlobalsAndPackages() ... DONE
[16:09:28.717]  - globals found/used: [n=1] ‘FUN’
[16:09:28.717]  - needed namespaces: [n=0] 
[16:09:28.717] Finding globals ... DONE
[16:09:28.717]  - use_args: TRUE
[16:09:28.717]  - Getting '...' globals ...
[16:09:28.717] resolve() on list ...
[16:09:28.718]  recursive: 0
[16:09:28.718]  length: 1
[16:09:28.718]  elements: ‘...’
[16:09:28.718]  length: 0 (resolved future 1)
[16:09:28.718] resolve() on list ... DONE
[16:09:28.718]    - '...' content: [n=0] 
[16:09:28.718] List of 1
[16:09:28.718]  $ ...: list()
[16:09:28.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.718]  - attr(*, "where")=List of 1
[16:09:28.718]   ..$ ...:<environment: 0x5633ac4dc9b8> 
[16:09:28.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.718]  - attr(*, "resolved")= logi TRUE
[16:09:28.718]  - attr(*, "total_size")= num NA
[16:09:28.722]  - Getting '...' globals ... DONE
[16:09:28.722] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.722] List of 2
[16:09:28.722]  $ ...future.FUN:function (x)  
[16:09:28.722]  $ ...          : list()
[16:09:28.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.722]  - attr(*, "where")=List of 2
[16:09:28.722]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.722]   ..$ ...          :<environment: 0x5633ac4dc9b8> 
[16:09:28.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.722]  - attr(*, "resolved")= logi FALSE
[16:09:28.722]  - attr(*, "total_size")= num 9888
[16:09:28.725] Packages to be attached in all futures: [n=0] 
[16:09:28.725] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.729] future_lapply() ...
[16:09:28.734] Number of chunks: 2
[16:09:28.734] getGlobalsAndPackagesXApply() ...
[16:09:28.735]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.735]  - use_args: TRUE
[16:09:28.735] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.735] List of 2
[16:09:28.735]  $ ...          : list()
[16:09:28.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.735]  $ ...future.FUN:function (x)  
[16:09:28.735]  - attr(*, "where")=List of 2
[16:09:28.735]   ..$ ...          :<environment: 0x5633ac4dc9b8> 
[16:09:28.735]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:09:28.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.735]  - attr(*, "resolved")= logi FALSE
[16:09:28.735]  - attr(*, "total_size")= num NA
[16:09:28.738] Packages to be attached in all futures: [n=0] 
[16:09:28.738] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.738] Number of futures (= number of chunks): 2
[16:09:28.738] Launching 2 futures (chunks) ...
[16:09:28.738] Chunk #1 of 2 ...
[16:09:28.740]  - seeds: <none>
[16:09:28.740] getGlobalsAndPackages() ...
[16:09:28.741] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.741] Resolving globals: FALSE
[16:09:28.741] Tweak future expression to call with '...' arguments ...
[16:09:28.741] {
[16:09:28.741]     do.call(function(...) {
[16:09:28.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.741]             on.exit(options(oopts), add = TRUE)
[16:09:28.741]         }
[16:09:28.741]         {
[16:09:28.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.741]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.741]             })
[16:09:28.741]         }
[16:09:28.741]     }, args = future.call.arguments)
[16:09:28.741] }
[16:09:28.741] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.742] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.742] 
[16:09:28.742] getGlobalsAndPackages() ... DONE
[16:09:28.742] run() for ‘Future’ ...
[16:09:28.742] - state: ‘created’
[16:09:28.743] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.747]   - Field: ‘label’
[16:09:28.747]   - Field: ‘local’
[16:09:28.747]   - Field: ‘owner’
[16:09:28.747]   - Field: ‘envir’
[16:09:28.747]   - Field: ‘workers’
[16:09:28.747]   - Field: ‘packages’
[16:09:28.747]   - Field: ‘gc’
[16:09:28.747]   - Field: ‘job’
[16:09:28.747]   - Field: ‘conditions’
[16:09:28.747]   - Field: ‘expr’
[16:09:28.748]   - Field: ‘uuid’
[16:09:28.748]   - Field: ‘seed’
[16:09:28.748]   - Field: ‘version’
[16:09:28.748]   - Field: ‘result’
[16:09:28.748]   - Field: ‘asynchronous’
[16:09:28.748]   - Field: ‘calls’
[16:09:28.748]   - Field: ‘globals’
[16:09:28.748]   - Field: ‘stdout’
[16:09:28.748]   - Field: ‘earlySignal’
[16:09:28.748]   - Field: ‘lazy’
[16:09:28.749]   - Field: ‘state’
[16:09:28.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.749] - Launch lazy future ...
[16:09:28.749] Packages needed by the future expression (n = 0): <none>
[16:09:28.749] Packages needed by future strategies (n = 0): <none>
[16:09:28.750] {
[16:09:28.750]     {
[16:09:28.750]         {
[16:09:28.750]             ...future.startTime <- base::Sys.time()
[16:09:28.750]             {
[16:09:28.750]                 {
[16:09:28.750]                   {
[16:09:28.750]                     {
[16:09:28.750]                       base::local({
[16:09:28.750]                         has_future <- base::requireNamespace("future", 
[16:09:28.750]                           quietly = TRUE)
[16:09:28.750]                         if (has_future) {
[16:09:28.750]                           ns <- base::getNamespace("future")
[16:09:28.750]                           version <- ns[[".package"]][["version"]]
[16:09:28.750]                           if (is.null(version)) 
[16:09:28.750]                             version <- utils::packageVersion("future")
[16:09:28.750]                         }
[16:09:28.750]                         else {
[16:09:28.750]                           version <- NULL
[16:09:28.750]                         }
[16:09:28.750]                         if (!has_future || version < "1.8.0") {
[16:09:28.750]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.750]                             "", base::R.version$version.string), 
[16:09:28.750]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.750]                               "release", "version")], collapse = " "), 
[16:09:28.750]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.750]                             info)
[16:09:28.750]                           info <- base::paste(info, collapse = "; ")
[16:09:28.750]                           if (!has_future) {
[16:09:28.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.750]                               info)
[16:09:28.750]                           }
[16:09:28.750]                           else {
[16:09:28.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.750]                               info, version)
[16:09:28.750]                           }
[16:09:28.750]                           base::stop(msg)
[16:09:28.750]                         }
[16:09:28.750]                       })
[16:09:28.750]                     }
[16:09:28.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.750]                     base::options(mc.cores = 1L)
[16:09:28.750]                   }
[16:09:28.750]                   options(future.plan = NULL)
[16:09:28.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.750]                 }
[16:09:28.750]                 ...future.workdir <- getwd()
[16:09:28.750]             }
[16:09:28.750]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.750]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.750]         }
[16:09:28.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.750]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.750]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.750]             base::names(...future.oldOptions))
[16:09:28.750]     }
[16:09:28.750]     if (FALSE) {
[16:09:28.750]     }
[16:09:28.750]     else {
[16:09:28.750]         if (TRUE) {
[16:09:28.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.750]                 open = "w")
[16:09:28.750]         }
[16:09:28.750]         else {
[16:09:28.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.750]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.750]         }
[16:09:28.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.750]             base::sink(type = "output", split = FALSE)
[16:09:28.750]             base::close(...future.stdout)
[16:09:28.750]         }, add = TRUE)
[16:09:28.750]     }
[16:09:28.750]     ...future.frame <- base::sys.nframe()
[16:09:28.750]     ...future.conditions <- base::list()
[16:09:28.750]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.750]     if (FALSE) {
[16:09:28.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.750]     }
[16:09:28.750]     ...future.result <- base::tryCatch({
[16:09:28.750]         base::withCallingHandlers({
[16:09:28.750]             ...future.value <- base::withVisible(base::local({
[16:09:28.750]                 withCallingHandlers({
[16:09:28.750]                   {
[16:09:28.750]                     do.call(function(...) {
[16:09:28.750]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.750]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.750]                         ...future.globals.maxSize)) {
[16:09:28.750]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.750]                         on.exit(options(oopts), add = TRUE)
[16:09:28.750]                       }
[16:09:28.750]                       {
[16:09:28.750]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.750]                           FUN = function(jj) {
[16:09:28.750]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.750]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.750]                           })
[16:09:28.750]                       }
[16:09:28.750]                     }, args = future.call.arguments)
[16:09:28.750]                   }
[16:09:28.750]                 }, immediateCondition = function(cond) {
[16:09:28.750]                   save_rds <- function (object, pathname, ...) 
[16:09:28.750]                   {
[16:09:28.750]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.750]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.750]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.750]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.750]                         fi_tmp[["mtime"]])
[16:09:28.750]                     }
[16:09:28.750]                     tryCatch({
[16:09:28.750]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.750]                     }, error = function(ex) {
[16:09:28.750]                       msg <- conditionMessage(ex)
[16:09:28.750]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.750]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.750]                         fi_tmp[["mtime"]], msg)
[16:09:28.750]                       ex$message <- msg
[16:09:28.750]                       stop(ex)
[16:09:28.750]                     })
[16:09:28.750]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.750]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.750]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.750]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.750]                       fi <- file.info(pathname)
[16:09:28.750]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.750]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.750]                         fi[["size"]], fi[["mtime"]])
[16:09:28.750]                       stop(msg)
[16:09:28.750]                     }
[16:09:28.750]                     invisible(pathname)
[16:09:28.750]                   }
[16:09:28.750]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.750]                     rootPath = tempdir()) 
[16:09:28.750]                   {
[16:09:28.750]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.750]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.750]                       tmpdir = path, fileext = ".rds")
[16:09:28.750]                     save_rds(obj, file)
[16:09:28.750]                   }
[16:09:28.750]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.750]                   {
[16:09:28.750]                     inherits <- base::inherits
[16:09:28.750]                     invokeRestart <- base::invokeRestart
[16:09:28.750]                     is.null <- base::is.null
[16:09:28.750]                     muffled <- FALSE
[16:09:28.750]                     if (inherits(cond, "message")) {
[16:09:28.750]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.750]                       if (muffled) 
[16:09:28.750]                         invokeRestart("muffleMessage")
[16:09:28.750]                     }
[16:09:28.750]                     else if (inherits(cond, "warning")) {
[16:09:28.750]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.750]                       if (muffled) 
[16:09:28.750]                         invokeRestart("muffleWarning")
[16:09:28.750]                     }
[16:09:28.750]                     else if (inherits(cond, "condition")) {
[16:09:28.750]                       if (!is.null(pattern)) {
[16:09:28.750]                         computeRestarts <- base::computeRestarts
[16:09:28.750]                         grepl <- base::grepl
[16:09:28.750]                         restarts <- computeRestarts(cond)
[16:09:28.750]                         for (restart in restarts) {
[16:09:28.750]                           name <- restart$name
[16:09:28.750]                           if (is.null(name)) 
[16:09:28.750]                             next
[16:09:28.750]                           if (!grepl(pattern, name)) 
[16:09:28.750]                             next
[16:09:28.750]                           invokeRestart(restart)
[16:09:28.750]                           muffled <- TRUE
[16:09:28.750]                           break
[16:09:28.750]                         }
[16:09:28.750]                       }
[16:09:28.750]                     }
[16:09:28.750]                     invisible(muffled)
[16:09:28.750]                   }
[16:09:28.750]                   muffleCondition(cond)
[16:09:28.750]                 })
[16:09:28.750]             }))
[16:09:28.750]             future::FutureResult(value = ...future.value$value, 
[16:09:28.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.750]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.750]                     ...future.globalenv.names))
[16:09:28.750]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.750]         }, condition = base::local({
[16:09:28.750]             c <- base::c
[16:09:28.750]             inherits <- base::inherits
[16:09:28.750]             invokeRestart <- base::invokeRestart
[16:09:28.750]             length <- base::length
[16:09:28.750]             list <- base::list
[16:09:28.750]             seq.int <- base::seq.int
[16:09:28.750]             signalCondition <- base::signalCondition
[16:09:28.750]             sys.calls <- base::sys.calls
[16:09:28.750]             `[[` <- base::`[[`
[16:09:28.750]             `+` <- base::`+`
[16:09:28.750]             `<<-` <- base::`<<-`
[16:09:28.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.750]                   3L)]
[16:09:28.750]             }
[16:09:28.750]             function(cond) {
[16:09:28.750]                 is_error <- inherits(cond, "error")
[16:09:28.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.750]                   NULL)
[16:09:28.750]                 if (is_error) {
[16:09:28.750]                   sessionInformation <- function() {
[16:09:28.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.750]                       search = base::search(), system = base::Sys.info())
[16:09:28.750]                   }
[16:09:28.750]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.750]                     cond$call), session = sessionInformation(), 
[16:09:28.750]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.750]                   signalCondition(cond)
[16:09:28.750]                 }
[16:09:28.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.750]                 "immediateCondition"))) {
[16:09:28.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.750]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.750]                   if (TRUE && !signal) {
[16:09:28.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.750]                     {
[16:09:28.750]                       inherits <- base::inherits
[16:09:28.750]                       invokeRestart <- base::invokeRestart
[16:09:28.750]                       is.null <- base::is.null
[16:09:28.750]                       muffled <- FALSE
[16:09:28.750]                       if (inherits(cond, "message")) {
[16:09:28.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.750]                         if (muffled) 
[16:09:28.750]                           invokeRestart("muffleMessage")
[16:09:28.750]                       }
[16:09:28.750]                       else if (inherits(cond, "warning")) {
[16:09:28.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.750]                         if (muffled) 
[16:09:28.750]                           invokeRestart("muffleWarning")
[16:09:28.750]                       }
[16:09:28.750]                       else if (inherits(cond, "condition")) {
[16:09:28.750]                         if (!is.null(pattern)) {
[16:09:28.750]                           computeRestarts <- base::computeRestarts
[16:09:28.750]                           grepl <- base::grepl
[16:09:28.750]                           restarts <- computeRestarts(cond)
[16:09:28.750]                           for (restart in restarts) {
[16:09:28.750]                             name <- restart$name
[16:09:28.750]                             if (is.null(name)) 
[16:09:28.750]                               next
[16:09:28.750]                             if (!grepl(pattern, name)) 
[16:09:28.750]                               next
[16:09:28.750]                             invokeRestart(restart)
[16:09:28.750]                             muffled <- TRUE
[16:09:28.750]                             break
[16:09:28.750]                           }
[16:09:28.750]                         }
[16:09:28.750]                       }
[16:09:28.750]                       invisible(muffled)
[16:09:28.750]                     }
[16:09:28.750]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.750]                   }
[16:09:28.750]                 }
[16:09:28.750]                 else {
[16:09:28.750]                   if (TRUE) {
[16:09:28.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.750]                     {
[16:09:28.750]                       inherits <- base::inherits
[16:09:28.750]                       invokeRestart <- base::invokeRestart
[16:09:28.750]                       is.null <- base::is.null
[16:09:28.750]                       muffled <- FALSE
[16:09:28.750]                       if (inherits(cond, "message")) {
[16:09:28.750]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.750]                         if (muffled) 
[16:09:28.750]                           invokeRestart("muffleMessage")
[16:09:28.750]                       }
[16:09:28.750]                       else if (inherits(cond, "warning")) {
[16:09:28.750]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.750]                         if (muffled) 
[16:09:28.750]                           invokeRestart("muffleWarning")
[16:09:28.750]                       }
[16:09:28.750]                       else if (inherits(cond, "condition")) {
[16:09:28.750]                         if (!is.null(pattern)) {
[16:09:28.750]                           computeRestarts <- base::computeRestarts
[16:09:28.750]                           grepl <- base::grepl
[16:09:28.750]                           restarts <- computeRestarts(cond)
[16:09:28.750]                           for (restart in restarts) {
[16:09:28.750]                             name <- restart$name
[16:09:28.750]                             if (is.null(name)) 
[16:09:28.750]                               next
[16:09:28.750]                             if (!grepl(pattern, name)) 
[16:09:28.750]                               next
[16:09:28.750]                             invokeRestart(restart)
[16:09:28.750]                             muffled <- TRUE
[16:09:28.750]                             break
[16:09:28.750]                           }
[16:09:28.750]                         }
[16:09:28.750]                       }
[16:09:28.750]                       invisible(muffled)
[16:09:28.750]                     }
[16:09:28.750]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.750]                   }
[16:09:28.750]                 }
[16:09:28.750]             }
[16:09:28.750]         }))
[16:09:28.750]     }, error = function(ex) {
[16:09:28.750]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.750]                 ...future.rng), started = ...future.startTime, 
[16:09:28.750]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.750]             version = "1.8"), class = "FutureResult")
[16:09:28.750]     }, finally = {
[16:09:28.750]         if (!identical(...future.workdir, getwd())) 
[16:09:28.750]             setwd(...future.workdir)
[16:09:28.750]         {
[16:09:28.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.750]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.750]             }
[16:09:28.750]             base::options(...future.oldOptions)
[16:09:28.750]             if (.Platform$OS.type == "windows") {
[16:09:28.750]                 old_names <- names(...future.oldEnvVars)
[16:09:28.750]                 envs <- base::Sys.getenv()
[16:09:28.750]                 names <- names(envs)
[16:09:28.750]                 common <- intersect(names, old_names)
[16:09:28.750]                 added <- setdiff(names, old_names)
[16:09:28.750]                 removed <- setdiff(old_names, names)
[16:09:28.750]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.750]                   envs[common]]
[16:09:28.750]                 NAMES <- toupper(changed)
[16:09:28.750]                 args <- list()
[16:09:28.750]                 for (kk in seq_along(NAMES)) {
[16:09:28.750]                   name <- changed[[kk]]
[16:09:28.750]                   NAME <- NAMES[[kk]]
[16:09:28.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.750]                     next
[16:09:28.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.750]                 }
[16:09:28.750]                 NAMES <- toupper(added)
[16:09:28.750]                 for (kk in seq_along(NAMES)) {
[16:09:28.750]                   name <- added[[kk]]
[16:09:28.750]                   NAME <- NAMES[[kk]]
[16:09:28.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.750]                     next
[16:09:28.750]                   args[[name]] <- ""
[16:09:28.750]                 }
[16:09:28.750]                 NAMES <- toupper(removed)
[16:09:28.750]                 for (kk in seq_along(NAMES)) {
[16:09:28.750]                   name <- removed[[kk]]
[16:09:28.750]                   NAME <- NAMES[[kk]]
[16:09:28.750]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.750]                     next
[16:09:28.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.750]                 }
[16:09:28.750]                 if (length(args) > 0) 
[16:09:28.750]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.750]             }
[16:09:28.750]             else {
[16:09:28.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.750]             }
[16:09:28.750]             {
[16:09:28.750]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.750]                   0L) {
[16:09:28.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.750]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.750]                   base::options(opts)
[16:09:28.750]                 }
[16:09:28.750]                 {
[16:09:28.750]                   {
[16:09:28.750]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.750]                     NULL
[16:09:28.750]                   }
[16:09:28.750]                   options(future.plan = NULL)
[16:09:28.750]                   if (is.na(NA_character_)) 
[16:09:28.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.750]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.750]                     envir = parent.frame()) 
[16:09:28.750]                   {
[16:09:28.750]                     default_workers <- missing(workers)
[16:09:28.750]                     if (is.function(workers)) 
[16:09:28.750]                       workers <- workers()
[16:09:28.750]                     workers <- structure(as.integer(workers), 
[16:09:28.750]                       class = class(workers))
[16:09:28.750]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.750]                       1L)
[16:09:28.750]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.750]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.750]                       if (default_workers) 
[16:09:28.750]                         supportsMulticore(warn = TRUE)
[16:09:28.750]                       return(sequential(..., envir = envir))
[16:09:28.750]                     }
[16:09:28.750]                     oopts <- options(mc.cores = workers)
[16:09:28.750]                     on.exit(options(oopts))
[16:09:28.750]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.750]                       envir = envir)
[16:09:28.750]                     if (!future$lazy) 
[16:09:28.750]                       future <- run(future)
[16:09:28.750]                     invisible(future)
[16:09:28.750]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.750]                 }
[16:09:28.750]             }
[16:09:28.750]         }
[16:09:28.750]     })
[16:09:28.750]     if (TRUE) {
[16:09:28.750]         base::sink(type = "output", split = FALSE)
[16:09:28.750]         if (TRUE) {
[16:09:28.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.750]         }
[16:09:28.750]         else {
[16:09:28.750]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.750]         }
[16:09:28.750]         base::close(...future.stdout)
[16:09:28.750]         ...future.stdout <- NULL
[16:09:28.750]     }
[16:09:28.750]     ...future.result$conditions <- ...future.conditions
[16:09:28.750]     ...future.result$finished <- base::Sys.time()
[16:09:28.750]     ...future.result
[16:09:28.750] }
[16:09:28.752] assign_globals() ...
[16:09:28.752] List of 5
[16:09:28.752]  $ future.call.arguments    : list()
[16:09:28.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.752]  $ ...future.FUN            :function (x)  
[16:09:28.752]  $ ...future.elements_ii    :List of 1
[16:09:28.752]   ..$ : int [1:2] 1 3
[16:09:28.752]  $ ...future.seeds_ii       : NULL
[16:09:28.752]  $ ...future.globals.maxSize: NULL
[16:09:28.752]  - attr(*, "where")=List of 5
[16:09:28.752]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.752]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.752]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.752]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.752]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.752]  - attr(*, "resolved")= logi FALSE
[16:09:28.752]  - attr(*, "total_size")= num NA
[16:09:28.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.752]  - attr(*, "already-done")= logi TRUE
[16:09:28.757] - copied ‘future.call.arguments’ to environment
[16:09:28.757] - reassign environment for ‘...future.FUN’
[16:09:28.757] - copied ‘...future.FUN’ to environment
[16:09:28.757] - copied ‘...future.elements_ii’ to environment
[16:09:28.757] - copied ‘...future.seeds_ii’ to environment
[16:09:28.757] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.757] assign_globals() ... done
[16:09:28.757] requestCore(): workers = 2
[16:09:28.760] MulticoreFuture started
[16:09:28.760] - Launch lazy future ... done
[16:09:28.760] run() for ‘MulticoreFuture’ ... done
[16:09:28.760] Created future:
[16:09:28.761] plan(): Setting new future strategy stack:
[16:09:28.761] List of future strategies:
[16:09:28.761] 1. sequential:
[16:09:28.761]    - args: function (..., envir = parent.frame())
[16:09:28.761]    - tweaked: FALSE
[16:09:28.761]    - call: NULL
[16:09:28.762] plan(): nbrOfWorkers() = 1
[16:09:28.764] plan(): Setting new future strategy stack:
[16:09:28.764] List of future strategies:
[16:09:28.764] 1. multicore:
[16:09:28.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.764]    - tweaked: FALSE
[16:09:28.764]    - call: plan(strategy)
[16:09:28.769] plan(): nbrOfWorkers() = 2
[16:09:28.761] MulticoreFuture:
[16:09:28.761] Label: ‘future_apply-1’
[16:09:28.761] Expression:
[16:09:28.761] {
[16:09:28.761]     do.call(function(...) {
[16:09:28.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.761]             on.exit(options(oopts), add = TRUE)
[16:09:28.761]         }
[16:09:28.761]         {
[16:09:28.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.761]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.761]             })
[16:09:28.761]         }
[16:09:28.761]     }, args = future.call.arguments)
[16:09:28.761] }
[16:09:28.761] Lazy evaluation: FALSE
[16:09:28.761] Asynchronous evaluation: TRUE
[16:09:28.761] Local evaluation: TRUE
[16:09:28.761] Environment: R_GlobalEnv
[16:09:28.761] Capture standard output: TRUE
[16:09:28.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.761] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.761] Packages: <none>
[16:09:28.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.761] Resolved: TRUE
[16:09:28.761] Value: <not collected>
[16:09:28.761] Conditions captured: <none>
[16:09:28.761] Early signaling: FALSE
[16:09:28.761] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.761] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.770] Chunk #1 of 2 ... DONE
[16:09:28.770] Chunk #2 of 2 ...
[16:09:28.771]  - seeds: <none>
[16:09:28.771] getGlobalsAndPackages() ...
[16:09:28.771] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.771] Resolving globals: FALSE
[16:09:28.771] Tweak future expression to call with '...' arguments ...
[16:09:28.771] {
[16:09:28.771]     do.call(function(...) {
[16:09:28.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.771]             on.exit(options(oopts), add = TRUE)
[16:09:28.771]         }
[16:09:28.771]         {
[16:09:28.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.771]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.771]             })
[16:09:28.771]         }
[16:09:28.771]     }, args = future.call.arguments)
[16:09:28.771] }
[16:09:28.772] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.772] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.772] 
[16:09:28.773] getGlobalsAndPackages() ... DONE
[16:09:28.773] run() for ‘Future’ ...
[16:09:28.773] - state: ‘created’
[16:09:28.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.778]   - Field: ‘label’
[16:09:28.779]   - Field: ‘local’
[16:09:28.779]   - Field: ‘owner’
[16:09:28.779]   - Field: ‘envir’
[16:09:28.779]   - Field: ‘workers’
[16:09:28.779]   - Field: ‘packages’
[16:09:28.779]   - Field: ‘gc’
[16:09:28.779]   - Field: ‘job’
[16:09:28.780]   - Field: ‘conditions’
[16:09:28.780]   - Field: ‘expr’
[16:09:28.783]   - Field: ‘uuid’
[16:09:28.783]   - Field: ‘seed’
[16:09:28.783]   - Field: ‘version’
[16:09:28.784]   - Field: ‘result’
[16:09:28.784]   - Field: ‘asynchronous’
[16:09:28.784]   - Field: ‘calls’
[16:09:28.785]   - Field: ‘globals’
[16:09:28.785]   - Field: ‘stdout’
[16:09:28.785]   - Field: ‘earlySignal’
[16:09:28.786]   - Field: ‘lazy’
[16:09:28.786]   - Field: ‘state’
[16:09:28.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.786] - Launch lazy future ...
[16:09:28.787] Packages needed by the future expression (n = 0): <none>
[16:09:28.787] Packages needed by future strategies (n = 0): <none>
[16:09:28.788] {
[16:09:28.788]     {
[16:09:28.788]         {
[16:09:28.788]             ...future.startTime <- base::Sys.time()
[16:09:28.788]             {
[16:09:28.788]                 {
[16:09:28.788]                   {
[16:09:28.788]                     {
[16:09:28.788]                       base::local({
[16:09:28.788]                         has_future <- base::requireNamespace("future", 
[16:09:28.788]                           quietly = TRUE)
[16:09:28.788]                         if (has_future) {
[16:09:28.788]                           ns <- base::getNamespace("future")
[16:09:28.788]                           version <- ns[[".package"]][["version"]]
[16:09:28.788]                           if (is.null(version)) 
[16:09:28.788]                             version <- utils::packageVersion("future")
[16:09:28.788]                         }
[16:09:28.788]                         else {
[16:09:28.788]                           version <- NULL
[16:09:28.788]                         }
[16:09:28.788]                         if (!has_future || version < "1.8.0") {
[16:09:28.788]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.788]                             "", base::R.version$version.string), 
[16:09:28.788]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.788]                               "release", "version")], collapse = " "), 
[16:09:28.788]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.788]                             info)
[16:09:28.788]                           info <- base::paste(info, collapse = "; ")
[16:09:28.788]                           if (!has_future) {
[16:09:28.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.788]                               info)
[16:09:28.788]                           }
[16:09:28.788]                           else {
[16:09:28.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.788]                               info, version)
[16:09:28.788]                           }
[16:09:28.788]                           base::stop(msg)
[16:09:28.788]                         }
[16:09:28.788]                       })
[16:09:28.788]                     }
[16:09:28.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.788]                     base::options(mc.cores = 1L)
[16:09:28.788]                   }
[16:09:28.788]                   options(future.plan = NULL)
[16:09:28.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.788]                 }
[16:09:28.788]                 ...future.workdir <- getwd()
[16:09:28.788]             }
[16:09:28.788]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.788]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.788]         }
[16:09:28.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.788]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.788]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.788]             base::names(...future.oldOptions))
[16:09:28.788]     }
[16:09:28.788]     if (FALSE) {
[16:09:28.788]     }
[16:09:28.788]     else {
[16:09:28.788]         if (TRUE) {
[16:09:28.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.788]                 open = "w")
[16:09:28.788]         }
[16:09:28.788]         else {
[16:09:28.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.788]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.788]         }
[16:09:28.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.788]             base::sink(type = "output", split = FALSE)
[16:09:28.788]             base::close(...future.stdout)
[16:09:28.788]         }, add = TRUE)
[16:09:28.788]     }
[16:09:28.788]     ...future.frame <- base::sys.nframe()
[16:09:28.788]     ...future.conditions <- base::list()
[16:09:28.788]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.788]     if (FALSE) {
[16:09:28.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.788]     }
[16:09:28.788]     ...future.result <- base::tryCatch({
[16:09:28.788]         base::withCallingHandlers({
[16:09:28.788]             ...future.value <- base::withVisible(base::local({
[16:09:28.788]                 withCallingHandlers({
[16:09:28.788]                   {
[16:09:28.788]                     do.call(function(...) {
[16:09:28.788]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.788]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.788]                         ...future.globals.maxSize)) {
[16:09:28.788]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.788]                         on.exit(options(oopts), add = TRUE)
[16:09:28.788]                       }
[16:09:28.788]                       {
[16:09:28.788]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.788]                           FUN = function(jj) {
[16:09:28.788]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.788]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.788]                           })
[16:09:28.788]                       }
[16:09:28.788]                     }, args = future.call.arguments)
[16:09:28.788]                   }
[16:09:28.788]                 }, immediateCondition = function(cond) {
[16:09:28.788]                   save_rds <- function (object, pathname, ...) 
[16:09:28.788]                   {
[16:09:28.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.788]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.788]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.788]                         fi_tmp[["mtime"]])
[16:09:28.788]                     }
[16:09:28.788]                     tryCatch({
[16:09:28.788]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.788]                     }, error = function(ex) {
[16:09:28.788]                       msg <- conditionMessage(ex)
[16:09:28.788]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.788]                         fi_tmp[["mtime"]], msg)
[16:09:28.788]                       ex$message <- msg
[16:09:28.788]                       stop(ex)
[16:09:28.788]                     })
[16:09:28.788]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.788]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.788]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.788]                       fi <- file.info(pathname)
[16:09:28.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.788]                         fi[["size"]], fi[["mtime"]])
[16:09:28.788]                       stop(msg)
[16:09:28.788]                     }
[16:09:28.788]                     invisible(pathname)
[16:09:28.788]                   }
[16:09:28.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.788]                     rootPath = tempdir()) 
[16:09:28.788]                   {
[16:09:28.788]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.788]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.788]                       tmpdir = path, fileext = ".rds")
[16:09:28.788]                     save_rds(obj, file)
[16:09:28.788]                   }
[16:09:28.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.788]                   {
[16:09:28.788]                     inherits <- base::inherits
[16:09:28.788]                     invokeRestart <- base::invokeRestart
[16:09:28.788]                     is.null <- base::is.null
[16:09:28.788]                     muffled <- FALSE
[16:09:28.788]                     if (inherits(cond, "message")) {
[16:09:28.788]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.788]                       if (muffled) 
[16:09:28.788]                         invokeRestart("muffleMessage")
[16:09:28.788]                     }
[16:09:28.788]                     else if (inherits(cond, "warning")) {
[16:09:28.788]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.788]                       if (muffled) 
[16:09:28.788]                         invokeRestart("muffleWarning")
[16:09:28.788]                     }
[16:09:28.788]                     else if (inherits(cond, "condition")) {
[16:09:28.788]                       if (!is.null(pattern)) {
[16:09:28.788]                         computeRestarts <- base::computeRestarts
[16:09:28.788]                         grepl <- base::grepl
[16:09:28.788]                         restarts <- computeRestarts(cond)
[16:09:28.788]                         for (restart in restarts) {
[16:09:28.788]                           name <- restart$name
[16:09:28.788]                           if (is.null(name)) 
[16:09:28.788]                             next
[16:09:28.788]                           if (!grepl(pattern, name)) 
[16:09:28.788]                             next
[16:09:28.788]                           invokeRestart(restart)
[16:09:28.788]                           muffled <- TRUE
[16:09:28.788]                           break
[16:09:28.788]                         }
[16:09:28.788]                       }
[16:09:28.788]                     }
[16:09:28.788]                     invisible(muffled)
[16:09:28.788]                   }
[16:09:28.788]                   muffleCondition(cond)
[16:09:28.788]                 })
[16:09:28.788]             }))
[16:09:28.788]             future::FutureResult(value = ...future.value$value, 
[16:09:28.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.788]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.788]                     ...future.globalenv.names))
[16:09:28.788]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.788]         }, condition = base::local({
[16:09:28.788]             c <- base::c
[16:09:28.788]             inherits <- base::inherits
[16:09:28.788]             invokeRestart <- base::invokeRestart
[16:09:28.788]             length <- base::length
[16:09:28.788]             list <- base::list
[16:09:28.788]             seq.int <- base::seq.int
[16:09:28.788]             signalCondition <- base::signalCondition
[16:09:28.788]             sys.calls <- base::sys.calls
[16:09:28.788]             `[[` <- base::`[[`
[16:09:28.788]             `+` <- base::`+`
[16:09:28.788]             `<<-` <- base::`<<-`
[16:09:28.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.788]                   3L)]
[16:09:28.788]             }
[16:09:28.788]             function(cond) {
[16:09:28.788]                 is_error <- inherits(cond, "error")
[16:09:28.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.788]                   NULL)
[16:09:28.788]                 if (is_error) {
[16:09:28.788]                   sessionInformation <- function() {
[16:09:28.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.788]                       search = base::search(), system = base::Sys.info())
[16:09:28.788]                   }
[16:09:28.788]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.788]                     cond$call), session = sessionInformation(), 
[16:09:28.788]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.788]                   signalCondition(cond)
[16:09:28.788]                 }
[16:09:28.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:28.788]                 "immediateCondition"))) {
[16:09:28.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.788]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.788]                   if (TRUE && !signal) {
[16:09:28.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.788]                     {
[16:09:28.788]                       inherits <- base::inherits
[16:09:28.788]                       invokeRestart <- base::invokeRestart
[16:09:28.788]                       is.null <- base::is.null
[16:09:28.788]                       muffled <- FALSE
[16:09:28.788]                       if (inherits(cond, "message")) {
[16:09:28.788]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.788]                         if (muffled) 
[16:09:28.788]                           invokeRestart("muffleMessage")
[16:09:28.788]                       }
[16:09:28.788]                       else if (inherits(cond, "warning")) {
[16:09:28.788]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.788]                         if (muffled) 
[16:09:28.788]                           invokeRestart("muffleWarning")
[16:09:28.788]                       }
[16:09:28.788]                       else if (inherits(cond, "condition")) {
[16:09:28.788]                         if (!is.null(pattern)) {
[16:09:28.788]                           computeRestarts <- base::computeRestarts
[16:09:28.788]                           grepl <- base::grepl
[16:09:28.788]                           restarts <- computeRestarts(cond)
[16:09:28.788]                           for (restart in restarts) {
[16:09:28.788]                             name <- restart$name
[16:09:28.788]                             if (is.null(name)) 
[16:09:28.788]                               next
[16:09:28.788]                             if (!grepl(pattern, name)) 
[16:09:28.788]                               next
[16:09:28.788]                             invokeRestart(restart)
[16:09:28.788]                             muffled <- TRUE
[16:09:28.788]                             break
[16:09:28.788]                           }
[16:09:28.788]                         }
[16:09:28.788]                       }
[16:09:28.788]                       invisible(muffled)
[16:09:28.788]                     }
[16:09:28.788]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.788]                   }
[16:09:28.788]                 }
[16:09:28.788]                 else {
[16:09:28.788]                   if (TRUE) {
[16:09:28.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.788]                     {
[16:09:28.788]                       inherits <- base::inherits
[16:09:28.788]                       invokeRestart <- base::invokeRestart
[16:09:28.788]                       is.null <- base::is.null
[16:09:28.788]                       muffled <- FALSE
[16:09:28.788]                       if (inherits(cond, "message")) {
[16:09:28.788]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.788]                         if (muffled) 
[16:09:28.788]                           invokeRestart("muffleMessage")
[16:09:28.788]                       }
[16:09:28.788]                       else if (inherits(cond, "warning")) {
[16:09:28.788]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.788]                         if (muffled) 
[16:09:28.788]                           invokeRestart("muffleWarning")
[16:09:28.788]                       }
[16:09:28.788]                       else if (inherits(cond, "condition")) {
[16:09:28.788]                         if (!is.null(pattern)) {
[16:09:28.788]                           computeRestarts <- base::computeRestarts
[16:09:28.788]                           grepl <- base::grepl
[16:09:28.788]                           restarts <- computeRestarts(cond)
[16:09:28.788]                           for (restart in restarts) {
[16:09:28.788]                             name <- restart$name
[16:09:28.788]                             if (is.null(name)) 
[16:09:28.788]                               next
[16:09:28.788]                             if (!grepl(pattern, name)) 
[16:09:28.788]                               next
[16:09:28.788]                             invokeRestart(restart)
[16:09:28.788]                             muffled <- TRUE
[16:09:28.788]                             break
[16:09:28.788]                           }
[16:09:28.788]                         }
[16:09:28.788]                       }
[16:09:28.788]                       invisible(muffled)
[16:09:28.788]                     }
[16:09:28.788]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.788]                   }
[16:09:28.788]                 }
[16:09:28.788]             }
[16:09:28.788]         }))
[16:09:28.788]     }, error = function(ex) {
[16:09:28.788]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.788]                 ...future.rng), started = ...future.startTime, 
[16:09:28.788]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.788]             version = "1.8"), class = "FutureResult")
[16:09:28.788]     }, finally = {
[16:09:28.788]         if (!identical(...future.workdir, getwd())) 
[16:09:28.788]             setwd(...future.workdir)
[16:09:28.788]         {
[16:09:28.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.788]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.788]             }
[16:09:28.788]             base::options(...future.oldOptions)
[16:09:28.788]             if (.Platform$OS.type == "windows") {
[16:09:28.788]                 old_names <- names(...future.oldEnvVars)
[16:09:28.788]                 envs <- base::Sys.getenv()
[16:09:28.788]                 names <- names(envs)
[16:09:28.788]                 common <- intersect(names, old_names)
[16:09:28.788]                 added <- setdiff(names, old_names)
[16:09:28.788]                 removed <- setdiff(old_names, names)
[16:09:28.788]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.788]                   envs[common]]
[16:09:28.788]                 NAMES <- toupper(changed)
[16:09:28.788]                 args <- list()
[16:09:28.788]                 for (kk in seq_along(NAMES)) {
[16:09:28.788]                   name <- changed[[kk]]
[16:09:28.788]                   NAME <- NAMES[[kk]]
[16:09:28.788]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.788]                     next
[16:09:28.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.788]                 }
[16:09:28.788]                 NAMES <- toupper(added)
[16:09:28.788]                 for (kk in seq_along(NAMES)) {
[16:09:28.788]                   name <- added[[kk]]
[16:09:28.788]                   NAME <- NAMES[[kk]]
[16:09:28.788]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.788]                     next
[16:09:28.788]                   args[[name]] <- ""
[16:09:28.788]                 }
[16:09:28.788]                 NAMES <- toupper(removed)
[16:09:28.788]                 for (kk in seq_along(NAMES)) {
[16:09:28.788]                   name <- removed[[kk]]
[16:09:28.788]                   NAME <- NAMES[[kk]]
[16:09:28.788]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.788]                     next
[16:09:28.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.788]                 }
[16:09:28.788]                 if (length(args) > 0) 
[16:09:28.788]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.788]             }
[16:09:28.788]             else {
[16:09:28.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.788]             }
[16:09:28.788]             {
[16:09:28.788]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.788]                   0L) {
[16:09:28.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.788]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.788]                   base::options(opts)
[16:09:28.788]                 }
[16:09:28.788]                 {
[16:09:28.788]                   {
[16:09:28.788]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.788]                     NULL
[16:09:28.788]                   }
[16:09:28.788]                   options(future.plan = NULL)
[16:09:28.788]                   if (is.na(NA_character_)) 
[16:09:28.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.788]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.788]                     envir = parent.frame()) 
[16:09:28.788]                   {
[16:09:28.788]                     default_workers <- missing(workers)
[16:09:28.788]                     if (is.function(workers)) 
[16:09:28.788]                       workers <- workers()
[16:09:28.788]                     workers <- structure(as.integer(workers), 
[16:09:28.788]                       class = class(workers))
[16:09:28.788]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.788]                       1L)
[16:09:28.788]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.788]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.788]                       if (default_workers) 
[16:09:28.788]                         supportsMulticore(warn = TRUE)
[16:09:28.788]                       return(sequential(..., envir = envir))
[16:09:28.788]                     }
[16:09:28.788]                     oopts <- options(mc.cores = workers)
[16:09:28.788]                     on.exit(options(oopts))
[16:09:28.788]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.788]                       envir = envir)
[16:09:28.788]                     if (!future$lazy) 
[16:09:28.788]                       future <- run(future)
[16:09:28.788]                     invisible(future)
[16:09:28.788]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.788]                 }
[16:09:28.788]             }
[16:09:28.788]         }
[16:09:28.788]     })
[16:09:28.788]     if (TRUE) {
[16:09:28.788]         base::sink(type = "output", split = FALSE)
[16:09:28.788]         if (TRUE) {
[16:09:28.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.788]         }
[16:09:28.788]         else {
[16:09:28.788]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.788]         }
[16:09:28.788]         base::close(...future.stdout)
[16:09:28.788]         ...future.stdout <- NULL
[16:09:28.788]     }
[16:09:28.788]     ...future.result$conditions <- ...future.conditions
[16:09:28.788]     ...future.result$finished <- base::Sys.time()
[16:09:28.788]     ...future.result
[16:09:28.788] }
[16:09:28.791] assign_globals() ...
[16:09:28.792] List of 5
[16:09:28.792]  $ future.call.arguments    : list()
[16:09:28.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.792]  $ ...future.FUN            :function (x)  
[16:09:28.792]  $ ...future.elements_ii    :List of 1
[16:09:28.792]   ..$ : int [1:2] 2 4
[16:09:28.792]  $ ...future.seeds_ii       : NULL
[16:09:28.792]  $ ...future.globals.maxSize: NULL
[16:09:28.792]  - attr(*, "where")=List of 5
[16:09:28.792]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.792]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.792]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.792]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.792]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.792]  - attr(*, "resolved")= logi FALSE
[16:09:28.792]  - attr(*, "total_size")= num NA
[16:09:28.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.792]  - attr(*, "already-done")= logi TRUE
[16:09:28.800] - copied ‘future.call.arguments’ to environment
[16:09:28.800] - reassign environment for ‘...future.FUN’
[16:09:28.800] - copied ‘...future.FUN’ to environment
[16:09:28.800] - copied ‘...future.elements_ii’ to environment
[16:09:28.800] - copied ‘...future.seeds_ii’ to environment
[16:09:28.800] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.800] assign_globals() ... done
[16:09:28.801] requestCore(): workers = 2
[16:09:28.803] MulticoreFuture started
[16:09:28.803] - Launch lazy future ... done
[16:09:28.804] run() for ‘MulticoreFuture’ ... done
[16:09:28.804] Created future:
[16:09:28.804] plan(): Setting new future strategy stack:
[16:09:28.804] List of future strategies:
[16:09:28.804] 1. sequential:
[16:09:28.804]    - args: function (..., envir = parent.frame())
[16:09:28.804]    - tweaked: FALSE
[16:09:28.804]    - call: NULL
[16:09:28.806] plan(): nbrOfWorkers() = 1
[16:09:28.808] plan(): Setting new future strategy stack:
[16:09:28.808] List of future strategies:
[16:09:28.808] 1. multicore:
[16:09:28.808]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.808]    - tweaked: FALSE
[16:09:28.808]    - call: plan(strategy)
[16:09:28.813] plan(): nbrOfWorkers() = 2
[16:09:28.804] MulticoreFuture:
[16:09:28.804] Label: ‘future_apply-2’
[16:09:28.804] Expression:
[16:09:28.804] {
[16:09:28.804]     do.call(function(...) {
[16:09:28.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.804]             on.exit(options(oopts), add = TRUE)
[16:09:28.804]         }
[16:09:28.804]         {
[16:09:28.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.804]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.804]             })
[16:09:28.804]         }
[16:09:28.804]     }, args = future.call.arguments)
[16:09:28.804] }
[16:09:28.804] Lazy evaluation: FALSE
[16:09:28.804] Asynchronous evaluation: TRUE
[16:09:28.804] Local evaluation: TRUE
[16:09:28.804] Environment: R_GlobalEnv
[16:09:28.804] Capture standard output: TRUE
[16:09:28.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:28.804] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.804] Packages: <none>
[16:09:28.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:28.804] Resolved: TRUE
[16:09:28.804] Value: <not collected>
[16:09:28.804] Conditions captured: <none>
[16:09:28.804] Early signaling: FALSE
[16:09:28.804] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.804] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.814] Chunk #2 of 2 ... DONE
[16:09:28.814] Launching 2 futures (chunks) ... DONE
[16:09:28.815] Resolving 2 futures (chunks) ...
[16:09:28.815] resolve() on list ...
[16:09:28.815]  recursive: 0
[16:09:28.815]  length: 2
[16:09:28.815] 
[16:09:28.816] Future #1
[16:09:28.817] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.817] - nx: 2
[16:09:28.817] - relay: TRUE
[16:09:28.817] - stdout: TRUE
[16:09:28.817] - signal: TRUE
[16:09:28.817] - resignal: FALSE
[16:09:28.817] - force: TRUE
[16:09:28.818] - relayed: [n=2] FALSE, FALSE
[16:09:28.818] - queued futures: [n=2] FALSE, FALSE
[16:09:28.818]  - until=1
[16:09:28.818]  - relaying element #1
[16:09:28.818] - relayed: [n=2] TRUE, FALSE
[16:09:28.818] - queued futures: [n=2] TRUE, FALSE
[16:09:28.819] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.819]  length: 1 (resolved future 1)
[16:09:28.819] Future #2
[16:09:28.820] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.821] - nx: 2
[16:09:28.821] - relay: TRUE
[16:09:28.821] - stdout: TRUE
[16:09:28.821] - signal: TRUE
[16:09:28.821] - resignal: FALSE
[16:09:28.822] - force: TRUE
[16:09:28.822] - relayed: [n=2] TRUE, FALSE
[16:09:28.822] - queued futures: [n=2] TRUE, FALSE
[16:09:28.822]  - until=2
[16:09:28.822]  - relaying element #2
[16:09:28.823] - relayed: [n=2] TRUE, TRUE
[16:09:28.823] - queued futures: [n=2] TRUE, TRUE
[16:09:28.823] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.823]  length: 0 (resolved future 2)
[16:09:28.823] Relaying remaining futures
[16:09:28.823] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.824] - nx: 2
[16:09:28.824] - relay: TRUE
[16:09:28.824] - stdout: TRUE
[16:09:28.824] - signal: TRUE
[16:09:28.824] - resignal: FALSE
[16:09:28.824] - force: TRUE
[16:09:28.824] - relayed: [n=2] TRUE, TRUE
[16:09:28.824] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.825] - relayed: [n=2] TRUE, TRUE
[16:09:28.825] - queued futures: [n=2] TRUE, TRUE
[16:09:28.825] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.825] resolve() on list ... DONE
[16:09:28.825]  - Number of value chunks collected: 2
[16:09:28.826] Resolving 2 futures (chunks) ... DONE
[16:09:28.826] Reducing values from 2 chunks ...
[16:09:28.826]  - Number of values collected after concatenation: 2
[16:09:28.826]  - Number of values expected: 2
[16:09:28.826] Reducing values from 2 chunks ... DONE
[16:09:28.826] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:09:28.827] getGlobalsAndPackagesXApply() ...
[16:09:28.827]  - future.globals: TRUE
[16:09:28.827] getGlobalsAndPackages() ...
[16:09:28.827] Searching for globals...
[16:09:28.835] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:09:28.835] Searching for globals ... DONE
[16:09:28.835] Resolving globals: FALSE
[16:09:28.836] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:09:28.836] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:09:28.836] - globals: [1] ‘FUN’
[16:09:28.837] 
[16:09:28.837] getGlobalsAndPackages() ... DONE
[16:09:28.837]  - globals found/used: [n=1] ‘FUN’
[16:09:28.837]  - needed namespaces: [n=0] 
[16:09:28.837] Finding globals ... DONE
[16:09:28.837]  - use_args: TRUE
[16:09:28.837]  - Getting '...' globals ...
[16:09:28.838] resolve() on list ...
[16:09:28.838]  recursive: 0
[16:09:28.838]  length: 1
[16:09:28.838]  elements: ‘...’
[16:09:28.838]  length: 0 (resolved future 1)
[16:09:28.838] resolve() on list ... DONE
[16:09:28.839]    - '...' content: [n=0] 
[16:09:28.839] List of 1
[16:09:28.839]  $ ...: list()
[16:09:28.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.839]  - attr(*, "where")=List of 1
[16:09:28.839]   ..$ ...:<environment: 0x5633ac5cb0e0> 
[16:09:28.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.839]  - attr(*, "resolved")= logi TRUE
[16:09:28.839]  - attr(*, "total_size")= num NA
[16:09:28.842]  - Getting '...' globals ... DONE
[16:09:28.842] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:28.842] List of 2
[16:09:28.842]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:09:28.842]  $ ...          : list()
[16:09:28.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.842]  - attr(*, "where")=List of 2
[16:09:28.842]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:28.842]   ..$ ...          :<environment: 0x5633ac5cb0e0> 
[16:09:28.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.842]  - attr(*, "resolved")= logi FALSE
[16:09:28.842]  - attr(*, "total_size")= num 36296
[16:09:28.845] Packages to be attached in all futures: [n=0] 
[16:09:28.845] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.849] future_lapply() ...
[16:09:28.851] Generating random seeds ...
[16:09:28.851] Generating random seed streams for 2 elements ...
[16:09:28.851] Generating random seed streams for 2 elements ... DONE
[16:09:28.851] Generating random seeds ... DONE
[16:09:28.851] Will set RNG state on exit: 10407, -1578269260, 368782423, -1800098810, -84025547, 133637952, 1633950339
[16:09:28.855] Number of chunks: 2
[16:09:28.855] getGlobalsAndPackagesXApply() ...
[16:09:28.855]  - future.globals: <name-value list> with names ‘list()’
[16:09:28.855]  - use_args: TRUE
[16:09:28.855] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:28.855] List of 2
[16:09:28.855]  $ ...          : list()
[16:09:28.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.855]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:09:28.855]  - attr(*, "where")=List of 2
[16:09:28.855]   ..$ ...          :<environment: 0x5633ac5cb0e0> 
[16:09:28.855]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:28.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.855]  - attr(*, "resolved")= logi FALSE
[16:09:28.855]  - attr(*, "total_size")= num NA
[16:09:28.861] Packages to be attached in all futures: [n=0] 
[16:09:28.861] getGlobalsAndPackagesXApply() ... DONE
[16:09:28.861] Number of futures (= number of chunks): 2
[16:09:28.861] Launching 2 futures (chunks) ...
[16:09:28.861] Chunk #1 of 2 ...
[16:09:28.861]  - seeds: [1] <seeds>
[16:09:28.861] getGlobalsAndPackages() ...
[16:09:28.862] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.862] Resolving globals: FALSE
[16:09:28.862] Tweak future expression to call with '...' arguments ...
[16:09:28.862] {
[16:09:28.862]     do.call(function(...) {
[16:09:28.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.862]             on.exit(options(oopts), add = TRUE)
[16:09:28.862]         }
[16:09:28.862]         {
[16:09:28.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.862]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:28.862]                   envir = globalenv(), inherits = FALSE)
[16:09:28.862]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.862]             })
[16:09:28.862]         }
[16:09:28.862]     }, args = future.call.arguments)
[16:09:28.862] }
[16:09:28.862] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.863] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.863] 
[16:09:28.863] getGlobalsAndPackages() ... DONE
[16:09:28.863] run() for ‘Future’ ...
[16:09:28.863] - state: ‘created’
[16:09:28.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.867]   - Field: ‘label’
[16:09:28.867]   - Field: ‘local’
[16:09:28.867]   - Field: ‘owner’
[16:09:28.867]   - Field: ‘envir’
[16:09:28.868]   - Field: ‘workers’
[16:09:28.868]   - Field: ‘packages’
[16:09:28.868]   - Field: ‘gc’
[16:09:28.868]   - Field: ‘job’
[16:09:28.868]   - Field: ‘conditions’
[16:09:28.868]   - Field: ‘expr’
[16:09:28.868]   - Field: ‘uuid’
[16:09:28.868]   - Field: ‘seed’
[16:09:28.868]   - Field: ‘version’
[16:09:28.869]   - Field: ‘result’
[16:09:28.869]   - Field: ‘asynchronous’
[16:09:28.869]   - Field: ‘calls’
[16:09:28.869]   - Field: ‘globals’
[16:09:28.869]   - Field: ‘stdout’
[16:09:28.869]   - Field: ‘earlySignal’
[16:09:28.869]   - Field: ‘lazy’
[16:09:28.869]   - Field: ‘state’
[16:09:28.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.869] - Launch lazy future ...
[16:09:28.870] Packages needed by the future expression (n = 0): <none>
[16:09:28.870] Packages needed by future strategies (n = 0): <none>
[16:09:28.870] {
[16:09:28.870]     {
[16:09:28.870]         {
[16:09:28.870]             ...future.startTime <- base::Sys.time()
[16:09:28.870]             {
[16:09:28.870]                 {
[16:09:28.870]                   {
[16:09:28.870]                     {
[16:09:28.870]                       base::local({
[16:09:28.870]                         has_future <- base::requireNamespace("future", 
[16:09:28.870]                           quietly = TRUE)
[16:09:28.870]                         if (has_future) {
[16:09:28.870]                           ns <- base::getNamespace("future")
[16:09:28.870]                           version <- ns[[".package"]][["version"]]
[16:09:28.870]                           if (is.null(version)) 
[16:09:28.870]                             version <- utils::packageVersion("future")
[16:09:28.870]                         }
[16:09:28.870]                         else {
[16:09:28.870]                           version <- NULL
[16:09:28.870]                         }
[16:09:28.870]                         if (!has_future || version < "1.8.0") {
[16:09:28.870]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.870]                             "", base::R.version$version.string), 
[16:09:28.870]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.870]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.870]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.870]                               "release", "version")], collapse = " "), 
[16:09:28.870]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.870]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.870]                             info)
[16:09:28.870]                           info <- base::paste(info, collapse = "; ")
[16:09:28.870]                           if (!has_future) {
[16:09:28.870]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.870]                               info)
[16:09:28.870]                           }
[16:09:28.870]                           else {
[16:09:28.870]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.870]                               info, version)
[16:09:28.870]                           }
[16:09:28.870]                           base::stop(msg)
[16:09:28.870]                         }
[16:09:28.870]                       })
[16:09:28.870]                     }
[16:09:28.870]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.870]                     base::options(mc.cores = 1L)
[16:09:28.870]                   }
[16:09:28.870]                   options(future.plan = NULL)
[16:09:28.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.870]                 }
[16:09:28.870]                 ...future.workdir <- getwd()
[16:09:28.870]             }
[16:09:28.870]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.870]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.870]         }
[16:09:28.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.870]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.870]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.870]             base::names(...future.oldOptions))
[16:09:28.870]     }
[16:09:28.870]     if (FALSE) {
[16:09:28.870]     }
[16:09:28.870]     else {
[16:09:28.870]         if (TRUE) {
[16:09:28.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.870]                 open = "w")
[16:09:28.870]         }
[16:09:28.870]         else {
[16:09:28.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.870]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.870]         }
[16:09:28.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.870]             base::sink(type = "output", split = FALSE)
[16:09:28.870]             base::close(...future.stdout)
[16:09:28.870]         }, add = TRUE)
[16:09:28.870]     }
[16:09:28.870]     ...future.frame <- base::sys.nframe()
[16:09:28.870]     ...future.conditions <- base::list()
[16:09:28.870]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.870]     if (FALSE) {
[16:09:28.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.870]     }
[16:09:28.870]     ...future.result <- base::tryCatch({
[16:09:28.870]         base::withCallingHandlers({
[16:09:28.870]             ...future.value <- base::withVisible(base::local({
[16:09:28.870]                 withCallingHandlers({
[16:09:28.870]                   {
[16:09:28.870]                     do.call(function(...) {
[16:09:28.870]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.870]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.870]                         ...future.globals.maxSize)) {
[16:09:28.870]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.870]                         on.exit(options(oopts), add = TRUE)
[16:09:28.870]                       }
[16:09:28.870]                       {
[16:09:28.870]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.870]                           FUN = function(jj) {
[16:09:28.870]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.870]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:28.870]                               envir = globalenv(), inherits = FALSE)
[16:09:28.870]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.870]                           })
[16:09:28.870]                       }
[16:09:28.870]                     }, args = future.call.arguments)
[16:09:28.870]                   }
[16:09:28.870]                 }, immediateCondition = function(cond) {
[16:09:28.870]                   save_rds <- function (object, pathname, ...) 
[16:09:28.870]                   {
[16:09:28.870]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.870]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.870]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.870]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.870]                         fi_tmp[["mtime"]])
[16:09:28.870]                     }
[16:09:28.870]                     tryCatch({
[16:09:28.870]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.870]                     }, error = function(ex) {
[16:09:28.870]                       msg <- conditionMessage(ex)
[16:09:28.870]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.870]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.870]                         fi_tmp[["mtime"]], msg)
[16:09:28.870]                       ex$message <- msg
[16:09:28.870]                       stop(ex)
[16:09:28.870]                     })
[16:09:28.870]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.870]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.870]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.870]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.870]                       fi <- file.info(pathname)
[16:09:28.870]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.870]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.870]                         fi[["size"]], fi[["mtime"]])
[16:09:28.870]                       stop(msg)
[16:09:28.870]                     }
[16:09:28.870]                     invisible(pathname)
[16:09:28.870]                   }
[16:09:28.870]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.870]                     rootPath = tempdir()) 
[16:09:28.870]                   {
[16:09:28.870]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.870]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.870]                       tmpdir = path, fileext = ".rds")
[16:09:28.870]                     save_rds(obj, file)
[16:09:28.870]                   }
[16:09:28.870]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.870]                   {
[16:09:28.870]                     inherits <- base::inherits
[16:09:28.870]                     invokeRestart <- base::invokeRestart
[16:09:28.870]                     is.null <- base::is.null
[16:09:28.870]                     muffled <- FALSE
[16:09:28.870]                     if (inherits(cond, "message")) {
[16:09:28.870]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.870]                       if (muffled) 
[16:09:28.870]                         invokeRestart("muffleMessage")
[16:09:28.870]                     }
[16:09:28.870]                     else if (inherits(cond, "warning")) {
[16:09:28.870]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.870]                       if (muffled) 
[16:09:28.870]                         invokeRestart("muffleWarning")
[16:09:28.870]                     }
[16:09:28.870]                     else if (inherits(cond, "condition")) {
[16:09:28.870]                       if (!is.null(pattern)) {
[16:09:28.870]                         computeRestarts <- base::computeRestarts
[16:09:28.870]                         grepl <- base::grepl
[16:09:28.870]                         restarts <- computeRestarts(cond)
[16:09:28.870]                         for (restart in restarts) {
[16:09:28.870]                           name <- restart$name
[16:09:28.870]                           if (is.null(name)) 
[16:09:28.870]                             next
[16:09:28.870]                           if (!grepl(pattern, name)) 
[16:09:28.870]                             next
[16:09:28.870]                           invokeRestart(restart)
[16:09:28.870]                           muffled <- TRUE
[16:09:28.870]                           break
[16:09:28.870]                         }
[16:09:28.870]                       }
[16:09:28.870]                     }
[16:09:28.870]                     invisible(muffled)
[16:09:28.870]                   }
[16:09:28.870]                   muffleCondition(cond)
[16:09:28.870]                 })
[16:09:28.870]             }))
[16:09:28.870]             future::FutureResult(value = ...future.value$value, 
[16:09:28.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.870]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.870]                     ...future.globalenv.names))
[16:09:28.870]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.870]         }, condition = base::local({
[16:09:28.870]             c <- base::c
[16:09:28.870]             inherits <- base::inherits
[16:09:28.870]             invokeRestart <- base::invokeRestart
[16:09:28.870]             length <- base::length
[16:09:28.870]             list <- base::list
[16:09:28.870]             seq.int <- base::seq.int
[16:09:28.870]             signalCondition <- base::signalCondition
[16:09:28.870]             sys.calls <- base::sys.calls
[16:09:28.870]             `[[` <- base::`[[`
[16:09:28.870]             `+` <- base::`+`
[16:09:28.870]             `<<-` <- base::`<<-`
[16:09:28.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.870]                   3L)]
[16:09:28.870]             }
[16:09:28.870]             function(cond) {
[16:09:28.870]                 is_error <- inherits(cond, "error")
[16:09:28.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.870]                   NULL)
[16:09:28.870]                 if (is_error) {
[16:09:28.870]                   sessionInformation <- function() {
[16:09:28.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.870]                       search = base::search(), system = base::Sys.info())
[16:09:28.870]                   }
[16:09:28.870]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.870]                     cond$call), session = sessionInformation(), 
[16:09:28.870]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.870]                   signalCondition(cond)
[16:09:28.870]                 }
[16:09:28.870]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:09:28.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.870]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.870]                   if (TRUE && !signal) {
[16:09:28.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.870]                     {
[16:09:28.870]                       inherits <- base::inherits
[16:09:28.870]                       invokeRestart <- base::invokeRestart
[16:09:28.870]                       is.null <- base::is.null
[16:09:28.870]                       muffled <- FALSE
[16:09:28.870]                       if (inherits(cond, "message")) {
[16:09:28.870]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.870]                         if (muffled) 
[16:09:28.870]                           invokeRestart("muffleMessage")
[16:09:28.870]                       }
[16:09:28.870]                       else if (inherits(cond, "warning")) {
[16:09:28.870]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.870]                         if (muffled) 
[16:09:28.870]                           invokeRestart("muffleWarning")
[16:09:28.870]                       }
[16:09:28.870]                       else if (inherits(cond, "condition")) {
[16:09:28.870]                         if (!is.null(pattern)) {
[16:09:28.870]                           computeRestarts <- base::computeRestarts
[16:09:28.870]                           grepl <- base::grepl
[16:09:28.870]                           restarts <- computeRestarts(cond)
[16:09:28.870]                           for (restart in restarts) {
[16:09:28.870]                             name <- restart$name
[16:09:28.870]                             if (is.null(name)) 
[16:09:28.870]                               next
[16:09:28.870]                             if (!grepl(pattern, name)) 
[16:09:28.870]                               next
[16:09:28.870]                             invokeRestart(restart)
[16:09:28.870]                             muffled <- TRUE
[16:09:28.870]                             break
[16:09:28.870]                           }
[16:09:28.870]                         }
[16:09:28.870]                       }
[16:09:28.870]                       invisible(muffled)
[16:09:28.870]                     }
[16:09:28.870]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.870]                   }
[16:09:28.870]                 }
[16:09:28.870]                 else {
[16:09:28.870]                   if (TRUE) {
[16:09:28.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.870]                     {
[16:09:28.870]                       inherits <- base::inherits
[16:09:28.870]                       invokeRestart <- base::invokeRestart
[16:09:28.870]                       is.null <- base::is.null
[16:09:28.870]                       muffled <- FALSE
[16:09:28.870]                       if (inherits(cond, "message")) {
[16:09:28.870]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.870]                         if (muffled) 
[16:09:28.870]                           invokeRestart("muffleMessage")
[16:09:28.870]                       }
[16:09:28.870]                       else if (inherits(cond, "warning")) {
[16:09:28.870]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.870]                         if (muffled) 
[16:09:28.870]                           invokeRestart("muffleWarning")
[16:09:28.870]                       }
[16:09:28.870]                       else if (inherits(cond, "condition")) {
[16:09:28.870]                         if (!is.null(pattern)) {
[16:09:28.870]                           computeRestarts <- base::computeRestarts
[16:09:28.870]                           grepl <- base::grepl
[16:09:28.870]                           restarts <- computeRestarts(cond)
[16:09:28.870]                           for (restart in restarts) {
[16:09:28.870]                             name <- restart$name
[16:09:28.870]                             if (is.null(name)) 
[16:09:28.870]                               next
[16:09:28.870]                             if (!grepl(pattern, name)) 
[16:09:28.870]                               next
[16:09:28.870]                             invokeRestart(restart)
[16:09:28.870]                             muffled <- TRUE
[16:09:28.870]                             break
[16:09:28.870]                           }
[16:09:28.870]                         }
[16:09:28.870]                       }
[16:09:28.870]                       invisible(muffled)
[16:09:28.870]                     }
[16:09:28.870]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.870]                   }
[16:09:28.870]                 }
[16:09:28.870]             }
[16:09:28.870]         }))
[16:09:28.870]     }, error = function(ex) {
[16:09:28.870]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.870]                 ...future.rng), started = ...future.startTime, 
[16:09:28.870]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.870]             version = "1.8"), class = "FutureResult")
[16:09:28.870]     }, finally = {
[16:09:28.870]         if (!identical(...future.workdir, getwd())) 
[16:09:28.870]             setwd(...future.workdir)
[16:09:28.870]         {
[16:09:28.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.870]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.870]             }
[16:09:28.870]             base::options(...future.oldOptions)
[16:09:28.870]             if (.Platform$OS.type == "windows") {
[16:09:28.870]                 old_names <- names(...future.oldEnvVars)
[16:09:28.870]                 envs <- base::Sys.getenv()
[16:09:28.870]                 names <- names(envs)
[16:09:28.870]                 common <- intersect(names, old_names)
[16:09:28.870]                 added <- setdiff(names, old_names)
[16:09:28.870]                 removed <- setdiff(old_names, names)
[16:09:28.870]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.870]                   envs[common]]
[16:09:28.870]                 NAMES <- toupper(changed)
[16:09:28.870]                 args <- list()
[16:09:28.870]                 for (kk in seq_along(NAMES)) {
[16:09:28.870]                   name <- changed[[kk]]
[16:09:28.870]                   NAME <- NAMES[[kk]]
[16:09:28.870]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.870]                     next
[16:09:28.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.870]                 }
[16:09:28.870]                 NAMES <- toupper(added)
[16:09:28.870]                 for (kk in seq_along(NAMES)) {
[16:09:28.870]                   name <- added[[kk]]
[16:09:28.870]                   NAME <- NAMES[[kk]]
[16:09:28.870]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.870]                     next
[16:09:28.870]                   args[[name]] <- ""
[16:09:28.870]                 }
[16:09:28.870]                 NAMES <- toupper(removed)
[16:09:28.870]                 for (kk in seq_along(NAMES)) {
[16:09:28.870]                   name <- removed[[kk]]
[16:09:28.870]                   NAME <- NAMES[[kk]]
[16:09:28.870]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.870]                     next
[16:09:28.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.870]                 }
[16:09:28.870]                 if (length(args) > 0) 
[16:09:28.870]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.870]             }
[16:09:28.870]             else {
[16:09:28.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.870]             }
[16:09:28.870]             {
[16:09:28.870]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.870]                   0L) {
[16:09:28.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.870]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.870]                   base::options(opts)
[16:09:28.870]                 }
[16:09:28.870]                 {
[16:09:28.870]                   {
[16:09:28.870]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.870]                     NULL
[16:09:28.870]                   }
[16:09:28.870]                   options(future.plan = NULL)
[16:09:28.870]                   if (is.na(NA_character_)) 
[16:09:28.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.870]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.870]                     envir = parent.frame()) 
[16:09:28.870]                   {
[16:09:28.870]                     default_workers <- missing(workers)
[16:09:28.870]                     if (is.function(workers)) 
[16:09:28.870]                       workers <- workers()
[16:09:28.870]                     workers <- structure(as.integer(workers), 
[16:09:28.870]                       class = class(workers))
[16:09:28.870]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.870]                       1L)
[16:09:28.870]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.870]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.870]                       if (default_workers) 
[16:09:28.870]                         supportsMulticore(warn = TRUE)
[16:09:28.870]                       return(sequential(..., envir = envir))
[16:09:28.870]                     }
[16:09:28.870]                     oopts <- options(mc.cores = workers)
[16:09:28.870]                     on.exit(options(oopts))
[16:09:28.870]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.870]                       envir = envir)
[16:09:28.870]                     if (!future$lazy) 
[16:09:28.870]                       future <- run(future)
[16:09:28.870]                     invisible(future)
[16:09:28.870]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.870]                 }
[16:09:28.870]             }
[16:09:28.870]         }
[16:09:28.870]     })
[16:09:28.870]     if (TRUE) {
[16:09:28.870]         base::sink(type = "output", split = FALSE)
[16:09:28.870]         if (TRUE) {
[16:09:28.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.870]         }
[16:09:28.870]         else {
[16:09:28.870]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.870]         }
[16:09:28.870]         base::close(...future.stdout)
[16:09:28.870]         ...future.stdout <- NULL
[16:09:28.870]     }
[16:09:28.870]     ...future.result$conditions <- ...future.conditions
[16:09:28.870]     ...future.result$finished <- base::Sys.time()
[16:09:28.870]     ...future.result
[16:09:28.870] }
[16:09:28.873] assign_globals() ...
[16:09:28.873] List of 5
[16:09:28.873]  $ future.call.arguments    : list()
[16:09:28.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.873]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:09:28.873]  $ ...future.elements_ii    :List of 1
[16:09:28.873]   ..$ : int [1:2] 1 3
[16:09:28.873]  $ ...future.seeds_ii       :List of 1
[16:09:28.873]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:09:28.873]  $ ...future.globals.maxSize: NULL
[16:09:28.873]  - attr(*, "where")=List of 5
[16:09:28.873]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.873]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.873]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.873]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.873]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.873]  - attr(*, "resolved")= logi FALSE
[16:09:28.873]  - attr(*, "total_size")= num NA
[16:09:28.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.873]  - attr(*, "already-done")= logi TRUE
[16:09:28.878] - copied ‘future.call.arguments’ to environment
[16:09:28.878] - copied ‘...future.FUN’ to environment
[16:09:28.878] - copied ‘...future.elements_ii’ to environment
[16:09:28.878] - copied ‘...future.seeds_ii’ to environment
[16:09:28.878] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.879] assign_globals() ... done
[16:09:28.879] requestCore(): workers = 2
[16:09:28.881] MulticoreFuture started
[16:09:28.881] - Launch lazy future ... done
[16:09:28.882] run() for ‘MulticoreFuture’ ... done
[16:09:28.882] Created future:
[16:09:28.882] plan(): Setting new future strategy stack:
[16:09:28.882] List of future strategies:
[16:09:28.882] 1. sequential:
[16:09:28.882]    - args: function (..., envir = parent.frame())
[16:09:28.882]    - tweaked: FALSE
[16:09:28.882]    - call: NULL
[16:09:28.883] plan(): nbrOfWorkers() = 1
[16:09:28.885] plan(): Setting new future strategy stack:
[16:09:28.886] List of future strategies:
[16:09:28.886] 1. multicore:
[16:09:28.886]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.886]    - tweaked: FALSE
[16:09:28.886]    - call: plan(strategy)
[16:09:28.882] MulticoreFuture:
[16:09:28.882] Label: ‘future_apply-1’
[16:09:28.882] Expression:
[16:09:28.882] {
[16:09:28.882]     do.call(function(...) {
[16:09:28.882]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.882]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.882]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.882]             on.exit(options(oopts), add = TRUE)
[16:09:28.882]         }
[16:09:28.882]         {
[16:09:28.882]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.882]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.882]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:28.882]                   envir = globalenv(), inherits = FALSE)
[16:09:28.882]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.882]             })
[16:09:28.882]         }
[16:09:28.882]     }, args = future.call.arguments)
[16:09:28.882] }
[16:09:28.882] Lazy evaluation: FALSE
[16:09:28.882] Asynchronous evaluation: TRUE
[16:09:28.882] Local evaluation: TRUE
[16:09:28.882] Environment: R_GlobalEnv
[16:09:28.882] Capture standard output: TRUE
[16:09:28.882] Capture condition classes: <none>
[16:09:28.882] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.882] Packages: <none>
[16:09:28.882] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:09:28.882] Resolved: FALSE
[16:09:28.882] Value: <not collected>
[16:09:28.882] Conditions captured: <none>
[16:09:28.882] Early signaling: FALSE
[16:09:28.882] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.882] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.895] Chunk #1 of 2 ... DONE
[16:09:28.895] Chunk #2 of 2 ...
[16:09:28.896]  - seeds: [1] <seeds>
[16:09:28.896] getGlobalsAndPackages() ...
[16:09:28.896] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.896] Resolving globals: FALSE
[16:09:28.896] Tweak future expression to call with '...' arguments ...
[16:09:28.897] {
[16:09:28.897]     do.call(function(...) {
[16:09:28.897]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.897]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.897]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.897]             on.exit(options(oopts), add = TRUE)
[16:09:28.897]         }
[16:09:28.897]         {
[16:09:28.897]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.897]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.897]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:28.897]                   envir = globalenv(), inherits = FALSE)
[16:09:28.897]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.897]             })
[16:09:28.897]         }
[16:09:28.897]     }, args = future.call.arguments)
[16:09:28.897] }
[16:09:28.900] plan(): nbrOfWorkers() = 2
[16:09:28.897] Tweak future expression to call with '...' arguments ... DONE
[16:09:28.903] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:28.904] 
[16:09:28.904] getGlobalsAndPackages() ... DONE
[16:09:28.904] run() for ‘Future’ ...
[16:09:28.904] - state: ‘created’
[16:09:28.904] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:09:28.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:09:28.910]   - Field: ‘label’
[16:09:28.911]   - Field: ‘local’
[16:09:28.911]   - Field: ‘owner’
[16:09:28.911]   - Field: ‘envir’
[16:09:28.911]   - Field: ‘workers’
[16:09:28.911]   - Field: ‘packages’
[16:09:28.912]   - Field: ‘gc’
[16:09:28.912]   - Field: ‘job’
[16:09:28.912]   - Field: ‘conditions’
[16:09:28.912]   - Field: ‘expr’
[16:09:28.913]   - Field: ‘uuid’
[16:09:28.913]   - Field: ‘seed’
[16:09:28.913]   - Field: ‘version’
[16:09:28.913]   - Field: ‘result’
[16:09:28.913]   - Field: ‘asynchronous’
[16:09:28.914]   - Field: ‘calls’
[16:09:28.914]   - Field: ‘globals’
[16:09:28.914]   - Field: ‘stdout’
[16:09:28.914]   - Field: ‘earlySignal’
[16:09:28.914]   - Field: ‘lazy’
[16:09:28.914]   - Field: ‘state’
[16:09:28.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:09:28.915] - Launch lazy future ...
[16:09:28.915] Packages needed by the future expression (n = 0): <none>
[16:09:28.915] Packages needed by future strategies (n = 0): <none>
[16:09:28.916] {
[16:09:28.916]     {
[16:09:28.916]         {
[16:09:28.916]             ...future.startTime <- base::Sys.time()
[16:09:28.916]             {
[16:09:28.916]                 {
[16:09:28.916]                   {
[16:09:28.916]                     {
[16:09:28.916]                       base::local({
[16:09:28.916]                         has_future <- base::requireNamespace("future", 
[16:09:28.916]                           quietly = TRUE)
[16:09:28.916]                         if (has_future) {
[16:09:28.916]                           ns <- base::getNamespace("future")
[16:09:28.916]                           version <- ns[[".package"]][["version"]]
[16:09:28.916]                           if (is.null(version)) 
[16:09:28.916]                             version <- utils::packageVersion("future")
[16:09:28.916]                         }
[16:09:28.916]                         else {
[16:09:28.916]                           version <- NULL
[16:09:28.916]                         }
[16:09:28.916]                         if (!has_future || version < "1.8.0") {
[16:09:28.916]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:28.916]                             "", base::R.version$version.string), 
[16:09:28.916]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:28.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:28.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:28.916]                               "release", "version")], collapse = " "), 
[16:09:28.916]                             hostname = base::Sys.info()[["nodename"]])
[16:09:28.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:28.916]                             info)
[16:09:28.916]                           info <- base::paste(info, collapse = "; ")
[16:09:28.916]                           if (!has_future) {
[16:09:28.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:28.916]                               info)
[16:09:28.916]                           }
[16:09:28.916]                           else {
[16:09:28.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:28.916]                               info, version)
[16:09:28.916]                           }
[16:09:28.916]                           base::stop(msg)
[16:09:28.916]                         }
[16:09:28.916]                       })
[16:09:28.916]                     }
[16:09:28.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:28.916]                     base::options(mc.cores = 1L)
[16:09:28.916]                   }
[16:09:28.916]                   options(future.plan = NULL)
[16:09:28.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:28.916]                 }
[16:09:28.916]                 ...future.workdir <- getwd()
[16:09:28.916]             }
[16:09:28.916]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:28.916]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:28.916]         }
[16:09:28.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:28.916]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:28.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:28.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:28.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:28.916]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:28.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:28.916]             base::names(...future.oldOptions))
[16:09:28.916]     }
[16:09:28.916]     if (FALSE) {
[16:09:28.916]     }
[16:09:28.916]     else {
[16:09:28.916]         if (TRUE) {
[16:09:28.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:28.916]                 open = "w")
[16:09:28.916]         }
[16:09:28.916]         else {
[16:09:28.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:28.916]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:28.916]         }
[16:09:28.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:28.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:28.916]             base::sink(type = "output", split = FALSE)
[16:09:28.916]             base::close(...future.stdout)
[16:09:28.916]         }, add = TRUE)
[16:09:28.916]     }
[16:09:28.916]     ...future.frame <- base::sys.nframe()
[16:09:28.916]     ...future.conditions <- base::list()
[16:09:28.916]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:28.916]     if (FALSE) {
[16:09:28.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:28.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:28.916]     }
[16:09:28.916]     ...future.result <- base::tryCatch({
[16:09:28.916]         base::withCallingHandlers({
[16:09:28.916]             ...future.value <- base::withVisible(base::local({
[16:09:28.916]                 withCallingHandlers({
[16:09:28.916]                   {
[16:09:28.916]                     do.call(function(...) {
[16:09:28.916]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.916]                       if (!identical(...future.globals.maxSize.org, 
[16:09:28.916]                         ...future.globals.maxSize)) {
[16:09:28.916]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.916]                         on.exit(options(oopts), add = TRUE)
[16:09:28.916]                       }
[16:09:28.916]                       {
[16:09:28.916]                         lapply(seq_along(...future.elements_ii), 
[16:09:28.916]                           FUN = function(jj) {
[16:09:28.916]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.916]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:28.916]                               envir = globalenv(), inherits = FALSE)
[16:09:28.916]                             ...future.FUN(...future.X_jj, ...)
[16:09:28.916]                           })
[16:09:28.916]                       }
[16:09:28.916]                     }, args = future.call.arguments)
[16:09:28.916]                   }
[16:09:28.916]                 }, immediateCondition = function(cond) {
[16:09:28.916]                   save_rds <- function (object, pathname, ...) 
[16:09:28.916]                   {
[16:09:28.916]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:09:28.916]                     if (file_test("-f", pathname_tmp)) {
[16:09:28.916]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.916]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:09:28.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.916]                         fi_tmp[["mtime"]])
[16:09:28.916]                     }
[16:09:28.916]                     tryCatch({
[16:09:28.916]                       saveRDS(object, file = pathname_tmp, ...)
[16:09:28.916]                     }, error = function(ex) {
[16:09:28.916]                       msg <- conditionMessage(ex)
[16:09:28.916]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.916]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:09:28.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.916]                         fi_tmp[["mtime"]], msg)
[16:09:28.916]                       ex$message <- msg
[16:09:28.916]                       stop(ex)
[16:09:28.916]                     })
[16:09:28.916]                     stopifnot(file_test("-f", pathname_tmp))
[16:09:28.916]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:09:28.916]                     if (!res || file_test("-f", pathname_tmp)) {
[16:09:28.916]                       fi_tmp <- file.info(pathname_tmp)
[16:09:28.916]                       fi <- file.info(pathname)
[16:09:28.916]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:09:28.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:09:28.916]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:09:28.916]                         fi[["size"]], fi[["mtime"]])
[16:09:28.916]                       stop(msg)
[16:09:28.916]                     }
[16:09:28.916]                     invisible(pathname)
[16:09:28.916]                   }
[16:09:28.916]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:09:28.916]                     rootPath = tempdir()) 
[16:09:28.916]                   {
[16:09:28.916]                     obj <- list(time = Sys.time(), condition = cond)
[16:09:28.916]                     file <- tempfile(pattern = class(cond)[1], 
[16:09:28.916]                       tmpdir = path, fileext = ".rds")
[16:09:28.916]                     save_rds(obj, file)
[16:09:28.916]                   }
[16:09:28.916]                   saveImmediateCondition(cond, path = "/tmp/RtmpgebZTl/.future/immediateConditions")
[16:09:28.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.916]                   {
[16:09:28.916]                     inherits <- base::inherits
[16:09:28.916]                     invokeRestart <- base::invokeRestart
[16:09:28.916]                     is.null <- base::is.null
[16:09:28.916]                     muffled <- FALSE
[16:09:28.916]                     if (inherits(cond, "message")) {
[16:09:28.916]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:28.916]                       if (muffled) 
[16:09:28.916]                         invokeRestart("muffleMessage")
[16:09:28.916]                     }
[16:09:28.916]                     else if (inherits(cond, "warning")) {
[16:09:28.916]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:28.916]                       if (muffled) 
[16:09:28.916]                         invokeRestart("muffleWarning")
[16:09:28.916]                     }
[16:09:28.916]                     else if (inherits(cond, "condition")) {
[16:09:28.916]                       if (!is.null(pattern)) {
[16:09:28.916]                         computeRestarts <- base::computeRestarts
[16:09:28.916]                         grepl <- base::grepl
[16:09:28.916]                         restarts <- computeRestarts(cond)
[16:09:28.916]                         for (restart in restarts) {
[16:09:28.916]                           name <- restart$name
[16:09:28.916]                           if (is.null(name)) 
[16:09:28.916]                             next
[16:09:28.916]                           if (!grepl(pattern, name)) 
[16:09:28.916]                             next
[16:09:28.916]                           invokeRestart(restart)
[16:09:28.916]                           muffled <- TRUE
[16:09:28.916]                           break
[16:09:28.916]                         }
[16:09:28.916]                       }
[16:09:28.916]                     }
[16:09:28.916]                     invisible(muffled)
[16:09:28.916]                   }
[16:09:28.916]                   muffleCondition(cond)
[16:09:28.916]                 })
[16:09:28.916]             }))
[16:09:28.916]             future::FutureResult(value = ...future.value$value, 
[16:09:28.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.916]                   ...future.rng), globalenv = if (FALSE) 
[16:09:28.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:28.916]                     ...future.globalenv.names))
[16:09:28.916]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:28.916]         }, condition = base::local({
[16:09:28.916]             c <- base::c
[16:09:28.916]             inherits <- base::inherits
[16:09:28.916]             invokeRestart <- base::invokeRestart
[16:09:28.916]             length <- base::length
[16:09:28.916]             list <- base::list
[16:09:28.916]             seq.int <- base::seq.int
[16:09:28.916]             signalCondition <- base::signalCondition
[16:09:28.916]             sys.calls <- base::sys.calls
[16:09:28.916]             `[[` <- base::`[[`
[16:09:28.916]             `+` <- base::`+`
[16:09:28.916]             `<<-` <- base::`<<-`
[16:09:28.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:28.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:28.916]                   3L)]
[16:09:28.916]             }
[16:09:28.916]             function(cond) {
[16:09:28.916]                 is_error <- inherits(cond, "error")
[16:09:28.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:28.916]                   NULL)
[16:09:28.916]                 if (is_error) {
[16:09:28.916]                   sessionInformation <- function() {
[16:09:28.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:28.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:28.916]                       search = base::search(), system = base::Sys.info())
[16:09:28.916]                   }
[16:09:28.916]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:28.916]                     cond$call), session = sessionInformation(), 
[16:09:28.916]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:28.916]                   signalCondition(cond)
[16:09:28.916]                 }
[16:09:28.916]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:09:28.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:28.916]                   ...future.conditions[[length(...future.conditions) + 
[16:09:28.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:28.916]                   if (TRUE && !signal) {
[16:09:28.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.916]                     {
[16:09:28.916]                       inherits <- base::inherits
[16:09:28.916]                       invokeRestart <- base::invokeRestart
[16:09:28.916]                       is.null <- base::is.null
[16:09:28.916]                       muffled <- FALSE
[16:09:28.916]                       if (inherits(cond, "message")) {
[16:09:28.916]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.916]                         if (muffled) 
[16:09:28.916]                           invokeRestart("muffleMessage")
[16:09:28.916]                       }
[16:09:28.916]                       else if (inherits(cond, "warning")) {
[16:09:28.916]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.916]                         if (muffled) 
[16:09:28.916]                           invokeRestart("muffleWarning")
[16:09:28.916]                       }
[16:09:28.916]                       else if (inherits(cond, "condition")) {
[16:09:28.916]                         if (!is.null(pattern)) {
[16:09:28.916]                           computeRestarts <- base::computeRestarts
[16:09:28.916]                           grepl <- base::grepl
[16:09:28.916]                           restarts <- computeRestarts(cond)
[16:09:28.916]                           for (restart in restarts) {
[16:09:28.916]                             name <- restart$name
[16:09:28.916]                             if (is.null(name)) 
[16:09:28.916]                               next
[16:09:28.916]                             if (!grepl(pattern, name)) 
[16:09:28.916]                               next
[16:09:28.916]                             invokeRestart(restart)
[16:09:28.916]                             muffled <- TRUE
[16:09:28.916]                             break
[16:09:28.916]                           }
[16:09:28.916]                         }
[16:09:28.916]                       }
[16:09:28.916]                       invisible(muffled)
[16:09:28.916]                     }
[16:09:28.916]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.916]                   }
[16:09:28.916]                 }
[16:09:28.916]                 else {
[16:09:28.916]                   if (TRUE) {
[16:09:28.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:28.916]                     {
[16:09:28.916]                       inherits <- base::inherits
[16:09:28.916]                       invokeRestart <- base::invokeRestart
[16:09:28.916]                       is.null <- base::is.null
[16:09:28.916]                       muffled <- FALSE
[16:09:28.916]                       if (inherits(cond, "message")) {
[16:09:28.916]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:28.916]                         if (muffled) 
[16:09:28.916]                           invokeRestart("muffleMessage")
[16:09:28.916]                       }
[16:09:28.916]                       else if (inherits(cond, "warning")) {
[16:09:28.916]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:28.916]                         if (muffled) 
[16:09:28.916]                           invokeRestart("muffleWarning")
[16:09:28.916]                       }
[16:09:28.916]                       else if (inherits(cond, "condition")) {
[16:09:28.916]                         if (!is.null(pattern)) {
[16:09:28.916]                           computeRestarts <- base::computeRestarts
[16:09:28.916]                           grepl <- base::grepl
[16:09:28.916]                           restarts <- computeRestarts(cond)
[16:09:28.916]                           for (restart in restarts) {
[16:09:28.916]                             name <- restart$name
[16:09:28.916]                             if (is.null(name)) 
[16:09:28.916]                               next
[16:09:28.916]                             if (!grepl(pattern, name)) 
[16:09:28.916]                               next
[16:09:28.916]                             invokeRestart(restart)
[16:09:28.916]                             muffled <- TRUE
[16:09:28.916]                             break
[16:09:28.916]                           }
[16:09:28.916]                         }
[16:09:28.916]                       }
[16:09:28.916]                       invisible(muffled)
[16:09:28.916]                     }
[16:09:28.916]                     muffleCondition(cond, pattern = "^muffle")
[16:09:28.916]                   }
[16:09:28.916]                 }
[16:09:28.916]             }
[16:09:28.916]         }))
[16:09:28.916]     }, error = function(ex) {
[16:09:28.916]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:28.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:28.916]                 ...future.rng), started = ...future.startTime, 
[16:09:28.916]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:28.916]             version = "1.8"), class = "FutureResult")
[16:09:28.916]     }, finally = {
[16:09:28.916]         if (!identical(...future.workdir, getwd())) 
[16:09:28.916]             setwd(...future.workdir)
[16:09:28.916]         {
[16:09:28.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:28.916]                 ...future.oldOptions$nwarnings <- NULL
[16:09:28.916]             }
[16:09:28.916]             base::options(...future.oldOptions)
[16:09:28.916]             if (.Platform$OS.type == "windows") {
[16:09:28.916]                 old_names <- names(...future.oldEnvVars)
[16:09:28.916]                 envs <- base::Sys.getenv()
[16:09:28.916]                 names <- names(envs)
[16:09:28.916]                 common <- intersect(names, old_names)
[16:09:28.916]                 added <- setdiff(names, old_names)
[16:09:28.916]                 removed <- setdiff(old_names, names)
[16:09:28.916]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:28.916]                   envs[common]]
[16:09:28.916]                 NAMES <- toupper(changed)
[16:09:28.916]                 args <- list()
[16:09:28.916]                 for (kk in seq_along(NAMES)) {
[16:09:28.916]                   name <- changed[[kk]]
[16:09:28.916]                   NAME <- NAMES[[kk]]
[16:09:28.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.916]                     next
[16:09:28.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.916]                 }
[16:09:28.916]                 NAMES <- toupper(added)
[16:09:28.916]                 for (kk in seq_along(NAMES)) {
[16:09:28.916]                   name <- added[[kk]]
[16:09:28.916]                   NAME <- NAMES[[kk]]
[16:09:28.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.916]                     next
[16:09:28.916]                   args[[name]] <- ""
[16:09:28.916]                 }
[16:09:28.916]                 NAMES <- toupper(removed)
[16:09:28.916]                 for (kk in seq_along(NAMES)) {
[16:09:28.916]                   name <- removed[[kk]]
[16:09:28.916]                   NAME <- NAMES[[kk]]
[16:09:28.916]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:28.916]                     next
[16:09:28.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:28.916]                 }
[16:09:28.916]                 if (length(args) > 0) 
[16:09:28.916]                   base::do.call(base::Sys.setenv, args = args)
[16:09:28.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:28.916]             }
[16:09:28.916]             else {
[16:09:28.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:28.916]             }
[16:09:28.916]             {
[16:09:28.916]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:28.916]                   0L) {
[16:09:28.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:28.916]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:28.916]                   base::options(opts)
[16:09:28.916]                 }
[16:09:28.916]                 {
[16:09:28.916]                   {
[16:09:28.916]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:28.916]                     NULL
[16:09:28.916]                   }
[16:09:28.916]                   options(future.plan = NULL)
[16:09:28.916]                   if (is.na(NA_character_)) 
[16:09:28.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:28.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:28.916]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:09:28.916]                     envir = parent.frame()) 
[16:09:28.916]                   {
[16:09:28.916]                     default_workers <- missing(workers)
[16:09:28.916]                     if (is.function(workers)) 
[16:09:28.916]                       workers <- workers()
[16:09:28.916]                     workers <- structure(as.integer(workers), 
[16:09:28.916]                       class = class(workers))
[16:09:28.916]                     stop_if_not(is.finite(workers), workers >= 
[16:09:28.916]                       1L)
[16:09:28.916]                     if ((workers == 1L && !inherits(workers, 
[16:09:28.916]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:09:28.916]                       if (default_workers) 
[16:09:28.916]                         supportsMulticore(warn = TRUE)
[16:09:28.916]                       return(sequential(..., envir = envir))
[16:09:28.916]                     }
[16:09:28.916]                     oopts <- options(mc.cores = workers)
[16:09:28.916]                     on.exit(options(oopts))
[16:09:28.916]                     future <- MulticoreFuture(..., workers = workers, 
[16:09:28.916]                       envir = envir)
[16:09:28.916]                     if (!future$lazy) 
[16:09:28.916]                       future <- run(future)
[16:09:28.916]                     invisible(future)
[16:09:28.916]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:28.916]                 }
[16:09:28.916]             }
[16:09:28.916]         }
[16:09:28.916]     })
[16:09:28.916]     if (TRUE) {
[16:09:28.916]         base::sink(type = "output", split = FALSE)
[16:09:28.916]         if (TRUE) {
[16:09:28.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:28.916]         }
[16:09:28.916]         else {
[16:09:28.916]             ...future.result["stdout"] <- base::list(NULL)
[16:09:28.916]         }
[16:09:28.916]         base::close(...future.stdout)
[16:09:28.916]         ...future.stdout <- NULL
[16:09:28.916]     }
[16:09:28.916]     ...future.result$conditions <- ...future.conditions
[16:09:28.916]     ...future.result$finished <- base::Sys.time()
[16:09:28.916]     ...future.result
[16:09:28.916] }
[16:09:28.919] assign_globals() ...
[16:09:28.919] List of 5
[16:09:28.919]  $ future.call.arguments    : list()
[16:09:28.919]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:28.919]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:09:28.919]  $ ...future.elements_ii    :List of 1
[16:09:28.919]   ..$ : int [1:2] 2 4
[16:09:28.919]  $ ...future.seeds_ii       :List of 1
[16:09:28.919]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:09:28.919]  $ ...future.globals.maxSize: NULL
[16:09:28.919]  - attr(*, "where")=List of 5
[16:09:28.919]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:09:28.919]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:09:28.919]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:09:28.919]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:09:28.919]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:09:28.919]  - attr(*, "resolved")= logi FALSE
[16:09:28.919]  - attr(*, "total_size")= num NA
[16:09:28.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:28.919]  - attr(*, "already-done")= logi TRUE
[16:09:28.927] - copied ‘future.call.arguments’ to environment
[16:09:28.927] - copied ‘...future.FUN’ to environment
[16:09:28.927] - copied ‘...future.elements_ii’ to environment
[16:09:28.927] - copied ‘...future.seeds_ii’ to environment
[16:09:28.927] - copied ‘...future.globals.maxSize’ to environment
[16:09:28.927] assign_globals() ... done
[16:09:28.927] requestCore(): workers = 2
[16:09:28.930] MulticoreFuture started
[16:09:28.930] - Launch lazy future ... done
[16:09:28.930] run() for ‘MulticoreFuture’ ... done
[16:09:28.931] Created future:
[16:09:28.931] plan(): Setting new future strategy stack:
[16:09:28.931] List of future strategies:
[16:09:28.931] 1. sequential:
[16:09:28.931]    - args: function (..., envir = parent.frame())
[16:09:28.931]    - tweaked: FALSE
[16:09:28.931]    - call: NULL
[16:09:28.932] plan(): nbrOfWorkers() = 1
[16:09:28.934] plan(): Setting new future strategy stack:
[16:09:28.934] List of future strategies:
[16:09:28.934] 1. multicore:
[16:09:28.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:09:28.934]    - tweaked: FALSE
[16:09:28.934]    - call: plan(strategy)
[16:09:28.940] plan(): nbrOfWorkers() = 2
[16:09:28.931] MulticoreFuture:
[16:09:28.931] Label: ‘future_apply-2’
[16:09:28.931] Expression:
[16:09:28.931] {
[16:09:28.931]     do.call(function(...) {
[16:09:28.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:28.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:28.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:28.931]             on.exit(options(oopts), add = TRUE)
[16:09:28.931]         }
[16:09:28.931]         {
[16:09:28.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:28.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:28.931]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:28.931]                   envir = globalenv(), inherits = FALSE)
[16:09:28.931]                 ...future.FUN(...future.X_jj, ...)
[16:09:28.931]             })
[16:09:28.931]         }
[16:09:28.931]     }, args = future.call.arguments)
[16:09:28.931] }
[16:09:28.931] Lazy evaluation: FALSE
[16:09:28.931] Asynchronous evaluation: TRUE
[16:09:28.931] Local evaluation: TRUE
[16:09:28.931] Environment: R_GlobalEnv
[16:09:28.931] Capture standard output: TRUE
[16:09:28.931] Capture condition classes: <none>
[16:09:28.931] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:28.931] Packages: <none>
[16:09:28.931] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:09:28.931] Resolved: TRUE
[16:09:28.931] Value: <not collected>
[16:09:28.931] Conditions captured: <none>
[16:09:28.931] Early signaling: FALSE
[16:09:28.931] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:28.931] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:28.941] Chunk #2 of 2 ... DONE
[16:09:28.941] Launching 2 futures (chunks) ... DONE
[16:09:28.941] Resolving 2 futures (chunks) ...
[16:09:28.941] resolve() on list ...
[16:09:28.941]  recursive: 0
[16:09:28.942]  length: 2
[16:09:28.942] 
[16:09:28.942] Future #1
[16:09:28.943] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:09:28.943] - nx: 2
[16:09:28.943] - relay: TRUE
[16:09:28.944] - stdout: TRUE
[16:09:28.944] - signal: TRUE
[16:09:28.944] - resignal: FALSE
[16:09:28.944] - force: TRUE
[16:09:28.944] - relayed: [n=2] FALSE, FALSE
[16:09:28.944] - queued futures: [n=2] FALSE, FALSE
[16:09:28.945]  - until=1
[16:09:28.945]  - relaying element #1
[16:09:28.945] - relayed: [n=2] TRUE, FALSE
[16:09:28.945] - queued futures: [n=2] TRUE, FALSE
[16:09:28.945] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:09:28.946]  length: 1 (resolved future 1)
[16:09:28.946] Future #2
[16:09:28.947] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:09:28.947] - nx: 2
[16:09:28.947] - relay: TRUE
[16:09:28.947] - stdout: TRUE
[16:09:28.947] - signal: TRUE
[16:09:28.947] - resignal: FALSE
[16:09:28.947] - force: TRUE
[16:09:28.948] - relayed: [n=2] TRUE, FALSE
[16:09:28.948] - queued futures: [n=2] TRUE, FALSE
[16:09:28.948]  - until=2
[16:09:28.948]  - relaying element #2
[16:09:28.948] - relayed: [n=2] TRUE, TRUE
[16:09:28.948] - queued futures: [n=2] TRUE, TRUE
[16:09:28.948] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:09:28.949]  length: 0 (resolved future 2)
[16:09:28.949] Relaying remaining futures
[16:09:28.949] signalConditionsASAP(NULL, pos=0) ...
[16:09:28.949] - nx: 2
[16:09:28.949] - relay: TRUE
[16:09:28.949] - stdout: TRUE
[16:09:28.949] - signal: TRUE
[16:09:28.949] - resignal: FALSE
[16:09:28.949] - force: TRUE
[16:09:28.950] - relayed: [n=2] TRUE, TRUE
[16:09:28.950] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:28.950] - relayed: [n=2] TRUE, TRUE
[16:09:28.950] - queued futures: [n=2] TRUE, TRUE
[16:09:28.950] signalConditionsASAP(NULL, pos=0) ... done
[16:09:28.950] resolve() on list ... DONE
[16:09:28.953]  - Number of value chunks collected: 2
[16:09:28.953] Resolving 2 futures (chunks) ... DONE
[16:09:28.953] Reducing values from 2 chunks ...
[16:09:28.954]  - Number of values collected after concatenation: 2
[16:09:28.954]  - Number of values expected: 2
[16:09:28.954] Reducing values from 2 chunks ... DONE
[16:09:28.954] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:09:28.955] plan(): Setting new future strategy stack:
[16:09:28.955] List of future strategies:
[16:09:28.955] 1. sequential:
[16:09:28.955]    - args: function (..., envir = parent.frame())
[16:09:28.955]    - tweaked: FALSE
[16:09:28.955]    - call: plan(sequential)
[16:09:28.955] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:09:28.956] plan(): Setting new future strategy stack:
[16:09:28.956] List of future strategies:
[16:09:28.956] 1. multisession:
[16:09:28.956]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:28.956]    - tweaked: FALSE
[16:09:28.956]    - call: plan(strategy)
[16:09:28.957] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:09:28.957] multisession:
[16:09:28.957] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:09:28.957] - tweaked: FALSE
[16:09:28.957] - call: plan(strategy)
[16:09:28.965] getGlobalsAndPackages() ...
[16:09:28.965] Not searching for globals
[16:09:28.965] - globals: [0] <none>
[16:09:28.965] getGlobalsAndPackages() ... DONE
[16:09:28.965] [local output] makeClusterPSOCK() ...
[16:09:29.004] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:09:29.010] [local output] Base port: 11676
[16:09:29.010] [local output] Getting setup options for 2 cluster nodes ...
[16:09:29.010] [local output]  - Node 1 of 2 ...
[16:09:29.010] [local output] localMachine=TRUE => revtunnel=FALSE

[16:09:29.011] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpgebZTl/worker.rank=1.parallelly.parent=68792.10cb8d3e9d70.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpgebZTl/worker.rank=1.parallelly.parent=68792.10cb8d3e9d70.pid")'’
[16:09:29.200] - Possible to infer worker's PID: TRUE
[16:09:29.200] [local output] Rscript port: 11676

[16:09:29.201] [local output]  - Node 2 of 2 ...
[16:09:29.201] [local output] localMachine=TRUE => revtunnel=FALSE

[16:09:29.202] [local output] Rscript port: 11676

[16:09:29.202] [local output] Getting setup options for 2 cluster nodes ... done
[16:09:29.202] [local output]  - Parallel setup requested for some PSOCK nodes
[16:09:29.203] [local output] Setting up PSOCK nodes in parallel
[16:09:29.203] List of 36
[16:09:29.203]  $ worker          : chr "localhost"
[16:09:29.203]   ..- attr(*, "localhost")= logi TRUE
[16:09:29.203]  $ master          : chr "localhost"
[16:09:29.203]  $ port            : int 11676
[16:09:29.203]  $ connectTimeout  : num 120
[16:09:29.203]  $ timeout         : num 2592000
[16:09:29.203]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:09:29.203]  $ homogeneous     : logi TRUE
[16:09:29.203]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:09:29.203]  $ rscript_envs    : NULL
[16:09:29.203]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:09:29.203]  $ rscript_startup : NULL
[16:09:29.203]  $ rscript_sh      : chr "sh"
[16:09:29.203]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:09:29.203]  $ methods         : logi TRUE
[16:09:29.203]  $ socketOptions   : chr "no-delay"
[16:09:29.203]  $ useXDR          : logi FALSE
[16:09:29.203]  $ outfile         : chr "/dev/null"
[16:09:29.203]  $ renice          : int NA
[16:09:29.203]  $ rshcmd          : NULL
[16:09:29.203]  $ user            : chr(0) 
[16:09:29.203]  $ revtunnel       : logi FALSE
[16:09:29.203]  $ rshlogfile      : NULL
[16:09:29.203]  $ rshopts         : chr(0) 
[16:09:29.203]  $ rank            : int 1
[16:09:29.203]  $ manual          : logi FALSE
[16:09:29.203]  $ dryrun          : logi FALSE
[16:09:29.203]  $ quiet           : logi FALSE
[16:09:29.203]  $ setup_strategy  : chr "parallel"
[16:09:29.203]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:09:29.203]  $ pidfile         : chr "/tmp/RtmpgebZTl/worker.rank=1.parallelly.parent=68792.10cb8d3e9d70.pid"
[16:09:29.203]  $ rshcmd_label    : NULL
[16:09:29.203]  $ rsh_call        : NULL
[16:09:29.203]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:09:29.203]  $ localMachine    : logi TRUE
[16:09:29.203]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:09:29.203]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:09:29.203]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:09:29.203]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:09:29.203]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:09:29.203]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:09:29.203]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:09:29.203]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:09:29.203]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:09:29.203]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:09:29.203]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:09:29.203]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:09:29.203]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:09:29.203]  $ arguments       :List of 28
[16:09:29.203]   ..$ worker          : chr "localhost"
[16:09:29.203]   ..$ master          : NULL
[16:09:29.203]   ..$ port            : int 11676
[16:09:29.203]   ..$ connectTimeout  : num 120
[16:09:29.203]   ..$ timeout         : num 2592000
[16:09:29.203]   ..$ rscript         : NULL
[16:09:29.203]   ..$ homogeneous     : NULL
[16:09:29.203]   ..$ rscript_args    : NULL
[16:09:29.203]   ..$ rscript_envs    : NULL
[16:09:29.203]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:09:29.203]   ..$ rscript_startup : NULL
[16:09:29.203]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:09:29.203]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:09:29.203]   ..$ methods         : logi TRUE
[16:09:29.203]   ..$ socketOptions   : chr "no-delay"
[16:09:29.203]   ..$ useXDR          : logi FALSE
[16:09:29.203]   ..$ outfile         : chr "/dev/null"
[16:09:29.203]   ..$ renice          : int NA
[16:09:29.203]   ..$ rshcmd          : NULL
[16:09:29.203]   ..$ user            : NULL
[16:09:29.203]   ..$ revtunnel       : logi NA
[16:09:29.203]   ..$ rshlogfile      : NULL
[16:09:29.203]   ..$ rshopts         : NULL
[16:09:29.203]   ..$ rank            : int 1
[16:09:29.203]   ..$ manual          : logi FALSE
[16:09:29.203]   ..$ dryrun          : logi FALSE
[16:09:29.203]   ..$ quiet           : logi FALSE
[16:09:29.203]   ..$ setup_strategy  : chr "parallel"
[16:09:29.203]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:09:29.220] [local output] System call to launch all workers:
[16:09:29.220] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpgebZTl/worker.rank=1.parallelly.parent=68792.10cb8d3e9d70.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11676 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:09:29.220] [local output] Starting PSOCK main server
[16:09:29.222] [local output] Workers launched
[16:09:29.222] [local output] Waiting for workers to connect back
[16:09:29.222]  - [local output] 0 workers out of 2 ready
[16:09:29.466]  - [local output] 0 workers out of 2 ready
[16:09:29.467]  - [local output] 1 workers out of 2 ready
[16:09:29.470]  - [local output] 1 workers out of 2 ready
[16:09:29.470]  - [local output] 2 workers out of 2 ready
[16:09:29.470] [local output] Launching of workers completed
[16:09:29.470] [local output] Collecting session information from workers
[16:09:29.471] [local output]  - Worker #1 of 2
[16:09:29.472] [local output]  - Worker #2 of 2
[16:09:29.472] [local output] makeClusterPSOCK() ... done
[16:09:29.484] Packages needed by the future expression (n = 0): <none>
[16:09:29.484] Packages needed by future strategies (n = 0): <none>
[16:09:29.485] {
[16:09:29.485]     {
[16:09:29.485]         {
[16:09:29.485]             ...future.startTime <- base::Sys.time()
[16:09:29.485]             {
[16:09:29.485]                 {
[16:09:29.485]                   {
[16:09:29.485]                     {
[16:09:29.485]                       base::local({
[16:09:29.485]                         has_future <- base::requireNamespace("future", 
[16:09:29.485]                           quietly = TRUE)
[16:09:29.485]                         if (has_future) {
[16:09:29.485]                           ns <- base::getNamespace("future")
[16:09:29.485]                           version <- ns[[".package"]][["version"]]
[16:09:29.485]                           if (is.null(version)) 
[16:09:29.485]                             version <- utils::packageVersion("future")
[16:09:29.485]                         }
[16:09:29.485]                         else {
[16:09:29.485]                           version <- NULL
[16:09:29.485]                         }
[16:09:29.485]                         if (!has_future || version < "1.8.0") {
[16:09:29.485]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:29.485]                             "", base::R.version$version.string), 
[16:09:29.485]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:29.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:29.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:29.485]                               "release", "version")], collapse = " "), 
[16:09:29.485]                             hostname = base::Sys.info()[["nodename"]])
[16:09:29.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:29.485]                             info)
[16:09:29.485]                           info <- base::paste(info, collapse = "; ")
[16:09:29.485]                           if (!has_future) {
[16:09:29.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:29.485]                               info)
[16:09:29.485]                           }
[16:09:29.485]                           else {
[16:09:29.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:29.485]                               info, version)
[16:09:29.485]                           }
[16:09:29.485]                           base::stop(msg)
[16:09:29.485]                         }
[16:09:29.485]                       })
[16:09:29.485]                     }
[16:09:29.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:29.485]                     base::options(mc.cores = 1L)
[16:09:29.485]                   }
[16:09:29.485]                   options(future.plan = NULL)
[16:09:29.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:29.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:29.485]                 }
[16:09:29.485]                 ...future.workdir <- getwd()
[16:09:29.485]             }
[16:09:29.485]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:29.485]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:29.485]         }
[16:09:29.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:29.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:09:29.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:29.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:29.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:29.485]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:29.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:29.485]             base::names(...future.oldOptions))
[16:09:29.485]     }
[16:09:29.485]     if (FALSE) {
[16:09:29.485]     }
[16:09:29.485]     else {
[16:09:29.485]         if (TRUE) {
[16:09:29.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:29.485]                 open = "w")
[16:09:29.485]         }
[16:09:29.485]         else {
[16:09:29.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:29.485]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:29.485]         }
[16:09:29.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:29.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:29.485]             base::sink(type = "output", split = FALSE)
[16:09:29.485]             base::close(...future.stdout)
[16:09:29.485]         }, add = TRUE)
[16:09:29.485]     }
[16:09:29.485]     ...future.frame <- base::sys.nframe()
[16:09:29.485]     ...future.conditions <- base::list()
[16:09:29.485]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:29.485]     if (FALSE) {
[16:09:29.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:29.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:29.485]     }
[16:09:29.485]     ...future.result <- base::tryCatch({
[16:09:29.485]         base::withCallingHandlers({
[16:09:29.485]             ...future.value <- base::withVisible(base::local({
[16:09:29.485]                 ...future.makeSendCondition <- local({
[16:09:29.485]                   sendCondition <- NULL
[16:09:29.485]                   function(frame = 1L) {
[16:09:29.485]                     if (is.function(sendCondition)) 
[16:09:29.485]                       return(sendCondition)
[16:09:29.485]                     ns <- getNamespace("parallel")
[16:09:29.485]                     if (exists("sendData", mode = "function", 
[16:09:29.485]                       envir = ns)) {
[16:09:29.485]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:29.485]                         envir = ns)
[16:09:29.485]                       envir <- sys.frame(frame)
[16:09:29.485]                       master <- NULL
[16:09:29.485]                       while (!identical(envir, .GlobalEnv) && 
[16:09:29.485]                         !identical(envir, emptyenv())) {
[16:09:29.485]                         if (exists("master", mode = "list", envir = envir, 
[16:09:29.485]                           inherits = FALSE)) {
[16:09:29.485]                           master <- get("master", mode = "list", 
[16:09:29.485]                             envir = envir, inherits = FALSE)
[16:09:29.485]                           if (inherits(master, c("SOCKnode", 
[16:09:29.485]                             "SOCK0node"))) {
[16:09:29.485]                             sendCondition <<- function(cond) {
[16:09:29.485]                               data <- list(type = "VALUE", value = cond, 
[16:09:29.485]                                 success = TRUE)
[16:09:29.485]                               parallel_sendData(master, data)
[16:09:29.485]                             }
[16:09:29.485]                             return(sendCondition)
[16:09:29.485]                           }
[16:09:29.485]                         }
[16:09:29.485]                         frame <- frame + 1L
[16:09:29.485]                         envir <- sys.frame(frame)
[16:09:29.485]                       }
[16:09:29.485]                     }
[16:09:29.485]                     sendCondition <<- function(cond) NULL
[16:09:29.485]                   }
[16:09:29.485]                 })
[16:09:29.485]                 withCallingHandlers({
[16:09:29.485]                   NA
[16:09:29.485]                 }, immediateCondition = function(cond) {
[16:09:29.485]                   sendCondition <- ...future.makeSendCondition()
[16:09:29.485]                   sendCondition(cond)
[16:09:29.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.485]                   {
[16:09:29.485]                     inherits <- base::inherits
[16:09:29.485]                     invokeRestart <- base::invokeRestart
[16:09:29.485]                     is.null <- base::is.null
[16:09:29.485]                     muffled <- FALSE
[16:09:29.485]                     if (inherits(cond, "message")) {
[16:09:29.485]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:29.485]                       if (muffled) 
[16:09:29.485]                         invokeRestart("muffleMessage")
[16:09:29.485]                     }
[16:09:29.485]                     else if (inherits(cond, "warning")) {
[16:09:29.485]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:29.485]                       if (muffled) 
[16:09:29.485]                         invokeRestart("muffleWarning")
[16:09:29.485]                     }
[16:09:29.485]                     else if (inherits(cond, "condition")) {
[16:09:29.485]                       if (!is.null(pattern)) {
[16:09:29.485]                         computeRestarts <- base::computeRestarts
[16:09:29.485]                         grepl <- base::grepl
[16:09:29.485]                         restarts <- computeRestarts(cond)
[16:09:29.485]                         for (restart in restarts) {
[16:09:29.485]                           name <- restart$name
[16:09:29.485]                           if (is.null(name)) 
[16:09:29.485]                             next
[16:09:29.485]                           if (!grepl(pattern, name)) 
[16:09:29.485]                             next
[16:09:29.485]                           invokeRestart(restart)
[16:09:29.485]                           muffled <- TRUE
[16:09:29.485]                           break
[16:09:29.485]                         }
[16:09:29.485]                       }
[16:09:29.485]                     }
[16:09:29.485]                     invisible(muffled)
[16:09:29.485]                   }
[16:09:29.485]                   muffleCondition(cond)
[16:09:29.485]                 })
[16:09:29.485]             }))
[16:09:29.485]             future::FutureResult(value = ...future.value$value, 
[16:09:29.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:29.485]                   ...future.rng), globalenv = if (FALSE) 
[16:09:29.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:29.485]                     ...future.globalenv.names))
[16:09:29.485]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:29.485]         }, condition = base::local({
[16:09:29.485]             c <- base::c
[16:09:29.485]             inherits <- base::inherits
[16:09:29.485]             invokeRestart <- base::invokeRestart
[16:09:29.485]             length <- base::length
[16:09:29.485]             list <- base::list
[16:09:29.485]             seq.int <- base::seq.int
[16:09:29.485]             signalCondition <- base::signalCondition
[16:09:29.485]             sys.calls <- base::sys.calls
[16:09:29.485]             `[[` <- base::`[[`
[16:09:29.485]             `+` <- base::`+`
[16:09:29.485]             `<<-` <- base::`<<-`
[16:09:29.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:29.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:29.485]                   3L)]
[16:09:29.485]             }
[16:09:29.485]             function(cond) {
[16:09:29.485]                 is_error <- inherits(cond, "error")
[16:09:29.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:29.485]                   NULL)
[16:09:29.485]                 if (is_error) {
[16:09:29.485]                   sessionInformation <- function() {
[16:09:29.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:29.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:29.485]                       search = base::search(), system = base::Sys.info())
[16:09:29.485]                   }
[16:09:29.485]                   ...future.conditions[[length(...future.conditions) + 
[16:09:29.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:29.485]                     cond$call), session = sessionInformation(), 
[16:09:29.485]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:29.485]                   signalCondition(cond)
[16:09:29.485]                 }
[16:09:29.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:29.485]                 "immediateCondition"))) {
[16:09:29.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:29.485]                   ...future.conditions[[length(...future.conditions) + 
[16:09:29.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:29.485]                   if (TRUE && !signal) {
[16:09:29.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.485]                     {
[16:09:29.485]                       inherits <- base::inherits
[16:09:29.485]                       invokeRestart <- base::invokeRestart
[16:09:29.485]                       is.null <- base::is.null
[16:09:29.485]                       muffled <- FALSE
[16:09:29.485]                       if (inherits(cond, "message")) {
[16:09:29.485]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:29.485]                         if (muffled) 
[16:09:29.485]                           invokeRestart("muffleMessage")
[16:09:29.485]                       }
[16:09:29.485]                       else if (inherits(cond, "warning")) {
[16:09:29.485]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:29.485]                         if (muffled) 
[16:09:29.485]                           invokeRestart("muffleWarning")
[16:09:29.485]                       }
[16:09:29.485]                       else if (inherits(cond, "condition")) {
[16:09:29.485]                         if (!is.null(pattern)) {
[16:09:29.485]                           computeRestarts <- base::computeRestarts
[16:09:29.485]                           grepl <- base::grepl
[16:09:29.485]                           restarts <- computeRestarts(cond)
[16:09:29.485]                           for (restart in restarts) {
[16:09:29.485]                             name <- restart$name
[16:09:29.485]                             if (is.null(name)) 
[16:09:29.485]                               next
[16:09:29.485]                             if (!grepl(pattern, name)) 
[16:09:29.485]                               next
[16:09:29.485]                             invokeRestart(restart)
[16:09:29.485]                             muffled <- TRUE
[16:09:29.485]                             break
[16:09:29.485]                           }
[16:09:29.485]                         }
[16:09:29.485]                       }
[16:09:29.485]                       invisible(muffled)
[16:09:29.485]                     }
[16:09:29.485]                     muffleCondition(cond, pattern = "^muffle")
[16:09:29.485]                   }
[16:09:29.485]                 }
[16:09:29.485]                 else {
[16:09:29.485]                   if (TRUE) {
[16:09:29.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.485]                     {
[16:09:29.485]                       inherits <- base::inherits
[16:09:29.485]                       invokeRestart <- base::invokeRestart
[16:09:29.485]                       is.null <- base::is.null
[16:09:29.485]                       muffled <- FALSE
[16:09:29.485]                       if (inherits(cond, "message")) {
[16:09:29.485]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:29.485]                         if (muffled) 
[16:09:29.485]                           invokeRestart("muffleMessage")
[16:09:29.485]                       }
[16:09:29.485]                       else if (inherits(cond, "warning")) {
[16:09:29.485]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:29.485]                         if (muffled) 
[16:09:29.485]                           invokeRestart("muffleWarning")
[16:09:29.485]                       }
[16:09:29.485]                       else if (inherits(cond, "condition")) {
[16:09:29.485]                         if (!is.null(pattern)) {
[16:09:29.485]                           computeRestarts <- base::computeRestarts
[16:09:29.485]                           grepl <- base::grepl
[16:09:29.485]                           restarts <- computeRestarts(cond)
[16:09:29.485]                           for (restart in restarts) {
[16:09:29.485]                             name <- restart$name
[16:09:29.485]                             if (is.null(name)) 
[16:09:29.485]                               next
[16:09:29.485]                             if (!grepl(pattern, name)) 
[16:09:29.485]                               next
[16:09:29.485]                             invokeRestart(restart)
[16:09:29.485]                             muffled <- TRUE
[16:09:29.485]                             break
[16:09:29.485]                           }
[16:09:29.485]                         }
[16:09:29.485]                       }
[16:09:29.485]                       invisible(muffled)
[16:09:29.485]                     }
[16:09:29.485]                     muffleCondition(cond, pattern = "^muffle")
[16:09:29.485]                   }
[16:09:29.485]                 }
[16:09:29.485]             }
[16:09:29.485]         }))
[16:09:29.485]     }, error = function(ex) {
[16:09:29.485]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:29.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:29.485]                 ...future.rng), started = ...future.startTime, 
[16:09:29.485]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:29.485]             version = "1.8"), class = "FutureResult")
[16:09:29.485]     }, finally = {
[16:09:29.485]         if (!identical(...future.workdir, getwd())) 
[16:09:29.485]             setwd(...future.workdir)
[16:09:29.485]         {
[16:09:29.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:29.485]                 ...future.oldOptions$nwarnings <- NULL
[16:09:29.485]             }
[16:09:29.485]             base::options(...future.oldOptions)
[16:09:29.485]             if (.Platform$OS.type == "windows") {
[16:09:29.485]                 old_names <- names(...future.oldEnvVars)
[16:09:29.485]                 envs <- base::Sys.getenv()
[16:09:29.485]                 names <- names(envs)
[16:09:29.485]                 common <- intersect(names, old_names)
[16:09:29.485]                 added <- setdiff(names, old_names)
[16:09:29.485]                 removed <- setdiff(old_names, names)
[16:09:29.485]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:29.485]                   envs[common]]
[16:09:29.485]                 NAMES <- toupper(changed)
[16:09:29.485]                 args <- list()
[16:09:29.485]                 for (kk in seq_along(NAMES)) {
[16:09:29.485]                   name <- changed[[kk]]
[16:09:29.485]                   NAME <- NAMES[[kk]]
[16:09:29.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.485]                     next
[16:09:29.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:29.485]                 }
[16:09:29.485]                 NAMES <- toupper(added)
[16:09:29.485]                 for (kk in seq_along(NAMES)) {
[16:09:29.485]                   name <- added[[kk]]
[16:09:29.485]                   NAME <- NAMES[[kk]]
[16:09:29.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.485]                     next
[16:09:29.485]                   args[[name]] <- ""
[16:09:29.485]                 }
[16:09:29.485]                 NAMES <- toupper(removed)
[16:09:29.485]                 for (kk in seq_along(NAMES)) {
[16:09:29.485]                   name <- removed[[kk]]
[16:09:29.485]                   NAME <- NAMES[[kk]]
[16:09:29.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.485]                     next
[16:09:29.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:29.485]                 }
[16:09:29.485]                 if (length(args) > 0) 
[16:09:29.485]                   base::do.call(base::Sys.setenv, args = args)
[16:09:29.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:29.485]             }
[16:09:29.485]             else {
[16:09:29.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:29.485]             }
[16:09:29.485]             {
[16:09:29.485]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:29.485]                   0L) {
[16:09:29.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:29.485]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:29.485]                   base::options(opts)
[16:09:29.485]                 }
[16:09:29.485]                 {
[16:09:29.485]                   {
[16:09:29.485]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:29.485]                     NULL
[16:09:29.485]                   }
[16:09:29.485]                   options(future.plan = NULL)
[16:09:29.485]                   if (is.na(NA_character_)) 
[16:09:29.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:29.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:29.485]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:29.485]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:29.485]                     envir = parent.frame()) 
[16:09:29.485]                   {
[16:09:29.485]                     if (is.function(workers)) 
[16:09:29.485]                       workers <- workers()
[16:09:29.485]                     workers <- structure(as.integer(workers), 
[16:09:29.485]                       class = class(workers))
[16:09:29.485]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:29.485]                       workers >= 1)
[16:09:29.485]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:29.485]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:29.485]                     }
[16:09:29.485]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:29.485]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:29.485]                       envir = envir)
[16:09:29.485]                     if (!future$lazy) 
[16:09:29.485]                       future <- run(future)
[16:09:29.485]                     invisible(future)
[16:09:29.485]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:29.485]                 }
[16:09:29.485]             }
[16:09:29.485]         }
[16:09:29.485]     })
[16:09:29.485]     if (TRUE) {
[16:09:29.485]         base::sink(type = "output", split = FALSE)
[16:09:29.485]         if (TRUE) {
[16:09:29.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:29.485]         }
[16:09:29.485]         else {
[16:09:29.485]             ...future.result["stdout"] <- base::list(NULL)
[16:09:29.485]         }
[16:09:29.485]         base::close(...future.stdout)
[16:09:29.485]         ...future.stdout <- NULL
[16:09:29.485]     }
[16:09:29.485]     ...future.result$conditions <- ...future.conditions
[16:09:29.485]     ...future.result$finished <- base::Sys.time()
[16:09:29.485]     ...future.result
[16:09:29.485] }
[16:09:29.556] MultisessionFuture started
[16:09:29.557] result() for ClusterFuture ...
[16:09:29.558] receiveMessageFromWorker() for ClusterFuture ...
[16:09:29.558] - Validating connection of MultisessionFuture
[16:09:29.590] - received message: FutureResult
[16:09:29.591] - Received FutureResult
[16:09:29.591] - Erased future from FutureRegistry
[16:09:29.591] result() for ClusterFuture ...
[16:09:29.591] - result already collected: FutureResult
[16:09:29.591] result() for ClusterFuture ... done
[16:09:29.591] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:29.591] result() for ClusterFuture ... done
[16:09:29.591] result() for ClusterFuture ...
[16:09:29.592] - result already collected: FutureResult
[16:09:29.592] result() for ClusterFuture ... done
[16:09:29.592] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:09:29.596] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:09:29.596] getGlobalsAndPackagesXApply() ...
[16:09:29.596]  - future.globals: TRUE
[16:09:29.596] getGlobalsAndPackages() ...
[16:09:29.597] Searching for globals...
[16:09:29.641] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:09:29.641] Searching for globals ... DONE
[16:09:29.641] Resolving globals: FALSE
[16:09:29.643] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:09:29.643] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:09:29.643] - globals: [1] ‘FUN’
[16:09:29.643] 
[16:09:29.643] getGlobalsAndPackages() ... DONE
[16:09:29.644]  - globals found/used: [n=1] ‘FUN’
[16:09:29.644]  - needed namespaces: [n=0] 
[16:09:29.644] Finding globals ... DONE
[16:09:29.644]  - use_args: TRUE
[16:09:29.644]  - Getting '...' globals ...
[16:09:29.644] resolve() on list ...
[16:09:29.644]  recursive: 0
[16:09:29.644]  length: 1
[16:09:29.644]  elements: ‘...’
[16:09:29.645]  length: 0 (resolved future 1)
[16:09:29.645] resolve() on list ... DONE
[16:09:29.645]    - '...' content: [n=0] 
[16:09:29.645] List of 1
[16:09:29.645]  $ ...: list()
[16:09:29.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:29.645]  - attr(*, "where")=List of 1
[16:09:29.645]   ..$ ...:<environment: 0x5633ad711c48> 
[16:09:29.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:29.645]  - attr(*, "resolved")= logi TRUE
[16:09:29.645]  - attr(*, "total_size")= num NA
[16:09:29.647]  - Getting '...' globals ... DONE
[16:09:29.648] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:29.648] List of 2
[16:09:29.648]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:29.648]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:29.648]  $ ...          : list()
[16:09:29.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:29.648]  - attr(*, "where")=List of 2
[16:09:29.648]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:29.648]   ..$ ...          :<environment: 0x5633ad711c48> 
[16:09:29.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:29.648]  - attr(*, "resolved")= logi FALSE
[16:09:29.648]  - attr(*, "total_size")= num 354224
[16:09:29.650] Packages to be attached in all futures: [n=0] 
[16:09:29.650] getGlobalsAndPackagesXApply() ... DONE
[16:09:29.654] future_lapply() ...
[16:09:29.687] Number of chunks: 2
[16:09:29.687] getGlobalsAndPackagesXApply() ...
[16:09:29.687]  - future.globals: <name-value list> with names ‘list()’
[16:09:29.688]  - use_args: TRUE
[16:09:29.688] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:29.688] List of 2
[16:09:29.688]  $ ...          : list()
[16:09:29.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:29.688]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:29.688]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:29.688]  - attr(*, "where")=List of 2
[16:09:29.688]   ..$ ...          :<environment: 0x5633ad711c48> 
[16:09:29.688]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:29.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:29.688]  - attr(*, "resolved")= logi FALSE
[16:09:29.688]  - attr(*, "total_size")= num NA
[16:09:29.691] Packages to be attached in all futures: [n=0] 
[16:09:29.691] getGlobalsAndPackagesXApply() ... DONE
[16:09:29.691] Number of futures (= number of chunks): 2
[16:09:29.692] Launching 2 futures (chunks) ...
[16:09:29.692] Chunk #1 of 2 ...
[16:09:29.692]  - seeds: <none>
[16:09:29.692] getGlobalsAndPackages() ...
[16:09:29.692] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:29.692] Resolving globals: FALSE
[16:09:29.692] Tweak future expression to call with '...' arguments ...
[16:09:29.692] {
[16:09:29.692]     do.call(function(...) {
[16:09:29.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:29.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:29.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:29.692]             on.exit(options(oopts), add = TRUE)
[16:09:29.692]         }
[16:09:29.692]         {
[16:09:29.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:29.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:29.692]                 ...future.FUN(...future.X_jj, ...)
[16:09:29.692]             })
[16:09:29.692]         }
[16:09:29.692]     }, args = future.call.arguments)
[16:09:29.692] }
[16:09:29.693] Tweak future expression to call with '...' arguments ... DONE
[16:09:29.693] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:29.693] 
[16:09:29.693] getGlobalsAndPackages() ... DONE
[16:09:29.694] run() for ‘Future’ ...
[16:09:29.694] - state: ‘created’
[16:09:29.694] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:29.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:29.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:29.708]   - Field: ‘node’
[16:09:29.709]   - Field: ‘label’
[16:09:29.709]   - Field: ‘local’
[16:09:29.709]   - Field: ‘owner’
[16:09:29.709]   - Field: ‘envir’
[16:09:29.709]   - Field: ‘workers’
[16:09:29.709]   - Field: ‘packages’
[16:09:29.709]   - Field: ‘gc’
[16:09:29.709]   - Field: ‘conditions’
[16:09:29.709]   - Field: ‘persistent’
[16:09:29.709]   - Field: ‘expr’
[16:09:29.709]   - Field: ‘uuid’
[16:09:29.710]   - Field: ‘seed’
[16:09:29.710]   - Field: ‘version’
[16:09:29.710]   - Field: ‘result’
[16:09:29.710]   - Field: ‘asynchronous’
[16:09:29.710]   - Field: ‘calls’
[16:09:29.710]   - Field: ‘globals’
[16:09:29.710]   - Field: ‘stdout’
[16:09:29.710]   - Field: ‘earlySignal’
[16:09:29.710]   - Field: ‘lazy’
[16:09:29.710]   - Field: ‘state’
[16:09:29.710] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:29.711] - Launch lazy future ...
[16:09:29.711] Packages needed by the future expression (n = 0): <none>
[16:09:29.711] Packages needed by future strategies (n = 0): <none>
[16:09:29.711] {
[16:09:29.711]     {
[16:09:29.711]         {
[16:09:29.711]             ...future.startTime <- base::Sys.time()
[16:09:29.711]             {
[16:09:29.711]                 {
[16:09:29.711]                   {
[16:09:29.711]                     {
[16:09:29.711]                       base::local({
[16:09:29.711]                         has_future <- base::requireNamespace("future", 
[16:09:29.711]                           quietly = TRUE)
[16:09:29.711]                         if (has_future) {
[16:09:29.711]                           ns <- base::getNamespace("future")
[16:09:29.711]                           version <- ns[[".package"]][["version"]]
[16:09:29.711]                           if (is.null(version)) 
[16:09:29.711]                             version <- utils::packageVersion("future")
[16:09:29.711]                         }
[16:09:29.711]                         else {
[16:09:29.711]                           version <- NULL
[16:09:29.711]                         }
[16:09:29.711]                         if (!has_future || version < "1.8.0") {
[16:09:29.711]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:29.711]                             "", base::R.version$version.string), 
[16:09:29.711]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:29.711]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:29.711]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:29.711]                               "release", "version")], collapse = " "), 
[16:09:29.711]                             hostname = base::Sys.info()[["nodename"]])
[16:09:29.711]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:29.711]                             info)
[16:09:29.711]                           info <- base::paste(info, collapse = "; ")
[16:09:29.711]                           if (!has_future) {
[16:09:29.711]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:29.711]                               info)
[16:09:29.711]                           }
[16:09:29.711]                           else {
[16:09:29.711]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:29.711]                               info, version)
[16:09:29.711]                           }
[16:09:29.711]                           base::stop(msg)
[16:09:29.711]                         }
[16:09:29.711]                       })
[16:09:29.711]                     }
[16:09:29.711]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:29.711]                     base::options(mc.cores = 1L)
[16:09:29.711]                   }
[16:09:29.711]                   options(future.plan = NULL)
[16:09:29.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:29.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:29.711]                 }
[16:09:29.711]                 ...future.workdir <- getwd()
[16:09:29.711]             }
[16:09:29.711]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:29.711]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:29.711]         }
[16:09:29.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:29.711]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:29.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:29.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:29.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:29.711]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:29.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:29.711]             base::names(...future.oldOptions))
[16:09:29.711]     }
[16:09:29.711]     if (FALSE) {
[16:09:29.711]     }
[16:09:29.711]     else {
[16:09:29.711]         if (TRUE) {
[16:09:29.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:29.711]                 open = "w")
[16:09:29.711]         }
[16:09:29.711]         else {
[16:09:29.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:29.711]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:29.711]         }
[16:09:29.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:29.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:29.711]             base::sink(type = "output", split = FALSE)
[16:09:29.711]             base::close(...future.stdout)
[16:09:29.711]         }, add = TRUE)
[16:09:29.711]     }
[16:09:29.711]     ...future.frame <- base::sys.nframe()
[16:09:29.711]     ...future.conditions <- base::list()
[16:09:29.711]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:29.711]     if (FALSE) {
[16:09:29.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:29.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:29.711]     }
[16:09:29.711]     ...future.result <- base::tryCatch({
[16:09:29.711]         base::withCallingHandlers({
[16:09:29.711]             ...future.value <- base::withVisible(base::local({
[16:09:29.711]                 ...future.makeSendCondition <- local({
[16:09:29.711]                   sendCondition <- NULL
[16:09:29.711]                   function(frame = 1L) {
[16:09:29.711]                     if (is.function(sendCondition)) 
[16:09:29.711]                       return(sendCondition)
[16:09:29.711]                     ns <- getNamespace("parallel")
[16:09:29.711]                     if (exists("sendData", mode = "function", 
[16:09:29.711]                       envir = ns)) {
[16:09:29.711]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:29.711]                         envir = ns)
[16:09:29.711]                       envir <- sys.frame(frame)
[16:09:29.711]                       master <- NULL
[16:09:29.711]                       while (!identical(envir, .GlobalEnv) && 
[16:09:29.711]                         !identical(envir, emptyenv())) {
[16:09:29.711]                         if (exists("master", mode = "list", envir = envir, 
[16:09:29.711]                           inherits = FALSE)) {
[16:09:29.711]                           master <- get("master", mode = "list", 
[16:09:29.711]                             envir = envir, inherits = FALSE)
[16:09:29.711]                           if (inherits(master, c("SOCKnode", 
[16:09:29.711]                             "SOCK0node"))) {
[16:09:29.711]                             sendCondition <<- function(cond) {
[16:09:29.711]                               data <- list(type = "VALUE", value = cond, 
[16:09:29.711]                                 success = TRUE)
[16:09:29.711]                               parallel_sendData(master, data)
[16:09:29.711]                             }
[16:09:29.711]                             return(sendCondition)
[16:09:29.711]                           }
[16:09:29.711]                         }
[16:09:29.711]                         frame <- frame + 1L
[16:09:29.711]                         envir <- sys.frame(frame)
[16:09:29.711]                       }
[16:09:29.711]                     }
[16:09:29.711]                     sendCondition <<- function(cond) NULL
[16:09:29.711]                   }
[16:09:29.711]                 })
[16:09:29.711]                 withCallingHandlers({
[16:09:29.711]                   {
[16:09:29.711]                     do.call(function(...) {
[16:09:29.711]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:29.711]                       if (!identical(...future.globals.maxSize.org, 
[16:09:29.711]                         ...future.globals.maxSize)) {
[16:09:29.711]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:29.711]                         on.exit(options(oopts), add = TRUE)
[16:09:29.711]                       }
[16:09:29.711]                       {
[16:09:29.711]                         lapply(seq_along(...future.elements_ii), 
[16:09:29.711]                           FUN = function(jj) {
[16:09:29.711]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:29.711]                             ...future.FUN(...future.X_jj, ...)
[16:09:29.711]                           })
[16:09:29.711]                       }
[16:09:29.711]                     }, args = future.call.arguments)
[16:09:29.711]                   }
[16:09:29.711]                 }, immediateCondition = function(cond) {
[16:09:29.711]                   sendCondition <- ...future.makeSendCondition()
[16:09:29.711]                   sendCondition(cond)
[16:09:29.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.711]                   {
[16:09:29.711]                     inherits <- base::inherits
[16:09:29.711]                     invokeRestart <- base::invokeRestart
[16:09:29.711]                     is.null <- base::is.null
[16:09:29.711]                     muffled <- FALSE
[16:09:29.711]                     if (inherits(cond, "message")) {
[16:09:29.711]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:29.711]                       if (muffled) 
[16:09:29.711]                         invokeRestart("muffleMessage")
[16:09:29.711]                     }
[16:09:29.711]                     else if (inherits(cond, "warning")) {
[16:09:29.711]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:29.711]                       if (muffled) 
[16:09:29.711]                         invokeRestart("muffleWarning")
[16:09:29.711]                     }
[16:09:29.711]                     else if (inherits(cond, "condition")) {
[16:09:29.711]                       if (!is.null(pattern)) {
[16:09:29.711]                         computeRestarts <- base::computeRestarts
[16:09:29.711]                         grepl <- base::grepl
[16:09:29.711]                         restarts <- computeRestarts(cond)
[16:09:29.711]                         for (restart in restarts) {
[16:09:29.711]                           name <- restart$name
[16:09:29.711]                           if (is.null(name)) 
[16:09:29.711]                             next
[16:09:29.711]                           if (!grepl(pattern, name)) 
[16:09:29.711]                             next
[16:09:29.711]                           invokeRestart(restart)
[16:09:29.711]                           muffled <- TRUE
[16:09:29.711]                           break
[16:09:29.711]                         }
[16:09:29.711]                       }
[16:09:29.711]                     }
[16:09:29.711]                     invisible(muffled)
[16:09:29.711]                   }
[16:09:29.711]                   muffleCondition(cond)
[16:09:29.711]                 })
[16:09:29.711]             }))
[16:09:29.711]             future::FutureResult(value = ...future.value$value, 
[16:09:29.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:29.711]                   ...future.rng), globalenv = if (FALSE) 
[16:09:29.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:29.711]                     ...future.globalenv.names))
[16:09:29.711]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:29.711]         }, condition = base::local({
[16:09:29.711]             c <- base::c
[16:09:29.711]             inherits <- base::inherits
[16:09:29.711]             invokeRestart <- base::invokeRestart
[16:09:29.711]             length <- base::length
[16:09:29.711]             list <- base::list
[16:09:29.711]             seq.int <- base::seq.int
[16:09:29.711]             signalCondition <- base::signalCondition
[16:09:29.711]             sys.calls <- base::sys.calls
[16:09:29.711]             `[[` <- base::`[[`
[16:09:29.711]             `+` <- base::`+`
[16:09:29.711]             `<<-` <- base::`<<-`
[16:09:29.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:29.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:29.711]                   3L)]
[16:09:29.711]             }
[16:09:29.711]             function(cond) {
[16:09:29.711]                 is_error <- inherits(cond, "error")
[16:09:29.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:29.711]                   NULL)
[16:09:29.711]                 if (is_error) {
[16:09:29.711]                   sessionInformation <- function() {
[16:09:29.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:29.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:29.711]                       search = base::search(), system = base::Sys.info())
[16:09:29.711]                   }
[16:09:29.711]                   ...future.conditions[[length(...future.conditions) + 
[16:09:29.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:29.711]                     cond$call), session = sessionInformation(), 
[16:09:29.711]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:29.711]                   signalCondition(cond)
[16:09:29.711]                 }
[16:09:29.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:29.711]                 "immediateCondition"))) {
[16:09:29.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:29.711]                   ...future.conditions[[length(...future.conditions) + 
[16:09:29.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:29.711]                   if (TRUE && !signal) {
[16:09:29.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.711]                     {
[16:09:29.711]                       inherits <- base::inherits
[16:09:29.711]                       invokeRestart <- base::invokeRestart
[16:09:29.711]                       is.null <- base::is.null
[16:09:29.711]                       muffled <- FALSE
[16:09:29.711]                       if (inherits(cond, "message")) {
[16:09:29.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:29.711]                         if (muffled) 
[16:09:29.711]                           invokeRestart("muffleMessage")
[16:09:29.711]                       }
[16:09:29.711]                       else if (inherits(cond, "warning")) {
[16:09:29.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:29.711]                         if (muffled) 
[16:09:29.711]                           invokeRestart("muffleWarning")
[16:09:29.711]                       }
[16:09:29.711]                       else if (inherits(cond, "condition")) {
[16:09:29.711]                         if (!is.null(pattern)) {
[16:09:29.711]                           computeRestarts <- base::computeRestarts
[16:09:29.711]                           grepl <- base::grepl
[16:09:29.711]                           restarts <- computeRestarts(cond)
[16:09:29.711]                           for (restart in restarts) {
[16:09:29.711]                             name <- restart$name
[16:09:29.711]                             if (is.null(name)) 
[16:09:29.711]                               next
[16:09:29.711]                             if (!grepl(pattern, name)) 
[16:09:29.711]                               next
[16:09:29.711]                             invokeRestart(restart)
[16:09:29.711]                             muffled <- TRUE
[16:09:29.711]                             break
[16:09:29.711]                           }
[16:09:29.711]                         }
[16:09:29.711]                       }
[16:09:29.711]                       invisible(muffled)
[16:09:29.711]                     }
[16:09:29.711]                     muffleCondition(cond, pattern = "^muffle")
[16:09:29.711]                   }
[16:09:29.711]                 }
[16:09:29.711]                 else {
[16:09:29.711]                   if (TRUE) {
[16:09:29.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.711]                     {
[16:09:29.711]                       inherits <- base::inherits
[16:09:29.711]                       invokeRestart <- base::invokeRestart
[16:09:29.711]                       is.null <- base::is.null
[16:09:29.711]                       muffled <- FALSE
[16:09:29.711]                       if (inherits(cond, "message")) {
[16:09:29.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:29.711]                         if (muffled) 
[16:09:29.711]                           invokeRestart("muffleMessage")
[16:09:29.711]                       }
[16:09:29.711]                       else if (inherits(cond, "warning")) {
[16:09:29.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:29.711]                         if (muffled) 
[16:09:29.711]                           invokeRestart("muffleWarning")
[16:09:29.711]                       }
[16:09:29.711]                       else if (inherits(cond, "condition")) {
[16:09:29.711]                         if (!is.null(pattern)) {
[16:09:29.711]                           computeRestarts <- base::computeRestarts
[16:09:29.711]                           grepl <- base::grepl
[16:09:29.711]                           restarts <- computeRestarts(cond)
[16:09:29.711]                           for (restart in restarts) {
[16:09:29.711]                             name <- restart$name
[16:09:29.711]                             if (is.null(name)) 
[16:09:29.711]                               next
[16:09:29.711]                             if (!grepl(pattern, name)) 
[16:09:29.711]                               next
[16:09:29.711]                             invokeRestart(restart)
[16:09:29.711]                             muffled <- TRUE
[16:09:29.711]                             break
[16:09:29.711]                           }
[16:09:29.711]                         }
[16:09:29.711]                       }
[16:09:29.711]                       invisible(muffled)
[16:09:29.711]                     }
[16:09:29.711]                     muffleCondition(cond, pattern = "^muffle")
[16:09:29.711]                   }
[16:09:29.711]                 }
[16:09:29.711]             }
[16:09:29.711]         }))
[16:09:29.711]     }, error = function(ex) {
[16:09:29.711]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:29.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:29.711]                 ...future.rng), started = ...future.startTime, 
[16:09:29.711]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:29.711]             version = "1.8"), class = "FutureResult")
[16:09:29.711]     }, finally = {
[16:09:29.711]         if (!identical(...future.workdir, getwd())) 
[16:09:29.711]             setwd(...future.workdir)
[16:09:29.711]         {
[16:09:29.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:29.711]                 ...future.oldOptions$nwarnings <- NULL
[16:09:29.711]             }
[16:09:29.711]             base::options(...future.oldOptions)
[16:09:29.711]             if (.Platform$OS.type == "windows") {
[16:09:29.711]                 old_names <- names(...future.oldEnvVars)
[16:09:29.711]                 envs <- base::Sys.getenv()
[16:09:29.711]                 names <- names(envs)
[16:09:29.711]                 common <- intersect(names, old_names)
[16:09:29.711]                 added <- setdiff(names, old_names)
[16:09:29.711]                 removed <- setdiff(old_names, names)
[16:09:29.711]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:29.711]                   envs[common]]
[16:09:29.711]                 NAMES <- toupper(changed)
[16:09:29.711]                 args <- list()
[16:09:29.711]                 for (kk in seq_along(NAMES)) {
[16:09:29.711]                   name <- changed[[kk]]
[16:09:29.711]                   NAME <- NAMES[[kk]]
[16:09:29.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.711]                     next
[16:09:29.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:29.711]                 }
[16:09:29.711]                 NAMES <- toupper(added)
[16:09:29.711]                 for (kk in seq_along(NAMES)) {
[16:09:29.711]                   name <- added[[kk]]
[16:09:29.711]                   NAME <- NAMES[[kk]]
[16:09:29.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.711]                     next
[16:09:29.711]                   args[[name]] <- ""
[16:09:29.711]                 }
[16:09:29.711]                 NAMES <- toupper(removed)
[16:09:29.711]                 for (kk in seq_along(NAMES)) {
[16:09:29.711]                   name <- removed[[kk]]
[16:09:29.711]                   NAME <- NAMES[[kk]]
[16:09:29.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.711]                     next
[16:09:29.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:29.711]                 }
[16:09:29.711]                 if (length(args) > 0) 
[16:09:29.711]                   base::do.call(base::Sys.setenv, args = args)
[16:09:29.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:29.711]             }
[16:09:29.711]             else {
[16:09:29.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:29.711]             }
[16:09:29.711]             {
[16:09:29.711]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:29.711]                   0L) {
[16:09:29.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:29.711]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:29.711]                   base::options(opts)
[16:09:29.711]                 }
[16:09:29.711]                 {
[16:09:29.711]                   {
[16:09:29.711]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:29.711]                     NULL
[16:09:29.711]                   }
[16:09:29.711]                   options(future.plan = NULL)
[16:09:29.711]                   if (is.na(NA_character_)) 
[16:09:29.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:29.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:29.711]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:29.711]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:29.711]                     envir = parent.frame()) 
[16:09:29.711]                   {
[16:09:29.711]                     if (is.function(workers)) 
[16:09:29.711]                       workers <- workers()
[16:09:29.711]                     workers <- structure(as.integer(workers), 
[16:09:29.711]                       class = class(workers))
[16:09:29.711]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:29.711]                       workers >= 1)
[16:09:29.711]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:29.711]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:29.711]                     }
[16:09:29.711]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:29.711]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:29.711]                       envir = envir)
[16:09:29.711]                     if (!future$lazy) 
[16:09:29.711]                       future <- run(future)
[16:09:29.711]                     invisible(future)
[16:09:29.711]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:29.711]                 }
[16:09:29.711]             }
[16:09:29.711]         }
[16:09:29.711]     })
[16:09:29.711]     if (TRUE) {
[16:09:29.711]         base::sink(type = "output", split = FALSE)
[16:09:29.711]         if (TRUE) {
[16:09:29.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:29.711]         }
[16:09:29.711]         else {
[16:09:29.711]             ...future.result["stdout"] <- base::list(NULL)
[16:09:29.711]         }
[16:09:29.711]         base::close(...future.stdout)
[16:09:29.711]         ...future.stdout <- NULL
[16:09:29.711]     }
[16:09:29.711]     ...future.result$conditions <- ...future.conditions
[16:09:29.711]     ...future.result$finished <- base::Sys.time()
[16:09:29.711]     ...future.result
[16:09:29.711] }
[16:09:29.714] Exporting 5 global objects (346.00 KiB) to cluster node #1 ...
[16:09:29.715] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:29.715] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:29.715] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:09:29.756] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:09:29.756] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:09:29.757] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:09:29.757] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:29.757] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:29.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:29.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:29.757] Exporting 5 global objects (346.00 KiB) to cluster node #1 ... DONE
[16:09:29.758] MultisessionFuture started
[16:09:29.758] - Launch lazy future ... done
[16:09:29.758] run() for ‘MultisessionFuture’ ... done
[16:09:29.758] Created future:
[16:09:29.758] MultisessionFuture:
[16:09:29.758] Label: ‘future_apply-1’
[16:09:29.758] Expression:
[16:09:29.758] {
[16:09:29.758]     do.call(function(...) {
[16:09:29.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:29.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:29.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:29.758]             on.exit(options(oopts), add = TRUE)
[16:09:29.758]         }
[16:09:29.758]         {
[16:09:29.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:29.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:29.758]                 ...future.FUN(...future.X_jj, ...)
[16:09:29.758]             })
[16:09:29.758]         }
[16:09:29.758]     }, args = future.call.arguments)
[16:09:29.758] }
[16:09:29.758] Lazy evaluation: FALSE
[16:09:29.758] Asynchronous evaluation: TRUE
[16:09:29.758] Local evaluation: TRUE
[16:09:29.758] Environment: R_GlobalEnv
[16:09:29.758] Capture standard output: TRUE
[16:09:29.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:29.758] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:29.758] Packages: <none>
[16:09:29.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:29.758] Resolved: FALSE
[16:09:29.758] Value: <not collected>
[16:09:29.758] Conditions captured: <none>
[16:09:29.758] Early signaling: FALSE
[16:09:29.758] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:29.758] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:29.770] Chunk #1 of 2 ... DONE
[16:09:29.770] Chunk #2 of 2 ...
[16:09:29.771]  - seeds: <none>
[16:09:29.771] getGlobalsAndPackages() ...
[16:09:29.771] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:29.771] Resolving globals: FALSE
[16:09:29.771] Tweak future expression to call with '...' arguments ...
[16:09:29.771] {
[16:09:29.771]     do.call(function(...) {
[16:09:29.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:29.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:29.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:29.771]             on.exit(options(oopts), add = TRUE)
[16:09:29.771]         }
[16:09:29.771]         {
[16:09:29.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:29.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:29.771]                 ...future.FUN(...future.X_jj, ...)
[16:09:29.771]             })
[16:09:29.771]         }
[16:09:29.771]     }, args = future.call.arguments)
[16:09:29.771] }
[16:09:29.771] Tweak future expression to call with '...' arguments ... DONE
[16:09:29.772] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:29.772] 
[16:09:29.772] getGlobalsAndPackages() ... DONE
[16:09:29.772] run() for ‘Future’ ...
[16:09:29.772] - state: ‘created’
[16:09:29.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:29.787] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:29.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:29.787]   - Field: ‘node’
[16:09:29.787]   - Field: ‘label’
[16:09:29.788]   - Field: ‘local’
[16:09:29.788]   - Field: ‘owner’
[16:09:29.788]   - Field: ‘envir’
[16:09:29.788]   - Field: ‘workers’
[16:09:29.788]   - Field: ‘packages’
[16:09:29.788]   - Field: ‘gc’
[16:09:29.788]   - Field: ‘conditions’
[16:09:29.790]   - Field: ‘persistent’
[16:09:29.790]   - Field: ‘expr’
[16:09:29.790]   - Field: ‘uuid’
[16:09:29.790]   - Field: ‘seed’
[16:09:29.790]   - Field: ‘version’
[16:09:29.790]   - Field: ‘result’
[16:09:29.790]   - Field: ‘asynchronous’
[16:09:29.791]   - Field: ‘calls’
[16:09:29.791]   - Field: ‘globals’
[16:09:29.791]   - Field: ‘stdout’
[16:09:29.791]   - Field: ‘earlySignal’
[16:09:29.791]   - Field: ‘lazy’
[16:09:29.791]   - Field: ‘state’
[16:09:29.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:29.791] - Launch lazy future ...
[16:09:29.791] Packages needed by the future expression (n = 0): <none>
[16:09:29.792] Packages needed by future strategies (n = 0): <none>
[16:09:29.792] {
[16:09:29.792]     {
[16:09:29.792]         {
[16:09:29.792]             ...future.startTime <- base::Sys.time()
[16:09:29.792]             {
[16:09:29.792]                 {
[16:09:29.792]                   {
[16:09:29.792]                     {
[16:09:29.792]                       base::local({
[16:09:29.792]                         has_future <- base::requireNamespace("future", 
[16:09:29.792]                           quietly = TRUE)
[16:09:29.792]                         if (has_future) {
[16:09:29.792]                           ns <- base::getNamespace("future")
[16:09:29.792]                           version <- ns[[".package"]][["version"]]
[16:09:29.792]                           if (is.null(version)) 
[16:09:29.792]                             version <- utils::packageVersion("future")
[16:09:29.792]                         }
[16:09:29.792]                         else {
[16:09:29.792]                           version <- NULL
[16:09:29.792]                         }
[16:09:29.792]                         if (!has_future || version < "1.8.0") {
[16:09:29.792]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:29.792]                             "", base::R.version$version.string), 
[16:09:29.792]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:29.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:29.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:29.792]                               "release", "version")], collapse = " "), 
[16:09:29.792]                             hostname = base::Sys.info()[["nodename"]])
[16:09:29.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:29.792]                             info)
[16:09:29.792]                           info <- base::paste(info, collapse = "; ")
[16:09:29.792]                           if (!has_future) {
[16:09:29.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:29.792]                               info)
[16:09:29.792]                           }
[16:09:29.792]                           else {
[16:09:29.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:29.792]                               info, version)
[16:09:29.792]                           }
[16:09:29.792]                           base::stop(msg)
[16:09:29.792]                         }
[16:09:29.792]                       })
[16:09:29.792]                     }
[16:09:29.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:29.792]                     base::options(mc.cores = 1L)
[16:09:29.792]                   }
[16:09:29.792]                   options(future.plan = NULL)
[16:09:29.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:29.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:29.792]                 }
[16:09:29.792]                 ...future.workdir <- getwd()
[16:09:29.792]             }
[16:09:29.792]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:29.792]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:29.792]         }
[16:09:29.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:29.792]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:29.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:29.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:29.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:29.792]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:29.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:29.792]             base::names(...future.oldOptions))
[16:09:29.792]     }
[16:09:29.792]     if (FALSE) {
[16:09:29.792]     }
[16:09:29.792]     else {
[16:09:29.792]         if (TRUE) {
[16:09:29.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:29.792]                 open = "w")
[16:09:29.792]         }
[16:09:29.792]         else {
[16:09:29.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:29.792]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:29.792]         }
[16:09:29.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:29.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:29.792]             base::sink(type = "output", split = FALSE)
[16:09:29.792]             base::close(...future.stdout)
[16:09:29.792]         }, add = TRUE)
[16:09:29.792]     }
[16:09:29.792]     ...future.frame <- base::sys.nframe()
[16:09:29.792]     ...future.conditions <- base::list()
[16:09:29.792]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:29.792]     if (FALSE) {
[16:09:29.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:29.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:29.792]     }
[16:09:29.792]     ...future.result <- base::tryCatch({
[16:09:29.792]         base::withCallingHandlers({
[16:09:29.792]             ...future.value <- base::withVisible(base::local({
[16:09:29.792]                 ...future.makeSendCondition <- local({
[16:09:29.792]                   sendCondition <- NULL
[16:09:29.792]                   function(frame = 1L) {
[16:09:29.792]                     if (is.function(sendCondition)) 
[16:09:29.792]                       return(sendCondition)
[16:09:29.792]                     ns <- getNamespace("parallel")
[16:09:29.792]                     if (exists("sendData", mode = "function", 
[16:09:29.792]                       envir = ns)) {
[16:09:29.792]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:29.792]                         envir = ns)
[16:09:29.792]                       envir <- sys.frame(frame)
[16:09:29.792]                       master <- NULL
[16:09:29.792]                       while (!identical(envir, .GlobalEnv) && 
[16:09:29.792]                         !identical(envir, emptyenv())) {
[16:09:29.792]                         if (exists("master", mode = "list", envir = envir, 
[16:09:29.792]                           inherits = FALSE)) {
[16:09:29.792]                           master <- get("master", mode = "list", 
[16:09:29.792]                             envir = envir, inherits = FALSE)
[16:09:29.792]                           if (inherits(master, c("SOCKnode", 
[16:09:29.792]                             "SOCK0node"))) {
[16:09:29.792]                             sendCondition <<- function(cond) {
[16:09:29.792]                               data <- list(type = "VALUE", value = cond, 
[16:09:29.792]                                 success = TRUE)
[16:09:29.792]                               parallel_sendData(master, data)
[16:09:29.792]                             }
[16:09:29.792]                             return(sendCondition)
[16:09:29.792]                           }
[16:09:29.792]                         }
[16:09:29.792]                         frame <- frame + 1L
[16:09:29.792]                         envir <- sys.frame(frame)
[16:09:29.792]                       }
[16:09:29.792]                     }
[16:09:29.792]                     sendCondition <<- function(cond) NULL
[16:09:29.792]                   }
[16:09:29.792]                 })
[16:09:29.792]                 withCallingHandlers({
[16:09:29.792]                   {
[16:09:29.792]                     do.call(function(...) {
[16:09:29.792]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:29.792]                       if (!identical(...future.globals.maxSize.org, 
[16:09:29.792]                         ...future.globals.maxSize)) {
[16:09:29.792]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:29.792]                         on.exit(options(oopts), add = TRUE)
[16:09:29.792]                       }
[16:09:29.792]                       {
[16:09:29.792]                         lapply(seq_along(...future.elements_ii), 
[16:09:29.792]                           FUN = function(jj) {
[16:09:29.792]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:29.792]                             ...future.FUN(...future.X_jj, ...)
[16:09:29.792]                           })
[16:09:29.792]                       }
[16:09:29.792]                     }, args = future.call.arguments)
[16:09:29.792]                   }
[16:09:29.792]                 }, immediateCondition = function(cond) {
[16:09:29.792]                   sendCondition <- ...future.makeSendCondition()
[16:09:29.792]                   sendCondition(cond)
[16:09:29.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.792]                   {
[16:09:29.792]                     inherits <- base::inherits
[16:09:29.792]                     invokeRestart <- base::invokeRestart
[16:09:29.792]                     is.null <- base::is.null
[16:09:29.792]                     muffled <- FALSE
[16:09:29.792]                     if (inherits(cond, "message")) {
[16:09:29.792]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:29.792]                       if (muffled) 
[16:09:29.792]                         invokeRestart("muffleMessage")
[16:09:29.792]                     }
[16:09:29.792]                     else if (inherits(cond, "warning")) {
[16:09:29.792]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:29.792]                       if (muffled) 
[16:09:29.792]                         invokeRestart("muffleWarning")
[16:09:29.792]                     }
[16:09:29.792]                     else if (inherits(cond, "condition")) {
[16:09:29.792]                       if (!is.null(pattern)) {
[16:09:29.792]                         computeRestarts <- base::computeRestarts
[16:09:29.792]                         grepl <- base::grepl
[16:09:29.792]                         restarts <- computeRestarts(cond)
[16:09:29.792]                         for (restart in restarts) {
[16:09:29.792]                           name <- restart$name
[16:09:29.792]                           if (is.null(name)) 
[16:09:29.792]                             next
[16:09:29.792]                           if (!grepl(pattern, name)) 
[16:09:29.792]                             next
[16:09:29.792]                           invokeRestart(restart)
[16:09:29.792]                           muffled <- TRUE
[16:09:29.792]                           break
[16:09:29.792]                         }
[16:09:29.792]                       }
[16:09:29.792]                     }
[16:09:29.792]                     invisible(muffled)
[16:09:29.792]                   }
[16:09:29.792]                   muffleCondition(cond)
[16:09:29.792]                 })
[16:09:29.792]             }))
[16:09:29.792]             future::FutureResult(value = ...future.value$value, 
[16:09:29.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:29.792]                   ...future.rng), globalenv = if (FALSE) 
[16:09:29.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:29.792]                     ...future.globalenv.names))
[16:09:29.792]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:29.792]         }, condition = base::local({
[16:09:29.792]             c <- base::c
[16:09:29.792]             inherits <- base::inherits
[16:09:29.792]             invokeRestart <- base::invokeRestart
[16:09:29.792]             length <- base::length
[16:09:29.792]             list <- base::list
[16:09:29.792]             seq.int <- base::seq.int
[16:09:29.792]             signalCondition <- base::signalCondition
[16:09:29.792]             sys.calls <- base::sys.calls
[16:09:29.792]             `[[` <- base::`[[`
[16:09:29.792]             `+` <- base::`+`
[16:09:29.792]             `<<-` <- base::`<<-`
[16:09:29.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:29.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:29.792]                   3L)]
[16:09:29.792]             }
[16:09:29.792]             function(cond) {
[16:09:29.792]                 is_error <- inherits(cond, "error")
[16:09:29.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:29.792]                   NULL)
[16:09:29.792]                 if (is_error) {
[16:09:29.792]                   sessionInformation <- function() {
[16:09:29.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:29.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:29.792]                       search = base::search(), system = base::Sys.info())
[16:09:29.792]                   }
[16:09:29.792]                   ...future.conditions[[length(...future.conditions) + 
[16:09:29.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:29.792]                     cond$call), session = sessionInformation(), 
[16:09:29.792]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:29.792]                   signalCondition(cond)
[16:09:29.792]                 }
[16:09:29.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:29.792]                 "immediateCondition"))) {
[16:09:29.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:29.792]                   ...future.conditions[[length(...future.conditions) + 
[16:09:29.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:29.792]                   if (TRUE && !signal) {
[16:09:29.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.792]                     {
[16:09:29.792]                       inherits <- base::inherits
[16:09:29.792]                       invokeRestart <- base::invokeRestart
[16:09:29.792]                       is.null <- base::is.null
[16:09:29.792]                       muffled <- FALSE
[16:09:29.792]                       if (inherits(cond, "message")) {
[16:09:29.792]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:29.792]                         if (muffled) 
[16:09:29.792]                           invokeRestart("muffleMessage")
[16:09:29.792]                       }
[16:09:29.792]                       else if (inherits(cond, "warning")) {
[16:09:29.792]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:29.792]                         if (muffled) 
[16:09:29.792]                           invokeRestart("muffleWarning")
[16:09:29.792]                       }
[16:09:29.792]                       else if (inherits(cond, "condition")) {
[16:09:29.792]                         if (!is.null(pattern)) {
[16:09:29.792]                           computeRestarts <- base::computeRestarts
[16:09:29.792]                           grepl <- base::grepl
[16:09:29.792]                           restarts <- computeRestarts(cond)
[16:09:29.792]                           for (restart in restarts) {
[16:09:29.792]                             name <- restart$name
[16:09:29.792]                             if (is.null(name)) 
[16:09:29.792]                               next
[16:09:29.792]                             if (!grepl(pattern, name)) 
[16:09:29.792]                               next
[16:09:29.792]                             invokeRestart(restart)
[16:09:29.792]                             muffled <- TRUE
[16:09:29.792]                             break
[16:09:29.792]                           }
[16:09:29.792]                         }
[16:09:29.792]                       }
[16:09:29.792]                       invisible(muffled)
[16:09:29.792]                     }
[16:09:29.792]                     muffleCondition(cond, pattern = "^muffle")
[16:09:29.792]                   }
[16:09:29.792]                 }
[16:09:29.792]                 else {
[16:09:29.792]                   if (TRUE) {
[16:09:29.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:29.792]                     {
[16:09:29.792]                       inherits <- base::inherits
[16:09:29.792]                       invokeRestart <- base::invokeRestart
[16:09:29.792]                       is.null <- base::is.null
[16:09:29.792]                       muffled <- FALSE
[16:09:29.792]                       if (inherits(cond, "message")) {
[16:09:29.792]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:29.792]                         if (muffled) 
[16:09:29.792]                           invokeRestart("muffleMessage")
[16:09:29.792]                       }
[16:09:29.792]                       else if (inherits(cond, "warning")) {
[16:09:29.792]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:29.792]                         if (muffled) 
[16:09:29.792]                           invokeRestart("muffleWarning")
[16:09:29.792]                       }
[16:09:29.792]                       else if (inherits(cond, "condition")) {
[16:09:29.792]                         if (!is.null(pattern)) {
[16:09:29.792]                           computeRestarts <- base::computeRestarts
[16:09:29.792]                           grepl <- base::grepl
[16:09:29.792]                           restarts <- computeRestarts(cond)
[16:09:29.792]                           for (restart in restarts) {
[16:09:29.792]                             name <- restart$name
[16:09:29.792]                             if (is.null(name)) 
[16:09:29.792]                               next
[16:09:29.792]                             if (!grepl(pattern, name)) 
[16:09:29.792]                               next
[16:09:29.792]                             invokeRestart(restart)
[16:09:29.792]                             muffled <- TRUE
[16:09:29.792]                             break
[16:09:29.792]                           }
[16:09:29.792]                         }
[16:09:29.792]                       }
[16:09:29.792]                       invisible(muffled)
[16:09:29.792]                     }
[16:09:29.792]                     muffleCondition(cond, pattern = "^muffle")
[16:09:29.792]                   }
[16:09:29.792]                 }
[16:09:29.792]             }
[16:09:29.792]         }))
[16:09:29.792]     }, error = function(ex) {
[16:09:29.792]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:29.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:29.792]                 ...future.rng), started = ...future.startTime, 
[16:09:29.792]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:29.792]             version = "1.8"), class = "FutureResult")
[16:09:29.792]     }, finally = {
[16:09:29.792]         if (!identical(...future.workdir, getwd())) 
[16:09:29.792]             setwd(...future.workdir)
[16:09:29.792]         {
[16:09:29.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:29.792]                 ...future.oldOptions$nwarnings <- NULL
[16:09:29.792]             }
[16:09:29.792]             base::options(...future.oldOptions)
[16:09:29.792]             if (.Platform$OS.type == "windows") {
[16:09:29.792]                 old_names <- names(...future.oldEnvVars)
[16:09:29.792]                 envs <- base::Sys.getenv()
[16:09:29.792]                 names <- names(envs)
[16:09:29.792]                 common <- intersect(names, old_names)
[16:09:29.792]                 added <- setdiff(names, old_names)
[16:09:29.792]                 removed <- setdiff(old_names, names)
[16:09:29.792]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:29.792]                   envs[common]]
[16:09:29.792]                 NAMES <- toupper(changed)
[16:09:29.792]                 args <- list()
[16:09:29.792]                 for (kk in seq_along(NAMES)) {
[16:09:29.792]                   name <- changed[[kk]]
[16:09:29.792]                   NAME <- NAMES[[kk]]
[16:09:29.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.792]                     next
[16:09:29.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:29.792]                 }
[16:09:29.792]                 NAMES <- toupper(added)
[16:09:29.792]                 for (kk in seq_along(NAMES)) {
[16:09:29.792]                   name <- added[[kk]]
[16:09:29.792]                   NAME <- NAMES[[kk]]
[16:09:29.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.792]                     next
[16:09:29.792]                   args[[name]] <- ""
[16:09:29.792]                 }
[16:09:29.792]                 NAMES <- toupper(removed)
[16:09:29.792]                 for (kk in seq_along(NAMES)) {
[16:09:29.792]                   name <- removed[[kk]]
[16:09:29.792]                   NAME <- NAMES[[kk]]
[16:09:29.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:29.792]                     next
[16:09:29.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:29.792]                 }
[16:09:29.792]                 if (length(args) > 0) 
[16:09:29.792]                   base::do.call(base::Sys.setenv, args = args)
[16:09:29.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:29.792]             }
[16:09:29.792]             else {
[16:09:29.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:29.792]             }
[16:09:29.792]             {
[16:09:29.792]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:29.792]                   0L) {
[16:09:29.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:29.792]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:29.792]                   base::options(opts)
[16:09:29.792]                 }
[16:09:29.792]                 {
[16:09:29.792]                   {
[16:09:29.792]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:29.792]                     NULL
[16:09:29.792]                   }
[16:09:29.792]                   options(future.plan = NULL)
[16:09:29.792]                   if (is.na(NA_character_)) 
[16:09:29.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:29.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:29.792]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:29.792]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:29.792]                     envir = parent.frame()) 
[16:09:29.792]                   {
[16:09:29.792]                     if (is.function(workers)) 
[16:09:29.792]                       workers <- workers()
[16:09:29.792]                     workers <- structure(as.integer(workers), 
[16:09:29.792]                       class = class(workers))
[16:09:29.792]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:29.792]                       workers >= 1)
[16:09:29.792]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:29.792]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:29.792]                     }
[16:09:29.792]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:29.792]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:29.792]                       envir = envir)
[16:09:29.792]                     if (!future$lazy) 
[16:09:29.792]                       future <- run(future)
[16:09:29.792]                     invisible(future)
[16:09:29.792]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:29.792]                 }
[16:09:29.792]             }
[16:09:29.792]         }
[16:09:29.792]     })
[16:09:29.792]     if (TRUE) {
[16:09:29.792]         base::sink(type = "output", split = FALSE)
[16:09:29.792]         if (TRUE) {
[16:09:29.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:29.792]         }
[16:09:29.792]         else {
[16:09:29.792]             ...future.result["stdout"] <- base::list(NULL)
[16:09:29.792]         }
[16:09:29.792]         base::close(...future.stdout)
[16:09:29.792]         ...future.stdout <- NULL
[16:09:29.792]     }
[16:09:29.792]     ...future.result$conditions <- ...future.conditions
[16:09:29.792]     ...future.result$finished <- base::Sys.time()
[16:09:29.792]     ...future.result
[16:09:29.792] }
[16:09:29.863] Exporting 5 global objects (346.00 KiB) to cluster node #2 ...
[16:09:29.864] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:29.864] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:29.864] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:09:29.908] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:09:29.908] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:09:29.909] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:09:29.909] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:29.909] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:29.909] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:29.909] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:29.909] Exporting 5 global objects (346.00 KiB) to cluster node #2 ... DONE
[16:09:29.910] MultisessionFuture started
[16:09:29.910] - Launch lazy future ... done
[16:09:29.910] run() for ‘MultisessionFuture’ ... done
[16:09:29.910] Created future:
[16:09:29.910] MultisessionFuture:
[16:09:29.910] Label: ‘future_apply-2’
[16:09:29.910] Expression:
[16:09:29.910] {
[16:09:29.910]     do.call(function(...) {
[16:09:29.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:29.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:29.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:29.910]             on.exit(options(oopts), add = TRUE)
[16:09:29.910]         }
[16:09:29.910]         {
[16:09:29.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:29.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:29.910]                 ...future.FUN(...future.X_jj, ...)
[16:09:29.910]             })
[16:09:29.910]         }
[16:09:29.910]     }, args = future.call.arguments)
[16:09:29.910] }
[16:09:29.910] Lazy evaluation: FALSE
[16:09:29.910] Asynchronous evaluation: TRUE
[16:09:29.910] Local evaluation: TRUE
[16:09:29.910] Environment: R_GlobalEnv
[16:09:29.910] Capture standard output: TRUE
[16:09:29.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:29.910] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:29.910] Packages: <none>
[16:09:29.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:29.910] Resolved: FALSE
[16:09:29.910] Value: <not collected>
[16:09:29.910] Conditions captured: <none>
[16:09:29.910] Early signaling: FALSE
[16:09:29.910] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:29.910] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:29.922] Chunk #2 of 2 ... DONE
[16:09:29.922] Launching 2 futures (chunks) ... DONE
[16:09:29.922] Resolving 2 futures (chunks) ...
[16:09:29.922] resolve() on list ...
[16:09:29.923]  recursive: 0
[16:09:29.923]  length: 2
[16:09:29.923] 
[16:09:29.923] receiveMessageFromWorker() for ClusterFuture ...
[16:09:29.923] - Validating connection of MultisessionFuture
[16:09:29.923] - received message: FutureResult
[16:09:29.923] - Received FutureResult
[16:09:29.924] - Erased future from FutureRegistry
[16:09:29.924] result() for ClusterFuture ...
[16:09:29.924] - result already collected: FutureResult
[16:09:29.924] result() for ClusterFuture ... done
[16:09:29.924] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:29.924] Future #1
[16:09:29.924] result() for ClusterFuture ...
[16:09:29.924] - result already collected: FutureResult
[16:09:29.924] result() for ClusterFuture ... done
[16:09:29.924] result() for ClusterFuture ...
[16:09:29.924] - result already collected: FutureResult
[16:09:29.925] result() for ClusterFuture ... done
[16:09:29.925] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:29.925] - nx: 2
[16:09:29.925] - relay: TRUE
[16:09:29.925] - stdout: TRUE
[16:09:29.925] - signal: TRUE
[16:09:29.925] - resignal: FALSE
[16:09:29.925] - force: TRUE
[16:09:29.925] - relayed: [n=2] FALSE, FALSE
[16:09:29.925] - queued futures: [n=2] FALSE, FALSE
[16:09:29.925]  - until=1
[16:09:29.926]  - relaying element #1
[16:09:29.926] result() for ClusterFuture ...
[16:09:29.926] - result already collected: FutureResult
[16:09:29.926] result() for ClusterFuture ... done
[16:09:29.926] result() for ClusterFuture ...
[16:09:29.926] - result already collected: FutureResult
[16:09:29.926] result() for ClusterFuture ... done
[16:09:29.926] result() for ClusterFuture ...
[16:09:29.926] - result already collected: FutureResult
[16:09:29.926] result() for ClusterFuture ... done
[16:09:29.926] result() for ClusterFuture ...
[16:09:29.926] - result already collected: FutureResult
[16:09:29.927] result() for ClusterFuture ... done
[16:09:29.927] - relayed: [n=2] TRUE, FALSE
[16:09:29.927] - queued futures: [n=2] TRUE, FALSE
[16:09:29.927] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:29.927]  length: 1 (resolved future 1)
[16:09:29.989] receiveMessageFromWorker() for ClusterFuture ...
[16:09:29.989] - Validating connection of MultisessionFuture
[16:09:29.989] - received message: FutureResult
[16:09:29.990] - Received FutureResult
[16:09:29.990] - Erased future from FutureRegistry
[16:09:29.990] result() for ClusterFuture ...
[16:09:29.990] - result already collected: FutureResult
[16:09:29.990] result() for ClusterFuture ... done
[16:09:29.990] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:29.990] Future #2
[16:09:29.990] result() for ClusterFuture ...
[16:09:29.990] - result already collected: FutureResult
[16:09:29.990] result() for ClusterFuture ... done
[16:09:29.991] result() for ClusterFuture ...
[16:09:29.991] - result already collected: FutureResult
[16:09:29.991] result() for ClusterFuture ... done
[16:09:29.991] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:29.991] - nx: 2
[16:09:29.991] - relay: TRUE
[16:09:29.991] - stdout: TRUE
[16:09:29.991] - signal: TRUE
[16:09:29.991] - resignal: FALSE
[16:09:29.991] - force: TRUE
[16:09:29.991] - relayed: [n=2] TRUE, FALSE
[16:09:29.992] - queued futures: [n=2] TRUE, FALSE
[16:09:29.992]  - until=2
[16:09:29.992]  - relaying element #2
[16:09:29.992] result() for ClusterFuture ...
[16:09:29.992] - result already collected: FutureResult
[16:09:29.992] result() for ClusterFuture ... done
[16:09:29.992] result() for ClusterFuture ...
[16:09:29.992] - result already collected: FutureResult
[16:09:29.992] result() for ClusterFuture ... done
[16:09:29.992] result() for ClusterFuture ...
[16:09:29.993] - result already collected: FutureResult
[16:09:29.993] result() for ClusterFuture ... done
[16:09:29.993] result() for ClusterFuture ...
[16:09:29.993] - result already collected: FutureResult
[16:09:29.993] result() for ClusterFuture ... done
[16:09:29.993] - relayed: [n=2] TRUE, TRUE
[16:09:29.993] - queued futures: [n=2] TRUE, TRUE
[16:09:29.993] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:29.993]  length: 0 (resolved future 2)
[16:09:29.993] Relaying remaining futures
[16:09:29.993] signalConditionsASAP(NULL, pos=0) ...
[16:09:29.993] - nx: 2
[16:09:29.994] - relay: TRUE
[16:09:29.994] - stdout: TRUE
[16:09:29.994] - signal: TRUE
[16:09:29.994] - resignal: FALSE
[16:09:29.994] - force: TRUE
[16:09:29.994] - relayed: [n=2] TRUE, TRUE
[16:09:29.994] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:29.994] - relayed: [n=2] TRUE, TRUE
[16:09:29.994] - queued futures: [n=2] TRUE, TRUE
[16:09:29.994] signalConditionsASAP(NULL, pos=0) ... done
[16:09:29.994] resolve() on list ... DONE
[16:09:29.995] result() for ClusterFuture ...
[16:09:29.995] - result already collected: FutureResult
[16:09:29.995] result() for ClusterFuture ... done
[16:09:29.995] result() for ClusterFuture ...
[16:09:29.995] - result already collected: FutureResult
[16:09:29.995] result() for ClusterFuture ... done
[16:09:29.995] result() for ClusterFuture ...
[16:09:29.995] - result already collected: FutureResult
[16:09:29.995] result() for ClusterFuture ... done
[16:09:29.995] result() for ClusterFuture ...
[16:09:29.995] - result already collected: FutureResult
[16:09:29.996] result() for ClusterFuture ... done
[16:09:29.996]  - Number of value chunks collected: 2
[16:09:29.996] Resolving 2 futures (chunks) ... DONE
[16:09:29.996] Reducing values from 2 chunks ...
[16:09:29.996]  - Number of values collected after concatenation: 2
[16:09:29.996]  - Number of values expected: 2
[16:09:29.996] Reducing values from 2 chunks ... DONE
[16:09:29.996] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:09:29.997] getGlobalsAndPackagesXApply() ...
[16:09:29.997]  - future.globals: TRUE
[16:09:29.997] getGlobalsAndPackages() ...
[16:09:29.997] Searching for globals...
[16:09:30.029] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:09:30.029] Searching for globals ... DONE
[16:09:30.029] Resolving globals: FALSE
[16:09:30.031] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:09:30.032] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:09:30.032] - globals: [1] ‘FUN’
[16:09:30.032] 
[16:09:30.032] getGlobalsAndPackages() ... DONE
[16:09:30.032]  - globals found/used: [n=1] ‘FUN’
[16:09:30.032]  - needed namespaces: [n=0] 
[16:09:30.032] Finding globals ... DONE
[16:09:30.032]  - use_args: TRUE
[16:09:30.032]  - Getting '...' globals ...
[16:09:30.033] resolve() on list ...
[16:09:30.033]  recursive: 0
[16:09:30.033]  length: 1
[16:09:30.033]  elements: ‘...’
[16:09:30.033]  length: 0 (resolved future 1)
[16:09:30.033] resolve() on list ... DONE
[16:09:30.033]    - '...' content: [n=0] 
[16:09:30.033] List of 1
[16:09:30.033]  $ ...: list()
[16:09:30.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.033]  - attr(*, "where")=List of 1
[16:09:30.033]   ..$ ...:<environment: 0x5633ab01df78> 
[16:09:30.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.033]  - attr(*, "resolved")= logi TRUE
[16:09:30.033]  - attr(*, "total_size")= num NA
[16:09:30.036]  - Getting '...' globals ... DONE
[16:09:30.036] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:30.036] List of 2
[16:09:30.036]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:30.036]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:30.036]  $ ...          : list()
[16:09:30.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.036]  - attr(*, "where")=List of 2
[16:09:30.036]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:30.036]   ..$ ...          :<environment: 0x5633ab01df78> 
[16:09:30.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.036]  - attr(*, "resolved")= logi FALSE
[16:09:30.036]  - attr(*, "total_size")= num 354224
[16:09:30.039] Packages to be attached in all futures: [n=0] 
[16:09:30.039] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.042] future_lapply() ...
[16:09:30.077] Number of chunks: 2
[16:09:30.078] getGlobalsAndPackagesXApply() ...
[16:09:30.078]  - future.globals: <name-value list> with names ‘list()’
[16:09:30.078]  - use_args: TRUE
[16:09:30.078] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:30.078] List of 2
[16:09:30.078]  $ ...          : list()
[16:09:30.078]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.078]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:09:30.078]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:09:30.078]  - attr(*, "where")=List of 2
[16:09:30.078]   ..$ ...          :<environment: 0x5633ab01df78> 
[16:09:30.078]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:30.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.078]  - attr(*, "resolved")= logi FALSE
[16:09:30.078]  - attr(*, "total_size")= num NA
[16:09:30.082] Packages to be attached in all futures: [n=0] 
[16:09:30.082] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.082] Number of futures (= number of chunks): 2
[16:09:30.082] Launching 2 futures (chunks) ...
[16:09:30.082] Chunk #1 of 2 ...
[16:09:30.082]  - seeds: <none>
[16:09:30.083] getGlobalsAndPackages() ...
[16:09:30.083] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.083] Resolving globals: FALSE
[16:09:30.083] Tweak future expression to call with '...' arguments ...
[16:09:30.083] {
[16:09:30.083]     do.call(function(...) {
[16:09:30.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.083]             on.exit(options(oopts), add = TRUE)
[16:09:30.083]         }
[16:09:30.083]         {
[16:09:30.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.083]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.083]             })
[16:09:30.083]         }
[16:09:30.083]     }, args = future.call.arguments)
[16:09:30.083] }
[16:09:30.083] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.084] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.084] 
[16:09:30.084] getGlobalsAndPackages() ... DONE
[16:09:30.084] run() for ‘Future’ ...
[16:09:30.084] - state: ‘created’
[16:09:30.084] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.099]   - Field: ‘node’
[16:09:30.099]   - Field: ‘label’
[16:09:30.099]   - Field: ‘local’
[16:09:30.099]   - Field: ‘owner’
[16:09:30.099]   - Field: ‘envir’
[16:09:30.099]   - Field: ‘workers’
[16:09:30.099]   - Field: ‘packages’
[16:09:30.100]   - Field: ‘gc’
[16:09:30.100]   - Field: ‘conditions’
[16:09:30.100]   - Field: ‘persistent’
[16:09:30.100]   - Field: ‘expr’
[16:09:30.100]   - Field: ‘uuid’
[16:09:30.100]   - Field: ‘seed’
[16:09:30.100]   - Field: ‘version’
[16:09:30.100]   - Field: ‘result’
[16:09:30.100]   - Field: ‘asynchronous’
[16:09:30.100]   - Field: ‘calls’
[16:09:30.100]   - Field: ‘globals’
[16:09:30.101]   - Field: ‘stdout’
[16:09:30.101]   - Field: ‘earlySignal’
[16:09:30.101]   - Field: ‘lazy’
[16:09:30.101]   - Field: ‘state’
[16:09:30.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.101] - Launch lazy future ...
[16:09:30.101] Packages needed by the future expression (n = 0): <none>
[16:09:30.101] Packages needed by future strategies (n = 0): <none>
[16:09:30.102] {
[16:09:30.102]     {
[16:09:30.102]         {
[16:09:30.102]             ...future.startTime <- base::Sys.time()
[16:09:30.102]             {
[16:09:30.102]                 {
[16:09:30.102]                   {
[16:09:30.102]                     {
[16:09:30.102]                       base::local({
[16:09:30.102]                         has_future <- base::requireNamespace("future", 
[16:09:30.102]                           quietly = TRUE)
[16:09:30.102]                         if (has_future) {
[16:09:30.102]                           ns <- base::getNamespace("future")
[16:09:30.102]                           version <- ns[[".package"]][["version"]]
[16:09:30.102]                           if (is.null(version)) 
[16:09:30.102]                             version <- utils::packageVersion("future")
[16:09:30.102]                         }
[16:09:30.102]                         else {
[16:09:30.102]                           version <- NULL
[16:09:30.102]                         }
[16:09:30.102]                         if (!has_future || version < "1.8.0") {
[16:09:30.102]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.102]                             "", base::R.version$version.string), 
[16:09:30.102]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.102]                               "release", "version")], collapse = " "), 
[16:09:30.102]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.102]                             info)
[16:09:30.102]                           info <- base::paste(info, collapse = "; ")
[16:09:30.102]                           if (!has_future) {
[16:09:30.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.102]                               info)
[16:09:30.102]                           }
[16:09:30.102]                           else {
[16:09:30.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.102]                               info, version)
[16:09:30.102]                           }
[16:09:30.102]                           base::stop(msg)
[16:09:30.102]                         }
[16:09:30.102]                       })
[16:09:30.102]                     }
[16:09:30.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.102]                     base::options(mc.cores = 1L)
[16:09:30.102]                   }
[16:09:30.102]                   options(future.plan = NULL)
[16:09:30.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.102]                 }
[16:09:30.102]                 ...future.workdir <- getwd()
[16:09:30.102]             }
[16:09:30.102]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.102]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.102]         }
[16:09:30.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.102]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.102]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.102]             base::names(...future.oldOptions))
[16:09:30.102]     }
[16:09:30.102]     if (FALSE) {
[16:09:30.102]     }
[16:09:30.102]     else {
[16:09:30.102]         if (TRUE) {
[16:09:30.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.102]                 open = "w")
[16:09:30.102]         }
[16:09:30.102]         else {
[16:09:30.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.102]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.102]         }
[16:09:30.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.102]             base::sink(type = "output", split = FALSE)
[16:09:30.102]             base::close(...future.stdout)
[16:09:30.102]         }, add = TRUE)
[16:09:30.102]     }
[16:09:30.102]     ...future.frame <- base::sys.nframe()
[16:09:30.102]     ...future.conditions <- base::list()
[16:09:30.102]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.102]     if (FALSE) {
[16:09:30.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.102]     }
[16:09:30.102]     ...future.result <- base::tryCatch({
[16:09:30.102]         base::withCallingHandlers({
[16:09:30.102]             ...future.value <- base::withVisible(base::local({
[16:09:30.102]                 ...future.makeSendCondition <- local({
[16:09:30.102]                   sendCondition <- NULL
[16:09:30.102]                   function(frame = 1L) {
[16:09:30.102]                     if (is.function(sendCondition)) 
[16:09:30.102]                       return(sendCondition)
[16:09:30.102]                     ns <- getNamespace("parallel")
[16:09:30.102]                     if (exists("sendData", mode = "function", 
[16:09:30.102]                       envir = ns)) {
[16:09:30.102]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.102]                         envir = ns)
[16:09:30.102]                       envir <- sys.frame(frame)
[16:09:30.102]                       master <- NULL
[16:09:30.102]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.102]                         !identical(envir, emptyenv())) {
[16:09:30.102]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.102]                           inherits = FALSE)) {
[16:09:30.102]                           master <- get("master", mode = "list", 
[16:09:30.102]                             envir = envir, inherits = FALSE)
[16:09:30.102]                           if (inherits(master, c("SOCKnode", 
[16:09:30.102]                             "SOCK0node"))) {
[16:09:30.102]                             sendCondition <<- function(cond) {
[16:09:30.102]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.102]                                 success = TRUE)
[16:09:30.102]                               parallel_sendData(master, data)
[16:09:30.102]                             }
[16:09:30.102]                             return(sendCondition)
[16:09:30.102]                           }
[16:09:30.102]                         }
[16:09:30.102]                         frame <- frame + 1L
[16:09:30.102]                         envir <- sys.frame(frame)
[16:09:30.102]                       }
[16:09:30.102]                     }
[16:09:30.102]                     sendCondition <<- function(cond) NULL
[16:09:30.102]                   }
[16:09:30.102]                 })
[16:09:30.102]                 withCallingHandlers({
[16:09:30.102]                   {
[16:09:30.102]                     do.call(function(...) {
[16:09:30.102]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.102]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.102]                         ...future.globals.maxSize)) {
[16:09:30.102]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.102]                         on.exit(options(oopts), add = TRUE)
[16:09:30.102]                       }
[16:09:30.102]                       {
[16:09:30.102]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.102]                           FUN = function(jj) {
[16:09:30.102]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.102]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.102]                           })
[16:09:30.102]                       }
[16:09:30.102]                     }, args = future.call.arguments)
[16:09:30.102]                   }
[16:09:30.102]                 }, immediateCondition = function(cond) {
[16:09:30.102]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.102]                   sendCondition(cond)
[16:09:30.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.102]                   {
[16:09:30.102]                     inherits <- base::inherits
[16:09:30.102]                     invokeRestart <- base::invokeRestart
[16:09:30.102]                     is.null <- base::is.null
[16:09:30.102]                     muffled <- FALSE
[16:09:30.102]                     if (inherits(cond, "message")) {
[16:09:30.102]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.102]                       if (muffled) 
[16:09:30.102]                         invokeRestart("muffleMessage")
[16:09:30.102]                     }
[16:09:30.102]                     else if (inherits(cond, "warning")) {
[16:09:30.102]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.102]                       if (muffled) 
[16:09:30.102]                         invokeRestart("muffleWarning")
[16:09:30.102]                     }
[16:09:30.102]                     else if (inherits(cond, "condition")) {
[16:09:30.102]                       if (!is.null(pattern)) {
[16:09:30.102]                         computeRestarts <- base::computeRestarts
[16:09:30.102]                         grepl <- base::grepl
[16:09:30.102]                         restarts <- computeRestarts(cond)
[16:09:30.102]                         for (restart in restarts) {
[16:09:30.102]                           name <- restart$name
[16:09:30.102]                           if (is.null(name)) 
[16:09:30.102]                             next
[16:09:30.102]                           if (!grepl(pattern, name)) 
[16:09:30.102]                             next
[16:09:30.102]                           invokeRestart(restart)
[16:09:30.102]                           muffled <- TRUE
[16:09:30.102]                           break
[16:09:30.102]                         }
[16:09:30.102]                       }
[16:09:30.102]                     }
[16:09:30.102]                     invisible(muffled)
[16:09:30.102]                   }
[16:09:30.102]                   muffleCondition(cond)
[16:09:30.102]                 })
[16:09:30.102]             }))
[16:09:30.102]             future::FutureResult(value = ...future.value$value, 
[16:09:30.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.102]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.102]                     ...future.globalenv.names))
[16:09:30.102]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.102]         }, condition = base::local({
[16:09:30.102]             c <- base::c
[16:09:30.102]             inherits <- base::inherits
[16:09:30.102]             invokeRestart <- base::invokeRestart
[16:09:30.102]             length <- base::length
[16:09:30.102]             list <- base::list
[16:09:30.102]             seq.int <- base::seq.int
[16:09:30.102]             signalCondition <- base::signalCondition
[16:09:30.102]             sys.calls <- base::sys.calls
[16:09:30.102]             `[[` <- base::`[[`
[16:09:30.102]             `+` <- base::`+`
[16:09:30.102]             `<<-` <- base::`<<-`
[16:09:30.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.102]                   3L)]
[16:09:30.102]             }
[16:09:30.102]             function(cond) {
[16:09:30.102]                 is_error <- inherits(cond, "error")
[16:09:30.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.102]                   NULL)
[16:09:30.102]                 if (is_error) {
[16:09:30.102]                   sessionInformation <- function() {
[16:09:30.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.102]                       search = base::search(), system = base::Sys.info())
[16:09:30.102]                   }
[16:09:30.102]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.102]                     cond$call), session = sessionInformation(), 
[16:09:30.102]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.102]                   signalCondition(cond)
[16:09:30.102]                 }
[16:09:30.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.102]                 "immediateCondition"))) {
[16:09:30.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.102]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.102]                   if (TRUE && !signal) {
[16:09:30.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.102]                     {
[16:09:30.102]                       inherits <- base::inherits
[16:09:30.102]                       invokeRestart <- base::invokeRestart
[16:09:30.102]                       is.null <- base::is.null
[16:09:30.102]                       muffled <- FALSE
[16:09:30.102]                       if (inherits(cond, "message")) {
[16:09:30.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.102]                         if (muffled) 
[16:09:30.102]                           invokeRestart("muffleMessage")
[16:09:30.102]                       }
[16:09:30.102]                       else if (inherits(cond, "warning")) {
[16:09:30.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.102]                         if (muffled) 
[16:09:30.102]                           invokeRestart("muffleWarning")
[16:09:30.102]                       }
[16:09:30.102]                       else if (inherits(cond, "condition")) {
[16:09:30.102]                         if (!is.null(pattern)) {
[16:09:30.102]                           computeRestarts <- base::computeRestarts
[16:09:30.102]                           grepl <- base::grepl
[16:09:30.102]                           restarts <- computeRestarts(cond)
[16:09:30.102]                           for (restart in restarts) {
[16:09:30.102]                             name <- restart$name
[16:09:30.102]                             if (is.null(name)) 
[16:09:30.102]                               next
[16:09:30.102]                             if (!grepl(pattern, name)) 
[16:09:30.102]                               next
[16:09:30.102]                             invokeRestart(restart)
[16:09:30.102]                             muffled <- TRUE
[16:09:30.102]                             break
[16:09:30.102]                           }
[16:09:30.102]                         }
[16:09:30.102]                       }
[16:09:30.102]                       invisible(muffled)
[16:09:30.102]                     }
[16:09:30.102]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.102]                   }
[16:09:30.102]                 }
[16:09:30.102]                 else {
[16:09:30.102]                   if (TRUE) {
[16:09:30.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.102]                     {
[16:09:30.102]                       inherits <- base::inherits
[16:09:30.102]                       invokeRestart <- base::invokeRestart
[16:09:30.102]                       is.null <- base::is.null
[16:09:30.102]                       muffled <- FALSE
[16:09:30.102]                       if (inherits(cond, "message")) {
[16:09:30.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.102]                         if (muffled) 
[16:09:30.102]                           invokeRestart("muffleMessage")
[16:09:30.102]                       }
[16:09:30.102]                       else if (inherits(cond, "warning")) {
[16:09:30.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.102]                         if (muffled) 
[16:09:30.102]                           invokeRestart("muffleWarning")
[16:09:30.102]                       }
[16:09:30.102]                       else if (inherits(cond, "condition")) {
[16:09:30.102]                         if (!is.null(pattern)) {
[16:09:30.102]                           computeRestarts <- base::computeRestarts
[16:09:30.102]                           grepl <- base::grepl
[16:09:30.102]                           restarts <- computeRestarts(cond)
[16:09:30.102]                           for (restart in restarts) {
[16:09:30.102]                             name <- restart$name
[16:09:30.102]                             if (is.null(name)) 
[16:09:30.102]                               next
[16:09:30.102]                             if (!grepl(pattern, name)) 
[16:09:30.102]                               next
[16:09:30.102]                             invokeRestart(restart)
[16:09:30.102]                             muffled <- TRUE
[16:09:30.102]                             break
[16:09:30.102]                           }
[16:09:30.102]                         }
[16:09:30.102]                       }
[16:09:30.102]                       invisible(muffled)
[16:09:30.102]                     }
[16:09:30.102]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.102]                   }
[16:09:30.102]                 }
[16:09:30.102]             }
[16:09:30.102]         }))
[16:09:30.102]     }, error = function(ex) {
[16:09:30.102]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.102]                 ...future.rng), started = ...future.startTime, 
[16:09:30.102]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.102]             version = "1.8"), class = "FutureResult")
[16:09:30.102]     }, finally = {
[16:09:30.102]         if (!identical(...future.workdir, getwd())) 
[16:09:30.102]             setwd(...future.workdir)
[16:09:30.102]         {
[16:09:30.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.102]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.102]             }
[16:09:30.102]             base::options(...future.oldOptions)
[16:09:30.102]             if (.Platform$OS.type == "windows") {
[16:09:30.102]                 old_names <- names(...future.oldEnvVars)
[16:09:30.102]                 envs <- base::Sys.getenv()
[16:09:30.102]                 names <- names(envs)
[16:09:30.102]                 common <- intersect(names, old_names)
[16:09:30.102]                 added <- setdiff(names, old_names)
[16:09:30.102]                 removed <- setdiff(old_names, names)
[16:09:30.102]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.102]                   envs[common]]
[16:09:30.102]                 NAMES <- toupper(changed)
[16:09:30.102]                 args <- list()
[16:09:30.102]                 for (kk in seq_along(NAMES)) {
[16:09:30.102]                   name <- changed[[kk]]
[16:09:30.102]                   NAME <- NAMES[[kk]]
[16:09:30.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.102]                     next
[16:09:30.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.102]                 }
[16:09:30.102]                 NAMES <- toupper(added)
[16:09:30.102]                 for (kk in seq_along(NAMES)) {
[16:09:30.102]                   name <- added[[kk]]
[16:09:30.102]                   NAME <- NAMES[[kk]]
[16:09:30.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.102]                     next
[16:09:30.102]                   args[[name]] <- ""
[16:09:30.102]                 }
[16:09:30.102]                 NAMES <- toupper(removed)
[16:09:30.102]                 for (kk in seq_along(NAMES)) {
[16:09:30.102]                   name <- removed[[kk]]
[16:09:30.102]                   NAME <- NAMES[[kk]]
[16:09:30.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.102]                     next
[16:09:30.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.102]                 }
[16:09:30.102]                 if (length(args) > 0) 
[16:09:30.102]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.102]             }
[16:09:30.102]             else {
[16:09:30.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.102]             }
[16:09:30.102]             {
[16:09:30.102]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.102]                   0L) {
[16:09:30.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.102]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.102]                   base::options(opts)
[16:09:30.102]                 }
[16:09:30.102]                 {
[16:09:30.102]                   {
[16:09:30.102]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.102]                     NULL
[16:09:30.102]                   }
[16:09:30.102]                   options(future.plan = NULL)
[16:09:30.102]                   if (is.na(NA_character_)) 
[16:09:30.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.102]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.102]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.102]                     envir = parent.frame()) 
[16:09:30.102]                   {
[16:09:30.102]                     if (is.function(workers)) 
[16:09:30.102]                       workers <- workers()
[16:09:30.102]                     workers <- structure(as.integer(workers), 
[16:09:30.102]                       class = class(workers))
[16:09:30.102]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.102]                       workers >= 1)
[16:09:30.102]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.102]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.102]                     }
[16:09:30.102]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.102]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.102]                       envir = envir)
[16:09:30.102]                     if (!future$lazy) 
[16:09:30.102]                       future <- run(future)
[16:09:30.102]                     invisible(future)
[16:09:30.102]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.102]                 }
[16:09:30.102]             }
[16:09:30.102]         }
[16:09:30.102]     })
[16:09:30.102]     if (TRUE) {
[16:09:30.102]         base::sink(type = "output", split = FALSE)
[16:09:30.102]         if (TRUE) {
[16:09:30.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.102]         }
[16:09:30.102]         else {
[16:09:30.102]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.102]         }
[16:09:30.102]         base::close(...future.stdout)
[16:09:30.102]         ...future.stdout <- NULL
[16:09:30.102]     }
[16:09:30.102]     ...future.result$conditions <- ...future.conditions
[16:09:30.102]     ...future.result$finished <- base::Sys.time()
[16:09:30.102]     ...future.result
[16:09:30.102] }
[16:09:30.105] Exporting 5 global objects (346.00 KiB) to cluster node #1 ...
[16:09:30.105] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:30.105] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.106] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:09:30.148] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:09:30.148] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:09:30.149] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:09:30.149] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:30.149] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:30.150] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.150] Exporting 5 global objects (346.00 KiB) to cluster node #1 ... DONE
[16:09:30.150] MultisessionFuture started
[16:09:30.151] - Launch lazy future ... done
[16:09:30.151] run() for ‘MultisessionFuture’ ... done
[16:09:30.151] Created future:
[16:09:30.151] MultisessionFuture:
[16:09:30.151] Label: ‘future_apply-1’
[16:09:30.151] Expression:
[16:09:30.151] {
[16:09:30.151]     do.call(function(...) {
[16:09:30.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.151]             on.exit(options(oopts), add = TRUE)
[16:09:30.151]         }
[16:09:30.151]         {
[16:09:30.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.151]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.151]             })
[16:09:30.151]         }
[16:09:30.151]     }, args = future.call.arguments)
[16:09:30.151] }
[16:09:30.151] Lazy evaluation: FALSE
[16:09:30.151] Asynchronous evaluation: TRUE
[16:09:30.151] Local evaluation: TRUE
[16:09:30.151] Environment: R_GlobalEnv
[16:09:30.151] Capture standard output: TRUE
[16:09:30.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.151] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.151] Packages: <none>
[16:09:30.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.151] Resolved: FALSE
[16:09:30.151] Value: <not collected>
[16:09:30.151] Conditions captured: <none>
[16:09:30.151] Early signaling: FALSE
[16:09:30.151] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.151] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.162] Chunk #1 of 2 ... DONE
[16:09:30.162] Chunk #2 of 2 ...
[16:09:30.163]  - seeds: <none>
[16:09:30.163] getGlobalsAndPackages() ...
[16:09:30.163] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.163] Resolving globals: FALSE
[16:09:30.163] Tweak future expression to call with '...' arguments ...
[16:09:30.163] {
[16:09:30.163]     do.call(function(...) {
[16:09:30.163]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.163]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.163]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.163]             on.exit(options(oopts), add = TRUE)
[16:09:30.163]         }
[16:09:30.163]         {
[16:09:30.163]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.163]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.163]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.163]             })
[16:09:30.163]         }
[16:09:30.163]     }, args = future.call.arguments)
[16:09:30.163] }
[16:09:30.163] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.164] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.164] 
[16:09:30.164] getGlobalsAndPackages() ... DONE
[16:09:30.164] run() for ‘Future’ ...
[16:09:30.164] - state: ‘created’
[16:09:30.164] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.179] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.179]   - Field: ‘node’
[16:09:30.179]   - Field: ‘label’
[16:09:30.179]   - Field: ‘local’
[16:09:30.179]   - Field: ‘owner’
[16:09:30.179]   - Field: ‘envir’
[16:09:30.179]   - Field: ‘workers’
[16:09:30.179]   - Field: ‘packages’
[16:09:30.179]   - Field: ‘gc’
[16:09:30.180]   - Field: ‘conditions’
[16:09:30.180]   - Field: ‘persistent’
[16:09:30.180]   - Field: ‘expr’
[16:09:30.180]   - Field: ‘uuid’
[16:09:30.180]   - Field: ‘seed’
[16:09:30.180]   - Field: ‘version’
[16:09:30.180]   - Field: ‘result’
[16:09:30.180]   - Field: ‘asynchronous’
[16:09:30.180]   - Field: ‘calls’
[16:09:30.180]   - Field: ‘globals’
[16:09:30.180]   - Field: ‘stdout’
[16:09:30.181]   - Field: ‘earlySignal’
[16:09:30.181]   - Field: ‘lazy’
[16:09:30.181]   - Field: ‘state’
[16:09:30.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.181] - Launch lazy future ...
[16:09:30.181] Packages needed by the future expression (n = 0): <none>
[16:09:30.181] Packages needed by future strategies (n = 0): <none>
[16:09:30.182] {
[16:09:30.182]     {
[16:09:30.182]         {
[16:09:30.182]             ...future.startTime <- base::Sys.time()
[16:09:30.182]             {
[16:09:30.182]                 {
[16:09:30.182]                   {
[16:09:30.182]                     {
[16:09:30.182]                       base::local({
[16:09:30.182]                         has_future <- base::requireNamespace("future", 
[16:09:30.182]                           quietly = TRUE)
[16:09:30.182]                         if (has_future) {
[16:09:30.182]                           ns <- base::getNamespace("future")
[16:09:30.182]                           version <- ns[[".package"]][["version"]]
[16:09:30.182]                           if (is.null(version)) 
[16:09:30.182]                             version <- utils::packageVersion("future")
[16:09:30.182]                         }
[16:09:30.182]                         else {
[16:09:30.182]                           version <- NULL
[16:09:30.182]                         }
[16:09:30.182]                         if (!has_future || version < "1.8.0") {
[16:09:30.182]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.182]                             "", base::R.version$version.string), 
[16:09:30.182]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.182]                               "release", "version")], collapse = " "), 
[16:09:30.182]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.182]                             info)
[16:09:30.182]                           info <- base::paste(info, collapse = "; ")
[16:09:30.182]                           if (!has_future) {
[16:09:30.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.182]                               info)
[16:09:30.182]                           }
[16:09:30.182]                           else {
[16:09:30.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.182]                               info, version)
[16:09:30.182]                           }
[16:09:30.182]                           base::stop(msg)
[16:09:30.182]                         }
[16:09:30.182]                       })
[16:09:30.182]                     }
[16:09:30.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.182]                     base::options(mc.cores = 1L)
[16:09:30.182]                   }
[16:09:30.182]                   options(future.plan = NULL)
[16:09:30.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.182]                 }
[16:09:30.182]                 ...future.workdir <- getwd()
[16:09:30.182]             }
[16:09:30.182]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.182]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.182]         }
[16:09:30.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.182]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.182]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.182]             base::names(...future.oldOptions))
[16:09:30.182]     }
[16:09:30.182]     if (FALSE) {
[16:09:30.182]     }
[16:09:30.182]     else {
[16:09:30.182]         if (TRUE) {
[16:09:30.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.182]                 open = "w")
[16:09:30.182]         }
[16:09:30.182]         else {
[16:09:30.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.182]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.182]         }
[16:09:30.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.182]             base::sink(type = "output", split = FALSE)
[16:09:30.182]             base::close(...future.stdout)
[16:09:30.182]         }, add = TRUE)
[16:09:30.182]     }
[16:09:30.182]     ...future.frame <- base::sys.nframe()
[16:09:30.182]     ...future.conditions <- base::list()
[16:09:30.182]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.182]     if (FALSE) {
[16:09:30.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.182]     }
[16:09:30.182]     ...future.result <- base::tryCatch({
[16:09:30.182]         base::withCallingHandlers({
[16:09:30.182]             ...future.value <- base::withVisible(base::local({
[16:09:30.182]                 ...future.makeSendCondition <- local({
[16:09:30.182]                   sendCondition <- NULL
[16:09:30.182]                   function(frame = 1L) {
[16:09:30.182]                     if (is.function(sendCondition)) 
[16:09:30.182]                       return(sendCondition)
[16:09:30.182]                     ns <- getNamespace("parallel")
[16:09:30.182]                     if (exists("sendData", mode = "function", 
[16:09:30.182]                       envir = ns)) {
[16:09:30.182]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.182]                         envir = ns)
[16:09:30.182]                       envir <- sys.frame(frame)
[16:09:30.182]                       master <- NULL
[16:09:30.182]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.182]                         !identical(envir, emptyenv())) {
[16:09:30.182]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.182]                           inherits = FALSE)) {
[16:09:30.182]                           master <- get("master", mode = "list", 
[16:09:30.182]                             envir = envir, inherits = FALSE)
[16:09:30.182]                           if (inherits(master, c("SOCKnode", 
[16:09:30.182]                             "SOCK0node"))) {
[16:09:30.182]                             sendCondition <<- function(cond) {
[16:09:30.182]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.182]                                 success = TRUE)
[16:09:30.182]                               parallel_sendData(master, data)
[16:09:30.182]                             }
[16:09:30.182]                             return(sendCondition)
[16:09:30.182]                           }
[16:09:30.182]                         }
[16:09:30.182]                         frame <- frame + 1L
[16:09:30.182]                         envir <- sys.frame(frame)
[16:09:30.182]                       }
[16:09:30.182]                     }
[16:09:30.182]                     sendCondition <<- function(cond) NULL
[16:09:30.182]                   }
[16:09:30.182]                 })
[16:09:30.182]                 withCallingHandlers({
[16:09:30.182]                   {
[16:09:30.182]                     do.call(function(...) {
[16:09:30.182]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.182]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.182]                         ...future.globals.maxSize)) {
[16:09:30.182]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.182]                         on.exit(options(oopts), add = TRUE)
[16:09:30.182]                       }
[16:09:30.182]                       {
[16:09:30.182]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.182]                           FUN = function(jj) {
[16:09:30.182]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.182]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.182]                           })
[16:09:30.182]                       }
[16:09:30.182]                     }, args = future.call.arguments)
[16:09:30.182]                   }
[16:09:30.182]                 }, immediateCondition = function(cond) {
[16:09:30.182]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.182]                   sendCondition(cond)
[16:09:30.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.182]                   {
[16:09:30.182]                     inherits <- base::inherits
[16:09:30.182]                     invokeRestart <- base::invokeRestart
[16:09:30.182]                     is.null <- base::is.null
[16:09:30.182]                     muffled <- FALSE
[16:09:30.182]                     if (inherits(cond, "message")) {
[16:09:30.182]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.182]                       if (muffled) 
[16:09:30.182]                         invokeRestart("muffleMessage")
[16:09:30.182]                     }
[16:09:30.182]                     else if (inherits(cond, "warning")) {
[16:09:30.182]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.182]                       if (muffled) 
[16:09:30.182]                         invokeRestart("muffleWarning")
[16:09:30.182]                     }
[16:09:30.182]                     else if (inherits(cond, "condition")) {
[16:09:30.182]                       if (!is.null(pattern)) {
[16:09:30.182]                         computeRestarts <- base::computeRestarts
[16:09:30.182]                         grepl <- base::grepl
[16:09:30.182]                         restarts <- computeRestarts(cond)
[16:09:30.182]                         for (restart in restarts) {
[16:09:30.182]                           name <- restart$name
[16:09:30.182]                           if (is.null(name)) 
[16:09:30.182]                             next
[16:09:30.182]                           if (!grepl(pattern, name)) 
[16:09:30.182]                             next
[16:09:30.182]                           invokeRestart(restart)
[16:09:30.182]                           muffled <- TRUE
[16:09:30.182]                           break
[16:09:30.182]                         }
[16:09:30.182]                       }
[16:09:30.182]                     }
[16:09:30.182]                     invisible(muffled)
[16:09:30.182]                   }
[16:09:30.182]                   muffleCondition(cond)
[16:09:30.182]                 })
[16:09:30.182]             }))
[16:09:30.182]             future::FutureResult(value = ...future.value$value, 
[16:09:30.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.182]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.182]                     ...future.globalenv.names))
[16:09:30.182]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.182]         }, condition = base::local({
[16:09:30.182]             c <- base::c
[16:09:30.182]             inherits <- base::inherits
[16:09:30.182]             invokeRestart <- base::invokeRestart
[16:09:30.182]             length <- base::length
[16:09:30.182]             list <- base::list
[16:09:30.182]             seq.int <- base::seq.int
[16:09:30.182]             signalCondition <- base::signalCondition
[16:09:30.182]             sys.calls <- base::sys.calls
[16:09:30.182]             `[[` <- base::`[[`
[16:09:30.182]             `+` <- base::`+`
[16:09:30.182]             `<<-` <- base::`<<-`
[16:09:30.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.182]                   3L)]
[16:09:30.182]             }
[16:09:30.182]             function(cond) {
[16:09:30.182]                 is_error <- inherits(cond, "error")
[16:09:30.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.182]                   NULL)
[16:09:30.182]                 if (is_error) {
[16:09:30.182]                   sessionInformation <- function() {
[16:09:30.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.182]                       search = base::search(), system = base::Sys.info())
[16:09:30.182]                   }
[16:09:30.182]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.182]                     cond$call), session = sessionInformation(), 
[16:09:30.182]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.182]                   signalCondition(cond)
[16:09:30.182]                 }
[16:09:30.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.182]                 "immediateCondition"))) {
[16:09:30.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.182]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.182]                   if (TRUE && !signal) {
[16:09:30.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.182]                     {
[16:09:30.182]                       inherits <- base::inherits
[16:09:30.182]                       invokeRestart <- base::invokeRestart
[16:09:30.182]                       is.null <- base::is.null
[16:09:30.182]                       muffled <- FALSE
[16:09:30.182]                       if (inherits(cond, "message")) {
[16:09:30.182]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.182]                         if (muffled) 
[16:09:30.182]                           invokeRestart("muffleMessage")
[16:09:30.182]                       }
[16:09:30.182]                       else if (inherits(cond, "warning")) {
[16:09:30.182]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.182]                         if (muffled) 
[16:09:30.182]                           invokeRestart("muffleWarning")
[16:09:30.182]                       }
[16:09:30.182]                       else if (inherits(cond, "condition")) {
[16:09:30.182]                         if (!is.null(pattern)) {
[16:09:30.182]                           computeRestarts <- base::computeRestarts
[16:09:30.182]                           grepl <- base::grepl
[16:09:30.182]                           restarts <- computeRestarts(cond)
[16:09:30.182]                           for (restart in restarts) {
[16:09:30.182]                             name <- restart$name
[16:09:30.182]                             if (is.null(name)) 
[16:09:30.182]                               next
[16:09:30.182]                             if (!grepl(pattern, name)) 
[16:09:30.182]                               next
[16:09:30.182]                             invokeRestart(restart)
[16:09:30.182]                             muffled <- TRUE
[16:09:30.182]                             break
[16:09:30.182]                           }
[16:09:30.182]                         }
[16:09:30.182]                       }
[16:09:30.182]                       invisible(muffled)
[16:09:30.182]                     }
[16:09:30.182]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.182]                   }
[16:09:30.182]                 }
[16:09:30.182]                 else {
[16:09:30.182]                   if (TRUE) {
[16:09:30.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.182]                     {
[16:09:30.182]                       inherits <- base::inherits
[16:09:30.182]                       invokeRestart <- base::invokeRestart
[16:09:30.182]                       is.null <- base::is.null
[16:09:30.182]                       muffled <- FALSE
[16:09:30.182]                       if (inherits(cond, "message")) {
[16:09:30.182]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.182]                         if (muffled) 
[16:09:30.182]                           invokeRestart("muffleMessage")
[16:09:30.182]                       }
[16:09:30.182]                       else if (inherits(cond, "warning")) {
[16:09:30.182]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.182]                         if (muffled) 
[16:09:30.182]                           invokeRestart("muffleWarning")
[16:09:30.182]                       }
[16:09:30.182]                       else if (inherits(cond, "condition")) {
[16:09:30.182]                         if (!is.null(pattern)) {
[16:09:30.182]                           computeRestarts <- base::computeRestarts
[16:09:30.182]                           grepl <- base::grepl
[16:09:30.182]                           restarts <- computeRestarts(cond)
[16:09:30.182]                           for (restart in restarts) {
[16:09:30.182]                             name <- restart$name
[16:09:30.182]                             if (is.null(name)) 
[16:09:30.182]                               next
[16:09:30.182]                             if (!grepl(pattern, name)) 
[16:09:30.182]                               next
[16:09:30.182]                             invokeRestart(restart)
[16:09:30.182]                             muffled <- TRUE
[16:09:30.182]                             break
[16:09:30.182]                           }
[16:09:30.182]                         }
[16:09:30.182]                       }
[16:09:30.182]                       invisible(muffled)
[16:09:30.182]                     }
[16:09:30.182]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.182]                   }
[16:09:30.182]                 }
[16:09:30.182]             }
[16:09:30.182]         }))
[16:09:30.182]     }, error = function(ex) {
[16:09:30.182]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.182]                 ...future.rng), started = ...future.startTime, 
[16:09:30.182]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.182]             version = "1.8"), class = "FutureResult")
[16:09:30.182]     }, finally = {
[16:09:30.182]         if (!identical(...future.workdir, getwd())) 
[16:09:30.182]             setwd(...future.workdir)
[16:09:30.182]         {
[16:09:30.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.182]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.182]             }
[16:09:30.182]             base::options(...future.oldOptions)
[16:09:30.182]             if (.Platform$OS.type == "windows") {
[16:09:30.182]                 old_names <- names(...future.oldEnvVars)
[16:09:30.182]                 envs <- base::Sys.getenv()
[16:09:30.182]                 names <- names(envs)
[16:09:30.182]                 common <- intersect(names, old_names)
[16:09:30.182]                 added <- setdiff(names, old_names)
[16:09:30.182]                 removed <- setdiff(old_names, names)
[16:09:30.182]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.182]                   envs[common]]
[16:09:30.182]                 NAMES <- toupper(changed)
[16:09:30.182]                 args <- list()
[16:09:30.182]                 for (kk in seq_along(NAMES)) {
[16:09:30.182]                   name <- changed[[kk]]
[16:09:30.182]                   NAME <- NAMES[[kk]]
[16:09:30.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.182]                     next
[16:09:30.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.182]                 }
[16:09:30.182]                 NAMES <- toupper(added)
[16:09:30.182]                 for (kk in seq_along(NAMES)) {
[16:09:30.182]                   name <- added[[kk]]
[16:09:30.182]                   NAME <- NAMES[[kk]]
[16:09:30.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.182]                     next
[16:09:30.182]                   args[[name]] <- ""
[16:09:30.182]                 }
[16:09:30.182]                 NAMES <- toupper(removed)
[16:09:30.182]                 for (kk in seq_along(NAMES)) {
[16:09:30.182]                   name <- removed[[kk]]
[16:09:30.182]                   NAME <- NAMES[[kk]]
[16:09:30.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.182]                     next
[16:09:30.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.182]                 }
[16:09:30.182]                 if (length(args) > 0) 
[16:09:30.182]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.182]             }
[16:09:30.182]             else {
[16:09:30.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.182]             }
[16:09:30.182]             {
[16:09:30.182]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.182]                   0L) {
[16:09:30.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.182]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.182]                   base::options(opts)
[16:09:30.182]                 }
[16:09:30.182]                 {
[16:09:30.182]                   {
[16:09:30.182]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.182]                     NULL
[16:09:30.182]                   }
[16:09:30.182]                   options(future.plan = NULL)
[16:09:30.182]                   if (is.na(NA_character_)) 
[16:09:30.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.182]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.182]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.182]                     envir = parent.frame()) 
[16:09:30.182]                   {
[16:09:30.182]                     if (is.function(workers)) 
[16:09:30.182]                       workers <- workers()
[16:09:30.182]                     workers <- structure(as.integer(workers), 
[16:09:30.182]                       class = class(workers))
[16:09:30.182]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.182]                       workers >= 1)
[16:09:30.182]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.182]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.182]                     }
[16:09:30.182]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.182]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.182]                       envir = envir)
[16:09:30.182]                     if (!future$lazy) 
[16:09:30.182]                       future <- run(future)
[16:09:30.182]                     invisible(future)
[16:09:30.182]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.182]                 }
[16:09:30.182]             }
[16:09:30.182]         }
[16:09:30.182]     })
[16:09:30.182]     if (TRUE) {
[16:09:30.182]         base::sink(type = "output", split = FALSE)
[16:09:30.182]         if (TRUE) {
[16:09:30.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.182]         }
[16:09:30.182]         else {
[16:09:30.182]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.182]         }
[16:09:30.182]         base::close(...future.stdout)
[16:09:30.182]         ...future.stdout <- NULL
[16:09:30.182]     }
[16:09:30.182]     ...future.result$conditions <- ...future.conditions
[16:09:30.182]     ...future.result$finished <- base::Sys.time()
[16:09:30.182]     ...future.result
[16:09:30.182] }
[16:09:30.185] Exporting 5 global objects (346.00 KiB) to cluster node #2 ...
[16:09:30.185] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:30.186] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.186] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:09:30.228] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:09:30.228] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:09:30.229] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:09:30.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:30.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.229] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:30.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.230] Exporting 5 global objects (346.00 KiB) to cluster node #2 ... DONE
[16:09:30.231] MultisessionFuture started
[16:09:30.231] - Launch lazy future ... done
[16:09:30.231] run() for ‘MultisessionFuture’ ... done
[16:09:30.231] Created future:
[16:09:30.231] MultisessionFuture:
[16:09:30.231] Label: ‘future_apply-2’
[16:09:30.231] Expression:
[16:09:30.231] {
[16:09:30.231]     do.call(function(...) {
[16:09:30.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.231]             on.exit(options(oopts), add = TRUE)
[16:09:30.231]         }
[16:09:30.231]         {
[16:09:30.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.231]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.231]             })
[16:09:30.231]         }
[16:09:30.231]     }, args = future.call.arguments)
[16:09:30.231] }
[16:09:30.231] Lazy evaluation: FALSE
[16:09:30.231] Asynchronous evaluation: TRUE
[16:09:30.231] Local evaluation: TRUE
[16:09:30.231] Environment: R_GlobalEnv
[16:09:30.231] Capture standard output: TRUE
[16:09:30.231] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.231] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.231] Packages: <none>
[16:09:30.231] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.231] Resolved: FALSE
[16:09:30.231] Value: <not collected>
[16:09:30.231] Conditions captured: <none>
[16:09:30.231] Early signaling: FALSE
[16:09:30.231] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.231] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.243] Chunk #2 of 2 ... DONE
[16:09:30.243] Launching 2 futures (chunks) ... DONE
[16:09:30.243] Resolving 2 futures (chunks) ...
[16:09:30.243] resolve() on list ...
[16:09:30.243]  recursive: 0
[16:09:30.243]  length: 2
[16:09:30.243] 
[16:09:30.244] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.244] - Validating connection of MultisessionFuture
[16:09:30.244] - received message: FutureResult
[16:09:30.244] - Received FutureResult
[16:09:30.244] - Erased future from FutureRegistry
[16:09:30.244] result() for ClusterFuture ...
[16:09:30.245] - result already collected: FutureResult
[16:09:30.245] result() for ClusterFuture ... done
[16:09:30.245] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.245] Future #1
[16:09:30.245] result() for ClusterFuture ...
[16:09:30.245] - result already collected: FutureResult
[16:09:30.245] result() for ClusterFuture ... done
[16:09:30.245] result() for ClusterFuture ...
[16:09:30.245] - result already collected: FutureResult
[16:09:30.245] result() for ClusterFuture ... done
[16:09:30.245] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:30.246] - nx: 2
[16:09:30.246] - relay: TRUE
[16:09:30.246] - stdout: TRUE
[16:09:30.246] - signal: TRUE
[16:09:30.246] - resignal: FALSE
[16:09:30.246] - force: TRUE
[16:09:30.246] - relayed: [n=2] FALSE, FALSE
[16:09:30.246] - queued futures: [n=2] FALSE, FALSE
[16:09:30.246]  - until=1
[16:09:30.246]  - relaying element #1
[16:09:30.246] result() for ClusterFuture ...
[16:09:30.246] - result already collected: FutureResult
[16:09:30.247] result() for ClusterFuture ... done
[16:09:30.247] result() for ClusterFuture ...
[16:09:30.247] - result already collected: FutureResult
[16:09:30.247] result() for ClusterFuture ... done
[16:09:30.247] result() for ClusterFuture ...
[16:09:30.247] - result already collected: FutureResult
[16:09:30.247] result() for ClusterFuture ... done
[16:09:30.247] result() for ClusterFuture ...
[16:09:30.247] - result already collected: FutureResult
[16:09:30.247] result() for ClusterFuture ... done
[16:09:30.248] - relayed: [n=2] TRUE, FALSE
[16:09:30.249] - queued futures: [n=2] TRUE, FALSE
[16:09:30.250] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:30.250]  length: 1 (resolved future 1)
[16:09:30.277] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.277] - Validating connection of MultisessionFuture
[16:09:30.277] - received message: FutureResult
[16:09:30.277] - Received FutureResult
[16:09:30.277] - Erased future from FutureRegistry
[16:09:30.277] result() for ClusterFuture ...
[16:09:30.277] - result already collected: FutureResult
[16:09:30.277] result() for ClusterFuture ... done
[16:09:30.277] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.278] Future #2
[16:09:30.278] result() for ClusterFuture ...
[16:09:30.278] - result already collected: FutureResult
[16:09:30.278] result() for ClusterFuture ... done
[16:09:30.278] result() for ClusterFuture ...
[16:09:30.278] - result already collected: FutureResult
[16:09:30.278] result() for ClusterFuture ... done
[16:09:30.278] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:30.278] - nx: 2
[16:09:30.278] - relay: TRUE
[16:09:30.278] - stdout: TRUE
[16:09:30.279] - signal: TRUE
[16:09:30.279] - resignal: FALSE
[16:09:30.279] - force: TRUE
[16:09:30.279] - relayed: [n=2] TRUE, FALSE
[16:09:30.279] - queued futures: [n=2] TRUE, FALSE
[16:09:30.279]  - until=2
[16:09:30.279]  - relaying element #2
[16:09:30.279] result() for ClusterFuture ...
[16:09:30.279] - result already collected: FutureResult
[16:09:30.279] result() for ClusterFuture ... done
[16:09:30.279] result() for ClusterFuture ...
[16:09:30.279] - result already collected: FutureResult
[16:09:30.280] result() for ClusterFuture ... done
[16:09:30.280] result() for ClusterFuture ...
[16:09:30.280] - result already collected: FutureResult
[16:09:30.280] result() for ClusterFuture ... done
[16:09:30.280] result() for ClusterFuture ...
[16:09:30.280] - result already collected: FutureResult
[16:09:30.280] result() for ClusterFuture ... done
[16:09:30.280] - relayed: [n=2] TRUE, TRUE
[16:09:30.280] - queued futures: [n=2] TRUE, TRUE
[16:09:30.280] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:30.281]  length: 0 (resolved future 2)
[16:09:30.281] Relaying remaining futures
[16:09:30.281] signalConditionsASAP(NULL, pos=0) ...
[16:09:30.281] - nx: 2
[16:09:30.281] - relay: TRUE
[16:09:30.281] - stdout: TRUE
[16:09:30.281] - signal: TRUE
[16:09:30.281] - resignal: FALSE
[16:09:30.281] - force: TRUE
[16:09:30.281] - relayed: [n=2] TRUE, TRUE
[16:09:30.281] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:30.281] - relayed: [n=2] TRUE, TRUE
[16:09:30.282] - queued futures: [n=2] TRUE, TRUE
[16:09:30.282] signalConditionsASAP(NULL, pos=0) ... done
[16:09:30.282] resolve() on list ... DONE
[16:09:30.282] result() for ClusterFuture ...
[16:09:30.282] - result already collected: FutureResult
[16:09:30.282] result() for ClusterFuture ... done
[16:09:30.282] result() for ClusterFuture ...
[16:09:30.282] - result already collected: FutureResult
[16:09:30.282] result() for ClusterFuture ... done
[16:09:30.282] result() for ClusterFuture ...
[16:09:30.282] - result already collected: FutureResult
[16:09:30.282] result() for ClusterFuture ... done
[16:09:30.283] result() for ClusterFuture ...
[16:09:30.283] - result already collected: FutureResult
[16:09:30.283] result() for ClusterFuture ... done
[16:09:30.283]  - Number of value chunks collected: 2
[16:09:30.283] Resolving 2 futures (chunks) ... DONE
[16:09:30.283] Reducing values from 2 chunks ...
[16:09:30.283]  - Number of values collected after concatenation: 2
[16:09:30.283]  - Number of values expected: 2
[16:09:30.283] Reducing values from 2 chunks ... DONE
[16:09:30.283] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:09:30.284] getGlobalsAndPackagesXApply() ...
[16:09:30.284]  - future.globals: TRUE
[16:09:30.284] getGlobalsAndPackages() ...
[16:09:30.285] Searching for globals...
[16:09:30.286] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:09:30.286] Searching for globals ... DONE
[16:09:30.286] Resolving globals: FALSE
[16:09:30.286] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:09:30.286] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:09:30.287] - globals: [1] ‘FUN’
[16:09:30.287] - packages: [1] ‘stats’
[16:09:30.287] getGlobalsAndPackages() ... DONE
[16:09:30.287]  - globals found/used: [n=1] ‘FUN’
[16:09:30.287]  - needed namespaces: [n=1] ‘stats’
[16:09:30.287] Finding globals ... DONE
[16:09:30.287]  - use_args: TRUE
[16:09:30.287]  - Getting '...' globals ...
[16:09:30.288] resolve() on list ...
[16:09:30.288]  recursive: 0
[16:09:30.288]  length: 1
[16:09:30.288]  elements: ‘...’
[16:09:30.288]  length: 0 (resolved future 1)
[16:09:30.288] resolve() on list ... DONE
[16:09:30.288]    - '...' content: [n=0] 
[16:09:30.288] List of 1
[16:09:30.288]  $ ...: list()
[16:09:30.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.288]  - attr(*, "where")=List of 1
[16:09:30.288]   ..$ ...:<environment: 0x5633ac682848> 
[16:09:30.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.288]  - attr(*, "resolved")= logi TRUE
[16:09:30.288]  - attr(*, "total_size")= num NA
[16:09:30.291]  - Getting '...' globals ... DONE
[16:09:30.291] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:30.291] List of 2
[16:09:30.291]  $ ...future.FUN:function (x, ...)  
[16:09:30.291]  $ ...          : list()
[16:09:30.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.291]  - attr(*, "where")=List of 2
[16:09:30.291]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:30.291]   ..$ ...          :<environment: 0x5633ac682848> 
[16:09:30.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.291]  - attr(*, "resolved")= logi FALSE
[16:09:30.291]  - attr(*, "total_size")= num 1248
[16:09:30.294] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:30.294] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.297] future_lapply() ...
[16:09:30.301] Number of chunks: 2
[16:09:30.301] getGlobalsAndPackagesXApply() ...
[16:09:30.301]  - future.globals: <name-value list> with names ‘list()’
[16:09:30.301]  - use_args: TRUE
[16:09:30.301] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:30.301] List of 2
[16:09:30.301]  $ ...          : list()
[16:09:30.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.301]  $ ...future.FUN:function (x, ...)  
[16:09:30.301]  - attr(*, "where")=List of 2
[16:09:30.301]   ..$ ...          :<environment: 0x5633ac682848> 
[16:09:30.301]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:09:30.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.301]  - attr(*, "resolved")= logi FALSE
[16:09:30.301]  - attr(*, "total_size")= num NA
[16:09:30.304] Packages to be attached in all futures: [n=1] ‘stats’
[16:09:30.304] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.305] Number of futures (= number of chunks): 2
[16:09:30.305] Launching 2 futures (chunks) ...
[16:09:30.305] Chunk #1 of 2 ...
[16:09:30.305]  - seeds: <none>
[16:09:30.305] getGlobalsAndPackages() ...
[16:09:30.305] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.305] Resolving globals: FALSE
[16:09:30.305] Tweak future expression to call with '...' arguments ...
[16:09:30.305] {
[16:09:30.305]     do.call(function(...) {
[16:09:30.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.305]             on.exit(options(oopts), add = TRUE)
[16:09:30.305]         }
[16:09:30.305]         {
[16:09:30.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.305]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.305]             })
[16:09:30.305]         }
[16:09:30.305]     }, args = future.call.arguments)
[16:09:30.305] }
[16:09:30.306] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.306] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.306] - packages: [1] ‘stats’
[16:09:30.306] getGlobalsAndPackages() ... DONE
[16:09:30.307] run() for ‘Future’ ...
[16:09:30.307] - state: ‘created’
[16:09:30.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.321] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.321]   - Field: ‘node’
[16:09:30.321]   - Field: ‘label’
[16:09:30.322]   - Field: ‘local’
[16:09:30.322]   - Field: ‘owner’
[16:09:30.322]   - Field: ‘envir’
[16:09:30.322]   - Field: ‘workers’
[16:09:30.322]   - Field: ‘packages’
[16:09:30.322]   - Field: ‘gc’
[16:09:30.322]   - Field: ‘conditions’
[16:09:30.322]   - Field: ‘persistent’
[16:09:30.322]   - Field: ‘expr’
[16:09:30.322]   - Field: ‘uuid’
[16:09:30.322]   - Field: ‘seed’
[16:09:30.323]   - Field: ‘version’
[16:09:30.323]   - Field: ‘result’
[16:09:30.323]   - Field: ‘asynchronous’
[16:09:30.323]   - Field: ‘calls’
[16:09:30.323]   - Field: ‘globals’
[16:09:30.323]   - Field: ‘stdout’
[16:09:30.323]   - Field: ‘earlySignal’
[16:09:30.323]   - Field: ‘lazy’
[16:09:30.323]   - Field: ‘state’
[16:09:30.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.323] - Launch lazy future ...
[16:09:30.324] Packages needed by the future expression (n = 1): ‘stats’
[16:09:30.324] Packages needed by future strategies (n = 0): <none>
[16:09:30.324] {
[16:09:30.324]     {
[16:09:30.324]         {
[16:09:30.324]             ...future.startTime <- base::Sys.time()
[16:09:30.324]             {
[16:09:30.324]                 {
[16:09:30.324]                   {
[16:09:30.324]                     {
[16:09:30.324]                       {
[16:09:30.324]                         base::local({
[16:09:30.324]                           has_future <- base::requireNamespace("future", 
[16:09:30.324]                             quietly = TRUE)
[16:09:30.324]                           if (has_future) {
[16:09:30.324]                             ns <- base::getNamespace("future")
[16:09:30.324]                             version <- ns[[".package"]][["version"]]
[16:09:30.324]                             if (is.null(version)) 
[16:09:30.324]                               version <- utils::packageVersion("future")
[16:09:30.324]                           }
[16:09:30.324]                           else {
[16:09:30.324]                             version <- NULL
[16:09:30.324]                           }
[16:09:30.324]                           if (!has_future || version < "1.8.0") {
[16:09:30.324]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.324]                               "", base::R.version$version.string), 
[16:09:30.324]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:30.324]                                 base::R.version$platform, 8 * 
[16:09:30.324]                                   base::.Machine$sizeof.pointer), 
[16:09:30.324]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.324]                                 "release", "version")], collapse = " "), 
[16:09:30.324]                               hostname = base::Sys.info()[["nodename"]])
[16:09:30.324]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.324]                               info)
[16:09:30.324]                             info <- base::paste(info, collapse = "; ")
[16:09:30.324]                             if (!has_future) {
[16:09:30.324]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.324]                                 info)
[16:09:30.324]                             }
[16:09:30.324]                             else {
[16:09:30.324]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.324]                                 info, version)
[16:09:30.324]                             }
[16:09:30.324]                             base::stop(msg)
[16:09:30.324]                           }
[16:09:30.324]                         })
[16:09:30.324]                       }
[16:09:30.324]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.324]                       base::options(mc.cores = 1L)
[16:09:30.324]                     }
[16:09:30.324]                     base::local({
[16:09:30.324]                       for (pkg in "stats") {
[16:09:30.324]                         base::loadNamespace(pkg)
[16:09:30.324]                         base::library(pkg, character.only = TRUE)
[16:09:30.324]                       }
[16:09:30.324]                     })
[16:09:30.324]                   }
[16:09:30.324]                   options(future.plan = NULL)
[16:09:30.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.324]                 }
[16:09:30.324]                 ...future.workdir <- getwd()
[16:09:30.324]             }
[16:09:30.324]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.324]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.324]         }
[16:09:30.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.324]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.324]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.324]             base::names(...future.oldOptions))
[16:09:30.324]     }
[16:09:30.324]     if (FALSE) {
[16:09:30.324]     }
[16:09:30.324]     else {
[16:09:30.324]         if (TRUE) {
[16:09:30.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.324]                 open = "w")
[16:09:30.324]         }
[16:09:30.324]         else {
[16:09:30.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.324]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.324]         }
[16:09:30.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.324]             base::sink(type = "output", split = FALSE)
[16:09:30.324]             base::close(...future.stdout)
[16:09:30.324]         }, add = TRUE)
[16:09:30.324]     }
[16:09:30.324]     ...future.frame <- base::sys.nframe()
[16:09:30.324]     ...future.conditions <- base::list()
[16:09:30.324]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.324]     if (FALSE) {
[16:09:30.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.324]     }
[16:09:30.324]     ...future.result <- base::tryCatch({
[16:09:30.324]         base::withCallingHandlers({
[16:09:30.324]             ...future.value <- base::withVisible(base::local({
[16:09:30.324]                 ...future.makeSendCondition <- local({
[16:09:30.324]                   sendCondition <- NULL
[16:09:30.324]                   function(frame = 1L) {
[16:09:30.324]                     if (is.function(sendCondition)) 
[16:09:30.324]                       return(sendCondition)
[16:09:30.324]                     ns <- getNamespace("parallel")
[16:09:30.324]                     if (exists("sendData", mode = "function", 
[16:09:30.324]                       envir = ns)) {
[16:09:30.324]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.324]                         envir = ns)
[16:09:30.324]                       envir <- sys.frame(frame)
[16:09:30.324]                       master <- NULL
[16:09:30.324]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.324]                         !identical(envir, emptyenv())) {
[16:09:30.324]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.324]                           inherits = FALSE)) {
[16:09:30.324]                           master <- get("master", mode = "list", 
[16:09:30.324]                             envir = envir, inherits = FALSE)
[16:09:30.324]                           if (inherits(master, c("SOCKnode", 
[16:09:30.324]                             "SOCK0node"))) {
[16:09:30.324]                             sendCondition <<- function(cond) {
[16:09:30.324]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.324]                                 success = TRUE)
[16:09:30.324]                               parallel_sendData(master, data)
[16:09:30.324]                             }
[16:09:30.324]                             return(sendCondition)
[16:09:30.324]                           }
[16:09:30.324]                         }
[16:09:30.324]                         frame <- frame + 1L
[16:09:30.324]                         envir <- sys.frame(frame)
[16:09:30.324]                       }
[16:09:30.324]                     }
[16:09:30.324]                     sendCondition <<- function(cond) NULL
[16:09:30.324]                   }
[16:09:30.324]                 })
[16:09:30.324]                 withCallingHandlers({
[16:09:30.324]                   {
[16:09:30.324]                     do.call(function(...) {
[16:09:30.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.324]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.324]                         ...future.globals.maxSize)) {
[16:09:30.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.324]                         on.exit(options(oopts), add = TRUE)
[16:09:30.324]                       }
[16:09:30.324]                       {
[16:09:30.324]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.324]                           FUN = function(jj) {
[16:09:30.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.324]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.324]                           })
[16:09:30.324]                       }
[16:09:30.324]                     }, args = future.call.arguments)
[16:09:30.324]                   }
[16:09:30.324]                 }, immediateCondition = function(cond) {
[16:09:30.324]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.324]                   sendCondition(cond)
[16:09:30.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.324]                   {
[16:09:30.324]                     inherits <- base::inherits
[16:09:30.324]                     invokeRestart <- base::invokeRestart
[16:09:30.324]                     is.null <- base::is.null
[16:09:30.324]                     muffled <- FALSE
[16:09:30.324]                     if (inherits(cond, "message")) {
[16:09:30.324]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.324]                       if (muffled) 
[16:09:30.324]                         invokeRestart("muffleMessage")
[16:09:30.324]                     }
[16:09:30.324]                     else if (inherits(cond, "warning")) {
[16:09:30.324]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.324]                       if (muffled) 
[16:09:30.324]                         invokeRestart("muffleWarning")
[16:09:30.324]                     }
[16:09:30.324]                     else if (inherits(cond, "condition")) {
[16:09:30.324]                       if (!is.null(pattern)) {
[16:09:30.324]                         computeRestarts <- base::computeRestarts
[16:09:30.324]                         grepl <- base::grepl
[16:09:30.324]                         restarts <- computeRestarts(cond)
[16:09:30.324]                         for (restart in restarts) {
[16:09:30.324]                           name <- restart$name
[16:09:30.324]                           if (is.null(name)) 
[16:09:30.324]                             next
[16:09:30.324]                           if (!grepl(pattern, name)) 
[16:09:30.324]                             next
[16:09:30.324]                           invokeRestart(restart)
[16:09:30.324]                           muffled <- TRUE
[16:09:30.324]                           break
[16:09:30.324]                         }
[16:09:30.324]                       }
[16:09:30.324]                     }
[16:09:30.324]                     invisible(muffled)
[16:09:30.324]                   }
[16:09:30.324]                   muffleCondition(cond)
[16:09:30.324]                 })
[16:09:30.324]             }))
[16:09:30.324]             future::FutureResult(value = ...future.value$value, 
[16:09:30.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.324]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.324]                     ...future.globalenv.names))
[16:09:30.324]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.324]         }, condition = base::local({
[16:09:30.324]             c <- base::c
[16:09:30.324]             inherits <- base::inherits
[16:09:30.324]             invokeRestart <- base::invokeRestart
[16:09:30.324]             length <- base::length
[16:09:30.324]             list <- base::list
[16:09:30.324]             seq.int <- base::seq.int
[16:09:30.324]             signalCondition <- base::signalCondition
[16:09:30.324]             sys.calls <- base::sys.calls
[16:09:30.324]             `[[` <- base::`[[`
[16:09:30.324]             `+` <- base::`+`
[16:09:30.324]             `<<-` <- base::`<<-`
[16:09:30.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.324]                   3L)]
[16:09:30.324]             }
[16:09:30.324]             function(cond) {
[16:09:30.324]                 is_error <- inherits(cond, "error")
[16:09:30.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.324]                   NULL)
[16:09:30.324]                 if (is_error) {
[16:09:30.324]                   sessionInformation <- function() {
[16:09:30.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.324]                       search = base::search(), system = base::Sys.info())
[16:09:30.324]                   }
[16:09:30.324]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.324]                     cond$call), session = sessionInformation(), 
[16:09:30.324]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.324]                   signalCondition(cond)
[16:09:30.324]                 }
[16:09:30.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.324]                 "immediateCondition"))) {
[16:09:30.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.324]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.324]                   if (TRUE && !signal) {
[16:09:30.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.324]                     {
[16:09:30.324]                       inherits <- base::inherits
[16:09:30.324]                       invokeRestart <- base::invokeRestart
[16:09:30.324]                       is.null <- base::is.null
[16:09:30.324]                       muffled <- FALSE
[16:09:30.324]                       if (inherits(cond, "message")) {
[16:09:30.324]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.324]                         if (muffled) 
[16:09:30.324]                           invokeRestart("muffleMessage")
[16:09:30.324]                       }
[16:09:30.324]                       else if (inherits(cond, "warning")) {
[16:09:30.324]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.324]                         if (muffled) 
[16:09:30.324]                           invokeRestart("muffleWarning")
[16:09:30.324]                       }
[16:09:30.324]                       else if (inherits(cond, "condition")) {
[16:09:30.324]                         if (!is.null(pattern)) {
[16:09:30.324]                           computeRestarts <- base::computeRestarts
[16:09:30.324]                           grepl <- base::grepl
[16:09:30.324]                           restarts <- computeRestarts(cond)
[16:09:30.324]                           for (restart in restarts) {
[16:09:30.324]                             name <- restart$name
[16:09:30.324]                             if (is.null(name)) 
[16:09:30.324]                               next
[16:09:30.324]                             if (!grepl(pattern, name)) 
[16:09:30.324]                               next
[16:09:30.324]                             invokeRestart(restart)
[16:09:30.324]                             muffled <- TRUE
[16:09:30.324]                             break
[16:09:30.324]                           }
[16:09:30.324]                         }
[16:09:30.324]                       }
[16:09:30.324]                       invisible(muffled)
[16:09:30.324]                     }
[16:09:30.324]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.324]                   }
[16:09:30.324]                 }
[16:09:30.324]                 else {
[16:09:30.324]                   if (TRUE) {
[16:09:30.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.324]                     {
[16:09:30.324]                       inherits <- base::inherits
[16:09:30.324]                       invokeRestart <- base::invokeRestart
[16:09:30.324]                       is.null <- base::is.null
[16:09:30.324]                       muffled <- FALSE
[16:09:30.324]                       if (inherits(cond, "message")) {
[16:09:30.324]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.324]                         if (muffled) 
[16:09:30.324]                           invokeRestart("muffleMessage")
[16:09:30.324]                       }
[16:09:30.324]                       else if (inherits(cond, "warning")) {
[16:09:30.324]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.324]                         if (muffled) 
[16:09:30.324]                           invokeRestart("muffleWarning")
[16:09:30.324]                       }
[16:09:30.324]                       else if (inherits(cond, "condition")) {
[16:09:30.324]                         if (!is.null(pattern)) {
[16:09:30.324]                           computeRestarts <- base::computeRestarts
[16:09:30.324]                           grepl <- base::grepl
[16:09:30.324]                           restarts <- computeRestarts(cond)
[16:09:30.324]                           for (restart in restarts) {
[16:09:30.324]                             name <- restart$name
[16:09:30.324]                             if (is.null(name)) 
[16:09:30.324]                               next
[16:09:30.324]                             if (!grepl(pattern, name)) 
[16:09:30.324]                               next
[16:09:30.324]                             invokeRestart(restart)
[16:09:30.324]                             muffled <- TRUE
[16:09:30.324]                             break
[16:09:30.324]                           }
[16:09:30.324]                         }
[16:09:30.324]                       }
[16:09:30.324]                       invisible(muffled)
[16:09:30.324]                     }
[16:09:30.324]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.324]                   }
[16:09:30.324]                 }
[16:09:30.324]             }
[16:09:30.324]         }))
[16:09:30.324]     }, error = function(ex) {
[16:09:30.324]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.324]                 ...future.rng), started = ...future.startTime, 
[16:09:30.324]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.324]             version = "1.8"), class = "FutureResult")
[16:09:30.324]     }, finally = {
[16:09:30.324]         if (!identical(...future.workdir, getwd())) 
[16:09:30.324]             setwd(...future.workdir)
[16:09:30.324]         {
[16:09:30.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.324]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.324]             }
[16:09:30.324]             base::options(...future.oldOptions)
[16:09:30.324]             if (.Platform$OS.type == "windows") {
[16:09:30.324]                 old_names <- names(...future.oldEnvVars)
[16:09:30.324]                 envs <- base::Sys.getenv()
[16:09:30.324]                 names <- names(envs)
[16:09:30.324]                 common <- intersect(names, old_names)
[16:09:30.324]                 added <- setdiff(names, old_names)
[16:09:30.324]                 removed <- setdiff(old_names, names)
[16:09:30.324]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.324]                   envs[common]]
[16:09:30.324]                 NAMES <- toupper(changed)
[16:09:30.324]                 args <- list()
[16:09:30.324]                 for (kk in seq_along(NAMES)) {
[16:09:30.324]                   name <- changed[[kk]]
[16:09:30.324]                   NAME <- NAMES[[kk]]
[16:09:30.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.324]                     next
[16:09:30.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.324]                 }
[16:09:30.324]                 NAMES <- toupper(added)
[16:09:30.324]                 for (kk in seq_along(NAMES)) {
[16:09:30.324]                   name <- added[[kk]]
[16:09:30.324]                   NAME <- NAMES[[kk]]
[16:09:30.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.324]                     next
[16:09:30.324]                   args[[name]] <- ""
[16:09:30.324]                 }
[16:09:30.324]                 NAMES <- toupper(removed)
[16:09:30.324]                 for (kk in seq_along(NAMES)) {
[16:09:30.324]                   name <- removed[[kk]]
[16:09:30.324]                   NAME <- NAMES[[kk]]
[16:09:30.324]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.324]                     next
[16:09:30.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.324]                 }
[16:09:30.324]                 if (length(args) > 0) 
[16:09:30.324]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.324]             }
[16:09:30.324]             else {
[16:09:30.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.324]             }
[16:09:30.324]             {
[16:09:30.324]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.324]                   0L) {
[16:09:30.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.324]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.324]                   base::options(opts)
[16:09:30.324]                 }
[16:09:30.324]                 {
[16:09:30.324]                   {
[16:09:30.324]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.324]                     NULL
[16:09:30.324]                   }
[16:09:30.324]                   options(future.plan = NULL)
[16:09:30.324]                   if (is.na(NA_character_)) 
[16:09:30.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.324]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.324]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.324]                     envir = parent.frame()) 
[16:09:30.324]                   {
[16:09:30.324]                     if (is.function(workers)) 
[16:09:30.324]                       workers <- workers()
[16:09:30.324]                     workers <- structure(as.integer(workers), 
[16:09:30.324]                       class = class(workers))
[16:09:30.324]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.324]                       workers >= 1)
[16:09:30.324]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.324]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.324]                     }
[16:09:30.324]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.324]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.324]                       envir = envir)
[16:09:30.324]                     if (!future$lazy) 
[16:09:30.324]                       future <- run(future)
[16:09:30.324]                     invisible(future)
[16:09:30.324]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.324]                 }
[16:09:30.324]             }
[16:09:30.324]         }
[16:09:30.324]     })
[16:09:30.324]     if (TRUE) {
[16:09:30.324]         base::sink(type = "output", split = FALSE)
[16:09:30.324]         if (TRUE) {
[16:09:30.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.324]         }
[16:09:30.324]         else {
[16:09:30.324]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.324]         }
[16:09:30.324]         base::close(...future.stdout)
[16:09:30.324]         ...future.stdout <- NULL
[16:09:30.324]     }
[16:09:30.324]     ...future.result$conditions <- ...future.conditions
[16:09:30.324]     ...future.result$finished <- base::Sys.time()
[16:09:30.324]     ...future.result
[16:09:30.324] }
[16:09:30.327] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[16:09:30.328] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:30.328] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.328] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:09:30.328] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:09:30.329] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:09:30.329] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:09:30.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:30.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:30.330] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.330] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[16:09:30.330] MultisessionFuture started
[16:09:30.330] - Launch lazy future ... done
[16:09:30.330] run() for ‘MultisessionFuture’ ... done
[16:09:30.331] Created future:
[16:09:30.331] MultisessionFuture:
[16:09:30.331] Label: ‘future_apply-1’
[16:09:30.331] Expression:
[16:09:30.331] {
[16:09:30.331]     do.call(function(...) {
[16:09:30.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.331]             on.exit(options(oopts), add = TRUE)
[16:09:30.331]         }
[16:09:30.331]         {
[16:09:30.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.331]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.331]             })
[16:09:30.331]         }
[16:09:30.331]     }, args = future.call.arguments)
[16:09:30.331] }
[16:09:30.331] Lazy evaluation: FALSE
[16:09:30.331] Asynchronous evaluation: TRUE
[16:09:30.331] Local evaluation: TRUE
[16:09:30.331] Environment: R_GlobalEnv
[16:09:30.331] Capture standard output: TRUE
[16:09:30.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.331] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.331] Packages: 1 packages (‘stats’)
[16:09:30.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.331] Resolved: FALSE
[16:09:30.331] Value: <not collected>
[16:09:30.331] Conditions captured: <none>
[16:09:30.331] Early signaling: FALSE
[16:09:30.331] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.331] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.342] Chunk #1 of 2 ... DONE
[16:09:30.342] Chunk #2 of 2 ...
[16:09:30.342]  - seeds: <none>
[16:09:30.343] getGlobalsAndPackages() ...
[16:09:30.343] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.343] Resolving globals: FALSE
[16:09:30.343] Tweak future expression to call with '...' arguments ...
[16:09:30.343] {
[16:09:30.343]     do.call(function(...) {
[16:09:30.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.343]             on.exit(options(oopts), add = TRUE)
[16:09:30.343]         }
[16:09:30.343]         {
[16:09:30.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.343]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.343]             })
[16:09:30.343]         }
[16:09:30.343]     }, args = future.call.arguments)
[16:09:30.343] }
[16:09:30.343] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.344] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.344] - packages: [1] ‘stats’
[16:09:30.344] getGlobalsAndPackages() ... DONE
[16:09:30.344] run() for ‘Future’ ...
[16:09:30.344] - state: ‘created’
[16:09:30.344] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.358] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.359]   - Field: ‘node’
[16:09:30.359]   - Field: ‘label’
[16:09:30.359]   - Field: ‘local’
[16:09:30.359]   - Field: ‘owner’
[16:09:30.359]   - Field: ‘envir’
[16:09:30.359]   - Field: ‘workers’
[16:09:30.359]   - Field: ‘packages’
[16:09:30.359]   - Field: ‘gc’
[16:09:30.359]   - Field: ‘conditions’
[16:09:30.359]   - Field: ‘persistent’
[16:09:30.360]   - Field: ‘expr’
[16:09:30.360]   - Field: ‘uuid’
[16:09:30.360]   - Field: ‘seed’
[16:09:30.360]   - Field: ‘version’
[16:09:30.360]   - Field: ‘result’
[16:09:30.360]   - Field: ‘asynchronous’
[16:09:30.360]   - Field: ‘calls’
[16:09:30.360]   - Field: ‘globals’
[16:09:30.360]   - Field: ‘stdout’
[16:09:30.360]   - Field: ‘earlySignal’
[16:09:30.361]   - Field: ‘lazy’
[16:09:30.361]   - Field: ‘state’
[16:09:30.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.361] - Launch lazy future ...
[16:09:30.361] Packages needed by the future expression (n = 1): ‘stats’
[16:09:30.361] Packages needed by future strategies (n = 0): <none>
[16:09:30.362] {
[16:09:30.362]     {
[16:09:30.362]         {
[16:09:30.362]             ...future.startTime <- base::Sys.time()
[16:09:30.362]             {
[16:09:30.362]                 {
[16:09:30.362]                   {
[16:09:30.362]                     {
[16:09:30.362]                       {
[16:09:30.362]                         base::local({
[16:09:30.362]                           has_future <- base::requireNamespace("future", 
[16:09:30.362]                             quietly = TRUE)
[16:09:30.362]                           if (has_future) {
[16:09:30.362]                             ns <- base::getNamespace("future")
[16:09:30.362]                             version <- ns[[".package"]][["version"]]
[16:09:30.362]                             if (is.null(version)) 
[16:09:30.362]                               version <- utils::packageVersion("future")
[16:09:30.362]                           }
[16:09:30.362]                           else {
[16:09:30.362]                             version <- NULL
[16:09:30.362]                           }
[16:09:30.362]                           if (!has_future || version < "1.8.0") {
[16:09:30.362]                             info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.362]                               "", base::R.version$version.string), 
[16:09:30.362]                               platform = base::sprintf("%s (%s-bit)", 
[16:09:30.362]                                 base::R.version$platform, 8 * 
[16:09:30.362]                                   base::.Machine$sizeof.pointer), 
[16:09:30.362]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.362]                                 "release", "version")], collapse = " "), 
[16:09:30.362]                               hostname = base::Sys.info()[["nodename"]])
[16:09:30.362]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.362]                               info)
[16:09:30.362]                             info <- base::paste(info, collapse = "; ")
[16:09:30.362]                             if (!has_future) {
[16:09:30.362]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.362]                                 info)
[16:09:30.362]                             }
[16:09:30.362]                             else {
[16:09:30.362]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.362]                                 info, version)
[16:09:30.362]                             }
[16:09:30.362]                             base::stop(msg)
[16:09:30.362]                           }
[16:09:30.362]                         })
[16:09:30.362]                       }
[16:09:30.362]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.362]                       base::options(mc.cores = 1L)
[16:09:30.362]                     }
[16:09:30.362]                     base::local({
[16:09:30.362]                       for (pkg in "stats") {
[16:09:30.362]                         base::loadNamespace(pkg)
[16:09:30.362]                         base::library(pkg, character.only = TRUE)
[16:09:30.362]                       }
[16:09:30.362]                     })
[16:09:30.362]                   }
[16:09:30.362]                   options(future.plan = NULL)
[16:09:30.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.362]                 }
[16:09:30.362]                 ...future.workdir <- getwd()
[16:09:30.362]             }
[16:09:30.362]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.362]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.362]         }
[16:09:30.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.362]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.362]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.362]             base::names(...future.oldOptions))
[16:09:30.362]     }
[16:09:30.362]     if (FALSE) {
[16:09:30.362]     }
[16:09:30.362]     else {
[16:09:30.362]         if (TRUE) {
[16:09:30.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.362]                 open = "w")
[16:09:30.362]         }
[16:09:30.362]         else {
[16:09:30.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.362]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.362]         }
[16:09:30.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.362]             base::sink(type = "output", split = FALSE)
[16:09:30.362]             base::close(...future.stdout)
[16:09:30.362]         }, add = TRUE)
[16:09:30.362]     }
[16:09:30.362]     ...future.frame <- base::sys.nframe()
[16:09:30.362]     ...future.conditions <- base::list()
[16:09:30.362]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.362]     if (FALSE) {
[16:09:30.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.362]     }
[16:09:30.362]     ...future.result <- base::tryCatch({
[16:09:30.362]         base::withCallingHandlers({
[16:09:30.362]             ...future.value <- base::withVisible(base::local({
[16:09:30.362]                 ...future.makeSendCondition <- local({
[16:09:30.362]                   sendCondition <- NULL
[16:09:30.362]                   function(frame = 1L) {
[16:09:30.362]                     if (is.function(sendCondition)) 
[16:09:30.362]                       return(sendCondition)
[16:09:30.362]                     ns <- getNamespace("parallel")
[16:09:30.362]                     if (exists("sendData", mode = "function", 
[16:09:30.362]                       envir = ns)) {
[16:09:30.362]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.362]                         envir = ns)
[16:09:30.362]                       envir <- sys.frame(frame)
[16:09:30.362]                       master <- NULL
[16:09:30.362]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.362]                         !identical(envir, emptyenv())) {
[16:09:30.362]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.362]                           inherits = FALSE)) {
[16:09:30.362]                           master <- get("master", mode = "list", 
[16:09:30.362]                             envir = envir, inherits = FALSE)
[16:09:30.362]                           if (inherits(master, c("SOCKnode", 
[16:09:30.362]                             "SOCK0node"))) {
[16:09:30.362]                             sendCondition <<- function(cond) {
[16:09:30.362]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.362]                                 success = TRUE)
[16:09:30.362]                               parallel_sendData(master, data)
[16:09:30.362]                             }
[16:09:30.362]                             return(sendCondition)
[16:09:30.362]                           }
[16:09:30.362]                         }
[16:09:30.362]                         frame <- frame + 1L
[16:09:30.362]                         envir <- sys.frame(frame)
[16:09:30.362]                       }
[16:09:30.362]                     }
[16:09:30.362]                     sendCondition <<- function(cond) NULL
[16:09:30.362]                   }
[16:09:30.362]                 })
[16:09:30.362]                 withCallingHandlers({
[16:09:30.362]                   {
[16:09:30.362]                     do.call(function(...) {
[16:09:30.362]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.362]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.362]                         ...future.globals.maxSize)) {
[16:09:30.362]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.362]                         on.exit(options(oopts), add = TRUE)
[16:09:30.362]                       }
[16:09:30.362]                       {
[16:09:30.362]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.362]                           FUN = function(jj) {
[16:09:30.362]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.362]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.362]                           })
[16:09:30.362]                       }
[16:09:30.362]                     }, args = future.call.arguments)
[16:09:30.362]                   }
[16:09:30.362]                 }, immediateCondition = function(cond) {
[16:09:30.362]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.362]                   sendCondition(cond)
[16:09:30.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.362]                   {
[16:09:30.362]                     inherits <- base::inherits
[16:09:30.362]                     invokeRestart <- base::invokeRestart
[16:09:30.362]                     is.null <- base::is.null
[16:09:30.362]                     muffled <- FALSE
[16:09:30.362]                     if (inherits(cond, "message")) {
[16:09:30.362]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.362]                       if (muffled) 
[16:09:30.362]                         invokeRestart("muffleMessage")
[16:09:30.362]                     }
[16:09:30.362]                     else if (inherits(cond, "warning")) {
[16:09:30.362]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.362]                       if (muffled) 
[16:09:30.362]                         invokeRestart("muffleWarning")
[16:09:30.362]                     }
[16:09:30.362]                     else if (inherits(cond, "condition")) {
[16:09:30.362]                       if (!is.null(pattern)) {
[16:09:30.362]                         computeRestarts <- base::computeRestarts
[16:09:30.362]                         grepl <- base::grepl
[16:09:30.362]                         restarts <- computeRestarts(cond)
[16:09:30.362]                         for (restart in restarts) {
[16:09:30.362]                           name <- restart$name
[16:09:30.362]                           if (is.null(name)) 
[16:09:30.362]                             next
[16:09:30.362]                           if (!grepl(pattern, name)) 
[16:09:30.362]                             next
[16:09:30.362]                           invokeRestart(restart)
[16:09:30.362]                           muffled <- TRUE
[16:09:30.362]                           break
[16:09:30.362]                         }
[16:09:30.362]                       }
[16:09:30.362]                     }
[16:09:30.362]                     invisible(muffled)
[16:09:30.362]                   }
[16:09:30.362]                   muffleCondition(cond)
[16:09:30.362]                 })
[16:09:30.362]             }))
[16:09:30.362]             future::FutureResult(value = ...future.value$value, 
[16:09:30.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.362]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.362]                     ...future.globalenv.names))
[16:09:30.362]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.362]         }, condition = base::local({
[16:09:30.362]             c <- base::c
[16:09:30.362]             inherits <- base::inherits
[16:09:30.362]             invokeRestart <- base::invokeRestart
[16:09:30.362]             length <- base::length
[16:09:30.362]             list <- base::list
[16:09:30.362]             seq.int <- base::seq.int
[16:09:30.362]             signalCondition <- base::signalCondition
[16:09:30.362]             sys.calls <- base::sys.calls
[16:09:30.362]             `[[` <- base::`[[`
[16:09:30.362]             `+` <- base::`+`
[16:09:30.362]             `<<-` <- base::`<<-`
[16:09:30.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.362]                   3L)]
[16:09:30.362]             }
[16:09:30.362]             function(cond) {
[16:09:30.362]                 is_error <- inherits(cond, "error")
[16:09:30.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.362]                   NULL)
[16:09:30.362]                 if (is_error) {
[16:09:30.362]                   sessionInformation <- function() {
[16:09:30.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.362]                       search = base::search(), system = base::Sys.info())
[16:09:30.362]                   }
[16:09:30.362]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.362]                     cond$call), session = sessionInformation(), 
[16:09:30.362]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.362]                   signalCondition(cond)
[16:09:30.362]                 }
[16:09:30.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.362]                 "immediateCondition"))) {
[16:09:30.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.362]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.362]                   if (TRUE && !signal) {
[16:09:30.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.362]                     {
[16:09:30.362]                       inherits <- base::inherits
[16:09:30.362]                       invokeRestart <- base::invokeRestart
[16:09:30.362]                       is.null <- base::is.null
[16:09:30.362]                       muffled <- FALSE
[16:09:30.362]                       if (inherits(cond, "message")) {
[16:09:30.362]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.362]                         if (muffled) 
[16:09:30.362]                           invokeRestart("muffleMessage")
[16:09:30.362]                       }
[16:09:30.362]                       else if (inherits(cond, "warning")) {
[16:09:30.362]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.362]                         if (muffled) 
[16:09:30.362]                           invokeRestart("muffleWarning")
[16:09:30.362]                       }
[16:09:30.362]                       else if (inherits(cond, "condition")) {
[16:09:30.362]                         if (!is.null(pattern)) {
[16:09:30.362]                           computeRestarts <- base::computeRestarts
[16:09:30.362]                           grepl <- base::grepl
[16:09:30.362]                           restarts <- computeRestarts(cond)
[16:09:30.362]                           for (restart in restarts) {
[16:09:30.362]                             name <- restart$name
[16:09:30.362]                             if (is.null(name)) 
[16:09:30.362]                               next
[16:09:30.362]                             if (!grepl(pattern, name)) 
[16:09:30.362]                               next
[16:09:30.362]                             invokeRestart(restart)
[16:09:30.362]                             muffled <- TRUE
[16:09:30.362]                             break
[16:09:30.362]                           }
[16:09:30.362]                         }
[16:09:30.362]                       }
[16:09:30.362]                       invisible(muffled)
[16:09:30.362]                     }
[16:09:30.362]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.362]                   }
[16:09:30.362]                 }
[16:09:30.362]                 else {
[16:09:30.362]                   if (TRUE) {
[16:09:30.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.362]                     {
[16:09:30.362]                       inherits <- base::inherits
[16:09:30.362]                       invokeRestart <- base::invokeRestart
[16:09:30.362]                       is.null <- base::is.null
[16:09:30.362]                       muffled <- FALSE
[16:09:30.362]                       if (inherits(cond, "message")) {
[16:09:30.362]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.362]                         if (muffled) 
[16:09:30.362]                           invokeRestart("muffleMessage")
[16:09:30.362]                       }
[16:09:30.362]                       else if (inherits(cond, "warning")) {
[16:09:30.362]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.362]                         if (muffled) 
[16:09:30.362]                           invokeRestart("muffleWarning")
[16:09:30.362]                       }
[16:09:30.362]                       else if (inherits(cond, "condition")) {
[16:09:30.362]                         if (!is.null(pattern)) {
[16:09:30.362]                           computeRestarts <- base::computeRestarts
[16:09:30.362]                           grepl <- base::grepl
[16:09:30.362]                           restarts <- computeRestarts(cond)
[16:09:30.362]                           for (restart in restarts) {
[16:09:30.362]                             name <- restart$name
[16:09:30.362]                             if (is.null(name)) 
[16:09:30.362]                               next
[16:09:30.362]                             if (!grepl(pattern, name)) 
[16:09:30.362]                               next
[16:09:30.362]                             invokeRestart(restart)
[16:09:30.362]                             muffled <- TRUE
[16:09:30.362]                             break
[16:09:30.362]                           }
[16:09:30.362]                         }
[16:09:30.362]                       }
[16:09:30.362]                       invisible(muffled)
[16:09:30.362]                     }
[16:09:30.362]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.362]                   }
[16:09:30.362]                 }
[16:09:30.362]             }
[16:09:30.362]         }))
[16:09:30.362]     }, error = function(ex) {
[16:09:30.362]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.362]                 ...future.rng), started = ...future.startTime, 
[16:09:30.362]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.362]             version = "1.8"), class = "FutureResult")
[16:09:30.362]     }, finally = {
[16:09:30.362]         if (!identical(...future.workdir, getwd())) 
[16:09:30.362]             setwd(...future.workdir)
[16:09:30.362]         {
[16:09:30.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.362]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.362]             }
[16:09:30.362]             base::options(...future.oldOptions)
[16:09:30.362]             if (.Platform$OS.type == "windows") {
[16:09:30.362]                 old_names <- names(...future.oldEnvVars)
[16:09:30.362]                 envs <- base::Sys.getenv()
[16:09:30.362]                 names <- names(envs)
[16:09:30.362]                 common <- intersect(names, old_names)
[16:09:30.362]                 added <- setdiff(names, old_names)
[16:09:30.362]                 removed <- setdiff(old_names, names)
[16:09:30.362]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.362]                   envs[common]]
[16:09:30.362]                 NAMES <- toupper(changed)
[16:09:30.362]                 args <- list()
[16:09:30.362]                 for (kk in seq_along(NAMES)) {
[16:09:30.362]                   name <- changed[[kk]]
[16:09:30.362]                   NAME <- NAMES[[kk]]
[16:09:30.362]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.362]                     next
[16:09:30.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.362]                 }
[16:09:30.362]                 NAMES <- toupper(added)
[16:09:30.362]                 for (kk in seq_along(NAMES)) {
[16:09:30.362]                   name <- added[[kk]]
[16:09:30.362]                   NAME <- NAMES[[kk]]
[16:09:30.362]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.362]                     next
[16:09:30.362]                   args[[name]] <- ""
[16:09:30.362]                 }
[16:09:30.362]                 NAMES <- toupper(removed)
[16:09:30.362]                 for (kk in seq_along(NAMES)) {
[16:09:30.362]                   name <- removed[[kk]]
[16:09:30.362]                   NAME <- NAMES[[kk]]
[16:09:30.362]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.362]                     next
[16:09:30.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.362]                 }
[16:09:30.362]                 if (length(args) > 0) 
[16:09:30.362]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.362]             }
[16:09:30.362]             else {
[16:09:30.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.362]             }
[16:09:30.362]             {
[16:09:30.362]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.362]                   0L) {
[16:09:30.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.362]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.362]                   base::options(opts)
[16:09:30.362]                 }
[16:09:30.362]                 {
[16:09:30.362]                   {
[16:09:30.362]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.362]                     NULL
[16:09:30.362]                   }
[16:09:30.362]                   options(future.plan = NULL)
[16:09:30.362]                   if (is.na(NA_character_)) 
[16:09:30.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.362]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.362]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.362]                     envir = parent.frame()) 
[16:09:30.362]                   {
[16:09:30.362]                     if (is.function(workers)) 
[16:09:30.362]                       workers <- workers()
[16:09:30.362]                     workers <- structure(as.integer(workers), 
[16:09:30.362]                       class = class(workers))
[16:09:30.362]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.362]                       workers >= 1)
[16:09:30.362]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.362]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.362]                     }
[16:09:30.362]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.362]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.362]                       envir = envir)
[16:09:30.362]                     if (!future$lazy) 
[16:09:30.362]                       future <- run(future)
[16:09:30.362]                     invisible(future)
[16:09:30.362]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.362]                 }
[16:09:30.362]             }
[16:09:30.362]         }
[16:09:30.362]     })
[16:09:30.362]     if (TRUE) {
[16:09:30.362]         base::sink(type = "output", split = FALSE)
[16:09:30.362]         if (TRUE) {
[16:09:30.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.362]         }
[16:09:30.362]         else {
[16:09:30.362]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.362]         }
[16:09:30.362]         base::close(...future.stdout)
[16:09:30.362]         ...future.stdout <- NULL
[16:09:30.362]     }
[16:09:30.362]     ...future.result$conditions <- ...future.conditions
[16:09:30.362]     ...future.result$finished <- base::Sys.time()
[16:09:30.362]     ...future.result
[16:09:30.362] }
[16:09:30.365] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[16:09:30.365] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:30.365] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.365] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:09:30.366] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:09:30.366] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:09:30.366] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:09:30.366] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:30.367] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.367] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:30.367] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.367] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[16:09:30.368] MultisessionFuture started
[16:09:30.368] - Launch lazy future ... done
[16:09:30.368] run() for ‘MultisessionFuture’ ... done
[16:09:30.368] Created future:
[16:09:30.368] MultisessionFuture:
[16:09:30.368] Label: ‘future_apply-2’
[16:09:30.368] Expression:
[16:09:30.368] {
[16:09:30.368]     do.call(function(...) {
[16:09:30.368]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.368]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.368]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.368]             on.exit(options(oopts), add = TRUE)
[16:09:30.368]         }
[16:09:30.368]         {
[16:09:30.368]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.368]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.368]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.368]             })
[16:09:30.368]         }
[16:09:30.368]     }, args = future.call.arguments)
[16:09:30.368] }
[16:09:30.368] Lazy evaluation: FALSE
[16:09:30.368] Asynchronous evaluation: TRUE
[16:09:30.368] Local evaluation: TRUE
[16:09:30.368] Environment: R_GlobalEnv
[16:09:30.368] Capture standard output: TRUE
[16:09:30.368] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.368] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.368] Packages: 1 packages (‘stats’)
[16:09:30.368] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.368] Resolved: FALSE
[16:09:30.368] Value: <not collected>
[16:09:30.368] Conditions captured: <none>
[16:09:30.368] Early signaling: FALSE
[16:09:30.368] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.368] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.380] Chunk #2 of 2 ... DONE
[16:09:30.380] Launching 2 futures (chunks) ... DONE
[16:09:30.380] Resolving 2 futures (chunks) ...
[16:09:30.380] resolve() on list ...
[16:09:30.380]  recursive: 0
[16:09:30.380]  length: 2
[16:09:30.380] 
[16:09:30.381] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.381] - Validating connection of MultisessionFuture
[16:09:30.381] - received message: FutureResult
[16:09:30.381] - Received FutureResult
[16:09:30.381] - Erased future from FutureRegistry
[16:09:30.382] result() for ClusterFuture ...
[16:09:30.382] - result already collected: FutureResult
[16:09:30.382] result() for ClusterFuture ... done
[16:09:30.382] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.382] Future #1
[16:09:30.382] result() for ClusterFuture ...
[16:09:30.382] - result already collected: FutureResult
[16:09:30.382] result() for ClusterFuture ... done
[16:09:30.382] result() for ClusterFuture ...
[16:09:30.382] - result already collected: FutureResult
[16:09:30.382] result() for ClusterFuture ... done
[16:09:30.383] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:30.383] - nx: 2
[16:09:30.383] - relay: TRUE
[16:09:30.383] - stdout: TRUE
[16:09:30.383] - signal: TRUE
[16:09:30.383] - resignal: FALSE
[16:09:30.383] - force: TRUE
[16:09:30.383] - relayed: [n=2] FALSE, FALSE
[16:09:30.383] - queued futures: [n=2] FALSE, FALSE
[16:09:30.383]  - until=1
[16:09:30.383]  - relaying element #1
[16:09:30.383] result() for ClusterFuture ...
[16:09:30.384] - result already collected: FutureResult
[16:09:30.384] result() for ClusterFuture ... done
[16:09:30.384] result() for ClusterFuture ...
[16:09:30.384] - result already collected: FutureResult
[16:09:30.384] result() for ClusterFuture ... done
[16:09:30.384] result() for ClusterFuture ...
[16:09:30.384] - result already collected: FutureResult
[16:09:30.384] result() for ClusterFuture ... done
[16:09:30.384] result() for ClusterFuture ...
[16:09:30.384] - result already collected: FutureResult
[16:09:30.385] result() for ClusterFuture ... done
[16:09:30.385] - relayed: [n=2] TRUE, FALSE
[16:09:30.385] - queued futures: [n=2] TRUE, FALSE
[16:09:30.385] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:30.385]  length: 1 (resolved future 1)
[16:09:30.426] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.427] - Validating connection of MultisessionFuture
[16:09:30.427] - received message: FutureResult
[16:09:30.427] - Received FutureResult
[16:09:30.427] - Erased future from FutureRegistry
[16:09:30.427] result() for ClusterFuture ...
[16:09:30.427] - result already collected: FutureResult
[16:09:30.427] result() for ClusterFuture ... done
[16:09:30.428] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.428] Future #2
[16:09:30.428] result() for ClusterFuture ...
[16:09:30.428] - result already collected: FutureResult
[16:09:30.428] result() for ClusterFuture ... done
[16:09:30.428] result() for ClusterFuture ...
[16:09:30.428] - result already collected: FutureResult
[16:09:30.428] result() for ClusterFuture ... done
[16:09:30.428] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:30.428] - nx: 2
[16:09:30.428] - relay: TRUE
[16:09:30.429] - stdout: TRUE
[16:09:30.429] - signal: TRUE
[16:09:30.429] - resignal: FALSE
[16:09:30.429] - force: TRUE
[16:09:30.429] - relayed: [n=2] TRUE, FALSE
[16:09:30.429] - queued futures: [n=2] TRUE, FALSE
[16:09:30.429]  - until=2
[16:09:30.429]  - relaying element #2
[16:09:30.429] result() for ClusterFuture ...
[16:09:30.429] - result already collected: FutureResult
[16:09:30.429] result() for ClusterFuture ... done
[16:09:30.429] result() for ClusterFuture ...
[16:09:30.430] - result already collected: FutureResult
[16:09:30.430] result() for ClusterFuture ... done
[16:09:30.430] result() for ClusterFuture ...
[16:09:30.430] - result already collected: FutureResult
[16:09:30.430] result() for ClusterFuture ... done
[16:09:30.430] result() for ClusterFuture ...
[16:09:30.430] - result already collected: FutureResult
[16:09:30.430] result() for ClusterFuture ... done
[16:09:30.430] - relayed: [n=2] TRUE, TRUE
[16:09:30.430] - queued futures: [n=2] TRUE, TRUE
[16:09:30.430] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:30.431]  length: 0 (resolved future 2)
[16:09:30.431] Relaying remaining futures
[16:09:30.431] signalConditionsASAP(NULL, pos=0) ...
[16:09:30.431] - nx: 2
[16:09:30.431] - relay: TRUE
[16:09:30.431] - stdout: TRUE
[16:09:30.431] - signal: TRUE
[16:09:30.431] - resignal: FALSE
[16:09:30.431] - force: TRUE
[16:09:30.431] - relayed: [n=2] TRUE, TRUE
[16:09:30.431] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:30.431] - relayed: [n=2] TRUE, TRUE
[16:09:30.432] - queued futures: [n=2] TRUE, TRUE
[16:09:30.432] signalConditionsASAP(NULL, pos=0) ... done
[16:09:30.432] resolve() on list ... DONE
[16:09:30.432] result() for ClusterFuture ...
[16:09:30.432] - result already collected: FutureResult
[16:09:30.432] result() for ClusterFuture ... done
[16:09:30.432] result() for ClusterFuture ...
[16:09:30.432] - result already collected: FutureResult
[16:09:30.432] result() for ClusterFuture ... done
[16:09:30.432] result() for ClusterFuture ...
[16:09:30.433] - result already collected: FutureResult
[16:09:30.433] result() for ClusterFuture ... done
[16:09:30.433] result() for ClusterFuture ...
[16:09:30.433] - result already collected: FutureResult
[16:09:30.433] result() for ClusterFuture ... done
[16:09:30.433]  - Number of value chunks collected: 2
[16:09:30.433] Resolving 2 futures (chunks) ... DONE
[16:09:30.433] Reducing values from 2 chunks ...
[16:09:30.433]  - Number of values collected after concatenation: 2
[16:09:30.433]  - Number of values expected: 2
[16:09:30.433] Reducing values from 2 chunks ... DONE
[16:09:30.434] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:09:30.434] getGlobalsAndPackagesXApply() ...
[16:09:30.434]  - future.globals: TRUE
[16:09:30.434] getGlobalsAndPackages() ...
[16:09:30.434] Searching for globals...
[16:09:30.435] - globals found: [1] ‘FUN’
[16:09:30.435] Searching for globals ... DONE
[16:09:30.436] Resolving globals: FALSE
[16:09:30.436] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:30.436] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:30.436] - globals: [1] ‘FUN’
[16:09:30.436] 
[16:09:30.436] getGlobalsAndPackages() ... DONE
[16:09:30.437]  - globals found/used: [n=1] ‘FUN’
[16:09:30.437]  - needed namespaces: [n=0] 
[16:09:30.437] Finding globals ... DONE
[16:09:30.437]  - use_args: TRUE
[16:09:30.437]  - Getting '...' globals ...
[16:09:30.437] resolve() on list ...
[16:09:30.437]  recursive: 0
[16:09:30.437]  length: 1
[16:09:30.437]  elements: ‘...’
[16:09:30.438]  length: 0 (resolved future 1)
[16:09:30.438] resolve() on list ... DONE
[16:09:30.438]    - '...' content: [n=0] 
[16:09:30.438] List of 1
[16:09:30.438]  $ ...: list()
[16:09:30.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.438]  - attr(*, "where")=List of 1
[16:09:30.438]   ..$ ...:<environment: 0x5633ae37e3a0> 
[16:09:30.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.438]  - attr(*, "resolved")= logi TRUE
[16:09:30.438]  - attr(*, "total_size")= num NA
[16:09:30.440]  - Getting '...' globals ... DONE
[16:09:30.441] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:30.441] List of 2
[16:09:30.441]  $ ...future.FUN:function (x)  
[16:09:30.441]  $ ...          : list()
[16:09:30.441]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.441]  - attr(*, "where")=List of 2
[16:09:30.441]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:30.441]   ..$ ...          :<environment: 0x5633ae37e3a0> 
[16:09:30.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.441]  - attr(*, "resolved")= logi FALSE
[16:09:30.441]  - attr(*, "total_size")= num 848
[16:09:30.443] Packages to be attached in all futures: [n=0] 
[16:09:30.443] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.449] future_lapply() ...
[16:09:30.452] Number of chunks: 2
[16:09:30.452] getGlobalsAndPackagesXApply() ...
[16:09:30.452]  - future.globals: <name-value list> with names ‘list()’
[16:09:30.453]  - use_args: TRUE
[16:09:30.453] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:30.453] List of 2
[16:09:30.453]  $ ...          : list()
[16:09:30.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.453]  $ ...future.FUN:function (x)  
[16:09:30.453]  - attr(*, "where")=List of 2
[16:09:30.453]   ..$ ...          :<environment: 0x5633ae37e3a0> 
[16:09:30.453]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:30.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.453]  - attr(*, "resolved")= logi FALSE
[16:09:30.453]  - attr(*, "total_size")= num NA
[16:09:30.456] Packages to be attached in all futures: [n=0] 
[16:09:30.456] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.456] Number of futures (= number of chunks): 2
[16:09:30.456] Launching 2 futures (chunks) ...
[16:09:30.456] Chunk #1 of 2 ...
[16:09:30.456]  - seeds: <none>
[16:09:30.457] getGlobalsAndPackages() ...
[16:09:30.457] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.457] Resolving globals: FALSE
[16:09:30.457] Tweak future expression to call with '...' arguments ...
[16:09:30.457] {
[16:09:30.457]     do.call(function(...) {
[16:09:30.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.457]             on.exit(options(oopts), add = TRUE)
[16:09:30.457]         }
[16:09:30.457]         {
[16:09:30.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.457]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.457]             })
[16:09:30.457]         }
[16:09:30.457]     }, args = future.call.arguments)
[16:09:30.457] }
[16:09:30.457] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.458] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.458] 
[16:09:30.458] getGlobalsAndPackages() ... DONE
[16:09:30.458] run() for ‘Future’ ...
[16:09:30.458] - state: ‘created’
[16:09:30.458] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.473] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.473]   - Field: ‘node’
[16:09:30.473]   - Field: ‘label’
[16:09:30.473]   - Field: ‘local’
[16:09:30.473]   - Field: ‘owner’
[16:09:30.474]   - Field: ‘envir’
[16:09:30.474]   - Field: ‘workers’
[16:09:30.474]   - Field: ‘packages’
[16:09:30.474]   - Field: ‘gc’
[16:09:30.474]   - Field: ‘conditions’
[16:09:30.474]   - Field: ‘persistent’
[16:09:30.474]   - Field: ‘expr’
[16:09:30.474]   - Field: ‘uuid’
[16:09:30.474]   - Field: ‘seed’
[16:09:30.474]   - Field: ‘version’
[16:09:30.474]   - Field: ‘result’
[16:09:30.475]   - Field: ‘asynchronous’
[16:09:30.475]   - Field: ‘calls’
[16:09:30.475]   - Field: ‘globals’
[16:09:30.475]   - Field: ‘stdout’
[16:09:30.475]   - Field: ‘earlySignal’
[16:09:30.475]   - Field: ‘lazy’
[16:09:30.475]   - Field: ‘state’
[16:09:30.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.475] - Launch lazy future ...
[16:09:30.476] Packages needed by the future expression (n = 0): <none>
[16:09:30.476] Packages needed by future strategies (n = 0): <none>
[16:09:30.476] {
[16:09:30.476]     {
[16:09:30.476]         {
[16:09:30.476]             ...future.startTime <- base::Sys.time()
[16:09:30.476]             {
[16:09:30.476]                 {
[16:09:30.476]                   {
[16:09:30.476]                     {
[16:09:30.476]                       base::local({
[16:09:30.476]                         has_future <- base::requireNamespace("future", 
[16:09:30.476]                           quietly = TRUE)
[16:09:30.476]                         if (has_future) {
[16:09:30.476]                           ns <- base::getNamespace("future")
[16:09:30.476]                           version <- ns[[".package"]][["version"]]
[16:09:30.476]                           if (is.null(version)) 
[16:09:30.476]                             version <- utils::packageVersion("future")
[16:09:30.476]                         }
[16:09:30.476]                         else {
[16:09:30.476]                           version <- NULL
[16:09:30.476]                         }
[16:09:30.476]                         if (!has_future || version < "1.8.0") {
[16:09:30.476]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.476]                             "", base::R.version$version.string), 
[16:09:30.476]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.476]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.476]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.476]                               "release", "version")], collapse = " "), 
[16:09:30.476]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.476]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.476]                             info)
[16:09:30.476]                           info <- base::paste(info, collapse = "; ")
[16:09:30.476]                           if (!has_future) {
[16:09:30.476]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.476]                               info)
[16:09:30.476]                           }
[16:09:30.476]                           else {
[16:09:30.476]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.476]                               info, version)
[16:09:30.476]                           }
[16:09:30.476]                           base::stop(msg)
[16:09:30.476]                         }
[16:09:30.476]                       })
[16:09:30.476]                     }
[16:09:30.476]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.476]                     base::options(mc.cores = 1L)
[16:09:30.476]                   }
[16:09:30.476]                   options(future.plan = NULL)
[16:09:30.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.476]                 }
[16:09:30.476]                 ...future.workdir <- getwd()
[16:09:30.476]             }
[16:09:30.476]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.476]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.476]         }
[16:09:30.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.476]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.476]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.476]             base::names(...future.oldOptions))
[16:09:30.476]     }
[16:09:30.476]     if (FALSE) {
[16:09:30.476]     }
[16:09:30.476]     else {
[16:09:30.476]         if (TRUE) {
[16:09:30.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.476]                 open = "w")
[16:09:30.476]         }
[16:09:30.476]         else {
[16:09:30.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.476]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.476]         }
[16:09:30.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.476]             base::sink(type = "output", split = FALSE)
[16:09:30.476]             base::close(...future.stdout)
[16:09:30.476]         }, add = TRUE)
[16:09:30.476]     }
[16:09:30.476]     ...future.frame <- base::sys.nframe()
[16:09:30.476]     ...future.conditions <- base::list()
[16:09:30.476]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.476]     if (FALSE) {
[16:09:30.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.476]     }
[16:09:30.476]     ...future.result <- base::tryCatch({
[16:09:30.476]         base::withCallingHandlers({
[16:09:30.476]             ...future.value <- base::withVisible(base::local({
[16:09:30.476]                 ...future.makeSendCondition <- local({
[16:09:30.476]                   sendCondition <- NULL
[16:09:30.476]                   function(frame = 1L) {
[16:09:30.476]                     if (is.function(sendCondition)) 
[16:09:30.476]                       return(sendCondition)
[16:09:30.476]                     ns <- getNamespace("parallel")
[16:09:30.476]                     if (exists("sendData", mode = "function", 
[16:09:30.476]                       envir = ns)) {
[16:09:30.476]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.476]                         envir = ns)
[16:09:30.476]                       envir <- sys.frame(frame)
[16:09:30.476]                       master <- NULL
[16:09:30.476]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.476]                         !identical(envir, emptyenv())) {
[16:09:30.476]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.476]                           inherits = FALSE)) {
[16:09:30.476]                           master <- get("master", mode = "list", 
[16:09:30.476]                             envir = envir, inherits = FALSE)
[16:09:30.476]                           if (inherits(master, c("SOCKnode", 
[16:09:30.476]                             "SOCK0node"))) {
[16:09:30.476]                             sendCondition <<- function(cond) {
[16:09:30.476]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.476]                                 success = TRUE)
[16:09:30.476]                               parallel_sendData(master, data)
[16:09:30.476]                             }
[16:09:30.476]                             return(sendCondition)
[16:09:30.476]                           }
[16:09:30.476]                         }
[16:09:30.476]                         frame <- frame + 1L
[16:09:30.476]                         envir <- sys.frame(frame)
[16:09:30.476]                       }
[16:09:30.476]                     }
[16:09:30.476]                     sendCondition <<- function(cond) NULL
[16:09:30.476]                   }
[16:09:30.476]                 })
[16:09:30.476]                 withCallingHandlers({
[16:09:30.476]                   {
[16:09:30.476]                     do.call(function(...) {
[16:09:30.476]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.476]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.476]                         ...future.globals.maxSize)) {
[16:09:30.476]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.476]                         on.exit(options(oopts), add = TRUE)
[16:09:30.476]                       }
[16:09:30.476]                       {
[16:09:30.476]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.476]                           FUN = function(jj) {
[16:09:30.476]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.476]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.476]                           })
[16:09:30.476]                       }
[16:09:30.476]                     }, args = future.call.arguments)
[16:09:30.476]                   }
[16:09:30.476]                 }, immediateCondition = function(cond) {
[16:09:30.476]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.476]                   sendCondition(cond)
[16:09:30.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.476]                   {
[16:09:30.476]                     inherits <- base::inherits
[16:09:30.476]                     invokeRestart <- base::invokeRestart
[16:09:30.476]                     is.null <- base::is.null
[16:09:30.476]                     muffled <- FALSE
[16:09:30.476]                     if (inherits(cond, "message")) {
[16:09:30.476]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.476]                       if (muffled) 
[16:09:30.476]                         invokeRestart("muffleMessage")
[16:09:30.476]                     }
[16:09:30.476]                     else if (inherits(cond, "warning")) {
[16:09:30.476]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.476]                       if (muffled) 
[16:09:30.476]                         invokeRestart("muffleWarning")
[16:09:30.476]                     }
[16:09:30.476]                     else if (inherits(cond, "condition")) {
[16:09:30.476]                       if (!is.null(pattern)) {
[16:09:30.476]                         computeRestarts <- base::computeRestarts
[16:09:30.476]                         grepl <- base::grepl
[16:09:30.476]                         restarts <- computeRestarts(cond)
[16:09:30.476]                         for (restart in restarts) {
[16:09:30.476]                           name <- restart$name
[16:09:30.476]                           if (is.null(name)) 
[16:09:30.476]                             next
[16:09:30.476]                           if (!grepl(pattern, name)) 
[16:09:30.476]                             next
[16:09:30.476]                           invokeRestart(restart)
[16:09:30.476]                           muffled <- TRUE
[16:09:30.476]                           break
[16:09:30.476]                         }
[16:09:30.476]                       }
[16:09:30.476]                     }
[16:09:30.476]                     invisible(muffled)
[16:09:30.476]                   }
[16:09:30.476]                   muffleCondition(cond)
[16:09:30.476]                 })
[16:09:30.476]             }))
[16:09:30.476]             future::FutureResult(value = ...future.value$value, 
[16:09:30.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.476]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.476]                     ...future.globalenv.names))
[16:09:30.476]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.476]         }, condition = base::local({
[16:09:30.476]             c <- base::c
[16:09:30.476]             inherits <- base::inherits
[16:09:30.476]             invokeRestart <- base::invokeRestart
[16:09:30.476]             length <- base::length
[16:09:30.476]             list <- base::list
[16:09:30.476]             seq.int <- base::seq.int
[16:09:30.476]             signalCondition <- base::signalCondition
[16:09:30.476]             sys.calls <- base::sys.calls
[16:09:30.476]             `[[` <- base::`[[`
[16:09:30.476]             `+` <- base::`+`
[16:09:30.476]             `<<-` <- base::`<<-`
[16:09:30.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.476]                   3L)]
[16:09:30.476]             }
[16:09:30.476]             function(cond) {
[16:09:30.476]                 is_error <- inherits(cond, "error")
[16:09:30.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.476]                   NULL)
[16:09:30.476]                 if (is_error) {
[16:09:30.476]                   sessionInformation <- function() {
[16:09:30.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.476]                       search = base::search(), system = base::Sys.info())
[16:09:30.476]                   }
[16:09:30.476]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.476]                     cond$call), session = sessionInformation(), 
[16:09:30.476]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.476]                   signalCondition(cond)
[16:09:30.476]                 }
[16:09:30.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.476]                 "immediateCondition"))) {
[16:09:30.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.476]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.476]                   if (TRUE && !signal) {
[16:09:30.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.476]                     {
[16:09:30.476]                       inherits <- base::inherits
[16:09:30.476]                       invokeRestart <- base::invokeRestart
[16:09:30.476]                       is.null <- base::is.null
[16:09:30.476]                       muffled <- FALSE
[16:09:30.476]                       if (inherits(cond, "message")) {
[16:09:30.476]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.476]                         if (muffled) 
[16:09:30.476]                           invokeRestart("muffleMessage")
[16:09:30.476]                       }
[16:09:30.476]                       else if (inherits(cond, "warning")) {
[16:09:30.476]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.476]                         if (muffled) 
[16:09:30.476]                           invokeRestart("muffleWarning")
[16:09:30.476]                       }
[16:09:30.476]                       else if (inherits(cond, "condition")) {
[16:09:30.476]                         if (!is.null(pattern)) {
[16:09:30.476]                           computeRestarts <- base::computeRestarts
[16:09:30.476]                           grepl <- base::grepl
[16:09:30.476]                           restarts <- computeRestarts(cond)
[16:09:30.476]                           for (restart in restarts) {
[16:09:30.476]                             name <- restart$name
[16:09:30.476]                             if (is.null(name)) 
[16:09:30.476]                               next
[16:09:30.476]                             if (!grepl(pattern, name)) 
[16:09:30.476]                               next
[16:09:30.476]                             invokeRestart(restart)
[16:09:30.476]                             muffled <- TRUE
[16:09:30.476]                             break
[16:09:30.476]                           }
[16:09:30.476]                         }
[16:09:30.476]                       }
[16:09:30.476]                       invisible(muffled)
[16:09:30.476]                     }
[16:09:30.476]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.476]                   }
[16:09:30.476]                 }
[16:09:30.476]                 else {
[16:09:30.476]                   if (TRUE) {
[16:09:30.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.476]                     {
[16:09:30.476]                       inherits <- base::inherits
[16:09:30.476]                       invokeRestart <- base::invokeRestart
[16:09:30.476]                       is.null <- base::is.null
[16:09:30.476]                       muffled <- FALSE
[16:09:30.476]                       if (inherits(cond, "message")) {
[16:09:30.476]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.476]                         if (muffled) 
[16:09:30.476]                           invokeRestart("muffleMessage")
[16:09:30.476]                       }
[16:09:30.476]                       else if (inherits(cond, "warning")) {
[16:09:30.476]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.476]                         if (muffled) 
[16:09:30.476]                           invokeRestart("muffleWarning")
[16:09:30.476]                       }
[16:09:30.476]                       else if (inherits(cond, "condition")) {
[16:09:30.476]                         if (!is.null(pattern)) {
[16:09:30.476]                           computeRestarts <- base::computeRestarts
[16:09:30.476]                           grepl <- base::grepl
[16:09:30.476]                           restarts <- computeRestarts(cond)
[16:09:30.476]                           for (restart in restarts) {
[16:09:30.476]                             name <- restart$name
[16:09:30.476]                             if (is.null(name)) 
[16:09:30.476]                               next
[16:09:30.476]                             if (!grepl(pattern, name)) 
[16:09:30.476]                               next
[16:09:30.476]                             invokeRestart(restart)
[16:09:30.476]                             muffled <- TRUE
[16:09:30.476]                             break
[16:09:30.476]                           }
[16:09:30.476]                         }
[16:09:30.476]                       }
[16:09:30.476]                       invisible(muffled)
[16:09:30.476]                     }
[16:09:30.476]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.476]                   }
[16:09:30.476]                 }
[16:09:30.476]             }
[16:09:30.476]         }))
[16:09:30.476]     }, error = function(ex) {
[16:09:30.476]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.476]                 ...future.rng), started = ...future.startTime, 
[16:09:30.476]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.476]             version = "1.8"), class = "FutureResult")
[16:09:30.476]     }, finally = {
[16:09:30.476]         if (!identical(...future.workdir, getwd())) 
[16:09:30.476]             setwd(...future.workdir)
[16:09:30.476]         {
[16:09:30.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.476]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.476]             }
[16:09:30.476]             base::options(...future.oldOptions)
[16:09:30.476]             if (.Platform$OS.type == "windows") {
[16:09:30.476]                 old_names <- names(...future.oldEnvVars)
[16:09:30.476]                 envs <- base::Sys.getenv()
[16:09:30.476]                 names <- names(envs)
[16:09:30.476]                 common <- intersect(names, old_names)
[16:09:30.476]                 added <- setdiff(names, old_names)
[16:09:30.476]                 removed <- setdiff(old_names, names)
[16:09:30.476]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.476]                   envs[common]]
[16:09:30.476]                 NAMES <- toupper(changed)
[16:09:30.476]                 args <- list()
[16:09:30.476]                 for (kk in seq_along(NAMES)) {
[16:09:30.476]                   name <- changed[[kk]]
[16:09:30.476]                   NAME <- NAMES[[kk]]
[16:09:30.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.476]                     next
[16:09:30.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.476]                 }
[16:09:30.476]                 NAMES <- toupper(added)
[16:09:30.476]                 for (kk in seq_along(NAMES)) {
[16:09:30.476]                   name <- added[[kk]]
[16:09:30.476]                   NAME <- NAMES[[kk]]
[16:09:30.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.476]                     next
[16:09:30.476]                   args[[name]] <- ""
[16:09:30.476]                 }
[16:09:30.476]                 NAMES <- toupper(removed)
[16:09:30.476]                 for (kk in seq_along(NAMES)) {
[16:09:30.476]                   name <- removed[[kk]]
[16:09:30.476]                   NAME <- NAMES[[kk]]
[16:09:30.476]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.476]                     next
[16:09:30.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.476]                 }
[16:09:30.476]                 if (length(args) > 0) 
[16:09:30.476]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.476]             }
[16:09:30.476]             else {
[16:09:30.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.476]             }
[16:09:30.476]             {
[16:09:30.476]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.476]                   0L) {
[16:09:30.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.476]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.476]                   base::options(opts)
[16:09:30.476]                 }
[16:09:30.476]                 {
[16:09:30.476]                   {
[16:09:30.476]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.476]                     NULL
[16:09:30.476]                   }
[16:09:30.476]                   options(future.plan = NULL)
[16:09:30.476]                   if (is.na(NA_character_)) 
[16:09:30.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.476]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.476]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.476]                     envir = parent.frame()) 
[16:09:30.476]                   {
[16:09:30.476]                     if (is.function(workers)) 
[16:09:30.476]                       workers <- workers()
[16:09:30.476]                     workers <- structure(as.integer(workers), 
[16:09:30.476]                       class = class(workers))
[16:09:30.476]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.476]                       workers >= 1)
[16:09:30.476]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.476]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.476]                     }
[16:09:30.476]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.476]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.476]                       envir = envir)
[16:09:30.476]                     if (!future$lazy) 
[16:09:30.476]                       future <- run(future)
[16:09:30.476]                     invisible(future)
[16:09:30.476]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.476]                 }
[16:09:30.476]             }
[16:09:30.476]         }
[16:09:30.476]     })
[16:09:30.476]     if (TRUE) {
[16:09:30.476]         base::sink(type = "output", split = FALSE)
[16:09:30.476]         if (TRUE) {
[16:09:30.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.476]         }
[16:09:30.476]         else {
[16:09:30.476]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.476]         }
[16:09:30.476]         base::close(...future.stdout)
[16:09:30.476]         ...future.stdout <- NULL
[16:09:30.476]     }
[16:09:30.476]     ...future.result$conditions <- ...future.conditions
[16:09:30.476]     ...future.result$finished <- base::Sys.time()
[16:09:30.476]     ...future.result
[16:09:30.476] }
[16:09:30.479] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[16:09:30.479] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:30.479] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.480] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:09:30.480] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:09:30.480] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:09:30.480] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:09:30.481] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:30.481] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.481] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:30.481] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.481] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[16:09:30.482] MultisessionFuture started
[16:09:30.482] - Launch lazy future ... done
[16:09:30.482] run() for ‘MultisessionFuture’ ... done
[16:09:30.482] Created future:
[16:09:30.482] MultisessionFuture:
[16:09:30.482] Label: ‘future_apply-1’
[16:09:30.482] Expression:
[16:09:30.482] {
[16:09:30.482]     do.call(function(...) {
[16:09:30.482]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.482]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.482]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.482]             on.exit(options(oopts), add = TRUE)
[16:09:30.482]         }
[16:09:30.482]         {
[16:09:30.482]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.482]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.482]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.482]             })
[16:09:30.482]         }
[16:09:30.482]     }, args = future.call.arguments)
[16:09:30.482] }
[16:09:30.482] Lazy evaluation: FALSE
[16:09:30.482] Asynchronous evaluation: TRUE
[16:09:30.482] Local evaluation: TRUE
[16:09:30.482] Environment: R_GlobalEnv
[16:09:30.482] Capture standard output: TRUE
[16:09:30.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.482] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.482] Packages: <none>
[16:09:30.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.482] Resolved: FALSE
[16:09:30.482] Value: <not collected>
[16:09:30.482] Conditions captured: <none>
[16:09:30.482] Early signaling: FALSE
[16:09:30.482] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.482] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.494] Chunk #1 of 2 ... DONE
[16:09:30.494] Chunk #2 of 2 ...
[16:09:30.494]  - seeds: <none>
[16:09:30.494] getGlobalsAndPackages() ...
[16:09:30.494] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.494] Resolving globals: FALSE
[16:09:30.494] Tweak future expression to call with '...' arguments ...
[16:09:30.494] {
[16:09:30.494]     do.call(function(...) {
[16:09:30.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.494]             on.exit(options(oopts), add = TRUE)
[16:09:30.494]         }
[16:09:30.494]         {
[16:09:30.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.494]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.494]             })
[16:09:30.494]         }
[16:09:30.494]     }, args = future.call.arguments)
[16:09:30.494] }
[16:09:30.495] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.495] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.495] 
[16:09:30.495] getGlobalsAndPackages() ... DONE
[16:09:30.496] run() for ‘Future’ ...
[16:09:30.496] - state: ‘created’
[16:09:30.496] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.511]   - Field: ‘node’
[16:09:30.511]   - Field: ‘label’
[16:09:30.511]   - Field: ‘local’
[16:09:30.511]   - Field: ‘owner’
[16:09:30.511]   - Field: ‘envir’
[16:09:30.511]   - Field: ‘workers’
[16:09:30.511]   - Field: ‘packages’
[16:09:30.511]   - Field: ‘gc’
[16:09:30.512]   - Field: ‘conditions’
[16:09:30.512]   - Field: ‘persistent’
[16:09:30.512]   - Field: ‘expr’
[16:09:30.512]   - Field: ‘uuid’
[16:09:30.512]   - Field: ‘seed’
[16:09:30.512]   - Field: ‘version’
[16:09:30.512]   - Field: ‘result’
[16:09:30.512]   - Field: ‘asynchronous’
[16:09:30.512]   - Field: ‘calls’
[16:09:30.512]   - Field: ‘globals’
[16:09:30.513]   - Field: ‘stdout’
[16:09:30.513]   - Field: ‘earlySignal’
[16:09:30.513]   - Field: ‘lazy’
[16:09:30.513]   - Field: ‘state’
[16:09:30.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.513] - Launch lazy future ...
[16:09:30.513] Packages needed by the future expression (n = 0): <none>
[16:09:30.513] Packages needed by future strategies (n = 0): <none>
[16:09:30.514] {
[16:09:30.514]     {
[16:09:30.514]         {
[16:09:30.514]             ...future.startTime <- base::Sys.time()
[16:09:30.514]             {
[16:09:30.514]                 {
[16:09:30.514]                   {
[16:09:30.514]                     {
[16:09:30.514]                       base::local({
[16:09:30.514]                         has_future <- base::requireNamespace("future", 
[16:09:30.514]                           quietly = TRUE)
[16:09:30.514]                         if (has_future) {
[16:09:30.514]                           ns <- base::getNamespace("future")
[16:09:30.514]                           version <- ns[[".package"]][["version"]]
[16:09:30.514]                           if (is.null(version)) 
[16:09:30.514]                             version <- utils::packageVersion("future")
[16:09:30.514]                         }
[16:09:30.514]                         else {
[16:09:30.514]                           version <- NULL
[16:09:30.514]                         }
[16:09:30.514]                         if (!has_future || version < "1.8.0") {
[16:09:30.514]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.514]                             "", base::R.version$version.string), 
[16:09:30.514]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.514]                               "release", "version")], collapse = " "), 
[16:09:30.514]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.514]                             info)
[16:09:30.514]                           info <- base::paste(info, collapse = "; ")
[16:09:30.514]                           if (!has_future) {
[16:09:30.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.514]                               info)
[16:09:30.514]                           }
[16:09:30.514]                           else {
[16:09:30.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.514]                               info, version)
[16:09:30.514]                           }
[16:09:30.514]                           base::stop(msg)
[16:09:30.514]                         }
[16:09:30.514]                       })
[16:09:30.514]                     }
[16:09:30.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.514]                     base::options(mc.cores = 1L)
[16:09:30.514]                   }
[16:09:30.514]                   options(future.plan = NULL)
[16:09:30.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.514]                 }
[16:09:30.514]                 ...future.workdir <- getwd()
[16:09:30.514]             }
[16:09:30.514]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.514]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.514]         }
[16:09:30.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.514]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.514]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.514]             base::names(...future.oldOptions))
[16:09:30.514]     }
[16:09:30.514]     if (FALSE) {
[16:09:30.514]     }
[16:09:30.514]     else {
[16:09:30.514]         if (TRUE) {
[16:09:30.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.514]                 open = "w")
[16:09:30.514]         }
[16:09:30.514]         else {
[16:09:30.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.514]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.514]         }
[16:09:30.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.514]             base::sink(type = "output", split = FALSE)
[16:09:30.514]             base::close(...future.stdout)
[16:09:30.514]         }, add = TRUE)
[16:09:30.514]     }
[16:09:30.514]     ...future.frame <- base::sys.nframe()
[16:09:30.514]     ...future.conditions <- base::list()
[16:09:30.514]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.514]     if (FALSE) {
[16:09:30.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.514]     }
[16:09:30.514]     ...future.result <- base::tryCatch({
[16:09:30.514]         base::withCallingHandlers({
[16:09:30.514]             ...future.value <- base::withVisible(base::local({
[16:09:30.514]                 ...future.makeSendCondition <- local({
[16:09:30.514]                   sendCondition <- NULL
[16:09:30.514]                   function(frame = 1L) {
[16:09:30.514]                     if (is.function(sendCondition)) 
[16:09:30.514]                       return(sendCondition)
[16:09:30.514]                     ns <- getNamespace("parallel")
[16:09:30.514]                     if (exists("sendData", mode = "function", 
[16:09:30.514]                       envir = ns)) {
[16:09:30.514]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.514]                         envir = ns)
[16:09:30.514]                       envir <- sys.frame(frame)
[16:09:30.514]                       master <- NULL
[16:09:30.514]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.514]                         !identical(envir, emptyenv())) {
[16:09:30.514]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.514]                           inherits = FALSE)) {
[16:09:30.514]                           master <- get("master", mode = "list", 
[16:09:30.514]                             envir = envir, inherits = FALSE)
[16:09:30.514]                           if (inherits(master, c("SOCKnode", 
[16:09:30.514]                             "SOCK0node"))) {
[16:09:30.514]                             sendCondition <<- function(cond) {
[16:09:30.514]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.514]                                 success = TRUE)
[16:09:30.514]                               parallel_sendData(master, data)
[16:09:30.514]                             }
[16:09:30.514]                             return(sendCondition)
[16:09:30.514]                           }
[16:09:30.514]                         }
[16:09:30.514]                         frame <- frame + 1L
[16:09:30.514]                         envir <- sys.frame(frame)
[16:09:30.514]                       }
[16:09:30.514]                     }
[16:09:30.514]                     sendCondition <<- function(cond) NULL
[16:09:30.514]                   }
[16:09:30.514]                 })
[16:09:30.514]                 withCallingHandlers({
[16:09:30.514]                   {
[16:09:30.514]                     do.call(function(...) {
[16:09:30.514]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.514]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.514]                         ...future.globals.maxSize)) {
[16:09:30.514]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.514]                         on.exit(options(oopts), add = TRUE)
[16:09:30.514]                       }
[16:09:30.514]                       {
[16:09:30.514]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.514]                           FUN = function(jj) {
[16:09:30.514]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.514]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.514]                           })
[16:09:30.514]                       }
[16:09:30.514]                     }, args = future.call.arguments)
[16:09:30.514]                   }
[16:09:30.514]                 }, immediateCondition = function(cond) {
[16:09:30.514]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.514]                   sendCondition(cond)
[16:09:30.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.514]                   {
[16:09:30.514]                     inherits <- base::inherits
[16:09:30.514]                     invokeRestart <- base::invokeRestart
[16:09:30.514]                     is.null <- base::is.null
[16:09:30.514]                     muffled <- FALSE
[16:09:30.514]                     if (inherits(cond, "message")) {
[16:09:30.514]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.514]                       if (muffled) 
[16:09:30.514]                         invokeRestart("muffleMessage")
[16:09:30.514]                     }
[16:09:30.514]                     else if (inherits(cond, "warning")) {
[16:09:30.514]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.514]                       if (muffled) 
[16:09:30.514]                         invokeRestart("muffleWarning")
[16:09:30.514]                     }
[16:09:30.514]                     else if (inherits(cond, "condition")) {
[16:09:30.514]                       if (!is.null(pattern)) {
[16:09:30.514]                         computeRestarts <- base::computeRestarts
[16:09:30.514]                         grepl <- base::grepl
[16:09:30.514]                         restarts <- computeRestarts(cond)
[16:09:30.514]                         for (restart in restarts) {
[16:09:30.514]                           name <- restart$name
[16:09:30.514]                           if (is.null(name)) 
[16:09:30.514]                             next
[16:09:30.514]                           if (!grepl(pattern, name)) 
[16:09:30.514]                             next
[16:09:30.514]                           invokeRestart(restart)
[16:09:30.514]                           muffled <- TRUE
[16:09:30.514]                           break
[16:09:30.514]                         }
[16:09:30.514]                       }
[16:09:30.514]                     }
[16:09:30.514]                     invisible(muffled)
[16:09:30.514]                   }
[16:09:30.514]                   muffleCondition(cond)
[16:09:30.514]                 })
[16:09:30.514]             }))
[16:09:30.514]             future::FutureResult(value = ...future.value$value, 
[16:09:30.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.514]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.514]                     ...future.globalenv.names))
[16:09:30.514]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.514]         }, condition = base::local({
[16:09:30.514]             c <- base::c
[16:09:30.514]             inherits <- base::inherits
[16:09:30.514]             invokeRestart <- base::invokeRestart
[16:09:30.514]             length <- base::length
[16:09:30.514]             list <- base::list
[16:09:30.514]             seq.int <- base::seq.int
[16:09:30.514]             signalCondition <- base::signalCondition
[16:09:30.514]             sys.calls <- base::sys.calls
[16:09:30.514]             `[[` <- base::`[[`
[16:09:30.514]             `+` <- base::`+`
[16:09:30.514]             `<<-` <- base::`<<-`
[16:09:30.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.514]                   3L)]
[16:09:30.514]             }
[16:09:30.514]             function(cond) {
[16:09:30.514]                 is_error <- inherits(cond, "error")
[16:09:30.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.514]                   NULL)
[16:09:30.514]                 if (is_error) {
[16:09:30.514]                   sessionInformation <- function() {
[16:09:30.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.514]                       search = base::search(), system = base::Sys.info())
[16:09:30.514]                   }
[16:09:30.514]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.514]                     cond$call), session = sessionInformation(), 
[16:09:30.514]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.514]                   signalCondition(cond)
[16:09:30.514]                 }
[16:09:30.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.514]                 "immediateCondition"))) {
[16:09:30.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.514]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.514]                   if (TRUE && !signal) {
[16:09:30.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.514]                     {
[16:09:30.514]                       inherits <- base::inherits
[16:09:30.514]                       invokeRestart <- base::invokeRestart
[16:09:30.514]                       is.null <- base::is.null
[16:09:30.514]                       muffled <- FALSE
[16:09:30.514]                       if (inherits(cond, "message")) {
[16:09:30.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.514]                         if (muffled) 
[16:09:30.514]                           invokeRestart("muffleMessage")
[16:09:30.514]                       }
[16:09:30.514]                       else if (inherits(cond, "warning")) {
[16:09:30.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.514]                         if (muffled) 
[16:09:30.514]                           invokeRestart("muffleWarning")
[16:09:30.514]                       }
[16:09:30.514]                       else if (inherits(cond, "condition")) {
[16:09:30.514]                         if (!is.null(pattern)) {
[16:09:30.514]                           computeRestarts <- base::computeRestarts
[16:09:30.514]                           grepl <- base::grepl
[16:09:30.514]                           restarts <- computeRestarts(cond)
[16:09:30.514]                           for (restart in restarts) {
[16:09:30.514]                             name <- restart$name
[16:09:30.514]                             if (is.null(name)) 
[16:09:30.514]                               next
[16:09:30.514]                             if (!grepl(pattern, name)) 
[16:09:30.514]                               next
[16:09:30.514]                             invokeRestart(restart)
[16:09:30.514]                             muffled <- TRUE
[16:09:30.514]                             break
[16:09:30.514]                           }
[16:09:30.514]                         }
[16:09:30.514]                       }
[16:09:30.514]                       invisible(muffled)
[16:09:30.514]                     }
[16:09:30.514]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.514]                   }
[16:09:30.514]                 }
[16:09:30.514]                 else {
[16:09:30.514]                   if (TRUE) {
[16:09:30.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.514]                     {
[16:09:30.514]                       inherits <- base::inherits
[16:09:30.514]                       invokeRestart <- base::invokeRestart
[16:09:30.514]                       is.null <- base::is.null
[16:09:30.514]                       muffled <- FALSE
[16:09:30.514]                       if (inherits(cond, "message")) {
[16:09:30.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.514]                         if (muffled) 
[16:09:30.514]                           invokeRestart("muffleMessage")
[16:09:30.514]                       }
[16:09:30.514]                       else if (inherits(cond, "warning")) {
[16:09:30.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.514]                         if (muffled) 
[16:09:30.514]                           invokeRestart("muffleWarning")
[16:09:30.514]                       }
[16:09:30.514]                       else if (inherits(cond, "condition")) {
[16:09:30.514]                         if (!is.null(pattern)) {
[16:09:30.514]                           computeRestarts <- base::computeRestarts
[16:09:30.514]                           grepl <- base::grepl
[16:09:30.514]                           restarts <- computeRestarts(cond)
[16:09:30.514]                           for (restart in restarts) {
[16:09:30.514]                             name <- restart$name
[16:09:30.514]                             if (is.null(name)) 
[16:09:30.514]                               next
[16:09:30.514]                             if (!grepl(pattern, name)) 
[16:09:30.514]                               next
[16:09:30.514]                             invokeRestart(restart)
[16:09:30.514]                             muffled <- TRUE
[16:09:30.514]                             break
[16:09:30.514]                           }
[16:09:30.514]                         }
[16:09:30.514]                       }
[16:09:30.514]                       invisible(muffled)
[16:09:30.514]                     }
[16:09:30.514]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.514]                   }
[16:09:30.514]                 }
[16:09:30.514]             }
[16:09:30.514]         }))
[16:09:30.514]     }, error = function(ex) {
[16:09:30.514]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.514]                 ...future.rng), started = ...future.startTime, 
[16:09:30.514]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.514]             version = "1.8"), class = "FutureResult")
[16:09:30.514]     }, finally = {
[16:09:30.514]         if (!identical(...future.workdir, getwd())) 
[16:09:30.514]             setwd(...future.workdir)
[16:09:30.514]         {
[16:09:30.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.514]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.514]             }
[16:09:30.514]             base::options(...future.oldOptions)
[16:09:30.514]             if (.Platform$OS.type == "windows") {
[16:09:30.514]                 old_names <- names(...future.oldEnvVars)
[16:09:30.514]                 envs <- base::Sys.getenv()
[16:09:30.514]                 names <- names(envs)
[16:09:30.514]                 common <- intersect(names, old_names)
[16:09:30.514]                 added <- setdiff(names, old_names)
[16:09:30.514]                 removed <- setdiff(old_names, names)
[16:09:30.514]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.514]                   envs[common]]
[16:09:30.514]                 NAMES <- toupper(changed)
[16:09:30.514]                 args <- list()
[16:09:30.514]                 for (kk in seq_along(NAMES)) {
[16:09:30.514]                   name <- changed[[kk]]
[16:09:30.514]                   NAME <- NAMES[[kk]]
[16:09:30.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.514]                     next
[16:09:30.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.514]                 }
[16:09:30.514]                 NAMES <- toupper(added)
[16:09:30.514]                 for (kk in seq_along(NAMES)) {
[16:09:30.514]                   name <- added[[kk]]
[16:09:30.514]                   NAME <- NAMES[[kk]]
[16:09:30.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.514]                     next
[16:09:30.514]                   args[[name]] <- ""
[16:09:30.514]                 }
[16:09:30.514]                 NAMES <- toupper(removed)
[16:09:30.514]                 for (kk in seq_along(NAMES)) {
[16:09:30.514]                   name <- removed[[kk]]
[16:09:30.514]                   NAME <- NAMES[[kk]]
[16:09:30.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.514]                     next
[16:09:30.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.514]                 }
[16:09:30.514]                 if (length(args) > 0) 
[16:09:30.514]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.514]             }
[16:09:30.514]             else {
[16:09:30.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.514]             }
[16:09:30.514]             {
[16:09:30.514]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.514]                   0L) {
[16:09:30.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.514]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.514]                   base::options(opts)
[16:09:30.514]                 }
[16:09:30.514]                 {
[16:09:30.514]                   {
[16:09:30.514]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.514]                     NULL
[16:09:30.514]                   }
[16:09:30.514]                   options(future.plan = NULL)
[16:09:30.514]                   if (is.na(NA_character_)) 
[16:09:30.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.514]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.514]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.514]                     envir = parent.frame()) 
[16:09:30.514]                   {
[16:09:30.514]                     if (is.function(workers)) 
[16:09:30.514]                       workers <- workers()
[16:09:30.514]                     workers <- structure(as.integer(workers), 
[16:09:30.514]                       class = class(workers))
[16:09:30.514]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.514]                       workers >= 1)
[16:09:30.514]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.514]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.514]                     }
[16:09:30.514]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.514]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.514]                       envir = envir)
[16:09:30.514]                     if (!future$lazy) 
[16:09:30.514]                       future <- run(future)
[16:09:30.514]                     invisible(future)
[16:09:30.514]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.514]                 }
[16:09:30.514]             }
[16:09:30.514]         }
[16:09:30.514]     })
[16:09:30.514]     if (TRUE) {
[16:09:30.514]         base::sink(type = "output", split = FALSE)
[16:09:30.514]         if (TRUE) {
[16:09:30.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.514]         }
[16:09:30.514]         else {
[16:09:30.514]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.514]         }
[16:09:30.514]         base::close(...future.stdout)
[16:09:30.514]         ...future.stdout <- NULL
[16:09:30.514]     }
[16:09:30.514]     ...future.result$conditions <- ...future.conditions
[16:09:30.514]     ...future.result$finished <- base::Sys.time()
[16:09:30.514]     ...future.result
[16:09:30.514] }
[16:09:30.517] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[16:09:30.517] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:30.517] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.517] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:09:30.518] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:09:30.518] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:09:30.518] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:09:30.518] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:30.519] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.519] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:30.519] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.519] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[16:09:30.520] MultisessionFuture started
[16:09:30.520] - Launch lazy future ... done
[16:09:30.520] run() for ‘MultisessionFuture’ ... done
[16:09:30.520] Created future:
[16:09:30.521] MultisessionFuture:
[16:09:30.521] Label: ‘future_apply-2’
[16:09:30.521] Expression:
[16:09:30.521] {
[16:09:30.521]     do.call(function(...) {
[16:09:30.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.521]             on.exit(options(oopts), add = TRUE)
[16:09:30.521]         }
[16:09:30.521]         {
[16:09:30.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.521]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.521]             })
[16:09:30.521]         }
[16:09:30.521]     }, args = future.call.arguments)
[16:09:30.521] }
[16:09:30.521] Lazy evaluation: FALSE
[16:09:30.521] Asynchronous evaluation: TRUE
[16:09:30.521] Local evaluation: TRUE
[16:09:30.521] Environment: R_GlobalEnv
[16:09:30.521] Capture standard output: TRUE
[16:09:30.521] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.521] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.521] Packages: <none>
[16:09:30.521] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.521] Resolved: FALSE
[16:09:30.521] Value: <not collected>
[16:09:30.521] Conditions captured: <none>
[16:09:30.521] Early signaling: FALSE
[16:09:30.521] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.521] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.532] Chunk #2 of 2 ... DONE
[16:09:30.532] Launching 2 futures (chunks) ... DONE
[16:09:30.532] Resolving 2 futures (chunks) ...
[16:09:30.532] resolve() on list ...
[16:09:30.532]  recursive: 0
[16:09:30.533]  length: 2
[16:09:30.533] 
[16:09:30.533] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.533] - Validating connection of MultisessionFuture
[16:09:30.533] - received message: FutureResult
[16:09:30.533] - Received FutureResult
[16:09:30.534] - Erased future from FutureRegistry
[16:09:30.534] result() for ClusterFuture ...
[16:09:30.534] - result already collected: FutureResult
[16:09:30.534] result() for ClusterFuture ... done
[16:09:30.534] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.534] Future #1
[16:09:30.534] result() for ClusterFuture ...
[16:09:30.534] - result already collected: FutureResult
[16:09:30.534] result() for ClusterFuture ... done
[16:09:30.534] result() for ClusterFuture ...
[16:09:30.535] - result already collected: FutureResult
[16:09:30.535] result() for ClusterFuture ... done
[16:09:30.535] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:30.535] - nx: 2
[16:09:30.535] - relay: TRUE
[16:09:30.535] - stdout: TRUE
[16:09:30.535] - signal: TRUE
[16:09:30.535] - resignal: FALSE
[16:09:30.535] - force: TRUE
[16:09:30.535] - relayed: [n=2] FALSE, FALSE
[16:09:30.535] - queued futures: [n=2] FALSE, FALSE
[16:09:30.536]  - until=1
[16:09:30.536]  - relaying element #1
[16:09:30.536] result() for ClusterFuture ...
[16:09:30.536] - result already collected: FutureResult
[16:09:30.536] result() for ClusterFuture ... done
[16:09:30.536] result() for ClusterFuture ...
[16:09:30.536] - result already collected: FutureResult
[16:09:30.536] result() for ClusterFuture ... done
[16:09:30.536] result() for ClusterFuture ...
[16:09:30.536] - result already collected: FutureResult
[16:09:30.537] result() for ClusterFuture ... done
[16:09:30.537] result() for ClusterFuture ...
[16:09:30.537] - result already collected: FutureResult
[16:09:30.537] result() for ClusterFuture ... done
[16:09:30.537] - relayed: [n=2] TRUE, FALSE
[16:09:30.537] - queued futures: [n=2] TRUE, FALSE
[16:09:30.537] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:30.537]  length: 1 (resolved future 1)
[16:09:30.579] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.579] - Validating connection of MultisessionFuture
[16:09:30.579] - received message: FutureResult
[16:09:30.579] - Received FutureResult
[16:09:30.579] - Erased future from FutureRegistry
[16:09:30.580] result() for ClusterFuture ...
[16:09:30.580] - result already collected: FutureResult
[16:09:30.580] result() for ClusterFuture ... done
[16:09:30.580] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.580] Future #2
[16:09:30.580] result() for ClusterFuture ...
[16:09:30.580] - result already collected: FutureResult
[16:09:30.580] result() for ClusterFuture ... done
[16:09:30.580] result() for ClusterFuture ...
[16:09:30.580] - result already collected: FutureResult
[16:09:30.580] result() for ClusterFuture ... done
[16:09:30.581] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:30.581] - nx: 2
[16:09:30.581] - relay: TRUE
[16:09:30.581] - stdout: TRUE
[16:09:30.581] - signal: TRUE
[16:09:30.581] - resignal: FALSE
[16:09:30.581] - force: TRUE
[16:09:30.581] - relayed: [n=2] TRUE, FALSE
[16:09:30.581] - queued futures: [n=2] TRUE, FALSE
[16:09:30.581]  - until=2
[16:09:30.581]  - relaying element #2
[16:09:30.582] result() for ClusterFuture ...
[16:09:30.582] - result already collected: FutureResult
[16:09:30.582] result() for ClusterFuture ... done
[16:09:30.582] result() for ClusterFuture ...
[16:09:30.582] - result already collected: FutureResult
[16:09:30.582] result() for ClusterFuture ... done
[16:09:30.582] result() for ClusterFuture ...
[16:09:30.582] - result already collected: FutureResult
[16:09:30.582] result() for ClusterFuture ... done
[16:09:30.582] result() for ClusterFuture ...
[16:09:30.582] - result already collected: FutureResult
[16:09:30.582] result() for ClusterFuture ... done
[16:09:30.583] - relayed: [n=2] TRUE, TRUE
[16:09:30.583] - queued futures: [n=2] TRUE, TRUE
[16:09:30.583] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:30.583]  length: 0 (resolved future 2)
[16:09:30.583] Relaying remaining futures
[16:09:30.583] signalConditionsASAP(NULL, pos=0) ...
[16:09:30.583] - nx: 2
[16:09:30.583] - relay: TRUE
[16:09:30.583] - stdout: TRUE
[16:09:30.583] - signal: TRUE
[16:09:30.583] - resignal: FALSE
[16:09:30.584] - force: TRUE
[16:09:30.584] - relayed: [n=2] TRUE, TRUE
[16:09:30.584] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:30.584] - relayed: [n=2] TRUE, TRUE
[16:09:30.584] - queued futures: [n=2] TRUE, TRUE
[16:09:30.584] signalConditionsASAP(NULL, pos=0) ... done
[16:09:30.584] resolve() on list ... DONE
[16:09:30.584] result() for ClusterFuture ...
[16:09:30.584] - result already collected: FutureResult
[16:09:30.584] result() for ClusterFuture ... done
[16:09:30.584] result() for ClusterFuture ...
[16:09:30.585] - result already collected: FutureResult
[16:09:30.585] result() for ClusterFuture ... done
[16:09:30.585] result() for ClusterFuture ...
[16:09:30.585] - result already collected: FutureResult
[16:09:30.585] result() for ClusterFuture ... done
[16:09:30.585] result() for ClusterFuture ...
[16:09:30.585] - result already collected: FutureResult
[16:09:30.585] result() for ClusterFuture ... done
[16:09:30.585]  - Number of value chunks collected: 2
[16:09:30.585] Resolving 2 futures (chunks) ... DONE
[16:09:30.585] Reducing values from 2 chunks ...
[16:09:30.586]  - Number of values collected after concatenation: 2
[16:09:30.586]  - Number of values expected: 2
[16:09:30.586] Reducing values from 2 chunks ... DONE
[16:09:30.586] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:09:30.586] getGlobalsAndPackagesXApply() ...
[16:09:30.586]  - future.globals: TRUE
[16:09:30.586] getGlobalsAndPackages() ...
[16:09:30.586] Searching for globals...
[16:09:30.587] - globals found: [1] ‘FUN’
[16:09:30.588] Searching for globals ... DONE
[16:09:30.588] Resolving globals: FALSE
[16:09:30.588] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:30.588] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:30.588] - globals: [1] ‘FUN’
[16:09:30.589] 
[16:09:30.589] getGlobalsAndPackages() ... DONE
[16:09:30.589]  - globals found/used: [n=1] ‘FUN’
[16:09:30.589]  - needed namespaces: [n=0] 
[16:09:30.589] Finding globals ... DONE
[16:09:30.589]  - use_args: TRUE
[16:09:30.589]  - Getting '...' globals ...
[16:09:30.589] resolve() on list ...
[16:09:30.590]  recursive: 0
[16:09:30.590]  length: 1
[16:09:30.590]  elements: ‘...’
[16:09:30.590]  length: 0 (resolved future 1)
[16:09:30.590] resolve() on list ... DONE
[16:09:30.590]    - '...' content: [n=0] 
[16:09:30.590] List of 1
[16:09:30.590]  $ ...: list()
[16:09:30.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.590]  - attr(*, "where")=List of 1
[16:09:30.590]   ..$ ...:<environment: 0x5633adada8f0> 
[16:09:30.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.590]  - attr(*, "resolved")= logi TRUE
[16:09:30.590]  - attr(*, "total_size")= num NA
[16:09:30.593]  - Getting '...' globals ... DONE
[16:09:30.593] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:30.593] List of 2
[16:09:30.593]  $ ...future.FUN:function (x)  
[16:09:30.593]  $ ...          : list()
[16:09:30.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.593]  - attr(*, "where")=List of 2
[16:09:30.593]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:30.593]   ..$ ...          :<environment: 0x5633adada8f0> 
[16:09:30.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.593]  - attr(*, "resolved")= logi FALSE
[16:09:30.593]  - attr(*, "total_size")= num 848
[16:09:30.596] Packages to be attached in all futures: [n=0] 
[16:09:30.596] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.599] future_lapply() ...
[16:09:30.602] Number of chunks: 2
[16:09:30.603] getGlobalsAndPackagesXApply() ...
[16:09:30.603]  - future.globals: <name-value list> with names ‘list()’
[16:09:30.603]  - use_args: TRUE
[16:09:30.603] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:30.603] List of 2
[16:09:30.603]  $ ...          : list()
[16:09:30.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.603]  $ ...future.FUN:function (x)  
[16:09:30.603]  - attr(*, "where")=List of 2
[16:09:30.603]   ..$ ...          :<environment: 0x5633adada8f0> 
[16:09:30.603]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:30.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.603]  - attr(*, "resolved")= logi FALSE
[16:09:30.603]  - attr(*, "total_size")= num NA
[16:09:30.606] Packages to be attached in all futures: [n=0] 
[16:09:30.606] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.607] Number of futures (= number of chunks): 2
[16:09:30.607] Launching 2 futures (chunks) ...
[16:09:30.607] Chunk #1 of 2 ...
[16:09:30.607]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:30.607]  - seeds: <none>
[16:09:30.607] getGlobalsAndPackages() ...
[16:09:30.607] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.607] Resolving globals: FALSE
[16:09:30.607] Tweak future expression to call with '...' arguments ...
[16:09:30.608] {
[16:09:30.608]     do.call(function(...) {
[16:09:30.608]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.608]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.608]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.608]             on.exit(options(oopts), add = TRUE)
[16:09:30.608]         }
[16:09:30.608]         {
[16:09:30.608]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.608]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.608]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.608]             })
[16:09:30.608]         }
[16:09:30.608]     }, args = future.call.arguments)
[16:09:30.608] }
[16:09:30.608] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.608] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.608] 
[16:09:30.608] getGlobalsAndPackages() ... DONE
[16:09:30.609] run() for ‘Future’ ...
[16:09:30.609] - state: ‘created’
[16:09:30.609] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.623] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.624]   - Field: ‘node’
[16:09:30.624]   - Field: ‘label’
[16:09:30.624]   - Field: ‘local’
[16:09:30.624]   - Field: ‘owner’
[16:09:30.624]   - Field: ‘envir’
[16:09:30.624]   - Field: ‘workers’
[16:09:30.624]   - Field: ‘packages’
[16:09:30.624]   - Field: ‘gc’
[16:09:30.625]   - Field: ‘conditions’
[16:09:30.625]   - Field: ‘persistent’
[16:09:30.625]   - Field: ‘expr’
[16:09:30.625]   - Field: ‘uuid’
[16:09:30.625]   - Field: ‘seed’
[16:09:30.625]   - Field: ‘version’
[16:09:30.625]   - Field: ‘result’
[16:09:30.625]   - Field: ‘asynchronous’
[16:09:30.625]   - Field: ‘calls’
[16:09:30.625]   - Field: ‘globals’
[16:09:30.625]   - Field: ‘stdout’
[16:09:30.626]   - Field: ‘earlySignal’
[16:09:30.626]   - Field: ‘lazy’
[16:09:30.626]   - Field: ‘state’
[16:09:30.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.626] - Launch lazy future ...
[16:09:30.626] Packages needed by the future expression (n = 0): <none>
[16:09:30.626] Packages needed by future strategies (n = 0): <none>
[16:09:30.627] {
[16:09:30.627]     {
[16:09:30.627]         {
[16:09:30.627]             ...future.startTime <- base::Sys.time()
[16:09:30.627]             {
[16:09:30.627]                 {
[16:09:30.627]                   {
[16:09:30.627]                     {
[16:09:30.627]                       base::local({
[16:09:30.627]                         has_future <- base::requireNamespace("future", 
[16:09:30.627]                           quietly = TRUE)
[16:09:30.627]                         if (has_future) {
[16:09:30.627]                           ns <- base::getNamespace("future")
[16:09:30.627]                           version <- ns[[".package"]][["version"]]
[16:09:30.627]                           if (is.null(version)) 
[16:09:30.627]                             version <- utils::packageVersion("future")
[16:09:30.627]                         }
[16:09:30.627]                         else {
[16:09:30.627]                           version <- NULL
[16:09:30.627]                         }
[16:09:30.627]                         if (!has_future || version < "1.8.0") {
[16:09:30.627]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.627]                             "", base::R.version$version.string), 
[16:09:30.627]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.627]                               "release", "version")], collapse = " "), 
[16:09:30.627]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.627]                             info)
[16:09:30.627]                           info <- base::paste(info, collapse = "; ")
[16:09:30.627]                           if (!has_future) {
[16:09:30.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.627]                               info)
[16:09:30.627]                           }
[16:09:30.627]                           else {
[16:09:30.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.627]                               info, version)
[16:09:30.627]                           }
[16:09:30.627]                           base::stop(msg)
[16:09:30.627]                         }
[16:09:30.627]                       })
[16:09:30.627]                     }
[16:09:30.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.627]                     base::options(mc.cores = 1L)
[16:09:30.627]                   }
[16:09:30.627]                   options(future.plan = NULL)
[16:09:30.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.627]                 }
[16:09:30.627]                 ...future.workdir <- getwd()
[16:09:30.627]             }
[16:09:30.627]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.627]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.627]         }
[16:09:30.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.627]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.627]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.627]             base::names(...future.oldOptions))
[16:09:30.627]     }
[16:09:30.627]     if (FALSE) {
[16:09:30.627]     }
[16:09:30.627]     else {
[16:09:30.627]         if (TRUE) {
[16:09:30.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.627]                 open = "w")
[16:09:30.627]         }
[16:09:30.627]         else {
[16:09:30.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.627]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.627]         }
[16:09:30.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.627]             base::sink(type = "output", split = FALSE)
[16:09:30.627]             base::close(...future.stdout)
[16:09:30.627]         }, add = TRUE)
[16:09:30.627]     }
[16:09:30.627]     ...future.frame <- base::sys.nframe()
[16:09:30.627]     ...future.conditions <- base::list()
[16:09:30.627]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.627]     if (FALSE) {
[16:09:30.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.627]     }
[16:09:30.627]     ...future.result <- base::tryCatch({
[16:09:30.627]         base::withCallingHandlers({
[16:09:30.627]             ...future.value <- base::withVisible(base::local({
[16:09:30.627]                 ...future.makeSendCondition <- local({
[16:09:30.627]                   sendCondition <- NULL
[16:09:30.627]                   function(frame = 1L) {
[16:09:30.627]                     if (is.function(sendCondition)) 
[16:09:30.627]                       return(sendCondition)
[16:09:30.627]                     ns <- getNamespace("parallel")
[16:09:30.627]                     if (exists("sendData", mode = "function", 
[16:09:30.627]                       envir = ns)) {
[16:09:30.627]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.627]                         envir = ns)
[16:09:30.627]                       envir <- sys.frame(frame)
[16:09:30.627]                       master <- NULL
[16:09:30.627]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.627]                         !identical(envir, emptyenv())) {
[16:09:30.627]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.627]                           inherits = FALSE)) {
[16:09:30.627]                           master <- get("master", mode = "list", 
[16:09:30.627]                             envir = envir, inherits = FALSE)
[16:09:30.627]                           if (inherits(master, c("SOCKnode", 
[16:09:30.627]                             "SOCK0node"))) {
[16:09:30.627]                             sendCondition <<- function(cond) {
[16:09:30.627]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.627]                                 success = TRUE)
[16:09:30.627]                               parallel_sendData(master, data)
[16:09:30.627]                             }
[16:09:30.627]                             return(sendCondition)
[16:09:30.627]                           }
[16:09:30.627]                         }
[16:09:30.627]                         frame <- frame + 1L
[16:09:30.627]                         envir <- sys.frame(frame)
[16:09:30.627]                       }
[16:09:30.627]                     }
[16:09:30.627]                     sendCondition <<- function(cond) NULL
[16:09:30.627]                   }
[16:09:30.627]                 })
[16:09:30.627]                 withCallingHandlers({
[16:09:30.627]                   {
[16:09:30.627]                     do.call(function(...) {
[16:09:30.627]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.627]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.627]                         ...future.globals.maxSize)) {
[16:09:30.627]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.627]                         on.exit(options(oopts), add = TRUE)
[16:09:30.627]                       }
[16:09:30.627]                       {
[16:09:30.627]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.627]                           FUN = function(jj) {
[16:09:30.627]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.627]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.627]                           })
[16:09:30.627]                       }
[16:09:30.627]                     }, args = future.call.arguments)
[16:09:30.627]                   }
[16:09:30.627]                 }, immediateCondition = function(cond) {
[16:09:30.627]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.627]                   sendCondition(cond)
[16:09:30.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.627]                   {
[16:09:30.627]                     inherits <- base::inherits
[16:09:30.627]                     invokeRestart <- base::invokeRestart
[16:09:30.627]                     is.null <- base::is.null
[16:09:30.627]                     muffled <- FALSE
[16:09:30.627]                     if (inherits(cond, "message")) {
[16:09:30.627]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.627]                       if (muffled) 
[16:09:30.627]                         invokeRestart("muffleMessage")
[16:09:30.627]                     }
[16:09:30.627]                     else if (inherits(cond, "warning")) {
[16:09:30.627]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.627]                       if (muffled) 
[16:09:30.627]                         invokeRestart("muffleWarning")
[16:09:30.627]                     }
[16:09:30.627]                     else if (inherits(cond, "condition")) {
[16:09:30.627]                       if (!is.null(pattern)) {
[16:09:30.627]                         computeRestarts <- base::computeRestarts
[16:09:30.627]                         grepl <- base::grepl
[16:09:30.627]                         restarts <- computeRestarts(cond)
[16:09:30.627]                         for (restart in restarts) {
[16:09:30.627]                           name <- restart$name
[16:09:30.627]                           if (is.null(name)) 
[16:09:30.627]                             next
[16:09:30.627]                           if (!grepl(pattern, name)) 
[16:09:30.627]                             next
[16:09:30.627]                           invokeRestart(restart)
[16:09:30.627]                           muffled <- TRUE
[16:09:30.627]                           break
[16:09:30.627]                         }
[16:09:30.627]                       }
[16:09:30.627]                     }
[16:09:30.627]                     invisible(muffled)
[16:09:30.627]                   }
[16:09:30.627]                   muffleCondition(cond)
[16:09:30.627]                 })
[16:09:30.627]             }))
[16:09:30.627]             future::FutureResult(value = ...future.value$value, 
[16:09:30.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.627]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.627]                     ...future.globalenv.names))
[16:09:30.627]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.627]         }, condition = base::local({
[16:09:30.627]             c <- base::c
[16:09:30.627]             inherits <- base::inherits
[16:09:30.627]             invokeRestart <- base::invokeRestart
[16:09:30.627]             length <- base::length
[16:09:30.627]             list <- base::list
[16:09:30.627]             seq.int <- base::seq.int
[16:09:30.627]             signalCondition <- base::signalCondition
[16:09:30.627]             sys.calls <- base::sys.calls
[16:09:30.627]             `[[` <- base::`[[`
[16:09:30.627]             `+` <- base::`+`
[16:09:30.627]             `<<-` <- base::`<<-`
[16:09:30.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.627]                   3L)]
[16:09:30.627]             }
[16:09:30.627]             function(cond) {
[16:09:30.627]                 is_error <- inherits(cond, "error")
[16:09:30.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.627]                   NULL)
[16:09:30.627]                 if (is_error) {
[16:09:30.627]                   sessionInformation <- function() {
[16:09:30.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.627]                       search = base::search(), system = base::Sys.info())
[16:09:30.627]                   }
[16:09:30.627]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.627]                     cond$call), session = sessionInformation(), 
[16:09:30.627]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.627]                   signalCondition(cond)
[16:09:30.627]                 }
[16:09:30.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.627]                 "immediateCondition"))) {
[16:09:30.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.627]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.627]                   if (TRUE && !signal) {
[16:09:30.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.627]                     {
[16:09:30.627]                       inherits <- base::inherits
[16:09:30.627]                       invokeRestart <- base::invokeRestart
[16:09:30.627]                       is.null <- base::is.null
[16:09:30.627]                       muffled <- FALSE
[16:09:30.627]                       if (inherits(cond, "message")) {
[16:09:30.627]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.627]                         if (muffled) 
[16:09:30.627]                           invokeRestart("muffleMessage")
[16:09:30.627]                       }
[16:09:30.627]                       else if (inherits(cond, "warning")) {
[16:09:30.627]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.627]                         if (muffled) 
[16:09:30.627]                           invokeRestart("muffleWarning")
[16:09:30.627]                       }
[16:09:30.627]                       else if (inherits(cond, "condition")) {
[16:09:30.627]                         if (!is.null(pattern)) {
[16:09:30.627]                           computeRestarts <- base::computeRestarts
[16:09:30.627]                           grepl <- base::grepl
[16:09:30.627]                           restarts <- computeRestarts(cond)
[16:09:30.627]                           for (restart in restarts) {
[16:09:30.627]                             name <- restart$name
[16:09:30.627]                             if (is.null(name)) 
[16:09:30.627]                               next
[16:09:30.627]                             if (!grepl(pattern, name)) 
[16:09:30.627]                               next
[16:09:30.627]                             invokeRestart(restart)
[16:09:30.627]                             muffled <- TRUE
[16:09:30.627]                             break
[16:09:30.627]                           }
[16:09:30.627]                         }
[16:09:30.627]                       }
[16:09:30.627]                       invisible(muffled)
[16:09:30.627]                     }
[16:09:30.627]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.627]                   }
[16:09:30.627]                 }
[16:09:30.627]                 else {
[16:09:30.627]                   if (TRUE) {
[16:09:30.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.627]                     {
[16:09:30.627]                       inherits <- base::inherits
[16:09:30.627]                       invokeRestart <- base::invokeRestart
[16:09:30.627]                       is.null <- base::is.null
[16:09:30.627]                       muffled <- FALSE
[16:09:30.627]                       if (inherits(cond, "message")) {
[16:09:30.627]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.627]                         if (muffled) 
[16:09:30.627]                           invokeRestart("muffleMessage")
[16:09:30.627]                       }
[16:09:30.627]                       else if (inherits(cond, "warning")) {
[16:09:30.627]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.627]                         if (muffled) 
[16:09:30.627]                           invokeRestart("muffleWarning")
[16:09:30.627]                       }
[16:09:30.627]                       else if (inherits(cond, "condition")) {
[16:09:30.627]                         if (!is.null(pattern)) {
[16:09:30.627]                           computeRestarts <- base::computeRestarts
[16:09:30.627]                           grepl <- base::grepl
[16:09:30.627]                           restarts <- computeRestarts(cond)
[16:09:30.627]                           for (restart in restarts) {
[16:09:30.627]                             name <- restart$name
[16:09:30.627]                             if (is.null(name)) 
[16:09:30.627]                               next
[16:09:30.627]                             if (!grepl(pattern, name)) 
[16:09:30.627]                               next
[16:09:30.627]                             invokeRestart(restart)
[16:09:30.627]                             muffled <- TRUE
[16:09:30.627]                             break
[16:09:30.627]                           }
[16:09:30.627]                         }
[16:09:30.627]                       }
[16:09:30.627]                       invisible(muffled)
[16:09:30.627]                     }
[16:09:30.627]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.627]                   }
[16:09:30.627]                 }
[16:09:30.627]             }
[16:09:30.627]         }))
[16:09:30.627]     }, error = function(ex) {
[16:09:30.627]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.627]                 ...future.rng), started = ...future.startTime, 
[16:09:30.627]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.627]             version = "1.8"), class = "FutureResult")
[16:09:30.627]     }, finally = {
[16:09:30.627]         if (!identical(...future.workdir, getwd())) 
[16:09:30.627]             setwd(...future.workdir)
[16:09:30.627]         {
[16:09:30.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.627]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.627]             }
[16:09:30.627]             base::options(...future.oldOptions)
[16:09:30.627]             if (.Platform$OS.type == "windows") {
[16:09:30.627]                 old_names <- names(...future.oldEnvVars)
[16:09:30.627]                 envs <- base::Sys.getenv()
[16:09:30.627]                 names <- names(envs)
[16:09:30.627]                 common <- intersect(names, old_names)
[16:09:30.627]                 added <- setdiff(names, old_names)
[16:09:30.627]                 removed <- setdiff(old_names, names)
[16:09:30.627]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.627]                   envs[common]]
[16:09:30.627]                 NAMES <- toupper(changed)
[16:09:30.627]                 args <- list()
[16:09:30.627]                 for (kk in seq_along(NAMES)) {
[16:09:30.627]                   name <- changed[[kk]]
[16:09:30.627]                   NAME <- NAMES[[kk]]
[16:09:30.627]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.627]                     next
[16:09:30.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.627]                 }
[16:09:30.627]                 NAMES <- toupper(added)
[16:09:30.627]                 for (kk in seq_along(NAMES)) {
[16:09:30.627]                   name <- added[[kk]]
[16:09:30.627]                   NAME <- NAMES[[kk]]
[16:09:30.627]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.627]                     next
[16:09:30.627]                   args[[name]] <- ""
[16:09:30.627]                 }
[16:09:30.627]                 NAMES <- toupper(removed)
[16:09:30.627]                 for (kk in seq_along(NAMES)) {
[16:09:30.627]                   name <- removed[[kk]]
[16:09:30.627]                   NAME <- NAMES[[kk]]
[16:09:30.627]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.627]                     next
[16:09:30.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.627]                 }
[16:09:30.627]                 if (length(args) > 0) 
[16:09:30.627]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.627]             }
[16:09:30.627]             else {
[16:09:30.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.627]             }
[16:09:30.627]             {
[16:09:30.627]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.627]                   0L) {
[16:09:30.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.627]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.627]                   base::options(opts)
[16:09:30.627]                 }
[16:09:30.627]                 {
[16:09:30.627]                   {
[16:09:30.627]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.627]                     NULL
[16:09:30.627]                   }
[16:09:30.627]                   options(future.plan = NULL)
[16:09:30.627]                   if (is.na(NA_character_)) 
[16:09:30.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.627]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.627]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.627]                     envir = parent.frame()) 
[16:09:30.627]                   {
[16:09:30.627]                     if (is.function(workers)) 
[16:09:30.627]                       workers <- workers()
[16:09:30.627]                     workers <- structure(as.integer(workers), 
[16:09:30.627]                       class = class(workers))
[16:09:30.627]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.627]                       workers >= 1)
[16:09:30.627]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.627]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.627]                     }
[16:09:30.627]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.627]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.627]                       envir = envir)
[16:09:30.627]                     if (!future$lazy) 
[16:09:30.627]                       future <- run(future)
[16:09:30.627]                     invisible(future)
[16:09:30.627]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.627]                 }
[16:09:30.627]             }
[16:09:30.627]         }
[16:09:30.627]     })
[16:09:30.627]     if (TRUE) {
[16:09:30.627]         base::sink(type = "output", split = FALSE)
[16:09:30.627]         if (TRUE) {
[16:09:30.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.627]         }
[16:09:30.627]         else {
[16:09:30.627]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.627]         }
[16:09:30.627]         base::close(...future.stdout)
[16:09:30.627]         ...future.stdout <- NULL
[16:09:30.627]     }
[16:09:30.627]     ...future.result$conditions <- ...future.conditions
[16:09:30.627]     ...future.result$finished <- base::Sys.time()
[16:09:30.627]     ...future.result
[16:09:30.627] }
[16:09:30.630] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:09:30.630] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:30.630] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.631] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:09:30.631] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:09:30.631] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:09:30.631] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:09:30.631] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:30.632] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.632] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:09:30.632] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:09:30.632] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:09:30.633] MultisessionFuture started
[16:09:30.633] - Launch lazy future ... done
[16:09:30.633] run() for ‘MultisessionFuture’ ... done
[16:09:30.633] Created future:
[16:09:30.633] MultisessionFuture:
[16:09:30.633] Label: ‘future_apply-1’
[16:09:30.633] Expression:
[16:09:30.633] {
[16:09:30.633]     do.call(function(...) {
[16:09:30.633]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.633]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.633]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.633]             on.exit(options(oopts), add = TRUE)
[16:09:30.633]         }
[16:09:30.633]         {
[16:09:30.633]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.633]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.633]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.633]             })
[16:09:30.633]         }
[16:09:30.633]     }, args = future.call.arguments)
[16:09:30.633] }
[16:09:30.633] Lazy evaluation: FALSE
[16:09:30.633] Asynchronous evaluation: TRUE
[16:09:30.633] Local evaluation: TRUE
[16:09:30.633] Environment: R_GlobalEnv
[16:09:30.633] Capture standard output: TRUE
[16:09:30.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.633] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:30.633] Packages: <none>
[16:09:30.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.633] Resolved: FALSE
[16:09:30.633] Value: <not collected>
[16:09:30.633] Conditions captured: <none>
[16:09:30.633] Early signaling: FALSE
[16:09:30.633] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.633] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.645] Chunk #1 of 2 ... DONE
[16:09:30.645] Chunk #2 of 2 ...
[16:09:30.645]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:30.645]  - seeds: <none>
[16:09:30.645] getGlobalsAndPackages() ...
[16:09:30.645] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.645] Resolving globals: FALSE
[16:09:30.645] Tweak future expression to call with '...' arguments ...
[16:09:30.646] {
[16:09:30.646]     do.call(function(...) {
[16:09:30.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.646]             on.exit(options(oopts), add = TRUE)
[16:09:30.646]         }
[16:09:30.646]         {
[16:09:30.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.646]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.646]             })
[16:09:30.646]         }
[16:09:30.646]     }, args = future.call.arguments)
[16:09:30.646] }
[16:09:30.646] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.646] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.646] 
[16:09:30.646] getGlobalsAndPackages() ... DONE
[16:09:30.648] run() for ‘Future’ ...
[16:09:30.649] - state: ‘created’
[16:09:30.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.663]   - Field: ‘node’
[16:09:30.663]   - Field: ‘label’
[16:09:30.663]   - Field: ‘local’
[16:09:30.663]   - Field: ‘owner’
[16:09:30.663]   - Field: ‘envir’
[16:09:30.664]   - Field: ‘workers’
[16:09:30.664]   - Field: ‘packages’
[16:09:30.664]   - Field: ‘gc’
[16:09:30.664]   - Field: ‘conditions’
[16:09:30.664]   - Field: ‘persistent’
[16:09:30.664]   - Field: ‘expr’
[16:09:30.664]   - Field: ‘uuid’
[16:09:30.664]   - Field: ‘seed’
[16:09:30.664]   - Field: ‘version’
[16:09:30.664]   - Field: ‘result’
[16:09:30.665]   - Field: ‘asynchronous’
[16:09:30.665]   - Field: ‘calls’
[16:09:30.665]   - Field: ‘globals’
[16:09:30.665]   - Field: ‘stdout’
[16:09:30.665]   - Field: ‘earlySignal’
[16:09:30.665]   - Field: ‘lazy’
[16:09:30.665]   - Field: ‘state’
[16:09:30.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.665] - Launch lazy future ...
[16:09:30.665] Packages needed by the future expression (n = 0): <none>
[16:09:30.666] Packages needed by future strategies (n = 0): <none>
[16:09:30.666] {
[16:09:30.666]     {
[16:09:30.666]         {
[16:09:30.666]             ...future.startTime <- base::Sys.time()
[16:09:30.666]             {
[16:09:30.666]                 {
[16:09:30.666]                   {
[16:09:30.666]                     {
[16:09:30.666]                       base::local({
[16:09:30.666]                         has_future <- base::requireNamespace("future", 
[16:09:30.666]                           quietly = TRUE)
[16:09:30.666]                         if (has_future) {
[16:09:30.666]                           ns <- base::getNamespace("future")
[16:09:30.666]                           version <- ns[[".package"]][["version"]]
[16:09:30.666]                           if (is.null(version)) 
[16:09:30.666]                             version <- utils::packageVersion("future")
[16:09:30.666]                         }
[16:09:30.666]                         else {
[16:09:30.666]                           version <- NULL
[16:09:30.666]                         }
[16:09:30.666]                         if (!has_future || version < "1.8.0") {
[16:09:30.666]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.666]                             "", base::R.version$version.string), 
[16:09:30.666]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.666]                               "release", "version")], collapse = " "), 
[16:09:30.666]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.666]                             info)
[16:09:30.666]                           info <- base::paste(info, collapse = "; ")
[16:09:30.666]                           if (!has_future) {
[16:09:30.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.666]                               info)
[16:09:30.666]                           }
[16:09:30.666]                           else {
[16:09:30.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.666]                               info, version)
[16:09:30.666]                           }
[16:09:30.666]                           base::stop(msg)
[16:09:30.666]                         }
[16:09:30.666]                       })
[16:09:30.666]                     }
[16:09:30.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.666]                     base::options(mc.cores = 1L)
[16:09:30.666]                   }
[16:09:30.666]                   options(future.plan = NULL)
[16:09:30.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.666]                 }
[16:09:30.666]                 ...future.workdir <- getwd()
[16:09:30.666]             }
[16:09:30.666]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.666]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.666]         }
[16:09:30.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.666]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.666]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.666]             base::names(...future.oldOptions))
[16:09:30.666]     }
[16:09:30.666]     if (FALSE) {
[16:09:30.666]     }
[16:09:30.666]     else {
[16:09:30.666]         if (TRUE) {
[16:09:30.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.666]                 open = "w")
[16:09:30.666]         }
[16:09:30.666]         else {
[16:09:30.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.666]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.666]         }
[16:09:30.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.666]             base::sink(type = "output", split = FALSE)
[16:09:30.666]             base::close(...future.stdout)
[16:09:30.666]         }, add = TRUE)
[16:09:30.666]     }
[16:09:30.666]     ...future.frame <- base::sys.nframe()
[16:09:30.666]     ...future.conditions <- base::list()
[16:09:30.666]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.666]     if (FALSE) {
[16:09:30.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.666]     }
[16:09:30.666]     ...future.result <- base::tryCatch({
[16:09:30.666]         base::withCallingHandlers({
[16:09:30.666]             ...future.value <- base::withVisible(base::local({
[16:09:30.666]                 ...future.makeSendCondition <- local({
[16:09:30.666]                   sendCondition <- NULL
[16:09:30.666]                   function(frame = 1L) {
[16:09:30.666]                     if (is.function(sendCondition)) 
[16:09:30.666]                       return(sendCondition)
[16:09:30.666]                     ns <- getNamespace("parallel")
[16:09:30.666]                     if (exists("sendData", mode = "function", 
[16:09:30.666]                       envir = ns)) {
[16:09:30.666]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.666]                         envir = ns)
[16:09:30.666]                       envir <- sys.frame(frame)
[16:09:30.666]                       master <- NULL
[16:09:30.666]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.666]                         !identical(envir, emptyenv())) {
[16:09:30.666]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.666]                           inherits = FALSE)) {
[16:09:30.666]                           master <- get("master", mode = "list", 
[16:09:30.666]                             envir = envir, inherits = FALSE)
[16:09:30.666]                           if (inherits(master, c("SOCKnode", 
[16:09:30.666]                             "SOCK0node"))) {
[16:09:30.666]                             sendCondition <<- function(cond) {
[16:09:30.666]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.666]                                 success = TRUE)
[16:09:30.666]                               parallel_sendData(master, data)
[16:09:30.666]                             }
[16:09:30.666]                             return(sendCondition)
[16:09:30.666]                           }
[16:09:30.666]                         }
[16:09:30.666]                         frame <- frame + 1L
[16:09:30.666]                         envir <- sys.frame(frame)
[16:09:30.666]                       }
[16:09:30.666]                     }
[16:09:30.666]                     sendCondition <<- function(cond) NULL
[16:09:30.666]                   }
[16:09:30.666]                 })
[16:09:30.666]                 withCallingHandlers({
[16:09:30.666]                   {
[16:09:30.666]                     do.call(function(...) {
[16:09:30.666]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.666]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.666]                         ...future.globals.maxSize)) {
[16:09:30.666]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.666]                         on.exit(options(oopts), add = TRUE)
[16:09:30.666]                       }
[16:09:30.666]                       {
[16:09:30.666]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.666]                           FUN = function(jj) {
[16:09:30.666]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.666]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.666]                           })
[16:09:30.666]                       }
[16:09:30.666]                     }, args = future.call.arguments)
[16:09:30.666]                   }
[16:09:30.666]                 }, immediateCondition = function(cond) {
[16:09:30.666]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.666]                   sendCondition(cond)
[16:09:30.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.666]                   {
[16:09:30.666]                     inherits <- base::inherits
[16:09:30.666]                     invokeRestart <- base::invokeRestart
[16:09:30.666]                     is.null <- base::is.null
[16:09:30.666]                     muffled <- FALSE
[16:09:30.666]                     if (inherits(cond, "message")) {
[16:09:30.666]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.666]                       if (muffled) 
[16:09:30.666]                         invokeRestart("muffleMessage")
[16:09:30.666]                     }
[16:09:30.666]                     else if (inherits(cond, "warning")) {
[16:09:30.666]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.666]                       if (muffled) 
[16:09:30.666]                         invokeRestart("muffleWarning")
[16:09:30.666]                     }
[16:09:30.666]                     else if (inherits(cond, "condition")) {
[16:09:30.666]                       if (!is.null(pattern)) {
[16:09:30.666]                         computeRestarts <- base::computeRestarts
[16:09:30.666]                         grepl <- base::grepl
[16:09:30.666]                         restarts <- computeRestarts(cond)
[16:09:30.666]                         for (restart in restarts) {
[16:09:30.666]                           name <- restart$name
[16:09:30.666]                           if (is.null(name)) 
[16:09:30.666]                             next
[16:09:30.666]                           if (!grepl(pattern, name)) 
[16:09:30.666]                             next
[16:09:30.666]                           invokeRestart(restart)
[16:09:30.666]                           muffled <- TRUE
[16:09:30.666]                           break
[16:09:30.666]                         }
[16:09:30.666]                       }
[16:09:30.666]                     }
[16:09:30.666]                     invisible(muffled)
[16:09:30.666]                   }
[16:09:30.666]                   muffleCondition(cond)
[16:09:30.666]                 })
[16:09:30.666]             }))
[16:09:30.666]             future::FutureResult(value = ...future.value$value, 
[16:09:30.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.666]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.666]                     ...future.globalenv.names))
[16:09:30.666]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.666]         }, condition = base::local({
[16:09:30.666]             c <- base::c
[16:09:30.666]             inherits <- base::inherits
[16:09:30.666]             invokeRestart <- base::invokeRestart
[16:09:30.666]             length <- base::length
[16:09:30.666]             list <- base::list
[16:09:30.666]             seq.int <- base::seq.int
[16:09:30.666]             signalCondition <- base::signalCondition
[16:09:30.666]             sys.calls <- base::sys.calls
[16:09:30.666]             `[[` <- base::`[[`
[16:09:30.666]             `+` <- base::`+`
[16:09:30.666]             `<<-` <- base::`<<-`
[16:09:30.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.666]                   3L)]
[16:09:30.666]             }
[16:09:30.666]             function(cond) {
[16:09:30.666]                 is_error <- inherits(cond, "error")
[16:09:30.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.666]                   NULL)
[16:09:30.666]                 if (is_error) {
[16:09:30.666]                   sessionInformation <- function() {
[16:09:30.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.666]                       search = base::search(), system = base::Sys.info())
[16:09:30.666]                   }
[16:09:30.666]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.666]                     cond$call), session = sessionInformation(), 
[16:09:30.666]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.666]                   signalCondition(cond)
[16:09:30.666]                 }
[16:09:30.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.666]                 "immediateCondition"))) {
[16:09:30.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.666]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.666]                   if (TRUE && !signal) {
[16:09:30.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.666]                     {
[16:09:30.666]                       inherits <- base::inherits
[16:09:30.666]                       invokeRestart <- base::invokeRestart
[16:09:30.666]                       is.null <- base::is.null
[16:09:30.666]                       muffled <- FALSE
[16:09:30.666]                       if (inherits(cond, "message")) {
[16:09:30.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.666]                         if (muffled) 
[16:09:30.666]                           invokeRestart("muffleMessage")
[16:09:30.666]                       }
[16:09:30.666]                       else if (inherits(cond, "warning")) {
[16:09:30.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.666]                         if (muffled) 
[16:09:30.666]                           invokeRestart("muffleWarning")
[16:09:30.666]                       }
[16:09:30.666]                       else if (inherits(cond, "condition")) {
[16:09:30.666]                         if (!is.null(pattern)) {
[16:09:30.666]                           computeRestarts <- base::computeRestarts
[16:09:30.666]                           grepl <- base::grepl
[16:09:30.666]                           restarts <- computeRestarts(cond)
[16:09:30.666]                           for (restart in restarts) {
[16:09:30.666]                             name <- restart$name
[16:09:30.666]                             if (is.null(name)) 
[16:09:30.666]                               next
[16:09:30.666]                             if (!grepl(pattern, name)) 
[16:09:30.666]                               next
[16:09:30.666]                             invokeRestart(restart)
[16:09:30.666]                             muffled <- TRUE
[16:09:30.666]                             break
[16:09:30.666]                           }
[16:09:30.666]                         }
[16:09:30.666]                       }
[16:09:30.666]                       invisible(muffled)
[16:09:30.666]                     }
[16:09:30.666]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.666]                   }
[16:09:30.666]                 }
[16:09:30.666]                 else {
[16:09:30.666]                   if (TRUE) {
[16:09:30.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.666]                     {
[16:09:30.666]                       inherits <- base::inherits
[16:09:30.666]                       invokeRestart <- base::invokeRestart
[16:09:30.666]                       is.null <- base::is.null
[16:09:30.666]                       muffled <- FALSE
[16:09:30.666]                       if (inherits(cond, "message")) {
[16:09:30.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.666]                         if (muffled) 
[16:09:30.666]                           invokeRestart("muffleMessage")
[16:09:30.666]                       }
[16:09:30.666]                       else if (inherits(cond, "warning")) {
[16:09:30.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.666]                         if (muffled) 
[16:09:30.666]                           invokeRestart("muffleWarning")
[16:09:30.666]                       }
[16:09:30.666]                       else if (inherits(cond, "condition")) {
[16:09:30.666]                         if (!is.null(pattern)) {
[16:09:30.666]                           computeRestarts <- base::computeRestarts
[16:09:30.666]                           grepl <- base::grepl
[16:09:30.666]                           restarts <- computeRestarts(cond)
[16:09:30.666]                           for (restart in restarts) {
[16:09:30.666]                             name <- restart$name
[16:09:30.666]                             if (is.null(name)) 
[16:09:30.666]                               next
[16:09:30.666]                             if (!grepl(pattern, name)) 
[16:09:30.666]                               next
[16:09:30.666]                             invokeRestart(restart)
[16:09:30.666]                             muffled <- TRUE
[16:09:30.666]                             break
[16:09:30.666]                           }
[16:09:30.666]                         }
[16:09:30.666]                       }
[16:09:30.666]                       invisible(muffled)
[16:09:30.666]                     }
[16:09:30.666]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.666]                   }
[16:09:30.666]                 }
[16:09:30.666]             }
[16:09:30.666]         }))
[16:09:30.666]     }, error = function(ex) {
[16:09:30.666]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.666]                 ...future.rng), started = ...future.startTime, 
[16:09:30.666]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.666]             version = "1.8"), class = "FutureResult")
[16:09:30.666]     }, finally = {
[16:09:30.666]         if (!identical(...future.workdir, getwd())) 
[16:09:30.666]             setwd(...future.workdir)
[16:09:30.666]         {
[16:09:30.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.666]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.666]             }
[16:09:30.666]             base::options(...future.oldOptions)
[16:09:30.666]             if (.Platform$OS.type == "windows") {
[16:09:30.666]                 old_names <- names(...future.oldEnvVars)
[16:09:30.666]                 envs <- base::Sys.getenv()
[16:09:30.666]                 names <- names(envs)
[16:09:30.666]                 common <- intersect(names, old_names)
[16:09:30.666]                 added <- setdiff(names, old_names)
[16:09:30.666]                 removed <- setdiff(old_names, names)
[16:09:30.666]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.666]                   envs[common]]
[16:09:30.666]                 NAMES <- toupper(changed)
[16:09:30.666]                 args <- list()
[16:09:30.666]                 for (kk in seq_along(NAMES)) {
[16:09:30.666]                   name <- changed[[kk]]
[16:09:30.666]                   NAME <- NAMES[[kk]]
[16:09:30.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.666]                     next
[16:09:30.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.666]                 }
[16:09:30.666]                 NAMES <- toupper(added)
[16:09:30.666]                 for (kk in seq_along(NAMES)) {
[16:09:30.666]                   name <- added[[kk]]
[16:09:30.666]                   NAME <- NAMES[[kk]]
[16:09:30.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.666]                     next
[16:09:30.666]                   args[[name]] <- ""
[16:09:30.666]                 }
[16:09:30.666]                 NAMES <- toupper(removed)
[16:09:30.666]                 for (kk in seq_along(NAMES)) {
[16:09:30.666]                   name <- removed[[kk]]
[16:09:30.666]                   NAME <- NAMES[[kk]]
[16:09:30.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.666]                     next
[16:09:30.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.666]                 }
[16:09:30.666]                 if (length(args) > 0) 
[16:09:30.666]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.666]             }
[16:09:30.666]             else {
[16:09:30.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.666]             }
[16:09:30.666]             {
[16:09:30.666]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.666]                   0L) {
[16:09:30.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.666]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.666]                   base::options(opts)
[16:09:30.666]                 }
[16:09:30.666]                 {
[16:09:30.666]                   {
[16:09:30.666]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.666]                     NULL
[16:09:30.666]                   }
[16:09:30.666]                   options(future.plan = NULL)
[16:09:30.666]                   if (is.na(NA_character_)) 
[16:09:30.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.666]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.666]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.666]                     envir = parent.frame()) 
[16:09:30.666]                   {
[16:09:30.666]                     if (is.function(workers)) 
[16:09:30.666]                       workers <- workers()
[16:09:30.666]                     workers <- structure(as.integer(workers), 
[16:09:30.666]                       class = class(workers))
[16:09:30.666]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.666]                       workers >= 1)
[16:09:30.666]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.666]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.666]                     }
[16:09:30.666]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.666]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.666]                       envir = envir)
[16:09:30.666]                     if (!future$lazy) 
[16:09:30.666]                       future <- run(future)
[16:09:30.666]                     invisible(future)
[16:09:30.666]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.666]                 }
[16:09:30.666]             }
[16:09:30.666]         }
[16:09:30.666]     })
[16:09:30.666]     if (TRUE) {
[16:09:30.666]         base::sink(type = "output", split = FALSE)
[16:09:30.666]         if (TRUE) {
[16:09:30.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.666]         }
[16:09:30.666]         else {
[16:09:30.666]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.666]         }
[16:09:30.666]         base::close(...future.stdout)
[16:09:30.666]         ...future.stdout <- NULL
[16:09:30.666]     }
[16:09:30.666]     ...future.result$conditions <- ...future.conditions
[16:09:30.666]     ...future.result$finished <- base::Sys.time()
[16:09:30.666]     ...future.result
[16:09:30.666] }
[16:09:30.669] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:09:30.669] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:30.670] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.670] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:09:30.670] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:09:30.670] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[16:09:30.671] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[16:09:30.671] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:30.671] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.671] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:09:30.672] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:09:30.672] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:09:30.672] MultisessionFuture started
[16:09:30.672] - Launch lazy future ... done
[16:09:30.673] run() for ‘MultisessionFuture’ ... done
[16:09:30.673] Created future:
[16:09:30.673] MultisessionFuture:
[16:09:30.673] Label: ‘future_apply-2’
[16:09:30.673] Expression:
[16:09:30.673] {
[16:09:30.673]     do.call(function(...) {
[16:09:30.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.673]             on.exit(options(oopts), add = TRUE)
[16:09:30.673]         }
[16:09:30.673]         {
[16:09:30.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.673]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.673]             })
[16:09:30.673]         }
[16:09:30.673]     }, args = future.call.arguments)
[16:09:30.673] }
[16:09:30.673] Lazy evaluation: FALSE
[16:09:30.673] Asynchronous evaluation: TRUE
[16:09:30.673] Local evaluation: TRUE
[16:09:30.673] Environment: R_GlobalEnv
[16:09:30.673] Capture standard output: TRUE
[16:09:30.673] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.673] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:30.673] Packages: <none>
[16:09:30.673] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.673] Resolved: FALSE
[16:09:30.673] Value: <not collected>
[16:09:30.673] Conditions captured: <none>
[16:09:30.673] Early signaling: FALSE
[16:09:30.673] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.673] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.684] Chunk #2 of 2 ... DONE
[16:09:30.684] Launching 2 futures (chunks) ... DONE
[16:09:30.685] Resolving 2 futures (chunks) ...
[16:09:30.685] resolve() on list ...
[16:09:30.685]  recursive: 0
[16:09:30.685]  length: 2
[16:09:30.685] 
[16:09:30.685] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.685] - Validating connection of MultisessionFuture
[16:09:30.686] - received message: FutureResult
[16:09:30.686] - Received FutureResult
[16:09:30.686] - Erased future from FutureRegistry
[16:09:30.686] result() for ClusterFuture ...
[16:09:30.686] - result already collected: FutureResult
[16:09:30.686] result() for ClusterFuture ... done
[16:09:30.686] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.686] Future #1
[16:09:30.686] result() for ClusterFuture ...
[16:09:30.686] - result already collected: FutureResult
[16:09:30.687] result() for ClusterFuture ... done
[16:09:30.687] result() for ClusterFuture ...
[16:09:30.687] - result already collected: FutureResult
[16:09:30.687] result() for ClusterFuture ... done
[16:09:30.687] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:30.687] - nx: 2
[16:09:30.687] - relay: TRUE
[16:09:30.687] - stdout: TRUE
[16:09:30.687] - signal: TRUE
[16:09:30.687] - resignal: FALSE
[16:09:30.687] - force: TRUE
[16:09:30.688] - relayed: [n=2] FALSE, FALSE
[16:09:30.688] - queued futures: [n=2] FALSE, FALSE
[16:09:30.688]  - until=1
[16:09:30.688]  - relaying element #1
[16:09:30.688] result() for ClusterFuture ...
[16:09:30.688] - result already collected: FutureResult
[16:09:30.688] result() for ClusterFuture ... done
[16:09:30.688] result() for ClusterFuture ...
[16:09:30.688] - result already collected: FutureResult
[16:09:30.688] result() for ClusterFuture ... done
[16:09:30.689] result() for ClusterFuture ...
[16:09:30.689] - result already collected: FutureResult
[16:09:30.689] result() for ClusterFuture ... done
[16:09:30.689] result() for ClusterFuture ...
[16:09:30.689] - result already collected: FutureResult
[16:09:30.689] result() for ClusterFuture ... done
[16:09:30.689] - relayed: [n=2] TRUE, FALSE
[16:09:30.689] - queued futures: [n=2] TRUE, FALSE
[16:09:30.689] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:30.689]  length: 1 (resolved future 1)
[16:09:30.720] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.721] - Validating connection of MultisessionFuture
[16:09:30.721] - received message: FutureResult
[16:09:30.721] - Received FutureResult
[16:09:30.721] - Erased future from FutureRegistry
[16:09:30.721] result() for ClusterFuture ...
[16:09:30.721] - result already collected: FutureResult
[16:09:30.721] result() for ClusterFuture ... done
[16:09:30.721] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.721] Future #2
[16:09:30.721] result() for ClusterFuture ...
[16:09:30.722] - result already collected: FutureResult
[16:09:30.722] result() for ClusterFuture ... done
[16:09:30.722] result() for ClusterFuture ...
[16:09:30.722] - result already collected: FutureResult
[16:09:30.722] result() for ClusterFuture ... done
[16:09:30.722] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:30.722] - nx: 2
[16:09:30.722] - relay: TRUE
[16:09:30.722] - stdout: TRUE
[16:09:30.722] - signal: TRUE
[16:09:30.722] - resignal: FALSE
[16:09:30.723] - force: TRUE
[16:09:30.723] - relayed: [n=2] TRUE, FALSE
[16:09:30.723] - queued futures: [n=2] TRUE, FALSE
[16:09:30.723]  - until=2
[16:09:30.723]  - relaying element #2
[16:09:30.723] result() for ClusterFuture ...
[16:09:30.723] - result already collected: FutureResult
[16:09:30.723] result() for ClusterFuture ... done
[16:09:30.723] result() for ClusterFuture ...
[16:09:30.723] - result already collected: FutureResult
[16:09:30.723] result() for ClusterFuture ... done
[16:09:30.724] result() for ClusterFuture ...
[16:09:30.724] - result already collected: FutureResult
[16:09:30.724] result() for ClusterFuture ... done
[16:09:30.724] result() for ClusterFuture ...
[16:09:30.724] - result already collected: FutureResult
[16:09:30.725] result() for ClusterFuture ... done
[16:09:30.725] - relayed: [n=2] TRUE, TRUE
[16:09:30.725] - queued futures: [n=2] TRUE, TRUE
[16:09:30.725] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:30.725]  length: 0 (resolved future 2)
[16:09:30.725] Relaying remaining futures
[16:09:30.725] signalConditionsASAP(NULL, pos=0) ...
[16:09:30.725] - nx: 2
[16:09:30.725] - relay: TRUE
[16:09:30.725] - stdout: TRUE
[16:09:30.725] - signal: TRUE
[16:09:30.725] - resignal: FALSE
[16:09:30.726] - force: TRUE
[16:09:30.726] - relayed: [n=2] TRUE, TRUE
[16:09:30.726] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:30.726] - relayed: [n=2] TRUE, TRUE
[16:09:30.726] - queued futures: [n=2] TRUE, TRUE
[16:09:30.726] signalConditionsASAP(NULL, pos=0) ... done
[16:09:30.726] resolve() on list ... DONE
[16:09:30.726] result() for ClusterFuture ...
[16:09:30.726] - result already collected: FutureResult
[16:09:30.726] result() for ClusterFuture ... done
[16:09:30.726] result() for ClusterFuture ...
[16:09:30.727] - result already collected: FutureResult
[16:09:30.727] result() for ClusterFuture ... done
[16:09:30.727] result() for ClusterFuture ...
[16:09:30.727] - result already collected: FutureResult
[16:09:30.727] result() for ClusterFuture ... done
[16:09:30.727] result() for ClusterFuture ...
[16:09:30.727] - result already collected: FutureResult
[16:09:30.727] result() for ClusterFuture ... done
[16:09:30.727]  - Number of value chunks collected: 2
[16:09:30.727] Resolving 2 futures (chunks) ... DONE
[16:09:30.727] Reducing values from 2 chunks ...
[16:09:30.728]  - Number of values collected after concatenation: 6
[16:09:30.728]  - Number of values expected: 6
[16:09:30.728] Reducing values from 2 chunks ... DONE
[16:09:30.728] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:09:30.728] getGlobalsAndPackagesXApply() ...
[16:09:30.729]  - future.globals: TRUE
[16:09:30.729] getGlobalsAndPackages() ...
[16:09:30.729] Searching for globals...
[16:09:30.730] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:09:30.730] Searching for globals ... DONE
[16:09:30.730] Resolving globals: FALSE
[16:09:30.731] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:09:30.731] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:09:30.731] - globals: [1] ‘FUN’
[16:09:30.731] 
[16:09:30.731] getGlobalsAndPackages() ... DONE
[16:09:30.731]  - globals found/used: [n=1] ‘FUN’
[16:09:30.731]  - needed namespaces: [n=0] 
[16:09:30.731] Finding globals ... DONE
[16:09:30.732]  - use_args: TRUE
[16:09:30.732]  - Getting '...' globals ...
[16:09:30.732] resolve() on list ...
[16:09:30.732]  recursive: 0
[16:09:30.732]  length: 1
[16:09:30.732]  elements: ‘...’
[16:09:30.732]  length: 0 (resolved future 1)
[16:09:30.733] resolve() on list ... DONE
[16:09:30.733]    - '...' content: [n=0] 
[16:09:30.733] List of 1
[16:09:30.733]  $ ...: list()
[16:09:30.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.733]  - attr(*, "where")=List of 1
[16:09:30.733]   ..$ ...:<environment: 0x5633aa40c9f8> 
[16:09:30.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.733]  - attr(*, "resolved")= logi TRUE
[16:09:30.733]  - attr(*, "total_size")= num NA
[16:09:30.735]  - Getting '...' globals ... DONE
[16:09:30.735] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:30.735] List of 2
[16:09:30.735]  $ ...future.FUN:function (x)  
[16:09:30.735]  $ ...          : list()
[16:09:30.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.735]  - attr(*, "where")=List of 2
[16:09:30.735]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:30.735]   ..$ ...          :<environment: 0x5633aa40c9f8> 
[16:09:30.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.735]  - attr(*, "resolved")= logi FALSE
[16:09:30.735]  - attr(*, "total_size")= num 1768
[16:09:30.738] Packages to be attached in all futures: [n=0] 
[16:09:30.738] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.742] future_lapply() ...
[16:09:30.745] Number of chunks: 2
[16:09:30.745] getGlobalsAndPackagesXApply() ...
[16:09:30.746]  - future.globals: <name-value list> with names ‘list()’
[16:09:30.746]  - use_args: TRUE
[16:09:30.746] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:30.746] List of 2
[16:09:30.746]  $ ...          : list()
[16:09:30.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.746]  $ ...future.FUN:function (x)  
[16:09:30.746]  - attr(*, "where")=List of 2
[16:09:30.746]   ..$ ...          :<environment: 0x5633aa40c9f8> 
[16:09:30.746]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:09:30.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.746]  - attr(*, "resolved")= logi FALSE
[16:09:30.746]  - attr(*, "total_size")= num NA
[16:09:30.749] Packages to be attached in all futures: [n=0] 
[16:09:30.749] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.749] Number of futures (= number of chunks): 2
[16:09:30.749] Launching 2 futures (chunks) ...
[16:09:30.749] Chunk #1 of 2 ...
[16:09:30.749]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:30.749]  - seeds: <none>
[16:09:30.750] getGlobalsAndPackages() ...
[16:09:30.750] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.750] Resolving globals: FALSE
[16:09:30.750] Tweak future expression to call with '...' arguments ...
[16:09:30.750] {
[16:09:30.750]     do.call(function(...) {
[16:09:30.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.750]             on.exit(options(oopts), add = TRUE)
[16:09:30.750]         }
[16:09:30.750]         {
[16:09:30.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.750]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.750]             })
[16:09:30.750]         }
[16:09:30.750]     }, args = future.call.arguments)
[16:09:30.750] }
[16:09:30.750] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.751] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.751] 
[16:09:30.751] getGlobalsAndPackages() ... DONE
[16:09:30.751] run() for ‘Future’ ...
[16:09:30.751] - state: ‘created’
[16:09:30.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.766] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.766]   - Field: ‘node’
[16:09:30.766]   - Field: ‘label’
[16:09:30.766]   - Field: ‘local’
[16:09:30.766]   - Field: ‘owner’
[16:09:30.766]   - Field: ‘envir’
[16:09:30.766]   - Field: ‘workers’
[16:09:30.766]   - Field: ‘packages’
[16:09:30.767]   - Field: ‘gc’
[16:09:30.767]   - Field: ‘conditions’
[16:09:30.767]   - Field: ‘persistent’
[16:09:30.767]   - Field: ‘expr’
[16:09:30.767]   - Field: ‘uuid’
[16:09:30.767]   - Field: ‘seed’
[16:09:30.767]   - Field: ‘version’
[16:09:30.767]   - Field: ‘result’
[16:09:30.767]   - Field: ‘asynchronous’
[16:09:30.767]   - Field: ‘calls’
[16:09:30.767]   - Field: ‘globals’
[16:09:30.768]   - Field: ‘stdout’
[16:09:30.768]   - Field: ‘earlySignal’
[16:09:30.768]   - Field: ‘lazy’
[16:09:30.768]   - Field: ‘state’
[16:09:30.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.768] - Launch lazy future ...
[16:09:30.768] Packages needed by the future expression (n = 0): <none>
[16:09:30.768] Packages needed by future strategies (n = 0): <none>
[16:09:30.769] {
[16:09:30.769]     {
[16:09:30.769]         {
[16:09:30.769]             ...future.startTime <- base::Sys.time()
[16:09:30.769]             {
[16:09:30.769]                 {
[16:09:30.769]                   {
[16:09:30.769]                     {
[16:09:30.769]                       base::local({
[16:09:30.769]                         has_future <- base::requireNamespace("future", 
[16:09:30.769]                           quietly = TRUE)
[16:09:30.769]                         if (has_future) {
[16:09:30.769]                           ns <- base::getNamespace("future")
[16:09:30.769]                           version <- ns[[".package"]][["version"]]
[16:09:30.769]                           if (is.null(version)) 
[16:09:30.769]                             version <- utils::packageVersion("future")
[16:09:30.769]                         }
[16:09:30.769]                         else {
[16:09:30.769]                           version <- NULL
[16:09:30.769]                         }
[16:09:30.769]                         if (!has_future || version < "1.8.0") {
[16:09:30.769]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.769]                             "", base::R.version$version.string), 
[16:09:30.769]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.769]                               "release", "version")], collapse = " "), 
[16:09:30.769]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.769]                             info)
[16:09:30.769]                           info <- base::paste(info, collapse = "; ")
[16:09:30.769]                           if (!has_future) {
[16:09:30.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.769]                               info)
[16:09:30.769]                           }
[16:09:30.769]                           else {
[16:09:30.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.769]                               info, version)
[16:09:30.769]                           }
[16:09:30.769]                           base::stop(msg)
[16:09:30.769]                         }
[16:09:30.769]                       })
[16:09:30.769]                     }
[16:09:30.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.769]                     base::options(mc.cores = 1L)
[16:09:30.769]                   }
[16:09:30.769]                   options(future.plan = NULL)
[16:09:30.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.769]                 }
[16:09:30.769]                 ...future.workdir <- getwd()
[16:09:30.769]             }
[16:09:30.769]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.769]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.769]         }
[16:09:30.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.769]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.769]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.769]             base::names(...future.oldOptions))
[16:09:30.769]     }
[16:09:30.769]     if (FALSE) {
[16:09:30.769]     }
[16:09:30.769]     else {
[16:09:30.769]         if (TRUE) {
[16:09:30.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.769]                 open = "w")
[16:09:30.769]         }
[16:09:30.769]         else {
[16:09:30.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.769]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.769]         }
[16:09:30.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.769]             base::sink(type = "output", split = FALSE)
[16:09:30.769]             base::close(...future.stdout)
[16:09:30.769]         }, add = TRUE)
[16:09:30.769]     }
[16:09:30.769]     ...future.frame <- base::sys.nframe()
[16:09:30.769]     ...future.conditions <- base::list()
[16:09:30.769]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.769]     if (FALSE) {
[16:09:30.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.769]     }
[16:09:30.769]     ...future.result <- base::tryCatch({
[16:09:30.769]         base::withCallingHandlers({
[16:09:30.769]             ...future.value <- base::withVisible(base::local({
[16:09:30.769]                 ...future.makeSendCondition <- local({
[16:09:30.769]                   sendCondition <- NULL
[16:09:30.769]                   function(frame = 1L) {
[16:09:30.769]                     if (is.function(sendCondition)) 
[16:09:30.769]                       return(sendCondition)
[16:09:30.769]                     ns <- getNamespace("parallel")
[16:09:30.769]                     if (exists("sendData", mode = "function", 
[16:09:30.769]                       envir = ns)) {
[16:09:30.769]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.769]                         envir = ns)
[16:09:30.769]                       envir <- sys.frame(frame)
[16:09:30.769]                       master <- NULL
[16:09:30.769]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.769]                         !identical(envir, emptyenv())) {
[16:09:30.769]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.769]                           inherits = FALSE)) {
[16:09:30.769]                           master <- get("master", mode = "list", 
[16:09:30.769]                             envir = envir, inherits = FALSE)
[16:09:30.769]                           if (inherits(master, c("SOCKnode", 
[16:09:30.769]                             "SOCK0node"))) {
[16:09:30.769]                             sendCondition <<- function(cond) {
[16:09:30.769]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.769]                                 success = TRUE)
[16:09:30.769]                               parallel_sendData(master, data)
[16:09:30.769]                             }
[16:09:30.769]                             return(sendCondition)
[16:09:30.769]                           }
[16:09:30.769]                         }
[16:09:30.769]                         frame <- frame + 1L
[16:09:30.769]                         envir <- sys.frame(frame)
[16:09:30.769]                       }
[16:09:30.769]                     }
[16:09:30.769]                     sendCondition <<- function(cond) NULL
[16:09:30.769]                   }
[16:09:30.769]                 })
[16:09:30.769]                 withCallingHandlers({
[16:09:30.769]                   {
[16:09:30.769]                     do.call(function(...) {
[16:09:30.769]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.769]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.769]                         ...future.globals.maxSize)) {
[16:09:30.769]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.769]                         on.exit(options(oopts), add = TRUE)
[16:09:30.769]                       }
[16:09:30.769]                       {
[16:09:30.769]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.769]                           FUN = function(jj) {
[16:09:30.769]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.769]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.769]                           })
[16:09:30.769]                       }
[16:09:30.769]                     }, args = future.call.arguments)
[16:09:30.769]                   }
[16:09:30.769]                 }, immediateCondition = function(cond) {
[16:09:30.769]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.769]                   sendCondition(cond)
[16:09:30.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.769]                   {
[16:09:30.769]                     inherits <- base::inherits
[16:09:30.769]                     invokeRestart <- base::invokeRestart
[16:09:30.769]                     is.null <- base::is.null
[16:09:30.769]                     muffled <- FALSE
[16:09:30.769]                     if (inherits(cond, "message")) {
[16:09:30.769]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.769]                       if (muffled) 
[16:09:30.769]                         invokeRestart("muffleMessage")
[16:09:30.769]                     }
[16:09:30.769]                     else if (inherits(cond, "warning")) {
[16:09:30.769]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.769]                       if (muffled) 
[16:09:30.769]                         invokeRestart("muffleWarning")
[16:09:30.769]                     }
[16:09:30.769]                     else if (inherits(cond, "condition")) {
[16:09:30.769]                       if (!is.null(pattern)) {
[16:09:30.769]                         computeRestarts <- base::computeRestarts
[16:09:30.769]                         grepl <- base::grepl
[16:09:30.769]                         restarts <- computeRestarts(cond)
[16:09:30.769]                         for (restart in restarts) {
[16:09:30.769]                           name <- restart$name
[16:09:30.769]                           if (is.null(name)) 
[16:09:30.769]                             next
[16:09:30.769]                           if (!grepl(pattern, name)) 
[16:09:30.769]                             next
[16:09:30.769]                           invokeRestart(restart)
[16:09:30.769]                           muffled <- TRUE
[16:09:30.769]                           break
[16:09:30.769]                         }
[16:09:30.769]                       }
[16:09:30.769]                     }
[16:09:30.769]                     invisible(muffled)
[16:09:30.769]                   }
[16:09:30.769]                   muffleCondition(cond)
[16:09:30.769]                 })
[16:09:30.769]             }))
[16:09:30.769]             future::FutureResult(value = ...future.value$value, 
[16:09:30.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.769]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.769]                     ...future.globalenv.names))
[16:09:30.769]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.769]         }, condition = base::local({
[16:09:30.769]             c <- base::c
[16:09:30.769]             inherits <- base::inherits
[16:09:30.769]             invokeRestart <- base::invokeRestart
[16:09:30.769]             length <- base::length
[16:09:30.769]             list <- base::list
[16:09:30.769]             seq.int <- base::seq.int
[16:09:30.769]             signalCondition <- base::signalCondition
[16:09:30.769]             sys.calls <- base::sys.calls
[16:09:30.769]             `[[` <- base::`[[`
[16:09:30.769]             `+` <- base::`+`
[16:09:30.769]             `<<-` <- base::`<<-`
[16:09:30.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.769]                   3L)]
[16:09:30.769]             }
[16:09:30.769]             function(cond) {
[16:09:30.769]                 is_error <- inherits(cond, "error")
[16:09:30.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.769]                   NULL)
[16:09:30.769]                 if (is_error) {
[16:09:30.769]                   sessionInformation <- function() {
[16:09:30.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.769]                       search = base::search(), system = base::Sys.info())
[16:09:30.769]                   }
[16:09:30.769]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.769]                     cond$call), session = sessionInformation(), 
[16:09:30.769]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.769]                   signalCondition(cond)
[16:09:30.769]                 }
[16:09:30.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.769]                 "immediateCondition"))) {
[16:09:30.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.769]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.769]                   if (TRUE && !signal) {
[16:09:30.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.769]                     {
[16:09:30.769]                       inherits <- base::inherits
[16:09:30.769]                       invokeRestart <- base::invokeRestart
[16:09:30.769]                       is.null <- base::is.null
[16:09:30.769]                       muffled <- FALSE
[16:09:30.769]                       if (inherits(cond, "message")) {
[16:09:30.769]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.769]                         if (muffled) 
[16:09:30.769]                           invokeRestart("muffleMessage")
[16:09:30.769]                       }
[16:09:30.769]                       else if (inherits(cond, "warning")) {
[16:09:30.769]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.769]                         if (muffled) 
[16:09:30.769]                           invokeRestart("muffleWarning")
[16:09:30.769]                       }
[16:09:30.769]                       else if (inherits(cond, "condition")) {
[16:09:30.769]                         if (!is.null(pattern)) {
[16:09:30.769]                           computeRestarts <- base::computeRestarts
[16:09:30.769]                           grepl <- base::grepl
[16:09:30.769]                           restarts <- computeRestarts(cond)
[16:09:30.769]                           for (restart in restarts) {
[16:09:30.769]                             name <- restart$name
[16:09:30.769]                             if (is.null(name)) 
[16:09:30.769]                               next
[16:09:30.769]                             if (!grepl(pattern, name)) 
[16:09:30.769]                               next
[16:09:30.769]                             invokeRestart(restart)
[16:09:30.769]                             muffled <- TRUE
[16:09:30.769]                             break
[16:09:30.769]                           }
[16:09:30.769]                         }
[16:09:30.769]                       }
[16:09:30.769]                       invisible(muffled)
[16:09:30.769]                     }
[16:09:30.769]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.769]                   }
[16:09:30.769]                 }
[16:09:30.769]                 else {
[16:09:30.769]                   if (TRUE) {
[16:09:30.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.769]                     {
[16:09:30.769]                       inherits <- base::inherits
[16:09:30.769]                       invokeRestart <- base::invokeRestart
[16:09:30.769]                       is.null <- base::is.null
[16:09:30.769]                       muffled <- FALSE
[16:09:30.769]                       if (inherits(cond, "message")) {
[16:09:30.769]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.769]                         if (muffled) 
[16:09:30.769]                           invokeRestart("muffleMessage")
[16:09:30.769]                       }
[16:09:30.769]                       else if (inherits(cond, "warning")) {
[16:09:30.769]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.769]                         if (muffled) 
[16:09:30.769]                           invokeRestart("muffleWarning")
[16:09:30.769]                       }
[16:09:30.769]                       else if (inherits(cond, "condition")) {
[16:09:30.769]                         if (!is.null(pattern)) {
[16:09:30.769]                           computeRestarts <- base::computeRestarts
[16:09:30.769]                           grepl <- base::grepl
[16:09:30.769]                           restarts <- computeRestarts(cond)
[16:09:30.769]                           for (restart in restarts) {
[16:09:30.769]                             name <- restart$name
[16:09:30.769]                             if (is.null(name)) 
[16:09:30.769]                               next
[16:09:30.769]                             if (!grepl(pattern, name)) 
[16:09:30.769]                               next
[16:09:30.769]                             invokeRestart(restart)
[16:09:30.769]                             muffled <- TRUE
[16:09:30.769]                             break
[16:09:30.769]                           }
[16:09:30.769]                         }
[16:09:30.769]                       }
[16:09:30.769]                       invisible(muffled)
[16:09:30.769]                     }
[16:09:30.769]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.769]                   }
[16:09:30.769]                 }
[16:09:30.769]             }
[16:09:30.769]         }))
[16:09:30.769]     }, error = function(ex) {
[16:09:30.769]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.769]                 ...future.rng), started = ...future.startTime, 
[16:09:30.769]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.769]             version = "1.8"), class = "FutureResult")
[16:09:30.769]     }, finally = {
[16:09:30.769]         if (!identical(...future.workdir, getwd())) 
[16:09:30.769]             setwd(...future.workdir)
[16:09:30.769]         {
[16:09:30.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.769]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.769]             }
[16:09:30.769]             base::options(...future.oldOptions)
[16:09:30.769]             if (.Platform$OS.type == "windows") {
[16:09:30.769]                 old_names <- names(...future.oldEnvVars)
[16:09:30.769]                 envs <- base::Sys.getenv()
[16:09:30.769]                 names <- names(envs)
[16:09:30.769]                 common <- intersect(names, old_names)
[16:09:30.769]                 added <- setdiff(names, old_names)
[16:09:30.769]                 removed <- setdiff(old_names, names)
[16:09:30.769]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.769]                   envs[common]]
[16:09:30.769]                 NAMES <- toupper(changed)
[16:09:30.769]                 args <- list()
[16:09:30.769]                 for (kk in seq_along(NAMES)) {
[16:09:30.769]                   name <- changed[[kk]]
[16:09:30.769]                   NAME <- NAMES[[kk]]
[16:09:30.769]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.769]                     next
[16:09:30.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.769]                 }
[16:09:30.769]                 NAMES <- toupper(added)
[16:09:30.769]                 for (kk in seq_along(NAMES)) {
[16:09:30.769]                   name <- added[[kk]]
[16:09:30.769]                   NAME <- NAMES[[kk]]
[16:09:30.769]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.769]                     next
[16:09:30.769]                   args[[name]] <- ""
[16:09:30.769]                 }
[16:09:30.769]                 NAMES <- toupper(removed)
[16:09:30.769]                 for (kk in seq_along(NAMES)) {
[16:09:30.769]                   name <- removed[[kk]]
[16:09:30.769]                   NAME <- NAMES[[kk]]
[16:09:30.769]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.769]                     next
[16:09:30.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.769]                 }
[16:09:30.769]                 if (length(args) > 0) 
[16:09:30.769]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.769]             }
[16:09:30.769]             else {
[16:09:30.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.769]             }
[16:09:30.769]             {
[16:09:30.769]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.769]                   0L) {
[16:09:30.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.769]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.769]                   base::options(opts)
[16:09:30.769]                 }
[16:09:30.769]                 {
[16:09:30.769]                   {
[16:09:30.769]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.769]                     NULL
[16:09:30.769]                   }
[16:09:30.769]                   options(future.plan = NULL)
[16:09:30.769]                   if (is.na(NA_character_)) 
[16:09:30.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.769]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.769]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.769]                     envir = parent.frame()) 
[16:09:30.769]                   {
[16:09:30.769]                     if (is.function(workers)) 
[16:09:30.769]                       workers <- workers()
[16:09:30.769]                     workers <- structure(as.integer(workers), 
[16:09:30.769]                       class = class(workers))
[16:09:30.769]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.769]                       workers >= 1)
[16:09:30.769]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.769]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.769]                     }
[16:09:30.769]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.769]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.769]                       envir = envir)
[16:09:30.769]                     if (!future$lazy) 
[16:09:30.769]                       future <- run(future)
[16:09:30.769]                     invisible(future)
[16:09:30.769]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.769]                 }
[16:09:30.769]             }
[16:09:30.769]         }
[16:09:30.769]     })
[16:09:30.769]     if (TRUE) {
[16:09:30.769]         base::sink(type = "output", split = FALSE)
[16:09:30.769]         if (TRUE) {
[16:09:30.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.769]         }
[16:09:30.769]         else {
[16:09:30.769]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.769]         }
[16:09:30.769]         base::close(...future.stdout)
[16:09:30.769]         ...future.stdout <- NULL
[16:09:30.769]     }
[16:09:30.769]     ...future.result$conditions <- ...future.conditions
[16:09:30.769]     ...future.result$finished <- base::Sys.time()
[16:09:30.769]     ...future.result
[16:09:30.769] }
[16:09:30.772] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[16:09:30.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:30.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.773] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[16:09:30.773] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[16:09:30.773] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[16:09:30.773] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[16:09:30.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:30.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.774] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:09:30.774] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:09:30.774] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[16:09:30.775] MultisessionFuture started
[16:09:30.775] - Launch lazy future ... done
[16:09:30.775] run() for ‘MultisessionFuture’ ... done
[16:09:30.775] Created future:
[16:09:30.775] MultisessionFuture:
[16:09:30.775] Label: ‘future_apply-1’
[16:09:30.775] Expression:
[16:09:30.775] {
[16:09:30.775]     do.call(function(...) {
[16:09:30.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.775]             on.exit(options(oopts), add = TRUE)
[16:09:30.775]         }
[16:09:30.775]         {
[16:09:30.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.775]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.775]             })
[16:09:30.775]         }
[16:09:30.775]     }, args = future.call.arguments)
[16:09:30.775] }
[16:09:30.775] Lazy evaluation: FALSE
[16:09:30.775] Asynchronous evaluation: TRUE
[16:09:30.775] Local evaluation: TRUE
[16:09:30.775] Environment: R_GlobalEnv
[16:09:30.775] Capture standard output: TRUE
[16:09:30.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.775] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:30.775] Packages: <none>
[16:09:30.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.775] Resolved: FALSE
[16:09:30.775] Value: <not collected>
[16:09:30.775] Conditions captured: <none>
[16:09:30.775] Early signaling: FALSE
[16:09:30.775] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.775] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.787] Chunk #1 of 2 ... DONE
[16:09:30.787] Chunk #2 of 2 ...
[16:09:30.787]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[16:09:30.787]  - seeds: <none>
[16:09:30.787] getGlobalsAndPackages() ...
[16:09:30.787] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.787] Resolving globals: FALSE
[16:09:30.787] Tweak future expression to call with '...' arguments ...
[16:09:30.788] {
[16:09:30.788]     do.call(function(...) {
[16:09:30.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.788]             on.exit(options(oopts), add = TRUE)
[16:09:30.788]         }
[16:09:30.788]         {
[16:09:30.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.788]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.788]             })
[16:09:30.788]         }
[16:09:30.788]     }, args = future.call.arguments)
[16:09:30.788] }
[16:09:30.788] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.788] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.788] 
[16:09:30.788] getGlobalsAndPackages() ... DONE
[16:09:30.789] run() for ‘Future’ ...
[16:09:30.789] - state: ‘created’
[16:09:30.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.803]   - Field: ‘node’
[16:09:30.803]   - Field: ‘label’
[16:09:30.803]   - Field: ‘local’
[16:09:30.803]   - Field: ‘owner’
[16:09:30.803]   - Field: ‘envir’
[16:09:30.803]   - Field: ‘workers’
[16:09:30.804]   - Field: ‘packages’
[16:09:30.804]   - Field: ‘gc’
[16:09:30.804]   - Field: ‘conditions’
[16:09:30.804]   - Field: ‘persistent’
[16:09:30.804]   - Field: ‘expr’
[16:09:30.804]   - Field: ‘uuid’
[16:09:30.804]   - Field: ‘seed’
[16:09:30.804]   - Field: ‘version’
[16:09:30.804]   - Field: ‘result’
[16:09:30.804]   - Field: ‘asynchronous’
[16:09:30.804]   - Field: ‘calls’
[16:09:30.805]   - Field: ‘globals’
[16:09:30.805]   - Field: ‘stdout’
[16:09:30.805]   - Field: ‘earlySignal’
[16:09:30.805]   - Field: ‘lazy’
[16:09:30.805]   - Field: ‘state’
[16:09:30.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.805] - Launch lazy future ...
[16:09:30.805] Packages needed by the future expression (n = 0): <none>
[16:09:30.805] Packages needed by future strategies (n = 0): <none>
[16:09:30.806] {
[16:09:30.806]     {
[16:09:30.806]         {
[16:09:30.806]             ...future.startTime <- base::Sys.time()
[16:09:30.806]             {
[16:09:30.806]                 {
[16:09:30.806]                   {
[16:09:30.806]                     {
[16:09:30.806]                       base::local({
[16:09:30.806]                         has_future <- base::requireNamespace("future", 
[16:09:30.806]                           quietly = TRUE)
[16:09:30.806]                         if (has_future) {
[16:09:30.806]                           ns <- base::getNamespace("future")
[16:09:30.806]                           version <- ns[[".package"]][["version"]]
[16:09:30.806]                           if (is.null(version)) 
[16:09:30.806]                             version <- utils::packageVersion("future")
[16:09:30.806]                         }
[16:09:30.806]                         else {
[16:09:30.806]                           version <- NULL
[16:09:30.806]                         }
[16:09:30.806]                         if (!has_future || version < "1.8.0") {
[16:09:30.806]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.806]                             "", base::R.version$version.string), 
[16:09:30.806]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.806]                               "release", "version")], collapse = " "), 
[16:09:30.806]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.806]                             info)
[16:09:30.806]                           info <- base::paste(info, collapse = "; ")
[16:09:30.806]                           if (!has_future) {
[16:09:30.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.806]                               info)
[16:09:30.806]                           }
[16:09:30.806]                           else {
[16:09:30.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.806]                               info, version)
[16:09:30.806]                           }
[16:09:30.806]                           base::stop(msg)
[16:09:30.806]                         }
[16:09:30.806]                       })
[16:09:30.806]                     }
[16:09:30.806]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.806]                     base::options(mc.cores = 1L)
[16:09:30.806]                   }
[16:09:30.806]                   options(future.plan = NULL)
[16:09:30.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.806]                 }
[16:09:30.806]                 ...future.workdir <- getwd()
[16:09:30.806]             }
[16:09:30.806]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.806]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.806]         }
[16:09:30.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.806]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.806]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.806]             base::names(...future.oldOptions))
[16:09:30.806]     }
[16:09:30.806]     if (FALSE) {
[16:09:30.806]     }
[16:09:30.806]     else {
[16:09:30.806]         if (TRUE) {
[16:09:30.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.806]                 open = "w")
[16:09:30.806]         }
[16:09:30.806]         else {
[16:09:30.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.806]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.806]         }
[16:09:30.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.806]             base::sink(type = "output", split = FALSE)
[16:09:30.806]             base::close(...future.stdout)
[16:09:30.806]         }, add = TRUE)
[16:09:30.806]     }
[16:09:30.806]     ...future.frame <- base::sys.nframe()
[16:09:30.806]     ...future.conditions <- base::list()
[16:09:30.806]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.806]     if (FALSE) {
[16:09:30.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.806]     }
[16:09:30.806]     ...future.result <- base::tryCatch({
[16:09:30.806]         base::withCallingHandlers({
[16:09:30.806]             ...future.value <- base::withVisible(base::local({
[16:09:30.806]                 ...future.makeSendCondition <- local({
[16:09:30.806]                   sendCondition <- NULL
[16:09:30.806]                   function(frame = 1L) {
[16:09:30.806]                     if (is.function(sendCondition)) 
[16:09:30.806]                       return(sendCondition)
[16:09:30.806]                     ns <- getNamespace("parallel")
[16:09:30.806]                     if (exists("sendData", mode = "function", 
[16:09:30.806]                       envir = ns)) {
[16:09:30.806]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.806]                         envir = ns)
[16:09:30.806]                       envir <- sys.frame(frame)
[16:09:30.806]                       master <- NULL
[16:09:30.806]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.806]                         !identical(envir, emptyenv())) {
[16:09:30.806]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.806]                           inherits = FALSE)) {
[16:09:30.806]                           master <- get("master", mode = "list", 
[16:09:30.806]                             envir = envir, inherits = FALSE)
[16:09:30.806]                           if (inherits(master, c("SOCKnode", 
[16:09:30.806]                             "SOCK0node"))) {
[16:09:30.806]                             sendCondition <<- function(cond) {
[16:09:30.806]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.806]                                 success = TRUE)
[16:09:30.806]                               parallel_sendData(master, data)
[16:09:30.806]                             }
[16:09:30.806]                             return(sendCondition)
[16:09:30.806]                           }
[16:09:30.806]                         }
[16:09:30.806]                         frame <- frame + 1L
[16:09:30.806]                         envir <- sys.frame(frame)
[16:09:30.806]                       }
[16:09:30.806]                     }
[16:09:30.806]                     sendCondition <<- function(cond) NULL
[16:09:30.806]                   }
[16:09:30.806]                 })
[16:09:30.806]                 withCallingHandlers({
[16:09:30.806]                   {
[16:09:30.806]                     do.call(function(...) {
[16:09:30.806]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.806]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.806]                         ...future.globals.maxSize)) {
[16:09:30.806]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.806]                         on.exit(options(oopts), add = TRUE)
[16:09:30.806]                       }
[16:09:30.806]                       {
[16:09:30.806]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.806]                           FUN = function(jj) {
[16:09:30.806]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.806]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.806]                           })
[16:09:30.806]                       }
[16:09:30.806]                     }, args = future.call.arguments)
[16:09:30.806]                   }
[16:09:30.806]                 }, immediateCondition = function(cond) {
[16:09:30.806]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.806]                   sendCondition(cond)
[16:09:30.806]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.806]                   {
[16:09:30.806]                     inherits <- base::inherits
[16:09:30.806]                     invokeRestart <- base::invokeRestart
[16:09:30.806]                     is.null <- base::is.null
[16:09:30.806]                     muffled <- FALSE
[16:09:30.806]                     if (inherits(cond, "message")) {
[16:09:30.806]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.806]                       if (muffled) 
[16:09:30.806]                         invokeRestart("muffleMessage")
[16:09:30.806]                     }
[16:09:30.806]                     else if (inherits(cond, "warning")) {
[16:09:30.806]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.806]                       if (muffled) 
[16:09:30.806]                         invokeRestart("muffleWarning")
[16:09:30.806]                     }
[16:09:30.806]                     else if (inherits(cond, "condition")) {
[16:09:30.806]                       if (!is.null(pattern)) {
[16:09:30.806]                         computeRestarts <- base::computeRestarts
[16:09:30.806]                         grepl <- base::grepl
[16:09:30.806]                         restarts <- computeRestarts(cond)
[16:09:30.806]                         for (restart in restarts) {
[16:09:30.806]                           name <- restart$name
[16:09:30.806]                           if (is.null(name)) 
[16:09:30.806]                             next
[16:09:30.806]                           if (!grepl(pattern, name)) 
[16:09:30.806]                             next
[16:09:30.806]                           invokeRestart(restart)
[16:09:30.806]                           muffled <- TRUE
[16:09:30.806]                           break
[16:09:30.806]                         }
[16:09:30.806]                       }
[16:09:30.806]                     }
[16:09:30.806]                     invisible(muffled)
[16:09:30.806]                   }
[16:09:30.806]                   muffleCondition(cond)
[16:09:30.806]                 })
[16:09:30.806]             }))
[16:09:30.806]             future::FutureResult(value = ...future.value$value, 
[16:09:30.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.806]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.806]                     ...future.globalenv.names))
[16:09:30.806]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.806]         }, condition = base::local({
[16:09:30.806]             c <- base::c
[16:09:30.806]             inherits <- base::inherits
[16:09:30.806]             invokeRestart <- base::invokeRestart
[16:09:30.806]             length <- base::length
[16:09:30.806]             list <- base::list
[16:09:30.806]             seq.int <- base::seq.int
[16:09:30.806]             signalCondition <- base::signalCondition
[16:09:30.806]             sys.calls <- base::sys.calls
[16:09:30.806]             `[[` <- base::`[[`
[16:09:30.806]             `+` <- base::`+`
[16:09:30.806]             `<<-` <- base::`<<-`
[16:09:30.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.806]                   3L)]
[16:09:30.806]             }
[16:09:30.806]             function(cond) {
[16:09:30.806]                 is_error <- inherits(cond, "error")
[16:09:30.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.806]                   NULL)
[16:09:30.806]                 if (is_error) {
[16:09:30.806]                   sessionInformation <- function() {
[16:09:30.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.806]                       search = base::search(), system = base::Sys.info())
[16:09:30.806]                   }
[16:09:30.806]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.806]                     cond$call), session = sessionInformation(), 
[16:09:30.806]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.806]                   signalCondition(cond)
[16:09:30.806]                 }
[16:09:30.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.806]                 "immediateCondition"))) {
[16:09:30.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.806]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.806]                   if (TRUE && !signal) {
[16:09:30.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.806]                     {
[16:09:30.806]                       inherits <- base::inherits
[16:09:30.806]                       invokeRestart <- base::invokeRestart
[16:09:30.806]                       is.null <- base::is.null
[16:09:30.806]                       muffled <- FALSE
[16:09:30.806]                       if (inherits(cond, "message")) {
[16:09:30.806]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.806]                         if (muffled) 
[16:09:30.806]                           invokeRestart("muffleMessage")
[16:09:30.806]                       }
[16:09:30.806]                       else if (inherits(cond, "warning")) {
[16:09:30.806]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.806]                         if (muffled) 
[16:09:30.806]                           invokeRestart("muffleWarning")
[16:09:30.806]                       }
[16:09:30.806]                       else if (inherits(cond, "condition")) {
[16:09:30.806]                         if (!is.null(pattern)) {
[16:09:30.806]                           computeRestarts <- base::computeRestarts
[16:09:30.806]                           grepl <- base::grepl
[16:09:30.806]                           restarts <- computeRestarts(cond)
[16:09:30.806]                           for (restart in restarts) {
[16:09:30.806]                             name <- restart$name
[16:09:30.806]                             if (is.null(name)) 
[16:09:30.806]                               next
[16:09:30.806]                             if (!grepl(pattern, name)) 
[16:09:30.806]                               next
[16:09:30.806]                             invokeRestart(restart)
[16:09:30.806]                             muffled <- TRUE
[16:09:30.806]                             break
[16:09:30.806]                           }
[16:09:30.806]                         }
[16:09:30.806]                       }
[16:09:30.806]                       invisible(muffled)
[16:09:30.806]                     }
[16:09:30.806]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.806]                   }
[16:09:30.806]                 }
[16:09:30.806]                 else {
[16:09:30.806]                   if (TRUE) {
[16:09:30.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.806]                     {
[16:09:30.806]                       inherits <- base::inherits
[16:09:30.806]                       invokeRestart <- base::invokeRestart
[16:09:30.806]                       is.null <- base::is.null
[16:09:30.806]                       muffled <- FALSE
[16:09:30.806]                       if (inherits(cond, "message")) {
[16:09:30.806]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.806]                         if (muffled) 
[16:09:30.806]                           invokeRestart("muffleMessage")
[16:09:30.806]                       }
[16:09:30.806]                       else if (inherits(cond, "warning")) {
[16:09:30.806]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.806]                         if (muffled) 
[16:09:30.806]                           invokeRestart("muffleWarning")
[16:09:30.806]                       }
[16:09:30.806]                       else if (inherits(cond, "condition")) {
[16:09:30.806]                         if (!is.null(pattern)) {
[16:09:30.806]                           computeRestarts <- base::computeRestarts
[16:09:30.806]                           grepl <- base::grepl
[16:09:30.806]                           restarts <- computeRestarts(cond)
[16:09:30.806]                           for (restart in restarts) {
[16:09:30.806]                             name <- restart$name
[16:09:30.806]                             if (is.null(name)) 
[16:09:30.806]                               next
[16:09:30.806]                             if (!grepl(pattern, name)) 
[16:09:30.806]                               next
[16:09:30.806]                             invokeRestart(restart)
[16:09:30.806]                             muffled <- TRUE
[16:09:30.806]                             break
[16:09:30.806]                           }
[16:09:30.806]                         }
[16:09:30.806]                       }
[16:09:30.806]                       invisible(muffled)
[16:09:30.806]                     }
[16:09:30.806]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.806]                   }
[16:09:30.806]                 }
[16:09:30.806]             }
[16:09:30.806]         }))
[16:09:30.806]     }, error = function(ex) {
[16:09:30.806]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.806]                 ...future.rng), started = ...future.startTime, 
[16:09:30.806]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.806]             version = "1.8"), class = "FutureResult")
[16:09:30.806]     }, finally = {
[16:09:30.806]         if (!identical(...future.workdir, getwd())) 
[16:09:30.806]             setwd(...future.workdir)
[16:09:30.806]         {
[16:09:30.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.806]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.806]             }
[16:09:30.806]             base::options(...future.oldOptions)
[16:09:30.806]             if (.Platform$OS.type == "windows") {
[16:09:30.806]                 old_names <- names(...future.oldEnvVars)
[16:09:30.806]                 envs <- base::Sys.getenv()
[16:09:30.806]                 names <- names(envs)
[16:09:30.806]                 common <- intersect(names, old_names)
[16:09:30.806]                 added <- setdiff(names, old_names)
[16:09:30.806]                 removed <- setdiff(old_names, names)
[16:09:30.806]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.806]                   envs[common]]
[16:09:30.806]                 NAMES <- toupper(changed)
[16:09:30.806]                 args <- list()
[16:09:30.806]                 for (kk in seq_along(NAMES)) {
[16:09:30.806]                   name <- changed[[kk]]
[16:09:30.806]                   NAME <- NAMES[[kk]]
[16:09:30.806]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.806]                     next
[16:09:30.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.806]                 }
[16:09:30.806]                 NAMES <- toupper(added)
[16:09:30.806]                 for (kk in seq_along(NAMES)) {
[16:09:30.806]                   name <- added[[kk]]
[16:09:30.806]                   NAME <- NAMES[[kk]]
[16:09:30.806]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.806]                     next
[16:09:30.806]                   args[[name]] <- ""
[16:09:30.806]                 }
[16:09:30.806]                 NAMES <- toupper(removed)
[16:09:30.806]                 for (kk in seq_along(NAMES)) {
[16:09:30.806]                   name <- removed[[kk]]
[16:09:30.806]                   NAME <- NAMES[[kk]]
[16:09:30.806]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.806]                     next
[16:09:30.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.806]                 }
[16:09:30.806]                 if (length(args) > 0) 
[16:09:30.806]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.806]             }
[16:09:30.806]             else {
[16:09:30.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.806]             }
[16:09:30.806]             {
[16:09:30.806]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.806]                   0L) {
[16:09:30.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.806]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.806]                   base::options(opts)
[16:09:30.806]                 }
[16:09:30.806]                 {
[16:09:30.806]                   {
[16:09:30.806]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.806]                     NULL
[16:09:30.806]                   }
[16:09:30.806]                   options(future.plan = NULL)
[16:09:30.806]                   if (is.na(NA_character_)) 
[16:09:30.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.806]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.806]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.806]                     envir = parent.frame()) 
[16:09:30.806]                   {
[16:09:30.806]                     if (is.function(workers)) 
[16:09:30.806]                       workers <- workers()
[16:09:30.806]                     workers <- structure(as.integer(workers), 
[16:09:30.806]                       class = class(workers))
[16:09:30.806]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.806]                       workers >= 1)
[16:09:30.806]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.806]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.806]                     }
[16:09:30.806]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.806]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.806]                       envir = envir)
[16:09:30.806]                     if (!future$lazy) 
[16:09:30.806]                       future <- run(future)
[16:09:30.806]                     invisible(future)
[16:09:30.806]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.806]                 }
[16:09:30.806]             }
[16:09:30.806]         }
[16:09:30.806]     })
[16:09:30.806]     if (TRUE) {
[16:09:30.806]         base::sink(type = "output", split = FALSE)
[16:09:30.806]         if (TRUE) {
[16:09:30.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.806]         }
[16:09:30.806]         else {
[16:09:30.806]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.806]         }
[16:09:30.806]         base::close(...future.stdout)
[16:09:30.806]         ...future.stdout <- NULL
[16:09:30.806]     }
[16:09:30.806]     ...future.result$conditions <- ...future.conditions
[16:09:30.806]     ...future.result$finished <- base::Sys.time()
[16:09:30.806]     ...future.result
[16:09:30.806] }
[16:09:30.809] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[16:09:30.809] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:30.809] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.810] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[16:09:30.810] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[16:09:30.810] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[16:09:30.811] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[16:09:30.811] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:30.811] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.811] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:09:30.812] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:09:30.812] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[16:09:30.812] MultisessionFuture started
[16:09:30.812] - Launch lazy future ... done
[16:09:30.813] run() for ‘MultisessionFuture’ ... done
[16:09:30.813] Created future:
[16:09:30.813] MultisessionFuture:
[16:09:30.813] Label: ‘future_apply-2’
[16:09:30.813] Expression:
[16:09:30.813] {
[16:09:30.813]     do.call(function(...) {
[16:09:30.813]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.813]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.813]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.813]             on.exit(options(oopts), add = TRUE)
[16:09:30.813]         }
[16:09:30.813]         {
[16:09:30.813]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.813]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.813]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.813]             })
[16:09:30.813]         }
[16:09:30.813]     }, args = future.call.arguments)
[16:09:30.813] }
[16:09:30.813] Lazy evaluation: FALSE
[16:09:30.813] Asynchronous evaluation: TRUE
[16:09:30.813] Local evaluation: TRUE
[16:09:30.813] Environment: R_GlobalEnv
[16:09:30.813] Capture standard output: TRUE
[16:09:30.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.813] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:09:30.813] Packages: <none>
[16:09:30.813] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.813] Resolved: FALSE
[16:09:30.813] Value: <not collected>
[16:09:30.813] Conditions captured: <none>
[16:09:30.813] Early signaling: FALSE
[16:09:30.813] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.813] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.824] Chunk #2 of 2 ... DONE
[16:09:30.824] Launching 2 futures (chunks) ... DONE
[16:09:30.825] Resolving 2 futures (chunks) ...
[16:09:30.825] resolve() on list ...
[16:09:30.825]  recursive: 0
[16:09:30.825]  length: 2
[16:09:30.825] 
[16:09:30.825] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.825] - Validating connection of MultisessionFuture
[16:09:30.826] - received message: FutureResult
[16:09:30.826] - Received FutureResult
[16:09:30.826] - Erased future from FutureRegistry
[16:09:30.826] result() for ClusterFuture ...
[16:09:30.826] - result already collected: FutureResult
[16:09:30.826] result() for ClusterFuture ... done
[16:09:30.826] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.826] Future #1
[16:09:30.826] result() for ClusterFuture ...
[16:09:30.826] - result already collected: FutureResult
[16:09:30.827] result() for ClusterFuture ... done
[16:09:30.827] result() for ClusterFuture ...
[16:09:30.827] - result already collected: FutureResult
[16:09:30.827] result() for ClusterFuture ... done
[16:09:30.827] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:30.827] - nx: 2
[16:09:30.827] - relay: TRUE
[16:09:30.827] - stdout: TRUE
[16:09:30.827] - signal: TRUE
[16:09:30.827] - resignal: FALSE
[16:09:30.827] - force: TRUE
[16:09:30.827] - relayed: [n=2] FALSE, FALSE
[16:09:30.828] - queued futures: [n=2] FALSE, FALSE
[16:09:30.828]  - until=1
[16:09:30.828]  - relaying element #1
[16:09:30.828] result() for ClusterFuture ...
[16:09:30.828] - result already collected: FutureResult
[16:09:30.828] result() for ClusterFuture ... done
[16:09:30.828] result() for ClusterFuture ...
[16:09:30.828] - result already collected: FutureResult
[16:09:30.828] result() for ClusterFuture ... done
[16:09:30.828] result() for ClusterFuture ...
[16:09:30.829] - result already collected: FutureResult
[16:09:30.829] result() for ClusterFuture ... done
[16:09:30.829] result() for ClusterFuture ...
[16:09:30.829] - result already collected: FutureResult
[16:09:30.829] result() for ClusterFuture ... done
[16:09:30.829] - relayed: [n=2] TRUE, FALSE
[16:09:30.829] - queued futures: [n=2] TRUE, FALSE
[16:09:30.829] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:30.829]  length: 1 (resolved future 1)
[16:09:30.860] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.860] - Validating connection of MultisessionFuture
[16:09:30.861] - received message: FutureResult
[16:09:30.861] - Received FutureResult
[16:09:30.861] - Erased future from FutureRegistry
[16:09:30.861] result() for ClusterFuture ...
[16:09:30.861] - result already collected: FutureResult
[16:09:30.861] result() for ClusterFuture ... done
[16:09:30.861] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.861] Future #2
[16:09:30.861] result() for ClusterFuture ...
[16:09:30.861] - result already collected: FutureResult
[16:09:30.862] result() for ClusterFuture ... done
[16:09:30.862] result() for ClusterFuture ...
[16:09:30.862] - result already collected: FutureResult
[16:09:30.862] result() for ClusterFuture ... done
[16:09:30.862] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:30.862] - nx: 2
[16:09:30.862] - relay: TRUE
[16:09:30.862] - stdout: TRUE
[16:09:30.862] - signal: TRUE
[16:09:30.862] - resignal: FALSE
[16:09:30.862] - force: TRUE
[16:09:30.862] - relayed: [n=2] TRUE, FALSE
[16:09:30.863] - queued futures: [n=2] TRUE, FALSE
[16:09:30.863]  - until=2
[16:09:30.863]  - relaying element #2
[16:09:30.863] result() for ClusterFuture ...
[16:09:30.865] - result already collected: FutureResult
[16:09:30.865] result() for ClusterFuture ... done
[16:09:30.865] result() for ClusterFuture ...
[16:09:30.865] - result already collected: FutureResult
[16:09:30.865] result() for ClusterFuture ... done
[16:09:30.866] result() for ClusterFuture ...
[16:09:30.866] - result already collected: FutureResult
[16:09:30.866] result() for ClusterFuture ... done
[16:09:30.866] result() for ClusterFuture ...
[16:09:30.866] - result already collected: FutureResult
[16:09:30.866] result() for ClusterFuture ... done
[16:09:30.866] - relayed: [n=2] TRUE, TRUE
[16:09:30.866] - queued futures: [n=2] TRUE, TRUE
[16:09:30.866] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:30.866]  length: 0 (resolved future 2)
[16:09:30.867] Relaying remaining futures
[16:09:30.867] signalConditionsASAP(NULL, pos=0) ...
[16:09:30.867] - nx: 2
[16:09:30.867] - relay: TRUE
[16:09:30.867] - stdout: TRUE
[16:09:30.867] - signal: TRUE
[16:09:30.867] - resignal: FALSE
[16:09:30.867] - force: TRUE
[16:09:30.867] - relayed: [n=2] TRUE, TRUE
[16:09:30.867] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:30.867] - relayed: [n=2] TRUE, TRUE
[16:09:30.867] - queued futures: [n=2] TRUE, TRUE
[16:09:30.868] signalConditionsASAP(NULL, pos=0) ... done
[16:09:30.868] resolve() on list ... DONE
[16:09:30.868] result() for ClusterFuture ...
[16:09:30.868] - result already collected: FutureResult
[16:09:30.868] result() for ClusterFuture ... done
[16:09:30.868] result() for ClusterFuture ...
[16:09:30.868] - result already collected: FutureResult
[16:09:30.868] result() for ClusterFuture ... done
[16:09:30.868] result() for ClusterFuture ...
[16:09:30.868] - result already collected: FutureResult
[16:09:30.868] result() for ClusterFuture ... done
[16:09:30.869] result() for ClusterFuture ...
[16:09:30.869] - result already collected: FutureResult
[16:09:30.869] result() for ClusterFuture ... done
[16:09:30.869]  - Number of value chunks collected: 2
[16:09:30.869] Resolving 2 futures (chunks) ... DONE
[16:09:30.869] Reducing values from 2 chunks ...
[16:09:30.869]  - Number of values collected after concatenation: 6
[16:09:30.869]  - Number of values expected: 6
[16:09:30.869] Reducing values from 2 chunks ... DONE
[16:09:30.869] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:09:30.870] getGlobalsAndPackagesXApply() ...
[16:09:30.870]  - future.globals: TRUE
[16:09:30.870] getGlobalsAndPackages() ...
[16:09:30.870] Searching for globals...
[16:09:30.871] - globals found: [1] ‘FUN’
[16:09:30.871] Searching for globals ... DONE
[16:09:30.871] Resolving globals: FALSE
[16:09:30.872] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:30.872] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:30.872] - globals: [1] ‘FUN’
[16:09:30.872] 
[16:09:30.872] getGlobalsAndPackages() ... DONE
[16:09:30.872]  - globals found/used: [n=1] ‘FUN’
[16:09:30.872]  - needed namespaces: [n=0] 
[16:09:30.873] Finding globals ... DONE
[16:09:30.873]  - use_args: TRUE
[16:09:30.873]  - Getting '...' globals ...
[16:09:30.873] resolve() on list ...
[16:09:30.873]  recursive: 0
[16:09:30.873]  length: 1
[16:09:30.873]  elements: ‘...’
[16:09:30.873]  length: 0 (resolved future 1)
[16:09:30.873] resolve() on list ... DONE
[16:09:30.874]    - '...' content: [n=0] 
[16:09:30.874] List of 1
[16:09:30.874]  $ ...: list()
[16:09:30.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.874]  - attr(*, "where")=List of 1
[16:09:30.874]   ..$ ...:<environment: 0x5633acaefa38> 
[16:09:30.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.874]  - attr(*, "resolved")= logi TRUE
[16:09:30.874]  - attr(*, "total_size")= num NA
[16:09:30.876]  - Getting '...' globals ... DONE
[16:09:30.876] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:30.876] List of 2
[16:09:30.876]  $ ...future.FUN:function (x)  
[16:09:30.876]  $ ...          : list()
[16:09:30.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.876]  - attr(*, "where")=List of 2
[16:09:30.876]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:30.876]   ..$ ...          :<environment: 0x5633acaefa38> 
[16:09:30.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.876]  - attr(*, "resolved")= logi FALSE
[16:09:30.876]  - attr(*, "total_size")= num 848
[16:09:30.879] Packages to be attached in all futures: [n=0] 
[16:09:30.879] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.883] future_lapply() ...
[16:09:30.886] Number of chunks: 2
[16:09:30.887] getGlobalsAndPackagesXApply() ...
[16:09:30.887]  - future.globals: <name-value list> with names ‘list()’
[16:09:30.887]  - use_args: TRUE
[16:09:30.887] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:30.887] List of 2
[16:09:30.887]  $ ...          : list()
[16:09:30.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:30.887]  $ ...future.FUN:function (x)  
[16:09:30.887]  - attr(*, "where")=List of 2
[16:09:30.887]   ..$ ...          :<environment: 0x5633acaefa38> 
[16:09:30.887]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:30.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:30.887]  - attr(*, "resolved")= logi FALSE
[16:09:30.887]  - attr(*, "total_size")= num NA
[16:09:30.891] Packages to be attached in all futures: [n=0] 
[16:09:30.891] getGlobalsAndPackagesXApply() ... DONE
[16:09:30.891] Number of futures (= number of chunks): 2
[16:09:30.891] Launching 2 futures (chunks) ...
[16:09:30.892] Chunk #1 of 2 ...
[16:09:30.892]  - seeds: <none>
[16:09:30.892] getGlobalsAndPackages() ...
[16:09:30.892] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.892] Resolving globals: FALSE
[16:09:30.892] Tweak future expression to call with '...' arguments ...
[16:09:30.892] {
[16:09:30.892]     do.call(function(...) {
[16:09:30.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.892]             on.exit(options(oopts), add = TRUE)
[16:09:30.892]         }
[16:09:30.892]         {
[16:09:30.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.892]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.892]             })
[16:09:30.892]         }
[16:09:30.892]     }, args = future.call.arguments)
[16:09:30.892] }
[16:09:30.893] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.893] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.893] 
[16:09:30.893] getGlobalsAndPackages() ... DONE
[16:09:30.893] run() for ‘Future’ ...
[16:09:30.894] - state: ‘created’
[16:09:30.894] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.909] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.909]   - Field: ‘node’
[16:09:30.909]   - Field: ‘label’
[16:09:30.909]   - Field: ‘local’
[16:09:30.909]   - Field: ‘owner’
[16:09:30.909]   - Field: ‘envir’
[16:09:30.910]   - Field: ‘workers’
[16:09:30.910]   - Field: ‘packages’
[16:09:30.910]   - Field: ‘gc’
[16:09:30.910]   - Field: ‘conditions’
[16:09:30.910]   - Field: ‘persistent’
[16:09:30.910]   - Field: ‘expr’
[16:09:30.910]   - Field: ‘uuid’
[16:09:30.910]   - Field: ‘seed’
[16:09:30.910]   - Field: ‘version’
[16:09:30.910]   - Field: ‘result’
[16:09:30.911]   - Field: ‘asynchronous’
[16:09:30.911]   - Field: ‘calls’
[16:09:30.911]   - Field: ‘globals’
[16:09:30.911]   - Field: ‘stdout’
[16:09:30.911]   - Field: ‘earlySignal’
[16:09:30.911]   - Field: ‘lazy’
[16:09:30.911]   - Field: ‘state’
[16:09:30.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.911] - Launch lazy future ...
[16:09:30.912] Packages needed by the future expression (n = 0): <none>
[16:09:30.912] Packages needed by future strategies (n = 0): <none>
[16:09:30.912] {
[16:09:30.912]     {
[16:09:30.912]         {
[16:09:30.912]             ...future.startTime <- base::Sys.time()
[16:09:30.912]             {
[16:09:30.912]                 {
[16:09:30.912]                   {
[16:09:30.912]                     {
[16:09:30.912]                       base::local({
[16:09:30.912]                         has_future <- base::requireNamespace("future", 
[16:09:30.912]                           quietly = TRUE)
[16:09:30.912]                         if (has_future) {
[16:09:30.912]                           ns <- base::getNamespace("future")
[16:09:30.912]                           version <- ns[[".package"]][["version"]]
[16:09:30.912]                           if (is.null(version)) 
[16:09:30.912]                             version <- utils::packageVersion("future")
[16:09:30.912]                         }
[16:09:30.912]                         else {
[16:09:30.912]                           version <- NULL
[16:09:30.912]                         }
[16:09:30.912]                         if (!has_future || version < "1.8.0") {
[16:09:30.912]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.912]                             "", base::R.version$version.string), 
[16:09:30.912]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.912]                               "release", "version")], collapse = " "), 
[16:09:30.912]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.912]                             info)
[16:09:30.912]                           info <- base::paste(info, collapse = "; ")
[16:09:30.912]                           if (!has_future) {
[16:09:30.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.912]                               info)
[16:09:30.912]                           }
[16:09:30.912]                           else {
[16:09:30.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.912]                               info, version)
[16:09:30.912]                           }
[16:09:30.912]                           base::stop(msg)
[16:09:30.912]                         }
[16:09:30.912]                       })
[16:09:30.912]                     }
[16:09:30.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.912]                     base::options(mc.cores = 1L)
[16:09:30.912]                   }
[16:09:30.912]                   options(future.plan = NULL)
[16:09:30.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.912]                 }
[16:09:30.912]                 ...future.workdir <- getwd()
[16:09:30.912]             }
[16:09:30.912]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.912]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.912]         }
[16:09:30.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.912]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.912]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.912]             base::names(...future.oldOptions))
[16:09:30.912]     }
[16:09:30.912]     if (FALSE) {
[16:09:30.912]     }
[16:09:30.912]     else {
[16:09:30.912]         if (TRUE) {
[16:09:30.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.912]                 open = "w")
[16:09:30.912]         }
[16:09:30.912]         else {
[16:09:30.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.912]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.912]         }
[16:09:30.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.912]             base::sink(type = "output", split = FALSE)
[16:09:30.912]             base::close(...future.stdout)
[16:09:30.912]         }, add = TRUE)
[16:09:30.912]     }
[16:09:30.912]     ...future.frame <- base::sys.nframe()
[16:09:30.912]     ...future.conditions <- base::list()
[16:09:30.912]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.912]     if (FALSE) {
[16:09:30.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.912]     }
[16:09:30.912]     ...future.result <- base::tryCatch({
[16:09:30.912]         base::withCallingHandlers({
[16:09:30.912]             ...future.value <- base::withVisible(base::local({
[16:09:30.912]                 ...future.makeSendCondition <- local({
[16:09:30.912]                   sendCondition <- NULL
[16:09:30.912]                   function(frame = 1L) {
[16:09:30.912]                     if (is.function(sendCondition)) 
[16:09:30.912]                       return(sendCondition)
[16:09:30.912]                     ns <- getNamespace("parallel")
[16:09:30.912]                     if (exists("sendData", mode = "function", 
[16:09:30.912]                       envir = ns)) {
[16:09:30.912]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.912]                         envir = ns)
[16:09:30.912]                       envir <- sys.frame(frame)
[16:09:30.912]                       master <- NULL
[16:09:30.912]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.912]                         !identical(envir, emptyenv())) {
[16:09:30.912]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.912]                           inherits = FALSE)) {
[16:09:30.912]                           master <- get("master", mode = "list", 
[16:09:30.912]                             envir = envir, inherits = FALSE)
[16:09:30.912]                           if (inherits(master, c("SOCKnode", 
[16:09:30.912]                             "SOCK0node"))) {
[16:09:30.912]                             sendCondition <<- function(cond) {
[16:09:30.912]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.912]                                 success = TRUE)
[16:09:30.912]                               parallel_sendData(master, data)
[16:09:30.912]                             }
[16:09:30.912]                             return(sendCondition)
[16:09:30.912]                           }
[16:09:30.912]                         }
[16:09:30.912]                         frame <- frame + 1L
[16:09:30.912]                         envir <- sys.frame(frame)
[16:09:30.912]                       }
[16:09:30.912]                     }
[16:09:30.912]                     sendCondition <<- function(cond) NULL
[16:09:30.912]                   }
[16:09:30.912]                 })
[16:09:30.912]                 withCallingHandlers({
[16:09:30.912]                   {
[16:09:30.912]                     do.call(function(...) {
[16:09:30.912]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.912]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.912]                         ...future.globals.maxSize)) {
[16:09:30.912]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.912]                         on.exit(options(oopts), add = TRUE)
[16:09:30.912]                       }
[16:09:30.912]                       {
[16:09:30.912]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.912]                           FUN = function(jj) {
[16:09:30.912]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.912]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.912]                           })
[16:09:30.912]                       }
[16:09:30.912]                     }, args = future.call.arguments)
[16:09:30.912]                   }
[16:09:30.912]                 }, immediateCondition = function(cond) {
[16:09:30.912]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.912]                   sendCondition(cond)
[16:09:30.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.912]                   {
[16:09:30.912]                     inherits <- base::inherits
[16:09:30.912]                     invokeRestart <- base::invokeRestart
[16:09:30.912]                     is.null <- base::is.null
[16:09:30.912]                     muffled <- FALSE
[16:09:30.912]                     if (inherits(cond, "message")) {
[16:09:30.912]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.912]                       if (muffled) 
[16:09:30.912]                         invokeRestart("muffleMessage")
[16:09:30.912]                     }
[16:09:30.912]                     else if (inherits(cond, "warning")) {
[16:09:30.912]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.912]                       if (muffled) 
[16:09:30.912]                         invokeRestart("muffleWarning")
[16:09:30.912]                     }
[16:09:30.912]                     else if (inherits(cond, "condition")) {
[16:09:30.912]                       if (!is.null(pattern)) {
[16:09:30.912]                         computeRestarts <- base::computeRestarts
[16:09:30.912]                         grepl <- base::grepl
[16:09:30.912]                         restarts <- computeRestarts(cond)
[16:09:30.912]                         for (restart in restarts) {
[16:09:30.912]                           name <- restart$name
[16:09:30.912]                           if (is.null(name)) 
[16:09:30.912]                             next
[16:09:30.912]                           if (!grepl(pattern, name)) 
[16:09:30.912]                             next
[16:09:30.912]                           invokeRestart(restart)
[16:09:30.912]                           muffled <- TRUE
[16:09:30.912]                           break
[16:09:30.912]                         }
[16:09:30.912]                       }
[16:09:30.912]                     }
[16:09:30.912]                     invisible(muffled)
[16:09:30.912]                   }
[16:09:30.912]                   muffleCondition(cond)
[16:09:30.912]                 })
[16:09:30.912]             }))
[16:09:30.912]             future::FutureResult(value = ...future.value$value, 
[16:09:30.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.912]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.912]                     ...future.globalenv.names))
[16:09:30.912]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.912]         }, condition = base::local({
[16:09:30.912]             c <- base::c
[16:09:30.912]             inherits <- base::inherits
[16:09:30.912]             invokeRestart <- base::invokeRestart
[16:09:30.912]             length <- base::length
[16:09:30.912]             list <- base::list
[16:09:30.912]             seq.int <- base::seq.int
[16:09:30.912]             signalCondition <- base::signalCondition
[16:09:30.912]             sys.calls <- base::sys.calls
[16:09:30.912]             `[[` <- base::`[[`
[16:09:30.912]             `+` <- base::`+`
[16:09:30.912]             `<<-` <- base::`<<-`
[16:09:30.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.912]                   3L)]
[16:09:30.912]             }
[16:09:30.912]             function(cond) {
[16:09:30.912]                 is_error <- inherits(cond, "error")
[16:09:30.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.912]                   NULL)
[16:09:30.912]                 if (is_error) {
[16:09:30.912]                   sessionInformation <- function() {
[16:09:30.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.912]                       search = base::search(), system = base::Sys.info())
[16:09:30.912]                   }
[16:09:30.912]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.912]                     cond$call), session = sessionInformation(), 
[16:09:30.912]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.912]                   signalCondition(cond)
[16:09:30.912]                 }
[16:09:30.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.912]                 "immediateCondition"))) {
[16:09:30.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.912]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.912]                   if (TRUE && !signal) {
[16:09:30.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.912]                     {
[16:09:30.912]                       inherits <- base::inherits
[16:09:30.912]                       invokeRestart <- base::invokeRestart
[16:09:30.912]                       is.null <- base::is.null
[16:09:30.912]                       muffled <- FALSE
[16:09:30.912]                       if (inherits(cond, "message")) {
[16:09:30.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.912]                         if (muffled) 
[16:09:30.912]                           invokeRestart("muffleMessage")
[16:09:30.912]                       }
[16:09:30.912]                       else if (inherits(cond, "warning")) {
[16:09:30.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.912]                         if (muffled) 
[16:09:30.912]                           invokeRestart("muffleWarning")
[16:09:30.912]                       }
[16:09:30.912]                       else if (inherits(cond, "condition")) {
[16:09:30.912]                         if (!is.null(pattern)) {
[16:09:30.912]                           computeRestarts <- base::computeRestarts
[16:09:30.912]                           grepl <- base::grepl
[16:09:30.912]                           restarts <- computeRestarts(cond)
[16:09:30.912]                           for (restart in restarts) {
[16:09:30.912]                             name <- restart$name
[16:09:30.912]                             if (is.null(name)) 
[16:09:30.912]                               next
[16:09:30.912]                             if (!grepl(pattern, name)) 
[16:09:30.912]                               next
[16:09:30.912]                             invokeRestart(restart)
[16:09:30.912]                             muffled <- TRUE
[16:09:30.912]                             break
[16:09:30.912]                           }
[16:09:30.912]                         }
[16:09:30.912]                       }
[16:09:30.912]                       invisible(muffled)
[16:09:30.912]                     }
[16:09:30.912]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.912]                   }
[16:09:30.912]                 }
[16:09:30.912]                 else {
[16:09:30.912]                   if (TRUE) {
[16:09:30.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.912]                     {
[16:09:30.912]                       inherits <- base::inherits
[16:09:30.912]                       invokeRestart <- base::invokeRestart
[16:09:30.912]                       is.null <- base::is.null
[16:09:30.912]                       muffled <- FALSE
[16:09:30.912]                       if (inherits(cond, "message")) {
[16:09:30.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.912]                         if (muffled) 
[16:09:30.912]                           invokeRestart("muffleMessage")
[16:09:30.912]                       }
[16:09:30.912]                       else if (inherits(cond, "warning")) {
[16:09:30.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.912]                         if (muffled) 
[16:09:30.912]                           invokeRestart("muffleWarning")
[16:09:30.912]                       }
[16:09:30.912]                       else if (inherits(cond, "condition")) {
[16:09:30.912]                         if (!is.null(pattern)) {
[16:09:30.912]                           computeRestarts <- base::computeRestarts
[16:09:30.912]                           grepl <- base::grepl
[16:09:30.912]                           restarts <- computeRestarts(cond)
[16:09:30.912]                           for (restart in restarts) {
[16:09:30.912]                             name <- restart$name
[16:09:30.912]                             if (is.null(name)) 
[16:09:30.912]                               next
[16:09:30.912]                             if (!grepl(pattern, name)) 
[16:09:30.912]                               next
[16:09:30.912]                             invokeRestart(restart)
[16:09:30.912]                             muffled <- TRUE
[16:09:30.912]                             break
[16:09:30.912]                           }
[16:09:30.912]                         }
[16:09:30.912]                       }
[16:09:30.912]                       invisible(muffled)
[16:09:30.912]                     }
[16:09:30.912]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.912]                   }
[16:09:30.912]                 }
[16:09:30.912]             }
[16:09:30.912]         }))
[16:09:30.912]     }, error = function(ex) {
[16:09:30.912]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.912]                 ...future.rng), started = ...future.startTime, 
[16:09:30.912]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.912]             version = "1.8"), class = "FutureResult")
[16:09:30.912]     }, finally = {
[16:09:30.912]         if (!identical(...future.workdir, getwd())) 
[16:09:30.912]             setwd(...future.workdir)
[16:09:30.912]         {
[16:09:30.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.912]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.912]             }
[16:09:30.912]             base::options(...future.oldOptions)
[16:09:30.912]             if (.Platform$OS.type == "windows") {
[16:09:30.912]                 old_names <- names(...future.oldEnvVars)
[16:09:30.912]                 envs <- base::Sys.getenv()
[16:09:30.912]                 names <- names(envs)
[16:09:30.912]                 common <- intersect(names, old_names)
[16:09:30.912]                 added <- setdiff(names, old_names)
[16:09:30.912]                 removed <- setdiff(old_names, names)
[16:09:30.912]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.912]                   envs[common]]
[16:09:30.912]                 NAMES <- toupper(changed)
[16:09:30.912]                 args <- list()
[16:09:30.912]                 for (kk in seq_along(NAMES)) {
[16:09:30.912]                   name <- changed[[kk]]
[16:09:30.912]                   NAME <- NAMES[[kk]]
[16:09:30.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.912]                     next
[16:09:30.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.912]                 }
[16:09:30.912]                 NAMES <- toupper(added)
[16:09:30.912]                 for (kk in seq_along(NAMES)) {
[16:09:30.912]                   name <- added[[kk]]
[16:09:30.912]                   NAME <- NAMES[[kk]]
[16:09:30.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.912]                     next
[16:09:30.912]                   args[[name]] <- ""
[16:09:30.912]                 }
[16:09:30.912]                 NAMES <- toupper(removed)
[16:09:30.912]                 for (kk in seq_along(NAMES)) {
[16:09:30.912]                   name <- removed[[kk]]
[16:09:30.912]                   NAME <- NAMES[[kk]]
[16:09:30.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.912]                     next
[16:09:30.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.912]                 }
[16:09:30.912]                 if (length(args) > 0) 
[16:09:30.912]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.912]             }
[16:09:30.912]             else {
[16:09:30.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.912]             }
[16:09:30.912]             {
[16:09:30.912]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.912]                   0L) {
[16:09:30.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.912]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.912]                   base::options(opts)
[16:09:30.912]                 }
[16:09:30.912]                 {
[16:09:30.912]                   {
[16:09:30.912]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.912]                     NULL
[16:09:30.912]                   }
[16:09:30.912]                   options(future.plan = NULL)
[16:09:30.912]                   if (is.na(NA_character_)) 
[16:09:30.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.912]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.912]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.912]                     envir = parent.frame()) 
[16:09:30.912]                   {
[16:09:30.912]                     if (is.function(workers)) 
[16:09:30.912]                       workers <- workers()
[16:09:30.912]                     workers <- structure(as.integer(workers), 
[16:09:30.912]                       class = class(workers))
[16:09:30.912]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.912]                       workers >= 1)
[16:09:30.912]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.912]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.912]                     }
[16:09:30.912]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.912]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.912]                       envir = envir)
[16:09:30.912]                     if (!future$lazy) 
[16:09:30.912]                       future <- run(future)
[16:09:30.912]                     invisible(future)
[16:09:30.912]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.912]                 }
[16:09:30.912]             }
[16:09:30.912]         }
[16:09:30.912]     })
[16:09:30.912]     if (TRUE) {
[16:09:30.912]         base::sink(type = "output", split = FALSE)
[16:09:30.912]         if (TRUE) {
[16:09:30.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.912]         }
[16:09:30.912]         else {
[16:09:30.912]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.912]         }
[16:09:30.912]         base::close(...future.stdout)
[16:09:30.912]         ...future.stdout <- NULL
[16:09:30.912]     }
[16:09:30.912]     ...future.result$conditions <- ...future.conditions
[16:09:30.912]     ...future.result$finished <- base::Sys.time()
[16:09:30.912]     ...future.result
[16:09:30.912] }
[16:09:30.916] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[16:09:30.916] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:30.916] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.916] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:09:30.917] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:09:30.917] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:09:30.917] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:09:30.917] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:30.918] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.918] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:30.918] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:30.918] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[16:09:30.919] MultisessionFuture started
[16:09:30.919] - Launch lazy future ... done
[16:09:30.919] run() for ‘MultisessionFuture’ ... done
[16:09:30.919] Created future:
[16:09:30.919] MultisessionFuture:
[16:09:30.919] Label: ‘future_apply-1’
[16:09:30.919] Expression:
[16:09:30.919] {
[16:09:30.919]     do.call(function(...) {
[16:09:30.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.919]             on.exit(options(oopts), add = TRUE)
[16:09:30.919]         }
[16:09:30.919]         {
[16:09:30.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.919]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.919]             })
[16:09:30.919]         }
[16:09:30.919]     }, args = future.call.arguments)
[16:09:30.919] }
[16:09:30.919] Lazy evaluation: FALSE
[16:09:30.919] Asynchronous evaluation: TRUE
[16:09:30.919] Local evaluation: TRUE
[16:09:30.919] Environment: R_GlobalEnv
[16:09:30.919] Capture standard output: TRUE
[16:09:30.919] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.919] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.919] Packages: <none>
[16:09:30.919] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.919] Resolved: FALSE
[16:09:30.919] Value: <not collected>
[16:09:30.919] Conditions captured: <none>
[16:09:30.919] Early signaling: FALSE
[16:09:30.919] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.919] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.931] Chunk #1 of 2 ... DONE
[16:09:30.931] Chunk #2 of 2 ...
[16:09:30.931]  - seeds: <none>
[16:09:30.931] getGlobalsAndPackages() ...
[16:09:30.931] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.931] Resolving globals: FALSE
[16:09:30.931] Tweak future expression to call with '...' arguments ...
[16:09:30.931] {
[16:09:30.931]     do.call(function(...) {
[16:09:30.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.931]             on.exit(options(oopts), add = TRUE)
[16:09:30.931]         }
[16:09:30.931]         {
[16:09:30.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.931]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.931]             })
[16:09:30.931]         }
[16:09:30.931]     }, args = future.call.arguments)
[16:09:30.931] }
[16:09:30.932] Tweak future expression to call with '...' arguments ... DONE
[16:09:30.932] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:30.932] 
[16:09:30.932] getGlobalsAndPackages() ... DONE
[16:09:30.933] run() for ‘Future’ ...
[16:09:30.933] - state: ‘created’
[16:09:30.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:30.948] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:30.948]   - Field: ‘node’
[16:09:30.948]   - Field: ‘label’
[16:09:30.948]   - Field: ‘local’
[16:09:30.948]   - Field: ‘owner’
[16:09:30.948]   - Field: ‘envir’
[16:09:30.948]   - Field: ‘workers’
[16:09:30.948]   - Field: ‘packages’
[16:09:30.949]   - Field: ‘gc’
[16:09:30.949]   - Field: ‘conditions’
[16:09:30.949]   - Field: ‘persistent’
[16:09:30.949]   - Field: ‘expr’
[16:09:30.949]   - Field: ‘uuid’
[16:09:30.949]   - Field: ‘seed’
[16:09:30.949]   - Field: ‘version’
[16:09:30.949]   - Field: ‘result’
[16:09:30.949]   - Field: ‘asynchronous’
[16:09:30.949]   - Field: ‘calls’
[16:09:30.949]   - Field: ‘globals’
[16:09:30.950]   - Field: ‘stdout’
[16:09:30.950]   - Field: ‘earlySignal’
[16:09:30.950]   - Field: ‘lazy’
[16:09:30.950]   - Field: ‘state’
[16:09:30.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:30.950] - Launch lazy future ...
[16:09:30.950] Packages needed by the future expression (n = 0): <none>
[16:09:30.950] Packages needed by future strategies (n = 0): <none>
[16:09:30.951] {
[16:09:30.951]     {
[16:09:30.951]         {
[16:09:30.951]             ...future.startTime <- base::Sys.time()
[16:09:30.951]             {
[16:09:30.951]                 {
[16:09:30.951]                   {
[16:09:30.951]                     {
[16:09:30.951]                       base::local({
[16:09:30.951]                         has_future <- base::requireNamespace("future", 
[16:09:30.951]                           quietly = TRUE)
[16:09:30.951]                         if (has_future) {
[16:09:30.951]                           ns <- base::getNamespace("future")
[16:09:30.951]                           version <- ns[[".package"]][["version"]]
[16:09:30.951]                           if (is.null(version)) 
[16:09:30.951]                             version <- utils::packageVersion("future")
[16:09:30.951]                         }
[16:09:30.951]                         else {
[16:09:30.951]                           version <- NULL
[16:09:30.951]                         }
[16:09:30.951]                         if (!has_future || version < "1.8.0") {
[16:09:30.951]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:30.951]                             "", base::R.version$version.string), 
[16:09:30.951]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:30.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:30.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:30.951]                               "release", "version")], collapse = " "), 
[16:09:30.951]                             hostname = base::Sys.info()[["nodename"]])
[16:09:30.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:30.951]                             info)
[16:09:30.951]                           info <- base::paste(info, collapse = "; ")
[16:09:30.951]                           if (!has_future) {
[16:09:30.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:30.951]                               info)
[16:09:30.951]                           }
[16:09:30.951]                           else {
[16:09:30.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:30.951]                               info, version)
[16:09:30.951]                           }
[16:09:30.951]                           base::stop(msg)
[16:09:30.951]                         }
[16:09:30.951]                       })
[16:09:30.951]                     }
[16:09:30.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:30.951]                     base::options(mc.cores = 1L)
[16:09:30.951]                   }
[16:09:30.951]                   options(future.plan = NULL)
[16:09:30.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:30.951]                 }
[16:09:30.951]                 ...future.workdir <- getwd()
[16:09:30.951]             }
[16:09:30.951]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:30.951]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:30.951]         }
[16:09:30.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:30.951]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:30.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:30.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:30.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:30.951]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:30.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:30.951]             base::names(...future.oldOptions))
[16:09:30.951]     }
[16:09:30.951]     if (FALSE) {
[16:09:30.951]     }
[16:09:30.951]     else {
[16:09:30.951]         if (TRUE) {
[16:09:30.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:30.951]                 open = "w")
[16:09:30.951]         }
[16:09:30.951]         else {
[16:09:30.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:30.951]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:30.951]         }
[16:09:30.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:30.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:30.951]             base::sink(type = "output", split = FALSE)
[16:09:30.951]             base::close(...future.stdout)
[16:09:30.951]         }, add = TRUE)
[16:09:30.951]     }
[16:09:30.951]     ...future.frame <- base::sys.nframe()
[16:09:30.951]     ...future.conditions <- base::list()
[16:09:30.951]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:30.951]     if (FALSE) {
[16:09:30.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:30.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:30.951]     }
[16:09:30.951]     ...future.result <- base::tryCatch({
[16:09:30.951]         base::withCallingHandlers({
[16:09:30.951]             ...future.value <- base::withVisible(base::local({
[16:09:30.951]                 ...future.makeSendCondition <- local({
[16:09:30.951]                   sendCondition <- NULL
[16:09:30.951]                   function(frame = 1L) {
[16:09:30.951]                     if (is.function(sendCondition)) 
[16:09:30.951]                       return(sendCondition)
[16:09:30.951]                     ns <- getNamespace("parallel")
[16:09:30.951]                     if (exists("sendData", mode = "function", 
[16:09:30.951]                       envir = ns)) {
[16:09:30.951]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:30.951]                         envir = ns)
[16:09:30.951]                       envir <- sys.frame(frame)
[16:09:30.951]                       master <- NULL
[16:09:30.951]                       while (!identical(envir, .GlobalEnv) && 
[16:09:30.951]                         !identical(envir, emptyenv())) {
[16:09:30.951]                         if (exists("master", mode = "list", envir = envir, 
[16:09:30.951]                           inherits = FALSE)) {
[16:09:30.951]                           master <- get("master", mode = "list", 
[16:09:30.951]                             envir = envir, inherits = FALSE)
[16:09:30.951]                           if (inherits(master, c("SOCKnode", 
[16:09:30.951]                             "SOCK0node"))) {
[16:09:30.951]                             sendCondition <<- function(cond) {
[16:09:30.951]                               data <- list(type = "VALUE", value = cond, 
[16:09:30.951]                                 success = TRUE)
[16:09:30.951]                               parallel_sendData(master, data)
[16:09:30.951]                             }
[16:09:30.951]                             return(sendCondition)
[16:09:30.951]                           }
[16:09:30.951]                         }
[16:09:30.951]                         frame <- frame + 1L
[16:09:30.951]                         envir <- sys.frame(frame)
[16:09:30.951]                       }
[16:09:30.951]                     }
[16:09:30.951]                     sendCondition <<- function(cond) NULL
[16:09:30.951]                   }
[16:09:30.951]                 })
[16:09:30.951]                 withCallingHandlers({
[16:09:30.951]                   {
[16:09:30.951]                     do.call(function(...) {
[16:09:30.951]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.951]                       if (!identical(...future.globals.maxSize.org, 
[16:09:30.951]                         ...future.globals.maxSize)) {
[16:09:30.951]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.951]                         on.exit(options(oopts), add = TRUE)
[16:09:30.951]                       }
[16:09:30.951]                       {
[16:09:30.951]                         lapply(seq_along(...future.elements_ii), 
[16:09:30.951]                           FUN = function(jj) {
[16:09:30.951]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.951]                             ...future.FUN(...future.X_jj, ...)
[16:09:30.951]                           })
[16:09:30.951]                       }
[16:09:30.951]                     }, args = future.call.arguments)
[16:09:30.951]                   }
[16:09:30.951]                 }, immediateCondition = function(cond) {
[16:09:30.951]                   sendCondition <- ...future.makeSendCondition()
[16:09:30.951]                   sendCondition(cond)
[16:09:30.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.951]                   {
[16:09:30.951]                     inherits <- base::inherits
[16:09:30.951]                     invokeRestart <- base::invokeRestart
[16:09:30.951]                     is.null <- base::is.null
[16:09:30.951]                     muffled <- FALSE
[16:09:30.951]                     if (inherits(cond, "message")) {
[16:09:30.951]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:30.951]                       if (muffled) 
[16:09:30.951]                         invokeRestart("muffleMessage")
[16:09:30.951]                     }
[16:09:30.951]                     else if (inherits(cond, "warning")) {
[16:09:30.951]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:30.951]                       if (muffled) 
[16:09:30.951]                         invokeRestart("muffleWarning")
[16:09:30.951]                     }
[16:09:30.951]                     else if (inherits(cond, "condition")) {
[16:09:30.951]                       if (!is.null(pattern)) {
[16:09:30.951]                         computeRestarts <- base::computeRestarts
[16:09:30.951]                         grepl <- base::grepl
[16:09:30.951]                         restarts <- computeRestarts(cond)
[16:09:30.951]                         for (restart in restarts) {
[16:09:30.951]                           name <- restart$name
[16:09:30.951]                           if (is.null(name)) 
[16:09:30.951]                             next
[16:09:30.951]                           if (!grepl(pattern, name)) 
[16:09:30.951]                             next
[16:09:30.951]                           invokeRestart(restart)
[16:09:30.951]                           muffled <- TRUE
[16:09:30.951]                           break
[16:09:30.951]                         }
[16:09:30.951]                       }
[16:09:30.951]                     }
[16:09:30.951]                     invisible(muffled)
[16:09:30.951]                   }
[16:09:30.951]                   muffleCondition(cond)
[16:09:30.951]                 })
[16:09:30.951]             }))
[16:09:30.951]             future::FutureResult(value = ...future.value$value, 
[16:09:30.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.951]                   ...future.rng), globalenv = if (FALSE) 
[16:09:30.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:30.951]                     ...future.globalenv.names))
[16:09:30.951]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:30.951]         }, condition = base::local({
[16:09:30.951]             c <- base::c
[16:09:30.951]             inherits <- base::inherits
[16:09:30.951]             invokeRestart <- base::invokeRestart
[16:09:30.951]             length <- base::length
[16:09:30.951]             list <- base::list
[16:09:30.951]             seq.int <- base::seq.int
[16:09:30.951]             signalCondition <- base::signalCondition
[16:09:30.951]             sys.calls <- base::sys.calls
[16:09:30.951]             `[[` <- base::`[[`
[16:09:30.951]             `+` <- base::`+`
[16:09:30.951]             `<<-` <- base::`<<-`
[16:09:30.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:30.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:30.951]                   3L)]
[16:09:30.951]             }
[16:09:30.951]             function(cond) {
[16:09:30.951]                 is_error <- inherits(cond, "error")
[16:09:30.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:30.951]                   NULL)
[16:09:30.951]                 if (is_error) {
[16:09:30.951]                   sessionInformation <- function() {
[16:09:30.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:30.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:30.951]                       search = base::search(), system = base::Sys.info())
[16:09:30.951]                   }
[16:09:30.951]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:30.951]                     cond$call), session = sessionInformation(), 
[16:09:30.951]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:30.951]                   signalCondition(cond)
[16:09:30.951]                 }
[16:09:30.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:30.951]                 "immediateCondition"))) {
[16:09:30.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:30.951]                   ...future.conditions[[length(...future.conditions) + 
[16:09:30.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:30.951]                   if (TRUE && !signal) {
[16:09:30.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.951]                     {
[16:09:30.951]                       inherits <- base::inherits
[16:09:30.951]                       invokeRestart <- base::invokeRestart
[16:09:30.951]                       is.null <- base::is.null
[16:09:30.951]                       muffled <- FALSE
[16:09:30.951]                       if (inherits(cond, "message")) {
[16:09:30.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.951]                         if (muffled) 
[16:09:30.951]                           invokeRestart("muffleMessage")
[16:09:30.951]                       }
[16:09:30.951]                       else if (inherits(cond, "warning")) {
[16:09:30.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.951]                         if (muffled) 
[16:09:30.951]                           invokeRestart("muffleWarning")
[16:09:30.951]                       }
[16:09:30.951]                       else if (inherits(cond, "condition")) {
[16:09:30.951]                         if (!is.null(pattern)) {
[16:09:30.951]                           computeRestarts <- base::computeRestarts
[16:09:30.951]                           grepl <- base::grepl
[16:09:30.951]                           restarts <- computeRestarts(cond)
[16:09:30.951]                           for (restart in restarts) {
[16:09:30.951]                             name <- restart$name
[16:09:30.951]                             if (is.null(name)) 
[16:09:30.951]                               next
[16:09:30.951]                             if (!grepl(pattern, name)) 
[16:09:30.951]                               next
[16:09:30.951]                             invokeRestart(restart)
[16:09:30.951]                             muffled <- TRUE
[16:09:30.951]                             break
[16:09:30.951]                           }
[16:09:30.951]                         }
[16:09:30.951]                       }
[16:09:30.951]                       invisible(muffled)
[16:09:30.951]                     }
[16:09:30.951]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.951]                   }
[16:09:30.951]                 }
[16:09:30.951]                 else {
[16:09:30.951]                   if (TRUE) {
[16:09:30.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:30.951]                     {
[16:09:30.951]                       inherits <- base::inherits
[16:09:30.951]                       invokeRestart <- base::invokeRestart
[16:09:30.951]                       is.null <- base::is.null
[16:09:30.951]                       muffled <- FALSE
[16:09:30.951]                       if (inherits(cond, "message")) {
[16:09:30.951]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:30.951]                         if (muffled) 
[16:09:30.951]                           invokeRestart("muffleMessage")
[16:09:30.951]                       }
[16:09:30.951]                       else if (inherits(cond, "warning")) {
[16:09:30.951]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:30.951]                         if (muffled) 
[16:09:30.951]                           invokeRestart("muffleWarning")
[16:09:30.951]                       }
[16:09:30.951]                       else if (inherits(cond, "condition")) {
[16:09:30.951]                         if (!is.null(pattern)) {
[16:09:30.951]                           computeRestarts <- base::computeRestarts
[16:09:30.951]                           grepl <- base::grepl
[16:09:30.951]                           restarts <- computeRestarts(cond)
[16:09:30.951]                           for (restart in restarts) {
[16:09:30.951]                             name <- restart$name
[16:09:30.951]                             if (is.null(name)) 
[16:09:30.951]                               next
[16:09:30.951]                             if (!grepl(pattern, name)) 
[16:09:30.951]                               next
[16:09:30.951]                             invokeRestart(restart)
[16:09:30.951]                             muffled <- TRUE
[16:09:30.951]                             break
[16:09:30.951]                           }
[16:09:30.951]                         }
[16:09:30.951]                       }
[16:09:30.951]                       invisible(muffled)
[16:09:30.951]                     }
[16:09:30.951]                     muffleCondition(cond, pattern = "^muffle")
[16:09:30.951]                   }
[16:09:30.951]                 }
[16:09:30.951]             }
[16:09:30.951]         }))
[16:09:30.951]     }, error = function(ex) {
[16:09:30.951]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:30.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:30.951]                 ...future.rng), started = ...future.startTime, 
[16:09:30.951]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:30.951]             version = "1.8"), class = "FutureResult")
[16:09:30.951]     }, finally = {
[16:09:30.951]         if (!identical(...future.workdir, getwd())) 
[16:09:30.951]             setwd(...future.workdir)
[16:09:30.951]         {
[16:09:30.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:30.951]                 ...future.oldOptions$nwarnings <- NULL
[16:09:30.951]             }
[16:09:30.951]             base::options(...future.oldOptions)
[16:09:30.951]             if (.Platform$OS.type == "windows") {
[16:09:30.951]                 old_names <- names(...future.oldEnvVars)
[16:09:30.951]                 envs <- base::Sys.getenv()
[16:09:30.951]                 names <- names(envs)
[16:09:30.951]                 common <- intersect(names, old_names)
[16:09:30.951]                 added <- setdiff(names, old_names)
[16:09:30.951]                 removed <- setdiff(old_names, names)
[16:09:30.951]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:30.951]                   envs[common]]
[16:09:30.951]                 NAMES <- toupper(changed)
[16:09:30.951]                 args <- list()
[16:09:30.951]                 for (kk in seq_along(NAMES)) {
[16:09:30.951]                   name <- changed[[kk]]
[16:09:30.951]                   NAME <- NAMES[[kk]]
[16:09:30.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.951]                     next
[16:09:30.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.951]                 }
[16:09:30.951]                 NAMES <- toupper(added)
[16:09:30.951]                 for (kk in seq_along(NAMES)) {
[16:09:30.951]                   name <- added[[kk]]
[16:09:30.951]                   NAME <- NAMES[[kk]]
[16:09:30.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.951]                     next
[16:09:30.951]                   args[[name]] <- ""
[16:09:30.951]                 }
[16:09:30.951]                 NAMES <- toupper(removed)
[16:09:30.951]                 for (kk in seq_along(NAMES)) {
[16:09:30.951]                   name <- removed[[kk]]
[16:09:30.951]                   NAME <- NAMES[[kk]]
[16:09:30.951]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:30.951]                     next
[16:09:30.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:30.951]                 }
[16:09:30.951]                 if (length(args) > 0) 
[16:09:30.951]                   base::do.call(base::Sys.setenv, args = args)
[16:09:30.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:30.951]             }
[16:09:30.951]             else {
[16:09:30.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:30.951]             }
[16:09:30.951]             {
[16:09:30.951]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:30.951]                   0L) {
[16:09:30.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:30.951]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:30.951]                   base::options(opts)
[16:09:30.951]                 }
[16:09:30.951]                 {
[16:09:30.951]                   {
[16:09:30.951]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:30.951]                     NULL
[16:09:30.951]                   }
[16:09:30.951]                   options(future.plan = NULL)
[16:09:30.951]                   if (is.na(NA_character_)) 
[16:09:30.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:30.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:30.951]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:30.951]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:30.951]                     envir = parent.frame()) 
[16:09:30.951]                   {
[16:09:30.951]                     if (is.function(workers)) 
[16:09:30.951]                       workers <- workers()
[16:09:30.951]                     workers <- structure(as.integer(workers), 
[16:09:30.951]                       class = class(workers))
[16:09:30.951]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:30.951]                       workers >= 1)
[16:09:30.951]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:30.951]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:30.951]                     }
[16:09:30.951]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:30.951]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:30.951]                       envir = envir)
[16:09:30.951]                     if (!future$lazy) 
[16:09:30.951]                       future <- run(future)
[16:09:30.951]                     invisible(future)
[16:09:30.951]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:30.951]                 }
[16:09:30.951]             }
[16:09:30.951]         }
[16:09:30.951]     })
[16:09:30.951]     if (TRUE) {
[16:09:30.951]         base::sink(type = "output", split = FALSE)
[16:09:30.951]         if (TRUE) {
[16:09:30.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:30.951]         }
[16:09:30.951]         else {
[16:09:30.951]             ...future.result["stdout"] <- base::list(NULL)
[16:09:30.951]         }
[16:09:30.951]         base::close(...future.stdout)
[16:09:30.951]         ...future.stdout <- NULL
[16:09:30.951]     }
[16:09:30.951]     ...future.result$conditions <- ...future.conditions
[16:09:30.951]     ...future.result$finished <- base::Sys.time()
[16:09:30.951]     ...future.result
[16:09:30.951] }
[16:09:30.954] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[16:09:30.954] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:30.954] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.955] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:09:30.955] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:09:30.955] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:09:30.956] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:09:30.956] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:30.956] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.956] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:30.957] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:30.957] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[16:09:30.957] MultisessionFuture started
[16:09:30.957] - Launch lazy future ... done
[16:09:30.958] run() for ‘MultisessionFuture’ ... done
[16:09:30.958] Created future:
[16:09:30.958] MultisessionFuture:
[16:09:30.958] Label: ‘future_apply-2’
[16:09:30.958] Expression:
[16:09:30.958] {
[16:09:30.958]     do.call(function(...) {
[16:09:30.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:30.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:30.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:30.958]             on.exit(options(oopts), add = TRUE)
[16:09:30.958]         }
[16:09:30.958]         {
[16:09:30.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:30.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:30.958]                 ...future.FUN(...future.X_jj, ...)
[16:09:30.958]             })
[16:09:30.958]         }
[16:09:30.958]     }, args = future.call.arguments)
[16:09:30.958] }
[16:09:30.958] Lazy evaluation: FALSE
[16:09:30.958] Asynchronous evaluation: TRUE
[16:09:30.958] Local evaluation: TRUE
[16:09:30.958] Environment: R_GlobalEnv
[16:09:30.958] Capture standard output: TRUE
[16:09:30.958] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:30.958] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:30.958] Packages: <none>
[16:09:30.958] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:30.958] Resolved: FALSE
[16:09:30.958] Value: <not collected>
[16:09:30.958] Conditions captured: <none>
[16:09:30.958] Early signaling: FALSE
[16:09:30.958] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:30.958] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:30.969] Chunk #2 of 2 ... DONE
[16:09:30.969] Launching 2 futures (chunks) ... DONE
[16:09:30.969] Resolving 2 futures (chunks) ...
[16:09:30.970] resolve() on list ...
[16:09:30.970]  recursive: 0
[16:09:30.970]  length: 2
[16:09:30.970] 
[16:09:30.970] receiveMessageFromWorker() for ClusterFuture ...
[16:09:30.971] - Validating connection of MultisessionFuture
[16:09:30.971] - received message: FutureResult
[16:09:30.971] - Received FutureResult
[16:09:30.971] - Erased future from FutureRegistry
[16:09:30.971] result() for ClusterFuture ...
[16:09:30.971] - result already collected: FutureResult
[16:09:30.971] result() for ClusterFuture ... done
[16:09:30.971] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:30.971] Future #1
[16:09:30.972] result() for ClusterFuture ...
[16:09:30.972] - result already collected: FutureResult
[16:09:30.972] result() for ClusterFuture ... done
[16:09:30.972] result() for ClusterFuture ...
[16:09:30.972] - result already collected: FutureResult
[16:09:30.972] result() for ClusterFuture ... done
[16:09:30.972] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:30.972] - nx: 2
[16:09:30.972] - relay: TRUE
[16:09:30.972] - stdout: TRUE
[16:09:30.972] - signal: TRUE
[16:09:30.973] - resignal: FALSE
[16:09:30.973] - force: TRUE
[16:09:30.973] - relayed: [n=2] FALSE, FALSE
[16:09:30.973] - queued futures: [n=2] FALSE, FALSE
[16:09:30.973]  - until=1
[16:09:30.973]  - relaying element #1
[16:09:30.973] result() for ClusterFuture ...
[16:09:30.973] - result already collected: FutureResult
[16:09:30.973] result() for ClusterFuture ... done
[16:09:30.973] result() for ClusterFuture ...
[16:09:30.973] - result already collected: FutureResult
[16:09:30.974] result() for ClusterFuture ... done
[16:09:30.974] result() for ClusterFuture ...
[16:09:30.974] - result already collected: FutureResult
[16:09:30.974] result() for ClusterFuture ... done
[16:09:30.974] result() for ClusterFuture ...
[16:09:30.974] - result already collected: FutureResult
[16:09:30.974] result() for ClusterFuture ... done
[16:09:30.974] - relayed: [n=2] TRUE, FALSE
[16:09:30.974] - queued futures: [n=2] TRUE, FALSE
[16:09:30.974] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:30.974]  length: 1 (resolved future 1)
[16:09:31.004] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.004] - Validating connection of MultisessionFuture
[16:09:31.004] - received message: FutureResult
[16:09:31.005] - Received FutureResult
[16:09:31.005] - Erased future from FutureRegistry
[16:09:31.005] result() for ClusterFuture ...
[16:09:31.005] - result already collected: FutureResult
[16:09:31.005] result() for ClusterFuture ... done
[16:09:31.005] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.005] Future #2
[16:09:31.005] result() for ClusterFuture ...
[16:09:31.005] - result already collected: FutureResult
[16:09:31.005] result() for ClusterFuture ... done
[16:09:31.005] result() for ClusterFuture ...
[16:09:31.006] - result already collected: FutureResult
[16:09:31.006] result() for ClusterFuture ... done
[16:09:31.006] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:31.006] - nx: 2
[16:09:31.006] - relay: TRUE
[16:09:31.006] - stdout: TRUE
[16:09:31.006] - signal: TRUE
[16:09:31.006] - resignal: FALSE
[16:09:31.006] - force: TRUE
[16:09:31.006] - relayed: [n=2] TRUE, FALSE
[16:09:31.006] - queued futures: [n=2] TRUE, FALSE
[16:09:31.007]  - until=2
[16:09:31.007]  - relaying element #2
[16:09:31.007] result() for ClusterFuture ...
[16:09:31.007] - result already collected: FutureResult
[16:09:31.007] result() for ClusterFuture ... done
[16:09:31.007] result() for ClusterFuture ...
[16:09:31.007] - result already collected: FutureResult
[16:09:31.007] result() for ClusterFuture ... done
[16:09:31.007] result() for ClusterFuture ...
[16:09:31.007] - result already collected: FutureResult
[16:09:31.007] result() for ClusterFuture ... done
[16:09:31.008] result() for ClusterFuture ...
[16:09:31.008] - result already collected: FutureResult
[16:09:31.008] result() for ClusterFuture ... done
[16:09:31.008] - relayed: [n=2] TRUE, TRUE
[16:09:31.008] - queued futures: [n=2] TRUE, TRUE
[16:09:31.008] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:31.008]  length: 0 (resolved future 2)
[16:09:31.008] Relaying remaining futures
[16:09:31.008] signalConditionsASAP(NULL, pos=0) ...
[16:09:31.008] - nx: 2
[16:09:31.008] - relay: TRUE
[16:09:31.009] - stdout: TRUE
[16:09:31.009] - signal: TRUE
[16:09:31.009] - resignal: FALSE
[16:09:31.009] - force: TRUE
[16:09:31.009] - relayed: [n=2] TRUE, TRUE
[16:09:31.009] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:31.009] - relayed: [n=2] TRUE, TRUE
[16:09:31.009] - queued futures: [n=2] TRUE, TRUE
[16:09:31.009] signalConditionsASAP(NULL, pos=0) ... done
[16:09:31.009] resolve() on list ... DONE
[16:09:31.009] result() for ClusterFuture ...
[16:09:31.009] - result already collected: FutureResult
[16:09:31.010] result() for ClusterFuture ... done
[16:09:31.010] result() for ClusterFuture ...
[16:09:31.010] - result already collected: FutureResult
[16:09:31.010] result() for ClusterFuture ... done
[16:09:31.010] result() for ClusterFuture ...
[16:09:31.010] - result already collected: FutureResult
[16:09:31.010] result() for ClusterFuture ... done
[16:09:31.010] result() for ClusterFuture ...
[16:09:31.010] - result already collected: FutureResult
[16:09:31.010] result() for ClusterFuture ... done
[16:09:31.010]  - Number of value chunks collected: 2
[16:09:31.011] Resolving 2 futures (chunks) ... DONE
[16:09:31.011] Reducing values from 2 chunks ...
[16:09:31.011]  - Number of values collected after concatenation: 2
[16:09:31.011]  - Number of values expected: 2
[16:09:31.011] Reducing values from 2 chunks ... DONE
[16:09:31.011] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:09:31.011] getGlobalsAndPackagesXApply() ...
[16:09:31.011]  - future.globals: TRUE
[16:09:31.011] getGlobalsAndPackages() ...
[16:09:31.012] Searching for globals...
[16:09:31.013] - globals found: [1] ‘FUN’
[16:09:31.013] Searching for globals ... DONE
[16:09:31.013] Resolving globals: FALSE
[16:09:31.013] The total size of the 1 globals is 848 bytes (848 bytes)
[16:09:31.013] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:09:31.014] - globals: [1] ‘FUN’
[16:09:31.014] 
[16:09:31.014] getGlobalsAndPackages() ... DONE
[16:09:31.014]  - globals found/used: [n=1] ‘FUN’
[16:09:31.014]  - needed namespaces: [n=0] 
[16:09:31.014] Finding globals ... DONE
[16:09:31.014]  - use_args: TRUE
[16:09:31.014]  - Getting '...' globals ...
[16:09:31.015] resolve() on list ...
[16:09:31.015]  recursive: 0
[16:09:31.015]  length: 1
[16:09:31.015]  elements: ‘...’
[16:09:31.015]  length: 0 (resolved future 1)
[16:09:31.015] resolve() on list ... DONE
[16:09:31.015]    - '...' content: [n=0] 
[16:09:31.015] List of 1
[16:09:31.015]  $ ...: list()
[16:09:31.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.015]  - attr(*, "where")=List of 1
[16:09:31.015]   ..$ ...:<environment: 0x5633ae1662e0> 
[16:09:31.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.015]  - attr(*, "resolved")= logi TRUE
[16:09:31.015]  - attr(*, "total_size")= num NA
[16:09:31.018]  - Getting '...' globals ... DONE
[16:09:31.018] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:31.018] List of 2
[16:09:31.018]  $ ...future.FUN:function (x)  
[16:09:31.018]  $ ...          : list()
[16:09:31.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.018]  - attr(*, "where")=List of 2
[16:09:31.018]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:31.018]   ..$ ...          :<environment: 0x5633ae1662e0> 
[16:09:31.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.018]  - attr(*, "resolved")= logi FALSE
[16:09:31.018]  - attr(*, "total_size")= num 848
[16:09:31.021] Packages to be attached in all futures: [n=0] 
[16:09:31.021] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.024] future_lapply() ...
[16:09:31.028] Number of chunks: 2
[16:09:31.028] getGlobalsAndPackagesXApply() ...
[16:09:31.028]  - future.globals: <name-value list> with names ‘list()’
[16:09:31.028]  - use_args: TRUE
[16:09:31.028] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:31.028] List of 2
[16:09:31.028]  $ ...          : list()
[16:09:31.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.028]  $ ...future.FUN:function (x)  
[16:09:31.028]  - attr(*, "where")=List of 2
[16:09:31.028]   ..$ ...          :<environment: 0x5633ae1662e0> 
[16:09:31.028]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:31.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.028]  - attr(*, "resolved")= logi FALSE
[16:09:31.028]  - attr(*, "total_size")= num NA
[16:09:31.034] Packages to be attached in all futures: [n=0] 
[16:09:31.034] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.034] Number of futures (= number of chunks): 2
[16:09:31.034] Launching 2 futures (chunks) ...
[16:09:31.034] Chunk #1 of 2 ...
[16:09:31.034]  - seeds: <none>
[16:09:31.034] getGlobalsAndPackages() ...
[16:09:31.034] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.035] Resolving globals: FALSE
[16:09:31.035] Tweak future expression to call with '...' arguments ...
[16:09:31.035] {
[16:09:31.035]     do.call(function(...) {
[16:09:31.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.035]             on.exit(options(oopts), add = TRUE)
[16:09:31.035]         }
[16:09:31.035]         {
[16:09:31.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.035]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.035]             })
[16:09:31.035]         }
[16:09:31.035]     }, args = future.call.arguments)
[16:09:31.035] }
[16:09:31.035] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.035] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.035] 
[16:09:31.036] getGlobalsAndPackages() ... DONE
[16:09:31.036] run() for ‘Future’ ...
[16:09:31.036] - state: ‘created’
[16:09:31.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:31.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:31.052]   - Field: ‘node’
[16:09:31.052]   - Field: ‘label’
[16:09:31.052]   - Field: ‘local’
[16:09:31.052]   - Field: ‘owner’
[16:09:31.052]   - Field: ‘envir’
[16:09:31.052]   - Field: ‘workers’
[16:09:31.052]   - Field: ‘packages’
[16:09:31.052]   - Field: ‘gc’
[16:09:31.053]   - Field: ‘conditions’
[16:09:31.053]   - Field: ‘persistent’
[16:09:31.053]   - Field: ‘expr’
[16:09:31.053]   - Field: ‘uuid’
[16:09:31.053]   - Field: ‘seed’
[16:09:31.053]   - Field: ‘version’
[16:09:31.053]   - Field: ‘result’
[16:09:31.053]   - Field: ‘asynchronous’
[16:09:31.053]   - Field: ‘calls’
[16:09:31.053]   - Field: ‘globals’
[16:09:31.053]   - Field: ‘stdout’
[16:09:31.053]   - Field: ‘earlySignal’
[16:09:31.054]   - Field: ‘lazy’
[16:09:31.054]   - Field: ‘state’
[16:09:31.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:31.054] - Launch lazy future ...
[16:09:31.054] Packages needed by the future expression (n = 0): <none>
[16:09:31.054] Packages needed by future strategies (n = 0): <none>
[16:09:31.055] {
[16:09:31.055]     {
[16:09:31.055]         {
[16:09:31.055]             ...future.startTime <- base::Sys.time()
[16:09:31.055]             {
[16:09:31.055]                 {
[16:09:31.055]                   {
[16:09:31.055]                     {
[16:09:31.055]                       base::local({
[16:09:31.055]                         has_future <- base::requireNamespace("future", 
[16:09:31.055]                           quietly = TRUE)
[16:09:31.055]                         if (has_future) {
[16:09:31.055]                           ns <- base::getNamespace("future")
[16:09:31.055]                           version <- ns[[".package"]][["version"]]
[16:09:31.055]                           if (is.null(version)) 
[16:09:31.055]                             version <- utils::packageVersion("future")
[16:09:31.055]                         }
[16:09:31.055]                         else {
[16:09:31.055]                           version <- NULL
[16:09:31.055]                         }
[16:09:31.055]                         if (!has_future || version < "1.8.0") {
[16:09:31.055]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.055]                             "", base::R.version$version.string), 
[16:09:31.055]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:31.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.055]                               "release", "version")], collapse = " "), 
[16:09:31.055]                             hostname = base::Sys.info()[["nodename"]])
[16:09:31.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.055]                             info)
[16:09:31.055]                           info <- base::paste(info, collapse = "; ")
[16:09:31.055]                           if (!has_future) {
[16:09:31.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.055]                               info)
[16:09:31.055]                           }
[16:09:31.055]                           else {
[16:09:31.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.055]                               info, version)
[16:09:31.055]                           }
[16:09:31.055]                           base::stop(msg)
[16:09:31.055]                         }
[16:09:31.055]                       })
[16:09:31.055]                     }
[16:09:31.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:31.055]                     base::options(mc.cores = 1L)
[16:09:31.055]                   }
[16:09:31.055]                   options(future.plan = NULL)
[16:09:31.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.055]                 }
[16:09:31.055]                 ...future.workdir <- getwd()
[16:09:31.055]             }
[16:09:31.055]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.055]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.055]         }
[16:09:31.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.055]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:31.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.055]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.055]             base::names(...future.oldOptions))
[16:09:31.055]     }
[16:09:31.055]     if (FALSE) {
[16:09:31.055]     }
[16:09:31.055]     else {
[16:09:31.055]         if (TRUE) {
[16:09:31.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.055]                 open = "w")
[16:09:31.055]         }
[16:09:31.055]         else {
[16:09:31.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.055]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.055]         }
[16:09:31.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.055]             base::sink(type = "output", split = FALSE)
[16:09:31.055]             base::close(...future.stdout)
[16:09:31.055]         }, add = TRUE)
[16:09:31.055]     }
[16:09:31.055]     ...future.frame <- base::sys.nframe()
[16:09:31.055]     ...future.conditions <- base::list()
[16:09:31.055]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.055]     if (FALSE) {
[16:09:31.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.055]     }
[16:09:31.055]     ...future.result <- base::tryCatch({
[16:09:31.055]         base::withCallingHandlers({
[16:09:31.055]             ...future.value <- base::withVisible(base::local({
[16:09:31.055]                 ...future.makeSendCondition <- local({
[16:09:31.055]                   sendCondition <- NULL
[16:09:31.055]                   function(frame = 1L) {
[16:09:31.055]                     if (is.function(sendCondition)) 
[16:09:31.055]                       return(sendCondition)
[16:09:31.055]                     ns <- getNamespace("parallel")
[16:09:31.055]                     if (exists("sendData", mode = "function", 
[16:09:31.055]                       envir = ns)) {
[16:09:31.055]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:31.055]                         envir = ns)
[16:09:31.055]                       envir <- sys.frame(frame)
[16:09:31.055]                       master <- NULL
[16:09:31.055]                       while (!identical(envir, .GlobalEnv) && 
[16:09:31.055]                         !identical(envir, emptyenv())) {
[16:09:31.055]                         if (exists("master", mode = "list", envir = envir, 
[16:09:31.055]                           inherits = FALSE)) {
[16:09:31.055]                           master <- get("master", mode = "list", 
[16:09:31.055]                             envir = envir, inherits = FALSE)
[16:09:31.055]                           if (inherits(master, c("SOCKnode", 
[16:09:31.055]                             "SOCK0node"))) {
[16:09:31.055]                             sendCondition <<- function(cond) {
[16:09:31.055]                               data <- list(type = "VALUE", value = cond, 
[16:09:31.055]                                 success = TRUE)
[16:09:31.055]                               parallel_sendData(master, data)
[16:09:31.055]                             }
[16:09:31.055]                             return(sendCondition)
[16:09:31.055]                           }
[16:09:31.055]                         }
[16:09:31.055]                         frame <- frame + 1L
[16:09:31.055]                         envir <- sys.frame(frame)
[16:09:31.055]                       }
[16:09:31.055]                     }
[16:09:31.055]                     sendCondition <<- function(cond) NULL
[16:09:31.055]                   }
[16:09:31.055]                 })
[16:09:31.055]                 withCallingHandlers({
[16:09:31.055]                   {
[16:09:31.055]                     do.call(function(...) {
[16:09:31.055]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.055]                       if (!identical(...future.globals.maxSize.org, 
[16:09:31.055]                         ...future.globals.maxSize)) {
[16:09:31.055]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.055]                         on.exit(options(oopts), add = TRUE)
[16:09:31.055]                       }
[16:09:31.055]                       {
[16:09:31.055]                         lapply(seq_along(...future.elements_ii), 
[16:09:31.055]                           FUN = function(jj) {
[16:09:31.055]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.055]                             ...future.FUN(...future.X_jj, ...)
[16:09:31.055]                           })
[16:09:31.055]                       }
[16:09:31.055]                     }, args = future.call.arguments)
[16:09:31.055]                   }
[16:09:31.055]                 }, immediateCondition = function(cond) {
[16:09:31.055]                   sendCondition <- ...future.makeSendCondition()
[16:09:31.055]                   sendCondition(cond)
[16:09:31.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.055]                   {
[16:09:31.055]                     inherits <- base::inherits
[16:09:31.055]                     invokeRestart <- base::invokeRestart
[16:09:31.055]                     is.null <- base::is.null
[16:09:31.055]                     muffled <- FALSE
[16:09:31.055]                     if (inherits(cond, "message")) {
[16:09:31.055]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:31.055]                       if (muffled) 
[16:09:31.055]                         invokeRestart("muffleMessage")
[16:09:31.055]                     }
[16:09:31.055]                     else if (inherits(cond, "warning")) {
[16:09:31.055]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:31.055]                       if (muffled) 
[16:09:31.055]                         invokeRestart("muffleWarning")
[16:09:31.055]                     }
[16:09:31.055]                     else if (inherits(cond, "condition")) {
[16:09:31.055]                       if (!is.null(pattern)) {
[16:09:31.055]                         computeRestarts <- base::computeRestarts
[16:09:31.055]                         grepl <- base::grepl
[16:09:31.055]                         restarts <- computeRestarts(cond)
[16:09:31.055]                         for (restart in restarts) {
[16:09:31.055]                           name <- restart$name
[16:09:31.055]                           if (is.null(name)) 
[16:09:31.055]                             next
[16:09:31.055]                           if (!grepl(pattern, name)) 
[16:09:31.055]                             next
[16:09:31.055]                           invokeRestart(restart)
[16:09:31.055]                           muffled <- TRUE
[16:09:31.055]                           break
[16:09:31.055]                         }
[16:09:31.055]                       }
[16:09:31.055]                     }
[16:09:31.055]                     invisible(muffled)
[16:09:31.055]                   }
[16:09:31.055]                   muffleCondition(cond)
[16:09:31.055]                 })
[16:09:31.055]             }))
[16:09:31.055]             future::FutureResult(value = ...future.value$value, 
[16:09:31.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.055]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.055]                     ...future.globalenv.names))
[16:09:31.055]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.055]         }, condition = base::local({
[16:09:31.055]             c <- base::c
[16:09:31.055]             inherits <- base::inherits
[16:09:31.055]             invokeRestart <- base::invokeRestart
[16:09:31.055]             length <- base::length
[16:09:31.055]             list <- base::list
[16:09:31.055]             seq.int <- base::seq.int
[16:09:31.055]             signalCondition <- base::signalCondition
[16:09:31.055]             sys.calls <- base::sys.calls
[16:09:31.055]             `[[` <- base::`[[`
[16:09:31.055]             `+` <- base::`+`
[16:09:31.055]             `<<-` <- base::`<<-`
[16:09:31.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.055]                   3L)]
[16:09:31.055]             }
[16:09:31.055]             function(cond) {
[16:09:31.055]                 is_error <- inherits(cond, "error")
[16:09:31.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.055]                   NULL)
[16:09:31.055]                 if (is_error) {
[16:09:31.055]                   sessionInformation <- function() {
[16:09:31.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.055]                       search = base::search(), system = base::Sys.info())
[16:09:31.055]                   }
[16:09:31.055]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.055]                     cond$call), session = sessionInformation(), 
[16:09:31.055]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.055]                   signalCondition(cond)
[16:09:31.055]                 }
[16:09:31.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:31.055]                 "immediateCondition"))) {
[16:09:31.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.055]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.055]                   if (TRUE && !signal) {
[16:09:31.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.055]                     {
[16:09:31.055]                       inherits <- base::inherits
[16:09:31.055]                       invokeRestart <- base::invokeRestart
[16:09:31.055]                       is.null <- base::is.null
[16:09:31.055]                       muffled <- FALSE
[16:09:31.055]                       if (inherits(cond, "message")) {
[16:09:31.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.055]                         if (muffled) 
[16:09:31.055]                           invokeRestart("muffleMessage")
[16:09:31.055]                       }
[16:09:31.055]                       else if (inherits(cond, "warning")) {
[16:09:31.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.055]                         if (muffled) 
[16:09:31.055]                           invokeRestart("muffleWarning")
[16:09:31.055]                       }
[16:09:31.055]                       else if (inherits(cond, "condition")) {
[16:09:31.055]                         if (!is.null(pattern)) {
[16:09:31.055]                           computeRestarts <- base::computeRestarts
[16:09:31.055]                           grepl <- base::grepl
[16:09:31.055]                           restarts <- computeRestarts(cond)
[16:09:31.055]                           for (restart in restarts) {
[16:09:31.055]                             name <- restart$name
[16:09:31.055]                             if (is.null(name)) 
[16:09:31.055]                               next
[16:09:31.055]                             if (!grepl(pattern, name)) 
[16:09:31.055]                               next
[16:09:31.055]                             invokeRestart(restart)
[16:09:31.055]                             muffled <- TRUE
[16:09:31.055]                             break
[16:09:31.055]                           }
[16:09:31.055]                         }
[16:09:31.055]                       }
[16:09:31.055]                       invisible(muffled)
[16:09:31.055]                     }
[16:09:31.055]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.055]                   }
[16:09:31.055]                 }
[16:09:31.055]                 else {
[16:09:31.055]                   if (TRUE) {
[16:09:31.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.055]                     {
[16:09:31.055]                       inherits <- base::inherits
[16:09:31.055]                       invokeRestart <- base::invokeRestart
[16:09:31.055]                       is.null <- base::is.null
[16:09:31.055]                       muffled <- FALSE
[16:09:31.055]                       if (inherits(cond, "message")) {
[16:09:31.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.055]                         if (muffled) 
[16:09:31.055]                           invokeRestart("muffleMessage")
[16:09:31.055]                       }
[16:09:31.055]                       else if (inherits(cond, "warning")) {
[16:09:31.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.055]                         if (muffled) 
[16:09:31.055]                           invokeRestart("muffleWarning")
[16:09:31.055]                       }
[16:09:31.055]                       else if (inherits(cond, "condition")) {
[16:09:31.055]                         if (!is.null(pattern)) {
[16:09:31.055]                           computeRestarts <- base::computeRestarts
[16:09:31.055]                           grepl <- base::grepl
[16:09:31.055]                           restarts <- computeRestarts(cond)
[16:09:31.055]                           for (restart in restarts) {
[16:09:31.055]                             name <- restart$name
[16:09:31.055]                             if (is.null(name)) 
[16:09:31.055]                               next
[16:09:31.055]                             if (!grepl(pattern, name)) 
[16:09:31.055]                               next
[16:09:31.055]                             invokeRestart(restart)
[16:09:31.055]                             muffled <- TRUE
[16:09:31.055]                             break
[16:09:31.055]                           }
[16:09:31.055]                         }
[16:09:31.055]                       }
[16:09:31.055]                       invisible(muffled)
[16:09:31.055]                     }
[16:09:31.055]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.055]                   }
[16:09:31.055]                 }
[16:09:31.055]             }
[16:09:31.055]         }))
[16:09:31.055]     }, error = function(ex) {
[16:09:31.055]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.055]                 ...future.rng), started = ...future.startTime, 
[16:09:31.055]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.055]             version = "1.8"), class = "FutureResult")
[16:09:31.055]     }, finally = {
[16:09:31.055]         if (!identical(...future.workdir, getwd())) 
[16:09:31.055]             setwd(...future.workdir)
[16:09:31.055]         {
[16:09:31.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.055]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.055]             }
[16:09:31.055]             base::options(...future.oldOptions)
[16:09:31.055]             if (.Platform$OS.type == "windows") {
[16:09:31.055]                 old_names <- names(...future.oldEnvVars)
[16:09:31.055]                 envs <- base::Sys.getenv()
[16:09:31.055]                 names <- names(envs)
[16:09:31.055]                 common <- intersect(names, old_names)
[16:09:31.055]                 added <- setdiff(names, old_names)
[16:09:31.055]                 removed <- setdiff(old_names, names)
[16:09:31.055]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.055]                   envs[common]]
[16:09:31.055]                 NAMES <- toupper(changed)
[16:09:31.055]                 args <- list()
[16:09:31.055]                 for (kk in seq_along(NAMES)) {
[16:09:31.055]                   name <- changed[[kk]]
[16:09:31.055]                   NAME <- NAMES[[kk]]
[16:09:31.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.055]                     next
[16:09:31.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.055]                 }
[16:09:31.055]                 NAMES <- toupper(added)
[16:09:31.055]                 for (kk in seq_along(NAMES)) {
[16:09:31.055]                   name <- added[[kk]]
[16:09:31.055]                   NAME <- NAMES[[kk]]
[16:09:31.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.055]                     next
[16:09:31.055]                   args[[name]] <- ""
[16:09:31.055]                 }
[16:09:31.055]                 NAMES <- toupper(removed)
[16:09:31.055]                 for (kk in seq_along(NAMES)) {
[16:09:31.055]                   name <- removed[[kk]]
[16:09:31.055]                   NAME <- NAMES[[kk]]
[16:09:31.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.055]                     next
[16:09:31.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.055]                 }
[16:09:31.055]                 if (length(args) > 0) 
[16:09:31.055]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.055]             }
[16:09:31.055]             else {
[16:09:31.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.055]             }
[16:09:31.055]             {
[16:09:31.055]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.055]                   0L) {
[16:09:31.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.055]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.055]                   base::options(opts)
[16:09:31.055]                 }
[16:09:31.055]                 {
[16:09:31.055]                   {
[16:09:31.055]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:31.055]                     NULL
[16:09:31.055]                   }
[16:09:31.055]                   options(future.plan = NULL)
[16:09:31.055]                   if (is.na(NA_character_)) 
[16:09:31.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.055]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:31.055]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:31.055]                     envir = parent.frame()) 
[16:09:31.055]                   {
[16:09:31.055]                     if (is.function(workers)) 
[16:09:31.055]                       workers <- workers()
[16:09:31.055]                     workers <- structure(as.integer(workers), 
[16:09:31.055]                       class = class(workers))
[16:09:31.055]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:31.055]                       workers >= 1)
[16:09:31.055]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:31.055]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:31.055]                     }
[16:09:31.055]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:31.055]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:31.055]                       envir = envir)
[16:09:31.055]                     if (!future$lazy) 
[16:09:31.055]                       future <- run(future)
[16:09:31.055]                     invisible(future)
[16:09:31.055]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.055]                 }
[16:09:31.055]             }
[16:09:31.055]         }
[16:09:31.055]     })
[16:09:31.055]     if (TRUE) {
[16:09:31.055]         base::sink(type = "output", split = FALSE)
[16:09:31.055]         if (TRUE) {
[16:09:31.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.055]         }
[16:09:31.055]         else {
[16:09:31.055]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.055]         }
[16:09:31.055]         base::close(...future.stdout)
[16:09:31.055]         ...future.stdout <- NULL
[16:09:31.055]     }
[16:09:31.055]     ...future.result$conditions <- ...future.conditions
[16:09:31.055]     ...future.result$finished <- base::Sys.time()
[16:09:31.055]     ...future.result
[16:09:31.055] }
[16:09:31.058] Exporting 5 global objects (1.07 KiB) to cluster node #1 ...
[16:09:31.058] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:31.058] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.058] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:09:31.059] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:09:31.059] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[16:09:31.059] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[16:09:31.059] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:31.060] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.060] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:31.060] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.060] Exporting 5 global objects (1.07 KiB) to cluster node #1 ... DONE
[16:09:31.061] MultisessionFuture started
[16:09:31.061] - Launch lazy future ... done
[16:09:31.061] run() for ‘MultisessionFuture’ ... done
[16:09:31.061] Created future:
[16:09:31.061] MultisessionFuture:
[16:09:31.061] Label: ‘future_apply-1’
[16:09:31.061] Expression:
[16:09:31.061] {
[16:09:31.061]     do.call(function(...) {
[16:09:31.061]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.061]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.061]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.061]             on.exit(options(oopts), add = TRUE)
[16:09:31.061]         }
[16:09:31.061]         {
[16:09:31.061]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.061]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.061]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.061]             })
[16:09:31.061]         }
[16:09:31.061]     }, args = future.call.arguments)
[16:09:31.061] }
[16:09:31.061] Lazy evaluation: FALSE
[16:09:31.061] Asynchronous evaluation: TRUE
[16:09:31.061] Local evaluation: TRUE
[16:09:31.061] Environment: R_GlobalEnv
[16:09:31.061] Capture standard output: TRUE
[16:09:31.061] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:31.061] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.061] Packages: <none>
[16:09:31.061] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:31.061] Resolved: FALSE
[16:09:31.061] Value: <not collected>
[16:09:31.061] Conditions captured: <none>
[16:09:31.061] Early signaling: FALSE
[16:09:31.061] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:31.061] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.073] Chunk #1 of 2 ... DONE
[16:09:31.073] Chunk #2 of 2 ...
[16:09:31.073]  - seeds: <none>
[16:09:31.073] getGlobalsAndPackages() ...
[16:09:31.073] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.073] Resolving globals: FALSE
[16:09:31.073] Tweak future expression to call with '...' arguments ...
[16:09:31.074] {
[16:09:31.074]     do.call(function(...) {
[16:09:31.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.074]             on.exit(options(oopts), add = TRUE)
[16:09:31.074]         }
[16:09:31.074]         {
[16:09:31.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.074]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.074]             })
[16:09:31.074]         }
[16:09:31.074]     }, args = future.call.arguments)
[16:09:31.074] }
[16:09:31.074] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.074] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.074] 
[16:09:31.074] getGlobalsAndPackages() ... DONE
[16:09:31.075] run() for ‘Future’ ...
[16:09:31.075] - state: ‘created’
[16:09:31.075] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:31.090] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:31.090]   - Field: ‘node’
[16:09:31.090]   - Field: ‘label’
[16:09:31.090]   - Field: ‘local’
[16:09:31.090]   - Field: ‘owner’
[16:09:31.090]   - Field: ‘envir’
[16:09:31.090]   - Field: ‘workers’
[16:09:31.091]   - Field: ‘packages’
[16:09:31.091]   - Field: ‘gc’
[16:09:31.091]   - Field: ‘conditions’
[16:09:31.091]   - Field: ‘persistent’
[16:09:31.091]   - Field: ‘expr’
[16:09:31.091]   - Field: ‘uuid’
[16:09:31.091]   - Field: ‘seed’
[16:09:31.091]   - Field: ‘version’
[16:09:31.091]   - Field: ‘result’
[16:09:31.091]   - Field: ‘asynchronous’
[16:09:31.092]   - Field: ‘calls’
[16:09:31.092]   - Field: ‘globals’
[16:09:31.092]   - Field: ‘stdout’
[16:09:31.092]   - Field: ‘earlySignal’
[16:09:31.092]   - Field: ‘lazy’
[16:09:31.092]   - Field: ‘state’
[16:09:31.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:31.092] - Launch lazy future ...
[16:09:31.092] Packages needed by the future expression (n = 0): <none>
[16:09:31.093] Packages needed by future strategies (n = 0): <none>
[16:09:31.093] {
[16:09:31.093]     {
[16:09:31.093]         {
[16:09:31.093]             ...future.startTime <- base::Sys.time()
[16:09:31.093]             {
[16:09:31.093]                 {
[16:09:31.093]                   {
[16:09:31.093]                     {
[16:09:31.093]                       base::local({
[16:09:31.093]                         has_future <- base::requireNamespace("future", 
[16:09:31.093]                           quietly = TRUE)
[16:09:31.093]                         if (has_future) {
[16:09:31.093]                           ns <- base::getNamespace("future")
[16:09:31.093]                           version <- ns[[".package"]][["version"]]
[16:09:31.093]                           if (is.null(version)) 
[16:09:31.093]                             version <- utils::packageVersion("future")
[16:09:31.093]                         }
[16:09:31.093]                         else {
[16:09:31.093]                           version <- NULL
[16:09:31.093]                         }
[16:09:31.093]                         if (!has_future || version < "1.8.0") {
[16:09:31.093]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.093]                             "", base::R.version$version.string), 
[16:09:31.093]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:31.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.093]                               "release", "version")], collapse = " "), 
[16:09:31.093]                             hostname = base::Sys.info()[["nodename"]])
[16:09:31.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.093]                             info)
[16:09:31.093]                           info <- base::paste(info, collapse = "; ")
[16:09:31.093]                           if (!has_future) {
[16:09:31.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.093]                               info)
[16:09:31.093]                           }
[16:09:31.093]                           else {
[16:09:31.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.093]                               info, version)
[16:09:31.093]                           }
[16:09:31.093]                           base::stop(msg)
[16:09:31.093]                         }
[16:09:31.093]                       })
[16:09:31.093]                     }
[16:09:31.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:31.093]                     base::options(mc.cores = 1L)
[16:09:31.093]                   }
[16:09:31.093]                   options(future.plan = NULL)
[16:09:31.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.093]                 }
[16:09:31.093]                 ...future.workdir <- getwd()
[16:09:31.093]             }
[16:09:31.093]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.093]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.093]         }
[16:09:31.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.093]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:31.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.093]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.093]             base::names(...future.oldOptions))
[16:09:31.093]     }
[16:09:31.093]     if (FALSE) {
[16:09:31.093]     }
[16:09:31.093]     else {
[16:09:31.093]         if (TRUE) {
[16:09:31.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.093]                 open = "w")
[16:09:31.093]         }
[16:09:31.093]         else {
[16:09:31.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.093]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.093]         }
[16:09:31.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.093]             base::sink(type = "output", split = FALSE)
[16:09:31.093]             base::close(...future.stdout)
[16:09:31.093]         }, add = TRUE)
[16:09:31.093]     }
[16:09:31.093]     ...future.frame <- base::sys.nframe()
[16:09:31.093]     ...future.conditions <- base::list()
[16:09:31.093]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.093]     if (FALSE) {
[16:09:31.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.093]     }
[16:09:31.093]     ...future.result <- base::tryCatch({
[16:09:31.093]         base::withCallingHandlers({
[16:09:31.093]             ...future.value <- base::withVisible(base::local({
[16:09:31.093]                 ...future.makeSendCondition <- local({
[16:09:31.093]                   sendCondition <- NULL
[16:09:31.093]                   function(frame = 1L) {
[16:09:31.093]                     if (is.function(sendCondition)) 
[16:09:31.093]                       return(sendCondition)
[16:09:31.093]                     ns <- getNamespace("parallel")
[16:09:31.093]                     if (exists("sendData", mode = "function", 
[16:09:31.093]                       envir = ns)) {
[16:09:31.093]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:31.093]                         envir = ns)
[16:09:31.093]                       envir <- sys.frame(frame)
[16:09:31.093]                       master <- NULL
[16:09:31.093]                       while (!identical(envir, .GlobalEnv) && 
[16:09:31.093]                         !identical(envir, emptyenv())) {
[16:09:31.093]                         if (exists("master", mode = "list", envir = envir, 
[16:09:31.093]                           inherits = FALSE)) {
[16:09:31.093]                           master <- get("master", mode = "list", 
[16:09:31.093]                             envir = envir, inherits = FALSE)
[16:09:31.093]                           if (inherits(master, c("SOCKnode", 
[16:09:31.093]                             "SOCK0node"))) {
[16:09:31.093]                             sendCondition <<- function(cond) {
[16:09:31.093]                               data <- list(type = "VALUE", value = cond, 
[16:09:31.093]                                 success = TRUE)
[16:09:31.093]                               parallel_sendData(master, data)
[16:09:31.093]                             }
[16:09:31.093]                             return(sendCondition)
[16:09:31.093]                           }
[16:09:31.093]                         }
[16:09:31.093]                         frame <- frame + 1L
[16:09:31.093]                         envir <- sys.frame(frame)
[16:09:31.093]                       }
[16:09:31.093]                     }
[16:09:31.093]                     sendCondition <<- function(cond) NULL
[16:09:31.093]                   }
[16:09:31.093]                 })
[16:09:31.093]                 withCallingHandlers({
[16:09:31.093]                   {
[16:09:31.093]                     do.call(function(...) {
[16:09:31.093]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.093]                       if (!identical(...future.globals.maxSize.org, 
[16:09:31.093]                         ...future.globals.maxSize)) {
[16:09:31.093]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.093]                         on.exit(options(oopts), add = TRUE)
[16:09:31.093]                       }
[16:09:31.093]                       {
[16:09:31.093]                         lapply(seq_along(...future.elements_ii), 
[16:09:31.093]                           FUN = function(jj) {
[16:09:31.093]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.093]                             ...future.FUN(...future.X_jj, ...)
[16:09:31.093]                           })
[16:09:31.093]                       }
[16:09:31.093]                     }, args = future.call.arguments)
[16:09:31.093]                   }
[16:09:31.093]                 }, immediateCondition = function(cond) {
[16:09:31.093]                   sendCondition <- ...future.makeSendCondition()
[16:09:31.093]                   sendCondition(cond)
[16:09:31.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.093]                   {
[16:09:31.093]                     inherits <- base::inherits
[16:09:31.093]                     invokeRestart <- base::invokeRestart
[16:09:31.093]                     is.null <- base::is.null
[16:09:31.093]                     muffled <- FALSE
[16:09:31.093]                     if (inherits(cond, "message")) {
[16:09:31.093]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:31.093]                       if (muffled) 
[16:09:31.093]                         invokeRestart("muffleMessage")
[16:09:31.093]                     }
[16:09:31.093]                     else if (inherits(cond, "warning")) {
[16:09:31.093]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:31.093]                       if (muffled) 
[16:09:31.093]                         invokeRestart("muffleWarning")
[16:09:31.093]                     }
[16:09:31.093]                     else if (inherits(cond, "condition")) {
[16:09:31.093]                       if (!is.null(pattern)) {
[16:09:31.093]                         computeRestarts <- base::computeRestarts
[16:09:31.093]                         grepl <- base::grepl
[16:09:31.093]                         restarts <- computeRestarts(cond)
[16:09:31.093]                         for (restart in restarts) {
[16:09:31.093]                           name <- restart$name
[16:09:31.093]                           if (is.null(name)) 
[16:09:31.093]                             next
[16:09:31.093]                           if (!grepl(pattern, name)) 
[16:09:31.093]                             next
[16:09:31.093]                           invokeRestart(restart)
[16:09:31.093]                           muffled <- TRUE
[16:09:31.093]                           break
[16:09:31.093]                         }
[16:09:31.093]                       }
[16:09:31.093]                     }
[16:09:31.093]                     invisible(muffled)
[16:09:31.093]                   }
[16:09:31.093]                   muffleCondition(cond)
[16:09:31.093]                 })
[16:09:31.093]             }))
[16:09:31.093]             future::FutureResult(value = ...future.value$value, 
[16:09:31.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.093]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.093]                     ...future.globalenv.names))
[16:09:31.093]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.093]         }, condition = base::local({
[16:09:31.093]             c <- base::c
[16:09:31.093]             inherits <- base::inherits
[16:09:31.093]             invokeRestart <- base::invokeRestart
[16:09:31.093]             length <- base::length
[16:09:31.093]             list <- base::list
[16:09:31.093]             seq.int <- base::seq.int
[16:09:31.093]             signalCondition <- base::signalCondition
[16:09:31.093]             sys.calls <- base::sys.calls
[16:09:31.093]             `[[` <- base::`[[`
[16:09:31.093]             `+` <- base::`+`
[16:09:31.093]             `<<-` <- base::`<<-`
[16:09:31.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.093]                   3L)]
[16:09:31.093]             }
[16:09:31.093]             function(cond) {
[16:09:31.093]                 is_error <- inherits(cond, "error")
[16:09:31.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.093]                   NULL)
[16:09:31.093]                 if (is_error) {
[16:09:31.093]                   sessionInformation <- function() {
[16:09:31.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.093]                       search = base::search(), system = base::Sys.info())
[16:09:31.093]                   }
[16:09:31.093]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.093]                     cond$call), session = sessionInformation(), 
[16:09:31.093]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.093]                   signalCondition(cond)
[16:09:31.093]                 }
[16:09:31.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:31.093]                 "immediateCondition"))) {
[16:09:31.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.093]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.093]                   if (TRUE && !signal) {
[16:09:31.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.093]                     {
[16:09:31.093]                       inherits <- base::inherits
[16:09:31.093]                       invokeRestart <- base::invokeRestart
[16:09:31.093]                       is.null <- base::is.null
[16:09:31.093]                       muffled <- FALSE
[16:09:31.093]                       if (inherits(cond, "message")) {
[16:09:31.093]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.093]                         if (muffled) 
[16:09:31.093]                           invokeRestart("muffleMessage")
[16:09:31.093]                       }
[16:09:31.093]                       else if (inherits(cond, "warning")) {
[16:09:31.093]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.093]                         if (muffled) 
[16:09:31.093]                           invokeRestart("muffleWarning")
[16:09:31.093]                       }
[16:09:31.093]                       else if (inherits(cond, "condition")) {
[16:09:31.093]                         if (!is.null(pattern)) {
[16:09:31.093]                           computeRestarts <- base::computeRestarts
[16:09:31.093]                           grepl <- base::grepl
[16:09:31.093]                           restarts <- computeRestarts(cond)
[16:09:31.093]                           for (restart in restarts) {
[16:09:31.093]                             name <- restart$name
[16:09:31.093]                             if (is.null(name)) 
[16:09:31.093]                               next
[16:09:31.093]                             if (!grepl(pattern, name)) 
[16:09:31.093]                               next
[16:09:31.093]                             invokeRestart(restart)
[16:09:31.093]                             muffled <- TRUE
[16:09:31.093]                             break
[16:09:31.093]                           }
[16:09:31.093]                         }
[16:09:31.093]                       }
[16:09:31.093]                       invisible(muffled)
[16:09:31.093]                     }
[16:09:31.093]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.093]                   }
[16:09:31.093]                 }
[16:09:31.093]                 else {
[16:09:31.093]                   if (TRUE) {
[16:09:31.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.093]                     {
[16:09:31.093]                       inherits <- base::inherits
[16:09:31.093]                       invokeRestart <- base::invokeRestart
[16:09:31.093]                       is.null <- base::is.null
[16:09:31.093]                       muffled <- FALSE
[16:09:31.093]                       if (inherits(cond, "message")) {
[16:09:31.093]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.093]                         if (muffled) 
[16:09:31.093]                           invokeRestart("muffleMessage")
[16:09:31.093]                       }
[16:09:31.093]                       else if (inherits(cond, "warning")) {
[16:09:31.093]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.093]                         if (muffled) 
[16:09:31.093]                           invokeRestart("muffleWarning")
[16:09:31.093]                       }
[16:09:31.093]                       else if (inherits(cond, "condition")) {
[16:09:31.093]                         if (!is.null(pattern)) {
[16:09:31.093]                           computeRestarts <- base::computeRestarts
[16:09:31.093]                           grepl <- base::grepl
[16:09:31.093]                           restarts <- computeRestarts(cond)
[16:09:31.093]                           for (restart in restarts) {
[16:09:31.093]                             name <- restart$name
[16:09:31.093]                             if (is.null(name)) 
[16:09:31.093]                               next
[16:09:31.093]                             if (!grepl(pattern, name)) 
[16:09:31.093]                               next
[16:09:31.093]                             invokeRestart(restart)
[16:09:31.093]                             muffled <- TRUE
[16:09:31.093]                             break
[16:09:31.093]                           }
[16:09:31.093]                         }
[16:09:31.093]                       }
[16:09:31.093]                       invisible(muffled)
[16:09:31.093]                     }
[16:09:31.093]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.093]                   }
[16:09:31.093]                 }
[16:09:31.093]             }
[16:09:31.093]         }))
[16:09:31.093]     }, error = function(ex) {
[16:09:31.093]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.093]                 ...future.rng), started = ...future.startTime, 
[16:09:31.093]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.093]             version = "1.8"), class = "FutureResult")
[16:09:31.093]     }, finally = {
[16:09:31.093]         if (!identical(...future.workdir, getwd())) 
[16:09:31.093]             setwd(...future.workdir)
[16:09:31.093]         {
[16:09:31.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.093]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.093]             }
[16:09:31.093]             base::options(...future.oldOptions)
[16:09:31.093]             if (.Platform$OS.type == "windows") {
[16:09:31.093]                 old_names <- names(...future.oldEnvVars)
[16:09:31.093]                 envs <- base::Sys.getenv()
[16:09:31.093]                 names <- names(envs)
[16:09:31.093]                 common <- intersect(names, old_names)
[16:09:31.093]                 added <- setdiff(names, old_names)
[16:09:31.093]                 removed <- setdiff(old_names, names)
[16:09:31.093]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.093]                   envs[common]]
[16:09:31.093]                 NAMES <- toupper(changed)
[16:09:31.093]                 args <- list()
[16:09:31.093]                 for (kk in seq_along(NAMES)) {
[16:09:31.093]                   name <- changed[[kk]]
[16:09:31.093]                   NAME <- NAMES[[kk]]
[16:09:31.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.093]                     next
[16:09:31.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.093]                 }
[16:09:31.093]                 NAMES <- toupper(added)
[16:09:31.093]                 for (kk in seq_along(NAMES)) {
[16:09:31.093]                   name <- added[[kk]]
[16:09:31.093]                   NAME <- NAMES[[kk]]
[16:09:31.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.093]                     next
[16:09:31.093]                   args[[name]] <- ""
[16:09:31.093]                 }
[16:09:31.093]                 NAMES <- toupper(removed)
[16:09:31.093]                 for (kk in seq_along(NAMES)) {
[16:09:31.093]                   name <- removed[[kk]]
[16:09:31.093]                   NAME <- NAMES[[kk]]
[16:09:31.093]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.093]                     next
[16:09:31.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.093]                 }
[16:09:31.093]                 if (length(args) > 0) 
[16:09:31.093]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.093]             }
[16:09:31.093]             else {
[16:09:31.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.093]             }
[16:09:31.093]             {
[16:09:31.093]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.093]                   0L) {
[16:09:31.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.093]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.093]                   base::options(opts)
[16:09:31.093]                 }
[16:09:31.093]                 {
[16:09:31.093]                   {
[16:09:31.093]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:31.093]                     NULL
[16:09:31.093]                   }
[16:09:31.093]                   options(future.plan = NULL)
[16:09:31.093]                   if (is.na(NA_character_)) 
[16:09:31.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.093]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:31.093]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:31.093]                     envir = parent.frame()) 
[16:09:31.093]                   {
[16:09:31.093]                     if (is.function(workers)) 
[16:09:31.093]                       workers <- workers()
[16:09:31.093]                     workers <- structure(as.integer(workers), 
[16:09:31.093]                       class = class(workers))
[16:09:31.093]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:31.093]                       workers >= 1)
[16:09:31.093]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:31.093]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:31.093]                     }
[16:09:31.093]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:31.093]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:31.093]                       envir = envir)
[16:09:31.093]                     if (!future$lazy) 
[16:09:31.093]                       future <- run(future)
[16:09:31.093]                     invisible(future)
[16:09:31.093]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.093]                 }
[16:09:31.093]             }
[16:09:31.093]         }
[16:09:31.093]     })
[16:09:31.093]     if (TRUE) {
[16:09:31.093]         base::sink(type = "output", split = FALSE)
[16:09:31.093]         if (TRUE) {
[16:09:31.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.093]         }
[16:09:31.093]         else {
[16:09:31.093]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.093]         }
[16:09:31.093]         base::close(...future.stdout)
[16:09:31.093]         ...future.stdout <- NULL
[16:09:31.093]     }
[16:09:31.093]     ...future.result$conditions <- ...future.conditions
[16:09:31.093]     ...future.result$finished <- base::Sys.time()
[16:09:31.093]     ...future.result
[16:09:31.093] }
[16:09:31.096] Exporting 5 global objects (1.07 KiB) to cluster node #2 ...
[16:09:31.096] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:31.097] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.097] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:09:31.097] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:09:31.097] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[16:09:31.098] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[16:09:31.098] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:31.098] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.098] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:31.099] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.099] Exporting 5 global objects (1.07 KiB) to cluster node #2 ... DONE
[16:09:31.099] MultisessionFuture started
[16:09:31.099] - Launch lazy future ... done
[16:09:31.100] run() for ‘MultisessionFuture’ ... done
[16:09:31.100] Created future:
[16:09:31.100] MultisessionFuture:
[16:09:31.100] Label: ‘future_apply-2’
[16:09:31.100] Expression:
[16:09:31.100] {
[16:09:31.100]     do.call(function(...) {
[16:09:31.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.100]             on.exit(options(oopts), add = TRUE)
[16:09:31.100]         }
[16:09:31.100]         {
[16:09:31.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.100]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.100]             })
[16:09:31.100]         }
[16:09:31.100]     }, args = future.call.arguments)
[16:09:31.100] }
[16:09:31.100] Lazy evaluation: FALSE
[16:09:31.100] Asynchronous evaluation: TRUE
[16:09:31.100] Local evaluation: TRUE
[16:09:31.100] Environment: R_GlobalEnv
[16:09:31.100] Capture standard output: TRUE
[16:09:31.100] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:31.100] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.100] Packages: <none>
[16:09:31.100] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:31.100] Resolved: FALSE
[16:09:31.100] Value: <not collected>
[16:09:31.100] Conditions captured: <none>
[16:09:31.100] Early signaling: FALSE
[16:09:31.100] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:31.100] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.111] Chunk #2 of 2 ... DONE
[16:09:31.112] Launching 2 futures (chunks) ... DONE
[16:09:31.112] Resolving 2 futures (chunks) ...
[16:09:31.112] resolve() on list ...
[16:09:31.112]  recursive: 0
[16:09:31.112]  length: 2
[16:09:31.112] 
[16:09:31.112] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.113] - Validating connection of MultisessionFuture
[16:09:31.113] - received message: FutureResult
[16:09:31.113] - Received FutureResult
[16:09:31.113] - Erased future from FutureRegistry
[16:09:31.113] result() for ClusterFuture ...
[16:09:31.113] - result already collected: FutureResult
[16:09:31.113] result() for ClusterFuture ... done
[16:09:31.113] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.113] Future #1
[16:09:31.114] result() for ClusterFuture ...
[16:09:31.114] - result already collected: FutureResult
[16:09:31.114] result() for ClusterFuture ... done
[16:09:31.114] result() for ClusterFuture ...
[16:09:31.114] - result already collected: FutureResult
[16:09:31.114] result() for ClusterFuture ... done
[16:09:31.114] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:31.114] - nx: 2
[16:09:31.114] - relay: TRUE
[16:09:31.114] - stdout: TRUE
[16:09:31.114] - signal: TRUE
[16:09:31.114] - resignal: FALSE
[16:09:31.115] - force: TRUE
[16:09:31.115] - relayed: [n=2] FALSE, FALSE
[16:09:31.115] - queued futures: [n=2] FALSE, FALSE
[16:09:31.115]  - until=1
[16:09:31.115]  - relaying element #1
[16:09:31.115] result() for ClusterFuture ...
[16:09:31.115] - result already collected: FutureResult
[16:09:31.115] result() for ClusterFuture ... done
[16:09:31.115] result() for ClusterFuture ...
[16:09:31.115] - result already collected: FutureResult
[16:09:31.115] result() for ClusterFuture ... done
[16:09:31.116] result() for ClusterFuture ...
[16:09:31.116] - result already collected: FutureResult
[16:09:31.116] result() for ClusterFuture ... done
[16:09:31.116] result() for ClusterFuture ...
[16:09:31.116] - result already collected: FutureResult
[16:09:31.116] result() for ClusterFuture ... done
[16:09:31.116] - relayed: [n=2] TRUE, FALSE
[16:09:31.116] - queued futures: [n=2] TRUE, FALSE
[16:09:31.116] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:31.116]  length: 1 (resolved future 1)
[16:09:31.144] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.144] - Validating connection of MultisessionFuture
[16:09:31.145] - received message: FutureResult
[16:09:31.145] - Received FutureResult
[16:09:31.145] - Erased future from FutureRegistry
[16:09:31.145] result() for ClusterFuture ...
[16:09:31.145] - result already collected: FutureResult
[16:09:31.145] result() for ClusterFuture ... done
[16:09:31.145] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.145] Future #2
[16:09:31.145] result() for ClusterFuture ...
[16:09:31.146] - result already collected: FutureResult
[16:09:31.146] result() for ClusterFuture ... done
[16:09:31.146] result() for ClusterFuture ...
[16:09:31.146] - result already collected: FutureResult
[16:09:31.146] result() for ClusterFuture ... done
[16:09:31.146] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:31.146] - nx: 2
[16:09:31.146] - relay: TRUE
[16:09:31.146] - stdout: TRUE
[16:09:31.146] - signal: TRUE
[16:09:31.146] - resignal: FALSE
[16:09:31.146] - force: TRUE
[16:09:31.147] - relayed: [n=2] TRUE, FALSE
[16:09:31.147] - queued futures: [n=2] TRUE, FALSE
[16:09:31.147]  - until=2
[16:09:31.147]  - relaying element #2
[16:09:31.147] result() for ClusterFuture ...
[16:09:31.147] - result already collected: FutureResult
[16:09:31.147] result() for ClusterFuture ... done
[16:09:31.147] result() for ClusterFuture ...
[16:09:31.147] - result already collected: FutureResult
[16:09:31.147] result() for ClusterFuture ... done
[16:09:31.147] result() for ClusterFuture ...
[16:09:31.148] - result already collected: FutureResult
[16:09:31.148] result() for ClusterFuture ... done
[16:09:31.148] result() for ClusterFuture ...
[16:09:31.148] - result already collected: FutureResult
[16:09:31.148] result() for ClusterFuture ... done
[16:09:31.148] - relayed: [n=2] TRUE, TRUE
[16:09:31.148] - queued futures: [n=2] TRUE, TRUE
[16:09:31.148] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:31.148]  length: 0 (resolved future 2)
[16:09:31.148] Relaying remaining futures
[16:09:31.149] signalConditionsASAP(NULL, pos=0) ...
[16:09:31.149] - nx: 2
[16:09:31.149] - relay: TRUE
[16:09:31.149] - stdout: TRUE
[16:09:31.149] - signal: TRUE
[16:09:31.149] - resignal: FALSE
[16:09:31.149] - force: TRUE
[16:09:31.149] - relayed: [n=2] TRUE, TRUE
[16:09:31.149] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:31.149] - relayed: [n=2] TRUE, TRUE
[16:09:31.149] - queued futures: [n=2] TRUE, TRUE
[16:09:31.150] signalConditionsASAP(NULL, pos=0) ... done
[16:09:31.150] resolve() on list ... DONE
[16:09:31.150] result() for ClusterFuture ...
[16:09:31.150] - result already collected: FutureResult
[16:09:31.150] result() for ClusterFuture ... done
[16:09:31.150] result() for ClusterFuture ...
[16:09:31.150] - result already collected: FutureResult
[16:09:31.150] result() for ClusterFuture ... done
[16:09:31.150] result() for ClusterFuture ...
[16:09:31.150] - result already collected: FutureResult
[16:09:31.150] result() for ClusterFuture ... done
[16:09:31.151] result() for ClusterFuture ...
[16:09:31.151] - result already collected: FutureResult
[16:09:31.151] result() for ClusterFuture ... done
[16:09:31.151]  - Number of value chunks collected: 2
[16:09:31.151] Resolving 2 futures (chunks) ... DONE
[16:09:31.151] Reducing values from 2 chunks ...
[16:09:31.151]  - Number of values collected after concatenation: 2
[16:09:31.151]  - Number of values expected: 2
[16:09:31.151] Reducing values from 2 chunks ... DONE
[16:09:31.151] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:09:31.152] getGlobalsAndPackagesXApply() ...
[16:09:31.152]  - future.globals: TRUE
[16:09:31.152] getGlobalsAndPackages() ...
[16:09:31.152] Searching for globals...
[16:09:31.154] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:09:31.154] Searching for globals ... DONE
[16:09:31.155] Resolving globals: FALSE
[16:09:31.155] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:09:31.155] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:09:31.156] - globals: [1] ‘FUN’
[16:09:31.156] 
[16:09:31.156] getGlobalsAndPackages() ... DONE
[16:09:31.156]  - globals found/used: [n=1] ‘FUN’
[16:09:31.156]  - needed namespaces: [n=0] 
[16:09:31.156] Finding globals ... DONE
[16:09:31.156]  - use_args: TRUE
[16:09:31.156]  - Getting '...' globals ...
[16:09:31.157] resolve() on list ...
[16:09:31.157]  recursive: 0
[16:09:31.157]  length: 1
[16:09:31.157]  elements: ‘...’
[16:09:31.157]  length: 0 (resolved future 1)
[16:09:31.157] resolve() on list ... DONE
[16:09:31.157]    - '...' content: [n=0] 
[16:09:31.157] List of 1
[16:09:31.157]  $ ...: list()
[16:09:31.157]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.157]  - attr(*, "where")=List of 1
[16:09:31.157]   ..$ ...:<environment: 0x5633ad933fd8> 
[16:09:31.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.157]  - attr(*, "resolved")= logi TRUE
[16:09:31.157]  - attr(*, "total_size")= num NA
[16:09:31.160]  - Getting '...' globals ... DONE
[16:09:31.160] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:31.160] List of 2
[16:09:31.160]  $ ...future.FUN:function (x)  
[16:09:31.160]  $ ...          : list()
[16:09:31.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.160]  - attr(*, "where")=List of 2
[16:09:31.160]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:31.160]   ..$ ...          :<environment: 0x5633ad933fd8> 
[16:09:31.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.160]  - attr(*, "resolved")= logi FALSE
[16:09:31.160]  - attr(*, "total_size")= num 9888
[16:09:31.163] Packages to be attached in all futures: [n=0] 
[16:09:31.163] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.166] future_lapply() ...
[16:09:31.171] Number of chunks: 2
[16:09:31.171] getGlobalsAndPackagesXApply() ...
[16:09:31.171]  - future.globals: <name-value list> with names ‘list()’
[16:09:31.172]  - use_args: TRUE
[16:09:31.172] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:31.172] List of 2
[16:09:31.172]  $ ...          : list()
[16:09:31.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.172]  $ ...future.FUN:function (x)  
[16:09:31.172]  - attr(*, "where")=List of 2
[16:09:31.172]   ..$ ...          :<environment: 0x5633ad933fd8> 
[16:09:31.172]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:09:31.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.172]  - attr(*, "resolved")= logi FALSE
[16:09:31.172]  - attr(*, "total_size")= num NA
[16:09:31.174] Packages to be attached in all futures: [n=0] 
[16:09:31.175] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.175] Number of futures (= number of chunks): 2
[16:09:31.175] Launching 2 futures (chunks) ...
[16:09:31.175] Chunk #1 of 2 ...
[16:09:31.175]  - seeds: <none>
[16:09:31.175] getGlobalsAndPackages() ...
[16:09:31.175] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.175] Resolving globals: FALSE
[16:09:31.175] Tweak future expression to call with '...' arguments ...
[16:09:31.176] {
[16:09:31.176]     do.call(function(...) {
[16:09:31.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.176]             on.exit(options(oopts), add = TRUE)
[16:09:31.176]         }
[16:09:31.176]         {
[16:09:31.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.176]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.176]             })
[16:09:31.176]         }
[16:09:31.176]     }, args = future.call.arguments)
[16:09:31.176] }
[16:09:31.176] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.176] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.176] 
[16:09:31.176] getGlobalsAndPackages() ... DONE
[16:09:31.177] run() for ‘Future’ ...
[16:09:31.177] - state: ‘created’
[16:09:31.177] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:31.191] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:31.191]   - Field: ‘node’
[16:09:31.192]   - Field: ‘label’
[16:09:31.192]   - Field: ‘local’
[16:09:31.192]   - Field: ‘owner’
[16:09:31.192]   - Field: ‘envir’
[16:09:31.192]   - Field: ‘workers’
[16:09:31.192]   - Field: ‘packages’
[16:09:31.192]   - Field: ‘gc’
[16:09:31.192]   - Field: ‘conditions’
[16:09:31.192]   - Field: ‘persistent’
[16:09:31.192]   - Field: ‘expr’
[16:09:31.193]   - Field: ‘uuid’
[16:09:31.193]   - Field: ‘seed’
[16:09:31.193]   - Field: ‘version’
[16:09:31.193]   - Field: ‘result’
[16:09:31.193]   - Field: ‘asynchronous’
[16:09:31.193]   - Field: ‘calls’
[16:09:31.193]   - Field: ‘globals’
[16:09:31.193]   - Field: ‘stdout’
[16:09:31.193]   - Field: ‘earlySignal’
[16:09:31.193]   - Field: ‘lazy’
[16:09:31.193]   - Field: ‘state’
[16:09:31.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:31.194] - Launch lazy future ...
[16:09:31.194] Packages needed by the future expression (n = 0): <none>
[16:09:31.194] Packages needed by future strategies (n = 0): <none>
[16:09:31.194] {
[16:09:31.194]     {
[16:09:31.194]         {
[16:09:31.194]             ...future.startTime <- base::Sys.time()
[16:09:31.194]             {
[16:09:31.194]                 {
[16:09:31.194]                   {
[16:09:31.194]                     {
[16:09:31.194]                       base::local({
[16:09:31.194]                         has_future <- base::requireNamespace("future", 
[16:09:31.194]                           quietly = TRUE)
[16:09:31.194]                         if (has_future) {
[16:09:31.194]                           ns <- base::getNamespace("future")
[16:09:31.194]                           version <- ns[[".package"]][["version"]]
[16:09:31.194]                           if (is.null(version)) 
[16:09:31.194]                             version <- utils::packageVersion("future")
[16:09:31.194]                         }
[16:09:31.194]                         else {
[16:09:31.194]                           version <- NULL
[16:09:31.194]                         }
[16:09:31.194]                         if (!has_future || version < "1.8.0") {
[16:09:31.194]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.194]                             "", base::R.version$version.string), 
[16:09:31.194]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:31.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.194]                               "release", "version")], collapse = " "), 
[16:09:31.194]                             hostname = base::Sys.info()[["nodename"]])
[16:09:31.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.194]                             info)
[16:09:31.194]                           info <- base::paste(info, collapse = "; ")
[16:09:31.194]                           if (!has_future) {
[16:09:31.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.194]                               info)
[16:09:31.194]                           }
[16:09:31.194]                           else {
[16:09:31.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.194]                               info, version)
[16:09:31.194]                           }
[16:09:31.194]                           base::stop(msg)
[16:09:31.194]                         }
[16:09:31.194]                       })
[16:09:31.194]                     }
[16:09:31.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:31.194]                     base::options(mc.cores = 1L)
[16:09:31.194]                   }
[16:09:31.194]                   options(future.plan = NULL)
[16:09:31.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.194]                 }
[16:09:31.194]                 ...future.workdir <- getwd()
[16:09:31.194]             }
[16:09:31.194]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.194]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.194]         }
[16:09:31.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.194]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:31.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.194]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.194]             base::names(...future.oldOptions))
[16:09:31.194]     }
[16:09:31.194]     if (FALSE) {
[16:09:31.194]     }
[16:09:31.194]     else {
[16:09:31.194]         if (TRUE) {
[16:09:31.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.194]                 open = "w")
[16:09:31.194]         }
[16:09:31.194]         else {
[16:09:31.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.194]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.194]         }
[16:09:31.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.194]             base::sink(type = "output", split = FALSE)
[16:09:31.194]             base::close(...future.stdout)
[16:09:31.194]         }, add = TRUE)
[16:09:31.194]     }
[16:09:31.194]     ...future.frame <- base::sys.nframe()
[16:09:31.194]     ...future.conditions <- base::list()
[16:09:31.194]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.194]     if (FALSE) {
[16:09:31.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.194]     }
[16:09:31.194]     ...future.result <- base::tryCatch({
[16:09:31.194]         base::withCallingHandlers({
[16:09:31.194]             ...future.value <- base::withVisible(base::local({
[16:09:31.194]                 ...future.makeSendCondition <- local({
[16:09:31.194]                   sendCondition <- NULL
[16:09:31.194]                   function(frame = 1L) {
[16:09:31.194]                     if (is.function(sendCondition)) 
[16:09:31.194]                       return(sendCondition)
[16:09:31.194]                     ns <- getNamespace("parallel")
[16:09:31.194]                     if (exists("sendData", mode = "function", 
[16:09:31.194]                       envir = ns)) {
[16:09:31.194]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:31.194]                         envir = ns)
[16:09:31.194]                       envir <- sys.frame(frame)
[16:09:31.194]                       master <- NULL
[16:09:31.194]                       while (!identical(envir, .GlobalEnv) && 
[16:09:31.194]                         !identical(envir, emptyenv())) {
[16:09:31.194]                         if (exists("master", mode = "list", envir = envir, 
[16:09:31.194]                           inherits = FALSE)) {
[16:09:31.194]                           master <- get("master", mode = "list", 
[16:09:31.194]                             envir = envir, inherits = FALSE)
[16:09:31.194]                           if (inherits(master, c("SOCKnode", 
[16:09:31.194]                             "SOCK0node"))) {
[16:09:31.194]                             sendCondition <<- function(cond) {
[16:09:31.194]                               data <- list(type = "VALUE", value = cond, 
[16:09:31.194]                                 success = TRUE)
[16:09:31.194]                               parallel_sendData(master, data)
[16:09:31.194]                             }
[16:09:31.194]                             return(sendCondition)
[16:09:31.194]                           }
[16:09:31.194]                         }
[16:09:31.194]                         frame <- frame + 1L
[16:09:31.194]                         envir <- sys.frame(frame)
[16:09:31.194]                       }
[16:09:31.194]                     }
[16:09:31.194]                     sendCondition <<- function(cond) NULL
[16:09:31.194]                   }
[16:09:31.194]                 })
[16:09:31.194]                 withCallingHandlers({
[16:09:31.194]                   {
[16:09:31.194]                     do.call(function(...) {
[16:09:31.194]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.194]                       if (!identical(...future.globals.maxSize.org, 
[16:09:31.194]                         ...future.globals.maxSize)) {
[16:09:31.194]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.194]                         on.exit(options(oopts), add = TRUE)
[16:09:31.194]                       }
[16:09:31.194]                       {
[16:09:31.194]                         lapply(seq_along(...future.elements_ii), 
[16:09:31.194]                           FUN = function(jj) {
[16:09:31.194]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.194]                             ...future.FUN(...future.X_jj, ...)
[16:09:31.194]                           })
[16:09:31.194]                       }
[16:09:31.194]                     }, args = future.call.arguments)
[16:09:31.194]                   }
[16:09:31.194]                 }, immediateCondition = function(cond) {
[16:09:31.194]                   sendCondition <- ...future.makeSendCondition()
[16:09:31.194]                   sendCondition(cond)
[16:09:31.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.194]                   {
[16:09:31.194]                     inherits <- base::inherits
[16:09:31.194]                     invokeRestart <- base::invokeRestart
[16:09:31.194]                     is.null <- base::is.null
[16:09:31.194]                     muffled <- FALSE
[16:09:31.194]                     if (inherits(cond, "message")) {
[16:09:31.194]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:31.194]                       if (muffled) 
[16:09:31.194]                         invokeRestart("muffleMessage")
[16:09:31.194]                     }
[16:09:31.194]                     else if (inherits(cond, "warning")) {
[16:09:31.194]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:31.194]                       if (muffled) 
[16:09:31.194]                         invokeRestart("muffleWarning")
[16:09:31.194]                     }
[16:09:31.194]                     else if (inherits(cond, "condition")) {
[16:09:31.194]                       if (!is.null(pattern)) {
[16:09:31.194]                         computeRestarts <- base::computeRestarts
[16:09:31.194]                         grepl <- base::grepl
[16:09:31.194]                         restarts <- computeRestarts(cond)
[16:09:31.194]                         for (restart in restarts) {
[16:09:31.194]                           name <- restart$name
[16:09:31.194]                           if (is.null(name)) 
[16:09:31.194]                             next
[16:09:31.194]                           if (!grepl(pattern, name)) 
[16:09:31.194]                             next
[16:09:31.194]                           invokeRestart(restart)
[16:09:31.194]                           muffled <- TRUE
[16:09:31.194]                           break
[16:09:31.194]                         }
[16:09:31.194]                       }
[16:09:31.194]                     }
[16:09:31.194]                     invisible(muffled)
[16:09:31.194]                   }
[16:09:31.194]                   muffleCondition(cond)
[16:09:31.194]                 })
[16:09:31.194]             }))
[16:09:31.194]             future::FutureResult(value = ...future.value$value, 
[16:09:31.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.194]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.194]                     ...future.globalenv.names))
[16:09:31.194]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.194]         }, condition = base::local({
[16:09:31.194]             c <- base::c
[16:09:31.194]             inherits <- base::inherits
[16:09:31.194]             invokeRestart <- base::invokeRestart
[16:09:31.194]             length <- base::length
[16:09:31.194]             list <- base::list
[16:09:31.194]             seq.int <- base::seq.int
[16:09:31.194]             signalCondition <- base::signalCondition
[16:09:31.194]             sys.calls <- base::sys.calls
[16:09:31.194]             `[[` <- base::`[[`
[16:09:31.194]             `+` <- base::`+`
[16:09:31.194]             `<<-` <- base::`<<-`
[16:09:31.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.194]                   3L)]
[16:09:31.194]             }
[16:09:31.194]             function(cond) {
[16:09:31.194]                 is_error <- inherits(cond, "error")
[16:09:31.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.194]                   NULL)
[16:09:31.194]                 if (is_error) {
[16:09:31.194]                   sessionInformation <- function() {
[16:09:31.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.194]                       search = base::search(), system = base::Sys.info())
[16:09:31.194]                   }
[16:09:31.194]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.194]                     cond$call), session = sessionInformation(), 
[16:09:31.194]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.194]                   signalCondition(cond)
[16:09:31.194]                 }
[16:09:31.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:31.194]                 "immediateCondition"))) {
[16:09:31.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.194]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.194]                   if (TRUE && !signal) {
[16:09:31.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.194]                     {
[16:09:31.194]                       inherits <- base::inherits
[16:09:31.194]                       invokeRestart <- base::invokeRestart
[16:09:31.194]                       is.null <- base::is.null
[16:09:31.194]                       muffled <- FALSE
[16:09:31.194]                       if (inherits(cond, "message")) {
[16:09:31.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.194]                         if (muffled) 
[16:09:31.194]                           invokeRestart("muffleMessage")
[16:09:31.194]                       }
[16:09:31.194]                       else if (inherits(cond, "warning")) {
[16:09:31.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.194]                         if (muffled) 
[16:09:31.194]                           invokeRestart("muffleWarning")
[16:09:31.194]                       }
[16:09:31.194]                       else if (inherits(cond, "condition")) {
[16:09:31.194]                         if (!is.null(pattern)) {
[16:09:31.194]                           computeRestarts <- base::computeRestarts
[16:09:31.194]                           grepl <- base::grepl
[16:09:31.194]                           restarts <- computeRestarts(cond)
[16:09:31.194]                           for (restart in restarts) {
[16:09:31.194]                             name <- restart$name
[16:09:31.194]                             if (is.null(name)) 
[16:09:31.194]                               next
[16:09:31.194]                             if (!grepl(pattern, name)) 
[16:09:31.194]                               next
[16:09:31.194]                             invokeRestart(restart)
[16:09:31.194]                             muffled <- TRUE
[16:09:31.194]                             break
[16:09:31.194]                           }
[16:09:31.194]                         }
[16:09:31.194]                       }
[16:09:31.194]                       invisible(muffled)
[16:09:31.194]                     }
[16:09:31.194]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.194]                   }
[16:09:31.194]                 }
[16:09:31.194]                 else {
[16:09:31.194]                   if (TRUE) {
[16:09:31.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.194]                     {
[16:09:31.194]                       inherits <- base::inherits
[16:09:31.194]                       invokeRestart <- base::invokeRestart
[16:09:31.194]                       is.null <- base::is.null
[16:09:31.194]                       muffled <- FALSE
[16:09:31.194]                       if (inherits(cond, "message")) {
[16:09:31.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.194]                         if (muffled) 
[16:09:31.194]                           invokeRestart("muffleMessage")
[16:09:31.194]                       }
[16:09:31.194]                       else if (inherits(cond, "warning")) {
[16:09:31.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.194]                         if (muffled) 
[16:09:31.194]                           invokeRestart("muffleWarning")
[16:09:31.194]                       }
[16:09:31.194]                       else if (inherits(cond, "condition")) {
[16:09:31.194]                         if (!is.null(pattern)) {
[16:09:31.194]                           computeRestarts <- base::computeRestarts
[16:09:31.194]                           grepl <- base::grepl
[16:09:31.194]                           restarts <- computeRestarts(cond)
[16:09:31.194]                           for (restart in restarts) {
[16:09:31.194]                             name <- restart$name
[16:09:31.194]                             if (is.null(name)) 
[16:09:31.194]                               next
[16:09:31.194]                             if (!grepl(pattern, name)) 
[16:09:31.194]                               next
[16:09:31.194]                             invokeRestart(restart)
[16:09:31.194]                             muffled <- TRUE
[16:09:31.194]                             break
[16:09:31.194]                           }
[16:09:31.194]                         }
[16:09:31.194]                       }
[16:09:31.194]                       invisible(muffled)
[16:09:31.194]                     }
[16:09:31.194]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.194]                   }
[16:09:31.194]                 }
[16:09:31.194]             }
[16:09:31.194]         }))
[16:09:31.194]     }, error = function(ex) {
[16:09:31.194]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.194]                 ...future.rng), started = ...future.startTime, 
[16:09:31.194]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.194]             version = "1.8"), class = "FutureResult")
[16:09:31.194]     }, finally = {
[16:09:31.194]         if (!identical(...future.workdir, getwd())) 
[16:09:31.194]             setwd(...future.workdir)
[16:09:31.194]         {
[16:09:31.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.194]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.194]             }
[16:09:31.194]             base::options(...future.oldOptions)
[16:09:31.194]             if (.Platform$OS.type == "windows") {
[16:09:31.194]                 old_names <- names(...future.oldEnvVars)
[16:09:31.194]                 envs <- base::Sys.getenv()
[16:09:31.194]                 names <- names(envs)
[16:09:31.194]                 common <- intersect(names, old_names)
[16:09:31.194]                 added <- setdiff(names, old_names)
[16:09:31.194]                 removed <- setdiff(old_names, names)
[16:09:31.194]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.194]                   envs[common]]
[16:09:31.194]                 NAMES <- toupper(changed)
[16:09:31.194]                 args <- list()
[16:09:31.194]                 for (kk in seq_along(NAMES)) {
[16:09:31.194]                   name <- changed[[kk]]
[16:09:31.194]                   NAME <- NAMES[[kk]]
[16:09:31.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.194]                     next
[16:09:31.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.194]                 }
[16:09:31.194]                 NAMES <- toupper(added)
[16:09:31.194]                 for (kk in seq_along(NAMES)) {
[16:09:31.194]                   name <- added[[kk]]
[16:09:31.194]                   NAME <- NAMES[[kk]]
[16:09:31.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.194]                     next
[16:09:31.194]                   args[[name]] <- ""
[16:09:31.194]                 }
[16:09:31.194]                 NAMES <- toupper(removed)
[16:09:31.194]                 for (kk in seq_along(NAMES)) {
[16:09:31.194]                   name <- removed[[kk]]
[16:09:31.194]                   NAME <- NAMES[[kk]]
[16:09:31.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.194]                     next
[16:09:31.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.194]                 }
[16:09:31.194]                 if (length(args) > 0) 
[16:09:31.194]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.194]             }
[16:09:31.194]             else {
[16:09:31.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.194]             }
[16:09:31.194]             {
[16:09:31.194]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.194]                   0L) {
[16:09:31.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.194]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.194]                   base::options(opts)
[16:09:31.194]                 }
[16:09:31.194]                 {
[16:09:31.194]                   {
[16:09:31.194]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:31.194]                     NULL
[16:09:31.194]                   }
[16:09:31.194]                   options(future.plan = NULL)
[16:09:31.194]                   if (is.na(NA_character_)) 
[16:09:31.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.194]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:31.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:31.194]                     envir = parent.frame()) 
[16:09:31.194]                   {
[16:09:31.194]                     if (is.function(workers)) 
[16:09:31.194]                       workers <- workers()
[16:09:31.194]                     workers <- structure(as.integer(workers), 
[16:09:31.194]                       class = class(workers))
[16:09:31.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:31.194]                       workers >= 1)
[16:09:31.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:31.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:31.194]                     }
[16:09:31.194]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:31.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:31.194]                       envir = envir)
[16:09:31.194]                     if (!future$lazy) 
[16:09:31.194]                       future <- run(future)
[16:09:31.194]                     invisible(future)
[16:09:31.194]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.194]                 }
[16:09:31.194]             }
[16:09:31.194]         }
[16:09:31.194]     })
[16:09:31.194]     if (TRUE) {
[16:09:31.194]         base::sink(type = "output", split = FALSE)
[16:09:31.194]         if (TRUE) {
[16:09:31.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.194]         }
[16:09:31.194]         else {
[16:09:31.194]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.194]         }
[16:09:31.194]         base::close(...future.stdout)
[16:09:31.194]         ...future.stdout <- NULL
[16:09:31.194]     }
[16:09:31.194]     ...future.result$conditions <- ...future.conditions
[16:09:31.194]     ...future.result$finished <- base::Sys.time()
[16:09:31.194]     ...future.result
[16:09:31.194] }
[16:09:31.197] Exporting 5 global objects (9.71 KiB) to cluster node #1 ...
[16:09:31.198] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:31.198] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.198] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[16:09:31.199] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[16:09:31.199] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:09:31.199] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:09:31.199] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:09:31.200] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.200] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:31.200] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.200] Exporting 5 global objects (9.71 KiB) to cluster node #1 ... DONE
[16:09:31.201] MultisessionFuture started
[16:09:31.201] - Launch lazy future ... done
[16:09:31.201] run() for ‘MultisessionFuture’ ... done
[16:09:31.201] Created future:
[16:09:31.201] MultisessionFuture:
[16:09:31.201] Label: ‘future_apply-1’
[16:09:31.201] Expression:
[16:09:31.201] {
[16:09:31.201]     do.call(function(...) {
[16:09:31.201]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.201]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.201]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.201]             on.exit(options(oopts), add = TRUE)
[16:09:31.201]         }
[16:09:31.201]         {
[16:09:31.201]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.201]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.201]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.201]             })
[16:09:31.201]         }
[16:09:31.201]     }, args = future.call.arguments)
[16:09:31.201] }
[16:09:31.201] Lazy evaluation: FALSE
[16:09:31.201] Asynchronous evaluation: TRUE
[16:09:31.201] Local evaluation: TRUE
[16:09:31.201] Environment: R_GlobalEnv
[16:09:31.201] Capture standard output: TRUE
[16:09:31.201] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:31.201] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.201] Packages: <none>
[16:09:31.201] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:31.201] Resolved: FALSE
[16:09:31.201] Value: <not collected>
[16:09:31.201] Conditions captured: <none>
[16:09:31.201] Early signaling: FALSE
[16:09:31.201] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:31.201] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.213] Chunk #1 of 2 ... DONE
[16:09:31.213] Chunk #2 of 2 ...
[16:09:31.213]  - seeds: <none>
[16:09:31.213] getGlobalsAndPackages() ...
[16:09:31.213] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.213] Resolving globals: FALSE
[16:09:31.213] Tweak future expression to call with '...' arguments ...
[16:09:31.214] {
[16:09:31.214]     do.call(function(...) {
[16:09:31.214]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.214]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.214]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.214]             on.exit(options(oopts), add = TRUE)
[16:09:31.214]         }
[16:09:31.214]         {
[16:09:31.214]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.214]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.214]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.214]             })
[16:09:31.214]         }
[16:09:31.214]     }, args = future.call.arguments)
[16:09:31.214] }
[16:09:31.214] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.214] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.214] 
[16:09:31.214] getGlobalsAndPackages() ... DONE
[16:09:31.217] run() for ‘Future’ ...
[16:09:31.217] - state: ‘created’
[16:09:31.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:31.232] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.232] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:31.232]   - Field: ‘node’
[16:09:31.232]   - Field: ‘label’
[16:09:31.232]   - Field: ‘local’
[16:09:31.232]   - Field: ‘owner’
[16:09:31.232]   - Field: ‘envir’
[16:09:31.232]   - Field: ‘workers’
[16:09:31.232]   - Field: ‘packages’
[16:09:31.233]   - Field: ‘gc’
[16:09:31.233]   - Field: ‘conditions’
[16:09:31.233]   - Field: ‘persistent’
[16:09:31.233]   - Field: ‘expr’
[16:09:31.233]   - Field: ‘uuid’
[16:09:31.233]   - Field: ‘seed’
[16:09:31.233]   - Field: ‘version’
[16:09:31.233]   - Field: ‘result’
[16:09:31.233]   - Field: ‘asynchronous’
[16:09:31.233]   - Field: ‘calls’
[16:09:31.233]   - Field: ‘globals’
[16:09:31.234]   - Field: ‘stdout’
[16:09:31.234]   - Field: ‘earlySignal’
[16:09:31.234]   - Field: ‘lazy’
[16:09:31.234]   - Field: ‘state’
[16:09:31.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:31.234] - Launch lazy future ...
[16:09:31.234] Packages needed by the future expression (n = 0): <none>
[16:09:31.234] Packages needed by future strategies (n = 0): <none>
[16:09:31.235] {
[16:09:31.235]     {
[16:09:31.235]         {
[16:09:31.235]             ...future.startTime <- base::Sys.time()
[16:09:31.235]             {
[16:09:31.235]                 {
[16:09:31.235]                   {
[16:09:31.235]                     {
[16:09:31.235]                       base::local({
[16:09:31.235]                         has_future <- base::requireNamespace("future", 
[16:09:31.235]                           quietly = TRUE)
[16:09:31.235]                         if (has_future) {
[16:09:31.235]                           ns <- base::getNamespace("future")
[16:09:31.235]                           version <- ns[[".package"]][["version"]]
[16:09:31.235]                           if (is.null(version)) 
[16:09:31.235]                             version <- utils::packageVersion("future")
[16:09:31.235]                         }
[16:09:31.235]                         else {
[16:09:31.235]                           version <- NULL
[16:09:31.235]                         }
[16:09:31.235]                         if (!has_future || version < "1.8.0") {
[16:09:31.235]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.235]                             "", base::R.version$version.string), 
[16:09:31.235]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:31.235]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.235]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.235]                               "release", "version")], collapse = " "), 
[16:09:31.235]                             hostname = base::Sys.info()[["nodename"]])
[16:09:31.235]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.235]                             info)
[16:09:31.235]                           info <- base::paste(info, collapse = "; ")
[16:09:31.235]                           if (!has_future) {
[16:09:31.235]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.235]                               info)
[16:09:31.235]                           }
[16:09:31.235]                           else {
[16:09:31.235]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.235]                               info, version)
[16:09:31.235]                           }
[16:09:31.235]                           base::stop(msg)
[16:09:31.235]                         }
[16:09:31.235]                       })
[16:09:31.235]                     }
[16:09:31.235]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:31.235]                     base::options(mc.cores = 1L)
[16:09:31.235]                   }
[16:09:31.235]                   options(future.plan = NULL)
[16:09:31.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.235]                 }
[16:09:31.235]                 ...future.workdir <- getwd()
[16:09:31.235]             }
[16:09:31.235]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.235]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.235]         }
[16:09:31.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.235]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:31.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.235]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.235]             base::names(...future.oldOptions))
[16:09:31.235]     }
[16:09:31.235]     if (FALSE) {
[16:09:31.235]     }
[16:09:31.235]     else {
[16:09:31.235]         if (TRUE) {
[16:09:31.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.235]                 open = "w")
[16:09:31.235]         }
[16:09:31.235]         else {
[16:09:31.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.235]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.235]         }
[16:09:31.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.235]             base::sink(type = "output", split = FALSE)
[16:09:31.235]             base::close(...future.stdout)
[16:09:31.235]         }, add = TRUE)
[16:09:31.235]     }
[16:09:31.235]     ...future.frame <- base::sys.nframe()
[16:09:31.235]     ...future.conditions <- base::list()
[16:09:31.235]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.235]     if (FALSE) {
[16:09:31.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.235]     }
[16:09:31.235]     ...future.result <- base::tryCatch({
[16:09:31.235]         base::withCallingHandlers({
[16:09:31.235]             ...future.value <- base::withVisible(base::local({
[16:09:31.235]                 ...future.makeSendCondition <- local({
[16:09:31.235]                   sendCondition <- NULL
[16:09:31.235]                   function(frame = 1L) {
[16:09:31.235]                     if (is.function(sendCondition)) 
[16:09:31.235]                       return(sendCondition)
[16:09:31.235]                     ns <- getNamespace("parallel")
[16:09:31.235]                     if (exists("sendData", mode = "function", 
[16:09:31.235]                       envir = ns)) {
[16:09:31.235]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:31.235]                         envir = ns)
[16:09:31.235]                       envir <- sys.frame(frame)
[16:09:31.235]                       master <- NULL
[16:09:31.235]                       while (!identical(envir, .GlobalEnv) && 
[16:09:31.235]                         !identical(envir, emptyenv())) {
[16:09:31.235]                         if (exists("master", mode = "list", envir = envir, 
[16:09:31.235]                           inherits = FALSE)) {
[16:09:31.235]                           master <- get("master", mode = "list", 
[16:09:31.235]                             envir = envir, inherits = FALSE)
[16:09:31.235]                           if (inherits(master, c("SOCKnode", 
[16:09:31.235]                             "SOCK0node"))) {
[16:09:31.235]                             sendCondition <<- function(cond) {
[16:09:31.235]                               data <- list(type = "VALUE", value = cond, 
[16:09:31.235]                                 success = TRUE)
[16:09:31.235]                               parallel_sendData(master, data)
[16:09:31.235]                             }
[16:09:31.235]                             return(sendCondition)
[16:09:31.235]                           }
[16:09:31.235]                         }
[16:09:31.235]                         frame <- frame + 1L
[16:09:31.235]                         envir <- sys.frame(frame)
[16:09:31.235]                       }
[16:09:31.235]                     }
[16:09:31.235]                     sendCondition <<- function(cond) NULL
[16:09:31.235]                   }
[16:09:31.235]                 })
[16:09:31.235]                 withCallingHandlers({
[16:09:31.235]                   {
[16:09:31.235]                     do.call(function(...) {
[16:09:31.235]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.235]                       if (!identical(...future.globals.maxSize.org, 
[16:09:31.235]                         ...future.globals.maxSize)) {
[16:09:31.235]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.235]                         on.exit(options(oopts), add = TRUE)
[16:09:31.235]                       }
[16:09:31.235]                       {
[16:09:31.235]                         lapply(seq_along(...future.elements_ii), 
[16:09:31.235]                           FUN = function(jj) {
[16:09:31.235]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.235]                             ...future.FUN(...future.X_jj, ...)
[16:09:31.235]                           })
[16:09:31.235]                       }
[16:09:31.235]                     }, args = future.call.arguments)
[16:09:31.235]                   }
[16:09:31.235]                 }, immediateCondition = function(cond) {
[16:09:31.235]                   sendCondition <- ...future.makeSendCondition()
[16:09:31.235]                   sendCondition(cond)
[16:09:31.235]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.235]                   {
[16:09:31.235]                     inherits <- base::inherits
[16:09:31.235]                     invokeRestart <- base::invokeRestart
[16:09:31.235]                     is.null <- base::is.null
[16:09:31.235]                     muffled <- FALSE
[16:09:31.235]                     if (inherits(cond, "message")) {
[16:09:31.235]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:31.235]                       if (muffled) 
[16:09:31.235]                         invokeRestart("muffleMessage")
[16:09:31.235]                     }
[16:09:31.235]                     else if (inherits(cond, "warning")) {
[16:09:31.235]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:31.235]                       if (muffled) 
[16:09:31.235]                         invokeRestart("muffleWarning")
[16:09:31.235]                     }
[16:09:31.235]                     else if (inherits(cond, "condition")) {
[16:09:31.235]                       if (!is.null(pattern)) {
[16:09:31.235]                         computeRestarts <- base::computeRestarts
[16:09:31.235]                         grepl <- base::grepl
[16:09:31.235]                         restarts <- computeRestarts(cond)
[16:09:31.235]                         for (restart in restarts) {
[16:09:31.235]                           name <- restart$name
[16:09:31.235]                           if (is.null(name)) 
[16:09:31.235]                             next
[16:09:31.235]                           if (!grepl(pattern, name)) 
[16:09:31.235]                             next
[16:09:31.235]                           invokeRestart(restart)
[16:09:31.235]                           muffled <- TRUE
[16:09:31.235]                           break
[16:09:31.235]                         }
[16:09:31.235]                       }
[16:09:31.235]                     }
[16:09:31.235]                     invisible(muffled)
[16:09:31.235]                   }
[16:09:31.235]                   muffleCondition(cond)
[16:09:31.235]                 })
[16:09:31.235]             }))
[16:09:31.235]             future::FutureResult(value = ...future.value$value, 
[16:09:31.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.235]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.235]                     ...future.globalenv.names))
[16:09:31.235]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.235]         }, condition = base::local({
[16:09:31.235]             c <- base::c
[16:09:31.235]             inherits <- base::inherits
[16:09:31.235]             invokeRestart <- base::invokeRestart
[16:09:31.235]             length <- base::length
[16:09:31.235]             list <- base::list
[16:09:31.235]             seq.int <- base::seq.int
[16:09:31.235]             signalCondition <- base::signalCondition
[16:09:31.235]             sys.calls <- base::sys.calls
[16:09:31.235]             `[[` <- base::`[[`
[16:09:31.235]             `+` <- base::`+`
[16:09:31.235]             `<<-` <- base::`<<-`
[16:09:31.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.235]                   3L)]
[16:09:31.235]             }
[16:09:31.235]             function(cond) {
[16:09:31.235]                 is_error <- inherits(cond, "error")
[16:09:31.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.235]                   NULL)
[16:09:31.235]                 if (is_error) {
[16:09:31.235]                   sessionInformation <- function() {
[16:09:31.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.235]                       search = base::search(), system = base::Sys.info())
[16:09:31.235]                   }
[16:09:31.235]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.235]                     cond$call), session = sessionInformation(), 
[16:09:31.235]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.235]                   signalCondition(cond)
[16:09:31.235]                 }
[16:09:31.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:09:31.235]                 "immediateCondition"))) {
[16:09:31.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.235]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.235]                   if (TRUE && !signal) {
[16:09:31.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.235]                     {
[16:09:31.235]                       inherits <- base::inherits
[16:09:31.235]                       invokeRestart <- base::invokeRestart
[16:09:31.235]                       is.null <- base::is.null
[16:09:31.235]                       muffled <- FALSE
[16:09:31.235]                       if (inherits(cond, "message")) {
[16:09:31.235]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.235]                         if (muffled) 
[16:09:31.235]                           invokeRestart("muffleMessage")
[16:09:31.235]                       }
[16:09:31.235]                       else if (inherits(cond, "warning")) {
[16:09:31.235]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.235]                         if (muffled) 
[16:09:31.235]                           invokeRestart("muffleWarning")
[16:09:31.235]                       }
[16:09:31.235]                       else if (inherits(cond, "condition")) {
[16:09:31.235]                         if (!is.null(pattern)) {
[16:09:31.235]                           computeRestarts <- base::computeRestarts
[16:09:31.235]                           grepl <- base::grepl
[16:09:31.235]                           restarts <- computeRestarts(cond)
[16:09:31.235]                           for (restart in restarts) {
[16:09:31.235]                             name <- restart$name
[16:09:31.235]                             if (is.null(name)) 
[16:09:31.235]                               next
[16:09:31.235]                             if (!grepl(pattern, name)) 
[16:09:31.235]                               next
[16:09:31.235]                             invokeRestart(restart)
[16:09:31.235]                             muffled <- TRUE
[16:09:31.235]                             break
[16:09:31.235]                           }
[16:09:31.235]                         }
[16:09:31.235]                       }
[16:09:31.235]                       invisible(muffled)
[16:09:31.235]                     }
[16:09:31.235]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.235]                   }
[16:09:31.235]                 }
[16:09:31.235]                 else {
[16:09:31.235]                   if (TRUE) {
[16:09:31.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.235]                     {
[16:09:31.235]                       inherits <- base::inherits
[16:09:31.235]                       invokeRestart <- base::invokeRestart
[16:09:31.235]                       is.null <- base::is.null
[16:09:31.235]                       muffled <- FALSE
[16:09:31.235]                       if (inherits(cond, "message")) {
[16:09:31.235]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.235]                         if (muffled) 
[16:09:31.235]                           invokeRestart("muffleMessage")
[16:09:31.235]                       }
[16:09:31.235]                       else if (inherits(cond, "warning")) {
[16:09:31.235]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.235]                         if (muffled) 
[16:09:31.235]                           invokeRestart("muffleWarning")
[16:09:31.235]                       }
[16:09:31.235]                       else if (inherits(cond, "condition")) {
[16:09:31.235]                         if (!is.null(pattern)) {
[16:09:31.235]                           computeRestarts <- base::computeRestarts
[16:09:31.235]                           grepl <- base::grepl
[16:09:31.235]                           restarts <- computeRestarts(cond)
[16:09:31.235]                           for (restart in restarts) {
[16:09:31.235]                             name <- restart$name
[16:09:31.235]                             if (is.null(name)) 
[16:09:31.235]                               next
[16:09:31.235]                             if (!grepl(pattern, name)) 
[16:09:31.235]                               next
[16:09:31.235]                             invokeRestart(restart)
[16:09:31.235]                             muffled <- TRUE
[16:09:31.235]                             break
[16:09:31.235]                           }
[16:09:31.235]                         }
[16:09:31.235]                       }
[16:09:31.235]                       invisible(muffled)
[16:09:31.235]                     }
[16:09:31.235]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.235]                   }
[16:09:31.235]                 }
[16:09:31.235]             }
[16:09:31.235]         }))
[16:09:31.235]     }, error = function(ex) {
[16:09:31.235]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.235]                 ...future.rng), started = ...future.startTime, 
[16:09:31.235]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.235]             version = "1.8"), class = "FutureResult")
[16:09:31.235]     }, finally = {
[16:09:31.235]         if (!identical(...future.workdir, getwd())) 
[16:09:31.235]             setwd(...future.workdir)
[16:09:31.235]         {
[16:09:31.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.235]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.235]             }
[16:09:31.235]             base::options(...future.oldOptions)
[16:09:31.235]             if (.Platform$OS.type == "windows") {
[16:09:31.235]                 old_names <- names(...future.oldEnvVars)
[16:09:31.235]                 envs <- base::Sys.getenv()
[16:09:31.235]                 names <- names(envs)
[16:09:31.235]                 common <- intersect(names, old_names)
[16:09:31.235]                 added <- setdiff(names, old_names)
[16:09:31.235]                 removed <- setdiff(old_names, names)
[16:09:31.235]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.235]                   envs[common]]
[16:09:31.235]                 NAMES <- toupper(changed)
[16:09:31.235]                 args <- list()
[16:09:31.235]                 for (kk in seq_along(NAMES)) {
[16:09:31.235]                   name <- changed[[kk]]
[16:09:31.235]                   NAME <- NAMES[[kk]]
[16:09:31.235]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.235]                     next
[16:09:31.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.235]                 }
[16:09:31.235]                 NAMES <- toupper(added)
[16:09:31.235]                 for (kk in seq_along(NAMES)) {
[16:09:31.235]                   name <- added[[kk]]
[16:09:31.235]                   NAME <- NAMES[[kk]]
[16:09:31.235]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.235]                     next
[16:09:31.235]                   args[[name]] <- ""
[16:09:31.235]                 }
[16:09:31.235]                 NAMES <- toupper(removed)
[16:09:31.235]                 for (kk in seq_along(NAMES)) {
[16:09:31.235]                   name <- removed[[kk]]
[16:09:31.235]                   NAME <- NAMES[[kk]]
[16:09:31.235]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.235]                     next
[16:09:31.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.235]                 }
[16:09:31.235]                 if (length(args) > 0) 
[16:09:31.235]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.235]             }
[16:09:31.235]             else {
[16:09:31.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.235]             }
[16:09:31.235]             {
[16:09:31.235]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.235]                   0L) {
[16:09:31.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.235]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.235]                   base::options(opts)
[16:09:31.235]                 }
[16:09:31.235]                 {
[16:09:31.235]                   {
[16:09:31.235]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:31.235]                     NULL
[16:09:31.235]                   }
[16:09:31.235]                   options(future.plan = NULL)
[16:09:31.235]                   if (is.na(NA_character_)) 
[16:09:31.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.235]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:31.235]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:31.235]                     envir = parent.frame()) 
[16:09:31.235]                   {
[16:09:31.235]                     if (is.function(workers)) 
[16:09:31.235]                       workers <- workers()
[16:09:31.235]                     workers <- structure(as.integer(workers), 
[16:09:31.235]                       class = class(workers))
[16:09:31.235]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:31.235]                       workers >= 1)
[16:09:31.235]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:31.235]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:31.235]                     }
[16:09:31.235]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:31.235]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:31.235]                       envir = envir)
[16:09:31.235]                     if (!future$lazy) 
[16:09:31.235]                       future <- run(future)
[16:09:31.235]                     invisible(future)
[16:09:31.235]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.235]                 }
[16:09:31.235]             }
[16:09:31.235]         }
[16:09:31.235]     })
[16:09:31.235]     if (TRUE) {
[16:09:31.235]         base::sink(type = "output", split = FALSE)
[16:09:31.235]         if (TRUE) {
[16:09:31.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.235]         }
[16:09:31.235]         else {
[16:09:31.235]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.235]         }
[16:09:31.235]         base::close(...future.stdout)
[16:09:31.235]         ...future.stdout <- NULL
[16:09:31.235]     }
[16:09:31.235]     ...future.result$conditions <- ...future.conditions
[16:09:31.235]     ...future.result$finished <- base::Sys.time()
[16:09:31.235]     ...future.result
[16:09:31.235] }
[16:09:31.238] Exporting 5 global objects (9.71 KiB) to cluster node #2 ...
[16:09:31.238] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:31.238] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.239] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[16:09:31.239] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[16:09:31.239] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:09:31.239] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:09:31.240] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:09:31.240] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.240] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:31.240] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.241] Exporting 5 global objects (9.71 KiB) to cluster node #2 ... DONE
[16:09:31.241] MultisessionFuture started
[16:09:31.241] - Launch lazy future ... done
[16:09:31.241] run() for ‘MultisessionFuture’ ... done
[16:09:31.242] Created future:
[16:09:31.242] MultisessionFuture:
[16:09:31.242] Label: ‘future_apply-2’
[16:09:31.242] Expression:
[16:09:31.242] {
[16:09:31.242]     do.call(function(...) {
[16:09:31.242]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.242]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.242]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.242]             on.exit(options(oopts), add = TRUE)
[16:09:31.242]         }
[16:09:31.242]         {
[16:09:31.242]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.242]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.242]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.242]             })
[16:09:31.242]         }
[16:09:31.242]     }, args = future.call.arguments)
[16:09:31.242] }
[16:09:31.242] Lazy evaluation: FALSE
[16:09:31.242] Asynchronous evaluation: TRUE
[16:09:31.242] Local evaluation: TRUE
[16:09:31.242] Environment: R_GlobalEnv
[16:09:31.242] Capture standard output: TRUE
[16:09:31.242] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:09:31.242] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.242] Packages: <none>
[16:09:31.242] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:09:31.242] Resolved: FALSE
[16:09:31.242] Value: <not collected>
[16:09:31.242] Conditions captured: <none>
[16:09:31.242] Early signaling: FALSE
[16:09:31.242] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:31.242] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.253] Chunk #2 of 2 ... DONE
[16:09:31.253] Launching 2 futures (chunks) ... DONE
[16:09:31.253] Resolving 2 futures (chunks) ...
[16:09:31.253] resolve() on list ...
[16:09:31.254]  recursive: 0
[16:09:31.254]  length: 2
[16:09:31.254] 
[16:09:31.254] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.254] - Validating connection of MultisessionFuture
[16:09:31.254] - received message: FutureResult
[16:09:31.255] - Received FutureResult
[16:09:31.255] - Erased future from FutureRegistry
[16:09:31.255] result() for ClusterFuture ...
[16:09:31.255] - result already collected: FutureResult
[16:09:31.255] result() for ClusterFuture ... done
[16:09:31.255] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.255] Future #1
[16:09:31.255] result() for ClusterFuture ...
[16:09:31.255] - result already collected: FutureResult
[16:09:31.255] result() for ClusterFuture ... done
[16:09:31.256] result() for ClusterFuture ...
[16:09:31.256] - result already collected: FutureResult
[16:09:31.256] result() for ClusterFuture ... done
[16:09:31.256] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:31.256] - nx: 2
[16:09:31.256] - relay: TRUE
[16:09:31.256] - stdout: TRUE
[16:09:31.256] - signal: TRUE
[16:09:31.256] - resignal: FALSE
[16:09:31.256] - force: TRUE
[16:09:31.256] - relayed: [n=2] FALSE, FALSE
[16:09:31.257] - queued futures: [n=2] FALSE, FALSE
[16:09:31.257]  - until=1
[16:09:31.257]  - relaying element #1
[16:09:31.257] result() for ClusterFuture ...
[16:09:31.257] - result already collected: FutureResult
[16:09:31.257] result() for ClusterFuture ... done
[16:09:31.257] result() for ClusterFuture ...
[16:09:31.257] - result already collected: FutureResult
[16:09:31.257] result() for ClusterFuture ... done
[16:09:31.257] result() for ClusterFuture ...
[16:09:31.258] - result already collected: FutureResult
[16:09:31.258] result() for ClusterFuture ... done
[16:09:31.258] result() for ClusterFuture ...
[16:09:31.258] - result already collected: FutureResult
[16:09:31.258] result() for ClusterFuture ... done
[16:09:31.258] - relayed: [n=2] TRUE, FALSE
[16:09:31.258] - queued futures: [n=2] TRUE, FALSE
[16:09:31.258] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:31.258]  length: 1 (resolved future 1)
[16:09:31.288] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.289] - Validating connection of MultisessionFuture
[16:09:31.289] - received message: FutureResult
[16:09:31.289] - Received FutureResult
[16:09:31.289] - Erased future from FutureRegistry
[16:09:31.289] result() for ClusterFuture ...
[16:09:31.289] - result already collected: FutureResult
[16:09:31.289] result() for ClusterFuture ... done
[16:09:31.290] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.290] Future #2
[16:09:31.290] result() for ClusterFuture ...
[16:09:31.290] - result already collected: FutureResult
[16:09:31.290] result() for ClusterFuture ... done
[16:09:31.290] result() for ClusterFuture ...
[16:09:31.290] - result already collected: FutureResult
[16:09:31.290] result() for ClusterFuture ... done
[16:09:31.290] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:31.290] - nx: 2
[16:09:31.291] - relay: TRUE
[16:09:31.291] - stdout: TRUE
[16:09:31.291] - signal: TRUE
[16:09:31.291] - resignal: FALSE
[16:09:31.291] - force: TRUE
[16:09:31.291] - relayed: [n=2] TRUE, FALSE
[16:09:31.291] - queued futures: [n=2] TRUE, FALSE
[16:09:31.291]  - until=2
[16:09:31.291]  - relaying element #2
[16:09:31.291] result() for ClusterFuture ...
[16:09:31.291] - result already collected: FutureResult
[16:09:31.291] result() for ClusterFuture ... done
[16:09:31.292] result() for ClusterFuture ...
[16:09:31.292] - result already collected: FutureResult
[16:09:31.292] result() for ClusterFuture ... done
[16:09:31.292] result() for ClusterFuture ...
[16:09:31.292] - result already collected: FutureResult
[16:09:31.292] result() for ClusterFuture ... done
[16:09:31.292] result() for ClusterFuture ...
[16:09:31.292] - result already collected: FutureResult
[16:09:31.292] result() for ClusterFuture ... done
[16:09:31.293] - relayed: [n=2] TRUE, TRUE
[16:09:31.293] - queued futures: [n=2] TRUE, TRUE
[16:09:31.293] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:31.293]  length: 0 (resolved future 2)
[16:09:31.293] Relaying remaining futures
[16:09:31.293] signalConditionsASAP(NULL, pos=0) ...
[16:09:31.293] - nx: 2
[16:09:31.293] - relay: TRUE
[16:09:31.293] - stdout: TRUE
[16:09:31.293] - signal: TRUE
[16:09:31.293] - resignal: FALSE
[16:09:31.294] - force: TRUE
[16:09:31.294] - relayed: [n=2] TRUE, TRUE
[16:09:31.294] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:31.294] - relayed: [n=2] TRUE, TRUE
[16:09:31.294] - queued futures: [n=2] TRUE, TRUE
[16:09:31.294] signalConditionsASAP(NULL, pos=0) ... done
[16:09:31.294] resolve() on list ... DONE
[16:09:31.294] result() for ClusterFuture ...
[16:09:31.294] - result already collected: FutureResult
[16:09:31.294] result() for ClusterFuture ... done
[16:09:31.294] result() for ClusterFuture ...
[16:09:31.295] - result already collected: FutureResult
[16:09:31.295] result() for ClusterFuture ... done
[16:09:31.295] result() for ClusterFuture ...
[16:09:31.295] - result already collected: FutureResult
[16:09:31.295] result() for ClusterFuture ... done
[16:09:31.295] result() for ClusterFuture ...
[16:09:31.295] - result already collected: FutureResult
[16:09:31.295] result() for ClusterFuture ... done
[16:09:31.295]  - Number of value chunks collected: 2
[16:09:31.295] Resolving 2 futures (chunks) ... DONE
[16:09:31.295] Reducing values from 2 chunks ...
[16:09:31.296]  - Number of values collected after concatenation: 2
[16:09:31.296]  - Number of values expected: 2
[16:09:31.296] Reducing values from 2 chunks ... DONE
[16:09:31.296] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:09:31.296] getGlobalsAndPackagesXApply() ...
[16:09:31.296]  - future.globals: TRUE
[16:09:31.296] getGlobalsAndPackages() ...
[16:09:31.296] Searching for globals...
[16:09:31.299] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:09:31.300] Searching for globals ... DONE
[16:09:31.300] Resolving globals: FALSE
[16:09:31.300] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:09:31.301] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:09:31.301] - globals: [1] ‘FUN’
[16:09:31.301] 
[16:09:31.301] getGlobalsAndPackages() ... DONE
[16:09:31.301]  - globals found/used: [n=1] ‘FUN’
[16:09:31.301]  - needed namespaces: [n=0] 
[16:09:31.301] Finding globals ... DONE
[16:09:31.301]  - use_args: TRUE
[16:09:31.301]  - Getting '...' globals ...
[16:09:31.302] resolve() on list ...
[16:09:31.302]  recursive: 0
[16:09:31.302]  length: 1
[16:09:31.302]  elements: ‘...’
[16:09:31.302]  length: 0 (resolved future 1)
[16:09:31.302] resolve() on list ... DONE
[16:09:31.302]    - '...' content: [n=0] 
[16:09:31.303] List of 1
[16:09:31.303]  $ ...: list()
[16:09:31.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.303]  - attr(*, "where")=List of 1
[16:09:31.303]   ..$ ...:<environment: 0x5633aa3ebc20> 
[16:09:31.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.303]  - attr(*, "resolved")= logi TRUE
[16:09:31.303]  - attr(*, "total_size")= num NA
[16:09:31.305]  - Getting '...' globals ... DONE
[16:09:31.305] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:09:31.305] List of 2
[16:09:31.305]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:09:31.305]  $ ...          : list()
[16:09:31.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.305]  - attr(*, "where")=List of 2
[16:09:31.305]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:09:31.305]   ..$ ...          :<environment: 0x5633aa3ebc20> 
[16:09:31.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.305]  - attr(*, "resolved")= logi FALSE
[16:09:31.305]  - attr(*, "total_size")= num 36296
[16:09:31.308] Packages to be attached in all futures: [n=0] 
[16:09:31.308] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.311] future_lapply() ...
[16:09:31.313] Generating random seeds ...
[16:09:31.313] Generating random seed streams for 2 elements ...
[16:09:31.314] Generating random seed streams for 2 elements ... DONE
[16:09:31.314] Generating random seeds ... DONE
[16:09:31.314] Will set RNG state on exit: 10407, -1800098810, -2008595586, -273364347, 1633950339, 560455887, 115218187
[16:09:31.317] Number of chunks: 2
[16:09:31.317] getGlobalsAndPackagesXApply() ...
[16:09:31.317]  - future.globals: <name-value list> with names ‘list()’
[16:09:31.318]  - use_args: TRUE
[16:09:31.318] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:09:31.318] List of 2
[16:09:31.318]  $ ...          : list()
[16:09:31.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:09:31.318]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:09:31.318]  - attr(*, "where")=List of 2
[16:09:31.318]   ..$ ...          :<environment: 0x5633aa3ebc20> 
[16:09:31.318]   ..$ ...future.FUN:<environment: namespace:base> 
[16:09:31.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:09:31.318]  - attr(*, "resolved")= logi FALSE
[16:09:31.318]  - attr(*, "total_size")= num NA
[16:09:31.321] Packages to be attached in all futures: [n=0] 
[16:09:31.321] getGlobalsAndPackagesXApply() ... DONE
[16:09:31.321] Number of futures (= number of chunks): 2
[16:09:31.321] Launching 2 futures (chunks) ...
[16:09:31.321] Chunk #1 of 2 ...
[16:09:31.322]  - seeds: [1] <seeds>
[16:09:31.322] getGlobalsAndPackages() ...
[16:09:31.322] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.322] Resolving globals: FALSE
[16:09:31.322] Tweak future expression to call with '...' arguments ...
[16:09:31.322] {
[16:09:31.322]     do.call(function(...) {
[16:09:31.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.322]             on.exit(options(oopts), add = TRUE)
[16:09:31.322]         }
[16:09:31.322]         {
[16:09:31.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.322]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:31.322]                   envir = globalenv(), inherits = FALSE)
[16:09:31.322]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.322]             })
[16:09:31.322]         }
[16:09:31.322]     }, args = future.call.arguments)
[16:09:31.322] }
[16:09:31.322] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.323] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.323] 
[16:09:31.323] getGlobalsAndPackages() ... DONE
[16:09:31.323] run() for ‘Future’ ...
[16:09:31.323] - state: ‘created’
[16:09:31.324] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:31.338] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:31.338]   - Field: ‘node’
[16:09:31.338]   - Field: ‘label’
[16:09:31.338]   - Field: ‘local’
[16:09:31.338]   - Field: ‘owner’
[16:09:31.338]   - Field: ‘envir’
[16:09:31.338]   - Field: ‘workers’
[16:09:31.339]   - Field: ‘packages’
[16:09:31.339]   - Field: ‘gc’
[16:09:31.339]   - Field: ‘conditions’
[16:09:31.339]   - Field: ‘persistent’
[16:09:31.339]   - Field: ‘expr’
[16:09:31.339]   - Field: ‘uuid’
[16:09:31.339]   - Field: ‘seed’
[16:09:31.339]   - Field: ‘version’
[16:09:31.339]   - Field: ‘result’
[16:09:31.339]   - Field: ‘asynchronous’
[16:09:31.339]   - Field: ‘calls’
[16:09:31.340]   - Field: ‘globals’
[16:09:31.340]   - Field: ‘stdout’
[16:09:31.340]   - Field: ‘earlySignal’
[16:09:31.340]   - Field: ‘lazy’
[16:09:31.340]   - Field: ‘state’
[16:09:31.340] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:31.340] - Launch lazy future ...
[16:09:31.340] Packages needed by the future expression (n = 0): <none>
[16:09:31.341] Packages needed by future strategies (n = 0): <none>
[16:09:31.341] {
[16:09:31.341]     {
[16:09:31.341]         {
[16:09:31.341]             ...future.startTime <- base::Sys.time()
[16:09:31.341]             {
[16:09:31.341]                 {
[16:09:31.341]                   {
[16:09:31.341]                     {
[16:09:31.341]                       base::local({
[16:09:31.341]                         has_future <- base::requireNamespace("future", 
[16:09:31.341]                           quietly = TRUE)
[16:09:31.341]                         if (has_future) {
[16:09:31.341]                           ns <- base::getNamespace("future")
[16:09:31.341]                           version <- ns[[".package"]][["version"]]
[16:09:31.341]                           if (is.null(version)) 
[16:09:31.341]                             version <- utils::packageVersion("future")
[16:09:31.341]                         }
[16:09:31.341]                         else {
[16:09:31.341]                           version <- NULL
[16:09:31.341]                         }
[16:09:31.341]                         if (!has_future || version < "1.8.0") {
[16:09:31.341]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.341]                             "", base::R.version$version.string), 
[16:09:31.341]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:31.341]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.341]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.341]                               "release", "version")], collapse = " "), 
[16:09:31.341]                             hostname = base::Sys.info()[["nodename"]])
[16:09:31.341]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.341]                             info)
[16:09:31.341]                           info <- base::paste(info, collapse = "; ")
[16:09:31.341]                           if (!has_future) {
[16:09:31.341]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.341]                               info)
[16:09:31.341]                           }
[16:09:31.341]                           else {
[16:09:31.341]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.341]                               info, version)
[16:09:31.341]                           }
[16:09:31.341]                           base::stop(msg)
[16:09:31.341]                         }
[16:09:31.341]                       })
[16:09:31.341]                     }
[16:09:31.341]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:31.341]                     base::options(mc.cores = 1L)
[16:09:31.341]                   }
[16:09:31.341]                   options(future.plan = NULL)
[16:09:31.341]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.341]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.341]                 }
[16:09:31.341]                 ...future.workdir <- getwd()
[16:09:31.341]             }
[16:09:31.341]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.341]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.341]         }
[16:09:31.341]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.341]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:31.341]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.341]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.341]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.341]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.341]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.341]             base::names(...future.oldOptions))
[16:09:31.341]     }
[16:09:31.341]     if (FALSE) {
[16:09:31.341]     }
[16:09:31.341]     else {
[16:09:31.341]         if (TRUE) {
[16:09:31.341]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.341]                 open = "w")
[16:09:31.341]         }
[16:09:31.341]         else {
[16:09:31.341]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.341]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.341]         }
[16:09:31.341]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.341]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.341]             base::sink(type = "output", split = FALSE)
[16:09:31.341]             base::close(...future.stdout)
[16:09:31.341]         }, add = TRUE)
[16:09:31.341]     }
[16:09:31.341]     ...future.frame <- base::sys.nframe()
[16:09:31.341]     ...future.conditions <- base::list()
[16:09:31.341]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.341]     if (FALSE) {
[16:09:31.341]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.341]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.341]     }
[16:09:31.341]     ...future.result <- base::tryCatch({
[16:09:31.341]         base::withCallingHandlers({
[16:09:31.341]             ...future.value <- base::withVisible(base::local({
[16:09:31.341]                 ...future.makeSendCondition <- local({
[16:09:31.341]                   sendCondition <- NULL
[16:09:31.341]                   function(frame = 1L) {
[16:09:31.341]                     if (is.function(sendCondition)) 
[16:09:31.341]                       return(sendCondition)
[16:09:31.341]                     ns <- getNamespace("parallel")
[16:09:31.341]                     if (exists("sendData", mode = "function", 
[16:09:31.341]                       envir = ns)) {
[16:09:31.341]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:31.341]                         envir = ns)
[16:09:31.341]                       envir <- sys.frame(frame)
[16:09:31.341]                       master <- NULL
[16:09:31.341]                       while (!identical(envir, .GlobalEnv) && 
[16:09:31.341]                         !identical(envir, emptyenv())) {
[16:09:31.341]                         if (exists("master", mode = "list", envir = envir, 
[16:09:31.341]                           inherits = FALSE)) {
[16:09:31.341]                           master <- get("master", mode = "list", 
[16:09:31.341]                             envir = envir, inherits = FALSE)
[16:09:31.341]                           if (inherits(master, c("SOCKnode", 
[16:09:31.341]                             "SOCK0node"))) {
[16:09:31.341]                             sendCondition <<- function(cond) {
[16:09:31.341]                               data <- list(type = "VALUE", value = cond, 
[16:09:31.341]                                 success = TRUE)
[16:09:31.341]                               parallel_sendData(master, data)
[16:09:31.341]                             }
[16:09:31.341]                             return(sendCondition)
[16:09:31.341]                           }
[16:09:31.341]                         }
[16:09:31.341]                         frame <- frame + 1L
[16:09:31.341]                         envir <- sys.frame(frame)
[16:09:31.341]                       }
[16:09:31.341]                     }
[16:09:31.341]                     sendCondition <<- function(cond) NULL
[16:09:31.341]                   }
[16:09:31.341]                 })
[16:09:31.341]                 withCallingHandlers({
[16:09:31.341]                   {
[16:09:31.341]                     do.call(function(...) {
[16:09:31.341]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.341]                       if (!identical(...future.globals.maxSize.org, 
[16:09:31.341]                         ...future.globals.maxSize)) {
[16:09:31.341]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.341]                         on.exit(options(oopts), add = TRUE)
[16:09:31.341]                       }
[16:09:31.341]                       {
[16:09:31.341]                         lapply(seq_along(...future.elements_ii), 
[16:09:31.341]                           FUN = function(jj) {
[16:09:31.341]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.341]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:31.341]                               envir = globalenv(), inherits = FALSE)
[16:09:31.341]                             ...future.FUN(...future.X_jj, ...)
[16:09:31.341]                           })
[16:09:31.341]                       }
[16:09:31.341]                     }, args = future.call.arguments)
[16:09:31.341]                   }
[16:09:31.341]                 }, immediateCondition = function(cond) {
[16:09:31.341]                   sendCondition <- ...future.makeSendCondition()
[16:09:31.341]                   sendCondition(cond)
[16:09:31.341]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.341]                   {
[16:09:31.341]                     inherits <- base::inherits
[16:09:31.341]                     invokeRestart <- base::invokeRestart
[16:09:31.341]                     is.null <- base::is.null
[16:09:31.341]                     muffled <- FALSE
[16:09:31.341]                     if (inherits(cond, "message")) {
[16:09:31.341]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:31.341]                       if (muffled) 
[16:09:31.341]                         invokeRestart("muffleMessage")
[16:09:31.341]                     }
[16:09:31.341]                     else if (inherits(cond, "warning")) {
[16:09:31.341]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:31.341]                       if (muffled) 
[16:09:31.341]                         invokeRestart("muffleWarning")
[16:09:31.341]                     }
[16:09:31.341]                     else if (inherits(cond, "condition")) {
[16:09:31.341]                       if (!is.null(pattern)) {
[16:09:31.341]                         computeRestarts <- base::computeRestarts
[16:09:31.341]                         grepl <- base::grepl
[16:09:31.341]                         restarts <- computeRestarts(cond)
[16:09:31.341]                         for (restart in restarts) {
[16:09:31.341]                           name <- restart$name
[16:09:31.341]                           if (is.null(name)) 
[16:09:31.341]                             next
[16:09:31.341]                           if (!grepl(pattern, name)) 
[16:09:31.341]                             next
[16:09:31.341]                           invokeRestart(restart)
[16:09:31.341]                           muffled <- TRUE
[16:09:31.341]                           break
[16:09:31.341]                         }
[16:09:31.341]                       }
[16:09:31.341]                     }
[16:09:31.341]                     invisible(muffled)
[16:09:31.341]                   }
[16:09:31.341]                   muffleCondition(cond)
[16:09:31.341]                 })
[16:09:31.341]             }))
[16:09:31.341]             future::FutureResult(value = ...future.value$value, 
[16:09:31.341]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.341]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.341]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.341]                     ...future.globalenv.names))
[16:09:31.341]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.341]         }, condition = base::local({
[16:09:31.341]             c <- base::c
[16:09:31.341]             inherits <- base::inherits
[16:09:31.341]             invokeRestart <- base::invokeRestart
[16:09:31.341]             length <- base::length
[16:09:31.341]             list <- base::list
[16:09:31.341]             seq.int <- base::seq.int
[16:09:31.341]             signalCondition <- base::signalCondition
[16:09:31.341]             sys.calls <- base::sys.calls
[16:09:31.341]             `[[` <- base::`[[`
[16:09:31.341]             `+` <- base::`+`
[16:09:31.341]             `<<-` <- base::`<<-`
[16:09:31.341]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.341]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.341]                   3L)]
[16:09:31.341]             }
[16:09:31.341]             function(cond) {
[16:09:31.341]                 is_error <- inherits(cond, "error")
[16:09:31.341]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.341]                   NULL)
[16:09:31.341]                 if (is_error) {
[16:09:31.341]                   sessionInformation <- function() {
[16:09:31.341]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.341]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.341]                       search = base::search(), system = base::Sys.info())
[16:09:31.341]                   }
[16:09:31.341]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.341]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.341]                     cond$call), session = sessionInformation(), 
[16:09:31.341]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.341]                   signalCondition(cond)
[16:09:31.341]                 }
[16:09:31.341]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:09:31.341]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.341]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.341]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.341]                   if (TRUE && !signal) {
[16:09:31.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.341]                     {
[16:09:31.341]                       inherits <- base::inherits
[16:09:31.341]                       invokeRestart <- base::invokeRestart
[16:09:31.341]                       is.null <- base::is.null
[16:09:31.341]                       muffled <- FALSE
[16:09:31.341]                       if (inherits(cond, "message")) {
[16:09:31.341]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.341]                         if (muffled) 
[16:09:31.341]                           invokeRestart("muffleMessage")
[16:09:31.341]                       }
[16:09:31.341]                       else if (inherits(cond, "warning")) {
[16:09:31.341]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.341]                         if (muffled) 
[16:09:31.341]                           invokeRestart("muffleWarning")
[16:09:31.341]                       }
[16:09:31.341]                       else if (inherits(cond, "condition")) {
[16:09:31.341]                         if (!is.null(pattern)) {
[16:09:31.341]                           computeRestarts <- base::computeRestarts
[16:09:31.341]                           grepl <- base::grepl
[16:09:31.341]                           restarts <- computeRestarts(cond)
[16:09:31.341]                           for (restart in restarts) {
[16:09:31.341]                             name <- restart$name
[16:09:31.341]                             if (is.null(name)) 
[16:09:31.341]                               next
[16:09:31.341]                             if (!grepl(pattern, name)) 
[16:09:31.341]                               next
[16:09:31.341]                             invokeRestart(restart)
[16:09:31.341]                             muffled <- TRUE
[16:09:31.341]                             break
[16:09:31.341]                           }
[16:09:31.341]                         }
[16:09:31.341]                       }
[16:09:31.341]                       invisible(muffled)
[16:09:31.341]                     }
[16:09:31.341]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.341]                   }
[16:09:31.341]                 }
[16:09:31.341]                 else {
[16:09:31.341]                   if (TRUE) {
[16:09:31.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.341]                     {
[16:09:31.341]                       inherits <- base::inherits
[16:09:31.341]                       invokeRestart <- base::invokeRestart
[16:09:31.341]                       is.null <- base::is.null
[16:09:31.341]                       muffled <- FALSE
[16:09:31.341]                       if (inherits(cond, "message")) {
[16:09:31.341]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.341]                         if (muffled) 
[16:09:31.341]                           invokeRestart("muffleMessage")
[16:09:31.341]                       }
[16:09:31.341]                       else if (inherits(cond, "warning")) {
[16:09:31.341]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.341]                         if (muffled) 
[16:09:31.341]                           invokeRestart("muffleWarning")
[16:09:31.341]                       }
[16:09:31.341]                       else if (inherits(cond, "condition")) {
[16:09:31.341]                         if (!is.null(pattern)) {
[16:09:31.341]                           computeRestarts <- base::computeRestarts
[16:09:31.341]                           grepl <- base::grepl
[16:09:31.341]                           restarts <- computeRestarts(cond)
[16:09:31.341]                           for (restart in restarts) {
[16:09:31.341]                             name <- restart$name
[16:09:31.341]                             if (is.null(name)) 
[16:09:31.341]                               next
[16:09:31.341]                             if (!grepl(pattern, name)) 
[16:09:31.341]                               next
[16:09:31.341]                             invokeRestart(restart)
[16:09:31.341]                             muffled <- TRUE
[16:09:31.341]                             break
[16:09:31.341]                           }
[16:09:31.341]                         }
[16:09:31.341]                       }
[16:09:31.341]                       invisible(muffled)
[16:09:31.341]                     }
[16:09:31.341]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.341]                   }
[16:09:31.341]                 }
[16:09:31.341]             }
[16:09:31.341]         }))
[16:09:31.341]     }, error = function(ex) {
[16:09:31.341]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.341]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.341]                 ...future.rng), started = ...future.startTime, 
[16:09:31.341]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.341]             version = "1.8"), class = "FutureResult")
[16:09:31.341]     }, finally = {
[16:09:31.341]         if (!identical(...future.workdir, getwd())) 
[16:09:31.341]             setwd(...future.workdir)
[16:09:31.341]         {
[16:09:31.341]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.341]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.341]             }
[16:09:31.341]             base::options(...future.oldOptions)
[16:09:31.341]             if (.Platform$OS.type == "windows") {
[16:09:31.341]                 old_names <- names(...future.oldEnvVars)
[16:09:31.341]                 envs <- base::Sys.getenv()
[16:09:31.341]                 names <- names(envs)
[16:09:31.341]                 common <- intersect(names, old_names)
[16:09:31.341]                 added <- setdiff(names, old_names)
[16:09:31.341]                 removed <- setdiff(old_names, names)
[16:09:31.341]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.341]                   envs[common]]
[16:09:31.341]                 NAMES <- toupper(changed)
[16:09:31.341]                 args <- list()
[16:09:31.341]                 for (kk in seq_along(NAMES)) {
[16:09:31.341]                   name <- changed[[kk]]
[16:09:31.341]                   NAME <- NAMES[[kk]]
[16:09:31.341]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.341]                     next
[16:09:31.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.341]                 }
[16:09:31.341]                 NAMES <- toupper(added)
[16:09:31.341]                 for (kk in seq_along(NAMES)) {
[16:09:31.341]                   name <- added[[kk]]
[16:09:31.341]                   NAME <- NAMES[[kk]]
[16:09:31.341]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.341]                     next
[16:09:31.341]                   args[[name]] <- ""
[16:09:31.341]                 }
[16:09:31.341]                 NAMES <- toupper(removed)
[16:09:31.341]                 for (kk in seq_along(NAMES)) {
[16:09:31.341]                   name <- removed[[kk]]
[16:09:31.341]                   NAME <- NAMES[[kk]]
[16:09:31.341]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.341]                     next
[16:09:31.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.341]                 }
[16:09:31.341]                 if (length(args) > 0) 
[16:09:31.341]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.341]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.341]             }
[16:09:31.341]             else {
[16:09:31.341]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.341]             }
[16:09:31.341]             {
[16:09:31.341]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.341]                   0L) {
[16:09:31.341]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.341]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.341]                   base::options(opts)
[16:09:31.341]                 }
[16:09:31.341]                 {
[16:09:31.341]                   {
[16:09:31.341]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:31.341]                     NULL
[16:09:31.341]                   }
[16:09:31.341]                   options(future.plan = NULL)
[16:09:31.341]                   if (is.na(NA_character_)) 
[16:09:31.341]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.341]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.341]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:31.341]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:31.341]                     envir = parent.frame()) 
[16:09:31.341]                   {
[16:09:31.341]                     if (is.function(workers)) 
[16:09:31.341]                       workers <- workers()
[16:09:31.341]                     workers <- structure(as.integer(workers), 
[16:09:31.341]                       class = class(workers))
[16:09:31.341]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:31.341]                       workers >= 1)
[16:09:31.341]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:31.341]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:31.341]                     }
[16:09:31.341]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:31.341]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:31.341]                       envir = envir)
[16:09:31.341]                     if (!future$lazy) 
[16:09:31.341]                       future <- run(future)
[16:09:31.341]                     invisible(future)
[16:09:31.341]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.341]                 }
[16:09:31.341]             }
[16:09:31.341]         }
[16:09:31.341]     })
[16:09:31.341]     if (TRUE) {
[16:09:31.341]         base::sink(type = "output", split = FALSE)
[16:09:31.341]         if (TRUE) {
[16:09:31.341]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.341]         }
[16:09:31.341]         else {
[16:09:31.341]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.341]         }
[16:09:31.341]         base::close(...future.stdout)
[16:09:31.341]         ...future.stdout <- NULL
[16:09:31.341]     }
[16:09:31.341]     ...future.result$conditions <- ...future.conditions
[16:09:31.341]     ...future.result$finished <- base::Sys.time()
[16:09:31.341]     ...future.result
[16:09:31.341] }
[16:09:31.344] Exporting 5 global objects (35.58 KiB) to cluster node #1 ...
[16:09:31.344] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:09:31.345] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.345] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[16:09:31.388] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[16:09:31.388] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:09:31.388] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:09:31.388] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[16:09:31.389] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[16:09:31.389] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:09:31.389] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:09:31.389] Exporting 5 global objects (35.58 KiB) to cluster node #1 ... DONE
[16:09:31.390] MultisessionFuture started
[16:09:31.390] - Launch lazy future ... done
[16:09:31.390] run() for ‘MultisessionFuture’ ... done
[16:09:31.390] Created future:
[16:09:31.390] MultisessionFuture:
[16:09:31.390] Label: ‘future_apply-1’
[16:09:31.390] Expression:
[16:09:31.390] {
[16:09:31.390]     do.call(function(...) {
[16:09:31.390]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.390]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.390]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.390]             on.exit(options(oopts), add = TRUE)
[16:09:31.390]         }
[16:09:31.390]         {
[16:09:31.390]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.390]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.390]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:31.390]                   envir = globalenv(), inherits = FALSE)
[16:09:31.390]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.390]             })
[16:09:31.390]         }
[16:09:31.390]     }, args = future.call.arguments)
[16:09:31.390] }
[16:09:31.390] Lazy evaluation: FALSE
[16:09:31.390] Asynchronous evaluation: TRUE
[16:09:31.390] Local evaluation: TRUE
[16:09:31.390] Environment: R_GlobalEnv
[16:09:31.390] Capture standard output: TRUE
[16:09:31.390] Capture condition classes: <none>
[16:09:31.390] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.390] Packages: <none>
[16:09:31.390] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:09:31.390] Resolved: FALSE
[16:09:31.390] Value: <not collected>
[16:09:31.390] Conditions captured: <none>
[16:09:31.390] Early signaling: FALSE
[16:09:31.390] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:31.390] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.402] Chunk #1 of 2 ... DONE
[16:09:31.402] Chunk #2 of 2 ...
[16:09:31.402]  - seeds: [1] <seeds>
[16:09:31.402] getGlobalsAndPackages() ...
[16:09:31.402] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.402] Resolving globals: FALSE
[16:09:31.402] Tweak future expression to call with '...' arguments ...
[16:09:31.403] {
[16:09:31.403]     do.call(function(...) {
[16:09:31.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.403]             on.exit(options(oopts), add = TRUE)
[16:09:31.403]         }
[16:09:31.403]         {
[16:09:31.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.403]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:31.403]                   envir = globalenv(), inherits = FALSE)
[16:09:31.403]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.403]             })
[16:09:31.403]         }
[16:09:31.403]     }, args = future.call.arguments)
[16:09:31.403] }
[16:09:31.403] Tweak future expression to call with '...' arguments ... DONE
[16:09:31.403] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:09:31.403] 
[16:09:31.403] getGlobalsAndPackages() ... DONE
[16:09:31.404] run() for ‘Future’ ...
[16:09:31.404] - state: ‘created’
[16:09:31.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:09:31.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:09:31.418]   - Field: ‘node’
[16:09:31.419]   - Field: ‘label’
[16:09:31.419]   - Field: ‘local’
[16:09:31.419]   - Field: ‘owner’
[16:09:31.419]   - Field: ‘envir’
[16:09:31.419]   - Field: ‘workers’
[16:09:31.419]   - Field: ‘packages’
[16:09:31.419]   - Field: ‘gc’
[16:09:31.419]   - Field: ‘conditions’
[16:09:31.419]   - Field: ‘persistent’
[16:09:31.419]   - Field: ‘expr’
[16:09:31.419]   - Field: ‘uuid’
[16:09:31.420]   - Field: ‘seed’
[16:09:31.420]   - Field: ‘version’
[16:09:31.420]   - Field: ‘result’
[16:09:31.420]   - Field: ‘asynchronous’
[16:09:31.420]   - Field: ‘calls’
[16:09:31.420]   - Field: ‘globals’
[16:09:31.420]   - Field: ‘stdout’
[16:09:31.420]   - Field: ‘earlySignal’
[16:09:31.420]   - Field: ‘lazy’
[16:09:31.420]   - Field: ‘state’
[16:09:31.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:09:31.421] - Launch lazy future ...
[16:09:31.421] Packages needed by the future expression (n = 0): <none>
[16:09:31.421] Packages needed by future strategies (n = 0): <none>
[16:09:31.421] {
[16:09:31.421]     {
[16:09:31.421]         {
[16:09:31.421]             ...future.startTime <- base::Sys.time()
[16:09:31.421]             {
[16:09:31.421]                 {
[16:09:31.421]                   {
[16:09:31.421]                     {
[16:09:31.421]                       base::local({
[16:09:31.421]                         has_future <- base::requireNamespace("future", 
[16:09:31.421]                           quietly = TRUE)
[16:09:31.421]                         if (has_future) {
[16:09:31.421]                           ns <- base::getNamespace("future")
[16:09:31.421]                           version <- ns[[".package"]][["version"]]
[16:09:31.421]                           if (is.null(version)) 
[16:09:31.421]                             version <- utils::packageVersion("future")
[16:09:31.421]                         }
[16:09:31.421]                         else {
[16:09:31.421]                           version <- NULL
[16:09:31.421]                         }
[16:09:31.421]                         if (!has_future || version < "1.8.0") {
[16:09:31.421]                           info <- base::c(r_version = base::gsub("R version ", 
[16:09:31.421]                             "", base::R.version$version.string), 
[16:09:31.421]                             platform = base::sprintf("%s (%s-bit)", 
[16:09:31.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:09:31.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:09:31.421]                               "release", "version")], collapse = " "), 
[16:09:31.421]                             hostname = base::Sys.info()[["nodename"]])
[16:09:31.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:09:31.421]                             info)
[16:09:31.421]                           info <- base::paste(info, collapse = "; ")
[16:09:31.421]                           if (!has_future) {
[16:09:31.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:09:31.421]                               info)
[16:09:31.421]                           }
[16:09:31.421]                           else {
[16:09:31.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:09:31.421]                               info, version)
[16:09:31.421]                           }
[16:09:31.421]                           base::stop(msg)
[16:09:31.421]                         }
[16:09:31.421]                       })
[16:09:31.421]                     }
[16:09:31.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:09:31.421]                     base::options(mc.cores = 1L)
[16:09:31.421]                   }
[16:09:31.421]                   options(future.plan = NULL)
[16:09:31.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:09:31.421]                 }
[16:09:31.421]                 ...future.workdir <- getwd()
[16:09:31.421]             }
[16:09:31.421]             ...future.oldOptions <- base::as.list(base::.Options)
[16:09:31.421]             ...future.oldEnvVars <- base::Sys.getenv()
[16:09:31.421]         }
[16:09:31.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:09:31.421]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:09:31.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:09:31.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:09:31.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:09:31.421]             future.stdout.windows.reencode = NULL, width = 80L)
[16:09:31.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:09:31.421]             base::names(...future.oldOptions))
[16:09:31.421]     }
[16:09:31.421]     if (FALSE) {
[16:09:31.421]     }
[16:09:31.421]     else {
[16:09:31.421]         if (TRUE) {
[16:09:31.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:09:31.421]                 open = "w")
[16:09:31.421]         }
[16:09:31.421]         else {
[16:09:31.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:09:31.421]                 windows = "NUL", "/dev/null"), open = "w")
[16:09:31.421]         }
[16:09:31.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:09:31.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:09:31.421]             base::sink(type = "output", split = FALSE)
[16:09:31.421]             base::close(...future.stdout)
[16:09:31.421]         }, add = TRUE)
[16:09:31.421]     }
[16:09:31.421]     ...future.frame <- base::sys.nframe()
[16:09:31.421]     ...future.conditions <- base::list()
[16:09:31.421]     ...future.rng <- base::globalenv()$.Random.seed
[16:09:31.421]     if (FALSE) {
[16:09:31.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:09:31.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:09:31.421]     }
[16:09:31.421]     ...future.result <- base::tryCatch({
[16:09:31.421]         base::withCallingHandlers({
[16:09:31.421]             ...future.value <- base::withVisible(base::local({
[16:09:31.421]                 ...future.makeSendCondition <- local({
[16:09:31.421]                   sendCondition <- NULL
[16:09:31.421]                   function(frame = 1L) {
[16:09:31.421]                     if (is.function(sendCondition)) 
[16:09:31.421]                       return(sendCondition)
[16:09:31.421]                     ns <- getNamespace("parallel")
[16:09:31.421]                     if (exists("sendData", mode = "function", 
[16:09:31.421]                       envir = ns)) {
[16:09:31.421]                       parallel_sendData <- get("sendData", mode = "function", 
[16:09:31.421]                         envir = ns)
[16:09:31.421]                       envir <- sys.frame(frame)
[16:09:31.421]                       master <- NULL
[16:09:31.421]                       while (!identical(envir, .GlobalEnv) && 
[16:09:31.421]                         !identical(envir, emptyenv())) {
[16:09:31.421]                         if (exists("master", mode = "list", envir = envir, 
[16:09:31.421]                           inherits = FALSE)) {
[16:09:31.421]                           master <- get("master", mode = "list", 
[16:09:31.421]                             envir = envir, inherits = FALSE)
[16:09:31.421]                           if (inherits(master, c("SOCKnode", 
[16:09:31.421]                             "SOCK0node"))) {
[16:09:31.421]                             sendCondition <<- function(cond) {
[16:09:31.421]                               data <- list(type = "VALUE", value = cond, 
[16:09:31.421]                                 success = TRUE)
[16:09:31.421]                               parallel_sendData(master, data)
[16:09:31.421]                             }
[16:09:31.421]                             return(sendCondition)
[16:09:31.421]                           }
[16:09:31.421]                         }
[16:09:31.421]                         frame <- frame + 1L
[16:09:31.421]                         envir <- sys.frame(frame)
[16:09:31.421]                       }
[16:09:31.421]                     }
[16:09:31.421]                     sendCondition <<- function(cond) NULL
[16:09:31.421]                   }
[16:09:31.421]                 })
[16:09:31.421]                 withCallingHandlers({
[16:09:31.421]                   {
[16:09:31.421]                     do.call(function(...) {
[16:09:31.421]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.421]                       if (!identical(...future.globals.maxSize.org, 
[16:09:31.421]                         ...future.globals.maxSize)) {
[16:09:31.421]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.421]                         on.exit(options(oopts), add = TRUE)
[16:09:31.421]                       }
[16:09:31.421]                       {
[16:09:31.421]                         lapply(seq_along(...future.elements_ii), 
[16:09:31.421]                           FUN = function(jj) {
[16:09:31.421]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.421]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:31.421]                               envir = globalenv(), inherits = FALSE)
[16:09:31.421]                             ...future.FUN(...future.X_jj, ...)
[16:09:31.421]                           })
[16:09:31.421]                       }
[16:09:31.421]                     }, args = future.call.arguments)
[16:09:31.421]                   }
[16:09:31.421]                 }, immediateCondition = function(cond) {
[16:09:31.421]                   sendCondition <- ...future.makeSendCondition()
[16:09:31.421]                   sendCondition(cond)
[16:09:31.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.421]                   {
[16:09:31.421]                     inherits <- base::inherits
[16:09:31.421]                     invokeRestart <- base::invokeRestart
[16:09:31.421]                     is.null <- base::is.null
[16:09:31.421]                     muffled <- FALSE
[16:09:31.421]                     if (inherits(cond, "message")) {
[16:09:31.421]                       muffled <- grepl(pattern, "muffleMessage")
[16:09:31.421]                       if (muffled) 
[16:09:31.421]                         invokeRestart("muffleMessage")
[16:09:31.421]                     }
[16:09:31.421]                     else if (inherits(cond, "warning")) {
[16:09:31.421]                       muffled <- grepl(pattern, "muffleWarning")
[16:09:31.421]                       if (muffled) 
[16:09:31.421]                         invokeRestart("muffleWarning")
[16:09:31.421]                     }
[16:09:31.421]                     else if (inherits(cond, "condition")) {
[16:09:31.421]                       if (!is.null(pattern)) {
[16:09:31.421]                         computeRestarts <- base::computeRestarts
[16:09:31.421]                         grepl <- base::grepl
[16:09:31.421]                         restarts <- computeRestarts(cond)
[16:09:31.421]                         for (restart in restarts) {
[16:09:31.421]                           name <- restart$name
[16:09:31.421]                           if (is.null(name)) 
[16:09:31.421]                             next
[16:09:31.421]                           if (!grepl(pattern, name)) 
[16:09:31.421]                             next
[16:09:31.421]                           invokeRestart(restart)
[16:09:31.421]                           muffled <- TRUE
[16:09:31.421]                           break
[16:09:31.421]                         }
[16:09:31.421]                       }
[16:09:31.421]                     }
[16:09:31.421]                     invisible(muffled)
[16:09:31.421]                   }
[16:09:31.421]                   muffleCondition(cond)
[16:09:31.421]                 })
[16:09:31.421]             }))
[16:09:31.421]             future::FutureResult(value = ...future.value$value, 
[16:09:31.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.421]                   ...future.rng), globalenv = if (FALSE) 
[16:09:31.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:09:31.421]                     ...future.globalenv.names))
[16:09:31.421]                 else NULL, started = ...future.startTime, version = "1.8")
[16:09:31.421]         }, condition = base::local({
[16:09:31.421]             c <- base::c
[16:09:31.421]             inherits <- base::inherits
[16:09:31.421]             invokeRestart <- base::invokeRestart
[16:09:31.421]             length <- base::length
[16:09:31.421]             list <- base::list
[16:09:31.421]             seq.int <- base::seq.int
[16:09:31.421]             signalCondition <- base::signalCondition
[16:09:31.421]             sys.calls <- base::sys.calls
[16:09:31.421]             `[[` <- base::`[[`
[16:09:31.421]             `+` <- base::`+`
[16:09:31.421]             `<<-` <- base::`<<-`
[16:09:31.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:09:31.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:09:31.421]                   3L)]
[16:09:31.421]             }
[16:09:31.421]             function(cond) {
[16:09:31.421]                 is_error <- inherits(cond, "error")
[16:09:31.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:09:31.421]                   NULL)
[16:09:31.421]                 if (is_error) {
[16:09:31.421]                   sessionInformation <- function() {
[16:09:31.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:09:31.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:09:31.421]                       search = base::search(), system = base::Sys.info())
[16:09:31.421]                   }
[16:09:31.421]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:09:31.421]                     cond$call), session = sessionInformation(), 
[16:09:31.421]                     timestamp = base::Sys.time(), signaled = 0L)
[16:09:31.421]                   signalCondition(cond)
[16:09:31.421]                 }
[16:09:31.421]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:09:31.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:09:31.421]                   ...future.conditions[[length(...future.conditions) + 
[16:09:31.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:09:31.421]                   if (TRUE && !signal) {
[16:09:31.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.421]                     {
[16:09:31.421]                       inherits <- base::inherits
[16:09:31.421]                       invokeRestart <- base::invokeRestart
[16:09:31.421]                       is.null <- base::is.null
[16:09:31.421]                       muffled <- FALSE
[16:09:31.421]                       if (inherits(cond, "message")) {
[16:09:31.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.421]                         if (muffled) 
[16:09:31.421]                           invokeRestart("muffleMessage")
[16:09:31.421]                       }
[16:09:31.421]                       else if (inherits(cond, "warning")) {
[16:09:31.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.421]                         if (muffled) 
[16:09:31.421]                           invokeRestart("muffleWarning")
[16:09:31.421]                       }
[16:09:31.421]                       else if (inherits(cond, "condition")) {
[16:09:31.421]                         if (!is.null(pattern)) {
[16:09:31.421]                           computeRestarts <- base::computeRestarts
[16:09:31.421]                           grepl <- base::grepl
[16:09:31.421]                           restarts <- computeRestarts(cond)
[16:09:31.421]                           for (restart in restarts) {
[16:09:31.421]                             name <- restart$name
[16:09:31.421]                             if (is.null(name)) 
[16:09:31.421]                               next
[16:09:31.421]                             if (!grepl(pattern, name)) 
[16:09:31.421]                               next
[16:09:31.421]                             invokeRestart(restart)
[16:09:31.421]                             muffled <- TRUE
[16:09:31.421]                             break
[16:09:31.421]                           }
[16:09:31.421]                         }
[16:09:31.421]                       }
[16:09:31.421]                       invisible(muffled)
[16:09:31.421]                     }
[16:09:31.421]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.421]                   }
[16:09:31.421]                 }
[16:09:31.421]                 else {
[16:09:31.421]                   if (TRUE) {
[16:09:31.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:09:31.421]                     {
[16:09:31.421]                       inherits <- base::inherits
[16:09:31.421]                       invokeRestart <- base::invokeRestart
[16:09:31.421]                       is.null <- base::is.null
[16:09:31.421]                       muffled <- FALSE
[16:09:31.421]                       if (inherits(cond, "message")) {
[16:09:31.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:09:31.421]                         if (muffled) 
[16:09:31.421]                           invokeRestart("muffleMessage")
[16:09:31.421]                       }
[16:09:31.421]                       else if (inherits(cond, "warning")) {
[16:09:31.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:09:31.421]                         if (muffled) 
[16:09:31.421]                           invokeRestart("muffleWarning")
[16:09:31.421]                       }
[16:09:31.421]                       else if (inherits(cond, "condition")) {
[16:09:31.421]                         if (!is.null(pattern)) {
[16:09:31.421]                           computeRestarts <- base::computeRestarts
[16:09:31.421]                           grepl <- base::grepl
[16:09:31.421]                           restarts <- computeRestarts(cond)
[16:09:31.421]                           for (restart in restarts) {
[16:09:31.421]                             name <- restart$name
[16:09:31.421]                             if (is.null(name)) 
[16:09:31.421]                               next
[16:09:31.421]                             if (!grepl(pattern, name)) 
[16:09:31.421]                               next
[16:09:31.421]                             invokeRestart(restart)
[16:09:31.421]                             muffled <- TRUE
[16:09:31.421]                             break
[16:09:31.421]                           }
[16:09:31.421]                         }
[16:09:31.421]                       }
[16:09:31.421]                       invisible(muffled)
[16:09:31.421]                     }
[16:09:31.421]                     muffleCondition(cond, pattern = "^muffle")
[16:09:31.421]                   }
[16:09:31.421]                 }
[16:09:31.421]             }
[16:09:31.421]         }))
[16:09:31.421]     }, error = function(ex) {
[16:09:31.421]         base::structure(base::list(value = NULL, visible = NULL, 
[16:09:31.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:09:31.421]                 ...future.rng), started = ...future.startTime, 
[16:09:31.421]             finished = Sys.time(), session_uuid = NA_character_, 
[16:09:31.421]             version = "1.8"), class = "FutureResult")
[16:09:31.421]     }, finally = {
[16:09:31.421]         if (!identical(...future.workdir, getwd())) 
[16:09:31.421]             setwd(...future.workdir)
[16:09:31.421]         {
[16:09:31.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:09:31.421]                 ...future.oldOptions$nwarnings <- NULL
[16:09:31.421]             }
[16:09:31.421]             base::options(...future.oldOptions)
[16:09:31.421]             if (.Platform$OS.type == "windows") {
[16:09:31.421]                 old_names <- names(...future.oldEnvVars)
[16:09:31.421]                 envs <- base::Sys.getenv()
[16:09:31.421]                 names <- names(envs)
[16:09:31.421]                 common <- intersect(names, old_names)
[16:09:31.421]                 added <- setdiff(names, old_names)
[16:09:31.421]                 removed <- setdiff(old_names, names)
[16:09:31.421]                 changed <- common[...future.oldEnvVars[common] != 
[16:09:31.421]                   envs[common]]
[16:09:31.421]                 NAMES <- toupper(changed)
[16:09:31.421]                 args <- list()
[16:09:31.421]                 for (kk in seq_along(NAMES)) {
[16:09:31.421]                   name <- changed[[kk]]
[16:09:31.421]                   NAME <- NAMES[[kk]]
[16:09:31.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.421]                     next
[16:09:31.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.421]                 }
[16:09:31.421]                 NAMES <- toupper(added)
[16:09:31.421]                 for (kk in seq_along(NAMES)) {
[16:09:31.421]                   name <- added[[kk]]
[16:09:31.421]                   NAME <- NAMES[[kk]]
[16:09:31.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.421]                     next
[16:09:31.421]                   args[[name]] <- ""
[16:09:31.421]                 }
[16:09:31.421]                 NAMES <- toupper(removed)
[16:09:31.421]                 for (kk in seq_along(NAMES)) {
[16:09:31.421]                   name <- removed[[kk]]
[16:09:31.421]                   NAME <- NAMES[[kk]]
[16:09:31.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:09:31.421]                     next
[16:09:31.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:09:31.421]                 }
[16:09:31.421]                 if (length(args) > 0) 
[16:09:31.421]                   base::do.call(base::Sys.setenv, args = args)
[16:09:31.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:09:31.421]             }
[16:09:31.421]             else {
[16:09:31.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:09:31.421]             }
[16:09:31.421]             {
[16:09:31.421]                 if (base::length(...future.futureOptionsAdded) > 
[16:09:31.421]                   0L) {
[16:09:31.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:09:31.421]                   base::names(opts) <- ...future.futureOptionsAdded
[16:09:31.421]                   base::options(opts)
[16:09:31.421]                 }
[16:09:31.421]                 {
[16:09:31.421]                   {
[16:09:31.421]                     base::options(mc.cores = ...future.mc.cores.old)
[16:09:31.421]                     NULL
[16:09:31.421]                   }
[16:09:31.421]                   options(future.plan = NULL)
[16:09:31.421]                   if (is.na(NA_character_)) 
[16:09:31.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:09:31.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:09:31.421]                   future::plan(list(function (..., workers = availableCores(), 
[16:09:31.421]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:09:31.421]                     envir = parent.frame()) 
[16:09:31.421]                   {
[16:09:31.421]                     if (is.function(workers)) 
[16:09:31.421]                       workers <- workers()
[16:09:31.421]                     workers <- structure(as.integer(workers), 
[16:09:31.421]                       class = class(workers))
[16:09:31.421]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:09:31.421]                       workers >= 1)
[16:09:31.421]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:09:31.421]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:09:31.421]                     }
[16:09:31.421]                     future <- MultisessionFuture(..., workers = workers, 
[16:09:31.421]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:09:31.421]                       envir = envir)
[16:09:31.421]                     if (!future$lazy) 
[16:09:31.421]                       future <- run(future)
[16:09:31.421]                     invisible(future)
[16:09:31.421]                   }), .cleanup = FALSE, .init = FALSE)
[16:09:31.421]                 }
[16:09:31.421]             }
[16:09:31.421]         }
[16:09:31.421]     })
[16:09:31.421]     if (TRUE) {
[16:09:31.421]         base::sink(type = "output", split = FALSE)
[16:09:31.421]         if (TRUE) {
[16:09:31.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:09:31.421]         }
[16:09:31.421]         else {
[16:09:31.421]             ...future.result["stdout"] <- base::list(NULL)
[16:09:31.421]         }
[16:09:31.421]         base::close(...future.stdout)
[16:09:31.421]         ...future.stdout <- NULL
[16:09:31.421]     }
[16:09:31.421]     ...future.result$conditions <- ...future.conditions
[16:09:31.421]     ...future.result$finished <- base::Sys.time()
[16:09:31.421]     ...future.result
[16:09:31.421] }
[16:09:31.424] Exporting 5 global objects (35.58 KiB) to cluster node #2 ...
[16:09:31.425] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:09:31.425] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.425] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[16:09:31.468] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[16:09:31.468] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:09:31.468] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:09:31.469] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[16:09:31.469] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[16:09:31.469] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:09:31.469] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:09:31.470] Exporting 5 global objects (35.58 KiB) to cluster node #2 ... DONE
[16:09:31.470] MultisessionFuture started
[16:09:31.470] - Launch lazy future ... done
[16:09:31.470] run() for ‘MultisessionFuture’ ... done
[16:09:31.471] Created future:
[16:09:31.471] MultisessionFuture:
[16:09:31.471] Label: ‘future_apply-2’
[16:09:31.471] Expression:
[16:09:31.471] {
[16:09:31.471]     do.call(function(...) {
[16:09:31.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:09:31.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:09:31.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:09:31.471]             on.exit(options(oopts), add = TRUE)
[16:09:31.471]         }
[16:09:31.471]         {
[16:09:31.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:09:31.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:09:31.471]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:09:31.471]                   envir = globalenv(), inherits = FALSE)
[16:09:31.471]                 ...future.FUN(...future.X_jj, ...)
[16:09:31.471]             })
[16:09:31.471]         }
[16:09:31.471]     }, args = future.call.arguments)
[16:09:31.471] }
[16:09:31.471] Lazy evaluation: FALSE
[16:09:31.471] Asynchronous evaluation: TRUE
[16:09:31.471] Local evaluation: TRUE
[16:09:31.471] Environment: R_GlobalEnv
[16:09:31.471] Capture standard output: TRUE
[16:09:31.471] Capture condition classes: <none>
[16:09:31.471] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:09:31.471] Packages: <none>
[16:09:31.471] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:09:31.471] Resolved: FALSE
[16:09:31.471] Value: <not collected>
[16:09:31.471] Conditions captured: <none>
[16:09:31.471] Early signaling: FALSE
[16:09:31.471] Owner process: c2589779-0151-d810-7c26-e584b8af1d35
[16:09:31.471] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:09:31.482] Chunk #2 of 2 ... DONE
[16:09:31.482] Launching 2 futures (chunks) ... DONE
[16:09:31.482] Resolving 2 futures (chunks) ...
[16:09:31.483] resolve() on list ...
[16:09:31.483]  recursive: 0
[16:09:31.483]  length: 2
[16:09:31.483] 
[16:09:31.483] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.483] - Validating connection of MultisessionFuture
[16:09:31.484] - received message: FutureResult
[16:09:31.484] - Received FutureResult
[16:09:31.484] - Erased future from FutureRegistry
[16:09:31.484] result() for ClusterFuture ...
[16:09:31.484] - result already collected: FutureResult
[16:09:31.484] result() for ClusterFuture ... done
[16:09:31.484] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.484] Future #1
[16:09:31.484] result() for ClusterFuture ...
[16:09:31.484] - result already collected: FutureResult
[16:09:31.485] result() for ClusterFuture ... done
[16:09:31.485] result() for ClusterFuture ...
[16:09:31.485] - result already collected: FutureResult
[16:09:31.485] result() for ClusterFuture ... done
[16:09:31.485] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:09:31.485] - nx: 2
[16:09:31.485] - relay: TRUE
[16:09:31.485] - stdout: TRUE
[16:09:31.485] - signal: TRUE
[16:09:31.487] - resignal: FALSE
[16:09:31.488] - force: TRUE
[16:09:31.488] - relayed: [n=2] FALSE, FALSE
[16:09:31.488] - queued futures: [n=2] FALSE, FALSE
[16:09:31.488]  - until=1
[16:09:31.488]  - relaying element #1
[16:09:31.488] result() for ClusterFuture ...
[16:09:31.488] - result already collected: FutureResult
[16:09:31.488] result() for ClusterFuture ... done
[16:09:31.488] result() for ClusterFuture ...
[16:09:31.488] - result already collected: FutureResult
[16:09:31.488] result() for ClusterFuture ... done
[16:09:31.489] result() for ClusterFuture ...
[16:09:31.489] - result already collected: FutureResult
[16:09:31.489] result() for ClusterFuture ... done
[16:09:31.489] result() for ClusterFuture ...
[16:09:31.489] - result already collected: FutureResult
[16:09:31.489] result() for ClusterFuture ... done
[16:09:31.489] - relayed: [n=2] TRUE, FALSE
[16:09:31.489] - queued futures: [n=2] TRUE, FALSE
[16:09:31.489] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:09:31.489]  length: 1 (resolved future 1)
[16:09:31.518] receiveMessageFromWorker() for ClusterFuture ...
[16:09:31.518] - Validating connection of MultisessionFuture
[16:09:31.519] - received message: FutureResult
[16:09:31.519] - Received FutureResult
[16:09:31.519] - Erased future from FutureRegistry
[16:09:31.519] result() for ClusterFuture ...
[16:09:31.519] - result already collected: FutureResult
[16:09:31.519] result() for ClusterFuture ... done
[16:09:31.519] receiveMessageFromWorker() for ClusterFuture ... done
[16:09:31.519] Future #2
[16:09:31.519] result() for ClusterFuture ...
[16:09:31.520] - result already collected: FutureResult
[16:09:31.520] result() for ClusterFuture ... done
[16:09:31.520] result() for ClusterFuture ...
[16:09:31.520] - result already collected: FutureResult
[16:09:31.520] result() for ClusterFuture ... done
[16:09:31.520] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:09:31.520] - nx: 2
[16:09:31.520] - relay: TRUE
[16:09:31.520] - stdout: TRUE
[16:09:31.520] - signal: TRUE
[16:09:31.520] - resignal: FALSE
[16:09:31.521] - force: TRUE
[16:09:31.521] - relayed: [n=2] TRUE, FALSE
[16:09:31.521] - queued futures: [n=2] TRUE, FALSE
[16:09:31.521]  - until=2
[16:09:31.521]  - relaying element #2
[16:09:31.521] result() for ClusterFuture ...
[16:09:31.521] - result already collected: FutureResult
[16:09:31.521] result() for ClusterFuture ... done
[16:09:31.521] result() for ClusterFuture ...
[16:09:31.521] - result already collected: FutureResult
[16:09:31.521] result() for ClusterFuture ... done
[16:09:31.522] result() for ClusterFuture ...
[16:09:31.522] - result already collected: FutureResult
[16:09:31.522] result() for ClusterFuture ... done
[16:09:31.522] result() for ClusterFuture ...
[16:09:31.522] - result already collected: FutureResult
[16:09:31.522] result() for ClusterFuture ... done
[16:09:31.522] - relayed: [n=2] TRUE, TRUE
[16:09:31.522] - queued futures: [n=2] TRUE, TRUE
[16:09:31.522] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:09:31.522]  length: 0 (resolved future 2)
[16:09:31.522] Relaying remaining futures
[16:09:31.523] signalConditionsASAP(NULL, pos=0) ...
[16:09:31.523] - nx: 2
[16:09:31.523] - relay: TRUE
[16:09:31.523] - stdout: TRUE
[16:09:31.523] - signal: TRUE
[16:09:31.523] - resignal: FALSE
[16:09:31.523] - force: TRUE
[16:09:31.523] - relayed: [n=2] TRUE, TRUE
[16:09:31.523] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:09:31.523] - relayed: [n=2] TRUE, TRUE
[16:09:31.523] - queued futures: [n=2] TRUE, TRUE
[16:09:31.523] signalConditionsASAP(NULL, pos=0) ... done
[16:09:31.524] resolve() on list ... DONE
[16:09:31.524] result() for ClusterFuture ...
[16:09:31.524] - result already collected: FutureResult
[16:09:31.524] result() for ClusterFuture ... done
[16:09:31.524] result() for ClusterFuture ...
[16:09:31.524] - result already collected: FutureResult
[16:09:31.524] result() for ClusterFuture ... done
[16:09:31.524] result() for ClusterFuture ...
[16:09:31.524] - result already collected: FutureResult
[16:09:31.524] result() for ClusterFuture ... done
[16:09:31.524] result() for ClusterFuture ...
[16:09:31.525] - result already collected: FutureResult
[16:09:31.525] result() for ClusterFuture ... done
[16:09:31.525]  - Number of value chunks collected: 2
[16:09:31.525] Resolving 2 futures (chunks) ... DONE
[16:09:31.525] Reducing values from 2 chunks ...
[16:09:31.525]  - Number of values collected after concatenation: 2
[16:09:31.525]  - Number of values expected: 2
[16:09:31.525] Reducing values from 2 chunks ... DONE
[16:09:31.525] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:09:31.526] plan(): Setting new future strategy stack:
[16:09:31.526] List of future strategies:
[16:09:31.526] 1. sequential:
[16:09:31.526]    - args: function (..., envir = parent.frame())
[16:09:31.526]    - tweaked: FALSE
[16:09:31.526]    - call: plan(sequential)
[16:09:31.526] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[16:09:31.528] plan(): Setting new future strategy stack:
[16:09:31.528] List of future strategies:
[16:09:31.528] 1. FutureStrategy:
[16:09:31.528]    - args: function (..., envir = parent.frame())
[16:09:31.528]    - tweaked: FALSE
[16:09:31.528]    - call: future::plan(oplan)
[16:09:31.528] plan(): nbrOfWorkers() = 1
> 
