
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:17:23.620] plan(): Setting new future strategy stack:
[13:17:23.621] List of future strategies:
[13:17:23.621] 1. sequential:
[13:17:23.621]    - args: function (..., envir = parent.frame())
[13:17:23.621]    - tweaked: FALSE
[13:17:23.621]    - call: future::plan("sequential")
[13:17:23.631] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:17:23.690] plan(): Setting new future strategy stack:
[13:17:23.690] List of future strategies:
[13:17:23.690] 1. sequential:
[13:17:23.690]    - args: function (..., envir = parent.frame())
[13:17:23.690]    - tweaked: FALSE
[13:17:23.690]    - call: plan(strategy)
[13:17:23.701] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[13:17:23.702] getGlobalsAndPackagesXApply() ...
[13:17:23.702]  - future.globals: TRUE
[13:17:23.703] getGlobalsAndPackages() ...
[13:17:23.703] Searching for globals...
[13:17:23.745] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:17:23.745] Searching for globals ... DONE
[13:17:23.745] Resolving globals: FALSE
[13:17:23.748] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:17:23.748] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:17:23.748] - globals: [1] ‘FUN’
[13:17:23.748] 
[13:17:23.748] getGlobalsAndPackages() ... DONE
[13:17:23.748]  - globals found/used: [n=1] ‘FUN’
[13:17:23.749]  - needed namespaces: [n=0] 
[13:17:23.749] Finding globals ... DONE
[13:17:23.749]  - use_args: TRUE
[13:17:23.749]  - Getting '...' globals ...
[13:17:23.750] resolve() on list ...
[13:17:23.750]  recursive: 0
[13:17:23.750]  length: 1
[13:17:23.750]  elements: ‘...’
[13:17:23.750]  length: 0 (resolved future 1)
[13:17:23.750] resolve() on list ... DONE
[13:17:23.751]    - '...' content: [n=0] 
[13:17:23.751] List of 1
[13:17:23.751]  $ ...: list()
[13:17:23.751]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.751]  - attr(*, "where")=List of 1
[13:17:23.751]   ..$ ...:<environment: 0x5647bb1f0a00> 
[13:17:23.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.751]  - attr(*, "resolved")= logi TRUE
[13:17:23.751]  - attr(*, "total_size")= num NA
[13:17:23.756]  - Getting '...' globals ... DONE
[13:17:23.756] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:23.756] List of 2
[13:17:23.756]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:23.756]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:23.756]  $ ...          : list()
[13:17:23.756]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.756]  - attr(*, "where")=List of 2
[13:17:23.756]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:23.756]   ..$ ...          :<environment: 0x5647bb1f0a00> 
[13:17:23.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.756]  - attr(*, "resolved")= logi FALSE
[13:17:23.756]  - attr(*, "total_size")= num 354224
[13:17:23.759] Packages to be attached in all futures: [n=0] 
[13:17:23.759] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.759] future_lapply() ...
[13:17:23.792] Number of chunks: 1
[13:17:23.792] getGlobalsAndPackagesXApply() ...
[13:17:23.792]  - future.globals: <name-value list> with names ‘list()’
[13:17:23.792]  - use_args: TRUE
[13:17:23.793] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:23.793] List of 2
[13:17:23.793]  $ ...          : list()
[13:17:23.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.793]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:23.793]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:23.793]  - attr(*, "where")=List of 2
[13:17:23.793]   ..$ ...          :<environment: 0x5647bb1f0a00> 
[13:17:23.793]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:23.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.793]  - attr(*, "resolved")= logi FALSE
[13:17:23.793]  - attr(*, "total_size")= num NA
[13:17:23.796] Packages to be attached in all futures: [n=0] 
[13:17:23.796] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.796] Number of futures (= number of chunks): 1
[13:17:23.796] Launching 1 futures (chunks) ...
[13:17:23.796] Chunk #1 of 1 ...
[13:17:23.797]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:23.797]  - seeds: <none>
[13:17:23.797] getGlobalsAndPackages() ...
[13:17:23.797] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.797] Resolving globals: FALSE
[13:17:23.797] Tweak future expression to call with '...' arguments ...
[13:17:23.797] {
[13:17:23.797]     do.call(function(...) {
[13:17:23.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.797]             on.exit(options(oopts), add = TRUE)
[13:17:23.797]         }
[13:17:23.797]         {
[13:17:23.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.797]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.797]             })
[13:17:23.797]         }
[13:17:23.797]     }, args = future.call.arguments)
[13:17:23.797] }
[13:17:23.798] Tweak future expression to call with '...' arguments ... DONE
[13:17:23.798] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.798] 
[13:17:23.798] getGlobalsAndPackages() ... DONE
[13:17:23.799] run() for ‘Future’ ...
[13:17:23.799] - state: ‘created’
[13:17:23.799] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:23.800] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:23.800]   - Field: ‘label’
[13:17:23.800]   - Field: ‘local’
[13:17:23.800]   - Field: ‘owner’
[13:17:23.800]   - Field: ‘envir’
[13:17:23.800]   - Field: ‘packages’
[13:17:23.800]   - Field: ‘gc’
[13:17:23.800]   - Field: ‘conditions’
[13:17:23.800]   - Field: ‘expr’
[13:17:23.801]   - Field: ‘uuid’
[13:17:23.801]   - Field: ‘seed’
[13:17:23.801]   - Field: ‘version’
[13:17:23.801]   - Field: ‘result’
[13:17:23.801]   - Field: ‘asynchronous’
[13:17:23.801]   - Field: ‘calls’
[13:17:23.801]   - Field: ‘globals’
[13:17:23.801]   - Field: ‘stdout’
[13:17:23.801]   - Field: ‘earlySignal’
[13:17:23.801]   - Field: ‘lazy’
[13:17:23.801]   - Field: ‘state’
[13:17:23.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:23.802] - Launch lazy future ...
[13:17:23.802] Packages needed by the future expression (n = 0): <none>
[13:17:23.803] Packages needed by future strategies (n = 0): <none>
[13:17:23.803] {
[13:17:23.803]     {
[13:17:23.803]         {
[13:17:23.803]             ...future.startTime <- base::Sys.time()
[13:17:23.803]             {
[13:17:23.803]                 {
[13:17:23.803]                   {
[13:17:23.803]                     base::local({
[13:17:23.803]                       has_future <- base::requireNamespace("future", 
[13:17:23.803]                         quietly = TRUE)
[13:17:23.803]                       if (has_future) {
[13:17:23.803]                         ns <- base::getNamespace("future")
[13:17:23.803]                         version <- ns[[".package"]][["version"]]
[13:17:23.803]                         if (is.null(version)) 
[13:17:23.803]                           version <- utils::packageVersion("future")
[13:17:23.803]                       }
[13:17:23.803]                       else {
[13:17:23.803]                         version <- NULL
[13:17:23.803]                       }
[13:17:23.803]                       if (!has_future || version < "1.8.0") {
[13:17:23.803]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:23.803]                           "", base::R.version$version.string), 
[13:17:23.803]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:23.803]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:23.803]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:23.803]                             "release", "version")], collapse = " "), 
[13:17:23.803]                           hostname = base::Sys.info()[["nodename"]])
[13:17:23.803]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:23.803]                           info)
[13:17:23.803]                         info <- base::paste(info, collapse = "; ")
[13:17:23.803]                         if (!has_future) {
[13:17:23.803]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:23.803]                             info)
[13:17:23.803]                         }
[13:17:23.803]                         else {
[13:17:23.803]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:23.803]                             info, version)
[13:17:23.803]                         }
[13:17:23.803]                         base::stop(msg)
[13:17:23.803]                       }
[13:17:23.803]                     })
[13:17:23.803]                   }
[13:17:23.803]                   options(future.plan = NULL)
[13:17:23.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:23.803]                 }
[13:17:23.803]                 ...future.workdir <- getwd()
[13:17:23.803]             }
[13:17:23.803]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:23.803]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:23.803]         }
[13:17:23.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:23.803]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:23.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:23.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:23.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:23.803]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:23.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:23.803]             base::names(...future.oldOptions))
[13:17:23.803]     }
[13:17:23.803]     if (FALSE) {
[13:17:23.803]     }
[13:17:23.803]     else {
[13:17:23.803]         if (TRUE) {
[13:17:23.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:23.803]                 open = "w")
[13:17:23.803]         }
[13:17:23.803]         else {
[13:17:23.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:23.803]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:23.803]         }
[13:17:23.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:23.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:23.803]             base::sink(type = "output", split = FALSE)
[13:17:23.803]             base::close(...future.stdout)
[13:17:23.803]         }, add = TRUE)
[13:17:23.803]     }
[13:17:23.803]     ...future.frame <- base::sys.nframe()
[13:17:23.803]     ...future.conditions <- base::list()
[13:17:23.803]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:23.803]     if (FALSE) {
[13:17:23.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:23.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:23.803]     }
[13:17:23.803]     ...future.result <- base::tryCatch({
[13:17:23.803]         base::withCallingHandlers({
[13:17:23.803]             ...future.value <- base::withVisible(base::local({
[13:17:23.803]                 do.call(function(...) {
[13:17:23.803]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.803]                   if (!identical(...future.globals.maxSize.org, 
[13:17:23.803]                     ...future.globals.maxSize)) {
[13:17:23.803]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.803]                     on.exit(options(oopts), add = TRUE)
[13:17:23.803]                   }
[13:17:23.803]                   {
[13:17:23.803]                     lapply(seq_along(...future.elements_ii), 
[13:17:23.803]                       FUN = function(jj) {
[13:17:23.803]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.803]                         ...future.FUN(...future.X_jj, ...)
[13:17:23.803]                       })
[13:17:23.803]                   }
[13:17:23.803]                 }, args = future.call.arguments)
[13:17:23.803]             }))
[13:17:23.803]             future::FutureResult(value = ...future.value$value, 
[13:17:23.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.803]                   ...future.rng), globalenv = if (FALSE) 
[13:17:23.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:23.803]                     ...future.globalenv.names))
[13:17:23.803]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:23.803]         }, condition = base::local({
[13:17:23.803]             c <- base::c
[13:17:23.803]             inherits <- base::inherits
[13:17:23.803]             invokeRestart <- base::invokeRestart
[13:17:23.803]             length <- base::length
[13:17:23.803]             list <- base::list
[13:17:23.803]             seq.int <- base::seq.int
[13:17:23.803]             signalCondition <- base::signalCondition
[13:17:23.803]             sys.calls <- base::sys.calls
[13:17:23.803]             `[[` <- base::`[[`
[13:17:23.803]             `+` <- base::`+`
[13:17:23.803]             `<<-` <- base::`<<-`
[13:17:23.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:23.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:23.803]                   3L)]
[13:17:23.803]             }
[13:17:23.803]             function(cond) {
[13:17:23.803]                 is_error <- inherits(cond, "error")
[13:17:23.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:23.803]                   NULL)
[13:17:23.803]                 if (is_error) {
[13:17:23.803]                   sessionInformation <- function() {
[13:17:23.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:23.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:23.803]                       search = base::search(), system = base::Sys.info())
[13:17:23.803]                   }
[13:17:23.803]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:23.803]                     cond$call), session = sessionInformation(), 
[13:17:23.803]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:23.803]                   signalCondition(cond)
[13:17:23.803]                 }
[13:17:23.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:23.803]                 "immediateCondition"))) {
[13:17:23.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:23.803]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:23.803]                   if (TRUE && !signal) {
[13:17:23.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.803]                     {
[13:17:23.803]                       inherits <- base::inherits
[13:17:23.803]                       invokeRestart <- base::invokeRestart
[13:17:23.803]                       is.null <- base::is.null
[13:17:23.803]                       muffled <- FALSE
[13:17:23.803]                       if (inherits(cond, "message")) {
[13:17:23.803]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.803]                         if (muffled) 
[13:17:23.803]                           invokeRestart("muffleMessage")
[13:17:23.803]                       }
[13:17:23.803]                       else if (inherits(cond, "warning")) {
[13:17:23.803]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.803]                         if (muffled) 
[13:17:23.803]                           invokeRestart("muffleWarning")
[13:17:23.803]                       }
[13:17:23.803]                       else if (inherits(cond, "condition")) {
[13:17:23.803]                         if (!is.null(pattern)) {
[13:17:23.803]                           computeRestarts <- base::computeRestarts
[13:17:23.803]                           grepl <- base::grepl
[13:17:23.803]                           restarts <- computeRestarts(cond)
[13:17:23.803]                           for (restart in restarts) {
[13:17:23.803]                             name <- restart$name
[13:17:23.803]                             if (is.null(name)) 
[13:17:23.803]                               next
[13:17:23.803]                             if (!grepl(pattern, name)) 
[13:17:23.803]                               next
[13:17:23.803]                             invokeRestart(restart)
[13:17:23.803]                             muffled <- TRUE
[13:17:23.803]                             break
[13:17:23.803]                           }
[13:17:23.803]                         }
[13:17:23.803]                       }
[13:17:23.803]                       invisible(muffled)
[13:17:23.803]                     }
[13:17:23.803]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.803]                   }
[13:17:23.803]                 }
[13:17:23.803]                 else {
[13:17:23.803]                   if (TRUE) {
[13:17:23.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.803]                     {
[13:17:23.803]                       inherits <- base::inherits
[13:17:23.803]                       invokeRestart <- base::invokeRestart
[13:17:23.803]                       is.null <- base::is.null
[13:17:23.803]                       muffled <- FALSE
[13:17:23.803]                       if (inherits(cond, "message")) {
[13:17:23.803]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.803]                         if (muffled) 
[13:17:23.803]                           invokeRestart("muffleMessage")
[13:17:23.803]                       }
[13:17:23.803]                       else if (inherits(cond, "warning")) {
[13:17:23.803]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.803]                         if (muffled) 
[13:17:23.803]                           invokeRestart("muffleWarning")
[13:17:23.803]                       }
[13:17:23.803]                       else if (inherits(cond, "condition")) {
[13:17:23.803]                         if (!is.null(pattern)) {
[13:17:23.803]                           computeRestarts <- base::computeRestarts
[13:17:23.803]                           grepl <- base::grepl
[13:17:23.803]                           restarts <- computeRestarts(cond)
[13:17:23.803]                           for (restart in restarts) {
[13:17:23.803]                             name <- restart$name
[13:17:23.803]                             if (is.null(name)) 
[13:17:23.803]                               next
[13:17:23.803]                             if (!grepl(pattern, name)) 
[13:17:23.803]                               next
[13:17:23.803]                             invokeRestart(restart)
[13:17:23.803]                             muffled <- TRUE
[13:17:23.803]                             break
[13:17:23.803]                           }
[13:17:23.803]                         }
[13:17:23.803]                       }
[13:17:23.803]                       invisible(muffled)
[13:17:23.803]                     }
[13:17:23.803]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.803]                   }
[13:17:23.803]                 }
[13:17:23.803]             }
[13:17:23.803]         }))
[13:17:23.803]     }, error = function(ex) {
[13:17:23.803]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:23.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.803]                 ...future.rng), started = ...future.startTime, 
[13:17:23.803]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:23.803]             version = "1.8"), class = "FutureResult")
[13:17:23.803]     }, finally = {
[13:17:23.803]         if (!identical(...future.workdir, getwd())) 
[13:17:23.803]             setwd(...future.workdir)
[13:17:23.803]         {
[13:17:23.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:23.803]                 ...future.oldOptions$nwarnings <- NULL
[13:17:23.803]             }
[13:17:23.803]             base::options(...future.oldOptions)
[13:17:23.803]             if (.Platform$OS.type == "windows") {
[13:17:23.803]                 old_names <- names(...future.oldEnvVars)
[13:17:23.803]                 envs <- base::Sys.getenv()
[13:17:23.803]                 names <- names(envs)
[13:17:23.803]                 common <- intersect(names, old_names)
[13:17:23.803]                 added <- setdiff(names, old_names)
[13:17:23.803]                 removed <- setdiff(old_names, names)
[13:17:23.803]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:23.803]                   envs[common]]
[13:17:23.803]                 NAMES <- toupper(changed)
[13:17:23.803]                 args <- list()
[13:17:23.803]                 for (kk in seq_along(NAMES)) {
[13:17:23.803]                   name <- changed[[kk]]
[13:17:23.803]                   NAME <- NAMES[[kk]]
[13:17:23.803]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.803]                     next
[13:17:23.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.803]                 }
[13:17:23.803]                 NAMES <- toupper(added)
[13:17:23.803]                 for (kk in seq_along(NAMES)) {
[13:17:23.803]                   name <- added[[kk]]
[13:17:23.803]                   NAME <- NAMES[[kk]]
[13:17:23.803]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.803]                     next
[13:17:23.803]                   args[[name]] <- ""
[13:17:23.803]                 }
[13:17:23.803]                 NAMES <- toupper(removed)
[13:17:23.803]                 for (kk in seq_along(NAMES)) {
[13:17:23.803]                   name <- removed[[kk]]
[13:17:23.803]                   NAME <- NAMES[[kk]]
[13:17:23.803]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.803]                     next
[13:17:23.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.803]                 }
[13:17:23.803]                 if (length(args) > 0) 
[13:17:23.803]                   base::do.call(base::Sys.setenv, args = args)
[13:17:23.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:23.803]             }
[13:17:23.803]             else {
[13:17:23.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:23.803]             }
[13:17:23.803]             {
[13:17:23.803]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:23.803]                   0L) {
[13:17:23.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:23.803]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:23.803]                   base::options(opts)
[13:17:23.803]                 }
[13:17:23.803]                 {
[13:17:23.803]                   {
[13:17:23.803]                     NULL
[13:17:23.803]                     RNGkind("Mersenne-Twister")
[13:17:23.803]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:23.803]                       inherits = FALSE)
[13:17:23.803]                   }
[13:17:23.803]                   options(future.plan = NULL)
[13:17:23.803]                   if (is.na(NA_character_)) 
[13:17:23.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:23.803]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:23.803]                   {
[13:17:23.803]                     future <- SequentialFuture(..., envir = envir)
[13:17:23.803]                     if (!future$lazy) 
[13:17:23.803]                       future <- run(future)
[13:17:23.803]                     invisible(future)
[13:17:23.803]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:23.803]                 }
[13:17:23.803]             }
[13:17:23.803]         }
[13:17:23.803]     })
[13:17:23.803]     if (TRUE) {
[13:17:23.803]         base::sink(type = "output", split = FALSE)
[13:17:23.803]         if (TRUE) {
[13:17:23.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:23.803]         }
[13:17:23.803]         else {
[13:17:23.803]             ...future.result["stdout"] <- base::list(NULL)
[13:17:23.803]         }
[13:17:23.803]         base::close(...future.stdout)
[13:17:23.803]         ...future.stdout <- NULL
[13:17:23.803]     }
[13:17:23.803]     ...future.result$conditions <- ...future.conditions
[13:17:23.803]     ...future.result$finished <- base::Sys.time()
[13:17:23.803]     ...future.result
[13:17:23.803] }
[13:17:23.805] assign_globals() ...
[13:17:23.805] List of 5
[13:17:23.805]  $ future.call.arguments    : list()
[13:17:23.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.805]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:23.805]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:23.805]  $ ...future.elements_ii    :List of 2
[13:17:23.805]   ..$ : num [1:4] 1 3 1 7
[13:17:23.805]   ..$ : num [1:4] 2 4 6 8
[13:17:23.805]  $ ...future.seeds_ii       : NULL
[13:17:23.805]  $ ...future.globals.maxSize: num Inf
[13:17:23.805]  - attr(*, "resolved")= logi FALSE
[13:17:23.805]  - attr(*, "total_size")= num NA
[13:17:23.805]  - attr(*, "where")=List of 5
[13:17:23.805]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:23.805]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:23.805]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:23.805]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:23.805]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:23.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.805]  - attr(*, "already-done")= logi TRUE
[13:17:23.811] - copied ‘future.call.arguments’ to environment
[13:17:23.811] - copied ‘...future.FUN’ to environment
[13:17:23.811] - copied ‘...future.elements_ii’ to environment
[13:17:23.811] - copied ‘...future.seeds_ii’ to environment
[13:17:23.811] - copied ‘...future.globals.maxSize’ to environment
[13:17:23.812] assign_globals() ... done
[13:17:23.812] plan(): Setting new future strategy stack:
[13:17:23.812] List of future strategies:
[13:17:23.812] 1. sequential:
[13:17:23.812]    - args: function (..., envir = parent.frame())
[13:17:23.812]    - tweaked: FALSE
[13:17:23.812]    - call: NULL
[13:17:23.812] plan(): nbrOfWorkers() = 1
[13:17:23.814] plan(): Setting new future strategy stack:
[13:17:23.814] List of future strategies:
[13:17:23.814] 1. sequential:
[13:17:23.814]    - args: function (..., envir = parent.frame())
[13:17:23.814]    - tweaked: FALSE
[13:17:23.814]    - call: plan(strategy)
[13:17:23.814] plan(): nbrOfWorkers() = 1
[13:17:23.814] SequentialFuture started (and completed)
[13:17:23.815] - Launch lazy future ... done
[13:17:23.815] run() for ‘SequentialFuture’ ... done
[13:17:23.815] Created future:
[13:17:23.815] SequentialFuture:
[13:17:23.815] Label: ‘future_apply-1’
[13:17:23.815] Expression:
[13:17:23.815] {
[13:17:23.815]     do.call(function(...) {
[13:17:23.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.815]             on.exit(options(oopts), add = TRUE)
[13:17:23.815]         }
[13:17:23.815]         {
[13:17:23.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.815]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.815]             })
[13:17:23.815]         }
[13:17:23.815]     }, args = future.call.arguments)
[13:17:23.815] }
[13:17:23.815] Lazy evaluation: FALSE
[13:17:23.815] Asynchronous evaluation: FALSE
[13:17:23.815] Local evaluation: TRUE
[13:17:23.815] Environment: R_GlobalEnv
[13:17:23.815] Capture standard output: TRUE
[13:17:23.815] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:23.815] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:23.815] Packages: <none>
[13:17:23.815] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:23.815] Resolved: TRUE
[13:17:23.815] Value: 2.21 KiB of class ‘list’
[13:17:23.815] Early signaling: FALSE
[13:17:23.815] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:23.815] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.817] Chunk #1 of 1 ... DONE
[13:17:23.817] Launching 1 futures (chunks) ... DONE
[13:17:23.817] Resolving 1 futures (chunks) ...
[13:17:23.817] resolve() on list ...
[13:17:23.817]  recursive: 0
[13:17:23.817]  length: 1
[13:17:23.817] 
[13:17:23.817] resolved() for ‘SequentialFuture’ ...
[13:17:23.817] - state: ‘finished’
[13:17:23.818] - run: TRUE
[13:17:23.818] - result: ‘FutureResult’
[13:17:23.818] resolved() for ‘SequentialFuture’ ... done
[13:17:23.818] Future #1
[13:17:23.818] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:23.818] - nx: 1
[13:17:23.818] - relay: TRUE
[13:17:23.818] - stdout: TRUE
[13:17:23.819] - signal: TRUE
[13:17:23.819] - resignal: FALSE
[13:17:23.819] - force: TRUE
[13:17:23.819] - relayed: [n=1] FALSE
[13:17:23.819] - queued futures: [n=1] FALSE
[13:17:23.819]  - until=1
[13:17:23.819]  - relaying element #1
[13:17:23.819] - relayed: [n=1] TRUE
[13:17:23.819] - queued futures: [n=1] TRUE
[13:17:23.819] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:23.820]  length: 0 (resolved future 1)
[13:17:23.820] Relaying remaining futures
[13:17:23.820] signalConditionsASAP(NULL, pos=0) ...
[13:17:23.820] - nx: 1
[13:17:23.820] - relay: TRUE
[13:17:23.820] - stdout: TRUE
[13:17:23.820] - signal: TRUE
[13:17:23.820] - resignal: FALSE
[13:17:23.820] - force: TRUE
[13:17:23.820] - relayed: [n=1] TRUE
[13:17:23.820] - queued futures: [n=1] TRUE
 - flush all
[13:17:23.821] - relayed: [n=1] TRUE
[13:17:23.821] - queued futures: [n=1] TRUE
[13:17:23.821] signalConditionsASAP(NULL, pos=0) ... done
[13:17:23.821] resolve() on list ... DONE
[13:17:23.821]  - Number of value chunks collected: 1
[13:17:23.821] Resolving 1 futures (chunks) ... DONE
[13:17:23.821] Reducing values from 1 chunks ...
[13:17:23.821]  - Number of values collected after concatenation: 2
[13:17:23.821]  - Number of values expected: 2
[13:17:23.822] Reducing values from 1 chunks ... DONE
[13:17:23.822] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:17:23.823] getGlobalsAndPackagesXApply() ...
[13:17:23.823]  - future.globals: TRUE
[13:17:23.823] getGlobalsAndPackages() ...
[13:17:23.823] Searching for globals...
[13:17:23.855] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:17:23.855] Searching for globals ... DONE
[13:17:23.855] Resolving globals: FALSE
[13:17:23.857] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:17:23.857] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:17:23.858] - globals: [1] ‘FUN’
[13:17:23.858] 
[13:17:23.858] getGlobalsAndPackages() ... DONE
[13:17:23.858]  - globals found/used: [n=1] ‘FUN’
[13:17:23.858]  - needed namespaces: [n=0] 
[13:17:23.858] Finding globals ... DONE
[13:17:23.858]  - use_args: TRUE
[13:17:23.858]  - Getting '...' globals ...
[13:17:23.858] resolve() on list ...
[13:17:23.859]  recursive: 0
[13:17:23.859]  length: 1
[13:17:23.859]  elements: ‘...’
[13:17:23.859]  length: 0 (resolved future 1)
[13:17:23.859] resolve() on list ... DONE
[13:17:23.859]    - '...' content: [n=0] 
[13:17:23.859] List of 1
[13:17:23.859]  $ ...: list()
[13:17:23.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.859]  - attr(*, "where")=List of 1
[13:17:23.859]   ..$ ...:<environment: 0x5647babd0850> 
[13:17:23.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.859]  - attr(*, "resolved")= logi TRUE
[13:17:23.859]  - attr(*, "total_size")= num NA
[13:17:23.862]  - Getting '...' globals ... DONE
[13:17:23.862] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:23.862] List of 2
[13:17:23.862]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:23.862]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:23.862]  $ ...          : list()
[13:17:23.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.862]  - attr(*, "where")=List of 2
[13:17:23.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:23.862]   ..$ ...          :<environment: 0x5647babd0850> 
[13:17:23.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.862]  - attr(*, "resolved")= logi FALSE
[13:17:23.862]  - attr(*, "total_size")= num 354224
[13:17:23.864] Packages to be attached in all futures: [n=0] 
[13:17:23.864] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.865] future_lapply() ...
[13:17:23.896] Number of chunks: 1
[13:17:23.897] getGlobalsAndPackagesXApply() ...
[13:17:23.897]  - future.globals: <name-value list> with names ‘list()’
[13:17:23.897]  - use_args: TRUE
[13:17:23.897] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:23.897] List of 2
[13:17:23.897]  $ ...          : list()
[13:17:23.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.897]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:23.897]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:23.897]  - attr(*, "where")=List of 2
[13:17:23.897]   ..$ ...          :<environment: 0x5647babd0850> 
[13:17:23.897]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:23.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.897]  - attr(*, "resolved")= logi FALSE
[13:17:23.897]  - attr(*, "total_size")= num NA
[13:17:23.900] Packages to be attached in all futures: [n=0] 
[13:17:23.900] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.901] Number of futures (= number of chunks): 1
[13:17:23.901] Launching 1 futures (chunks) ...
[13:17:23.901] Chunk #1 of 1 ...
[13:17:23.901]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:23.901]  - seeds: <none>
[13:17:23.901] getGlobalsAndPackages() ...
[13:17:23.901] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.901] Resolving globals: FALSE
[13:17:23.901] Tweak future expression to call with '...' arguments ...
[13:17:23.902] {
[13:17:23.902]     do.call(function(...) {
[13:17:23.902]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.902]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.902]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.902]             on.exit(options(oopts), add = TRUE)
[13:17:23.902]         }
[13:17:23.902]         {
[13:17:23.902]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.902]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.902]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.902]             })
[13:17:23.902]         }
[13:17:23.902]     }, args = future.call.arguments)
[13:17:23.902] }
[13:17:23.902] Tweak future expression to call with '...' arguments ... DONE
[13:17:23.902] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.902] 
[13:17:23.902] getGlobalsAndPackages() ... DONE
[13:17:23.903] run() for ‘Future’ ...
[13:17:23.903] - state: ‘created’
[13:17:23.903] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:23.903] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:23.903]   - Field: ‘label’
[13:17:23.904]   - Field: ‘local’
[13:17:23.904]   - Field: ‘owner’
[13:17:23.904]   - Field: ‘envir’
[13:17:23.904]   - Field: ‘packages’
[13:17:23.904]   - Field: ‘gc’
[13:17:23.904]   - Field: ‘conditions’
[13:17:23.904]   - Field: ‘expr’
[13:17:23.905]   - Field: ‘uuid’
[13:17:23.905]   - Field: ‘seed’
[13:17:23.905]   - Field: ‘version’
[13:17:23.905]   - Field: ‘result’
[13:17:23.905]   - Field: ‘asynchronous’
[13:17:23.906]   - Field: ‘calls’
[13:17:23.906]   - Field: ‘globals’
[13:17:23.906]   - Field: ‘stdout’
[13:17:23.906]   - Field: ‘earlySignal’
[13:17:23.906]   - Field: ‘lazy’
[13:17:23.906]   - Field: ‘state’
[13:17:23.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:23.906] - Launch lazy future ...
[13:17:23.906] Packages needed by the future expression (n = 0): <none>
[13:17:23.906] Packages needed by future strategies (n = 0): <none>
[13:17:23.907] {
[13:17:23.907]     {
[13:17:23.907]         {
[13:17:23.907]             ...future.startTime <- base::Sys.time()
[13:17:23.907]             {
[13:17:23.907]                 {
[13:17:23.907]                   {
[13:17:23.907]                     base::local({
[13:17:23.907]                       has_future <- base::requireNamespace("future", 
[13:17:23.907]                         quietly = TRUE)
[13:17:23.907]                       if (has_future) {
[13:17:23.907]                         ns <- base::getNamespace("future")
[13:17:23.907]                         version <- ns[[".package"]][["version"]]
[13:17:23.907]                         if (is.null(version)) 
[13:17:23.907]                           version <- utils::packageVersion("future")
[13:17:23.907]                       }
[13:17:23.907]                       else {
[13:17:23.907]                         version <- NULL
[13:17:23.907]                       }
[13:17:23.907]                       if (!has_future || version < "1.8.0") {
[13:17:23.907]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:23.907]                           "", base::R.version$version.string), 
[13:17:23.907]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:23.907]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:23.907]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:23.907]                             "release", "version")], collapse = " "), 
[13:17:23.907]                           hostname = base::Sys.info()[["nodename"]])
[13:17:23.907]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:23.907]                           info)
[13:17:23.907]                         info <- base::paste(info, collapse = "; ")
[13:17:23.907]                         if (!has_future) {
[13:17:23.907]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:23.907]                             info)
[13:17:23.907]                         }
[13:17:23.907]                         else {
[13:17:23.907]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:23.907]                             info, version)
[13:17:23.907]                         }
[13:17:23.907]                         base::stop(msg)
[13:17:23.907]                       }
[13:17:23.907]                     })
[13:17:23.907]                   }
[13:17:23.907]                   options(future.plan = NULL)
[13:17:23.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:23.907]                 }
[13:17:23.907]                 ...future.workdir <- getwd()
[13:17:23.907]             }
[13:17:23.907]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:23.907]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:23.907]         }
[13:17:23.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:23.907]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:23.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:23.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:23.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:23.907]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:23.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:23.907]             base::names(...future.oldOptions))
[13:17:23.907]     }
[13:17:23.907]     if (FALSE) {
[13:17:23.907]     }
[13:17:23.907]     else {
[13:17:23.907]         if (TRUE) {
[13:17:23.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:23.907]                 open = "w")
[13:17:23.907]         }
[13:17:23.907]         else {
[13:17:23.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:23.907]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:23.907]         }
[13:17:23.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:23.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:23.907]             base::sink(type = "output", split = FALSE)
[13:17:23.907]             base::close(...future.stdout)
[13:17:23.907]         }, add = TRUE)
[13:17:23.907]     }
[13:17:23.907]     ...future.frame <- base::sys.nframe()
[13:17:23.907]     ...future.conditions <- base::list()
[13:17:23.907]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:23.907]     if (FALSE) {
[13:17:23.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:23.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:23.907]     }
[13:17:23.907]     ...future.result <- base::tryCatch({
[13:17:23.907]         base::withCallingHandlers({
[13:17:23.907]             ...future.value <- base::withVisible(base::local({
[13:17:23.907]                 do.call(function(...) {
[13:17:23.907]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.907]                   if (!identical(...future.globals.maxSize.org, 
[13:17:23.907]                     ...future.globals.maxSize)) {
[13:17:23.907]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.907]                     on.exit(options(oopts), add = TRUE)
[13:17:23.907]                   }
[13:17:23.907]                   {
[13:17:23.907]                     lapply(seq_along(...future.elements_ii), 
[13:17:23.907]                       FUN = function(jj) {
[13:17:23.907]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.907]                         ...future.FUN(...future.X_jj, ...)
[13:17:23.907]                       })
[13:17:23.907]                   }
[13:17:23.907]                 }, args = future.call.arguments)
[13:17:23.907]             }))
[13:17:23.907]             future::FutureResult(value = ...future.value$value, 
[13:17:23.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.907]                   ...future.rng), globalenv = if (FALSE) 
[13:17:23.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:23.907]                     ...future.globalenv.names))
[13:17:23.907]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:23.907]         }, condition = base::local({
[13:17:23.907]             c <- base::c
[13:17:23.907]             inherits <- base::inherits
[13:17:23.907]             invokeRestart <- base::invokeRestart
[13:17:23.907]             length <- base::length
[13:17:23.907]             list <- base::list
[13:17:23.907]             seq.int <- base::seq.int
[13:17:23.907]             signalCondition <- base::signalCondition
[13:17:23.907]             sys.calls <- base::sys.calls
[13:17:23.907]             `[[` <- base::`[[`
[13:17:23.907]             `+` <- base::`+`
[13:17:23.907]             `<<-` <- base::`<<-`
[13:17:23.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:23.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:23.907]                   3L)]
[13:17:23.907]             }
[13:17:23.907]             function(cond) {
[13:17:23.907]                 is_error <- inherits(cond, "error")
[13:17:23.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:23.907]                   NULL)
[13:17:23.907]                 if (is_error) {
[13:17:23.907]                   sessionInformation <- function() {
[13:17:23.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:23.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:23.907]                       search = base::search(), system = base::Sys.info())
[13:17:23.907]                   }
[13:17:23.907]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:23.907]                     cond$call), session = sessionInformation(), 
[13:17:23.907]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:23.907]                   signalCondition(cond)
[13:17:23.907]                 }
[13:17:23.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:23.907]                 "immediateCondition"))) {
[13:17:23.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:23.907]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:23.907]                   if (TRUE && !signal) {
[13:17:23.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.907]                     {
[13:17:23.907]                       inherits <- base::inherits
[13:17:23.907]                       invokeRestart <- base::invokeRestart
[13:17:23.907]                       is.null <- base::is.null
[13:17:23.907]                       muffled <- FALSE
[13:17:23.907]                       if (inherits(cond, "message")) {
[13:17:23.907]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.907]                         if (muffled) 
[13:17:23.907]                           invokeRestart("muffleMessage")
[13:17:23.907]                       }
[13:17:23.907]                       else if (inherits(cond, "warning")) {
[13:17:23.907]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.907]                         if (muffled) 
[13:17:23.907]                           invokeRestart("muffleWarning")
[13:17:23.907]                       }
[13:17:23.907]                       else if (inherits(cond, "condition")) {
[13:17:23.907]                         if (!is.null(pattern)) {
[13:17:23.907]                           computeRestarts <- base::computeRestarts
[13:17:23.907]                           grepl <- base::grepl
[13:17:23.907]                           restarts <- computeRestarts(cond)
[13:17:23.907]                           for (restart in restarts) {
[13:17:23.907]                             name <- restart$name
[13:17:23.907]                             if (is.null(name)) 
[13:17:23.907]                               next
[13:17:23.907]                             if (!grepl(pattern, name)) 
[13:17:23.907]                               next
[13:17:23.907]                             invokeRestart(restart)
[13:17:23.907]                             muffled <- TRUE
[13:17:23.907]                             break
[13:17:23.907]                           }
[13:17:23.907]                         }
[13:17:23.907]                       }
[13:17:23.907]                       invisible(muffled)
[13:17:23.907]                     }
[13:17:23.907]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.907]                   }
[13:17:23.907]                 }
[13:17:23.907]                 else {
[13:17:23.907]                   if (TRUE) {
[13:17:23.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.907]                     {
[13:17:23.907]                       inherits <- base::inherits
[13:17:23.907]                       invokeRestart <- base::invokeRestart
[13:17:23.907]                       is.null <- base::is.null
[13:17:23.907]                       muffled <- FALSE
[13:17:23.907]                       if (inherits(cond, "message")) {
[13:17:23.907]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.907]                         if (muffled) 
[13:17:23.907]                           invokeRestart("muffleMessage")
[13:17:23.907]                       }
[13:17:23.907]                       else if (inherits(cond, "warning")) {
[13:17:23.907]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.907]                         if (muffled) 
[13:17:23.907]                           invokeRestart("muffleWarning")
[13:17:23.907]                       }
[13:17:23.907]                       else if (inherits(cond, "condition")) {
[13:17:23.907]                         if (!is.null(pattern)) {
[13:17:23.907]                           computeRestarts <- base::computeRestarts
[13:17:23.907]                           grepl <- base::grepl
[13:17:23.907]                           restarts <- computeRestarts(cond)
[13:17:23.907]                           for (restart in restarts) {
[13:17:23.907]                             name <- restart$name
[13:17:23.907]                             if (is.null(name)) 
[13:17:23.907]                               next
[13:17:23.907]                             if (!grepl(pattern, name)) 
[13:17:23.907]                               next
[13:17:23.907]                             invokeRestart(restart)
[13:17:23.907]                             muffled <- TRUE
[13:17:23.907]                             break
[13:17:23.907]                           }
[13:17:23.907]                         }
[13:17:23.907]                       }
[13:17:23.907]                       invisible(muffled)
[13:17:23.907]                     }
[13:17:23.907]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.907]                   }
[13:17:23.907]                 }
[13:17:23.907]             }
[13:17:23.907]         }))
[13:17:23.907]     }, error = function(ex) {
[13:17:23.907]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:23.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.907]                 ...future.rng), started = ...future.startTime, 
[13:17:23.907]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:23.907]             version = "1.8"), class = "FutureResult")
[13:17:23.907]     }, finally = {
[13:17:23.907]         if (!identical(...future.workdir, getwd())) 
[13:17:23.907]             setwd(...future.workdir)
[13:17:23.907]         {
[13:17:23.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:23.907]                 ...future.oldOptions$nwarnings <- NULL
[13:17:23.907]             }
[13:17:23.907]             base::options(...future.oldOptions)
[13:17:23.907]             if (.Platform$OS.type == "windows") {
[13:17:23.907]                 old_names <- names(...future.oldEnvVars)
[13:17:23.907]                 envs <- base::Sys.getenv()
[13:17:23.907]                 names <- names(envs)
[13:17:23.907]                 common <- intersect(names, old_names)
[13:17:23.907]                 added <- setdiff(names, old_names)
[13:17:23.907]                 removed <- setdiff(old_names, names)
[13:17:23.907]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:23.907]                   envs[common]]
[13:17:23.907]                 NAMES <- toupper(changed)
[13:17:23.907]                 args <- list()
[13:17:23.907]                 for (kk in seq_along(NAMES)) {
[13:17:23.907]                   name <- changed[[kk]]
[13:17:23.907]                   NAME <- NAMES[[kk]]
[13:17:23.907]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.907]                     next
[13:17:23.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.907]                 }
[13:17:23.907]                 NAMES <- toupper(added)
[13:17:23.907]                 for (kk in seq_along(NAMES)) {
[13:17:23.907]                   name <- added[[kk]]
[13:17:23.907]                   NAME <- NAMES[[kk]]
[13:17:23.907]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.907]                     next
[13:17:23.907]                   args[[name]] <- ""
[13:17:23.907]                 }
[13:17:23.907]                 NAMES <- toupper(removed)
[13:17:23.907]                 for (kk in seq_along(NAMES)) {
[13:17:23.907]                   name <- removed[[kk]]
[13:17:23.907]                   NAME <- NAMES[[kk]]
[13:17:23.907]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.907]                     next
[13:17:23.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.907]                 }
[13:17:23.907]                 if (length(args) > 0) 
[13:17:23.907]                   base::do.call(base::Sys.setenv, args = args)
[13:17:23.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:23.907]             }
[13:17:23.907]             else {
[13:17:23.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:23.907]             }
[13:17:23.907]             {
[13:17:23.907]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:23.907]                   0L) {
[13:17:23.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:23.907]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:23.907]                   base::options(opts)
[13:17:23.907]                 }
[13:17:23.907]                 {
[13:17:23.907]                   {
[13:17:23.907]                     NULL
[13:17:23.907]                     RNGkind("Mersenne-Twister")
[13:17:23.907]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:23.907]                       inherits = FALSE)
[13:17:23.907]                   }
[13:17:23.907]                   options(future.plan = NULL)
[13:17:23.907]                   if (is.na(NA_character_)) 
[13:17:23.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:23.907]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:23.907]                   {
[13:17:23.907]                     future <- SequentialFuture(..., envir = envir)
[13:17:23.907]                     if (!future$lazy) 
[13:17:23.907]                       future <- run(future)
[13:17:23.907]                     invisible(future)
[13:17:23.907]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:23.907]                 }
[13:17:23.907]             }
[13:17:23.907]         }
[13:17:23.907]     })
[13:17:23.907]     if (TRUE) {
[13:17:23.907]         base::sink(type = "output", split = FALSE)
[13:17:23.907]         if (TRUE) {
[13:17:23.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:23.907]         }
[13:17:23.907]         else {
[13:17:23.907]             ...future.result["stdout"] <- base::list(NULL)
[13:17:23.907]         }
[13:17:23.907]         base::close(...future.stdout)
[13:17:23.907]         ...future.stdout <- NULL
[13:17:23.907]     }
[13:17:23.907]     ...future.result$conditions <- ...future.conditions
[13:17:23.907]     ...future.result$finished <- base::Sys.time()
[13:17:23.907]     ...future.result
[13:17:23.907] }
[13:17:23.909] assign_globals() ...
[13:17:23.909] List of 5
[13:17:23.909]  $ future.call.arguments    : list()
[13:17:23.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.909]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:23.909]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:23.909]  $ ...future.elements_ii    :List of 2
[13:17:23.909]   ..$ : num [1:4] 1 3 1 7
[13:17:23.909]   ..$ : num [1:4] 2 4 6 8
[13:17:23.909]  $ ...future.seeds_ii       : NULL
[13:17:23.909]  $ ...future.globals.maxSize: num Inf
[13:17:23.909]  - attr(*, "resolved")= logi FALSE
[13:17:23.909]  - attr(*, "total_size")= num NA
[13:17:23.909]  - attr(*, "where")=List of 5
[13:17:23.909]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:23.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:23.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:23.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:23.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:23.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.909]  - attr(*, "already-done")= logi TRUE
[13:17:23.914] - copied ‘future.call.arguments’ to environment
[13:17:23.914] - copied ‘...future.FUN’ to environment
[13:17:23.914] - copied ‘...future.elements_ii’ to environment
[13:17:23.914] - copied ‘...future.seeds_ii’ to environment
[13:17:23.914] - copied ‘...future.globals.maxSize’ to environment
[13:17:23.914] assign_globals() ... done
[13:17:23.914] plan(): Setting new future strategy stack:
[13:17:23.914] List of future strategies:
[13:17:23.914] 1. sequential:
[13:17:23.914]    - args: function (..., envir = parent.frame())
[13:17:23.914]    - tweaked: FALSE
[13:17:23.914]    - call: NULL
[13:17:23.915] plan(): nbrOfWorkers() = 1
[13:17:23.916] plan(): Setting new future strategy stack:
[13:17:23.916] List of future strategies:
[13:17:23.916] 1. sequential:
[13:17:23.916]    - args: function (..., envir = parent.frame())
[13:17:23.916]    - tweaked: FALSE
[13:17:23.916]    - call: plan(strategy)
[13:17:23.916] plan(): nbrOfWorkers() = 1
[13:17:23.916] SequentialFuture started (and completed)
[13:17:23.916] - Launch lazy future ... done
[13:17:23.916] run() for ‘SequentialFuture’ ... done
[13:17:23.917] Created future:
[13:17:23.917] SequentialFuture:
[13:17:23.917] Label: ‘future_apply-1’
[13:17:23.917] Expression:
[13:17:23.917] {
[13:17:23.917]     do.call(function(...) {
[13:17:23.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.917]             on.exit(options(oopts), add = TRUE)
[13:17:23.917]         }
[13:17:23.917]         {
[13:17:23.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.917]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.917]             })
[13:17:23.917]         }
[13:17:23.917]     }, args = future.call.arguments)
[13:17:23.917] }
[13:17:23.917] Lazy evaluation: FALSE
[13:17:23.917] Asynchronous evaluation: FALSE
[13:17:23.917] Local evaluation: TRUE
[13:17:23.917] Environment: R_GlobalEnv
[13:17:23.917] Capture standard output: TRUE
[13:17:23.917] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:23.917] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:23.917] Packages: <none>
[13:17:23.917] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:23.917] Resolved: TRUE
[13:17:23.917] Value: 2.21 KiB of class ‘list’
[13:17:23.917] Early signaling: FALSE
[13:17:23.917] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:23.917] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.918] Chunk #1 of 1 ... DONE
[13:17:23.918] Launching 1 futures (chunks) ... DONE
[13:17:23.918] Resolving 1 futures (chunks) ...
[13:17:23.918] resolve() on list ...
[13:17:23.918]  recursive: 0
[13:17:23.918]  length: 1
[13:17:23.918] 
[13:17:23.918] resolved() for ‘SequentialFuture’ ...
[13:17:23.918] - state: ‘finished’
[13:17:23.919] - run: TRUE
[13:17:23.919] - result: ‘FutureResult’
[13:17:23.919] resolved() for ‘SequentialFuture’ ... done
[13:17:23.919] Future #1
[13:17:23.919] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:23.919] - nx: 1
[13:17:23.919] - relay: TRUE
[13:17:23.919] - stdout: TRUE
[13:17:23.919] - signal: TRUE
[13:17:23.919] - resignal: FALSE
[13:17:23.919] - force: TRUE
[13:17:23.920] - relayed: [n=1] FALSE
[13:17:23.920] - queued futures: [n=1] FALSE
[13:17:23.920]  - until=1
[13:17:23.920]  - relaying element #1
[13:17:23.920] - relayed: [n=1] TRUE
[13:17:23.920] - queued futures: [n=1] TRUE
[13:17:23.920] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:23.920]  length: 0 (resolved future 1)
[13:17:23.920] Relaying remaining futures
[13:17:23.920] signalConditionsASAP(NULL, pos=0) ...
[13:17:23.921] - nx: 1
[13:17:23.921] - relay: TRUE
[13:17:23.921] - stdout: TRUE
[13:17:23.921] - signal: TRUE
[13:17:23.921] - resignal: FALSE
[13:17:23.921] - force: TRUE
[13:17:23.921] - relayed: [n=1] TRUE
[13:17:23.921] - queued futures: [n=1] TRUE
 - flush all
[13:17:23.921] - relayed: [n=1] TRUE
[13:17:23.921] - queued futures: [n=1] TRUE
[13:17:23.921] signalConditionsASAP(NULL, pos=0) ... done
[13:17:23.922] resolve() on list ... DONE
[13:17:23.922]  - Number of value chunks collected: 1
[13:17:23.922] Resolving 1 futures (chunks) ... DONE
[13:17:23.922] Reducing values from 1 chunks ...
[13:17:23.922]  - Number of values collected after concatenation: 2
[13:17:23.922]  - Number of values expected: 2
[13:17:23.922] Reducing values from 1 chunks ... DONE
[13:17:23.922] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:17:23.924] getGlobalsAndPackagesXApply() ...
[13:17:23.925]  - future.globals: TRUE
[13:17:23.925] getGlobalsAndPackages() ...
[13:17:23.925] Searching for globals...
[13:17:23.926] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:23.926] Searching for globals ... DONE
[13:17:23.926] Resolving globals: FALSE
[13:17:23.926] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:23.927] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:23.927] - globals: [1] ‘FUN’
[13:17:23.927] - packages: [1] ‘stats’
[13:17:23.927] getGlobalsAndPackages() ... DONE
[13:17:23.927]  - globals found/used: [n=1] ‘FUN’
[13:17:23.927]  - needed namespaces: [n=1] ‘stats’
[13:17:23.927] Finding globals ... DONE
[13:17:23.928]  - use_args: TRUE
[13:17:23.928]  - Getting '...' globals ...
[13:17:23.928] resolve() on list ...
[13:17:23.928]  recursive: 0
[13:17:23.928]  length: 1
[13:17:23.928]  elements: ‘...’
[13:17:23.928]  length: 0 (resolved future 1)
[13:17:23.928] resolve() on list ... DONE
[13:17:23.929]    - '...' content: [n=0] 
[13:17:23.929] List of 1
[13:17:23.929]  $ ...: list()
[13:17:23.929]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.929]  - attr(*, "where")=List of 1
[13:17:23.929]   ..$ ...:<environment: 0x5647bb0279d0> 
[13:17:23.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.929]  - attr(*, "resolved")= logi TRUE
[13:17:23.929]  - attr(*, "total_size")= num NA
[13:17:23.933]  - Getting '...' globals ... DONE
[13:17:23.933] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:23.933] List of 2
[13:17:23.933]  $ ...future.FUN:function (x, ...)  
[13:17:23.933]  $ ...          : list()
[13:17:23.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.933]  - attr(*, "where")=List of 2
[13:17:23.933]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:23.933]   ..$ ...          :<environment: 0x5647bb0279d0> 
[13:17:23.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.933]  - attr(*, "resolved")= logi FALSE
[13:17:23.933]  - attr(*, "total_size")= num 1248
[13:17:23.936] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:23.936] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.936] future_lapply() ...
[13:17:23.936] Number of chunks: 1
[13:17:23.936] getGlobalsAndPackagesXApply() ...
[13:17:23.937]  - future.globals: <name-value list> with names ‘list()’
[13:17:23.937]  - use_args: TRUE
[13:17:23.937] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:23.937] List of 2
[13:17:23.937]  $ ...          : list()
[13:17:23.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.937]  $ ...future.FUN:function (x, ...)  
[13:17:23.937]  - attr(*, "where")=List of 2
[13:17:23.937]   ..$ ...          :<environment: 0x5647bb0279d0> 
[13:17:23.937]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:17:23.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.937]  - attr(*, "resolved")= logi FALSE
[13:17:23.937]  - attr(*, "total_size")= num NA
[13:17:23.940] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:23.940] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.940] Number of futures (= number of chunks): 1
[13:17:23.940] Launching 1 futures (chunks) ...
[13:17:23.940] Chunk #1 of 1 ...
[13:17:23.940]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:23.940]  - seeds: <none>
[13:17:23.941] getGlobalsAndPackages() ...
[13:17:23.941] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.941] Resolving globals: FALSE
[13:17:23.941] Tweak future expression to call with '...' arguments ...
[13:17:23.941] {
[13:17:23.941]     do.call(function(...) {
[13:17:23.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.941]             on.exit(options(oopts), add = TRUE)
[13:17:23.941]         }
[13:17:23.941]         {
[13:17:23.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.941]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.941]             })
[13:17:23.941]         }
[13:17:23.941]     }, args = future.call.arguments)
[13:17:23.941] }
[13:17:23.941] Tweak future expression to call with '...' arguments ... DONE
[13:17:23.942] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.942] - packages: [1] ‘stats’
[13:17:23.942] getGlobalsAndPackages() ... DONE
[13:17:23.942] run() for ‘Future’ ...
[13:17:23.942] - state: ‘created’
[13:17:23.942] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:23.943] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:23.943]   - Field: ‘label’
[13:17:23.943]   - Field: ‘local’
[13:17:23.943]   - Field: ‘owner’
[13:17:23.943]   - Field: ‘envir’
[13:17:23.943]   - Field: ‘packages’
[13:17:23.943]   - Field: ‘gc’
[13:17:23.943]   - Field: ‘conditions’
[13:17:23.944]   - Field: ‘expr’
[13:17:23.944]   - Field: ‘uuid’
[13:17:23.944]   - Field: ‘seed’
[13:17:23.944]   - Field: ‘version’
[13:17:23.944]   - Field: ‘result’
[13:17:23.944]   - Field: ‘asynchronous’
[13:17:23.944]   - Field: ‘calls’
[13:17:23.944]   - Field: ‘globals’
[13:17:23.944]   - Field: ‘stdout’
[13:17:23.944]   - Field: ‘earlySignal’
[13:17:23.944]   - Field: ‘lazy’
[13:17:23.945]   - Field: ‘state’
[13:17:23.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:23.945] - Launch lazy future ...
[13:17:23.945] Packages needed by the future expression (n = 1): ‘stats’
[13:17:23.945] Packages needed by future strategies (n = 0): <none>
[13:17:23.946] {
[13:17:23.946]     {
[13:17:23.946]         {
[13:17:23.946]             ...future.startTime <- base::Sys.time()
[13:17:23.946]             {
[13:17:23.946]                 {
[13:17:23.946]                   {
[13:17:23.946]                     {
[13:17:23.946]                       base::local({
[13:17:23.946]                         has_future <- base::requireNamespace("future", 
[13:17:23.946]                           quietly = TRUE)
[13:17:23.946]                         if (has_future) {
[13:17:23.946]                           ns <- base::getNamespace("future")
[13:17:23.946]                           version <- ns[[".package"]][["version"]]
[13:17:23.946]                           if (is.null(version)) 
[13:17:23.946]                             version <- utils::packageVersion("future")
[13:17:23.946]                         }
[13:17:23.946]                         else {
[13:17:23.946]                           version <- NULL
[13:17:23.946]                         }
[13:17:23.946]                         if (!has_future || version < "1.8.0") {
[13:17:23.946]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:23.946]                             "", base::R.version$version.string), 
[13:17:23.946]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:23.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:23.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:23.946]                               "release", "version")], collapse = " "), 
[13:17:23.946]                             hostname = base::Sys.info()[["nodename"]])
[13:17:23.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:23.946]                             info)
[13:17:23.946]                           info <- base::paste(info, collapse = "; ")
[13:17:23.946]                           if (!has_future) {
[13:17:23.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:23.946]                               info)
[13:17:23.946]                           }
[13:17:23.946]                           else {
[13:17:23.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:23.946]                               info, version)
[13:17:23.946]                           }
[13:17:23.946]                           base::stop(msg)
[13:17:23.946]                         }
[13:17:23.946]                       })
[13:17:23.946]                     }
[13:17:23.946]                     base::local({
[13:17:23.946]                       for (pkg in "stats") {
[13:17:23.946]                         base::loadNamespace(pkg)
[13:17:23.946]                         base::library(pkg, character.only = TRUE)
[13:17:23.946]                       }
[13:17:23.946]                     })
[13:17:23.946]                   }
[13:17:23.946]                   options(future.plan = NULL)
[13:17:23.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:23.946]                 }
[13:17:23.946]                 ...future.workdir <- getwd()
[13:17:23.946]             }
[13:17:23.946]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:23.946]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:23.946]         }
[13:17:23.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:23.946]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:23.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:23.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:23.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:23.946]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:23.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:23.946]             base::names(...future.oldOptions))
[13:17:23.946]     }
[13:17:23.946]     if (FALSE) {
[13:17:23.946]     }
[13:17:23.946]     else {
[13:17:23.946]         if (TRUE) {
[13:17:23.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:23.946]                 open = "w")
[13:17:23.946]         }
[13:17:23.946]         else {
[13:17:23.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:23.946]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:23.946]         }
[13:17:23.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:23.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:23.946]             base::sink(type = "output", split = FALSE)
[13:17:23.946]             base::close(...future.stdout)
[13:17:23.946]         }, add = TRUE)
[13:17:23.946]     }
[13:17:23.946]     ...future.frame <- base::sys.nframe()
[13:17:23.946]     ...future.conditions <- base::list()
[13:17:23.946]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:23.946]     if (FALSE) {
[13:17:23.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:23.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:23.946]     }
[13:17:23.946]     ...future.result <- base::tryCatch({
[13:17:23.946]         base::withCallingHandlers({
[13:17:23.946]             ...future.value <- base::withVisible(base::local({
[13:17:23.946]                 do.call(function(...) {
[13:17:23.946]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.946]                   if (!identical(...future.globals.maxSize.org, 
[13:17:23.946]                     ...future.globals.maxSize)) {
[13:17:23.946]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.946]                     on.exit(options(oopts), add = TRUE)
[13:17:23.946]                   }
[13:17:23.946]                   {
[13:17:23.946]                     lapply(seq_along(...future.elements_ii), 
[13:17:23.946]                       FUN = function(jj) {
[13:17:23.946]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.946]                         ...future.FUN(...future.X_jj, ...)
[13:17:23.946]                       })
[13:17:23.946]                   }
[13:17:23.946]                 }, args = future.call.arguments)
[13:17:23.946]             }))
[13:17:23.946]             future::FutureResult(value = ...future.value$value, 
[13:17:23.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.946]                   ...future.rng), globalenv = if (FALSE) 
[13:17:23.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:23.946]                     ...future.globalenv.names))
[13:17:23.946]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:23.946]         }, condition = base::local({
[13:17:23.946]             c <- base::c
[13:17:23.946]             inherits <- base::inherits
[13:17:23.946]             invokeRestart <- base::invokeRestart
[13:17:23.946]             length <- base::length
[13:17:23.946]             list <- base::list
[13:17:23.946]             seq.int <- base::seq.int
[13:17:23.946]             signalCondition <- base::signalCondition
[13:17:23.946]             sys.calls <- base::sys.calls
[13:17:23.946]             `[[` <- base::`[[`
[13:17:23.946]             `+` <- base::`+`
[13:17:23.946]             `<<-` <- base::`<<-`
[13:17:23.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:23.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:23.946]                   3L)]
[13:17:23.946]             }
[13:17:23.946]             function(cond) {
[13:17:23.946]                 is_error <- inherits(cond, "error")
[13:17:23.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:23.946]                   NULL)
[13:17:23.946]                 if (is_error) {
[13:17:23.946]                   sessionInformation <- function() {
[13:17:23.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:23.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:23.946]                       search = base::search(), system = base::Sys.info())
[13:17:23.946]                   }
[13:17:23.946]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:23.946]                     cond$call), session = sessionInformation(), 
[13:17:23.946]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:23.946]                   signalCondition(cond)
[13:17:23.946]                 }
[13:17:23.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:23.946]                 "immediateCondition"))) {
[13:17:23.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:23.946]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:23.946]                   if (TRUE && !signal) {
[13:17:23.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.946]                     {
[13:17:23.946]                       inherits <- base::inherits
[13:17:23.946]                       invokeRestart <- base::invokeRestart
[13:17:23.946]                       is.null <- base::is.null
[13:17:23.946]                       muffled <- FALSE
[13:17:23.946]                       if (inherits(cond, "message")) {
[13:17:23.946]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.946]                         if (muffled) 
[13:17:23.946]                           invokeRestart("muffleMessage")
[13:17:23.946]                       }
[13:17:23.946]                       else if (inherits(cond, "warning")) {
[13:17:23.946]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.946]                         if (muffled) 
[13:17:23.946]                           invokeRestart("muffleWarning")
[13:17:23.946]                       }
[13:17:23.946]                       else if (inherits(cond, "condition")) {
[13:17:23.946]                         if (!is.null(pattern)) {
[13:17:23.946]                           computeRestarts <- base::computeRestarts
[13:17:23.946]                           grepl <- base::grepl
[13:17:23.946]                           restarts <- computeRestarts(cond)
[13:17:23.946]                           for (restart in restarts) {
[13:17:23.946]                             name <- restart$name
[13:17:23.946]                             if (is.null(name)) 
[13:17:23.946]                               next
[13:17:23.946]                             if (!grepl(pattern, name)) 
[13:17:23.946]                               next
[13:17:23.946]                             invokeRestart(restart)
[13:17:23.946]                             muffled <- TRUE
[13:17:23.946]                             break
[13:17:23.946]                           }
[13:17:23.946]                         }
[13:17:23.946]                       }
[13:17:23.946]                       invisible(muffled)
[13:17:23.946]                     }
[13:17:23.946]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.946]                   }
[13:17:23.946]                 }
[13:17:23.946]                 else {
[13:17:23.946]                   if (TRUE) {
[13:17:23.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.946]                     {
[13:17:23.946]                       inherits <- base::inherits
[13:17:23.946]                       invokeRestart <- base::invokeRestart
[13:17:23.946]                       is.null <- base::is.null
[13:17:23.946]                       muffled <- FALSE
[13:17:23.946]                       if (inherits(cond, "message")) {
[13:17:23.946]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.946]                         if (muffled) 
[13:17:23.946]                           invokeRestart("muffleMessage")
[13:17:23.946]                       }
[13:17:23.946]                       else if (inherits(cond, "warning")) {
[13:17:23.946]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.946]                         if (muffled) 
[13:17:23.946]                           invokeRestart("muffleWarning")
[13:17:23.946]                       }
[13:17:23.946]                       else if (inherits(cond, "condition")) {
[13:17:23.946]                         if (!is.null(pattern)) {
[13:17:23.946]                           computeRestarts <- base::computeRestarts
[13:17:23.946]                           grepl <- base::grepl
[13:17:23.946]                           restarts <- computeRestarts(cond)
[13:17:23.946]                           for (restart in restarts) {
[13:17:23.946]                             name <- restart$name
[13:17:23.946]                             if (is.null(name)) 
[13:17:23.946]                               next
[13:17:23.946]                             if (!grepl(pattern, name)) 
[13:17:23.946]                               next
[13:17:23.946]                             invokeRestart(restart)
[13:17:23.946]                             muffled <- TRUE
[13:17:23.946]                             break
[13:17:23.946]                           }
[13:17:23.946]                         }
[13:17:23.946]                       }
[13:17:23.946]                       invisible(muffled)
[13:17:23.946]                     }
[13:17:23.946]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.946]                   }
[13:17:23.946]                 }
[13:17:23.946]             }
[13:17:23.946]         }))
[13:17:23.946]     }, error = function(ex) {
[13:17:23.946]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:23.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.946]                 ...future.rng), started = ...future.startTime, 
[13:17:23.946]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:23.946]             version = "1.8"), class = "FutureResult")
[13:17:23.946]     }, finally = {
[13:17:23.946]         if (!identical(...future.workdir, getwd())) 
[13:17:23.946]             setwd(...future.workdir)
[13:17:23.946]         {
[13:17:23.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:23.946]                 ...future.oldOptions$nwarnings <- NULL
[13:17:23.946]             }
[13:17:23.946]             base::options(...future.oldOptions)
[13:17:23.946]             if (.Platform$OS.type == "windows") {
[13:17:23.946]                 old_names <- names(...future.oldEnvVars)
[13:17:23.946]                 envs <- base::Sys.getenv()
[13:17:23.946]                 names <- names(envs)
[13:17:23.946]                 common <- intersect(names, old_names)
[13:17:23.946]                 added <- setdiff(names, old_names)
[13:17:23.946]                 removed <- setdiff(old_names, names)
[13:17:23.946]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:23.946]                   envs[common]]
[13:17:23.946]                 NAMES <- toupper(changed)
[13:17:23.946]                 args <- list()
[13:17:23.946]                 for (kk in seq_along(NAMES)) {
[13:17:23.946]                   name <- changed[[kk]]
[13:17:23.946]                   NAME <- NAMES[[kk]]
[13:17:23.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.946]                     next
[13:17:23.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.946]                 }
[13:17:23.946]                 NAMES <- toupper(added)
[13:17:23.946]                 for (kk in seq_along(NAMES)) {
[13:17:23.946]                   name <- added[[kk]]
[13:17:23.946]                   NAME <- NAMES[[kk]]
[13:17:23.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.946]                     next
[13:17:23.946]                   args[[name]] <- ""
[13:17:23.946]                 }
[13:17:23.946]                 NAMES <- toupper(removed)
[13:17:23.946]                 for (kk in seq_along(NAMES)) {
[13:17:23.946]                   name <- removed[[kk]]
[13:17:23.946]                   NAME <- NAMES[[kk]]
[13:17:23.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.946]                     next
[13:17:23.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.946]                 }
[13:17:23.946]                 if (length(args) > 0) 
[13:17:23.946]                   base::do.call(base::Sys.setenv, args = args)
[13:17:23.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:23.946]             }
[13:17:23.946]             else {
[13:17:23.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:23.946]             }
[13:17:23.946]             {
[13:17:23.946]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:23.946]                   0L) {
[13:17:23.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:23.946]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:23.946]                   base::options(opts)
[13:17:23.946]                 }
[13:17:23.946]                 {
[13:17:23.946]                   {
[13:17:23.946]                     NULL
[13:17:23.946]                     RNGkind("Mersenne-Twister")
[13:17:23.946]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:23.946]                       inherits = FALSE)
[13:17:23.946]                   }
[13:17:23.946]                   options(future.plan = NULL)
[13:17:23.946]                   if (is.na(NA_character_)) 
[13:17:23.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:23.946]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:23.946]                   {
[13:17:23.946]                     future <- SequentialFuture(..., envir = envir)
[13:17:23.946]                     if (!future$lazy) 
[13:17:23.946]                       future <- run(future)
[13:17:23.946]                     invisible(future)
[13:17:23.946]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:23.946]                 }
[13:17:23.946]             }
[13:17:23.946]         }
[13:17:23.946]     })
[13:17:23.946]     if (TRUE) {
[13:17:23.946]         base::sink(type = "output", split = FALSE)
[13:17:23.946]         if (TRUE) {
[13:17:23.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:23.946]         }
[13:17:23.946]         else {
[13:17:23.946]             ...future.result["stdout"] <- base::list(NULL)
[13:17:23.946]         }
[13:17:23.946]         base::close(...future.stdout)
[13:17:23.946]         ...future.stdout <- NULL
[13:17:23.946]     }
[13:17:23.946]     ...future.result$conditions <- ...future.conditions
[13:17:23.946]     ...future.result$finished <- base::Sys.time()
[13:17:23.946]     ...future.result
[13:17:23.946] }
[13:17:23.947] assign_globals() ...
[13:17:23.947] List of 5
[13:17:23.947]  $ future.call.arguments    : list()
[13:17:23.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.947]  $ ...future.FUN            :function (x, ...)  
[13:17:23.947]  $ ...future.elements_ii    :List of 2
[13:17:23.947]   ..$ : num [1:4] 1 3 1 7
[13:17:23.947]   ..$ : num [1:4] 2 4 6 8
[13:17:23.947]  $ ...future.seeds_ii       : NULL
[13:17:23.947]  $ ...future.globals.maxSize: num Inf
[13:17:23.947]  - attr(*, "resolved")= logi FALSE
[13:17:23.947]  - attr(*, "total_size")= num NA
[13:17:23.947]  - attr(*, "where")=List of 5
[13:17:23.947]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:23.947]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:23.947]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:23.947]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:23.947]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:23.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.947]  - attr(*, "already-done")= logi TRUE
[13:17:23.954] - copied ‘future.call.arguments’ to environment
[13:17:23.954] - copied ‘...future.FUN’ to environment
[13:17:23.954] - copied ‘...future.elements_ii’ to environment
[13:17:23.954] - copied ‘...future.seeds_ii’ to environment
[13:17:23.954] - copied ‘...future.globals.maxSize’ to environment
[13:17:23.954] assign_globals() ... done
[13:17:23.955] plan(): Setting new future strategy stack:
[13:17:23.955] List of future strategies:
[13:17:23.955] 1. sequential:
[13:17:23.955]    - args: function (..., envir = parent.frame())
[13:17:23.955]    - tweaked: FALSE
[13:17:23.955]    - call: NULL
[13:17:23.955] plan(): nbrOfWorkers() = 1
[13:17:23.956] plan(): Setting new future strategy stack:
[13:17:23.956] List of future strategies:
[13:17:23.956] 1. sequential:
[13:17:23.956]    - args: function (..., envir = parent.frame())
[13:17:23.956]    - tweaked: FALSE
[13:17:23.956]    - call: plan(strategy)
[13:17:23.956] plan(): nbrOfWorkers() = 1
[13:17:23.957] SequentialFuture started (and completed)
[13:17:23.957] - Launch lazy future ... done
[13:17:23.957] run() for ‘SequentialFuture’ ... done
[13:17:23.957] Created future:
[13:17:23.957] SequentialFuture:
[13:17:23.957] Label: ‘future_apply-1’
[13:17:23.957] Expression:
[13:17:23.957] {
[13:17:23.957]     do.call(function(...) {
[13:17:23.957]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.957]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.957]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.957]             on.exit(options(oopts), add = TRUE)
[13:17:23.957]         }
[13:17:23.957]         {
[13:17:23.957]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.957]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.957]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.957]             })
[13:17:23.957]         }
[13:17:23.957]     }, args = future.call.arguments)
[13:17:23.957] }
[13:17:23.957] Lazy evaluation: FALSE
[13:17:23.957] Asynchronous evaluation: FALSE
[13:17:23.957] Local evaluation: TRUE
[13:17:23.957] Environment: R_GlobalEnv
[13:17:23.957] Capture standard output: TRUE
[13:17:23.957] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:23.957] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:23.957] Packages: 1 packages (‘stats’)
[13:17:23.957] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:23.957] Resolved: TRUE
[13:17:23.957] Value: 1.14 KiB of class ‘list’
[13:17:23.957] Early signaling: FALSE
[13:17:23.957] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:23.957] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.958] Chunk #1 of 1 ... DONE
[13:17:23.958] Launching 1 futures (chunks) ... DONE
[13:17:23.958] Resolving 1 futures (chunks) ...
[13:17:23.958] resolve() on list ...
[13:17:23.958]  recursive: 0
[13:17:23.959]  length: 1
[13:17:23.959] 
[13:17:23.959] resolved() for ‘SequentialFuture’ ...
[13:17:23.959] - state: ‘finished’
[13:17:23.959] - run: TRUE
[13:17:23.959] - result: ‘FutureResult’
[13:17:23.959] resolved() for ‘SequentialFuture’ ... done
[13:17:23.959] Future #1
[13:17:23.959] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:23.959] - nx: 1
[13:17:23.960] - relay: TRUE
[13:17:23.960] - stdout: TRUE
[13:17:23.960] - signal: TRUE
[13:17:23.960] - resignal: FALSE
[13:17:23.960] - force: TRUE
[13:17:23.960] - relayed: [n=1] FALSE
[13:17:23.960] - queued futures: [n=1] FALSE
[13:17:23.960]  - until=1
[13:17:23.960]  - relaying element #1
[13:17:23.960] - relayed: [n=1] TRUE
[13:17:23.961] - queued futures: [n=1] TRUE
[13:17:23.961] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:23.961]  length: 0 (resolved future 1)
[13:17:23.961] Relaying remaining futures
[13:17:23.961] signalConditionsASAP(NULL, pos=0) ...
[13:17:23.961] - nx: 1
[13:17:23.961] - relay: TRUE
[13:17:23.961] - stdout: TRUE
[13:17:23.961] - signal: TRUE
[13:17:23.961] - resignal: FALSE
[13:17:23.961] - force: TRUE
[13:17:23.961] - relayed: [n=1] TRUE
[13:17:23.962] - queued futures: [n=1] TRUE
 - flush all
[13:17:23.962] - relayed: [n=1] TRUE
[13:17:23.962] - queued futures: [n=1] TRUE
[13:17:23.962] signalConditionsASAP(NULL, pos=0) ... done
[13:17:23.962] resolve() on list ... DONE
[13:17:23.962]  - Number of value chunks collected: 1
[13:17:23.962] Resolving 1 futures (chunks) ... DONE
[13:17:23.962] Reducing values from 1 chunks ...
[13:17:23.962]  - Number of values collected after concatenation: 2
[13:17:23.962]  - Number of values expected: 2
[13:17:23.963] Reducing values from 1 chunks ... DONE
[13:17:23.963] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:17:23.963] getGlobalsAndPackagesXApply() ...
[13:17:23.964]  - future.globals: TRUE
[13:17:23.964] getGlobalsAndPackages() ...
[13:17:23.964] Searching for globals...
[13:17:23.965] - globals found: [1] ‘FUN’
[13:17:23.965] Searching for globals ... DONE
[13:17:23.965] Resolving globals: FALSE
[13:17:23.965] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:23.966] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:23.966] - globals: [1] ‘FUN’
[13:17:23.966] 
[13:17:23.966] getGlobalsAndPackages() ... DONE
[13:17:23.966]  - globals found/used: [n=1] ‘FUN’
[13:17:23.966]  - needed namespaces: [n=0] 
[13:17:23.966] Finding globals ... DONE
[13:17:23.966]  - use_args: TRUE
[13:17:23.967]  - Getting '...' globals ...
[13:17:23.967] resolve() on list ...
[13:17:23.967]  recursive: 0
[13:17:23.967]  length: 1
[13:17:23.967]  elements: ‘...’
[13:17:23.967]  length: 0 (resolved future 1)
[13:17:23.967] resolve() on list ... DONE
[13:17:23.967]    - '...' content: [n=0] 
[13:17:23.967] List of 1
[13:17:23.967]  $ ...: list()
[13:17:23.967]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.967]  - attr(*, "where")=List of 1
[13:17:23.967]   ..$ ...:<environment: 0x5647ba7ebdb8> 
[13:17:23.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.967]  - attr(*, "resolved")= logi TRUE
[13:17:23.967]  - attr(*, "total_size")= num NA
[13:17:23.970]  - Getting '...' globals ... DONE
[13:17:23.970] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:23.970] List of 2
[13:17:23.970]  $ ...future.FUN:function (x)  
[13:17:23.970]  $ ...          : list()
[13:17:23.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.970]  - attr(*, "where")=List of 2
[13:17:23.970]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:23.970]   ..$ ...          :<environment: 0x5647ba7ebdb8> 
[13:17:23.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.970]  - attr(*, "resolved")= logi FALSE
[13:17:23.970]  - attr(*, "total_size")= num 848
[13:17:23.973] Packages to be attached in all futures: [n=0] 
[13:17:23.973] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.973] future_lapply() ...
[13:17:23.974] Number of chunks: 1
[13:17:23.974] getGlobalsAndPackagesXApply() ...
[13:17:23.974]  - future.globals: <name-value list> with names ‘list()’
[13:17:23.974]  - use_args: TRUE
[13:17:23.974] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:23.974] List of 2
[13:17:23.974]  $ ...          : list()
[13:17:23.974]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.974]  $ ...future.FUN:function (x)  
[13:17:23.974]  - attr(*, "where")=List of 2
[13:17:23.974]   ..$ ...          :<environment: 0x5647ba7ebdb8> 
[13:17:23.974]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:23.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.974]  - attr(*, "resolved")= logi FALSE
[13:17:23.974]  - attr(*, "total_size")= num NA
[13:17:23.979] Packages to be attached in all futures: [n=0] 
[13:17:23.979] getGlobalsAndPackagesXApply() ... DONE
[13:17:23.979] Number of futures (= number of chunks): 1
[13:17:23.979] Launching 1 futures (chunks) ...
[13:17:23.979] Chunk #1 of 1 ...
[13:17:23.979]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:23.980]  - seeds: <none>
[13:17:23.980] getGlobalsAndPackages() ...
[13:17:23.980] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.980] Resolving globals: FALSE
[13:17:23.980] Tweak future expression to call with '...' arguments ...
[13:17:23.980] {
[13:17:23.980]     do.call(function(...) {
[13:17:23.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.980]             on.exit(options(oopts), add = TRUE)
[13:17:23.980]         }
[13:17:23.980]         {
[13:17:23.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.980]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.980]             })
[13:17:23.980]         }
[13:17:23.980]     }, args = future.call.arguments)
[13:17:23.980] }
[13:17:23.980] Tweak future expression to call with '...' arguments ... DONE
[13:17:23.981] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:23.981] 
[13:17:23.981] getGlobalsAndPackages() ... DONE
[13:17:23.981] run() for ‘Future’ ...
[13:17:23.981] - state: ‘created’
[13:17:23.981] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:23.982] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:23.982]   - Field: ‘label’
[13:17:23.982]   - Field: ‘local’
[13:17:23.982]   - Field: ‘owner’
[13:17:23.982]   - Field: ‘envir’
[13:17:23.982]   - Field: ‘packages’
[13:17:23.982]   - Field: ‘gc’
[13:17:23.983]   - Field: ‘conditions’
[13:17:23.983]   - Field: ‘expr’
[13:17:23.983]   - Field: ‘uuid’
[13:17:23.983]   - Field: ‘seed’
[13:17:23.983]   - Field: ‘version’
[13:17:23.983]   - Field: ‘result’
[13:17:23.983]   - Field: ‘asynchronous’
[13:17:23.983]   - Field: ‘calls’
[13:17:23.983]   - Field: ‘globals’
[13:17:23.983]   - Field: ‘stdout’
[13:17:23.984]   - Field: ‘earlySignal’
[13:17:23.984]   - Field: ‘lazy’
[13:17:23.984]   - Field: ‘state’
[13:17:23.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:23.984] - Launch lazy future ...
[13:17:23.984] Packages needed by the future expression (n = 0): <none>
[13:17:23.984] Packages needed by future strategies (n = 0): <none>
[13:17:23.985] {
[13:17:23.985]     {
[13:17:23.985]         {
[13:17:23.985]             ...future.startTime <- base::Sys.time()
[13:17:23.985]             {
[13:17:23.985]                 {
[13:17:23.985]                   {
[13:17:23.985]                     base::local({
[13:17:23.985]                       has_future <- base::requireNamespace("future", 
[13:17:23.985]                         quietly = TRUE)
[13:17:23.985]                       if (has_future) {
[13:17:23.985]                         ns <- base::getNamespace("future")
[13:17:23.985]                         version <- ns[[".package"]][["version"]]
[13:17:23.985]                         if (is.null(version)) 
[13:17:23.985]                           version <- utils::packageVersion("future")
[13:17:23.985]                       }
[13:17:23.985]                       else {
[13:17:23.985]                         version <- NULL
[13:17:23.985]                       }
[13:17:23.985]                       if (!has_future || version < "1.8.0") {
[13:17:23.985]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:23.985]                           "", base::R.version$version.string), 
[13:17:23.985]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:23.985]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:23.985]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:23.985]                             "release", "version")], collapse = " "), 
[13:17:23.985]                           hostname = base::Sys.info()[["nodename"]])
[13:17:23.985]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:23.985]                           info)
[13:17:23.985]                         info <- base::paste(info, collapse = "; ")
[13:17:23.985]                         if (!has_future) {
[13:17:23.985]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:23.985]                             info)
[13:17:23.985]                         }
[13:17:23.985]                         else {
[13:17:23.985]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:23.985]                             info, version)
[13:17:23.985]                         }
[13:17:23.985]                         base::stop(msg)
[13:17:23.985]                       }
[13:17:23.985]                     })
[13:17:23.985]                   }
[13:17:23.985]                   options(future.plan = NULL)
[13:17:23.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:23.985]                 }
[13:17:23.985]                 ...future.workdir <- getwd()
[13:17:23.985]             }
[13:17:23.985]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:23.985]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:23.985]         }
[13:17:23.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:23.985]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:23.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:23.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:23.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:23.985]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:23.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:23.985]             base::names(...future.oldOptions))
[13:17:23.985]     }
[13:17:23.985]     if (FALSE) {
[13:17:23.985]     }
[13:17:23.985]     else {
[13:17:23.985]         if (TRUE) {
[13:17:23.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:23.985]                 open = "w")
[13:17:23.985]         }
[13:17:23.985]         else {
[13:17:23.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:23.985]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:23.985]         }
[13:17:23.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:23.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:23.985]             base::sink(type = "output", split = FALSE)
[13:17:23.985]             base::close(...future.stdout)
[13:17:23.985]         }, add = TRUE)
[13:17:23.985]     }
[13:17:23.985]     ...future.frame <- base::sys.nframe()
[13:17:23.985]     ...future.conditions <- base::list()
[13:17:23.985]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:23.985]     if (FALSE) {
[13:17:23.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:23.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:23.985]     }
[13:17:23.985]     ...future.result <- base::tryCatch({
[13:17:23.985]         base::withCallingHandlers({
[13:17:23.985]             ...future.value <- base::withVisible(base::local({
[13:17:23.985]                 do.call(function(...) {
[13:17:23.985]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.985]                   if (!identical(...future.globals.maxSize.org, 
[13:17:23.985]                     ...future.globals.maxSize)) {
[13:17:23.985]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.985]                     on.exit(options(oopts), add = TRUE)
[13:17:23.985]                   }
[13:17:23.985]                   {
[13:17:23.985]                     lapply(seq_along(...future.elements_ii), 
[13:17:23.985]                       FUN = function(jj) {
[13:17:23.985]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.985]                         ...future.FUN(...future.X_jj, ...)
[13:17:23.985]                       })
[13:17:23.985]                   }
[13:17:23.985]                 }, args = future.call.arguments)
[13:17:23.985]             }))
[13:17:23.985]             future::FutureResult(value = ...future.value$value, 
[13:17:23.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.985]                   ...future.rng), globalenv = if (FALSE) 
[13:17:23.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:23.985]                     ...future.globalenv.names))
[13:17:23.985]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:23.985]         }, condition = base::local({
[13:17:23.985]             c <- base::c
[13:17:23.985]             inherits <- base::inherits
[13:17:23.985]             invokeRestart <- base::invokeRestart
[13:17:23.985]             length <- base::length
[13:17:23.985]             list <- base::list
[13:17:23.985]             seq.int <- base::seq.int
[13:17:23.985]             signalCondition <- base::signalCondition
[13:17:23.985]             sys.calls <- base::sys.calls
[13:17:23.985]             `[[` <- base::`[[`
[13:17:23.985]             `+` <- base::`+`
[13:17:23.985]             `<<-` <- base::`<<-`
[13:17:23.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:23.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:23.985]                   3L)]
[13:17:23.985]             }
[13:17:23.985]             function(cond) {
[13:17:23.985]                 is_error <- inherits(cond, "error")
[13:17:23.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:23.985]                   NULL)
[13:17:23.985]                 if (is_error) {
[13:17:23.985]                   sessionInformation <- function() {
[13:17:23.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:23.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:23.985]                       search = base::search(), system = base::Sys.info())
[13:17:23.985]                   }
[13:17:23.985]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:23.985]                     cond$call), session = sessionInformation(), 
[13:17:23.985]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:23.985]                   signalCondition(cond)
[13:17:23.985]                 }
[13:17:23.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:23.985]                 "immediateCondition"))) {
[13:17:23.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:23.985]                   ...future.conditions[[length(...future.conditions) + 
[13:17:23.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:23.985]                   if (TRUE && !signal) {
[13:17:23.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.985]                     {
[13:17:23.985]                       inherits <- base::inherits
[13:17:23.985]                       invokeRestart <- base::invokeRestart
[13:17:23.985]                       is.null <- base::is.null
[13:17:23.985]                       muffled <- FALSE
[13:17:23.985]                       if (inherits(cond, "message")) {
[13:17:23.985]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.985]                         if (muffled) 
[13:17:23.985]                           invokeRestart("muffleMessage")
[13:17:23.985]                       }
[13:17:23.985]                       else if (inherits(cond, "warning")) {
[13:17:23.985]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.985]                         if (muffled) 
[13:17:23.985]                           invokeRestart("muffleWarning")
[13:17:23.985]                       }
[13:17:23.985]                       else if (inherits(cond, "condition")) {
[13:17:23.985]                         if (!is.null(pattern)) {
[13:17:23.985]                           computeRestarts <- base::computeRestarts
[13:17:23.985]                           grepl <- base::grepl
[13:17:23.985]                           restarts <- computeRestarts(cond)
[13:17:23.985]                           for (restart in restarts) {
[13:17:23.985]                             name <- restart$name
[13:17:23.985]                             if (is.null(name)) 
[13:17:23.985]                               next
[13:17:23.985]                             if (!grepl(pattern, name)) 
[13:17:23.985]                               next
[13:17:23.985]                             invokeRestart(restart)
[13:17:23.985]                             muffled <- TRUE
[13:17:23.985]                             break
[13:17:23.985]                           }
[13:17:23.985]                         }
[13:17:23.985]                       }
[13:17:23.985]                       invisible(muffled)
[13:17:23.985]                     }
[13:17:23.985]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.985]                   }
[13:17:23.985]                 }
[13:17:23.985]                 else {
[13:17:23.985]                   if (TRUE) {
[13:17:23.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:23.985]                     {
[13:17:23.985]                       inherits <- base::inherits
[13:17:23.985]                       invokeRestart <- base::invokeRestart
[13:17:23.985]                       is.null <- base::is.null
[13:17:23.985]                       muffled <- FALSE
[13:17:23.985]                       if (inherits(cond, "message")) {
[13:17:23.985]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:23.985]                         if (muffled) 
[13:17:23.985]                           invokeRestart("muffleMessage")
[13:17:23.985]                       }
[13:17:23.985]                       else if (inherits(cond, "warning")) {
[13:17:23.985]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:23.985]                         if (muffled) 
[13:17:23.985]                           invokeRestart("muffleWarning")
[13:17:23.985]                       }
[13:17:23.985]                       else if (inherits(cond, "condition")) {
[13:17:23.985]                         if (!is.null(pattern)) {
[13:17:23.985]                           computeRestarts <- base::computeRestarts
[13:17:23.985]                           grepl <- base::grepl
[13:17:23.985]                           restarts <- computeRestarts(cond)
[13:17:23.985]                           for (restart in restarts) {
[13:17:23.985]                             name <- restart$name
[13:17:23.985]                             if (is.null(name)) 
[13:17:23.985]                               next
[13:17:23.985]                             if (!grepl(pattern, name)) 
[13:17:23.985]                               next
[13:17:23.985]                             invokeRestart(restart)
[13:17:23.985]                             muffled <- TRUE
[13:17:23.985]                             break
[13:17:23.985]                           }
[13:17:23.985]                         }
[13:17:23.985]                       }
[13:17:23.985]                       invisible(muffled)
[13:17:23.985]                     }
[13:17:23.985]                     muffleCondition(cond, pattern = "^muffle")
[13:17:23.985]                   }
[13:17:23.985]                 }
[13:17:23.985]             }
[13:17:23.985]         }))
[13:17:23.985]     }, error = function(ex) {
[13:17:23.985]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:23.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:23.985]                 ...future.rng), started = ...future.startTime, 
[13:17:23.985]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:23.985]             version = "1.8"), class = "FutureResult")
[13:17:23.985]     }, finally = {
[13:17:23.985]         if (!identical(...future.workdir, getwd())) 
[13:17:23.985]             setwd(...future.workdir)
[13:17:23.985]         {
[13:17:23.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:23.985]                 ...future.oldOptions$nwarnings <- NULL
[13:17:23.985]             }
[13:17:23.985]             base::options(...future.oldOptions)
[13:17:23.985]             if (.Platform$OS.type == "windows") {
[13:17:23.985]                 old_names <- names(...future.oldEnvVars)
[13:17:23.985]                 envs <- base::Sys.getenv()
[13:17:23.985]                 names <- names(envs)
[13:17:23.985]                 common <- intersect(names, old_names)
[13:17:23.985]                 added <- setdiff(names, old_names)
[13:17:23.985]                 removed <- setdiff(old_names, names)
[13:17:23.985]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:23.985]                   envs[common]]
[13:17:23.985]                 NAMES <- toupper(changed)
[13:17:23.985]                 args <- list()
[13:17:23.985]                 for (kk in seq_along(NAMES)) {
[13:17:23.985]                   name <- changed[[kk]]
[13:17:23.985]                   NAME <- NAMES[[kk]]
[13:17:23.985]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.985]                     next
[13:17:23.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.985]                 }
[13:17:23.985]                 NAMES <- toupper(added)
[13:17:23.985]                 for (kk in seq_along(NAMES)) {
[13:17:23.985]                   name <- added[[kk]]
[13:17:23.985]                   NAME <- NAMES[[kk]]
[13:17:23.985]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.985]                     next
[13:17:23.985]                   args[[name]] <- ""
[13:17:23.985]                 }
[13:17:23.985]                 NAMES <- toupper(removed)
[13:17:23.985]                 for (kk in seq_along(NAMES)) {
[13:17:23.985]                   name <- removed[[kk]]
[13:17:23.985]                   NAME <- NAMES[[kk]]
[13:17:23.985]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:23.985]                     next
[13:17:23.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:23.985]                 }
[13:17:23.985]                 if (length(args) > 0) 
[13:17:23.985]                   base::do.call(base::Sys.setenv, args = args)
[13:17:23.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:23.985]             }
[13:17:23.985]             else {
[13:17:23.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:23.985]             }
[13:17:23.985]             {
[13:17:23.985]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:23.985]                   0L) {
[13:17:23.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:23.985]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:23.985]                   base::options(opts)
[13:17:23.985]                 }
[13:17:23.985]                 {
[13:17:23.985]                   {
[13:17:23.985]                     NULL
[13:17:23.985]                     RNGkind("Mersenne-Twister")
[13:17:23.985]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:23.985]                       inherits = FALSE)
[13:17:23.985]                   }
[13:17:23.985]                   options(future.plan = NULL)
[13:17:23.985]                   if (is.na(NA_character_)) 
[13:17:23.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:23.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:23.985]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:23.985]                   {
[13:17:23.985]                     future <- SequentialFuture(..., envir = envir)
[13:17:23.985]                     if (!future$lazy) 
[13:17:23.985]                       future <- run(future)
[13:17:23.985]                     invisible(future)
[13:17:23.985]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:23.985]                 }
[13:17:23.985]             }
[13:17:23.985]         }
[13:17:23.985]     })
[13:17:23.985]     if (TRUE) {
[13:17:23.985]         base::sink(type = "output", split = FALSE)
[13:17:23.985]         if (TRUE) {
[13:17:23.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:23.985]         }
[13:17:23.985]         else {
[13:17:23.985]             ...future.result["stdout"] <- base::list(NULL)
[13:17:23.985]         }
[13:17:23.985]         base::close(...future.stdout)
[13:17:23.985]         ...future.stdout <- NULL
[13:17:23.985]     }
[13:17:23.985]     ...future.result$conditions <- ...future.conditions
[13:17:23.985]     ...future.result$finished <- base::Sys.time()
[13:17:23.985]     ...future.result
[13:17:23.985] }
[13:17:23.986] assign_globals() ...
[13:17:23.986] List of 5
[13:17:23.986]  $ future.call.arguments    : list()
[13:17:23.986]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:23.986]  $ ...future.FUN            :function (x)  
[13:17:23.986]  $ ...future.elements_ii    :List of 2
[13:17:23.986]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:23.986]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:23.986]  $ ...future.seeds_ii       : NULL
[13:17:23.986]  $ ...future.globals.maxSize: num Inf
[13:17:23.986]  - attr(*, "resolved")= logi FALSE
[13:17:23.986]  - attr(*, "total_size")= num NA
[13:17:23.986]  - attr(*, "where")=List of 5
[13:17:23.986]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:23.986]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:23.986]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:23.986]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:23.986]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:23.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:23.986]  - attr(*, "already-done")= logi TRUE
[13:17:23.991] - copied ‘future.call.arguments’ to environment
[13:17:23.991] - copied ‘...future.FUN’ to environment
[13:17:23.992] - copied ‘...future.elements_ii’ to environment
[13:17:23.992] - copied ‘...future.seeds_ii’ to environment
[13:17:23.992] - copied ‘...future.globals.maxSize’ to environment
[13:17:23.992] assign_globals() ... done
[13:17:23.992] plan(): Setting new future strategy stack:
[13:17:23.992] List of future strategies:
[13:17:23.992] 1. sequential:
[13:17:23.992]    - args: function (..., envir = parent.frame())
[13:17:23.992]    - tweaked: FALSE
[13:17:23.992]    - call: NULL
[13:17:23.993] plan(): nbrOfWorkers() = 1
[13:17:23.993] plan(): Setting new future strategy stack:
[13:17:23.993] List of future strategies:
[13:17:23.993] 1. sequential:
[13:17:23.993]    - args: function (..., envir = parent.frame())
[13:17:23.993]    - tweaked: FALSE
[13:17:23.993]    - call: plan(strategy)
[13:17:23.994] plan(): nbrOfWorkers() = 1
[13:17:23.994] SequentialFuture started (and completed)
[13:17:23.994] - Launch lazy future ... done
[13:17:23.994] run() for ‘SequentialFuture’ ... done
[13:17:23.994] Created future:
[13:17:23.994] SequentialFuture:
[13:17:23.994] Label: ‘future_apply-1’
[13:17:23.994] Expression:
[13:17:23.994] {
[13:17:23.994]     do.call(function(...) {
[13:17:23.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:23.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:23.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:23.994]             on.exit(options(oopts), add = TRUE)
[13:17:23.994]         }
[13:17:23.994]         {
[13:17:23.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:23.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:23.994]                 ...future.FUN(...future.X_jj, ...)
[13:17:23.994]             })
[13:17:23.994]         }
[13:17:23.994]     }, args = future.call.arguments)
[13:17:23.994] }
[13:17:23.994] Lazy evaluation: FALSE
[13:17:23.994] Asynchronous evaluation: FALSE
[13:17:23.994] Local evaluation: TRUE
[13:17:23.994] Environment: R_GlobalEnv
[13:17:23.994] Capture standard output: TRUE
[13:17:23.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:23.994] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:23.994] Packages: <none>
[13:17:23.994] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:23.994] Resolved: TRUE
[13:17:23.994] Value: 224 bytes of class ‘list’
[13:17:23.994] Early signaling: FALSE
[13:17:23.994] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:23.994] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:23.995] Chunk #1 of 1 ... DONE
[13:17:23.995] Launching 1 futures (chunks) ... DONE
[13:17:23.995] Resolving 1 futures (chunks) ...
[13:17:23.996] resolve() on list ...
[13:17:23.996]  recursive: 0
[13:17:23.996]  length: 1
[13:17:23.996] 
[13:17:23.996] resolved() for ‘SequentialFuture’ ...
[13:17:23.996] - state: ‘finished’
[13:17:23.996] - run: TRUE
[13:17:23.996] - result: ‘FutureResult’
[13:17:23.996] resolved() for ‘SequentialFuture’ ... done
[13:17:23.996] Future #1
[13:17:23.997] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:23.997] - nx: 1
[13:17:23.997] - relay: TRUE
[13:17:23.997] - stdout: TRUE
[13:17:23.997] - signal: TRUE
[13:17:23.997] - resignal: FALSE
[13:17:23.997] - force: TRUE
[13:17:23.997] - relayed: [n=1] FALSE
[13:17:23.997] - queued futures: [n=1] FALSE
[13:17:23.997]  - until=1
[13:17:23.997]  - relaying element #1
[13:17:23.998] - relayed: [n=1] TRUE
[13:17:23.998] - queued futures: [n=1] TRUE
[13:17:23.998] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:23.998]  length: 0 (resolved future 1)
[13:17:23.999] Relaying remaining futures
[13:17:23.999] signalConditionsASAP(NULL, pos=0) ...
[13:17:23.999] - nx: 1
[13:17:23.999] - relay: TRUE
[13:17:23.999] - stdout: TRUE
[13:17:24.000] - signal: TRUE
[13:17:24.000] - resignal: FALSE
[13:17:24.000] - force: TRUE
[13:17:24.000] - relayed: [n=1] TRUE
[13:17:24.000] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.000] - relayed: [n=1] TRUE
[13:17:24.000] - queued futures: [n=1] TRUE
[13:17:24.000] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.000] resolve() on list ... DONE
[13:17:24.000]  - Number of value chunks collected: 1
[13:17:24.001] Resolving 1 futures (chunks) ... DONE
[13:17:24.001] Reducing values from 1 chunks ...
[13:17:24.001]  - Number of values collected after concatenation: 2
[13:17:24.001]  - Number of values expected: 2
[13:17:24.001] Reducing values from 1 chunks ... DONE
[13:17:24.001] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:17:24.001] getGlobalsAndPackagesXApply() ...
[13:17:24.001]  - future.globals: TRUE
[13:17:24.002] getGlobalsAndPackages() ...
[13:17:24.002] Searching for globals...
[13:17:24.003] - globals found: [1] ‘FUN’
[13:17:24.003] Searching for globals ... DONE
[13:17:24.003] Resolving globals: FALSE
[13:17:24.003] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:24.003] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:24.004] - globals: [1] ‘FUN’
[13:17:24.004] 
[13:17:24.004] getGlobalsAndPackages() ... DONE
[13:17:24.004]  - globals found/used: [n=1] ‘FUN’
[13:17:24.004]  - needed namespaces: [n=0] 
[13:17:24.004] Finding globals ... DONE
[13:17:24.004]  - use_args: TRUE
[13:17:24.004]  - Getting '...' globals ...
[13:17:24.004] resolve() on list ...
[13:17:24.005]  recursive: 0
[13:17:24.005]  length: 1
[13:17:24.005]  elements: ‘...’
[13:17:24.005]  length: 0 (resolved future 1)
[13:17:24.005] resolve() on list ... DONE
[13:17:24.005]    - '...' content: [n=0] 
[13:17:24.005] List of 1
[13:17:24.005]  $ ...: list()
[13:17:24.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.005]  - attr(*, "where")=List of 1
[13:17:24.005]   ..$ ...:<environment: 0x5647b9926068> 
[13:17:24.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.005]  - attr(*, "resolved")= logi TRUE
[13:17:24.005]  - attr(*, "total_size")= num NA
[13:17:24.007]  - Getting '...' globals ... DONE
[13:17:24.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.008] List of 2
[13:17:24.008]  $ ...future.FUN:function (x)  
[13:17:24.008]  $ ...          : list()
[13:17:24.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.008]  - attr(*, "where")=List of 2
[13:17:24.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.008]   ..$ ...          :<environment: 0x5647b9926068> 
[13:17:24.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.008]  - attr(*, "resolved")= logi FALSE
[13:17:24.008]  - attr(*, "total_size")= num 848
[13:17:24.010] Packages to be attached in all futures: [n=0] 
[13:17:24.010] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.011] future_lapply() ...
[13:17:24.011] Number of chunks: 1
[13:17:24.011] getGlobalsAndPackagesXApply() ...
[13:17:24.011]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.011]  - use_args: TRUE
[13:17:24.011] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.012] List of 2
[13:17:24.012]  $ ...          : list()
[13:17:24.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.012]  $ ...future.FUN:function (x)  
[13:17:24.012]  - attr(*, "where")=List of 2
[13:17:24.012]   ..$ ...          :<environment: 0x5647b9926068> 
[13:17:24.012]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.012]  - attr(*, "resolved")= logi FALSE
[13:17:24.012]  - attr(*, "total_size")= num NA
[13:17:24.015] Packages to be attached in all futures: [n=0] 
[13:17:24.015] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.015] Number of futures (= number of chunks): 1
[13:17:24.015] Launching 1 futures (chunks) ...
[13:17:24.015] Chunk #1 of 1 ...
[13:17:24.015]  - Adjusted option 'future.globals.maxSize': Inf -> 6 * Inf = Inf (bytes)
[13:17:24.015]  - seeds: <none>
[13:17:24.015] getGlobalsAndPackages() ...
[13:17:24.015] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.016] Resolving globals: FALSE
[13:17:24.016] Tweak future expression to call with '...' arguments ...
[13:17:24.016] {
[13:17:24.016]     do.call(function(...) {
[13:17:24.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.016]             on.exit(options(oopts), add = TRUE)
[13:17:24.016]         }
[13:17:24.016]         {
[13:17:24.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.016]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.016]             })
[13:17:24.016]         }
[13:17:24.016]     }, args = future.call.arguments)
[13:17:24.016] }
[13:17:24.016] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.016] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.016] 
[13:17:24.017] getGlobalsAndPackages() ... DONE
[13:17:24.017] run() for ‘Future’ ...
[13:17:24.017] - state: ‘created’
[13:17:24.017] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:24.017] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:24.018]   - Field: ‘label’
[13:17:24.018]   - Field: ‘local’
[13:17:24.018]   - Field: ‘owner’
[13:17:24.018]   - Field: ‘envir’
[13:17:24.018]   - Field: ‘packages’
[13:17:24.018]   - Field: ‘gc’
[13:17:24.018]   - Field: ‘conditions’
[13:17:24.018]   - Field: ‘expr’
[13:17:24.018]   - Field: ‘uuid’
[13:17:24.018]   - Field: ‘seed’
[13:17:24.018]   - Field: ‘version’
[13:17:24.019]   - Field: ‘result’
[13:17:24.019]   - Field: ‘asynchronous’
[13:17:24.019]   - Field: ‘calls’
[13:17:24.019]   - Field: ‘globals’
[13:17:24.019]   - Field: ‘stdout’
[13:17:24.020]   - Field: ‘earlySignal’
[13:17:24.020]   - Field: ‘lazy’
[13:17:24.020]   - Field: ‘state’
[13:17:24.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:24.020] - Launch lazy future ...
[13:17:24.020] Packages needed by the future expression (n = 0): <none>
[13:17:24.021] Packages needed by future strategies (n = 0): <none>
[13:17:24.021] {
[13:17:24.021]     {
[13:17:24.021]         {
[13:17:24.021]             ...future.startTime <- base::Sys.time()
[13:17:24.021]             {
[13:17:24.021]                 {
[13:17:24.021]                   {
[13:17:24.021]                     base::local({
[13:17:24.021]                       has_future <- base::requireNamespace("future", 
[13:17:24.021]                         quietly = TRUE)
[13:17:24.021]                       if (has_future) {
[13:17:24.021]                         ns <- base::getNamespace("future")
[13:17:24.021]                         version <- ns[[".package"]][["version"]]
[13:17:24.021]                         if (is.null(version)) 
[13:17:24.021]                           version <- utils::packageVersion("future")
[13:17:24.021]                       }
[13:17:24.021]                       else {
[13:17:24.021]                         version <- NULL
[13:17:24.021]                       }
[13:17:24.021]                       if (!has_future || version < "1.8.0") {
[13:17:24.021]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.021]                           "", base::R.version$version.string), 
[13:17:24.021]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:24.021]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.021]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.021]                             "release", "version")], collapse = " "), 
[13:17:24.021]                           hostname = base::Sys.info()[["nodename"]])
[13:17:24.021]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.021]                           info)
[13:17:24.021]                         info <- base::paste(info, collapse = "; ")
[13:17:24.021]                         if (!has_future) {
[13:17:24.021]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.021]                             info)
[13:17:24.021]                         }
[13:17:24.021]                         else {
[13:17:24.021]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.021]                             info, version)
[13:17:24.021]                         }
[13:17:24.021]                         base::stop(msg)
[13:17:24.021]                       }
[13:17:24.021]                     })
[13:17:24.021]                   }
[13:17:24.021]                   options(future.plan = NULL)
[13:17:24.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.021]                 }
[13:17:24.021]                 ...future.workdir <- getwd()
[13:17:24.021]             }
[13:17:24.021]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.021]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.021]         }
[13:17:24.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.021]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.021]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.021]             base::names(...future.oldOptions))
[13:17:24.021]     }
[13:17:24.021]     if (FALSE) {
[13:17:24.021]     }
[13:17:24.021]     else {
[13:17:24.021]         if (TRUE) {
[13:17:24.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.021]                 open = "w")
[13:17:24.021]         }
[13:17:24.021]         else {
[13:17:24.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.021]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.021]         }
[13:17:24.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.021]             base::sink(type = "output", split = FALSE)
[13:17:24.021]             base::close(...future.stdout)
[13:17:24.021]         }, add = TRUE)
[13:17:24.021]     }
[13:17:24.021]     ...future.frame <- base::sys.nframe()
[13:17:24.021]     ...future.conditions <- base::list()
[13:17:24.021]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.021]     if (FALSE) {
[13:17:24.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.021]     }
[13:17:24.021]     ...future.result <- base::tryCatch({
[13:17:24.021]         base::withCallingHandlers({
[13:17:24.021]             ...future.value <- base::withVisible(base::local({
[13:17:24.021]                 do.call(function(...) {
[13:17:24.021]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.021]                   if (!identical(...future.globals.maxSize.org, 
[13:17:24.021]                     ...future.globals.maxSize)) {
[13:17:24.021]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.021]                     on.exit(options(oopts), add = TRUE)
[13:17:24.021]                   }
[13:17:24.021]                   {
[13:17:24.021]                     lapply(seq_along(...future.elements_ii), 
[13:17:24.021]                       FUN = function(jj) {
[13:17:24.021]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.021]                         ...future.FUN(...future.X_jj, ...)
[13:17:24.021]                       })
[13:17:24.021]                   }
[13:17:24.021]                 }, args = future.call.arguments)
[13:17:24.021]             }))
[13:17:24.021]             future::FutureResult(value = ...future.value$value, 
[13:17:24.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.021]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.021]                     ...future.globalenv.names))
[13:17:24.021]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.021]         }, condition = base::local({
[13:17:24.021]             c <- base::c
[13:17:24.021]             inherits <- base::inherits
[13:17:24.021]             invokeRestart <- base::invokeRestart
[13:17:24.021]             length <- base::length
[13:17:24.021]             list <- base::list
[13:17:24.021]             seq.int <- base::seq.int
[13:17:24.021]             signalCondition <- base::signalCondition
[13:17:24.021]             sys.calls <- base::sys.calls
[13:17:24.021]             `[[` <- base::`[[`
[13:17:24.021]             `+` <- base::`+`
[13:17:24.021]             `<<-` <- base::`<<-`
[13:17:24.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.021]                   3L)]
[13:17:24.021]             }
[13:17:24.021]             function(cond) {
[13:17:24.021]                 is_error <- inherits(cond, "error")
[13:17:24.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.021]                   NULL)
[13:17:24.021]                 if (is_error) {
[13:17:24.021]                   sessionInformation <- function() {
[13:17:24.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.021]                       search = base::search(), system = base::Sys.info())
[13:17:24.021]                   }
[13:17:24.021]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.021]                     cond$call), session = sessionInformation(), 
[13:17:24.021]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.021]                   signalCondition(cond)
[13:17:24.021]                 }
[13:17:24.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.021]                 "immediateCondition"))) {
[13:17:24.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.021]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.021]                   if (TRUE && !signal) {
[13:17:24.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.021]                     {
[13:17:24.021]                       inherits <- base::inherits
[13:17:24.021]                       invokeRestart <- base::invokeRestart
[13:17:24.021]                       is.null <- base::is.null
[13:17:24.021]                       muffled <- FALSE
[13:17:24.021]                       if (inherits(cond, "message")) {
[13:17:24.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.021]                         if (muffled) 
[13:17:24.021]                           invokeRestart("muffleMessage")
[13:17:24.021]                       }
[13:17:24.021]                       else if (inherits(cond, "warning")) {
[13:17:24.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.021]                         if (muffled) 
[13:17:24.021]                           invokeRestart("muffleWarning")
[13:17:24.021]                       }
[13:17:24.021]                       else if (inherits(cond, "condition")) {
[13:17:24.021]                         if (!is.null(pattern)) {
[13:17:24.021]                           computeRestarts <- base::computeRestarts
[13:17:24.021]                           grepl <- base::grepl
[13:17:24.021]                           restarts <- computeRestarts(cond)
[13:17:24.021]                           for (restart in restarts) {
[13:17:24.021]                             name <- restart$name
[13:17:24.021]                             if (is.null(name)) 
[13:17:24.021]                               next
[13:17:24.021]                             if (!grepl(pattern, name)) 
[13:17:24.021]                               next
[13:17:24.021]                             invokeRestart(restart)
[13:17:24.021]                             muffled <- TRUE
[13:17:24.021]                             break
[13:17:24.021]                           }
[13:17:24.021]                         }
[13:17:24.021]                       }
[13:17:24.021]                       invisible(muffled)
[13:17:24.021]                     }
[13:17:24.021]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.021]                   }
[13:17:24.021]                 }
[13:17:24.021]                 else {
[13:17:24.021]                   if (TRUE) {
[13:17:24.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.021]                     {
[13:17:24.021]                       inherits <- base::inherits
[13:17:24.021]                       invokeRestart <- base::invokeRestart
[13:17:24.021]                       is.null <- base::is.null
[13:17:24.021]                       muffled <- FALSE
[13:17:24.021]                       if (inherits(cond, "message")) {
[13:17:24.021]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.021]                         if (muffled) 
[13:17:24.021]                           invokeRestart("muffleMessage")
[13:17:24.021]                       }
[13:17:24.021]                       else if (inherits(cond, "warning")) {
[13:17:24.021]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.021]                         if (muffled) 
[13:17:24.021]                           invokeRestart("muffleWarning")
[13:17:24.021]                       }
[13:17:24.021]                       else if (inherits(cond, "condition")) {
[13:17:24.021]                         if (!is.null(pattern)) {
[13:17:24.021]                           computeRestarts <- base::computeRestarts
[13:17:24.021]                           grepl <- base::grepl
[13:17:24.021]                           restarts <- computeRestarts(cond)
[13:17:24.021]                           for (restart in restarts) {
[13:17:24.021]                             name <- restart$name
[13:17:24.021]                             if (is.null(name)) 
[13:17:24.021]                               next
[13:17:24.021]                             if (!grepl(pattern, name)) 
[13:17:24.021]                               next
[13:17:24.021]                             invokeRestart(restart)
[13:17:24.021]                             muffled <- TRUE
[13:17:24.021]                             break
[13:17:24.021]                           }
[13:17:24.021]                         }
[13:17:24.021]                       }
[13:17:24.021]                       invisible(muffled)
[13:17:24.021]                     }
[13:17:24.021]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.021]                   }
[13:17:24.021]                 }
[13:17:24.021]             }
[13:17:24.021]         }))
[13:17:24.021]     }, error = function(ex) {
[13:17:24.021]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.021]                 ...future.rng), started = ...future.startTime, 
[13:17:24.021]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.021]             version = "1.8"), class = "FutureResult")
[13:17:24.021]     }, finally = {
[13:17:24.021]         if (!identical(...future.workdir, getwd())) 
[13:17:24.021]             setwd(...future.workdir)
[13:17:24.021]         {
[13:17:24.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.021]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.021]             }
[13:17:24.021]             base::options(...future.oldOptions)
[13:17:24.021]             if (.Platform$OS.type == "windows") {
[13:17:24.021]                 old_names <- names(...future.oldEnvVars)
[13:17:24.021]                 envs <- base::Sys.getenv()
[13:17:24.021]                 names <- names(envs)
[13:17:24.021]                 common <- intersect(names, old_names)
[13:17:24.021]                 added <- setdiff(names, old_names)
[13:17:24.021]                 removed <- setdiff(old_names, names)
[13:17:24.021]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.021]                   envs[common]]
[13:17:24.021]                 NAMES <- toupper(changed)
[13:17:24.021]                 args <- list()
[13:17:24.021]                 for (kk in seq_along(NAMES)) {
[13:17:24.021]                   name <- changed[[kk]]
[13:17:24.021]                   NAME <- NAMES[[kk]]
[13:17:24.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.021]                     next
[13:17:24.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.021]                 }
[13:17:24.021]                 NAMES <- toupper(added)
[13:17:24.021]                 for (kk in seq_along(NAMES)) {
[13:17:24.021]                   name <- added[[kk]]
[13:17:24.021]                   NAME <- NAMES[[kk]]
[13:17:24.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.021]                     next
[13:17:24.021]                   args[[name]] <- ""
[13:17:24.021]                 }
[13:17:24.021]                 NAMES <- toupper(removed)
[13:17:24.021]                 for (kk in seq_along(NAMES)) {
[13:17:24.021]                   name <- removed[[kk]]
[13:17:24.021]                   NAME <- NAMES[[kk]]
[13:17:24.021]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.021]                     next
[13:17:24.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.021]                 }
[13:17:24.021]                 if (length(args) > 0) 
[13:17:24.021]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.021]             }
[13:17:24.021]             else {
[13:17:24.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.021]             }
[13:17:24.021]             {
[13:17:24.021]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.021]                   0L) {
[13:17:24.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.021]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.021]                   base::options(opts)
[13:17:24.021]                 }
[13:17:24.021]                 {
[13:17:24.021]                   {
[13:17:24.021]                     NULL
[13:17:24.021]                     RNGkind("Mersenne-Twister")
[13:17:24.021]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:24.021]                       inherits = FALSE)
[13:17:24.021]                   }
[13:17:24.021]                   options(future.plan = NULL)
[13:17:24.021]                   if (is.na(NA_character_)) 
[13:17:24.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.021]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:24.021]                   {
[13:17:24.021]                     future <- SequentialFuture(..., envir = envir)
[13:17:24.021]                     if (!future$lazy) 
[13:17:24.021]                       future <- run(future)
[13:17:24.021]                     invisible(future)
[13:17:24.021]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.021]                 }
[13:17:24.021]             }
[13:17:24.021]         }
[13:17:24.021]     })
[13:17:24.021]     if (TRUE) {
[13:17:24.021]         base::sink(type = "output", split = FALSE)
[13:17:24.021]         if (TRUE) {
[13:17:24.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.021]         }
[13:17:24.021]         else {
[13:17:24.021]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.021]         }
[13:17:24.021]         base::close(...future.stdout)
[13:17:24.021]         ...future.stdout <- NULL
[13:17:24.021]     }
[13:17:24.021]     ...future.result$conditions <- ...future.conditions
[13:17:24.021]     ...future.result$finished <- base::Sys.time()
[13:17:24.021]     ...future.result
[13:17:24.021] }
[13:17:24.023] assign_globals() ...
[13:17:24.023] List of 5
[13:17:24.023]  $ future.call.arguments    : list()
[13:17:24.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.023]  $ ...future.FUN            :function (x)  
[13:17:24.023]  $ ...future.elements_ii    :List of 6
[13:17:24.023]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.023]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.023]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.023]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.023]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.023]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.023]  $ ...future.seeds_ii       : NULL
[13:17:24.023]  $ ...future.globals.maxSize: num Inf
[13:17:24.023]  - attr(*, "resolved")= logi FALSE
[13:17:24.023]  - attr(*, "total_size")= num NA
[13:17:24.023]  - attr(*, "where")=List of 5
[13:17:24.023]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.023]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.023]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.023]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.023]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.023]  - attr(*, "already-done")= logi TRUE
[13:17:24.029] - copied ‘future.call.arguments’ to environment
[13:17:24.029] - copied ‘...future.FUN’ to environment
[13:17:24.029] - copied ‘...future.elements_ii’ to environment
[13:17:24.029] - copied ‘...future.seeds_ii’ to environment
[13:17:24.029] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.029] assign_globals() ... done
[13:17:24.029] plan(): Setting new future strategy stack:
[13:17:24.029] List of future strategies:
[13:17:24.029] 1. sequential:
[13:17:24.029]    - args: function (..., envir = parent.frame())
[13:17:24.029]    - tweaked: FALSE
[13:17:24.029]    - call: NULL
[13:17:24.030] plan(): nbrOfWorkers() = 1
[13:17:24.031] plan(): Setting new future strategy stack:
[13:17:24.031] List of future strategies:
[13:17:24.031] 1. sequential:
[13:17:24.031]    - args: function (..., envir = parent.frame())
[13:17:24.031]    - tweaked: FALSE
[13:17:24.031]    - call: plan(strategy)
[13:17:24.031] plan(): nbrOfWorkers() = 1
[13:17:24.031] SequentialFuture started (and completed)
[13:17:24.031] - Launch lazy future ... done
[13:17:24.031] run() for ‘SequentialFuture’ ... done
[13:17:24.031] Created future:
[13:17:24.032] SequentialFuture:
[13:17:24.032] Label: ‘future_apply-1’
[13:17:24.032] Expression:
[13:17:24.032] {
[13:17:24.032]     do.call(function(...) {
[13:17:24.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.032]             on.exit(options(oopts), add = TRUE)
[13:17:24.032]         }
[13:17:24.032]         {
[13:17:24.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.032]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.032]             })
[13:17:24.032]         }
[13:17:24.032]     }, args = future.call.arguments)
[13:17:24.032] }
[13:17:24.032] Lazy evaluation: FALSE
[13:17:24.032] Asynchronous evaluation: FALSE
[13:17:24.032] Local evaluation: TRUE
[13:17:24.032] Environment: R_GlobalEnv
[13:17:24.032] Capture standard output: TRUE
[13:17:24.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.032] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.032] Packages: <none>
[13:17:24.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.032] Resolved: TRUE
[13:17:24.032] Value: 672 bytes of class ‘list’
[13:17:24.032] Early signaling: FALSE
[13:17:24.032] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.032] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.033] Chunk #1 of 1 ... DONE
[13:17:24.033] Launching 1 futures (chunks) ... DONE
[13:17:24.033] Resolving 1 futures (chunks) ...
[13:17:24.033] resolve() on list ...
[13:17:24.033]  recursive: 0
[13:17:24.033]  length: 1
[13:17:24.033] 
[13:17:24.033] resolved() for ‘SequentialFuture’ ...
[13:17:24.033] - state: ‘finished’
[13:17:24.033] - run: TRUE
[13:17:24.033] - result: ‘FutureResult’
[13:17:24.034] resolved() for ‘SequentialFuture’ ... done
[13:17:24.034] Future #1
[13:17:24.034] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:24.034] - nx: 1
[13:17:24.034] - relay: TRUE
[13:17:24.034] - stdout: TRUE
[13:17:24.034] - signal: TRUE
[13:17:24.034] - resignal: FALSE
[13:17:24.034] - force: TRUE
[13:17:24.034] - relayed: [n=1] FALSE
[13:17:24.034] - queued futures: [n=1] FALSE
[13:17:24.035]  - until=1
[13:17:24.035]  - relaying element #1
[13:17:24.035] - relayed: [n=1] TRUE
[13:17:24.035] - queued futures: [n=1] TRUE
[13:17:24.035] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:24.035]  length: 0 (resolved future 1)
[13:17:24.035] Relaying remaining futures
[13:17:24.035] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.035] - nx: 1
[13:17:24.035] - relay: TRUE
[13:17:24.035] - stdout: TRUE
[13:17:24.036] - signal: TRUE
[13:17:24.036] - resignal: FALSE
[13:17:24.036] - force: TRUE
[13:17:24.036] - relayed: [n=1] TRUE
[13:17:24.036] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.036] - relayed: [n=1] TRUE
[13:17:24.036] - queued futures: [n=1] TRUE
[13:17:24.036] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.036] resolve() on list ... DONE
[13:17:24.036]  - Number of value chunks collected: 1
[13:17:24.037] Resolving 1 futures (chunks) ... DONE
[13:17:24.037] Reducing values from 1 chunks ...
[13:17:24.037]  - Number of values collected after concatenation: 6
[13:17:24.037]  - Number of values expected: 6
[13:17:24.037] Reducing values from 1 chunks ... DONE
[13:17:24.037] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:17:24.037] getGlobalsAndPackagesXApply() ...
[13:17:24.038]  - future.globals: TRUE
[13:17:24.038] getGlobalsAndPackages() ...
[13:17:24.038] Searching for globals...
[13:17:24.039] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:17:24.039] Searching for globals ... DONE
[13:17:24.039] Resolving globals: FALSE
[13:17:24.039] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:17:24.040] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:17:24.040] - globals: [1] ‘FUN’
[13:17:24.040] 
[13:17:24.040] getGlobalsAndPackages() ... DONE
[13:17:24.040]  - globals found/used: [n=1] ‘FUN’
[13:17:24.040]  - needed namespaces: [n=0] 
[13:17:24.040] Finding globals ... DONE
[13:17:24.040]  - use_args: TRUE
[13:17:24.041]  - Getting '...' globals ...
[13:17:24.042] resolve() on list ...
[13:17:24.042]  recursive: 0
[13:17:24.042]  length: 1
[13:17:24.042]  elements: ‘...’
[13:17:24.042]  length: 0 (resolved future 1)
[13:17:24.042] resolve() on list ... DONE
[13:17:24.043]    - '...' content: [n=0] 
[13:17:24.043] List of 1
[13:17:24.043]  $ ...: list()
[13:17:24.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.043]  - attr(*, "where")=List of 1
[13:17:24.043]   ..$ ...:<environment: 0x5647bb07eb68> 
[13:17:24.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.043]  - attr(*, "resolved")= logi TRUE
[13:17:24.043]  - attr(*, "total_size")= num NA
[13:17:24.045]  - Getting '...' globals ... DONE
[13:17:24.045] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.045] List of 2
[13:17:24.045]  $ ...future.FUN:function (x)  
[13:17:24.045]  $ ...          : list()
[13:17:24.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.045]  - attr(*, "where")=List of 2
[13:17:24.045]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.045]   ..$ ...          :<environment: 0x5647bb07eb68> 
[13:17:24.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.045]  - attr(*, "resolved")= logi FALSE
[13:17:24.045]  - attr(*, "total_size")= num 1768
[13:17:24.048] Packages to be attached in all futures: [n=0] 
[13:17:24.048] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.048] future_lapply() ...
[13:17:24.049] Number of chunks: 1
[13:17:24.049] getGlobalsAndPackagesXApply() ...
[13:17:24.049]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.049]  - use_args: TRUE
[13:17:24.049] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.049] List of 2
[13:17:24.049]  $ ...          : list()
[13:17:24.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.049]  $ ...future.FUN:function (x)  
[13:17:24.049]  - attr(*, "where")=List of 2
[13:17:24.049]   ..$ ...          :<environment: 0x5647bb07eb68> 
[13:17:24.049]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:17:24.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.049]  - attr(*, "resolved")= logi FALSE
[13:17:24.049]  - attr(*, "total_size")= num NA
[13:17:24.052] Packages to be attached in all futures: [n=0] 
[13:17:24.052] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.052] Number of futures (= number of chunks): 1
[13:17:24.052] Launching 1 futures (chunks) ...
[13:17:24.052] Chunk #1 of 1 ...
[13:17:24.052]  - Adjusted option 'future.globals.maxSize': Inf -> 6 * Inf = Inf (bytes)
[13:17:24.053]  - seeds: <none>
[13:17:24.053] getGlobalsAndPackages() ...
[13:17:24.053] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.053] Resolving globals: FALSE
[13:17:24.053] Tweak future expression to call with '...' arguments ...
[13:17:24.053] {
[13:17:24.053]     do.call(function(...) {
[13:17:24.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.053]             on.exit(options(oopts), add = TRUE)
[13:17:24.053]         }
[13:17:24.053]         {
[13:17:24.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.053]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.053]             })
[13:17:24.053]         }
[13:17:24.053]     }, args = future.call.arguments)
[13:17:24.053] }
[13:17:24.053] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.054] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.054] 
[13:17:24.054] getGlobalsAndPackages() ... DONE
[13:17:24.054] run() for ‘Future’ ...
[13:17:24.054] - state: ‘created’
[13:17:24.054] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:24.055] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:24.055]   - Field: ‘label’
[13:17:24.055]   - Field: ‘local’
[13:17:24.055]   - Field: ‘owner’
[13:17:24.055]   - Field: ‘envir’
[13:17:24.055]   - Field: ‘packages’
[13:17:24.055]   - Field: ‘gc’
[13:17:24.055]   - Field: ‘conditions’
[13:17:24.055]   - Field: ‘expr’
[13:17:24.056]   - Field: ‘uuid’
[13:17:24.056]   - Field: ‘seed’
[13:17:24.056]   - Field: ‘version’
[13:17:24.056]   - Field: ‘result’
[13:17:24.056]   - Field: ‘asynchronous’
[13:17:24.056]   - Field: ‘calls’
[13:17:24.056]   - Field: ‘globals’
[13:17:24.056]   - Field: ‘stdout’
[13:17:24.056]   - Field: ‘earlySignal’
[13:17:24.056]   - Field: ‘lazy’
[13:17:24.056]   - Field: ‘state’
[13:17:24.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:24.057] - Launch lazy future ...
[13:17:24.057] Packages needed by the future expression (n = 0): <none>
[13:17:24.057] Packages needed by future strategies (n = 0): <none>
[13:17:24.057] {
[13:17:24.057]     {
[13:17:24.057]         {
[13:17:24.057]             ...future.startTime <- base::Sys.time()
[13:17:24.057]             {
[13:17:24.057]                 {
[13:17:24.057]                   {
[13:17:24.057]                     base::local({
[13:17:24.057]                       has_future <- base::requireNamespace("future", 
[13:17:24.057]                         quietly = TRUE)
[13:17:24.057]                       if (has_future) {
[13:17:24.057]                         ns <- base::getNamespace("future")
[13:17:24.057]                         version <- ns[[".package"]][["version"]]
[13:17:24.057]                         if (is.null(version)) 
[13:17:24.057]                           version <- utils::packageVersion("future")
[13:17:24.057]                       }
[13:17:24.057]                       else {
[13:17:24.057]                         version <- NULL
[13:17:24.057]                       }
[13:17:24.057]                       if (!has_future || version < "1.8.0") {
[13:17:24.057]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.057]                           "", base::R.version$version.string), 
[13:17:24.057]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:24.057]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.057]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.057]                             "release", "version")], collapse = " "), 
[13:17:24.057]                           hostname = base::Sys.info()[["nodename"]])
[13:17:24.057]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.057]                           info)
[13:17:24.057]                         info <- base::paste(info, collapse = "; ")
[13:17:24.057]                         if (!has_future) {
[13:17:24.057]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.057]                             info)
[13:17:24.057]                         }
[13:17:24.057]                         else {
[13:17:24.057]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.057]                             info, version)
[13:17:24.057]                         }
[13:17:24.057]                         base::stop(msg)
[13:17:24.057]                       }
[13:17:24.057]                     })
[13:17:24.057]                   }
[13:17:24.057]                   options(future.plan = NULL)
[13:17:24.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.057]                 }
[13:17:24.057]                 ...future.workdir <- getwd()
[13:17:24.057]             }
[13:17:24.057]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.057]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.057]         }
[13:17:24.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.057]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.057]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.057]             base::names(...future.oldOptions))
[13:17:24.057]     }
[13:17:24.057]     if (FALSE) {
[13:17:24.057]     }
[13:17:24.057]     else {
[13:17:24.057]         if (TRUE) {
[13:17:24.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.057]                 open = "w")
[13:17:24.057]         }
[13:17:24.057]         else {
[13:17:24.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.057]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.057]         }
[13:17:24.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.057]             base::sink(type = "output", split = FALSE)
[13:17:24.057]             base::close(...future.stdout)
[13:17:24.057]         }, add = TRUE)
[13:17:24.057]     }
[13:17:24.057]     ...future.frame <- base::sys.nframe()
[13:17:24.057]     ...future.conditions <- base::list()
[13:17:24.057]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.057]     if (FALSE) {
[13:17:24.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.057]     }
[13:17:24.057]     ...future.result <- base::tryCatch({
[13:17:24.057]         base::withCallingHandlers({
[13:17:24.057]             ...future.value <- base::withVisible(base::local({
[13:17:24.057]                 do.call(function(...) {
[13:17:24.057]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.057]                   if (!identical(...future.globals.maxSize.org, 
[13:17:24.057]                     ...future.globals.maxSize)) {
[13:17:24.057]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.057]                     on.exit(options(oopts), add = TRUE)
[13:17:24.057]                   }
[13:17:24.057]                   {
[13:17:24.057]                     lapply(seq_along(...future.elements_ii), 
[13:17:24.057]                       FUN = function(jj) {
[13:17:24.057]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.057]                         ...future.FUN(...future.X_jj, ...)
[13:17:24.057]                       })
[13:17:24.057]                   }
[13:17:24.057]                 }, args = future.call.arguments)
[13:17:24.057]             }))
[13:17:24.057]             future::FutureResult(value = ...future.value$value, 
[13:17:24.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.057]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.057]                     ...future.globalenv.names))
[13:17:24.057]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.057]         }, condition = base::local({
[13:17:24.057]             c <- base::c
[13:17:24.057]             inherits <- base::inherits
[13:17:24.057]             invokeRestart <- base::invokeRestart
[13:17:24.057]             length <- base::length
[13:17:24.057]             list <- base::list
[13:17:24.057]             seq.int <- base::seq.int
[13:17:24.057]             signalCondition <- base::signalCondition
[13:17:24.057]             sys.calls <- base::sys.calls
[13:17:24.057]             `[[` <- base::`[[`
[13:17:24.057]             `+` <- base::`+`
[13:17:24.057]             `<<-` <- base::`<<-`
[13:17:24.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.057]                   3L)]
[13:17:24.057]             }
[13:17:24.057]             function(cond) {
[13:17:24.057]                 is_error <- inherits(cond, "error")
[13:17:24.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.057]                   NULL)
[13:17:24.057]                 if (is_error) {
[13:17:24.057]                   sessionInformation <- function() {
[13:17:24.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.057]                       search = base::search(), system = base::Sys.info())
[13:17:24.057]                   }
[13:17:24.057]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.057]                     cond$call), session = sessionInformation(), 
[13:17:24.057]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.057]                   signalCondition(cond)
[13:17:24.057]                 }
[13:17:24.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.057]                 "immediateCondition"))) {
[13:17:24.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.057]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.057]                   if (TRUE && !signal) {
[13:17:24.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.057]                     {
[13:17:24.057]                       inherits <- base::inherits
[13:17:24.057]                       invokeRestart <- base::invokeRestart
[13:17:24.057]                       is.null <- base::is.null
[13:17:24.057]                       muffled <- FALSE
[13:17:24.057]                       if (inherits(cond, "message")) {
[13:17:24.057]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.057]                         if (muffled) 
[13:17:24.057]                           invokeRestart("muffleMessage")
[13:17:24.057]                       }
[13:17:24.057]                       else if (inherits(cond, "warning")) {
[13:17:24.057]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.057]                         if (muffled) 
[13:17:24.057]                           invokeRestart("muffleWarning")
[13:17:24.057]                       }
[13:17:24.057]                       else if (inherits(cond, "condition")) {
[13:17:24.057]                         if (!is.null(pattern)) {
[13:17:24.057]                           computeRestarts <- base::computeRestarts
[13:17:24.057]                           grepl <- base::grepl
[13:17:24.057]                           restarts <- computeRestarts(cond)
[13:17:24.057]                           for (restart in restarts) {
[13:17:24.057]                             name <- restart$name
[13:17:24.057]                             if (is.null(name)) 
[13:17:24.057]                               next
[13:17:24.057]                             if (!grepl(pattern, name)) 
[13:17:24.057]                               next
[13:17:24.057]                             invokeRestart(restart)
[13:17:24.057]                             muffled <- TRUE
[13:17:24.057]                             break
[13:17:24.057]                           }
[13:17:24.057]                         }
[13:17:24.057]                       }
[13:17:24.057]                       invisible(muffled)
[13:17:24.057]                     }
[13:17:24.057]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.057]                   }
[13:17:24.057]                 }
[13:17:24.057]                 else {
[13:17:24.057]                   if (TRUE) {
[13:17:24.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.057]                     {
[13:17:24.057]                       inherits <- base::inherits
[13:17:24.057]                       invokeRestart <- base::invokeRestart
[13:17:24.057]                       is.null <- base::is.null
[13:17:24.057]                       muffled <- FALSE
[13:17:24.057]                       if (inherits(cond, "message")) {
[13:17:24.057]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.057]                         if (muffled) 
[13:17:24.057]                           invokeRestart("muffleMessage")
[13:17:24.057]                       }
[13:17:24.057]                       else if (inherits(cond, "warning")) {
[13:17:24.057]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.057]                         if (muffled) 
[13:17:24.057]                           invokeRestart("muffleWarning")
[13:17:24.057]                       }
[13:17:24.057]                       else if (inherits(cond, "condition")) {
[13:17:24.057]                         if (!is.null(pattern)) {
[13:17:24.057]                           computeRestarts <- base::computeRestarts
[13:17:24.057]                           grepl <- base::grepl
[13:17:24.057]                           restarts <- computeRestarts(cond)
[13:17:24.057]                           for (restart in restarts) {
[13:17:24.057]                             name <- restart$name
[13:17:24.057]                             if (is.null(name)) 
[13:17:24.057]                               next
[13:17:24.057]                             if (!grepl(pattern, name)) 
[13:17:24.057]                               next
[13:17:24.057]                             invokeRestart(restart)
[13:17:24.057]                             muffled <- TRUE
[13:17:24.057]                             break
[13:17:24.057]                           }
[13:17:24.057]                         }
[13:17:24.057]                       }
[13:17:24.057]                       invisible(muffled)
[13:17:24.057]                     }
[13:17:24.057]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.057]                   }
[13:17:24.057]                 }
[13:17:24.057]             }
[13:17:24.057]         }))
[13:17:24.057]     }, error = function(ex) {
[13:17:24.057]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.057]                 ...future.rng), started = ...future.startTime, 
[13:17:24.057]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.057]             version = "1.8"), class = "FutureResult")
[13:17:24.057]     }, finally = {
[13:17:24.057]         if (!identical(...future.workdir, getwd())) 
[13:17:24.057]             setwd(...future.workdir)
[13:17:24.057]         {
[13:17:24.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.057]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.057]             }
[13:17:24.057]             base::options(...future.oldOptions)
[13:17:24.057]             if (.Platform$OS.type == "windows") {
[13:17:24.057]                 old_names <- names(...future.oldEnvVars)
[13:17:24.057]                 envs <- base::Sys.getenv()
[13:17:24.057]                 names <- names(envs)
[13:17:24.057]                 common <- intersect(names, old_names)
[13:17:24.057]                 added <- setdiff(names, old_names)
[13:17:24.057]                 removed <- setdiff(old_names, names)
[13:17:24.057]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.057]                   envs[common]]
[13:17:24.057]                 NAMES <- toupper(changed)
[13:17:24.057]                 args <- list()
[13:17:24.057]                 for (kk in seq_along(NAMES)) {
[13:17:24.057]                   name <- changed[[kk]]
[13:17:24.057]                   NAME <- NAMES[[kk]]
[13:17:24.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.057]                     next
[13:17:24.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.057]                 }
[13:17:24.057]                 NAMES <- toupper(added)
[13:17:24.057]                 for (kk in seq_along(NAMES)) {
[13:17:24.057]                   name <- added[[kk]]
[13:17:24.057]                   NAME <- NAMES[[kk]]
[13:17:24.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.057]                     next
[13:17:24.057]                   args[[name]] <- ""
[13:17:24.057]                 }
[13:17:24.057]                 NAMES <- toupper(removed)
[13:17:24.057]                 for (kk in seq_along(NAMES)) {
[13:17:24.057]                   name <- removed[[kk]]
[13:17:24.057]                   NAME <- NAMES[[kk]]
[13:17:24.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.057]                     next
[13:17:24.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.057]                 }
[13:17:24.057]                 if (length(args) > 0) 
[13:17:24.057]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.057]             }
[13:17:24.057]             else {
[13:17:24.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.057]             }
[13:17:24.057]             {
[13:17:24.057]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.057]                   0L) {
[13:17:24.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.057]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.057]                   base::options(opts)
[13:17:24.057]                 }
[13:17:24.057]                 {
[13:17:24.057]                   {
[13:17:24.057]                     NULL
[13:17:24.057]                     RNGkind("Mersenne-Twister")
[13:17:24.057]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:24.057]                       inherits = FALSE)
[13:17:24.057]                   }
[13:17:24.057]                   options(future.plan = NULL)
[13:17:24.057]                   if (is.na(NA_character_)) 
[13:17:24.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.057]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:24.057]                   {
[13:17:24.057]                     future <- SequentialFuture(..., envir = envir)
[13:17:24.057]                     if (!future$lazy) 
[13:17:24.057]                       future <- run(future)
[13:17:24.057]                     invisible(future)
[13:17:24.057]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.057]                 }
[13:17:24.057]             }
[13:17:24.057]         }
[13:17:24.057]     })
[13:17:24.057]     if (TRUE) {
[13:17:24.057]         base::sink(type = "output", split = FALSE)
[13:17:24.057]         if (TRUE) {
[13:17:24.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.057]         }
[13:17:24.057]         else {
[13:17:24.057]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.057]         }
[13:17:24.057]         base::close(...future.stdout)
[13:17:24.057]         ...future.stdout <- NULL
[13:17:24.057]     }
[13:17:24.057]     ...future.result$conditions <- ...future.conditions
[13:17:24.057]     ...future.result$finished <- base::Sys.time()
[13:17:24.057]     ...future.result
[13:17:24.057] }
[13:17:24.059] assign_globals() ...
[13:17:24.059] List of 5
[13:17:24.059]  $ future.call.arguments    : list()
[13:17:24.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.059]  $ ...future.FUN            :function (x)  
[13:17:24.059]  $ ...future.elements_ii    :List of 6
[13:17:24.059]   ..$ : int [1:4] 1 7 13 19
[13:17:24.059]   ..$ : int [1:4] 2 8 14 20
[13:17:24.059]   ..$ : int [1:4] 3 9 15 21
[13:17:24.059]   ..$ : int [1:4] 4 10 16 22
[13:17:24.059]   ..$ : int [1:4] 5 11 17 23
[13:17:24.059]   ..$ : int [1:4] 6 12 18 24
[13:17:24.059]  $ ...future.seeds_ii       : NULL
[13:17:24.059]  $ ...future.globals.maxSize: num Inf
[13:17:24.059]  - attr(*, "resolved")= logi FALSE
[13:17:24.059]  - attr(*, "total_size")= num NA
[13:17:24.059]  - attr(*, "where")=List of 5
[13:17:24.059]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.059]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.059]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.059]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.059]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.059]  - attr(*, "already-done")= logi TRUE
[13:17:24.089] - copied ‘future.call.arguments’ to environment
[13:17:24.089] - reassign environment for ‘...future.FUN’
[13:17:24.089] - copied ‘...future.FUN’ to environment
[13:17:24.089] - copied ‘...future.elements_ii’ to environment
[13:17:24.089] - copied ‘...future.seeds_ii’ to environment
[13:17:24.090] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.090] assign_globals() ... done
[13:17:24.090] plan(): Setting new future strategy stack:
[13:17:24.090] List of future strategies:
[13:17:24.090] 1. sequential:
[13:17:24.090]    - args: function (..., envir = parent.frame())
[13:17:24.090]    - tweaked: FALSE
[13:17:24.090]    - call: NULL
[13:17:24.090] plan(): nbrOfWorkers() = 1
[13:17:24.091] plan(): Setting new future strategy stack:
[13:17:24.091] List of future strategies:
[13:17:24.091] 1. sequential:
[13:17:24.091]    - args: function (..., envir = parent.frame())
[13:17:24.091]    - tweaked: FALSE
[13:17:24.091]    - call: plan(strategy)
[13:17:24.092] plan(): nbrOfWorkers() = 1
[13:17:24.092] SequentialFuture started (and completed)
[13:17:24.092] - Launch lazy future ... done
[13:17:24.092] run() for ‘SequentialFuture’ ... done
[13:17:24.092] Created future:
[13:17:24.092] SequentialFuture:
[13:17:24.092] Label: ‘future_apply-1’
[13:17:24.092] Expression:
[13:17:24.092] {
[13:17:24.092]     do.call(function(...) {
[13:17:24.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.092]             on.exit(options(oopts), add = TRUE)
[13:17:24.092]         }
[13:17:24.092]         {
[13:17:24.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.092]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.092]             })
[13:17:24.092]         }
[13:17:24.092]     }, args = future.call.arguments)
[13:17:24.092] }
[13:17:24.092] Lazy evaluation: FALSE
[13:17:24.092] Asynchronous evaluation: FALSE
[13:17:24.092] Local evaluation: TRUE
[13:17:24.092] Environment: R_GlobalEnv
[13:17:24.092] Capture standard output: TRUE
[13:17:24.092] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.092] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.092] Packages: <none>
[13:17:24.092] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.092] Resolved: TRUE
[13:17:24.092] Value: 1.03 KiB of class ‘list’
[13:17:24.092] Early signaling: FALSE
[13:17:24.092] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.092] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.093] Chunk #1 of 1 ... DONE
[13:17:24.093] Launching 1 futures (chunks) ... DONE
[13:17:24.093] Resolving 1 futures (chunks) ...
[13:17:24.093] resolve() on list ...
[13:17:24.094]  recursive: 0
[13:17:24.094]  length: 1
[13:17:24.094] 
[13:17:24.094] resolved() for ‘SequentialFuture’ ...
[13:17:24.094] - state: ‘finished’
[13:17:24.094] - run: TRUE
[13:17:24.094] - result: ‘FutureResult’
[13:17:24.094] resolved() for ‘SequentialFuture’ ... done
[13:17:24.094] Future #1
[13:17:24.095] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:24.095] - nx: 1
[13:17:24.095] - relay: TRUE
[13:17:24.095] - stdout: TRUE
[13:17:24.095] - signal: TRUE
[13:17:24.095] - resignal: FALSE
[13:17:24.095] - force: TRUE
[13:17:24.095] - relayed: [n=1] FALSE
[13:17:24.095] - queued futures: [n=1] FALSE
[13:17:24.095]  - until=1
[13:17:24.095]  - relaying element #1
[13:17:24.096] - relayed: [n=1] TRUE
[13:17:24.096] - queued futures: [n=1] TRUE
[13:17:24.096] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:24.096]  length: 0 (resolved future 1)
[13:17:24.096] Relaying remaining futures
[13:17:24.096] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.096] - nx: 1
[13:17:24.096] - relay: TRUE
[13:17:24.096] - stdout: TRUE
[13:17:24.096] - signal: TRUE
[13:17:24.096] - resignal: FALSE
[13:17:24.096] - force: TRUE
[13:17:24.097] - relayed: [n=1] TRUE
[13:17:24.097] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.097] - relayed: [n=1] TRUE
[13:17:24.097] - queued futures: [n=1] TRUE
[13:17:24.097] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.097] resolve() on list ... DONE
[13:17:24.097]  - Number of value chunks collected: 1
[13:17:24.097] Resolving 1 futures (chunks) ... DONE
[13:17:24.097] Reducing values from 1 chunks ...
[13:17:24.098]  - Number of values collected after concatenation: 6
[13:17:24.098]  - Number of values expected: 6
[13:17:24.098] Reducing values from 1 chunks ... DONE
[13:17:24.098] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:17:24.098] getGlobalsAndPackagesXApply() ...
[13:17:24.098]  - future.globals: TRUE
[13:17:24.098] getGlobalsAndPackages() ...
[13:17:24.098] Searching for globals...
[13:17:24.099] - globals found: [1] ‘FUN’
[13:17:24.099] Searching for globals ... DONE
[13:17:24.100] Resolving globals: FALSE
[13:17:24.100] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:24.100] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:24.100] - globals: [1] ‘FUN’
[13:17:24.100] 
[13:17:24.100] getGlobalsAndPackages() ... DONE
[13:17:24.101]  - globals found/used: [n=1] ‘FUN’
[13:17:24.101]  - needed namespaces: [n=0] 
[13:17:24.101] Finding globals ... DONE
[13:17:24.101]  - use_args: TRUE
[13:17:24.101]  - Getting '...' globals ...
[13:17:24.101] resolve() on list ...
[13:17:24.101]  recursive: 0
[13:17:24.101]  length: 1
[13:17:24.101]  elements: ‘...’
[13:17:24.102]  length: 0 (resolved future 1)
[13:17:24.102] resolve() on list ... DONE
[13:17:24.102]    - '...' content: [n=0] 
[13:17:24.102] List of 1
[13:17:24.102]  $ ...: list()
[13:17:24.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.102]  - attr(*, "where")=List of 1
[13:17:24.102]   ..$ ...:<environment: 0x5647ba8e00d0> 
[13:17:24.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.102]  - attr(*, "resolved")= logi TRUE
[13:17:24.102]  - attr(*, "total_size")= num NA
[13:17:24.104]  - Getting '...' globals ... DONE
[13:17:24.105] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.105] List of 2
[13:17:24.105]  $ ...future.FUN:function (x)  
[13:17:24.105]  $ ...          : list()
[13:17:24.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.105]  - attr(*, "where")=List of 2
[13:17:24.105]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.105]   ..$ ...          :<environment: 0x5647ba8e00d0> 
[13:17:24.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.105]  - attr(*, "resolved")= logi FALSE
[13:17:24.105]  - attr(*, "total_size")= num 848
[13:17:24.107] Packages to be attached in all futures: [n=0] 
[13:17:24.107] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.108] future_lapply() ...
[13:17:24.109] Number of chunks: 1
[13:17:24.109] getGlobalsAndPackagesXApply() ...
[13:17:24.109]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.110]  - use_args: TRUE
[13:17:24.110] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.110] List of 2
[13:17:24.110]  $ ...          : list()
[13:17:24.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.110]  $ ...future.FUN:function (x)  
[13:17:24.110]  - attr(*, "where")=List of 2
[13:17:24.110]   ..$ ...          :<environment: 0x5647ba8e00d0> 
[13:17:24.110]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.110]  - attr(*, "resolved")= logi FALSE
[13:17:24.110]  - attr(*, "total_size")= num NA
[13:17:24.113] Packages to be attached in all futures: [n=0] 
[13:17:24.113] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.113] Number of futures (= number of chunks): 1
[13:17:24.114] Launching 1 futures (chunks) ...
[13:17:24.114] Chunk #1 of 1 ...
[13:17:24.114]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:24.114]  - seeds: <none>
[13:17:24.114] getGlobalsAndPackages() ...
[13:17:24.114] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.114] Resolving globals: FALSE
[13:17:24.114] Tweak future expression to call with '...' arguments ...
[13:17:24.114] {
[13:17:24.114]     do.call(function(...) {
[13:17:24.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.114]             on.exit(options(oopts), add = TRUE)
[13:17:24.114]         }
[13:17:24.114]         {
[13:17:24.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.114]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.114]             })
[13:17:24.114]         }
[13:17:24.114]     }, args = future.call.arguments)
[13:17:24.114] }
[13:17:24.115] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.115] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.115] 
[13:17:24.115] getGlobalsAndPackages() ... DONE
[13:17:24.116] run() for ‘Future’ ...
[13:17:24.116] - state: ‘created’
[13:17:24.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:24.116] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:24.116]   - Field: ‘label’
[13:17:24.116]   - Field: ‘local’
[13:17:24.117]   - Field: ‘owner’
[13:17:24.117]   - Field: ‘envir’
[13:17:24.117]   - Field: ‘packages’
[13:17:24.117]   - Field: ‘gc’
[13:17:24.117]   - Field: ‘conditions’
[13:17:24.117]   - Field: ‘expr’
[13:17:24.117]   - Field: ‘uuid’
[13:17:24.117]   - Field: ‘seed’
[13:17:24.117]   - Field: ‘version’
[13:17:24.118]   - Field: ‘result’
[13:17:24.118]   - Field: ‘asynchronous’
[13:17:24.118]   - Field: ‘calls’
[13:17:24.118]   - Field: ‘globals’
[13:17:24.118]   - Field: ‘stdout’
[13:17:24.118]   - Field: ‘earlySignal’
[13:17:24.118]   - Field: ‘lazy’
[13:17:24.118]   - Field: ‘state’
[13:17:24.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:24.118] - Launch lazy future ...
[13:17:24.119] Packages needed by the future expression (n = 0): <none>
[13:17:24.119] Packages needed by future strategies (n = 0): <none>
[13:17:24.119] {
[13:17:24.119]     {
[13:17:24.119]         {
[13:17:24.119]             ...future.startTime <- base::Sys.time()
[13:17:24.119]             {
[13:17:24.119]                 {
[13:17:24.119]                   {
[13:17:24.119]                     base::local({
[13:17:24.119]                       has_future <- base::requireNamespace("future", 
[13:17:24.119]                         quietly = TRUE)
[13:17:24.119]                       if (has_future) {
[13:17:24.119]                         ns <- base::getNamespace("future")
[13:17:24.119]                         version <- ns[[".package"]][["version"]]
[13:17:24.119]                         if (is.null(version)) 
[13:17:24.119]                           version <- utils::packageVersion("future")
[13:17:24.119]                       }
[13:17:24.119]                       else {
[13:17:24.119]                         version <- NULL
[13:17:24.119]                       }
[13:17:24.119]                       if (!has_future || version < "1.8.0") {
[13:17:24.119]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.119]                           "", base::R.version$version.string), 
[13:17:24.119]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:24.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.119]                             "release", "version")], collapse = " "), 
[13:17:24.119]                           hostname = base::Sys.info()[["nodename"]])
[13:17:24.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.119]                           info)
[13:17:24.119]                         info <- base::paste(info, collapse = "; ")
[13:17:24.119]                         if (!has_future) {
[13:17:24.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.119]                             info)
[13:17:24.119]                         }
[13:17:24.119]                         else {
[13:17:24.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.119]                             info, version)
[13:17:24.119]                         }
[13:17:24.119]                         base::stop(msg)
[13:17:24.119]                       }
[13:17:24.119]                     })
[13:17:24.119]                   }
[13:17:24.119]                   options(future.plan = NULL)
[13:17:24.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.119]                 }
[13:17:24.119]                 ...future.workdir <- getwd()
[13:17:24.119]             }
[13:17:24.119]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.119]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.119]         }
[13:17:24.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.119]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.119]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.119]             base::names(...future.oldOptions))
[13:17:24.119]     }
[13:17:24.119]     if (FALSE) {
[13:17:24.119]     }
[13:17:24.119]     else {
[13:17:24.119]         if (TRUE) {
[13:17:24.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.119]                 open = "w")
[13:17:24.119]         }
[13:17:24.119]         else {
[13:17:24.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.119]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.119]         }
[13:17:24.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.119]             base::sink(type = "output", split = FALSE)
[13:17:24.119]             base::close(...future.stdout)
[13:17:24.119]         }, add = TRUE)
[13:17:24.119]     }
[13:17:24.119]     ...future.frame <- base::sys.nframe()
[13:17:24.119]     ...future.conditions <- base::list()
[13:17:24.119]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.119]     if (FALSE) {
[13:17:24.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.119]     }
[13:17:24.119]     ...future.result <- base::tryCatch({
[13:17:24.119]         base::withCallingHandlers({
[13:17:24.119]             ...future.value <- base::withVisible(base::local({
[13:17:24.119]                 do.call(function(...) {
[13:17:24.119]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.119]                   if (!identical(...future.globals.maxSize.org, 
[13:17:24.119]                     ...future.globals.maxSize)) {
[13:17:24.119]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.119]                     on.exit(options(oopts), add = TRUE)
[13:17:24.119]                   }
[13:17:24.119]                   {
[13:17:24.119]                     lapply(seq_along(...future.elements_ii), 
[13:17:24.119]                       FUN = function(jj) {
[13:17:24.119]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.119]                         ...future.FUN(...future.X_jj, ...)
[13:17:24.119]                       })
[13:17:24.119]                   }
[13:17:24.119]                 }, args = future.call.arguments)
[13:17:24.119]             }))
[13:17:24.119]             future::FutureResult(value = ...future.value$value, 
[13:17:24.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.119]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.119]                     ...future.globalenv.names))
[13:17:24.119]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.119]         }, condition = base::local({
[13:17:24.119]             c <- base::c
[13:17:24.119]             inherits <- base::inherits
[13:17:24.119]             invokeRestart <- base::invokeRestart
[13:17:24.119]             length <- base::length
[13:17:24.119]             list <- base::list
[13:17:24.119]             seq.int <- base::seq.int
[13:17:24.119]             signalCondition <- base::signalCondition
[13:17:24.119]             sys.calls <- base::sys.calls
[13:17:24.119]             `[[` <- base::`[[`
[13:17:24.119]             `+` <- base::`+`
[13:17:24.119]             `<<-` <- base::`<<-`
[13:17:24.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.119]                   3L)]
[13:17:24.119]             }
[13:17:24.119]             function(cond) {
[13:17:24.119]                 is_error <- inherits(cond, "error")
[13:17:24.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.119]                   NULL)
[13:17:24.119]                 if (is_error) {
[13:17:24.119]                   sessionInformation <- function() {
[13:17:24.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.119]                       search = base::search(), system = base::Sys.info())
[13:17:24.119]                   }
[13:17:24.119]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.119]                     cond$call), session = sessionInformation(), 
[13:17:24.119]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.119]                   signalCondition(cond)
[13:17:24.119]                 }
[13:17:24.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.119]                 "immediateCondition"))) {
[13:17:24.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.119]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.119]                   if (TRUE && !signal) {
[13:17:24.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.119]                     {
[13:17:24.119]                       inherits <- base::inherits
[13:17:24.119]                       invokeRestart <- base::invokeRestart
[13:17:24.119]                       is.null <- base::is.null
[13:17:24.119]                       muffled <- FALSE
[13:17:24.119]                       if (inherits(cond, "message")) {
[13:17:24.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.119]                         if (muffled) 
[13:17:24.119]                           invokeRestart("muffleMessage")
[13:17:24.119]                       }
[13:17:24.119]                       else if (inherits(cond, "warning")) {
[13:17:24.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.119]                         if (muffled) 
[13:17:24.119]                           invokeRestart("muffleWarning")
[13:17:24.119]                       }
[13:17:24.119]                       else if (inherits(cond, "condition")) {
[13:17:24.119]                         if (!is.null(pattern)) {
[13:17:24.119]                           computeRestarts <- base::computeRestarts
[13:17:24.119]                           grepl <- base::grepl
[13:17:24.119]                           restarts <- computeRestarts(cond)
[13:17:24.119]                           for (restart in restarts) {
[13:17:24.119]                             name <- restart$name
[13:17:24.119]                             if (is.null(name)) 
[13:17:24.119]                               next
[13:17:24.119]                             if (!grepl(pattern, name)) 
[13:17:24.119]                               next
[13:17:24.119]                             invokeRestart(restart)
[13:17:24.119]                             muffled <- TRUE
[13:17:24.119]                             break
[13:17:24.119]                           }
[13:17:24.119]                         }
[13:17:24.119]                       }
[13:17:24.119]                       invisible(muffled)
[13:17:24.119]                     }
[13:17:24.119]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.119]                   }
[13:17:24.119]                 }
[13:17:24.119]                 else {
[13:17:24.119]                   if (TRUE) {
[13:17:24.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.119]                     {
[13:17:24.119]                       inherits <- base::inherits
[13:17:24.119]                       invokeRestart <- base::invokeRestart
[13:17:24.119]                       is.null <- base::is.null
[13:17:24.119]                       muffled <- FALSE
[13:17:24.119]                       if (inherits(cond, "message")) {
[13:17:24.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.119]                         if (muffled) 
[13:17:24.119]                           invokeRestart("muffleMessage")
[13:17:24.119]                       }
[13:17:24.119]                       else if (inherits(cond, "warning")) {
[13:17:24.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.119]                         if (muffled) 
[13:17:24.119]                           invokeRestart("muffleWarning")
[13:17:24.119]                       }
[13:17:24.119]                       else if (inherits(cond, "condition")) {
[13:17:24.119]                         if (!is.null(pattern)) {
[13:17:24.119]                           computeRestarts <- base::computeRestarts
[13:17:24.119]                           grepl <- base::grepl
[13:17:24.119]                           restarts <- computeRestarts(cond)
[13:17:24.119]                           for (restart in restarts) {
[13:17:24.119]                             name <- restart$name
[13:17:24.119]                             if (is.null(name)) 
[13:17:24.119]                               next
[13:17:24.119]                             if (!grepl(pattern, name)) 
[13:17:24.119]                               next
[13:17:24.119]                             invokeRestart(restart)
[13:17:24.119]                             muffled <- TRUE
[13:17:24.119]                             break
[13:17:24.119]                           }
[13:17:24.119]                         }
[13:17:24.119]                       }
[13:17:24.119]                       invisible(muffled)
[13:17:24.119]                     }
[13:17:24.119]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.119]                   }
[13:17:24.119]                 }
[13:17:24.119]             }
[13:17:24.119]         }))
[13:17:24.119]     }, error = function(ex) {
[13:17:24.119]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.119]                 ...future.rng), started = ...future.startTime, 
[13:17:24.119]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.119]             version = "1.8"), class = "FutureResult")
[13:17:24.119]     }, finally = {
[13:17:24.119]         if (!identical(...future.workdir, getwd())) 
[13:17:24.119]             setwd(...future.workdir)
[13:17:24.119]         {
[13:17:24.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.119]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.119]             }
[13:17:24.119]             base::options(...future.oldOptions)
[13:17:24.119]             if (.Platform$OS.type == "windows") {
[13:17:24.119]                 old_names <- names(...future.oldEnvVars)
[13:17:24.119]                 envs <- base::Sys.getenv()
[13:17:24.119]                 names <- names(envs)
[13:17:24.119]                 common <- intersect(names, old_names)
[13:17:24.119]                 added <- setdiff(names, old_names)
[13:17:24.119]                 removed <- setdiff(old_names, names)
[13:17:24.119]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.119]                   envs[common]]
[13:17:24.119]                 NAMES <- toupper(changed)
[13:17:24.119]                 args <- list()
[13:17:24.119]                 for (kk in seq_along(NAMES)) {
[13:17:24.119]                   name <- changed[[kk]]
[13:17:24.119]                   NAME <- NAMES[[kk]]
[13:17:24.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.119]                     next
[13:17:24.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.119]                 }
[13:17:24.119]                 NAMES <- toupper(added)
[13:17:24.119]                 for (kk in seq_along(NAMES)) {
[13:17:24.119]                   name <- added[[kk]]
[13:17:24.119]                   NAME <- NAMES[[kk]]
[13:17:24.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.119]                     next
[13:17:24.119]                   args[[name]] <- ""
[13:17:24.119]                 }
[13:17:24.119]                 NAMES <- toupper(removed)
[13:17:24.119]                 for (kk in seq_along(NAMES)) {
[13:17:24.119]                   name <- removed[[kk]]
[13:17:24.119]                   NAME <- NAMES[[kk]]
[13:17:24.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.119]                     next
[13:17:24.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.119]                 }
[13:17:24.119]                 if (length(args) > 0) 
[13:17:24.119]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.119]             }
[13:17:24.119]             else {
[13:17:24.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.119]             }
[13:17:24.119]             {
[13:17:24.119]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.119]                   0L) {
[13:17:24.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.119]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.119]                   base::options(opts)
[13:17:24.119]                 }
[13:17:24.119]                 {
[13:17:24.119]                   {
[13:17:24.119]                     NULL
[13:17:24.119]                     RNGkind("Mersenne-Twister")
[13:17:24.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:24.119]                       inherits = FALSE)
[13:17:24.119]                   }
[13:17:24.119]                   options(future.plan = NULL)
[13:17:24.119]                   if (is.na(NA_character_)) 
[13:17:24.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.119]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:24.119]                   {
[13:17:24.119]                     future <- SequentialFuture(..., envir = envir)
[13:17:24.119]                     if (!future$lazy) 
[13:17:24.119]                       future <- run(future)
[13:17:24.119]                     invisible(future)
[13:17:24.119]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.119]                 }
[13:17:24.119]             }
[13:17:24.119]         }
[13:17:24.119]     })
[13:17:24.119]     if (TRUE) {
[13:17:24.119]         base::sink(type = "output", split = FALSE)
[13:17:24.119]         if (TRUE) {
[13:17:24.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.119]         }
[13:17:24.119]         else {
[13:17:24.119]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.119]         }
[13:17:24.119]         base::close(...future.stdout)
[13:17:24.119]         ...future.stdout <- NULL
[13:17:24.119]     }
[13:17:24.119]     ...future.result$conditions <- ...future.conditions
[13:17:24.119]     ...future.result$finished <- base::Sys.time()
[13:17:24.119]     ...future.result
[13:17:24.119] }
[13:17:24.121] assign_globals() ...
[13:17:24.121] List of 5
[13:17:24.121]  $ future.call.arguments    : list()
[13:17:24.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.121]  $ ...future.FUN            :function (x)  
[13:17:24.121]  $ ...future.elements_ii    :List of 2
[13:17:24.121]   ..$ : int 1
[13:17:24.121]   ..$ : int 2
[13:17:24.121]  $ ...future.seeds_ii       : NULL
[13:17:24.121]  $ ...future.globals.maxSize: num Inf
[13:17:24.121]  - attr(*, "resolved")= logi FALSE
[13:17:24.121]  - attr(*, "total_size")= num NA
[13:17:24.121]  - attr(*, "where")=List of 5
[13:17:24.121]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.121]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.121]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.121]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.121]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.121]  - attr(*, "already-done")= logi TRUE
[13:17:24.126] - copied ‘future.call.arguments’ to environment
[13:17:24.126] - copied ‘...future.FUN’ to environment
[13:17:24.126] - copied ‘...future.elements_ii’ to environment
[13:17:24.126] - copied ‘...future.seeds_ii’ to environment
[13:17:24.126] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.126] assign_globals() ... done
[13:17:24.127] plan(): Setting new future strategy stack:
[13:17:24.127] List of future strategies:
[13:17:24.127] 1. sequential:
[13:17:24.127]    - args: function (..., envir = parent.frame())
[13:17:24.127]    - tweaked: FALSE
[13:17:24.127]    - call: NULL
[13:17:24.127] plan(): nbrOfWorkers() = 1
[13:17:24.128] plan(): Setting new future strategy stack:
[13:17:24.128] List of future strategies:
[13:17:24.128] 1. sequential:
[13:17:24.128]    - args: function (..., envir = parent.frame())
[13:17:24.128]    - tweaked: FALSE
[13:17:24.128]    - call: plan(strategy)
[13:17:24.128] plan(): nbrOfWorkers() = 1
[13:17:24.128] SequentialFuture started (and completed)
[13:17:24.129] - Launch lazy future ... done
[13:17:24.129] run() for ‘SequentialFuture’ ... done
[13:17:24.129] Created future:
[13:17:24.129] SequentialFuture:
[13:17:24.129] Label: ‘future_apply-1’
[13:17:24.129] Expression:
[13:17:24.129] {
[13:17:24.129]     do.call(function(...) {
[13:17:24.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.129]             on.exit(options(oopts), add = TRUE)
[13:17:24.129]         }
[13:17:24.129]         {
[13:17:24.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.129]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.129]             })
[13:17:24.129]         }
[13:17:24.129]     }, args = future.call.arguments)
[13:17:24.129] }
[13:17:24.129] Lazy evaluation: FALSE
[13:17:24.129] Asynchronous evaluation: FALSE
[13:17:24.129] Local evaluation: TRUE
[13:17:24.129] Environment: R_GlobalEnv
[13:17:24.129] Capture standard output: TRUE
[13:17:24.129] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.129] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.129] Packages: <none>
[13:17:24.129] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.129] Resolved: TRUE
[13:17:24.129] Value: 112 bytes of class ‘list’
[13:17:24.129] Early signaling: FALSE
[13:17:24.129] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.129] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.130] Chunk #1 of 1 ... DONE
[13:17:24.130] Launching 1 futures (chunks) ... DONE
[13:17:24.130] Resolving 1 futures (chunks) ...
[13:17:24.130] resolve() on list ...
[13:17:24.130]  recursive: 0
[13:17:24.130]  length: 1
[13:17:24.130] 
[13:17:24.131] resolved() for ‘SequentialFuture’ ...
[13:17:24.131] - state: ‘finished’
[13:17:24.131] - run: TRUE
[13:17:24.131] - result: ‘FutureResult’
[13:17:24.131] resolved() for ‘SequentialFuture’ ... done
[13:17:24.131] Future #1
[13:17:24.131] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:24.131] - nx: 1
[13:17:24.131] - relay: TRUE
[13:17:24.132] - stdout: TRUE
[13:17:24.132] - signal: TRUE
[13:17:24.132] - resignal: FALSE
[13:17:24.132] - force: TRUE
[13:17:24.132] - relayed: [n=1] FALSE
[13:17:24.132] - queued futures: [n=1] FALSE
[13:17:24.132]  - until=1
[13:17:24.132]  - relaying element #1
[13:17:24.132] - relayed: [n=1] TRUE
[13:17:24.132] - queued futures: [n=1] TRUE
[13:17:24.132] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:24.133]  length: 0 (resolved future 1)
[13:17:24.133] Relaying remaining futures
[13:17:24.133] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.133] - nx: 1
[13:17:24.133] - relay: TRUE
[13:17:24.133] - stdout: TRUE
[13:17:24.133] - signal: TRUE
[13:17:24.133] - resignal: FALSE
[13:17:24.135] - force: TRUE
[13:17:24.135] - relayed: [n=1] TRUE
[13:17:24.135] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.135] - relayed: [n=1] TRUE
[13:17:24.135] - queued futures: [n=1] TRUE
[13:17:24.135] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.135] resolve() on list ... DONE
[13:17:24.135]  - Number of value chunks collected: 1
[13:17:24.136] Resolving 1 futures (chunks) ... DONE
[13:17:24.136] Reducing values from 1 chunks ...
[13:17:24.136]  - Number of values collected after concatenation: 2
[13:17:24.136]  - Number of values expected: 2
[13:17:24.136] Reducing values from 1 chunks ... DONE
[13:17:24.136] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:17:24.136] getGlobalsAndPackagesXApply() ...
[13:17:24.136]  - future.globals: TRUE
[13:17:24.137] getGlobalsAndPackages() ...
[13:17:24.137] Searching for globals...
[13:17:24.138] - globals found: [1] ‘FUN’
[13:17:24.138] Searching for globals ... DONE
[13:17:24.138] Resolving globals: FALSE
[13:17:24.138] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:24.138] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:24.139] - globals: [1] ‘FUN’
[13:17:24.139] 
[13:17:24.139] getGlobalsAndPackages() ... DONE
[13:17:24.139]  - globals found/used: [n=1] ‘FUN’
[13:17:24.139]  - needed namespaces: [n=0] 
[13:17:24.139] Finding globals ... DONE
[13:17:24.139]  - use_args: TRUE
[13:17:24.139]  - Getting '...' globals ...
[13:17:24.139] resolve() on list ...
[13:17:24.140]  recursive: 0
[13:17:24.140]  length: 1
[13:17:24.140]  elements: ‘...’
[13:17:24.140]  length: 0 (resolved future 1)
[13:17:24.140] resolve() on list ... DONE
[13:17:24.140]    - '...' content: [n=0] 
[13:17:24.140] List of 1
[13:17:24.140]  $ ...: list()
[13:17:24.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.140]  - attr(*, "where")=List of 1
[13:17:24.140]   ..$ ...:<environment: 0x5647ba45b6f8> 
[13:17:24.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.140]  - attr(*, "resolved")= logi TRUE
[13:17:24.140]  - attr(*, "total_size")= num NA
[13:17:24.143]  - Getting '...' globals ... DONE
[13:17:24.143] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.143] List of 2
[13:17:24.143]  $ ...future.FUN:function (x)  
[13:17:24.143]  $ ...          : list()
[13:17:24.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.143]  - attr(*, "where")=List of 2
[13:17:24.143]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.143]   ..$ ...          :<environment: 0x5647ba45b6f8> 
[13:17:24.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.143]  - attr(*, "resolved")= logi FALSE
[13:17:24.143]  - attr(*, "total_size")= num 848
[13:17:24.145] Packages to be attached in all futures: [n=0] 
[13:17:24.146] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.146] future_lapply() ...
[13:17:24.146] Number of chunks: 1
[13:17:24.146] getGlobalsAndPackagesXApply() ...
[13:17:24.146]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.147]  - use_args: TRUE
[13:17:24.147] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.147] List of 2
[13:17:24.147]  $ ...          : list()
[13:17:24.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.147]  $ ...future.FUN:function (x)  
[13:17:24.147]  - attr(*, "where")=List of 2
[13:17:24.147]   ..$ ...          :<environment: 0x5647ba45b6f8> 
[13:17:24.147]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.147]  - attr(*, "resolved")= logi FALSE
[13:17:24.147]  - attr(*, "total_size")= num NA
[13:17:24.150] Packages to be attached in all futures: [n=0] 
[13:17:24.150] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.150] Number of futures (= number of chunks): 1
[13:17:24.150] Launching 1 futures (chunks) ...
[13:17:24.151] Chunk #1 of 1 ...
[13:17:24.151]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:24.151]  - seeds: <none>
[13:17:24.151] getGlobalsAndPackages() ...
[13:17:24.151] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.151] Resolving globals: FALSE
[13:17:24.151] Tweak future expression to call with '...' arguments ...
[13:17:24.151] {
[13:17:24.151]     do.call(function(...) {
[13:17:24.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.151]             on.exit(options(oopts), add = TRUE)
[13:17:24.151]         }
[13:17:24.151]         {
[13:17:24.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.151]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.151]             })
[13:17:24.151]         }
[13:17:24.151]     }, args = future.call.arguments)
[13:17:24.151] }
[13:17:24.152] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.152] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.152] 
[13:17:24.152] getGlobalsAndPackages() ... DONE
[13:17:24.152] run() for ‘Future’ ...
[13:17:24.152] - state: ‘created’
[13:17:24.153] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:24.153] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:24.153]   - Field: ‘label’
[13:17:24.153]   - Field: ‘local’
[13:17:24.153]   - Field: ‘owner’
[13:17:24.153]   - Field: ‘envir’
[13:17:24.154]   - Field: ‘packages’
[13:17:24.154]   - Field: ‘gc’
[13:17:24.154]   - Field: ‘conditions’
[13:17:24.154]   - Field: ‘expr’
[13:17:24.154]   - Field: ‘uuid’
[13:17:24.154]   - Field: ‘seed’
[13:17:24.154]   - Field: ‘version’
[13:17:24.154]   - Field: ‘result’
[13:17:24.154]   - Field: ‘asynchronous’
[13:17:24.154]   - Field: ‘calls’
[13:17:24.154]   - Field: ‘globals’
[13:17:24.155]   - Field: ‘stdout’
[13:17:24.155]   - Field: ‘earlySignal’
[13:17:24.155]   - Field: ‘lazy’
[13:17:24.155]   - Field: ‘state’
[13:17:24.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:24.155] - Launch lazy future ...
[13:17:24.155] Packages needed by the future expression (n = 0): <none>
[13:17:24.155] Packages needed by future strategies (n = 0): <none>
[13:17:24.156] {
[13:17:24.156]     {
[13:17:24.156]         {
[13:17:24.156]             ...future.startTime <- base::Sys.time()
[13:17:24.156]             {
[13:17:24.156]                 {
[13:17:24.156]                   {
[13:17:24.156]                     base::local({
[13:17:24.156]                       has_future <- base::requireNamespace("future", 
[13:17:24.156]                         quietly = TRUE)
[13:17:24.156]                       if (has_future) {
[13:17:24.156]                         ns <- base::getNamespace("future")
[13:17:24.156]                         version <- ns[[".package"]][["version"]]
[13:17:24.156]                         if (is.null(version)) 
[13:17:24.156]                           version <- utils::packageVersion("future")
[13:17:24.156]                       }
[13:17:24.156]                       else {
[13:17:24.156]                         version <- NULL
[13:17:24.156]                       }
[13:17:24.156]                       if (!has_future || version < "1.8.0") {
[13:17:24.156]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.156]                           "", base::R.version$version.string), 
[13:17:24.156]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:24.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.156]                             "release", "version")], collapse = " "), 
[13:17:24.156]                           hostname = base::Sys.info()[["nodename"]])
[13:17:24.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.156]                           info)
[13:17:24.156]                         info <- base::paste(info, collapse = "; ")
[13:17:24.156]                         if (!has_future) {
[13:17:24.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.156]                             info)
[13:17:24.156]                         }
[13:17:24.156]                         else {
[13:17:24.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.156]                             info, version)
[13:17:24.156]                         }
[13:17:24.156]                         base::stop(msg)
[13:17:24.156]                       }
[13:17:24.156]                     })
[13:17:24.156]                   }
[13:17:24.156]                   options(future.plan = NULL)
[13:17:24.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.156]                 }
[13:17:24.156]                 ...future.workdir <- getwd()
[13:17:24.156]             }
[13:17:24.156]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.156]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.156]         }
[13:17:24.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.156]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.156]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.156]             base::names(...future.oldOptions))
[13:17:24.156]     }
[13:17:24.156]     if (FALSE) {
[13:17:24.156]     }
[13:17:24.156]     else {
[13:17:24.156]         if (TRUE) {
[13:17:24.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.156]                 open = "w")
[13:17:24.156]         }
[13:17:24.156]         else {
[13:17:24.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.156]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.156]         }
[13:17:24.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.156]             base::sink(type = "output", split = FALSE)
[13:17:24.156]             base::close(...future.stdout)
[13:17:24.156]         }, add = TRUE)
[13:17:24.156]     }
[13:17:24.156]     ...future.frame <- base::sys.nframe()
[13:17:24.156]     ...future.conditions <- base::list()
[13:17:24.156]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.156]     if (FALSE) {
[13:17:24.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.156]     }
[13:17:24.156]     ...future.result <- base::tryCatch({
[13:17:24.156]         base::withCallingHandlers({
[13:17:24.156]             ...future.value <- base::withVisible(base::local({
[13:17:24.156]                 do.call(function(...) {
[13:17:24.156]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.156]                   if (!identical(...future.globals.maxSize.org, 
[13:17:24.156]                     ...future.globals.maxSize)) {
[13:17:24.156]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.156]                     on.exit(options(oopts), add = TRUE)
[13:17:24.156]                   }
[13:17:24.156]                   {
[13:17:24.156]                     lapply(seq_along(...future.elements_ii), 
[13:17:24.156]                       FUN = function(jj) {
[13:17:24.156]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.156]                         ...future.FUN(...future.X_jj, ...)
[13:17:24.156]                       })
[13:17:24.156]                   }
[13:17:24.156]                 }, args = future.call.arguments)
[13:17:24.156]             }))
[13:17:24.156]             future::FutureResult(value = ...future.value$value, 
[13:17:24.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.156]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.156]                     ...future.globalenv.names))
[13:17:24.156]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.156]         }, condition = base::local({
[13:17:24.156]             c <- base::c
[13:17:24.156]             inherits <- base::inherits
[13:17:24.156]             invokeRestart <- base::invokeRestart
[13:17:24.156]             length <- base::length
[13:17:24.156]             list <- base::list
[13:17:24.156]             seq.int <- base::seq.int
[13:17:24.156]             signalCondition <- base::signalCondition
[13:17:24.156]             sys.calls <- base::sys.calls
[13:17:24.156]             `[[` <- base::`[[`
[13:17:24.156]             `+` <- base::`+`
[13:17:24.156]             `<<-` <- base::`<<-`
[13:17:24.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.156]                   3L)]
[13:17:24.156]             }
[13:17:24.156]             function(cond) {
[13:17:24.156]                 is_error <- inherits(cond, "error")
[13:17:24.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.156]                   NULL)
[13:17:24.156]                 if (is_error) {
[13:17:24.156]                   sessionInformation <- function() {
[13:17:24.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.156]                       search = base::search(), system = base::Sys.info())
[13:17:24.156]                   }
[13:17:24.156]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.156]                     cond$call), session = sessionInformation(), 
[13:17:24.156]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.156]                   signalCondition(cond)
[13:17:24.156]                 }
[13:17:24.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.156]                 "immediateCondition"))) {
[13:17:24.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.156]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.156]                   if (TRUE && !signal) {
[13:17:24.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.156]                     {
[13:17:24.156]                       inherits <- base::inherits
[13:17:24.156]                       invokeRestart <- base::invokeRestart
[13:17:24.156]                       is.null <- base::is.null
[13:17:24.156]                       muffled <- FALSE
[13:17:24.156]                       if (inherits(cond, "message")) {
[13:17:24.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.156]                         if (muffled) 
[13:17:24.156]                           invokeRestart("muffleMessage")
[13:17:24.156]                       }
[13:17:24.156]                       else if (inherits(cond, "warning")) {
[13:17:24.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.156]                         if (muffled) 
[13:17:24.156]                           invokeRestart("muffleWarning")
[13:17:24.156]                       }
[13:17:24.156]                       else if (inherits(cond, "condition")) {
[13:17:24.156]                         if (!is.null(pattern)) {
[13:17:24.156]                           computeRestarts <- base::computeRestarts
[13:17:24.156]                           grepl <- base::grepl
[13:17:24.156]                           restarts <- computeRestarts(cond)
[13:17:24.156]                           for (restart in restarts) {
[13:17:24.156]                             name <- restart$name
[13:17:24.156]                             if (is.null(name)) 
[13:17:24.156]                               next
[13:17:24.156]                             if (!grepl(pattern, name)) 
[13:17:24.156]                               next
[13:17:24.156]                             invokeRestart(restart)
[13:17:24.156]                             muffled <- TRUE
[13:17:24.156]                             break
[13:17:24.156]                           }
[13:17:24.156]                         }
[13:17:24.156]                       }
[13:17:24.156]                       invisible(muffled)
[13:17:24.156]                     }
[13:17:24.156]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.156]                   }
[13:17:24.156]                 }
[13:17:24.156]                 else {
[13:17:24.156]                   if (TRUE) {
[13:17:24.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.156]                     {
[13:17:24.156]                       inherits <- base::inherits
[13:17:24.156]                       invokeRestart <- base::invokeRestart
[13:17:24.156]                       is.null <- base::is.null
[13:17:24.156]                       muffled <- FALSE
[13:17:24.156]                       if (inherits(cond, "message")) {
[13:17:24.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.156]                         if (muffled) 
[13:17:24.156]                           invokeRestart("muffleMessage")
[13:17:24.156]                       }
[13:17:24.156]                       else if (inherits(cond, "warning")) {
[13:17:24.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.156]                         if (muffled) 
[13:17:24.156]                           invokeRestart("muffleWarning")
[13:17:24.156]                       }
[13:17:24.156]                       else if (inherits(cond, "condition")) {
[13:17:24.156]                         if (!is.null(pattern)) {
[13:17:24.156]                           computeRestarts <- base::computeRestarts
[13:17:24.156]                           grepl <- base::grepl
[13:17:24.156]                           restarts <- computeRestarts(cond)
[13:17:24.156]                           for (restart in restarts) {
[13:17:24.156]                             name <- restart$name
[13:17:24.156]                             if (is.null(name)) 
[13:17:24.156]                               next
[13:17:24.156]                             if (!grepl(pattern, name)) 
[13:17:24.156]                               next
[13:17:24.156]                             invokeRestart(restart)
[13:17:24.156]                             muffled <- TRUE
[13:17:24.156]                             break
[13:17:24.156]                           }
[13:17:24.156]                         }
[13:17:24.156]                       }
[13:17:24.156]                       invisible(muffled)
[13:17:24.156]                     }
[13:17:24.156]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.156]                   }
[13:17:24.156]                 }
[13:17:24.156]             }
[13:17:24.156]         }))
[13:17:24.156]     }, error = function(ex) {
[13:17:24.156]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.156]                 ...future.rng), started = ...future.startTime, 
[13:17:24.156]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.156]             version = "1.8"), class = "FutureResult")
[13:17:24.156]     }, finally = {
[13:17:24.156]         if (!identical(...future.workdir, getwd())) 
[13:17:24.156]             setwd(...future.workdir)
[13:17:24.156]         {
[13:17:24.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.156]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.156]             }
[13:17:24.156]             base::options(...future.oldOptions)
[13:17:24.156]             if (.Platform$OS.type == "windows") {
[13:17:24.156]                 old_names <- names(...future.oldEnvVars)
[13:17:24.156]                 envs <- base::Sys.getenv()
[13:17:24.156]                 names <- names(envs)
[13:17:24.156]                 common <- intersect(names, old_names)
[13:17:24.156]                 added <- setdiff(names, old_names)
[13:17:24.156]                 removed <- setdiff(old_names, names)
[13:17:24.156]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.156]                   envs[common]]
[13:17:24.156]                 NAMES <- toupper(changed)
[13:17:24.156]                 args <- list()
[13:17:24.156]                 for (kk in seq_along(NAMES)) {
[13:17:24.156]                   name <- changed[[kk]]
[13:17:24.156]                   NAME <- NAMES[[kk]]
[13:17:24.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.156]                     next
[13:17:24.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.156]                 }
[13:17:24.156]                 NAMES <- toupper(added)
[13:17:24.156]                 for (kk in seq_along(NAMES)) {
[13:17:24.156]                   name <- added[[kk]]
[13:17:24.156]                   NAME <- NAMES[[kk]]
[13:17:24.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.156]                     next
[13:17:24.156]                   args[[name]] <- ""
[13:17:24.156]                 }
[13:17:24.156]                 NAMES <- toupper(removed)
[13:17:24.156]                 for (kk in seq_along(NAMES)) {
[13:17:24.156]                   name <- removed[[kk]]
[13:17:24.156]                   NAME <- NAMES[[kk]]
[13:17:24.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.156]                     next
[13:17:24.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.156]                 }
[13:17:24.156]                 if (length(args) > 0) 
[13:17:24.156]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.156]             }
[13:17:24.156]             else {
[13:17:24.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.156]             }
[13:17:24.156]             {
[13:17:24.156]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.156]                   0L) {
[13:17:24.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.156]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.156]                   base::options(opts)
[13:17:24.156]                 }
[13:17:24.156]                 {
[13:17:24.156]                   {
[13:17:24.156]                     NULL
[13:17:24.156]                     RNGkind("Mersenne-Twister")
[13:17:24.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:24.156]                       inherits = FALSE)
[13:17:24.156]                   }
[13:17:24.156]                   options(future.plan = NULL)
[13:17:24.156]                   if (is.na(NA_character_)) 
[13:17:24.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.156]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:24.156]                   {
[13:17:24.156]                     future <- SequentialFuture(..., envir = envir)
[13:17:24.156]                     if (!future$lazy) 
[13:17:24.156]                       future <- run(future)
[13:17:24.156]                     invisible(future)
[13:17:24.156]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.156]                 }
[13:17:24.156]             }
[13:17:24.156]         }
[13:17:24.156]     })
[13:17:24.156]     if (TRUE) {
[13:17:24.156]         base::sink(type = "output", split = FALSE)
[13:17:24.156]         if (TRUE) {
[13:17:24.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.156]         }
[13:17:24.156]         else {
[13:17:24.156]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.156]         }
[13:17:24.156]         base::close(...future.stdout)
[13:17:24.156]         ...future.stdout <- NULL
[13:17:24.156]     }
[13:17:24.156]     ...future.result$conditions <- ...future.conditions
[13:17:24.156]     ...future.result$finished <- base::Sys.time()
[13:17:24.156]     ...future.result
[13:17:24.156] }
[13:17:24.157] assign_globals() ...
[13:17:24.157] List of 5
[13:17:24.157]  $ future.call.arguments    : list()
[13:17:24.157]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.157]  $ ...future.FUN            :function (x)  
[13:17:24.157]  $ ...future.elements_ii    :List of 2
[13:17:24.157]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[13:17:24.157]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[13:17:24.157]  $ ...future.seeds_ii       : NULL
[13:17:24.157]  $ ...future.globals.maxSize: num Inf
[13:17:24.157]  - attr(*, "resolved")= logi FALSE
[13:17:24.157]  - attr(*, "total_size")= num NA
[13:17:24.157]  - attr(*, "where")=List of 5
[13:17:24.157]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.157]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.157]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.157]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.157]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.157]  - attr(*, "already-done")= logi TRUE
[13:17:24.164] - copied ‘future.call.arguments’ to environment
[13:17:24.164] - copied ‘...future.FUN’ to environment
[13:17:24.164] - copied ‘...future.elements_ii’ to environment
[13:17:24.164] - copied ‘...future.seeds_ii’ to environment
[13:17:24.164] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.164] assign_globals() ... done
[13:17:24.165] plan(): Setting new future strategy stack:
[13:17:24.165] List of future strategies:
[13:17:24.165] 1. sequential:
[13:17:24.165]    - args: function (..., envir = parent.frame())
[13:17:24.165]    - tweaked: FALSE
[13:17:24.165]    - call: NULL
[13:17:24.165] plan(): nbrOfWorkers() = 1
[13:17:24.166] plan(): Setting new future strategy stack:
[13:17:24.166] List of future strategies:
[13:17:24.166] 1. sequential:
[13:17:24.166]    - args: function (..., envir = parent.frame())
[13:17:24.166]    - tweaked: FALSE
[13:17:24.166]    - call: plan(strategy)
[13:17:24.166] plan(): nbrOfWorkers() = 1
[13:17:24.166] SequentialFuture started (and completed)
[13:17:24.166] - Launch lazy future ... done
[13:17:24.167] run() for ‘SequentialFuture’ ... done
[13:17:24.167] Created future:
[13:17:24.167] SequentialFuture:
[13:17:24.167] Label: ‘future_apply-1’
[13:17:24.167] Expression:
[13:17:24.167] {
[13:17:24.167]     do.call(function(...) {
[13:17:24.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.167]             on.exit(options(oopts), add = TRUE)
[13:17:24.167]         }
[13:17:24.167]         {
[13:17:24.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.167]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.167]             })
[13:17:24.167]         }
[13:17:24.167]     }, args = future.call.arguments)
[13:17:24.167] }
[13:17:24.167] Lazy evaluation: FALSE
[13:17:24.167] Asynchronous evaluation: FALSE
[13:17:24.167] Local evaluation: TRUE
[13:17:24.167] Environment: R_GlobalEnv
[13:17:24.167] Capture standard output: TRUE
[13:17:24.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.167] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.167] Packages: <none>
[13:17:24.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.167] Resolved: TRUE
[13:17:24.167] Value: 496 bytes of class ‘list’
[13:17:24.167] Early signaling: FALSE
[13:17:24.167] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.167] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.168] Chunk #1 of 1 ... DONE
[13:17:24.168] Launching 1 futures (chunks) ... DONE
[13:17:24.168] Resolving 1 futures (chunks) ...
[13:17:24.168] resolve() on list ...
[13:17:24.168]  recursive: 0
[13:17:24.168]  length: 1
[13:17:24.168] 
[13:17:24.168] resolved() for ‘SequentialFuture’ ...
[13:17:24.168] - state: ‘finished’
[13:17:24.169] - run: TRUE
[13:17:24.169] - result: ‘FutureResult’
[13:17:24.169] resolved() for ‘SequentialFuture’ ... done
[13:17:24.169] Future #1
[13:17:24.169] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:24.169] - nx: 1
[13:17:24.169] - relay: TRUE
[13:17:24.169] - stdout: TRUE
[13:17:24.169] - signal: TRUE
[13:17:24.169] - resignal: FALSE
[13:17:24.170] - force: TRUE
[13:17:24.170] - relayed: [n=1] FALSE
[13:17:24.170] - queued futures: [n=1] FALSE
[13:17:24.170]  - until=1
[13:17:24.170]  - relaying element #1
[13:17:24.170] - relayed: [n=1] TRUE
[13:17:24.170] - queued futures: [n=1] TRUE
[13:17:24.170] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:24.170]  length: 0 (resolved future 1)
[13:17:24.170] Relaying remaining futures
[13:17:24.171] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.171] - nx: 1
[13:17:24.171] - relay: TRUE
[13:17:24.171] - stdout: TRUE
[13:17:24.171] - signal: TRUE
[13:17:24.171] - resignal: FALSE
[13:17:24.171] - force: TRUE
[13:17:24.171] - relayed: [n=1] TRUE
[13:17:24.171] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.171] - relayed: [n=1] TRUE
[13:17:24.171] - queued futures: [n=1] TRUE
[13:17:24.171] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.172] resolve() on list ... DONE
[13:17:24.172]  - Number of value chunks collected: 1
[13:17:24.172] Resolving 1 futures (chunks) ... DONE
[13:17:24.172] Reducing values from 1 chunks ...
[13:17:24.172]  - Number of values collected after concatenation: 2
[13:17:24.172]  - Number of values expected: 2
[13:17:24.172] Reducing values from 1 chunks ... DONE
[13:17:24.172] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:17:24.173] getGlobalsAndPackagesXApply() ...
[13:17:24.173]  - future.globals: TRUE
[13:17:24.173] getGlobalsAndPackages() ...
[13:17:24.173] Searching for globals...
[13:17:24.175] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:17:24.175] Searching for globals ... DONE
[13:17:24.175] Resolving globals: FALSE
[13:17:24.176] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:17:24.176] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:17:24.176] - globals: [1] ‘FUN’
[13:17:24.176] 
[13:17:24.177] getGlobalsAndPackages() ... DONE
[13:17:24.177]  - globals found/used: [n=1] ‘FUN’
[13:17:24.177]  - needed namespaces: [n=0] 
[13:17:24.177] Finding globals ... DONE
[13:17:24.177]  - use_args: TRUE
[13:17:24.177]  - Getting '...' globals ...
[13:17:24.177] resolve() on list ...
[13:17:24.177]  recursive: 0
[13:17:24.177]  length: 1
[13:17:24.178]  elements: ‘...’
[13:17:24.178]  length: 0 (resolved future 1)
[13:17:24.178] resolve() on list ... DONE
[13:17:24.178]    - '...' content: [n=0] 
[13:17:24.178] List of 1
[13:17:24.178]  $ ...: list()
[13:17:24.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.178]  - attr(*, "where")=List of 1
[13:17:24.178]   ..$ ...:<environment: 0x5647babd1538> 
[13:17:24.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.178]  - attr(*, "resolved")= logi TRUE
[13:17:24.178]  - attr(*, "total_size")= num NA
[13:17:24.181]  - Getting '...' globals ... DONE
[13:17:24.181] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.181] List of 2
[13:17:24.181]  $ ...future.FUN:function (x)  
[13:17:24.181]  $ ...          : list()
[13:17:24.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.181]  - attr(*, "where")=List of 2
[13:17:24.181]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.181]   ..$ ...          :<environment: 0x5647babd1538> 
[13:17:24.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.181]  - attr(*, "resolved")= logi FALSE
[13:17:24.181]  - attr(*, "total_size")= num 9888
[13:17:24.184] Packages to be attached in all futures: [n=0] 
[13:17:24.184] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.184] future_lapply() ...
[13:17:24.186] Number of chunks: 1
[13:17:24.186] getGlobalsAndPackagesXApply() ...
[13:17:24.186]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.186]  - use_args: TRUE
[13:17:24.186] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.186] List of 2
[13:17:24.186]  $ ...          : list()
[13:17:24.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.186]  $ ...future.FUN:function (x)  
[13:17:24.186]  - attr(*, "where")=List of 2
[13:17:24.186]   ..$ ...          :<environment: 0x5647babd1538> 
[13:17:24.186]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:17:24.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.186]  - attr(*, "resolved")= logi FALSE
[13:17:24.186]  - attr(*, "total_size")= num NA
[13:17:24.189] Packages to be attached in all futures: [n=0] 
[13:17:24.189] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.189] Number of futures (= number of chunks): 1
[13:17:24.189] Launching 1 futures (chunks) ...
[13:17:24.189] Chunk #1 of 1 ...
[13:17:24.190]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:24.190]  - seeds: <none>
[13:17:24.190] getGlobalsAndPackages() ...
[13:17:24.190] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.190] Resolving globals: FALSE
[13:17:24.190] Tweak future expression to call with '...' arguments ...
[13:17:24.190] {
[13:17:24.190]     do.call(function(...) {
[13:17:24.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.190]             on.exit(options(oopts), add = TRUE)
[13:17:24.190]         }
[13:17:24.190]         {
[13:17:24.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.190]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.190]             })
[13:17:24.190]         }
[13:17:24.190]     }, args = future.call.arguments)
[13:17:24.190] }
[13:17:24.190] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.191] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.191] 
[13:17:24.191] getGlobalsAndPackages() ... DONE
[13:17:24.191] run() for ‘Future’ ...
[13:17:24.191] - state: ‘created’
[13:17:24.191] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:24.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:24.192]   - Field: ‘label’
[13:17:24.192]   - Field: ‘local’
[13:17:24.192]   - Field: ‘owner’
[13:17:24.192]   - Field: ‘envir’
[13:17:24.192]   - Field: ‘packages’
[13:17:24.192]   - Field: ‘gc’
[13:17:24.192]   - Field: ‘conditions’
[13:17:24.193]   - Field: ‘expr’
[13:17:24.193]   - Field: ‘uuid’
[13:17:24.193]   - Field: ‘seed’
[13:17:24.193]   - Field: ‘version’
[13:17:24.193]   - Field: ‘result’
[13:17:24.193]   - Field: ‘asynchronous’
[13:17:24.193]   - Field: ‘calls’
[13:17:24.193]   - Field: ‘globals’
[13:17:24.193]   - Field: ‘stdout’
[13:17:24.193]   - Field: ‘earlySignal’
[13:17:24.193]   - Field: ‘lazy’
[13:17:24.194]   - Field: ‘state’
[13:17:24.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:24.194] - Launch lazy future ...
[13:17:24.194] Packages needed by the future expression (n = 0): <none>
[13:17:24.194] Packages needed by future strategies (n = 0): <none>
[13:17:24.194] {
[13:17:24.194]     {
[13:17:24.194]         {
[13:17:24.194]             ...future.startTime <- base::Sys.time()
[13:17:24.194]             {
[13:17:24.194]                 {
[13:17:24.194]                   {
[13:17:24.194]                     base::local({
[13:17:24.194]                       has_future <- base::requireNamespace("future", 
[13:17:24.194]                         quietly = TRUE)
[13:17:24.194]                       if (has_future) {
[13:17:24.194]                         ns <- base::getNamespace("future")
[13:17:24.194]                         version <- ns[[".package"]][["version"]]
[13:17:24.194]                         if (is.null(version)) 
[13:17:24.194]                           version <- utils::packageVersion("future")
[13:17:24.194]                       }
[13:17:24.194]                       else {
[13:17:24.194]                         version <- NULL
[13:17:24.194]                       }
[13:17:24.194]                       if (!has_future || version < "1.8.0") {
[13:17:24.194]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.194]                           "", base::R.version$version.string), 
[13:17:24.194]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:24.194]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.194]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.194]                             "release", "version")], collapse = " "), 
[13:17:24.194]                           hostname = base::Sys.info()[["nodename"]])
[13:17:24.194]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.194]                           info)
[13:17:24.194]                         info <- base::paste(info, collapse = "; ")
[13:17:24.194]                         if (!has_future) {
[13:17:24.194]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.194]                             info)
[13:17:24.194]                         }
[13:17:24.194]                         else {
[13:17:24.194]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.194]                             info, version)
[13:17:24.194]                         }
[13:17:24.194]                         base::stop(msg)
[13:17:24.194]                       }
[13:17:24.194]                     })
[13:17:24.194]                   }
[13:17:24.194]                   options(future.plan = NULL)
[13:17:24.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.194]                 }
[13:17:24.194]                 ...future.workdir <- getwd()
[13:17:24.194]             }
[13:17:24.194]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.194]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.194]         }
[13:17:24.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.194]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.194]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.194]             base::names(...future.oldOptions))
[13:17:24.194]     }
[13:17:24.194]     if (FALSE) {
[13:17:24.194]     }
[13:17:24.194]     else {
[13:17:24.194]         if (TRUE) {
[13:17:24.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.194]                 open = "w")
[13:17:24.194]         }
[13:17:24.194]         else {
[13:17:24.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.194]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.194]         }
[13:17:24.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.194]             base::sink(type = "output", split = FALSE)
[13:17:24.194]             base::close(...future.stdout)
[13:17:24.194]         }, add = TRUE)
[13:17:24.194]     }
[13:17:24.194]     ...future.frame <- base::sys.nframe()
[13:17:24.194]     ...future.conditions <- base::list()
[13:17:24.194]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.194]     if (FALSE) {
[13:17:24.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.194]     }
[13:17:24.194]     ...future.result <- base::tryCatch({
[13:17:24.194]         base::withCallingHandlers({
[13:17:24.194]             ...future.value <- base::withVisible(base::local({
[13:17:24.194]                 do.call(function(...) {
[13:17:24.194]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.194]                   if (!identical(...future.globals.maxSize.org, 
[13:17:24.194]                     ...future.globals.maxSize)) {
[13:17:24.194]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.194]                     on.exit(options(oopts), add = TRUE)
[13:17:24.194]                   }
[13:17:24.194]                   {
[13:17:24.194]                     lapply(seq_along(...future.elements_ii), 
[13:17:24.194]                       FUN = function(jj) {
[13:17:24.194]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.194]                         ...future.FUN(...future.X_jj, ...)
[13:17:24.194]                       })
[13:17:24.194]                   }
[13:17:24.194]                 }, args = future.call.arguments)
[13:17:24.194]             }))
[13:17:24.194]             future::FutureResult(value = ...future.value$value, 
[13:17:24.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.194]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.194]                     ...future.globalenv.names))
[13:17:24.194]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.194]         }, condition = base::local({
[13:17:24.194]             c <- base::c
[13:17:24.194]             inherits <- base::inherits
[13:17:24.194]             invokeRestart <- base::invokeRestart
[13:17:24.194]             length <- base::length
[13:17:24.194]             list <- base::list
[13:17:24.194]             seq.int <- base::seq.int
[13:17:24.194]             signalCondition <- base::signalCondition
[13:17:24.194]             sys.calls <- base::sys.calls
[13:17:24.194]             `[[` <- base::`[[`
[13:17:24.194]             `+` <- base::`+`
[13:17:24.194]             `<<-` <- base::`<<-`
[13:17:24.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.194]                   3L)]
[13:17:24.194]             }
[13:17:24.194]             function(cond) {
[13:17:24.194]                 is_error <- inherits(cond, "error")
[13:17:24.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.194]                   NULL)
[13:17:24.194]                 if (is_error) {
[13:17:24.194]                   sessionInformation <- function() {
[13:17:24.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.194]                       search = base::search(), system = base::Sys.info())
[13:17:24.194]                   }
[13:17:24.194]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.194]                     cond$call), session = sessionInformation(), 
[13:17:24.194]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.194]                   signalCondition(cond)
[13:17:24.194]                 }
[13:17:24.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.194]                 "immediateCondition"))) {
[13:17:24.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.194]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.194]                   if (TRUE && !signal) {
[13:17:24.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.194]                     {
[13:17:24.194]                       inherits <- base::inherits
[13:17:24.194]                       invokeRestart <- base::invokeRestart
[13:17:24.194]                       is.null <- base::is.null
[13:17:24.194]                       muffled <- FALSE
[13:17:24.194]                       if (inherits(cond, "message")) {
[13:17:24.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.194]                         if (muffled) 
[13:17:24.194]                           invokeRestart("muffleMessage")
[13:17:24.194]                       }
[13:17:24.194]                       else if (inherits(cond, "warning")) {
[13:17:24.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.194]                         if (muffled) 
[13:17:24.194]                           invokeRestart("muffleWarning")
[13:17:24.194]                       }
[13:17:24.194]                       else if (inherits(cond, "condition")) {
[13:17:24.194]                         if (!is.null(pattern)) {
[13:17:24.194]                           computeRestarts <- base::computeRestarts
[13:17:24.194]                           grepl <- base::grepl
[13:17:24.194]                           restarts <- computeRestarts(cond)
[13:17:24.194]                           for (restart in restarts) {
[13:17:24.194]                             name <- restart$name
[13:17:24.194]                             if (is.null(name)) 
[13:17:24.194]                               next
[13:17:24.194]                             if (!grepl(pattern, name)) 
[13:17:24.194]                               next
[13:17:24.194]                             invokeRestart(restart)
[13:17:24.194]                             muffled <- TRUE
[13:17:24.194]                             break
[13:17:24.194]                           }
[13:17:24.194]                         }
[13:17:24.194]                       }
[13:17:24.194]                       invisible(muffled)
[13:17:24.194]                     }
[13:17:24.194]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.194]                   }
[13:17:24.194]                 }
[13:17:24.194]                 else {
[13:17:24.194]                   if (TRUE) {
[13:17:24.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.194]                     {
[13:17:24.194]                       inherits <- base::inherits
[13:17:24.194]                       invokeRestart <- base::invokeRestart
[13:17:24.194]                       is.null <- base::is.null
[13:17:24.194]                       muffled <- FALSE
[13:17:24.194]                       if (inherits(cond, "message")) {
[13:17:24.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.194]                         if (muffled) 
[13:17:24.194]                           invokeRestart("muffleMessage")
[13:17:24.194]                       }
[13:17:24.194]                       else if (inherits(cond, "warning")) {
[13:17:24.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.194]                         if (muffled) 
[13:17:24.194]                           invokeRestart("muffleWarning")
[13:17:24.194]                       }
[13:17:24.194]                       else if (inherits(cond, "condition")) {
[13:17:24.194]                         if (!is.null(pattern)) {
[13:17:24.194]                           computeRestarts <- base::computeRestarts
[13:17:24.194]                           grepl <- base::grepl
[13:17:24.194]                           restarts <- computeRestarts(cond)
[13:17:24.194]                           for (restart in restarts) {
[13:17:24.194]                             name <- restart$name
[13:17:24.194]                             if (is.null(name)) 
[13:17:24.194]                               next
[13:17:24.194]                             if (!grepl(pattern, name)) 
[13:17:24.194]                               next
[13:17:24.194]                             invokeRestart(restart)
[13:17:24.194]                             muffled <- TRUE
[13:17:24.194]                             break
[13:17:24.194]                           }
[13:17:24.194]                         }
[13:17:24.194]                       }
[13:17:24.194]                       invisible(muffled)
[13:17:24.194]                     }
[13:17:24.194]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.194]                   }
[13:17:24.194]                 }
[13:17:24.194]             }
[13:17:24.194]         }))
[13:17:24.194]     }, error = function(ex) {
[13:17:24.194]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.194]                 ...future.rng), started = ...future.startTime, 
[13:17:24.194]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.194]             version = "1.8"), class = "FutureResult")
[13:17:24.194]     }, finally = {
[13:17:24.194]         if (!identical(...future.workdir, getwd())) 
[13:17:24.194]             setwd(...future.workdir)
[13:17:24.194]         {
[13:17:24.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.194]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.194]             }
[13:17:24.194]             base::options(...future.oldOptions)
[13:17:24.194]             if (.Platform$OS.type == "windows") {
[13:17:24.194]                 old_names <- names(...future.oldEnvVars)
[13:17:24.194]                 envs <- base::Sys.getenv()
[13:17:24.194]                 names <- names(envs)
[13:17:24.194]                 common <- intersect(names, old_names)
[13:17:24.194]                 added <- setdiff(names, old_names)
[13:17:24.194]                 removed <- setdiff(old_names, names)
[13:17:24.194]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.194]                   envs[common]]
[13:17:24.194]                 NAMES <- toupper(changed)
[13:17:24.194]                 args <- list()
[13:17:24.194]                 for (kk in seq_along(NAMES)) {
[13:17:24.194]                   name <- changed[[kk]]
[13:17:24.194]                   NAME <- NAMES[[kk]]
[13:17:24.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.194]                     next
[13:17:24.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.194]                 }
[13:17:24.194]                 NAMES <- toupper(added)
[13:17:24.194]                 for (kk in seq_along(NAMES)) {
[13:17:24.194]                   name <- added[[kk]]
[13:17:24.194]                   NAME <- NAMES[[kk]]
[13:17:24.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.194]                     next
[13:17:24.194]                   args[[name]] <- ""
[13:17:24.194]                 }
[13:17:24.194]                 NAMES <- toupper(removed)
[13:17:24.194]                 for (kk in seq_along(NAMES)) {
[13:17:24.194]                   name <- removed[[kk]]
[13:17:24.194]                   NAME <- NAMES[[kk]]
[13:17:24.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.194]                     next
[13:17:24.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.194]                 }
[13:17:24.194]                 if (length(args) > 0) 
[13:17:24.194]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.194]             }
[13:17:24.194]             else {
[13:17:24.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.194]             }
[13:17:24.194]             {
[13:17:24.194]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.194]                   0L) {
[13:17:24.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.194]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.194]                   base::options(opts)
[13:17:24.194]                 }
[13:17:24.194]                 {
[13:17:24.194]                   {
[13:17:24.194]                     NULL
[13:17:24.194]                     RNGkind("Mersenne-Twister")
[13:17:24.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:17:24.194]                       inherits = FALSE)
[13:17:24.194]                   }
[13:17:24.194]                   options(future.plan = NULL)
[13:17:24.194]                   if (is.na(NA_character_)) 
[13:17:24.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.194]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:24.194]                   {
[13:17:24.194]                     future <- SequentialFuture(..., envir = envir)
[13:17:24.194]                     if (!future$lazy) 
[13:17:24.194]                       future <- run(future)
[13:17:24.194]                     invisible(future)
[13:17:24.194]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.194]                 }
[13:17:24.194]             }
[13:17:24.194]         }
[13:17:24.194]     })
[13:17:24.194]     if (TRUE) {
[13:17:24.194]         base::sink(type = "output", split = FALSE)
[13:17:24.194]         if (TRUE) {
[13:17:24.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.194]         }
[13:17:24.194]         else {
[13:17:24.194]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.194]         }
[13:17:24.194]         base::close(...future.stdout)
[13:17:24.194]         ...future.stdout <- NULL
[13:17:24.194]     }
[13:17:24.194]     ...future.result$conditions <- ...future.conditions
[13:17:24.194]     ...future.result$finished <- base::Sys.time()
[13:17:24.194]     ...future.result
[13:17:24.194] }
[13:17:24.196] assign_globals() ...
[13:17:24.196] List of 5
[13:17:24.196]  $ future.call.arguments    : list()
[13:17:24.196]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.196]  $ ...future.FUN            :function (x)  
[13:17:24.196]  $ ...future.elements_ii    :List of 2
[13:17:24.196]   ..$ : int [1:2] 1 3
[13:17:24.196]   ..$ : int [1:2] 2 4
[13:17:24.196]  $ ...future.seeds_ii       : NULL
[13:17:24.196]  $ ...future.globals.maxSize: num Inf
[13:17:24.196]  - attr(*, "resolved")= logi FALSE
[13:17:24.196]  - attr(*, "total_size")= num NA
[13:17:24.196]  - attr(*, "where")=List of 5
[13:17:24.196]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.196]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.196]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.196]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.196]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.196]  - attr(*, "already-done")= logi TRUE
[13:17:24.201] - copied ‘future.call.arguments’ to environment
[13:17:24.201] - reassign environment for ‘...future.FUN’
[13:17:24.201] - copied ‘...future.FUN’ to environment
[13:17:24.201] - copied ‘...future.elements_ii’ to environment
[13:17:24.201] - copied ‘...future.seeds_ii’ to environment
[13:17:24.202] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.202] assign_globals() ... done
[13:17:24.202] plan(): Setting new future strategy stack:
[13:17:24.202] List of future strategies:
[13:17:24.202] 1. sequential:
[13:17:24.202]    - args: function (..., envir = parent.frame())
[13:17:24.202]    - tweaked: FALSE
[13:17:24.202]    - call: NULL
[13:17:24.203] plan(): nbrOfWorkers() = 1
[13:17:24.204] plan(): Setting new future strategy stack:
[13:17:24.204] List of future strategies:
[13:17:24.204] 1. sequential:
[13:17:24.204]    - args: function (..., envir = parent.frame())
[13:17:24.204]    - tweaked: FALSE
[13:17:24.204]    - call: plan(strategy)
[13:17:24.205] plan(): nbrOfWorkers() = 1
[13:17:24.205] SequentialFuture started (and completed)
[13:17:24.205] - Launch lazy future ... done
[13:17:24.205] run() for ‘SequentialFuture’ ... done
[13:17:24.205] Created future:
[13:17:24.205] SequentialFuture:
[13:17:24.205] Label: ‘future_apply-1’
[13:17:24.205] Expression:
[13:17:24.205] {
[13:17:24.205]     do.call(function(...) {
[13:17:24.205]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.205]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.205]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.205]             on.exit(options(oopts), add = TRUE)
[13:17:24.205]         }
[13:17:24.205]         {
[13:17:24.205]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.205]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.205]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.205]             })
[13:17:24.205]         }
[13:17:24.205]     }, args = future.call.arguments)
[13:17:24.205] }
[13:17:24.205] Lazy evaluation: FALSE
[13:17:24.205] Asynchronous evaluation: FALSE
[13:17:24.205] Local evaluation: TRUE
[13:17:24.205] Environment: R_GlobalEnv
[13:17:24.205] Capture standard output: TRUE
[13:17:24.205] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.205] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.205] Packages: <none>
[13:17:24.205] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.205] Resolved: TRUE
[13:17:24.205] Value: 400 bytes of class ‘list’
[13:17:24.205] Early signaling: FALSE
[13:17:24.205] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.205] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.206] Chunk #1 of 1 ... DONE
[13:17:24.206] Launching 1 futures (chunks) ... DONE
[13:17:24.206] Resolving 1 futures (chunks) ...
[13:17:24.207] resolve() on list ...
[13:17:24.207]  recursive: 0
[13:17:24.207]  length: 1
[13:17:24.207] 
[13:17:24.207] resolved() for ‘SequentialFuture’ ...
[13:17:24.207] - state: ‘finished’
[13:17:24.207] - run: TRUE
[13:17:24.207] - result: ‘FutureResult’
[13:17:24.207] resolved() for ‘SequentialFuture’ ... done
[13:17:24.207] Future #1
[13:17:24.208] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:24.208] - nx: 1
[13:17:24.208] - relay: TRUE
[13:17:24.208] - stdout: TRUE
[13:17:24.208] - signal: TRUE
[13:17:24.208] - resignal: FALSE
[13:17:24.208] - force: TRUE
[13:17:24.208] - relayed: [n=1] FALSE
[13:17:24.208] - queued futures: [n=1] FALSE
[13:17:24.208]  - until=1
[13:17:24.208]  - relaying element #1
[13:17:24.209] - relayed: [n=1] TRUE
[13:17:24.209] - queued futures: [n=1] TRUE
[13:17:24.209] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:24.209]  length: 0 (resolved future 1)
[13:17:24.209] Relaying remaining futures
[13:17:24.209] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.209] - nx: 1
[13:17:24.209] - relay: TRUE
[13:17:24.209] - stdout: TRUE
[13:17:24.209] - signal: TRUE
[13:17:24.210] - resignal: FALSE
[13:17:24.210] - force: TRUE
[13:17:24.210] - relayed: [n=1] TRUE
[13:17:24.210] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.210] - relayed: [n=1] TRUE
[13:17:24.210] - queued futures: [n=1] TRUE
[13:17:24.210] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.210] resolve() on list ... DONE
[13:17:24.210]  - Number of value chunks collected: 1
[13:17:24.210] Resolving 1 futures (chunks) ... DONE
[13:17:24.211] Reducing values from 1 chunks ...
[13:17:24.211]  - Number of values collected after concatenation: 2
[13:17:24.211]  - Number of values expected: 2
[13:17:24.211] Reducing values from 1 chunks ... DONE
[13:17:24.211] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:17:24.211] getGlobalsAndPackagesXApply() ...
[13:17:24.211]  - future.globals: TRUE
[13:17:24.211] getGlobalsAndPackages() ...
[13:17:24.211] Searching for globals...
[13:17:24.214] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:17:24.214] Searching for globals ... DONE
[13:17:24.214] Resolving globals: FALSE
[13:17:24.215] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:17:24.215] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:17:24.215] - globals: [1] ‘FUN’
[13:17:24.216] 
[13:17:24.216] getGlobalsAndPackages() ... DONE
[13:17:24.216]  - globals found/used: [n=1] ‘FUN’
[13:17:24.216]  - needed namespaces: [n=0] 
[13:17:24.216] Finding globals ... DONE
[13:17:24.216]  - use_args: TRUE
[13:17:24.216]  - Getting '...' globals ...
[13:17:24.216] resolve() on list ...
[13:17:24.216]  recursive: 0
[13:17:24.217]  length: 1
[13:17:24.217]  elements: ‘...’
[13:17:24.217]  length: 0 (resolved future 1)
[13:17:24.217] resolve() on list ... DONE
[13:17:24.217]    - '...' content: [n=0] 
[13:17:24.217] List of 1
[13:17:24.217]  $ ...: list()
[13:17:24.217]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.217]  - attr(*, "where")=List of 1
[13:17:24.217]   ..$ ...:<environment: 0x5647b8c903c0> 
[13:17:24.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.217]  - attr(*, "resolved")= logi TRUE
[13:17:24.217]  - attr(*, "total_size")= num NA
[13:17:24.219]  - Getting '...' globals ... DONE
[13:17:24.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.220] List of 2
[13:17:24.220]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:17:24.220]  $ ...          : list()
[13:17:24.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.220]  - attr(*, "where")=List of 2
[13:17:24.220]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.220]   ..$ ...          :<environment: 0x5647b8c903c0> 
[13:17:24.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.220]  - attr(*, "resolved")= logi FALSE
[13:17:24.220]  - attr(*, "total_size")= num 36296
[13:17:24.222] Packages to be attached in all futures: [n=0] 
[13:17:24.222] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.223] future_lapply() ...
[13:17:24.226] Generating random seeds ...
[13:17:24.226] Generating random seed streams for 2 elements ...
[13:17:24.226] Generating random seed streams for 2 elements ... DONE
[13:17:24.226] Generating random seeds ... DONE
[13:17:24.226] Will set RNG state on exit: 10407, 1487216257, -274646202, 814490448, 1519327308, -1160950582, 1304759412
[13:17:24.227] Number of chunks: 1
[13:17:24.227] getGlobalsAndPackagesXApply() ...
[13:17:24.227]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.227]  - use_args: TRUE
[13:17:24.227] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.227] List of 2
[13:17:24.227]  $ ...          : list()
[13:17:24.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.227]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:17:24.227]  - attr(*, "where")=List of 2
[13:17:24.227]   ..$ ...          :<environment: 0x5647b8c903c0> 
[13:17:24.227]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.227]  - attr(*, "resolved")= logi FALSE
[13:17:24.227]  - attr(*, "total_size")= num NA
[13:17:24.230] Packages to be attached in all futures: [n=0] 
[13:17:24.230] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.231] Number of futures (= number of chunks): 1
[13:17:24.231] Launching 1 futures (chunks) ...
[13:17:24.231] Chunk #1 of 1 ...
[13:17:24.231]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[13:17:24.231]  - seeds: [2] <seeds>
[13:17:24.231] getGlobalsAndPackages() ...
[13:17:24.231] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.231] Resolving globals: FALSE
[13:17:24.231] Tweak future expression to call with '...' arguments ...
[13:17:24.232] {
[13:17:24.232]     do.call(function(...) {
[13:17:24.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.232]             on.exit(options(oopts), add = TRUE)
[13:17:24.232]         }
[13:17:24.232]         {
[13:17:24.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.232]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:24.232]                   envir = globalenv(), inherits = FALSE)
[13:17:24.232]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.232]             })
[13:17:24.232]         }
[13:17:24.232]     }, args = future.call.arguments)
[13:17:24.232] }
[13:17:24.232] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.232] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.232] 
[13:17:24.232] getGlobalsAndPackages() ... DONE
[13:17:24.233] run() for ‘Future’ ...
[13:17:24.233] - state: ‘created’
[13:17:24.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:17:24.233] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.233] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:17:24.233]   - Field: ‘label’
[13:17:24.233]   - Field: ‘local’
[13:17:24.234]   - Field: ‘owner’
[13:17:24.234]   - Field: ‘envir’
[13:17:24.234]   - Field: ‘packages’
[13:17:24.234]   - Field: ‘gc’
[13:17:24.234]   - Field: ‘conditions’
[13:17:24.234]   - Field: ‘expr’
[13:17:24.234]   - Field: ‘uuid’
[13:17:24.234]   - Field: ‘seed’
[13:17:24.234]   - Field: ‘version’
[13:17:24.234]   - Field: ‘result’
[13:17:24.234]   - Field: ‘asynchronous’
[13:17:24.235]   - Field: ‘calls’
[13:17:24.235]   - Field: ‘globals’
[13:17:24.235]   - Field: ‘stdout’
[13:17:24.235]   - Field: ‘earlySignal’
[13:17:24.235]   - Field: ‘lazy’
[13:17:24.235]   - Field: ‘state’
[13:17:24.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:17:24.235] - Launch lazy future ...
[13:17:24.235] Packages needed by the future expression (n = 0): <none>
[13:17:24.235] Packages needed by future strategies (n = 0): <none>
[13:17:24.236] {
[13:17:24.236]     {
[13:17:24.236]         {
[13:17:24.236]             ...future.startTime <- base::Sys.time()
[13:17:24.236]             {
[13:17:24.236]                 {
[13:17:24.236]                   {
[13:17:24.236]                     base::local({
[13:17:24.236]                       has_future <- base::requireNamespace("future", 
[13:17:24.236]                         quietly = TRUE)
[13:17:24.236]                       if (has_future) {
[13:17:24.236]                         ns <- base::getNamespace("future")
[13:17:24.236]                         version <- ns[[".package"]][["version"]]
[13:17:24.236]                         if (is.null(version)) 
[13:17:24.236]                           version <- utils::packageVersion("future")
[13:17:24.236]                       }
[13:17:24.236]                       else {
[13:17:24.236]                         version <- NULL
[13:17:24.236]                       }
[13:17:24.236]                       if (!has_future || version < "1.8.0") {
[13:17:24.236]                         info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.236]                           "", base::R.version$version.string), 
[13:17:24.236]                           platform = base::sprintf("%s (%s-bit)", 
[13:17:24.236]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.236]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.236]                             "release", "version")], collapse = " "), 
[13:17:24.236]                           hostname = base::Sys.info()[["nodename"]])
[13:17:24.236]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.236]                           info)
[13:17:24.236]                         info <- base::paste(info, collapse = "; ")
[13:17:24.236]                         if (!has_future) {
[13:17:24.236]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.236]                             info)
[13:17:24.236]                         }
[13:17:24.236]                         else {
[13:17:24.236]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.236]                             info, version)
[13:17:24.236]                         }
[13:17:24.236]                         base::stop(msg)
[13:17:24.236]                       }
[13:17:24.236]                     })
[13:17:24.236]                   }
[13:17:24.236]                   options(future.plan = NULL)
[13:17:24.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.236]                 }
[13:17:24.236]                 ...future.workdir <- getwd()
[13:17:24.236]             }
[13:17:24.236]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.236]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.236]         }
[13:17:24.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.236]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.236]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.236]             base::names(...future.oldOptions))
[13:17:24.236]     }
[13:17:24.236]     if (FALSE) {
[13:17:24.236]     }
[13:17:24.236]     else {
[13:17:24.236]         if (TRUE) {
[13:17:24.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.236]                 open = "w")
[13:17:24.236]         }
[13:17:24.236]         else {
[13:17:24.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.236]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.236]         }
[13:17:24.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.236]             base::sink(type = "output", split = FALSE)
[13:17:24.236]             base::close(...future.stdout)
[13:17:24.236]         }, add = TRUE)
[13:17:24.236]     }
[13:17:24.236]     ...future.frame <- base::sys.nframe()
[13:17:24.236]     ...future.conditions <- base::list()
[13:17:24.236]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.236]     if (FALSE) {
[13:17:24.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.236]     }
[13:17:24.236]     ...future.result <- base::tryCatch({
[13:17:24.236]         base::withCallingHandlers({
[13:17:24.236]             ...future.value <- base::withVisible(base::local({
[13:17:24.236]                 do.call(function(...) {
[13:17:24.236]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.236]                   if (!identical(...future.globals.maxSize.org, 
[13:17:24.236]                     ...future.globals.maxSize)) {
[13:17:24.236]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.236]                     on.exit(options(oopts), add = TRUE)
[13:17:24.236]                   }
[13:17:24.236]                   {
[13:17:24.236]                     lapply(seq_along(...future.elements_ii), 
[13:17:24.236]                       FUN = function(jj) {
[13:17:24.236]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.236]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:24.236]                           envir = globalenv(), inherits = FALSE)
[13:17:24.236]                         ...future.FUN(...future.X_jj, ...)
[13:17:24.236]                       })
[13:17:24.236]                   }
[13:17:24.236]                 }, args = future.call.arguments)
[13:17:24.236]             }))
[13:17:24.236]             future::FutureResult(value = ...future.value$value, 
[13:17:24.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.236]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.236]                     ...future.globalenv.names))
[13:17:24.236]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.236]         }, condition = base::local({
[13:17:24.236]             c <- base::c
[13:17:24.236]             inherits <- base::inherits
[13:17:24.236]             invokeRestart <- base::invokeRestart
[13:17:24.236]             length <- base::length
[13:17:24.236]             list <- base::list
[13:17:24.236]             seq.int <- base::seq.int
[13:17:24.236]             signalCondition <- base::signalCondition
[13:17:24.236]             sys.calls <- base::sys.calls
[13:17:24.236]             `[[` <- base::`[[`
[13:17:24.236]             `+` <- base::`+`
[13:17:24.236]             `<<-` <- base::`<<-`
[13:17:24.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.236]                   3L)]
[13:17:24.236]             }
[13:17:24.236]             function(cond) {
[13:17:24.236]                 is_error <- inherits(cond, "error")
[13:17:24.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.236]                   NULL)
[13:17:24.236]                 if (is_error) {
[13:17:24.236]                   sessionInformation <- function() {
[13:17:24.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.236]                       search = base::search(), system = base::Sys.info())
[13:17:24.236]                   }
[13:17:24.236]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.236]                     cond$call), session = sessionInformation(), 
[13:17:24.236]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.236]                   signalCondition(cond)
[13:17:24.236]                 }
[13:17:24.236]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[13:17:24.236]                   signal <- TRUE && inherits(cond, character(0))
[13:17:24.236]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.236]                   if (TRUE && !signal) {
[13:17:24.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.236]                     {
[13:17:24.236]                       inherits <- base::inherits
[13:17:24.236]                       invokeRestart <- base::invokeRestart
[13:17:24.236]                       is.null <- base::is.null
[13:17:24.236]                       muffled <- FALSE
[13:17:24.236]                       if (inherits(cond, "message")) {
[13:17:24.236]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.236]                         if (muffled) 
[13:17:24.236]                           invokeRestart("muffleMessage")
[13:17:24.236]                       }
[13:17:24.236]                       else if (inherits(cond, "warning")) {
[13:17:24.236]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.236]                         if (muffled) 
[13:17:24.236]                           invokeRestart("muffleWarning")
[13:17:24.236]                       }
[13:17:24.236]                       else if (inherits(cond, "condition")) {
[13:17:24.236]                         if (!is.null(pattern)) {
[13:17:24.236]                           computeRestarts <- base::computeRestarts
[13:17:24.236]                           grepl <- base::grepl
[13:17:24.236]                           restarts <- computeRestarts(cond)
[13:17:24.236]                           for (restart in restarts) {
[13:17:24.236]                             name <- restart$name
[13:17:24.236]                             if (is.null(name)) 
[13:17:24.236]                               next
[13:17:24.236]                             if (!grepl(pattern, name)) 
[13:17:24.236]                               next
[13:17:24.236]                             invokeRestart(restart)
[13:17:24.236]                             muffled <- TRUE
[13:17:24.236]                             break
[13:17:24.236]                           }
[13:17:24.236]                         }
[13:17:24.236]                       }
[13:17:24.236]                       invisible(muffled)
[13:17:24.236]                     }
[13:17:24.236]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.236]                   }
[13:17:24.236]                 }
[13:17:24.236]                 else {
[13:17:24.236]                   if (FALSE) {
[13:17:24.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.236]                     {
[13:17:24.236]                       inherits <- base::inherits
[13:17:24.236]                       invokeRestart <- base::invokeRestart
[13:17:24.236]                       is.null <- base::is.null
[13:17:24.236]                       muffled <- FALSE
[13:17:24.236]                       if (inherits(cond, "message")) {
[13:17:24.236]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.236]                         if (muffled) 
[13:17:24.236]                           invokeRestart("muffleMessage")
[13:17:24.236]                       }
[13:17:24.236]                       else if (inherits(cond, "warning")) {
[13:17:24.236]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.236]                         if (muffled) 
[13:17:24.236]                           invokeRestart("muffleWarning")
[13:17:24.236]                       }
[13:17:24.236]                       else if (inherits(cond, "condition")) {
[13:17:24.236]                         if (!is.null(pattern)) {
[13:17:24.236]                           computeRestarts <- base::computeRestarts
[13:17:24.236]                           grepl <- base::grepl
[13:17:24.236]                           restarts <- computeRestarts(cond)
[13:17:24.236]                           for (restart in restarts) {
[13:17:24.236]                             name <- restart$name
[13:17:24.236]                             if (is.null(name)) 
[13:17:24.236]                               next
[13:17:24.236]                             if (!grepl(pattern, name)) 
[13:17:24.236]                               next
[13:17:24.236]                             invokeRestart(restart)
[13:17:24.236]                             muffled <- TRUE
[13:17:24.236]                             break
[13:17:24.236]                           }
[13:17:24.236]                         }
[13:17:24.236]                       }
[13:17:24.236]                       invisible(muffled)
[13:17:24.236]                     }
[13:17:24.236]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.236]                   }
[13:17:24.236]                 }
[13:17:24.236]             }
[13:17:24.236]         }))
[13:17:24.236]     }, error = function(ex) {
[13:17:24.236]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.236]                 ...future.rng), started = ...future.startTime, 
[13:17:24.236]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.236]             version = "1.8"), class = "FutureResult")
[13:17:24.236]     }, finally = {
[13:17:24.236]         if (!identical(...future.workdir, getwd())) 
[13:17:24.236]             setwd(...future.workdir)
[13:17:24.236]         {
[13:17:24.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.236]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.236]             }
[13:17:24.236]             base::options(...future.oldOptions)
[13:17:24.236]             if (.Platform$OS.type == "windows") {
[13:17:24.236]                 old_names <- names(...future.oldEnvVars)
[13:17:24.236]                 envs <- base::Sys.getenv()
[13:17:24.236]                 names <- names(envs)
[13:17:24.236]                 common <- intersect(names, old_names)
[13:17:24.236]                 added <- setdiff(names, old_names)
[13:17:24.236]                 removed <- setdiff(old_names, names)
[13:17:24.236]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.236]                   envs[common]]
[13:17:24.236]                 NAMES <- toupper(changed)
[13:17:24.236]                 args <- list()
[13:17:24.236]                 for (kk in seq_along(NAMES)) {
[13:17:24.236]                   name <- changed[[kk]]
[13:17:24.236]                   NAME <- NAMES[[kk]]
[13:17:24.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.236]                     next
[13:17:24.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.236]                 }
[13:17:24.236]                 NAMES <- toupper(added)
[13:17:24.236]                 for (kk in seq_along(NAMES)) {
[13:17:24.236]                   name <- added[[kk]]
[13:17:24.236]                   NAME <- NAMES[[kk]]
[13:17:24.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.236]                     next
[13:17:24.236]                   args[[name]] <- ""
[13:17:24.236]                 }
[13:17:24.236]                 NAMES <- toupper(removed)
[13:17:24.236]                 for (kk in seq_along(NAMES)) {
[13:17:24.236]                   name <- removed[[kk]]
[13:17:24.236]                   NAME <- NAMES[[kk]]
[13:17:24.236]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.236]                     next
[13:17:24.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.236]                 }
[13:17:24.236]                 if (length(args) > 0) 
[13:17:24.236]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.236]             }
[13:17:24.236]             else {
[13:17:24.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.236]             }
[13:17:24.236]             {
[13:17:24.236]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.236]                   0L) {
[13:17:24.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.236]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.236]                   base::options(opts)
[13:17:24.236]                 }
[13:17:24.236]                 {
[13:17:24.236]                   {
[13:17:24.236]                     base::assign(".Random.seed", c(10407L, 1487216257L, 
[13:17:24.236]                     -274646202L, 814490448L, 1519327308L, -1160950582L, 
[13:17:24.236]                     1304759412L), envir = base::globalenv(), 
[13:17:24.236]                       inherits = FALSE)
[13:17:24.236]                     NULL
[13:17:24.236]                   }
[13:17:24.236]                   options(future.plan = NULL)
[13:17:24.236]                   if (is.na(NA_character_)) 
[13:17:24.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.236]                   future::plan(list(function (..., envir = parent.frame()) 
[13:17:24.236]                   {
[13:17:24.236]                     future <- SequentialFuture(..., envir = envir)
[13:17:24.236]                     if (!future$lazy) 
[13:17:24.236]                       future <- run(future)
[13:17:24.236]                     invisible(future)
[13:17:24.236]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.236]                 }
[13:17:24.236]             }
[13:17:24.236]         }
[13:17:24.236]     })
[13:17:24.236]     if (TRUE) {
[13:17:24.236]         base::sink(type = "output", split = FALSE)
[13:17:24.236]         if (TRUE) {
[13:17:24.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.236]         }
[13:17:24.236]         else {
[13:17:24.236]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.236]         }
[13:17:24.236]         base::close(...future.stdout)
[13:17:24.236]         ...future.stdout <- NULL
[13:17:24.236]     }
[13:17:24.236]     ...future.result$conditions <- ...future.conditions
[13:17:24.236]     ...future.result$finished <- base::Sys.time()
[13:17:24.236]     ...future.result
[13:17:24.236] }
[13:17:24.238] assign_globals() ...
[13:17:24.238] List of 5
[13:17:24.238]  $ future.call.arguments    : list()
[13:17:24.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.238]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:17:24.238]  $ ...future.elements_ii    :List of 2
[13:17:24.238]   ..$ : int [1:2] 1 3
[13:17:24.238]   ..$ : int [1:2] 2 4
[13:17:24.238]  $ ...future.seeds_ii       :List of 2
[13:17:24.238]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:17:24.238]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:17:24.238]  $ ...future.globals.maxSize: num Inf
[13:17:24.238]  - attr(*, "resolved")= logi FALSE
[13:17:24.238]  - attr(*, "total_size")= num NA
[13:17:24.238]  - attr(*, "where")=List of 5
[13:17:24.238]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.238]  - attr(*, "already-done")= logi TRUE
[13:17:24.243] - copied ‘future.call.arguments’ to environment
[13:17:24.243] - copied ‘...future.FUN’ to environment
[13:17:24.243] - copied ‘...future.elements_ii’ to environment
[13:17:24.243] - copied ‘...future.seeds_ii’ to environment
[13:17:24.243] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.243] assign_globals() ... done
[13:17:24.244] plan(): Setting new future strategy stack:
[13:17:24.244] List of future strategies:
[13:17:24.244] 1. sequential:
[13:17:24.244]    - args: function (..., envir = parent.frame())
[13:17:24.244]    - tweaked: FALSE
[13:17:24.244]    - call: NULL
[13:17:24.244] plan(): nbrOfWorkers() = 1
[13:17:24.245] plan(): Setting new future strategy stack:
[13:17:24.245] List of future strategies:
[13:17:24.245] 1. sequential:
[13:17:24.245]    - args: function (..., envir = parent.frame())
[13:17:24.245]    - tweaked: FALSE
[13:17:24.245]    - call: plan(strategy)
[13:17:24.245] plan(): nbrOfWorkers() = 1
[13:17:24.245] SequentialFuture started (and completed)
[13:17:24.246] - Launch lazy future ... done
[13:17:24.246] run() for ‘SequentialFuture’ ... done
[13:17:24.246] Created future:
[13:17:24.246] SequentialFuture:
[13:17:24.246] Label: ‘future_apply-1’
[13:17:24.246] Expression:
[13:17:24.246] {
[13:17:24.246]     do.call(function(...) {
[13:17:24.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.246]             on.exit(options(oopts), add = TRUE)
[13:17:24.246]         }
[13:17:24.246]         {
[13:17:24.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.246]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:24.246]                   envir = globalenv(), inherits = FALSE)
[13:17:24.246]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.246]             })
[13:17:24.246]         }
[13:17:24.246]     }, args = future.call.arguments)
[13:17:24.246] }
[13:17:24.246] Lazy evaluation: FALSE
[13:17:24.246] Asynchronous evaluation: FALSE
[13:17:24.246] Local evaluation: TRUE
[13:17:24.246] Environment: R_GlobalEnv
[13:17:24.246] Capture standard output: TRUE
[13:17:24.246] Capture condition classes: <none>
[13:17:24.246] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.246] Packages: <none>
[13:17:24.246] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:17:24.246] Resolved: TRUE
[13:17:24.246] Value: 112 bytes of class ‘list’
[13:17:24.246] Early signaling: FALSE
[13:17:24.246] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.246] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:17:24.247] Chunk #1 of 1 ... DONE
[13:17:24.247] Launching 1 futures (chunks) ... DONE
[13:17:24.247] Resolving 1 futures (chunks) ...
[13:17:24.247] resolve() on list ...
[13:17:24.247]  recursive: 0
[13:17:24.247]  length: 1
[13:17:24.247] 
[13:17:24.248] resolved() for ‘SequentialFuture’ ...
[13:17:24.248] - state: ‘finished’
[13:17:24.248] - run: TRUE
[13:17:24.248] - result: ‘FutureResult’
[13:17:24.249] resolved() for ‘SequentialFuture’ ... done
[13:17:24.249] Future #1
[13:17:24.249] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:17:24.249] - nx: 1
[13:17:24.249] - relay: TRUE
[13:17:24.249] - stdout: TRUE
[13:17:24.249] - signal: TRUE
[13:17:24.249] - resignal: FALSE
[13:17:24.249] - force: TRUE
[13:17:24.249] - relayed: [n=1] FALSE
[13:17:24.250] - queued futures: [n=1] FALSE
[13:17:24.250]  - until=1
[13:17:24.250]  - relaying element #1
[13:17:24.250] - relayed: [n=1] TRUE
[13:17:24.250] - queued futures: [n=1] TRUE
[13:17:24.250] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:17:24.250]  length: 0 (resolved future 1)
[13:17:24.250] Relaying remaining futures
[13:17:24.250] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.250] - nx: 1
[13:17:24.250] - relay: TRUE
[13:17:24.251] - stdout: TRUE
[13:17:24.251] - signal: TRUE
[13:17:24.251] - resignal: FALSE
[13:17:24.251] - force: TRUE
[13:17:24.251] - relayed: [n=1] TRUE
[13:17:24.251] - queued futures: [n=1] TRUE
 - flush all
[13:17:24.251] - relayed: [n=1] TRUE
[13:17:24.251] - queued futures: [n=1] TRUE
[13:17:24.251] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.251] resolve() on list ... DONE
[13:17:24.252]  - Number of value chunks collected: 1
[13:17:24.252] Resolving 1 futures (chunks) ... DONE
[13:17:24.252] Reducing values from 1 chunks ...
[13:17:24.252]  - Number of values collected after concatenation: 2
[13:17:24.252]  - Number of values expected: 2
[13:17:24.252] Reducing values from 1 chunks ... DONE
[13:17:24.252] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:17:24.252] plan(): Setting new future strategy stack:
[13:17:24.252] List of future strategies:
[13:17:24.252] 1. sequential:
[13:17:24.252]    - args: function (..., envir = parent.frame())
[13:17:24.252]    - tweaked: FALSE
[13:17:24.252]    - call: plan(sequential)
[13:17:24.253] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:17:24.253] plan(): Setting new future strategy stack:
[13:17:24.253] List of future strategies:
[13:17:24.253] 1. multicore:
[13:17:24.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.253]    - tweaked: FALSE
[13:17:24.253]    - call: plan(strategy)
[13:17:24.257] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[13:17:24.258] getGlobalsAndPackagesXApply() ...
[13:17:24.258]  - future.globals: TRUE
[13:17:24.258] getGlobalsAndPackages() ...
[13:17:24.258] Searching for globals...
[13:17:24.292] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:17:24.292] Searching for globals ... DONE
[13:17:24.293] Resolving globals: FALSE
[13:17:24.294] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:17:24.294] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:17:24.295] - globals: [1] ‘FUN’
[13:17:24.295] 
[13:17:24.295] getGlobalsAndPackages() ... DONE
[13:17:24.295]  - globals found/used: [n=1] ‘FUN’
[13:17:24.295]  - needed namespaces: [n=0] 
[13:17:24.295] Finding globals ... DONE
[13:17:24.295]  - use_args: TRUE
[13:17:24.295]  - Getting '...' globals ...
[13:17:24.296] resolve() on list ...
[13:17:24.296]  recursive: 0
[13:17:24.296]  length: 1
[13:17:24.296]  elements: ‘...’
[13:17:24.296]  length: 0 (resolved future 1)
[13:17:24.296] resolve() on list ... DONE
[13:17:24.296]    - '...' content: [n=0] 
[13:17:24.296] List of 1
[13:17:24.296]  $ ...: list()
[13:17:24.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.296]  - attr(*, "where")=List of 1
[13:17:24.296]   ..$ ...:<environment: 0x5647b8d50ba8> 
[13:17:24.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.296]  - attr(*, "resolved")= logi TRUE
[13:17:24.296]  - attr(*, "total_size")= num NA
[13:17:24.299]  - Getting '...' globals ... DONE
[13:17:24.299] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.299] List of 2
[13:17:24.299]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.299]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.299]  $ ...          : list()
[13:17:24.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.299]  - attr(*, "where")=List of 2
[13:17:24.299]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.299]   ..$ ...          :<environment: 0x5647b8d50ba8> 
[13:17:24.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.299]  - attr(*, "resolved")= logi FALSE
[13:17:24.299]  - attr(*, "total_size")= num 354224
[13:17:24.302] Packages to be attached in all futures: [n=0] 
[13:17:24.302] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.305] future_lapply() ...
[13:17:24.342] Number of chunks: 2
[13:17:24.342] getGlobalsAndPackagesXApply() ...
[13:17:24.342]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.343]  - use_args: TRUE
[13:17:24.343] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.343] List of 2
[13:17:24.343]  $ ...          : list()
[13:17:24.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.343]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.343]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.343]  - attr(*, "where")=List of 2
[13:17:24.343]   ..$ ...          :<environment: 0x5647b8d50ba8> 
[13:17:24.343]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.343]  - attr(*, "resolved")= logi FALSE
[13:17:24.343]  - attr(*, "total_size")= num NA
[13:17:24.346] Packages to be attached in all futures: [n=0] 
[13:17:24.346] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.347] Number of futures (= number of chunks): 2
[13:17:24.347] Launching 2 futures (chunks) ...
[13:17:24.347] Chunk #1 of 2 ...
[13:17:24.347]  - seeds: <none>
[13:17:24.347] getGlobalsAndPackages() ...
[13:17:24.347] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.347] Resolving globals: FALSE
[13:17:24.348] Tweak future expression to call with '...' arguments ...
[13:17:24.348] {
[13:17:24.348]     do.call(function(...) {
[13:17:24.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.348]             on.exit(options(oopts), add = TRUE)
[13:17:24.348]         }
[13:17:24.348]         {
[13:17:24.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.348]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.348]             })
[13:17:24.348]         }
[13:17:24.348]     }, args = future.call.arguments)
[13:17:24.348] }
[13:17:24.349] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.349] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.349] 
[13:17:24.349] getGlobalsAndPackages() ... DONE
[13:17:24.350] run() for ‘Future’ ...
[13:17:24.350] - state: ‘created’
[13:17:24.350] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.354]   - Field: ‘label’
[13:17:24.354]   - Field: ‘local’
[13:17:24.354]   - Field: ‘owner’
[13:17:24.354]   - Field: ‘envir’
[13:17:24.354]   - Field: ‘workers’
[13:17:24.354]   - Field: ‘packages’
[13:17:24.354]   - Field: ‘gc’
[13:17:24.355]   - Field: ‘job’
[13:17:24.355]   - Field: ‘conditions’
[13:17:24.355]   - Field: ‘expr’
[13:17:24.355]   - Field: ‘uuid’
[13:17:24.355]   - Field: ‘seed’
[13:17:24.355]   - Field: ‘version’
[13:17:24.355]   - Field: ‘result’
[13:17:24.355]   - Field: ‘asynchronous’
[13:17:24.355]   - Field: ‘calls’
[13:17:24.355]   - Field: ‘globals’
[13:17:24.355]   - Field: ‘stdout’
[13:17:24.356]   - Field: ‘earlySignal’
[13:17:24.356]   - Field: ‘lazy’
[13:17:24.356]   - Field: ‘state’
[13:17:24.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.356] - Launch lazy future ...
[13:17:24.357] Packages needed by the future expression (n = 0): <none>
[13:17:24.357] Packages needed by future strategies (n = 0): <none>
[13:17:24.358] {
[13:17:24.358]     {
[13:17:24.358]         {
[13:17:24.358]             ...future.startTime <- base::Sys.time()
[13:17:24.358]             {
[13:17:24.358]                 {
[13:17:24.358]                   {
[13:17:24.358]                     {
[13:17:24.358]                       base::local({
[13:17:24.358]                         has_future <- base::requireNamespace("future", 
[13:17:24.358]                           quietly = TRUE)
[13:17:24.358]                         if (has_future) {
[13:17:24.358]                           ns <- base::getNamespace("future")
[13:17:24.358]                           version <- ns[[".package"]][["version"]]
[13:17:24.358]                           if (is.null(version)) 
[13:17:24.358]                             version <- utils::packageVersion("future")
[13:17:24.358]                         }
[13:17:24.358]                         else {
[13:17:24.358]                           version <- NULL
[13:17:24.358]                         }
[13:17:24.358]                         if (!has_future || version < "1.8.0") {
[13:17:24.358]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.358]                             "", base::R.version$version.string), 
[13:17:24.358]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.358]                               "release", "version")], collapse = " "), 
[13:17:24.358]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.358]                             info)
[13:17:24.358]                           info <- base::paste(info, collapse = "; ")
[13:17:24.358]                           if (!has_future) {
[13:17:24.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.358]                               info)
[13:17:24.358]                           }
[13:17:24.358]                           else {
[13:17:24.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.358]                               info, version)
[13:17:24.358]                           }
[13:17:24.358]                           base::stop(msg)
[13:17:24.358]                         }
[13:17:24.358]                       })
[13:17:24.358]                     }
[13:17:24.358]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.358]                     base::options(mc.cores = 1L)
[13:17:24.358]                   }
[13:17:24.358]                   options(future.plan = NULL)
[13:17:24.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.358]                 }
[13:17:24.358]                 ...future.workdir <- getwd()
[13:17:24.358]             }
[13:17:24.358]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.358]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.358]         }
[13:17:24.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.358]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.358]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.358]             base::names(...future.oldOptions))
[13:17:24.358]     }
[13:17:24.358]     if (FALSE) {
[13:17:24.358]     }
[13:17:24.358]     else {
[13:17:24.358]         if (TRUE) {
[13:17:24.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.358]                 open = "w")
[13:17:24.358]         }
[13:17:24.358]         else {
[13:17:24.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.358]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.358]         }
[13:17:24.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.358]             base::sink(type = "output", split = FALSE)
[13:17:24.358]             base::close(...future.stdout)
[13:17:24.358]         }, add = TRUE)
[13:17:24.358]     }
[13:17:24.358]     ...future.frame <- base::sys.nframe()
[13:17:24.358]     ...future.conditions <- base::list()
[13:17:24.358]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.358]     if (FALSE) {
[13:17:24.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.358]     }
[13:17:24.358]     ...future.result <- base::tryCatch({
[13:17:24.358]         base::withCallingHandlers({
[13:17:24.358]             ...future.value <- base::withVisible(base::local({
[13:17:24.358]                 withCallingHandlers({
[13:17:24.358]                   {
[13:17:24.358]                     do.call(function(...) {
[13:17:24.358]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.358]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.358]                         ...future.globals.maxSize)) {
[13:17:24.358]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.358]                         on.exit(options(oopts), add = TRUE)
[13:17:24.358]                       }
[13:17:24.358]                       {
[13:17:24.358]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.358]                           FUN = function(jj) {
[13:17:24.358]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.358]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.358]                           })
[13:17:24.358]                       }
[13:17:24.358]                     }, args = future.call.arguments)
[13:17:24.358]                   }
[13:17:24.358]                 }, immediateCondition = function(cond) {
[13:17:24.358]                   save_rds <- function (object, pathname, ...) 
[13:17:24.358]                   {
[13:17:24.358]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.358]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.358]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.358]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.358]                         fi_tmp[["mtime"]])
[13:17:24.358]                     }
[13:17:24.358]                     tryCatch({
[13:17:24.358]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.358]                     }, error = function(ex) {
[13:17:24.358]                       msg <- conditionMessage(ex)
[13:17:24.358]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.358]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.358]                         fi_tmp[["mtime"]], msg)
[13:17:24.358]                       ex$message <- msg
[13:17:24.358]                       stop(ex)
[13:17:24.358]                     })
[13:17:24.358]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.358]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.358]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.358]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.358]                       fi <- file.info(pathname)
[13:17:24.358]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.358]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.358]                         fi[["size"]], fi[["mtime"]])
[13:17:24.358]                       stop(msg)
[13:17:24.358]                     }
[13:17:24.358]                     invisible(pathname)
[13:17:24.358]                   }
[13:17:24.358]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.358]                     rootPath = tempdir()) 
[13:17:24.358]                   {
[13:17:24.358]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.358]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.358]                       tmpdir = path, fileext = ".rds")
[13:17:24.358]                     save_rds(obj, file)
[13:17:24.358]                   }
[13:17:24.358]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.358]                   {
[13:17:24.358]                     inherits <- base::inherits
[13:17:24.358]                     invokeRestart <- base::invokeRestart
[13:17:24.358]                     is.null <- base::is.null
[13:17:24.358]                     muffled <- FALSE
[13:17:24.358]                     if (inherits(cond, "message")) {
[13:17:24.358]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.358]                       if (muffled) 
[13:17:24.358]                         invokeRestart("muffleMessage")
[13:17:24.358]                     }
[13:17:24.358]                     else if (inherits(cond, "warning")) {
[13:17:24.358]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.358]                       if (muffled) 
[13:17:24.358]                         invokeRestart("muffleWarning")
[13:17:24.358]                     }
[13:17:24.358]                     else if (inherits(cond, "condition")) {
[13:17:24.358]                       if (!is.null(pattern)) {
[13:17:24.358]                         computeRestarts <- base::computeRestarts
[13:17:24.358]                         grepl <- base::grepl
[13:17:24.358]                         restarts <- computeRestarts(cond)
[13:17:24.358]                         for (restart in restarts) {
[13:17:24.358]                           name <- restart$name
[13:17:24.358]                           if (is.null(name)) 
[13:17:24.358]                             next
[13:17:24.358]                           if (!grepl(pattern, name)) 
[13:17:24.358]                             next
[13:17:24.358]                           invokeRestart(restart)
[13:17:24.358]                           muffled <- TRUE
[13:17:24.358]                           break
[13:17:24.358]                         }
[13:17:24.358]                       }
[13:17:24.358]                     }
[13:17:24.358]                     invisible(muffled)
[13:17:24.358]                   }
[13:17:24.358]                   muffleCondition(cond)
[13:17:24.358]                 })
[13:17:24.358]             }))
[13:17:24.358]             future::FutureResult(value = ...future.value$value, 
[13:17:24.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.358]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.358]                     ...future.globalenv.names))
[13:17:24.358]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.358]         }, condition = base::local({
[13:17:24.358]             c <- base::c
[13:17:24.358]             inherits <- base::inherits
[13:17:24.358]             invokeRestart <- base::invokeRestart
[13:17:24.358]             length <- base::length
[13:17:24.358]             list <- base::list
[13:17:24.358]             seq.int <- base::seq.int
[13:17:24.358]             signalCondition <- base::signalCondition
[13:17:24.358]             sys.calls <- base::sys.calls
[13:17:24.358]             `[[` <- base::`[[`
[13:17:24.358]             `+` <- base::`+`
[13:17:24.358]             `<<-` <- base::`<<-`
[13:17:24.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.358]                   3L)]
[13:17:24.358]             }
[13:17:24.358]             function(cond) {
[13:17:24.358]                 is_error <- inherits(cond, "error")
[13:17:24.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.358]                   NULL)
[13:17:24.358]                 if (is_error) {
[13:17:24.358]                   sessionInformation <- function() {
[13:17:24.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.358]                       search = base::search(), system = base::Sys.info())
[13:17:24.358]                   }
[13:17:24.358]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.358]                     cond$call), session = sessionInformation(), 
[13:17:24.358]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.358]                   signalCondition(cond)
[13:17:24.358]                 }
[13:17:24.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.358]                 "immediateCondition"))) {
[13:17:24.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.358]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.358]                   if (TRUE && !signal) {
[13:17:24.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.358]                     {
[13:17:24.358]                       inherits <- base::inherits
[13:17:24.358]                       invokeRestart <- base::invokeRestart
[13:17:24.358]                       is.null <- base::is.null
[13:17:24.358]                       muffled <- FALSE
[13:17:24.358]                       if (inherits(cond, "message")) {
[13:17:24.358]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.358]                         if (muffled) 
[13:17:24.358]                           invokeRestart("muffleMessage")
[13:17:24.358]                       }
[13:17:24.358]                       else if (inherits(cond, "warning")) {
[13:17:24.358]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.358]                         if (muffled) 
[13:17:24.358]                           invokeRestart("muffleWarning")
[13:17:24.358]                       }
[13:17:24.358]                       else if (inherits(cond, "condition")) {
[13:17:24.358]                         if (!is.null(pattern)) {
[13:17:24.358]                           computeRestarts <- base::computeRestarts
[13:17:24.358]                           grepl <- base::grepl
[13:17:24.358]                           restarts <- computeRestarts(cond)
[13:17:24.358]                           for (restart in restarts) {
[13:17:24.358]                             name <- restart$name
[13:17:24.358]                             if (is.null(name)) 
[13:17:24.358]                               next
[13:17:24.358]                             if (!grepl(pattern, name)) 
[13:17:24.358]                               next
[13:17:24.358]                             invokeRestart(restart)
[13:17:24.358]                             muffled <- TRUE
[13:17:24.358]                             break
[13:17:24.358]                           }
[13:17:24.358]                         }
[13:17:24.358]                       }
[13:17:24.358]                       invisible(muffled)
[13:17:24.358]                     }
[13:17:24.358]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.358]                   }
[13:17:24.358]                 }
[13:17:24.358]                 else {
[13:17:24.358]                   if (TRUE) {
[13:17:24.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.358]                     {
[13:17:24.358]                       inherits <- base::inherits
[13:17:24.358]                       invokeRestart <- base::invokeRestart
[13:17:24.358]                       is.null <- base::is.null
[13:17:24.358]                       muffled <- FALSE
[13:17:24.358]                       if (inherits(cond, "message")) {
[13:17:24.358]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.358]                         if (muffled) 
[13:17:24.358]                           invokeRestart("muffleMessage")
[13:17:24.358]                       }
[13:17:24.358]                       else if (inherits(cond, "warning")) {
[13:17:24.358]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.358]                         if (muffled) 
[13:17:24.358]                           invokeRestart("muffleWarning")
[13:17:24.358]                       }
[13:17:24.358]                       else if (inherits(cond, "condition")) {
[13:17:24.358]                         if (!is.null(pattern)) {
[13:17:24.358]                           computeRestarts <- base::computeRestarts
[13:17:24.358]                           grepl <- base::grepl
[13:17:24.358]                           restarts <- computeRestarts(cond)
[13:17:24.358]                           for (restart in restarts) {
[13:17:24.358]                             name <- restart$name
[13:17:24.358]                             if (is.null(name)) 
[13:17:24.358]                               next
[13:17:24.358]                             if (!grepl(pattern, name)) 
[13:17:24.358]                               next
[13:17:24.358]                             invokeRestart(restart)
[13:17:24.358]                             muffled <- TRUE
[13:17:24.358]                             break
[13:17:24.358]                           }
[13:17:24.358]                         }
[13:17:24.358]                       }
[13:17:24.358]                       invisible(muffled)
[13:17:24.358]                     }
[13:17:24.358]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.358]                   }
[13:17:24.358]                 }
[13:17:24.358]             }
[13:17:24.358]         }))
[13:17:24.358]     }, error = function(ex) {
[13:17:24.358]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.358]                 ...future.rng), started = ...future.startTime, 
[13:17:24.358]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.358]             version = "1.8"), class = "FutureResult")
[13:17:24.358]     }, finally = {
[13:17:24.358]         if (!identical(...future.workdir, getwd())) 
[13:17:24.358]             setwd(...future.workdir)
[13:17:24.358]         {
[13:17:24.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.358]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.358]             }
[13:17:24.358]             base::options(...future.oldOptions)
[13:17:24.358]             if (.Platform$OS.type == "windows") {
[13:17:24.358]                 old_names <- names(...future.oldEnvVars)
[13:17:24.358]                 envs <- base::Sys.getenv()
[13:17:24.358]                 names <- names(envs)
[13:17:24.358]                 common <- intersect(names, old_names)
[13:17:24.358]                 added <- setdiff(names, old_names)
[13:17:24.358]                 removed <- setdiff(old_names, names)
[13:17:24.358]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.358]                   envs[common]]
[13:17:24.358]                 NAMES <- toupper(changed)
[13:17:24.358]                 args <- list()
[13:17:24.358]                 for (kk in seq_along(NAMES)) {
[13:17:24.358]                   name <- changed[[kk]]
[13:17:24.358]                   NAME <- NAMES[[kk]]
[13:17:24.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.358]                     next
[13:17:24.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.358]                 }
[13:17:24.358]                 NAMES <- toupper(added)
[13:17:24.358]                 for (kk in seq_along(NAMES)) {
[13:17:24.358]                   name <- added[[kk]]
[13:17:24.358]                   NAME <- NAMES[[kk]]
[13:17:24.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.358]                     next
[13:17:24.358]                   args[[name]] <- ""
[13:17:24.358]                 }
[13:17:24.358]                 NAMES <- toupper(removed)
[13:17:24.358]                 for (kk in seq_along(NAMES)) {
[13:17:24.358]                   name <- removed[[kk]]
[13:17:24.358]                   NAME <- NAMES[[kk]]
[13:17:24.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.358]                     next
[13:17:24.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.358]                 }
[13:17:24.358]                 if (length(args) > 0) 
[13:17:24.358]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.358]             }
[13:17:24.358]             else {
[13:17:24.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.358]             }
[13:17:24.358]             {
[13:17:24.358]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.358]                   0L) {
[13:17:24.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.358]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.358]                   base::options(opts)
[13:17:24.358]                 }
[13:17:24.358]                 {
[13:17:24.358]                   {
[13:17:24.358]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.358]                     NULL
[13:17:24.358]                   }
[13:17:24.358]                   options(future.plan = NULL)
[13:17:24.358]                   if (is.na(NA_character_)) 
[13:17:24.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.358]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.358]                     envir = parent.frame()) 
[13:17:24.358]                   {
[13:17:24.358]                     default_workers <- missing(workers)
[13:17:24.358]                     if (is.function(workers)) 
[13:17:24.358]                       workers <- workers()
[13:17:24.358]                     workers <- structure(as.integer(workers), 
[13:17:24.358]                       class = class(workers))
[13:17:24.358]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.358]                       1L)
[13:17:24.358]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.358]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.358]                       if (default_workers) 
[13:17:24.358]                         supportsMulticore(warn = TRUE)
[13:17:24.358]                       return(sequential(..., envir = envir))
[13:17:24.358]                     }
[13:17:24.358]                     oopts <- options(mc.cores = workers)
[13:17:24.358]                     on.exit(options(oopts))
[13:17:24.358]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.358]                       envir = envir)
[13:17:24.358]                     if (!future$lazy) 
[13:17:24.358]                       future <- run(future)
[13:17:24.358]                     invisible(future)
[13:17:24.358]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.358]                 }
[13:17:24.358]             }
[13:17:24.358]         }
[13:17:24.358]     })
[13:17:24.358]     if (TRUE) {
[13:17:24.358]         base::sink(type = "output", split = FALSE)
[13:17:24.358]         if (TRUE) {
[13:17:24.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.358]         }
[13:17:24.358]         else {
[13:17:24.358]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.358]         }
[13:17:24.358]         base::close(...future.stdout)
[13:17:24.358]         ...future.stdout <- NULL
[13:17:24.358]     }
[13:17:24.358]     ...future.result$conditions <- ...future.conditions
[13:17:24.358]     ...future.result$finished <- base::Sys.time()
[13:17:24.358]     ...future.result
[13:17:24.358] }
[13:17:24.360] assign_globals() ...
[13:17:24.360] List of 5
[13:17:24.360]  $ future.call.arguments    : list()
[13:17:24.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.360]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.360]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.360]  $ ...future.elements_ii    :List of 1
[13:17:24.360]   ..$ : num [1:4] 1 3 1 7
[13:17:24.360]  $ ...future.seeds_ii       : NULL
[13:17:24.360]  $ ...future.globals.maxSize: NULL
[13:17:24.360]  - attr(*, "where")=List of 5
[13:17:24.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.360]  - attr(*, "resolved")= logi FALSE
[13:17:24.360]  - attr(*, "total_size")= num NA
[13:17:24.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.360]  - attr(*, "already-done")= logi TRUE
[13:17:24.365] - copied ‘future.call.arguments’ to environment
[13:17:24.365] - copied ‘...future.FUN’ to environment
[13:17:24.365] - copied ‘...future.elements_ii’ to environment
[13:17:24.365] - copied ‘...future.seeds_ii’ to environment
[13:17:24.365] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.365] assign_globals() ... done
[13:17:24.366] requestCore(): workers = 2
[13:17:24.369] MulticoreFuture started
[13:17:24.369] - Launch lazy future ... done
[13:17:24.369] plan(): Setting new future strategy stack:
[13:17:24.369] run() for ‘MulticoreFuture’ ... done
[13:17:24.370] Created future:
[13:17:24.369] List of future strategies:
[13:17:24.369] 1. sequential:
[13:17:24.369]    - args: function (..., envir = parent.frame())
[13:17:24.369]    - tweaked: FALSE
[13:17:24.369]    - call: NULL
[13:17:24.370] plan(): nbrOfWorkers() = 1
[13:17:24.373] plan(): Setting new future strategy stack:
[13:17:24.373] List of future strategies:
[13:17:24.373] 1. multicore:
[13:17:24.373]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.373]    - tweaked: FALSE
[13:17:24.373]    - call: plan(strategy)
[13:17:24.378] plan(): nbrOfWorkers() = 2
[13:17:24.370] MulticoreFuture:
[13:17:24.370] Label: ‘future_apply-1’
[13:17:24.370] Expression:
[13:17:24.370] {
[13:17:24.370]     do.call(function(...) {
[13:17:24.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.370]             on.exit(options(oopts), add = TRUE)
[13:17:24.370]         }
[13:17:24.370]         {
[13:17:24.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.370]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.370]             })
[13:17:24.370]         }
[13:17:24.370]     }, args = future.call.arguments)
[13:17:24.370] }
[13:17:24.370] Lazy evaluation: FALSE
[13:17:24.370] Asynchronous evaluation: TRUE
[13:17:24.370] Local evaluation: TRUE
[13:17:24.370] Environment: R_GlobalEnv
[13:17:24.370] Capture standard output: TRUE
[13:17:24.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.370] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.370] Packages: <none>
[13:17:24.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.370] Resolved: TRUE
[13:17:24.370] Value: <not collected>
[13:17:24.370] Conditions captured: <none>
[13:17:24.370] Early signaling: FALSE
[13:17:24.370] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.370] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.379] Chunk #1 of 2 ... DONE
[13:17:24.379] Chunk #2 of 2 ...
[13:17:24.379]  - seeds: <none>
[13:17:24.380] getGlobalsAndPackages() ...
[13:17:24.380] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.380] Resolving globals: FALSE
[13:17:24.380] Tweak future expression to call with '...' arguments ...
[13:17:24.380] {
[13:17:24.380]     do.call(function(...) {
[13:17:24.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.380]             on.exit(options(oopts), add = TRUE)
[13:17:24.380]         }
[13:17:24.380]         {
[13:17:24.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.380]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.380]             })
[13:17:24.380]         }
[13:17:24.380]     }, args = future.call.arguments)
[13:17:24.380] }
[13:17:24.380] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.381] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.381] 
[13:17:24.381] getGlobalsAndPackages() ... DONE
[13:17:24.382] run() for ‘Future’ ...
[13:17:24.382] - state: ‘created’
[13:17:24.382] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.387] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.387]   - Field: ‘label’
[13:17:24.387]   - Field: ‘local’
[13:17:24.387]   - Field: ‘owner’
[13:17:24.387]   - Field: ‘envir’
[13:17:24.388]   - Field: ‘workers’
[13:17:24.388]   - Field: ‘packages’
[13:17:24.388]   - Field: ‘gc’
[13:17:24.388]   - Field: ‘job’
[13:17:24.388]   - Field: ‘conditions’
[13:17:24.388]   - Field: ‘expr’
[13:17:24.388]   - Field: ‘uuid’
[13:17:24.388]   - Field: ‘seed’
[13:17:24.389]   - Field: ‘version’
[13:17:24.389]   - Field: ‘result’
[13:17:24.389]   - Field: ‘asynchronous’
[13:17:24.389]   - Field: ‘calls’
[13:17:24.389]   - Field: ‘globals’
[13:17:24.389]   - Field: ‘stdout’
[13:17:24.389]   - Field: ‘earlySignal’
[13:17:24.390]   - Field: ‘lazy’
[13:17:24.390]   - Field: ‘state’
[13:17:24.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.390] - Launch lazy future ...
[13:17:24.390] Packages needed by the future expression (n = 0): <none>
[13:17:24.391] Packages needed by future strategies (n = 0): <none>
[13:17:24.395] {
[13:17:24.395]     {
[13:17:24.395]         {
[13:17:24.395]             ...future.startTime <- base::Sys.time()
[13:17:24.395]             {
[13:17:24.395]                 {
[13:17:24.395]                   {
[13:17:24.395]                     {
[13:17:24.395]                       base::local({
[13:17:24.395]                         has_future <- base::requireNamespace("future", 
[13:17:24.395]                           quietly = TRUE)
[13:17:24.395]                         if (has_future) {
[13:17:24.395]                           ns <- base::getNamespace("future")
[13:17:24.395]                           version <- ns[[".package"]][["version"]]
[13:17:24.395]                           if (is.null(version)) 
[13:17:24.395]                             version <- utils::packageVersion("future")
[13:17:24.395]                         }
[13:17:24.395]                         else {
[13:17:24.395]                           version <- NULL
[13:17:24.395]                         }
[13:17:24.395]                         if (!has_future || version < "1.8.0") {
[13:17:24.395]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.395]                             "", base::R.version$version.string), 
[13:17:24.395]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.395]                               "release", "version")], collapse = " "), 
[13:17:24.395]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.395]                             info)
[13:17:24.395]                           info <- base::paste(info, collapse = "; ")
[13:17:24.395]                           if (!has_future) {
[13:17:24.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.395]                               info)
[13:17:24.395]                           }
[13:17:24.395]                           else {
[13:17:24.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.395]                               info, version)
[13:17:24.395]                           }
[13:17:24.395]                           base::stop(msg)
[13:17:24.395]                         }
[13:17:24.395]                       })
[13:17:24.395]                     }
[13:17:24.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.395]                     base::options(mc.cores = 1L)
[13:17:24.395]                   }
[13:17:24.395]                   options(future.plan = NULL)
[13:17:24.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.395]                 }
[13:17:24.395]                 ...future.workdir <- getwd()
[13:17:24.395]             }
[13:17:24.395]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.395]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.395]         }
[13:17:24.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.395]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.395]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.395]             base::names(...future.oldOptions))
[13:17:24.395]     }
[13:17:24.395]     if (FALSE) {
[13:17:24.395]     }
[13:17:24.395]     else {
[13:17:24.395]         if (TRUE) {
[13:17:24.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.395]                 open = "w")
[13:17:24.395]         }
[13:17:24.395]         else {
[13:17:24.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.395]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.395]         }
[13:17:24.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.395]             base::sink(type = "output", split = FALSE)
[13:17:24.395]             base::close(...future.stdout)
[13:17:24.395]         }, add = TRUE)
[13:17:24.395]     }
[13:17:24.395]     ...future.frame <- base::sys.nframe()
[13:17:24.395]     ...future.conditions <- base::list()
[13:17:24.395]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.395]     if (FALSE) {
[13:17:24.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.395]     }
[13:17:24.395]     ...future.result <- base::tryCatch({
[13:17:24.395]         base::withCallingHandlers({
[13:17:24.395]             ...future.value <- base::withVisible(base::local({
[13:17:24.395]                 withCallingHandlers({
[13:17:24.395]                   {
[13:17:24.395]                     do.call(function(...) {
[13:17:24.395]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.395]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.395]                         ...future.globals.maxSize)) {
[13:17:24.395]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.395]                         on.exit(options(oopts), add = TRUE)
[13:17:24.395]                       }
[13:17:24.395]                       {
[13:17:24.395]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.395]                           FUN = function(jj) {
[13:17:24.395]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.395]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.395]                           })
[13:17:24.395]                       }
[13:17:24.395]                     }, args = future.call.arguments)
[13:17:24.395]                   }
[13:17:24.395]                 }, immediateCondition = function(cond) {
[13:17:24.395]                   save_rds <- function (object, pathname, ...) 
[13:17:24.395]                   {
[13:17:24.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.395]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.395]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.395]                         fi_tmp[["mtime"]])
[13:17:24.395]                     }
[13:17:24.395]                     tryCatch({
[13:17:24.395]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.395]                     }, error = function(ex) {
[13:17:24.395]                       msg <- conditionMessage(ex)
[13:17:24.395]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.395]                         fi_tmp[["mtime"]], msg)
[13:17:24.395]                       ex$message <- msg
[13:17:24.395]                       stop(ex)
[13:17:24.395]                     })
[13:17:24.395]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.395]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.395]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.395]                       fi <- file.info(pathname)
[13:17:24.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.395]                         fi[["size"]], fi[["mtime"]])
[13:17:24.395]                       stop(msg)
[13:17:24.395]                     }
[13:17:24.395]                     invisible(pathname)
[13:17:24.395]                   }
[13:17:24.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.395]                     rootPath = tempdir()) 
[13:17:24.395]                   {
[13:17:24.395]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.395]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.395]                       tmpdir = path, fileext = ".rds")
[13:17:24.395]                     save_rds(obj, file)
[13:17:24.395]                   }
[13:17:24.395]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.395]                   {
[13:17:24.395]                     inherits <- base::inherits
[13:17:24.395]                     invokeRestart <- base::invokeRestart
[13:17:24.395]                     is.null <- base::is.null
[13:17:24.395]                     muffled <- FALSE
[13:17:24.395]                     if (inherits(cond, "message")) {
[13:17:24.395]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.395]                       if (muffled) 
[13:17:24.395]                         invokeRestart("muffleMessage")
[13:17:24.395]                     }
[13:17:24.395]                     else if (inherits(cond, "warning")) {
[13:17:24.395]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.395]                       if (muffled) 
[13:17:24.395]                         invokeRestart("muffleWarning")
[13:17:24.395]                     }
[13:17:24.395]                     else if (inherits(cond, "condition")) {
[13:17:24.395]                       if (!is.null(pattern)) {
[13:17:24.395]                         computeRestarts <- base::computeRestarts
[13:17:24.395]                         grepl <- base::grepl
[13:17:24.395]                         restarts <- computeRestarts(cond)
[13:17:24.395]                         for (restart in restarts) {
[13:17:24.395]                           name <- restart$name
[13:17:24.395]                           if (is.null(name)) 
[13:17:24.395]                             next
[13:17:24.395]                           if (!grepl(pattern, name)) 
[13:17:24.395]                             next
[13:17:24.395]                           invokeRestart(restart)
[13:17:24.395]                           muffled <- TRUE
[13:17:24.395]                           break
[13:17:24.395]                         }
[13:17:24.395]                       }
[13:17:24.395]                     }
[13:17:24.395]                     invisible(muffled)
[13:17:24.395]                   }
[13:17:24.395]                   muffleCondition(cond)
[13:17:24.395]                 })
[13:17:24.395]             }))
[13:17:24.395]             future::FutureResult(value = ...future.value$value, 
[13:17:24.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.395]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.395]                     ...future.globalenv.names))
[13:17:24.395]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.395]         }, condition = base::local({
[13:17:24.395]             c <- base::c
[13:17:24.395]             inherits <- base::inherits
[13:17:24.395]             invokeRestart <- base::invokeRestart
[13:17:24.395]             length <- base::length
[13:17:24.395]             list <- base::list
[13:17:24.395]             seq.int <- base::seq.int
[13:17:24.395]             signalCondition <- base::signalCondition
[13:17:24.395]             sys.calls <- base::sys.calls
[13:17:24.395]             `[[` <- base::`[[`
[13:17:24.395]             `+` <- base::`+`
[13:17:24.395]             `<<-` <- base::`<<-`
[13:17:24.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.395]                   3L)]
[13:17:24.395]             }
[13:17:24.395]             function(cond) {
[13:17:24.395]                 is_error <- inherits(cond, "error")
[13:17:24.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.395]                   NULL)
[13:17:24.395]                 if (is_error) {
[13:17:24.395]                   sessionInformation <- function() {
[13:17:24.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.395]                       search = base::search(), system = base::Sys.info())
[13:17:24.395]                   }
[13:17:24.395]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.395]                     cond$call), session = sessionInformation(), 
[13:17:24.395]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.395]                   signalCondition(cond)
[13:17:24.395]                 }
[13:17:24.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.395]                 "immediateCondition"))) {
[13:17:24.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.395]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.395]                   if (TRUE && !signal) {
[13:17:24.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.395]                     {
[13:17:24.395]                       inherits <- base::inherits
[13:17:24.395]                       invokeRestart <- base::invokeRestart
[13:17:24.395]                       is.null <- base::is.null
[13:17:24.395]                       muffled <- FALSE
[13:17:24.395]                       if (inherits(cond, "message")) {
[13:17:24.395]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.395]                         if (muffled) 
[13:17:24.395]                           invokeRestart("muffleMessage")
[13:17:24.395]                       }
[13:17:24.395]                       else if (inherits(cond, "warning")) {
[13:17:24.395]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.395]                         if (muffled) 
[13:17:24.395]                           invokeRestart("muffleWarning")
[13:17:24.395]                       }
[13:17:24.395]                       else if (inherits(cond, "condition")) {
[13:17:24.395]                         if (!is.null(pattern)) {
[13:17:24.395]                           computeRestarts <- base::computeRestarts
[13:17:24.395]                           grepl <- base::grepl
[13:17:24.395]                           restarts <- computeRestarts(cond)
[13:17:24.395]                           for (restart in restarts) {
[13:17:24.395]                             name <- restart$name
[13:17:24.395]                             if (is.null(name)) 
[13:17:24.395]                               next
[13:17:24.395]                             if (!grepl(pattern, name)) 
[13:17:24.395]                               next
[13:17:24.395]                             invokeRestart(restart)
[13:17:24.395]                             muffled <- TRUE
[13:17:24.395]                             break
[13:17:24.395]                           }
[13:17:24.395]                         }
[13:17:24.395]                       }
[13:17:24.395]                       invisible(muffled)
[13:17:24.395]                     }
[13:17:24.395]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.395]                   }
[13:17:24.395]                 }
[13:17:24.395]                 else {
[13:17:24.395]                   if (TRUE) {
[13:17:24.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.395]                     {
[13:17:24.395]                       inherits <- base::inherits
[13:17:24.395]                       invokeRestart <- base::invokeRestart
[13:17:24.395]                       is.null <- base::is.null
[13:17:24.395]                       muffled <- FALSE
[13:17:24.395]                       if (inherits(cond, "message")) {
[13:17:24.395]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.395]                         if (muffled) 
[13:17:24.395]                           invokeRestart("muffleMessage")
[13:17:24.395]                       }
[13:17:24.395]                       else if (inherits(cond, "warning")) {
[13:17:24.395]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.395]                         if (muffled) 
[13:17:24.395]                           invokeRestart("muffleWarning")
[13:17:24.395]                       }
[13:17:24.395]                       else if (inherits(cond, "condition")) {
[13:17:24.395]                         if (!is.null(pattern)) {
[13:17:24.395]                           computeRestarts <- base::computeRestarts
[13:17:24.395]                           grepl <- base::grepl
[13:17:24.395]                           restarts <- computeRestarts(cond)
[13:17:24.395]                           for (restart in restarts) {
[13:17:24.395]                             name <- restart$name
[13:17:24.395]                             if (is.null(name)) 
[13:17:24.395]                               next
[13:17:24.395]                             if (!grepl(pattern, name)) 
[13:17:24.395]                               next
[13:17:24.395]                             invokeRestart(restart)
[13:17:24.395]                             muffled <- TRUE
[13:17:24.395]                             break
[13:17:24.395]                           }
[13:17:24.395]                         }
[13:17:24.395]                       }
[13:17:24.395]                       invisible(muffled)
[13:17:24.395]                     }
[13:17:24.395]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.395]                   }
[13:17:24.395]                 }
[13:17:24.395]             }
[13:17:24.395]         }))
[13:17:24.395]     }, error = function(ex) {
[13:17:24.395]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.395]                 ...future.rng), started = ...future.startTime, 
[13:17:24.395]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.395]             version = "1.8"), class = "FutureResult")
[13:17:24.395]     }, finally = {
[13:17:24.395]         if (!identical(...future.workdir, getwd())) 
[13:17:24.395]             setwd(...future.workdir)
[13:17:24.395]         {
[13:17:24.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.395]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.395]             }
[13:17:24.395]             base::options(...future.oldOptions)
[13:17:24.395]             if (.Platform$OS.type == "windows") {
[13:17:24.395]                 old_names <- names(...future.oldEnvVars)
[13:17:24.395]                 envs <- base::Sys.getenv()
[13:17:24.395]                 names <- names(envs)
[13:17:24.395]                 common <- intersect(names, old_names)
[13:17:24.395]                 added <- setdiff(names, old_names)
[13:17:24.395]                 removed <- setdiff(old_names, names)
[13:17:24.395]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.395]                   envs[common]]
[13:17:24.395]                 NAMES <- toupper(changed)
[13:17:24.395]                 args <- list()
[13:17:24.395]                 for (kk in seq_along(NAMES)) {
[13:17:24.395]                   name <- changed[[kk]]
[13:17:24.395]                   NAME <- NAMES[[kk]]
[13:17:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.395]                     next
[13:17:24.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.395]                 }
[13:17:24.395]                 NAMES <- toupper(added)
[13:17:24.395]                 for (kk in seq_along(NAMES)) {
[13:17:24.395]                   name <- added[[kk]]
[13:17:24.395]                   NAME <- NAMES[[kk]]
[13:17:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.395]                     next
[13:17:24.395]                   args[[name]] <- ""
[13:17:24.395]                 }
[13:17:24.395]                 NAMES <- toupper(removed)
[13:17:24.395]                 for (kk in seq_along(NAMES)) {
[13:17:24.395]                   name <- removed[[kk]]
[13:17:24.395]                   NAME <- NAMES[[kk]]
[13:17:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.395]                     next
[13:17:24.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.395]                 }
[13:17:24.395]                 if (length(args) > 0) 
[13:17:24.395]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.395]             }
[13:17:24.395]             else {
[13:17:24.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.395]             }
[13:17:24.395]             {
[13:17:24.395]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.395]                   0L) {
[13:17:24.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.395]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.395]                   base::options(opts)
[13:17:24.395]                 }
[13:17:24.395]                 {
[13:17:24.395]                   {
[13:17:24.395]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.395]                     NULL
[13:17:24.395]                   }
[13:17:24.395]                   options(future.plan = NULL)
[13:17:24.395]                   if (is.na(NA_character_)) 
[13:17:24.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.395]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.395]                     envir = parent.frame()) 
[13:17:24.395]                   {
[13:17:24.395]                     default_workers <- missing(workers)
[13:17:24.395]                     if (is.function(workers)) 
[13:17:24.395]                       workers <- workers()
[13:17:24.395]                     workers <- structure(as.integer(workers), 
[13:17:24.395]                       class = class(workers))
[13:17:24.395]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.395]                       1L)
[13:17:24.395]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.395]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.395]                       if (default_workers) 
[13:17:24.395]                         supportsMulticore(warn = TRUE)
[13:17:24.395]                       return(sequential(..., envir = envir))
[13:17:24.395]                     }
[13:17:24.395]                     oopts <- options(mc.cores = workers)
[13:17:24.395]                     on.exit(options(oopts))
[13:17:24.395]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.395]                       envir = envir)
[13:17:24.395]                     if (!future$lazy) 
[13:17:24.395]                       future <- run(future)
[13:17:24.395]                     invisible(future)
[13:17:24.395]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.395]                 }
[13:17:24.395]             }
[13:17:24.395]         }
[13:17:24.395]     })
[13:17:24.395]     if (TRUE) {
[13:17:24.395]         base::sink(type = "output", split = FALSE)
[13:17:24.395]         if (TRUE) {
[13:17:24.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.395]         }
[13:17:24.395]         else {
[13:17:24.395]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.395]         }
[13:17:24.395]         base::close(...future.stdout)
[13:17:24.395]         ...future.stdout <- NULL
[13:17:24.395]     }
[13:17:24.395]     ...future.result$conditions <- ...future.conditions
[13:17:24.395]     ...future.result$finished <- base::Sys.time()
[13:17:24.395]     ...future.result
[13:17:24.395] }
[13:17:24.398] assign_globals() ...
[13:17:24.398] List of 5
[13:17:24.398]  $ future.call.arguments    : list()
[13:17:24.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.398]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.398]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.398]  $ ...future.elements_ii    :List of 1
[13:17:24.398]   ..$ : num [1:4] 2 4 6 8
[13:17:24.398]  $ ...future.seeds_ii       : NULL
[13:17:24.398]  $ ...future.globals.maxSize: NULL
[13:17:24.398]  - attr(*, "where")=List of 5
[13:17:24.398]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.398]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.398]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.398]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.398]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.398]  - attr(*, "resolved")= logi FALSE
[13:17:24.398]  - attr(*, "total_size")= num NA
[13:17:24.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.398]  - attr(*, "already-done")= logi TRUE
[13:17:24.407] - copied ‘future.call.arguments’ to environment
[13:17:24.407] - copied ‘...future.FUN’ to environment
[13:17:24.407] - copied ‘...future.elements_ii’ to environment
[13:17:24.407] - copied ‘...future.seeds_ii’ to environment
[13:17:24.408] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.408] assign_globals() ... done
[13:17:24.408] requestCore(): workers = 2
[13:17:24.414] MulticoreFuture started
[13:17:24.414] - Launch lazy future ... done
[13:17:24.414] run() for ‘MulticoreFuture’ ... done
[13:17:24.414] Created future:
[13:17:24.415] plan(): Setting new future strategy stack:
[13:17:24.415] List of future strategies:
[13:17:24.415] 1. sequential:
[13:17:24.415]    - args: function (..., envir = parent.frame())
[13:17:24.415]    - tweaked: FALSE
[13:17:24.415]    - call: NULL
[13:17:24.416] plan(): nbrOfWorkers() = 1
[13:17:24.418] plan(): Setting new future strategy stack:
[13:17:24.418] List of future strategies:
[13:17:24.418] 1. multicore:
[13:17:24.418]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.418]    - tweaked: FALSE
[13:17:24.418]    - call: plan(strategy)
[13:17:24.424] plan(): nbrOfWorkers() = 2
[13:17:24.415] MulticoreFuture:
[13:17:24.415] Label: ‘future_apply-2’
[13:17:24.415] Expression:
[13:17:24.415] {
[13:17:24.415]     do.call(function(...) {
[13:17:24.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.415]             on.exit(options(oopts), add = TRUE)
[13:17:24.415]         }
[13:17:24.415]         {
[13:17:24.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.415]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.415]             })
[13:17:24.415]         }
[13:17:24.415]     }, args = future.call.arguments)
[13:17:24.415] }
[13:17:24.415] Lazy evaluation: FALSE
[13:17:24.415] Asynchronous evaluation: TRUE
[13:17:24.415] Local evaluation: TRUE
[13:17:24.415] Environment: R_GlobalEnv
[13:17:24.415] Capture standard output: TRUE
[13:17:24.415] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.415] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.415] Packages: <none>
[13:17:24.415] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.415] Resolved: TRUE
[13:17:24.415] Value: <not collected>
[13:17:24.415] Conditions captured: <none>
[13:17:24.415] Early signaling: FALSE
[13:17:24.415] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.415] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.425] Chunk #2 of 2 ... DONE
[13:17:24.425] Launching 2 futures (chunks) ... DONE
[13:17:24.425] Resolving 2 futures (chunks) ...
[13:17:24.425] resolve() on list ...
[13:17:24.426]  recursive: 0
[13:17:24.426]  length: 2
[13:17:24.426] 
[13:17:24.426] Future #1
[13:17:24.428] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:24.429] - nx: 2
[13:17:24.429] - relay: TRUE
[13:17:24.429] - stdout: TRUE
[13:17:24.429] - signal: TRUE
[13:17:24.429] - resignal: FALSE
[13:17:24.429] - force: TRUE
[13:17:24.429] - relayed: [n=2] FALSE, FALSE
[13:17:24.430] - queued futures: [n=2] FALSE, FALSE
[13:17:24.430]  - until=1
[13:17:24.430]  - relaying element #1
[13:17:24.430] - relayed: [n=2] TRUE, FALSE
[13:17:24.430] - queued futures: [n=2] TRUE, FALSE
[13:17:24.431] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:24.431]  length: 1 (resolved future 1)
[13:17:24.431] Future #2
[13:17:24.432] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:24.432] - nx: 2
[13:17:24.432] - relay: TRUE
[13:17:24.432] - stdout: TRUE
[13:17:24.432] - signal: TRUE
[13:17:24.433] - resignal: FALSE
[13:17:24.433] - force: TRUE
[13:17:24.433] - relayed: [n=2] TRUE, FALSE
[13:17:24.433] - queued futures: [n=2] TRUE, FALSE
[13:17:24.433]  - until=2
[13:17:24.433]  - relaying element #2
[13:17:24.433] - relayed: [n=2] TRUE, TRUE
[13:17:24.433] - queued futures: [n=2] TRUE, TRUE
[13:17:24.434] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:24.434]  length: 0 (resolved future 2)
[13:17:24.434] Relaying remaining futures
[13:17:24.434] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.434] - nx: 2
[13:17:24.434] - relay: TRUE
[13:17:24.434] - stdout: TRUE
[13:17:24.434] - signal: TRUE
[13:17:24.434] - resignal: FALSE
[13:17:24.435] - force: TRUE
[13:17:24.435] - relayed: [n=2] TRUE, TRUE
[13:17:24.435] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:24.435] - relayed: [n=2] TRUE, TRUE
[13:17:24.435] - queued futures: [n=2] TRUE, TRUE
[13:17:24.435] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.435] resolve() on list ... DONE
[13:17:24.436]  - Number of value chunks collected: 2
[13:17:24.436] Resolving 2 futures (chunks) ... DONE
[13:17:24.436] Reducing values from 2 chunks ...
[13:17:24.436]  - Number of values collected after concatenation: 2
[13:17:24.436]  - Number of values expected: 2
[13:17:24.436] Reducing values from 2 chunks ... DONE
[13:17:24.436] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:17:24.437] getGlobalsAndPackagesXApply() ...
[13:17:24.437]  - future.globals: TRUE
[13:17:24.437] getGlobalsAndPackages() ...
[13:17:24.437] Searching for globals...
[13:17:24.479] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:17:24.479] Searching for globals ... DONE
[13:17:24.479] Resolving globals: FALSE
[13:17:24.481] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:17:24.482] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:17:24.482] - globals: [1] ‘FUN’
[13:17:24.482] 
[13:17:24.482] getGlobalsAndPackages() ... DONE
[13:17:24.482]  - globals found/used: [n=1] ‘FUN’
[13:17:24.482]  - needed namespaces: [n=0] 
[13:17:24.482] Finding globals ... DONE
[13:17:24.482]  - use_args: TRUE
[13:17:24.482]  - Getting '...' globals ...
[13:17:24.483] resolve() on list ...
[13:17:24.483]  recursive: 0
[13:17:24.483]  length: 1
[13:17:24.483]  elements: ‘...’
[13:17:24.483]  length: 0 (resolved future 1)
[13:17:24.483] resolve() on list ... DONE
[13:17:24.483]    - '...' content: [n=0] 
[13:17:24.483] List of 1
[13:17:24.483]  $ ...: list()
[13:17:24.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.483]  - attr(*, "where")=List of 1
[13:17:24.483]   ..$ ...:<environment: 0x5647bb0c71d8> 
[13:17:24.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.483]  - attr(*, "resolved")= logi TRUE
[13:17:24.483]  - attr(*, "total_size")= num NA
[13:17:24.486]  - Getting '...' globals ... DONE
[13:17:24.486] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.486] List of 2
[13:17:24.486]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.486]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.486]  $ ...          : list()
[13:17:24.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.486]  - attr(*, "where")=List of 2
[13:17:24.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.486]   ..$ ...          :<environment: 0x5647bb0c71d8> 
[13:17:24.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.486]  - attr(*, "resolved")= logi FALSE
[13:17:24.486]  - attr(*, "total_size")= num 354224
[13:17:24.489] Packages to be attached in all futures: [n=0] 
[13:17:24.489] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.493] future_lapply() ...
[13:17:24.529] Number of chunks: 2
[13:17:24.529] getGlobalsAndPackagesXApply() ...
[13:17:24.529]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.530]  - use_args: TRUE
[13:17:24.530] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.530] List of 2
[13:17:24.530]  $ ...          : list()
[13:17:24.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.530]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.530]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.530]  - attr(*, "where")=List of 2
[13:17:24.530]   ..$ ...          :<environment: 0x5647bb0c71d8> 
[13:17:24.530]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.530]  - attr(*, "resolved")= logi FALSE
[13:17:24.530]  - attr(*, "total_size")= num NA
[13:17:24.533] Packages to be attached in all futures: [n=0] 
[13:17:24.533] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.534] Number of futures (= number of chunks): 2
[13:17:24.534] Launching 2 futures (chunks) ...
[13:17:24.534] Chunk #1 of 2 ...
[13:17:24.534]  - seeds: <none>
[13:17:24.534] getGlobalsAndPackages() ...
[13:17:24.534] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.534] Resolving globals: FALSE
[13:17:24.534] Tweak future expression to call with '...' arguments ...
[13:17:24.534] {
[13:17:24.534]     do.call(function(...) {
[13:17:24.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.534]             on.exit(options(oopts), add = TRUE)
[13:17:24.534]         }
[13:17:24.534]         {
[13:17:24.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.534]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.534]             })
[13:17:24.534]         }
[13:17:24.534]     }, args = future.call.arguments)
[13:17:24.534] }
[13:17:24.535] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.535] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.535] 
[13:17:24.535] getGlobalsAndPackages() ... DONE
[13:17:24.537] run() for ‘Future’ ...
[13:17:24.537] - state: ‘created’
[13:17:24.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.541]   - Field: ‘label’
[13:17:24.541]   - Field: ‘local’
[13:17:24.542]   - Field: ‘owner’
[13:17:24.542]   - Field: ‘envir’
[13:17:24.542]   - Field: ‘workers’
[13:17:24.542]   - Field: ‘packages’
[13:17:24.542]   - Field: ‘gc’
[13:17:24.542]   - Field: ‘job’
[13:17:24.542]   - Field: ‘conditions’
[13:17:24.542]   - Field: ‘expr’
[13:17:24.542]   - Field: ‘uuid’
[13:17:24.542]   - Field: ‘seed’
[13:17:24.542]   - Field: ‘version’
[13:17:24.543]   - Field: ‘result’
[13:17:24.543]   - Field: ‘asynchronous’
[13:17:24.543]   - Field: ‘calls’
[13:17:24.543]   - Field: ‘globals’
[13:17:24.543]   - Field: ‘stdout’
[13:17:24.543]   - Field: ‘earlySignal’
[13:17:24.543]   - Field: ‘lazy’
[13:17:24.543]   - Field: ‘state’
[13:17:24.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.543] - Launch lazy future ...
[13:17:24.544] Packages needed by the future expression (n = 0): <none>
[13:17:24.544] Packages needed by future strategies (n = 0): <none>
[13:17:24.544] {
[13:17:24.544]     {
[13:17:24.544]         {
[13:17:24.544]             ...future.startTime <- base::Sys.time()
[13:17:24.544]             {
[13:17:24.544]                 {
[13:17:24.544]                   {
[13:17:24.544]                     {
[13:17:24.544]                       base::local({
[13:17:24.544]                         has_future <- base::requireNamespace("future", 
[13:17:24.544]                           quietly = TRUE)
[13:17:24.544]                         if (has_future) {
[13:17:24.544]                           ns <- base::getNamespace("future")
[13:17:24.544]                           version <- ns[[".package"]][["version"]]
[13:17:24.544]                           if (is.null(version)) 
[13:17:24.544]                             version <- utils::packageVersion("future")
[13:17:24.544]                         }
[13:17:24.544]                         else {
[13:17:24.544]                           version <- NULL
[13:17:24.544]                         }
[13:17:24.544]                         if (!has_future || version < "1.8.0") {
[13:17:24.544]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.544]                             "", base::R.version$version.string), 
[13:17:24.544]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.544]                               "release", "version")], collapse = " "), 
[13:17:24.544]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.544]                             info)
[13:17:24.544]                           info <- base::paste(info, collapse = "; ")
[13:17:24.544]                           if (!has_future) {
[13:17:24.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.544]                               info)
[13:17:24.544]                           }
[13:17:24.544]                           else {
[13:17:24.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.544]                               info, version)
[13:17:24.544]                           }
[13:17:24.544]                           base::stop(msg)
[13:17:24.544]                         }
[13:17:24.544]                       })
[13:17:24.544]                     }
[13:17:24.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.544]                     base::options(mc.cores = 1L)
[13:17:24.544]                   }
[13:17:24.544]                   options(future.plan = NULL)
[13:17:24.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.544]                 }
[13:17:24.544]                 ...future.workdir <- getwd()
[13:17:24.544]             }
[13:17:24.544]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.544]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.544]         }
[13:17:24.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.544]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.544]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.544]             base::names(...future.oldOptions))
[13:17:24.544]     }
[13:17:24.544]     if (FALSE) {
[13:17:24.544]     }
[13:17:24.544]     else {
[13:17:24.544]         if (TRUE) {
[13:17:24.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.544]                 open = "w")
[13:17:24.544]         }
[13:17:24.544]         else {
[13:17:24.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.544]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.544]         }
[13:17:24.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.544]             base::sink(type = "output", split = FALSE)
[13:17:24.544]             base::close(...future.stdout)
[13:17:24.544]         }, add = TRUE)
[13:17:24.544]     }
[13:17:24.544]     ...future.frame <- base::sys.nframe()
[13:17:24.544]     ...future.conditions <- base::list()
[13:17:24.544]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.544]     if (FALSE) {
[13:17:24.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.544]     }
[13:17:24.544]     ...future.result <- base::tryCatch({
[13:17:24.544]         base::withCallingHandlers({
[13:17:24.544]             ...future.value <- base::withVisible(base::local({
[13:17:24.544]                 withCallingHandlers({
[13:17:24.544]                   {
[13:17:24.544]                     do.call(function(...) {
[13:17:24.544]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.544]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.544]                         ...future.globals.maxSize)) {
[13:17:24.544]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.544]                         on.exit(options(oopts), add = TRUE)
[13:17:24.544]                       }
[13:17:24.544]                       {
[13:17:24.544]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.544]                           FUN = function(jj) {
[13:17:24.544]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.544]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.544]                           })
[13:17:24.544]                       }
[13:17:24.544]                     }, args = future.call.arguments)
[13:17:24.544]                   }
[13:17:24.544]                 }, immediateCondition = function(cond) {
[13:17:24.544]                   save_rds <- function (object, pathname, ...) 
[13:17:24.544]                   {
[13:17:24.544]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.544]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.544]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.544]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.544]                         fi_tmp[["mtime"]])
[13:17:24.544]                     }
[13:17:24.544]                     tryCatch({
[13:17:24.544]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.544]                     }, error = function(ex) {
[13:17:24.544]                       msg <- conditionMessage(ex)
[13:17:24.544]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.544]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.544]                         fi_tmp[["mtime"]], msg)
[13:17:24.544]                       ex$message <- msg
[13:17:24.544]                       stop(ex)
[13:17:24.544]                     })
[13:17:24.544]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.544]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.544]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.544]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.544]                       fi <- file.info(pathname)
[13:17:24.544]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.544]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.544]                         fi[["size"]], fi[["mtime"]])
[13:17:24.544]                       stop(msg)
[13:17:24.544]                     }
[13:17:24.544]                     invisible(pathname)
[13:17:24.544]                   }
[13:17:24.544]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.544]                     rootPath = tempdir()) 
[13:17:24.544]                   {
[13:17:24.544]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.544]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.544]                       tmpdir = path, fileext = ".rds")
[13:17:24.544]                     save_rds(obj, file)
[13:17:24.544]                   }
[13:17:24.544]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.544]                   {
[13:17:24.544]                     inherits <- base::inherits
[13:17:24.544]                     invokeRestart <- base::invokeRestart
[13:17:24.544]                     is.null <- base::is.null
[13:17:24.544]                     muffled <- FALSE
[13:17:24.544]                     if (inherits(cond, "message")) {
[13:17:24.544]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.544]                       if (muffled) 
[13:17:24.544]                         invokeRestart("muffleMessage")
[13:17:24.544]                     }
[13:17:24.544]                     else if (inherits(cond, "warning")) {
[13:17:24.544]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.544]                       if (muffled) 
[13:17:24.544]                         invokeRestart("muffleWarning")
[13:17:24.544]                     }
[13:17:24.544]                     else if (inherits(cond, "condition")) {
[13:17:24.544]                       if (!is.null(pattern)) {
[13:17:24.544]                         computeRestarts <- base::computeRestarts
[13:17:24.544]                         grepl <- base::grepl
[13:17:24.544]                         restarts <- computeRestarts(cond)
[13:17:24.544]                         for (restart in restarts) {
[13:17:24.544]                           name <- restart$name
[13:17:24.544]                           if (is.null(name)) 
[13:17:24.544]                             next
[13:17:24.544]                           if (!grepl(pattern, name)) 
[13:17:24.544]                             next
[13:17:24.544]                           invokeRestart(restart)
[13:17:24.544]                           muffled <- TRUE
[13:17:24.544]                           break
[13:17:24.544]                         }
[13:17:24.544]                       }
[13:17:24.544]                     }
[13:17:24.544]                     invisible(muffled)
[13:17:24.544]                   }
[13:17:24.544]                   muffleCondition(cond)
[13:17:24.544]                 })
[13:17:24.544]             }))
[13:17:24.544]             future::FutureResult(value = ...future.value$value, 
[13:17:24.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.544]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.544]                     ...future.globalenv.names))
[13:17:24.544]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.544]         }, condition = base::local({
[13:17:24.544]             c <- base::c
[13:17:24.544]             inherits <- base::inherits
[13:17:24.544]             invokeRestart <- base::invokeRestart
[13:17:24.544]             length <- base::length
[13:17:24.544]             list <- base::list
[13:17:24.544]             seq.int <- base::seq.int
[13:17:24.544]             signalCondition <- base::signalCondition
[13:17:24.544]             sys.calls <- base::sys.calls
[13:17:24.544]             `[[` <- base::`[[`
[13:17:24.544]             `+` <- base::`+`
[13:17:24.544]             `<<-` <- base::`<<-`
[13:17:24.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.544]                   3L)]
[13:17:24.544]             }
[13:17:24.544]             function(cond) {
[13:17:24.544]                 is_error <- inherits(cond, "error")
[13:17:24.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.544]                   NULL)
[13:17:24.544]                 if (is_error) {
[13:17:24.544]                   sessionInformation <- function() {
[13:17:24.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.544]                       search = base::search(), system = base::Sys.info())
[13:17:24.544]                   }
[13:17:24.544]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.544]                     cond$call), session = sessionInformation(), 
[13:17:24.544]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.544]                   signalCondition(cond)
[13:17:24.544]                 }
[13:17:24.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.544]                 "immediateCondition"))) {
[13:17:24.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.544]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.544]                   if (TRUE && !signal) {
[13:17:24.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.544]                     {
[13:17:24.544]                       inherits <- base::inherits
[13:17:24.544]                       invokeRestart <- base::invokeRestart
[13:17:24.544]                       is.null <- base::is.null
[13:17:24.544]                       muffled <- FALSE
[13:17:24.544]                       if (inherits(cond, "message")) {
[13:17:24.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.544]                         if (muffled) 
[13:17:24.544]                           invokeRestart("muffleMessage")
[13:17:24.544]                       }
[13:17:24.544]                       else if (inherits(cond, "warning")) {
[13:17:24.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.544]                         if (muffled) 
[13:17:24.544]                           invokeRestart("muffleWarning")
[13:17:24.544]                       }
[13:17:24.544]                       else if (inherits(cond, "condition")) {
[13:17:24.544]                         if (!is.null(pattern)) {
[13:17:24.544]                           computeRestarts <- base::computeRestarts
[13:17:24.544]                           grepl <- base::grepl
[13:17:24.544]                           restarts <- computeRestarts(cond)
[13:17:24.544]                           for (restart in restarts) {
[13:17:24.544]                             name <- restart$name
[13:17:24.544]                             if (is.null(name)) 
[13:17:24.544]                               next
[13:17:24.544]                             if (!grepl(pattern, name)) 
[13:17:24.544]                               next
[13:17:24.544]                             invokeRestart(restart)
[13:17:24.544]                             muffled <- TRUE
[13:17:24.544]                             break
[13:17:24.544]                           }
[13:17:24.544]                         }
[13:17:24.544]                       }
[13:17:24.544]                       invisible(muffled)
[13:17:24.544]                     }
[13:17:24.544]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.544]                   }
[13:17:24.544]                 }
[13:17:24.544]                 else {
[13:17:24.544]                   if (TRUE) {
[13:17:24.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.544]                     {
[13:17:24.544]                       inherits <- base::inherits
[13:17:24.544]                       invokeRestart <- base::invokeRestart
[13:17:24.544]                       is.null <- base::is.null
[13:17:24.544]                       muffled <- FALSE
[13:17:24.544]                       if (inherits(cond, "message")) {
[13:17:24.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.544]                         if (muffled) 
[13:17:24.544]                           invokeRestart("muffleMessage")
[13:17:24.544]                       }
[13:17:24.544]                       else if (inherits(cond, "warning")) {
[13:17:24.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.544]                         if (muffled) 
[13:17:24.544]                           invokeRestart("muffleWarning")
[13:17:24.544]                       }
[13:17:24.544]                       else if (inherits(cond, "condition")) {
[13:17:24.544]                         if (!is.null(pattern)) {
[13:17:24.544]                           computeRestarts <- base::computeRestarts
[13:17:24.544]                           grepl <- base::grepl
[13:17:24.544]                           restarts <- computeRestarts(cond)
[13:17:24.544]                           for (restart in restarts) {
[13:17:24.544]                             name <- restart$name
[13:17:24.544]                             if (is.null(name)) 
[13:17:24.544]                               next
[13:17:24.544]                             if (!grepl(pattern, name)) 
[13:17:24.544]                               next
[13:17:24.544]                             invokeRestart(restart)
[13:17:24.544]                             muffled <- TRUE
[13:17:24.544]                             break
[13:17:24.544]                           }
[13:17:24.544]                         }
[13:17:24.544]                       }
[13:17:24.544]                       invisible(muffled)
[13:17:24.544]                     }
[13:17:24.544]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.544]                   }
[13:17:24.544]                 }
[13:17:24.544]             }
[13:17:24.544]         }))
[13:17:24.544]     }, error = function(ex) {
[13:17:24.544]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.544]                 ...future.rng), started = ...future.startTime, 
[13:17:24.544]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.544]             version = "1.8"), class = "FutureResult")
[13:17:24.544]     }, finally = {
[13:17:24.544]         if (!identical(...future.workdir, getwd())) 
[13:17:24.544]             setwd(...future.workdir)
[13:17:24.544]         {
[13:17:24.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.544]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.544]             }
[13:17:24.544]             base::options(...future.oldOptions)
[13:17:24.544]             if (.Platform$OS.type == "windows") {
[13:17:24.544]                 old_names <- names(...future.oldEnvVars)
[13:17:24.544]                 envs <- base::Sys.getenv()
[13:17:24.544]                 names <- names(envs)
[13:17:24.544]                 common <- intersect(names, old_names)
[13:17:24.544]                 added <- setdiff(names, old_names)
[13:17:24.544]                 removed <- setdiff(old_names, names)
[13:17:24.544]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.544]                   envs[common]]
[13:17:24.544]                 NAMES <- toupper(changed)
[13:17:24.544]                 args <- list()
[13:17:24.544]                 for (kk in seq_along(NAMES)) {
[13:17:24.544]                   name <- changed[[kk]]
[13:17:24.544]                   NAME <- NAMES[[kk]]
[13:17:24.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.544]                     next
[13:17:24.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.544]                 }
[13:17:24.544]                 NAMES <- toupper(added)
[13:17:24.544]                 for (kk in seq_along(NAMES)) {
[13:17:24.544]                   name <- added[[kk]]
[13:17:24.544]                   NAME <- NAMES[[kk]]
[13:17:24.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.544]                     next
[13:17:24.544]                   args[[name]] <- ""
[13:17:24.544]                 }
[13:17:24.544]                 NAMES <- toupper(removed)
[13:17:24.544]                 for (kk in seq_along(NAMES)) {
[13:17:24.544]                   name <- removed[[kk]]
[13:17:24.544]                   NAME <- NAMES[[kk]]
[13:17:24.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.544]                     next
[13:17:24.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.544]                 }
[13:17:24.544]                 if (length(args) > 0) 
[13:17:24.544]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.544]             }
[13:17:24.544]             else {
[13:17:24.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.544]             }
[13:17:24.544]             {
[13:17:24.544]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.544]                   0L) {
[13:17:24.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.544]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.544]                   base::options(opts)
[13:17:24.544]                 }
[13:17:24.544]                 {
[13:17:24.544]                   {
[13:17:24.544]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.544]                     NULL
[13:17:24.544]                   }
[13:17:24.544]                   options(future.plan = NULL)
[13:17:24.544]                   if (is.na(NA_character_)) 
[13:17:24.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.544]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.544]                     envir = parent.frame()) 
[13:17:24.544]                   {
[13:17:24.544]                     default_workers <- missing(workers)
[13:17:24.544]                     if (is.function(workers)) 
[13:17:24.544]                       workers <- workers()
[13:17:24.544]                     workers <- structure(as.integer(workers), 
[13:17:24.544]                       class = class(workers))
[13:17:24.544]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.544]                       1L)
[13:17:24.544]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.544]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.544]                       if (default_workers) 
[13:17:24.544]                         supportsMulticore(warn = TRUE)
[13:17:24.544]                       return(sequential(..., envir = envir))
[13:17:24.544]                     }
[13:17:24.544]                     oopts <- options(mc.cores = workers)
[13:17:24.544]                     on.exit(options(oopts))
[13:17:24.544]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.544]                       envir = envir)
[13:17:24.544]                     if (!future$lazy) 
[13:17:24.544]                       future <- run(future)
[13:17:24.544]                     invisible(future)
[13:17:24.544]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.544]                 }
[13:17:24.544]             }
[13:17:24.544]         }
[13:17:24.544]     })
[13:17:24.544]     if (TRUE) {
[13:17:24.544]         base::sink(type = "output", split = FALSE)
[13:17:24.544]         if (TRUE) {
[13:17:24.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.544]         }
[13:17:24.544]         else {
[13:17:24.544]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.544]         }
[13:17:24.544]         base::close(...future.stdout)
[13:17:24.544]         ...future.stdout <- NULL
[13:17:24.544]     }
[13:17:24.544]     ...future.result$conditions <- ...future.conditions
[13:17:24.544]     ...future.result$finished <- base::Sys.time()
[13:17:24.544]     ...future.result
[13:17:24.544] }
[13:17:24.547] assign_globals() ...
[13:17:24.547] List of 5
[13:17:24.547]  $ future.call.arguments    : list()
[13:17:24.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.547]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.547]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.547]  $ ...future.elements_ii    :List of 1
[13:17:24.547]   ..$ : num [1:4] 1 3 1 7
[13:17:24.547]  $ ...future.seeds_ii       : NULL
[13:17:24.547]  $ ...future.globals.maxSize: NULL
[13:17:24.547]  - attr(*, "where")=List of 5
[13:17:24.547]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.547]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.547]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.547]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.547]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.547]  - attr(*, "resolved")= logi FALSE
[13:17:24.547]  - attr(*, "total_size")= num NA
[13:17:24.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.547]  - attr(*, "already-done")= logi TRUE
[13:17:24.551] - copied ‘future.call.arguments’ to environment
[13:17:24.552] - copied ‘...future.FUN’ to environment
[13:17:24.552] - copied ‘...future.elements_ii’ to environment
[13:17:24.552] - copied ‘...future.seeds_ii’ to environment
[13:17:24.552] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.552] assign_globals() ... done
[13:17:24.552] requestCore(): workers = 2
[13:17:24.554] MulticoreFuture started
[13:17:24.555] - Launch lazy future ... done
[13:17:24.555] run() for ‘MulticoreFuture’ ... done
[13:17:24.555] Created future:
[13:17:24.555] plan(): Setting new future strategy stack:
[13:17:24.556] List of future strategies:
[13:17:24.556] 1. sequential:
[13:17:24.556]    - args: function (..., envir = parent.frame())
[13:17:24.556]    - tweaked: FALSE
[13:17:24.556]    - call: NULL
[13:17:24.556] plan(): nbrOfWorkers() = 1
[13:17:24.559] plan(): Setting new future strategy stack:
[13:17:24.559] List of future strategies:
[13:17:24.559] 1. multicore:
[13:17:24.559]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.559]    - tweaked: FALSE
[13:17:24.559]    - call: plan(strategy)
[13:17:24.564] plan(): nbrOfWorkers() = 2
[13:17:24.555] MulticoreFuture:
[13:17:24.555] Label: ‘future_apply-1’
[13:17:24.555] Expression:
[13:17:24.555] {
[13:17:24.555]     do.call(function(...) {
[13:17:24.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.555]             on.exit(options(oopts), add = TRUE)
[13:17:24.555]         }
[13:17:24.555]         {
[13:17:24.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.555]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.555]             })
[13:17:24.555]         }
[13:17:24.555]     }, args = future.call.arguments)
[13:17:24.555] }
[13:17:24.555] Lazy evaluation: FALSE
[13:17:24.555] Asynchronous evaluation: TRUE
[13:17:24.555] Local evaluation: TRUE
[13:17:24.555] Environment: R_GlobalEnv
[13:17:24.555] Capture standard output: TRUE
[13:17:24.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.555] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.555] Packages: <none>
[13:17:24.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.555] Resolved: TRUE
[13:17:24.555] Value: <not collected>
[13:17:24.555] Conditions captured: <none>
[13:17:24.555] Early signaling: FALSE
[13:17:24.555] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.555] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.565] Chunk #1 of 2 ... DONE
[13:17:24.565] Chunk #2 of 2 ...
[13:17:24.565]  - seeds: <none>
[13:17:24.566] getGlobalsAndPackages() ...
[13:17:24.566] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.566] Resolving globals: FALSE
[13:17:24.566] Tweak future expression to call with '...' arguments ...
[13:17:24.566] {
[13:17:24.566]     do.call(function(...) {
[13:17:24.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.566]             on.exit(options(oopts), add = TRUE)
[13:17:24.566]         }
[13:17:24.566]         {
[13:17:24.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.566]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.566]             })
[13:17:24.566]         }
[13:17:24.566]     }, args = future.call.arguments)
[13:17:24.566] }
[13:17:24.567] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.567] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.568] 
[13:17:24.568] getGlobalsAndPackages() ... DONE
[13:17:24.568] run() for ‘Future’ ...
[13:17:24.568] - state: ‘created’
[13:17:24.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.573] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.573]   - Field: ‘label’
[13:17:24.573]   - Field: ‘local’
[13:17:24.573]   - Field: ‘owner’
[13:17:24.574]   - Field: ‘envir’
[13:17:24.574]   - Field: ‘workers’
[13:17:24.574]   - Field: ‘packages’
[13:17:24.574]   - Field: ‘gc’
[13:17:24.574]   - Field: ‘job’
[13:17:24.574]   - Field: ‘conditions’
[13:17:24.574]   - Field: ‘expr’
[13:17:24.575]   - Field: ‘uuid’
[13:17:24.575]   - Field: ‘seed’
[13:17:24.575]   - Field: ‘version’
[13:17:24.575]   - Field: ‘result’
[13:17:24.575]   - Field: ‘asynchronous’
[13:17:24.575]   - Field: ‘calls’
[13:17:24.575]   - Field: ‘globals’
[13:17:24.576]   - Field: ‘stdout’
[13:17:24.576]   - Field: ‘earlySignal’
[13:17:24.576]   - Field: ‘lazy’
[13:17:24.576]   - Field: ‘state’
[13:17:24.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.576] - Launch lazy future ...
[13:17:24.577] Packages needed by the future expression (n = 0): <none>
[13:17:24.577] Packages needed by future strategies (n = 0): <none>
[13:17:24.578] {
[13:17:24.578]     {
[13:17:24.578]         {
[13:17:24.578]             ...future.startTime <- base::Sys.time()
[13:17:24.578]             {
[13:17:24.578]                 {
[13:17:24.578]                   {
[13:17:24.578]                     {
[13:17:24.578]                       base::local({
[13:17:24.578]                         has_future <- base::requireNamespace("future", 
[13:17:24.578]                           quietly = TRUE)
[13:17:24.578]                         if (has_future) {
[13:17:24.578]                           ns <- base::getNamespace("future")
[13:17:24.578]                           version <- ns[[".package"]][["version"]]
[13:17:24.578]                           if (is.null(version)) 
[13:17:24.578]                             version <- utils::packageVersion("future")
[13:17:24.578]                         }
[13:17:24.578]                         else {
[13:17:24.578]                           version <- NULL
[13:17:24.578]                         }
[13:17:24.578]                         if (!has_future || version < "1.8.0") {
[13:17:24.578]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.578]                             "", base::R.version$version.string), 
[13:17:24.578]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.578]                               "release", "version")], collapse = " "), 
[13:17:24.578]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.578]                             info)
[13:17:24.578]                           info <- base::paste(info, collapse = "; ")
[13:17:24.578]                           if (!has_future) {
[13:17:24.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.578]                               info)
[13:17:24.578]                           }
[13:17:24.578]                           else {
[13:17:24.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.578]                               info, version)
[13:17:24.578]                           }
[13:17:24.578]                           base::stop(msg)
[13:17:24.578]                         }
[13:17:24.578]                       })
[13:17:24.578]                     }
[13:17:24.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.578]                     base::options(mc.cores = 1L)
[13:17:24.578]                   }
[13:17:24.578]                   options(future.plan = NULL)
[13:17:24.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.578]                 }
[13:17:24.578]                 ...future.workdir <- getwd()
[13:17:24.578]             }
[13:17:24.578]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.578]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.578]         }
[13:17:24.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.578]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.578]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.578]             base::names(...future.oldOptions))
[13:17:24.578]     }
[13:17:24.578]     if (FALSE) {
[13:17:24.578]     }
[13:17:24.578]     else {
[13:17:24.578]         if (TRUE) {
[13:17:24.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.578]                 open = "w")
[13:17:24.578]         }
[13:17:24.578]         else {
[13:17:24.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.578]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.578]         }
[13:17:24.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.578]             base::sink(type = "output", split = FALSE)
[13:17:24.578]             base::close(...future.stdout)
[13:17:24.578]         }, add = TRUE)
[13:17:24.578]     }
[13:17:24.578]     ...future.frame <- base::sys.nframe()
[13:17:24.578]     ...future.conditions <- base::list()
[13:17:24.578]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.578]     if (FALSE) {
[13:17:24.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.578]     }
[13:17:24.578]     ...future.result <- base::tryCatch({
[13:17:24.578]         base::withCallingHandlers({
[13:17:24.578]             ...future.value <- base::withVisible(base::local({
[13:17:24.578]                 withCallingHandlers({
[13:17:24.578]                   {
[13:17:24.578]                     do.call(function(...) {
[13:17:24.578]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.578]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.578]                         ...future.globals.maxSize)) {
[13:17:24.578]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.578]                         on.exit(options(oopts), add = TRUE)
[13:17:24.578]                       }
[13:17:24.578]                       {
[13:17:24.578]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.578]                           FUN = function(jj) {
[13:17:24.578]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.578]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.578]                           })
[13:17:24.578]                       }
[13:17:24.578]                     }, args = future.call.arguments)
[13:17:24.578]                   }
[13:17:24.578]                 }, immediateCondition = function(cond) {
[13:17:24.578]                   save_rds <- function (object, pathname, ...) 
[13:17:24.578]                   {
[13:17:24.578]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.578]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.578]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.578]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.578]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.578]                         fi_tmp[["mtime"]])
[13:17:24.578]                     }
[13:17:24.578]                     tryCatch({
[13:17:24.578]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.578]                     }, error = function(ex) {
[13:17:24.578]                       msg <- conditionMessage(ex)
[13:17:24.578]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.578]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.578]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.578]                         fi_tmp[["mtime"]], msg)
[13:17:24.578]                       ex$message <- msg
[13:17:24.578]                       stop(ex)
[13:17:24.578]                     })
[13:17:24.578]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.578]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.578]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.578]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.578]                       fi <- file.info(pathname)
[13:17:24.578]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.578]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.578]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.578]                         fi[["size"]], fi[["mtime"]])
[13:17:24.578]                       stop(msg)
[13:17:24.578]                     }
[13:17:24.578]                     invisible(pathname)
[13:17:24.578]                   }
[13:17:24.578]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.578]                     rootPath = tempdir()) 
[13:17:24.578]                   {
[13:17:24.578]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.578]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.578]                       tmpdir = path, fileext = ".rds")
[13:17:24.578]                     save_rds(obj, file)
[13:17:24.578]                   }
[13:17:24.578]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.578]                   {
[13:17:24.578]                     inherits <- base::inherits
[13:17:24.578]                     invokeRestart <- base::invokeRestart
[13:17:24.578]                     is.null <- base::is.null
[13:17:24.578]                     muffled <- FALSE
[13:17:24.578]                     if (inherits(cond, "message")) {
[13:17:24.578]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.578]                       if (muffled) 
[13:17:24.578]                         invokeRestart("muffleMessage")
[13:17:24.578]                     }
[13:17:24.578]                     else if (inherits(cond, "warning")) {
[13:17:24.578]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.578]                       if (muffled) 
[13:17:24.578]                         invokeRestart("muffleWarning")
[13:17:24.578]                     }
[13:17:24.578]                     else if (inherits(cond, "condition")) {
[13:17:24.578]                       if (!is.null(pattern)) {
[13:17:24.578]                         computeRestarts <- base::computeRestarts
[13:17:24.578]                         grepl <- base::grepl
[13:17:24.578]                         restarts <- computeRestarts(cond)
[13:17:24.578]                         for (restart in restarts) {
[13:17:24.578]                           name <- restart$name
[13:17:24.578]                           if (is.null(name)) 
[13:17:24.578]                             next
[13:17:24.578]                           if (!grepl(pattern, name)) 
[13:17:24.578]                             next
[13:17:24.578]                           invokeRestart(restart)
[13:17:24.578]                           muffled <- TRUE
[13:17:24.578]                           break
[13:17:24.578]                         }
[13:17:24.578]                       }
[13:17:24.578]                     }
[13:17:24.578]                     invisible(muffled)
[13:17:24.578]                   }
[13:17:24.578]                   muffleCondition(cond)
[13:17:24.578]                 })
[13:17:24.578]             }))
[13:17:24.578]             future::FutureResult(value = ...future.value$value, 
[13:17:24.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.578]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.578]                     ...future.globalenv.names))
[13:17:24.578]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.578]         }, condition = base::local({
[13:17:24.578]             c <- base::c
[13:17:24.578]             inherits <- base::inherits
[13:17:24.578]             invokeRestart <- base::invokeRestart
[13:17:24.578]             length <- base::length
[13:17:24.578]             list <- base::list
[13:17:24.578]             seq.int <- base::seq.int
[13:17:24.578]             signalCondition <- base::signalCondition
[13:17:24.578]             sys.calls <- base::sys.calls
[13:17:24.578]             `[[` <- base::`[[`
[13:17:24.578]             `+` <- base::`+`
[13:17:24.578]             `<<-` <- base::`<<-`
[13:17:24.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.578]                   3L)]
[13:17:24.578]             }
[13:17:24.578]             function(cond) {
[13:17:24.578]                 is_error <- inherits(cond, "error")
[13:17:24.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.578]                   NULL)
[13:17:24.578]                 if (is_error) {
[13:17:24.578]                   sessionInformation <- function() {
[13:17:24.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.578]                       search = base::search(), system = base::Sys.info())
[13:17:24.578]                   }
[13:17:24.578]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.578]                     cond$call), session = sessionInformation(), 
[13:17:24.578]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.578]                   signalCondition(cond)
[13:17:24.578]                 }
[13:17:24.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.578]                 "immediateCondition"))) {
[13:17:24.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.578]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.578]                   if (TRUE && !signal) {
[13:17:24.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.578]                     {
[13:17:24.578]                       inherits <- base::inherits
[13:17:24.578]                       invokeRestart <- base::invokeRestart
[13:17:24.578]                       is.null <- base::is.null
[13:17:24.578]                       muffled <- FALSE
[13:17:24.578]                       if (inherits(cond, "message")) {
[13:17:24.578]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.578]                         if (muffled) 
[13:17:24.578]                           invokeRestart("muffleMessage")
[13:17:24.578]                       }
[13:17:24.578]                       else if (inherits(cond, "warning")) {
[13:17:24.578]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.578]                         if (muffled) 
[13:17:24.578]                           invokeRestart("muffleWarning")
[13:17:24.578]                       }
[13:17:24.578]                       else if (inherits(cond, "condition")) {
[13:17:24.578]                         if (!is.null(pattern)) {
[13:17:24.578]                           computeRestarts <- base::computeRestarts
[13:17:24.578]                           grepl <- base::grepl
[13:17:24.578]                           restarts <- computeRestarts(cond)
[13:17:24.578]                           for (restart in restarts) {
[13:17:24.578]                             name <- restart$name
[13:17:24.578]                             if (is.null(name)) 
[13:17:24.578]                               next
[13:17:24.578]                             if (!grepl(pattern, name)) 
[13:17:24.578]                               next
[13:17:24.578]                             invokeRestart(restart)
[13:17:24.578]                             muffled <- TRUE
[13:17:24.578]                             break
[13:17:24.578]                           }
[13:17:24.578]                         }
[13:17:24.578]                       }
[13:17:24.578]                       invisible(muffled)
[13:17:24.578]                     }
[13:17:24.578]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.578]                   }
[13:17:24.578]                 }
[13:17:24.578]                 else {
[13:17:24.578]                   if (TRUE) {
[13:17:24.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.578]                     {
[13:17:24.578]                       inherits <- base::inherits
[13:17:24.578]                       invokeRestart <- base::invokeRestart
[13:17:24.578]                       is.null <- base::is.null
[13:17:24.578]                       muffled <- FALSE
[13:17:24.578]                       if (inherits(cond, "message")) {
[13:17:24.578]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.578]                         if (muffled) 
[13:17:24.578]                           invokeRestart("muffleMessage")
[13:17:24.578]                       }
[13:17:24.578]                       else if (inherits(cond, "warning")) {
[13:17:24.578]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.578]                         if (muffled) 
[13:17:24.578]                           invokeRestart("muffleWarning")
[13:17:24.578]                       }
[13:17:24.578]                       else if (inherits(cond, "condition")) {
[13:17:24.578]                         if (!is.null(pattern)) {
[13:17:24.578]                           computeRestarts <- base::computeRestarts
[13:17:24.578]                           grepl <- base::grepl
[13:17:24.578]                           restarts <- computeRestarts(cond)
[13:17:24.578]                           for (restart in restarts) {
[13:17:24.578]                             name <- restart$name
[13:17:24.578]                             if (is.null(name)) 
[13:17:24.578]                               next
[13:17:24.578]                             if (!grepl(pattern, name)) 
[13:17:24.578]                               next
[13:17:24.578]                             invokeRestart(restart)
[13:17:24.578]                             muffled <- TRUE
[13:17:24.578]                             break
[13:17:24.578]                           }
[13:17:24.578]                         }
[13:17:24.578]                       }
[13:17:24.578]                       invisible(muffled)
[13:17:24.578]                     }
[13:17:24.578]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.578]                   }
[13:17:24.578]                 }
[13:17:24.578]             }
[13:17:24.578]         }))
[13:17:24.578]     }, error = function(ex) {
[13:17:24.578]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.578]                 ...future.rng), started = ...future.startTime, 
[13:17:24.578]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.578]             version = "1.8"), class = "FutureResult")
[13:17:24.578]     }, finally = {
[13:17:24.578]         if (!identical(...future.workdir, getwd())) 
[13:17:24.578]             setwd(...future.workdir)
[13:17:24.578]         {
[13:17:24.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.578]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.578]             }
[13:17:24.578]             base::options(...future.oldOptions)
[13:17:24.578]             if (.Platform$OS.type == "windows") {
[13:17:24.578]                 old_names <- names(...future.oldEnvVars)
[13:17:24.578]                 envs <- base::Sys.getenv()
[13:17:24.578]                 names <- names(envs)
[13:17:24.578]                 common <- intersect(names, old_names)
[13:17:24.578]                 added <- setdiff(names, old_names)
[13:17:24.578]                 removed <- setdiff(old_names, names)
[13:17:24.578]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.578]                   envs[common]]
[13:17:24.578]                 NAMES <- toupper(changed)
[13:17:24.578]                 args <- list()
[13:17:24.578]                 for (kk in seq_along(NAMES)) {
[13:17:24.578]                   name <- changed[[kk]]
[13:17:24.578]                   NAME <- NAMES[[kk]]
[13:17:24.578]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.578]                     next
[13:17:24.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.578]                 }
[13:17:24.578]                 NAMES <- toupper(added)
[13:17:24.578]                 for (kk in seq_along(NAMES)) {
[13:17:24.578]                   name <- added[[kk]]
[13:17:24.578]                   NAME <- NAMES[[kk]]
[13:17:24.578]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.578]                     next
[13:17:24.578]                   args[[name]] <- ""
[13:17:24.578]                 }
[13:17:24.578]                 NAMES <- toupper(removed)
[13:17:24.578]                 for (kk in seq_along(NAMES)) {
[13:17:24.578]                   name <- removed[[kk]]
[13:17:24.578]                   NAME <- NAMES[[kk]]
[13:17:24.578]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.578]                     next
[13:17:24.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.578]                 }
[13:17:24.578]                 if (length(args) > 0) 
[13:17:24.578]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.578]             }
[13:17:24.578]             else {
[13:17:24.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.578]             }
[13:17:24.578]             {
[13:17:24.578]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.578]                   0L) {
[13:17:24.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.578]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.578]                   base::options(opts)
[13:17:24.578]                 }
[13:17:24.578]                 {
[13:17:24.578]                   {
[13:17:24.578]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.578]                     NULL
[13:17:24.578]                   }
[13:17:24.578]                   options(future.plan = NULL)
[13:17:24.578]                   if (is.na(NA_character_)) 
[13:17:24.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.578]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.578]                     envir = parent.frame()) 
[13:17:24.578]                   {
[13:17:24.578]                     default_workers <- missing(workers)
[13:17:24.578]                     if (is.function(workers)) 
[13:17:24.578]                       workers <- workers()
[13:17:24.578]                     workers <- structure(as.integer(workers), 
[13:17:24.578]                       class = class(workers))
[13:17:24.578]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.578]                       1L)
[13:17:24.578]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.578]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.578]                       if (default_workers) 
[13:17:24.578]                         supportsMulticore(warn = TRUE)
[13:17:24.578]                       return(sequential(..., envir = envir))
[13:17:24.578]                     }
[13:17:24.578]                     oopts <- options(mc.cores = workers)
[13:17:24.578]                     on.exit(options(oopts))
[13:17:24.578]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.578]                       envir = envir)
[13:17:24.578]                     if (!future$lazy) 
[13:17:24.578]                       future <- run(future)
[13:17:24.578]                     invisible(future)
[13:17:24.578]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.578]                 }
[13:17:24.578]             }
[13:17:24.578]         }
[13:17:24.578]     })
[13:17:24.578]     if (TRUE) {
[13:17:24.578]         base::sink(type = "output", split = FALSE)
[13:17:24.578]         if (TRUE) {
[13:17:24.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.578]         }
[13:17:24.578]         else {
[13:17:24.578]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.578]         }
[13:17:24.578]         base::close(...future.stdout)
[13:17:24.578]         ...future.stdout <- NULL
[13:17:24.578]     }
[13:17:24.578]     ...future.result$conditions <- ...future.conditions
[13:17:24.578]     ...future.result$finished <- base::Sys.time()
[13:17:24.578]     ...future.result
[13:17:24.578] }
[13:17:24.581] assign_globals() ...
[13:17:24.581] List of 5
[13:17:24.581]  $ future.call.arguments    : list()
[13:17:24.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.581]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:24.581]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:24.581]  $ ...future.elements_ii    :List of 1
[13:17:24.581]   ..$ : num [1:4] 2 4 6 8
[13:17:24.581]  $ ...future.seeds_ii       : NULL
[13:17:24.581]  $ ...future.globals.maxSize: NULL
[13:17:24.581]  - attr(*, "where")=List of 5
[13:17:24.581]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.581]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.581]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.581]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.581]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.581]  - attr(*, "resolved")= logi FALSE
[13:17:24.581]  - attr(*, "total_size")= num NA
[13:17:24.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.581]  - attr(*, "already-done")= logi TRUE
[13:17:24.593] - copied ‘future.call.arguments’ to environment
[13:17:24.593] - copied ‘...future.FUN’ to environment
[13:17:24.594] - copied ‘...future.elements_ii’ to environment
[13:17:24.594] - copied ‘...future.seeds_ii’ to environment
[13:17:24.594] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.594] assign_globals() ... done
[13:17:24.594] requestCore(): workers = 2
[13:17:24.596] MulticoreFuture started
[13:17:24.597] - Launch lazy future ... done
[13:17:24.597] run() for ‘MulticoreFuture’ ... done
[13:17:24.597] Created future:
[13:17:24.598] plan(): Setting new future strategy stack:
[13:17:24.598] List of future strategies:
[13:17:24.598] 1. sequential:
[13:17:24.598]    - args: function (..., envir = parent.frame())
[13:17:24.598]    - tweaked: FALSE
[13:17:24.598]    - call: NULL
[13:17:24.599] plan(): nbrOfWorkers() = 1
[13:17:24.601] plan(): Setting new future strategy stack:
[13:17:24.601] List of future strategies:
[13:17:24.601] 1. multicore:
[13:17:24.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.601]    - tweaked: FALSE
[13:17:24.601]    - call: plan(strategy)
[13:17:24.607] plan(): nbrOfWorkers() = 2
[13:17:24.598] MulticoreFuture:
[13:17:24.598] Label: ‘future_apply-2’
[13:17:24.598] Expression:
[13:17:24.598] {
[13:17:24.598]     do.call(function(...) {
[13:17:24.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.598]             on.exit(options(oopts), add = TRUE)
[13:17:24.598]         }
[13:17:24.598]         {
[13:17:24.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.598]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.598]             })
[13:17:24.598]         }
[13:17:24.598]     }, args = future.call.arguments)
[13:17:24.598] }
[13:17:24.598] Lazy evaluation: FALSE
[13:17:24.598] Asynchronous evaluation: TRUE
[13:17:24.598] Local evaluation: TRUE
[13:17:24.598] Environment: R_GlobalEnv
[13:17:24.598] Capture standard output: TRUE
[13:17:24.598] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.598] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.598] Packages: <none>
[13:17:24.598] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.598] Resolved: TRUE
[13:17:24.598] Value: <not collected>
[13:17:24.598] Conditions captured: <none>
[13:17:24.598] Early signaling: FALSE
[13:17:24.598] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.598] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.608] Chunk #2 of 2 ... DONE
[13:17:24.608] Launching 2 futures (chunks) ... DONE
[13:17:24.608] Resolving 2 futures (chunks) ...
[13:17:24.609] resolve() on list ...
[13:17:24.609]  recursive: 0
[13:17:24.609]  length: 2
[13:17:24.609] 
[13:17:24.609] Future #1
[13:17:24.610] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:24.611] - nx: 2
[13:17:24.611] - relay: TRUE
[13:17:24.611] - stdout: TRUE
[13:17:24.611] - signal: TRUE
[13:17:24.611] - resignal: FALSE
[13:17:24.611] - force: TRUE
[13:17:24.611] - relayed: [n=2] FALSE, FALSE
[13:17:24.612] - queued futures: [n=2] FALSE, FALSE
[13:17:24.612]  - until=1
[13:17:24.612]  - relaying element #1
[13:17:24.612] - relayed: [n=2] TRUE, FALSE
[13:17:24.612] - queued futures: [n=2] TRUE, FALSE
[13:17:24.612] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:24.613]  length: 1 (resolved future 1)
[13:17:24.613] Future #2
[13:17:24.614] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:24.614] - nx: 2
[13:17:24.614] - relay: TRUE
[13:17:24.614] - stdout: TRUE
[13:17:24.614] - signal: TRUE
[13:17:24.615] - resignal: FALSE
[13:17:24.615] - force: TRUE
[13:17:24.615] - relayed: [n=2] TRUE, FALSE
[13:17:24.615] - queued futures: [n=2] TRUE, FALSE
[13:17:24.615]  - until=2
[13:17:24.615]  - relaying element #2
[13:17:24.616] - relayed: [n=2] TRUE, TRUE
[13:17:24.616] - queued futures: [n=2] TRUE, TRUE
[13:17:24.616] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:24.616]  length: 0 (resolved future 2)
[13:17:24.616] Relaying remaining futures
[13:17:24.616] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.616] - nx: 2
[13:17:24.616] - relay: TRUE
[13:17:24.616] - stdout: TRUE
[13:17:24.617] - signal: TRUE
[13:17:24.617] - resignal: FALSE
[13:17:24.617] - force: TRUE
[13:17:24.617] - relayed: [n=2] TRUE, TRUE
[13:17:24.617] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:24.617] - relayed: [n=2] TRUE, TRUE
[13:17:24.617] - queued futures: [n=2] TRUE, TRUE
[13:17:24.618] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.618] resolve() on list ... DONE
[13:17:24.618]  - Number of value chunks collected: 2
[13:17:24.618] Resolving 2 futures (chunks) ... DONE
[13:17:24.618] Reducing values from 2 chunks ...
[13:17:24.618]  - Number of values collected after concatenation: 2
[13:17:24.618]  - Number of values expected: 2
[13:17:24.618] Reducing values from 2 chunks ... DONE
[13:17:24.619] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:17:24.620] getGlobalsAndPackagesXApply() ...
[13:17:24.620]  - future.globals: TRUE
[13:17:24.620] getGlobalsAndPackages() ...
[13:17:24.620] Searching for globals...
[13:17:24.621] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:24.622] Searching for globals ... DONE
[13:17:24.622] Resolving globals: FALSE
[13:17:24.622] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:24.623] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:24.623] - globals: [1] ‘FUN’
[13:17:24.623] - packages: [1] ‘stats’
[13:17:24.623] getGlobalsAndPackages() ... DONE
[13:17:24.623]  - globals found/used: [n=1] ‘FUN’
[13:17:24.623]  - needed namespaces: [n=1] ‘stats’
[13:17:24.623] Finding globals ... DONE
[13:17:24.623]  - use_args: TRUE
[13:17:24.624]  - Getting '...' globals ...
[13:17:24.624] resolve() on list ...
[13:17:24.624]  recursive: 0
[13:17:24.624]  length: 1
[13:17:24.624]  elements: ‘...’
[13:17:24.624]  length: 0 (resolved future 1)
[13:17:24.625] resolve() on list ... DONE
[13:17:24.625]    - '...' content: [n=0] 
[13:17:24.625] List of 1
[13:17:24.625]  $ ...: list()
[13:17:24.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.625]  - attr(*, "where")=List of 1
[13:17:24.625]   ..$ ...:<environment: 0x5647bad75c30> 
[13:17:24.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.625]  - attr(*, "resolved")= logi TRUE
[13:17:24.625]  - attr(*, "total_size")= num NA
[13:17:24.632]  - Getting '...' globals ... DONE
[13:17:24.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.633] List of 2
[13:17:24.633]  $ ...future.FUN:function (x, ...)  
[13:17:24.633]  $ ...          : list()
[13:17:24.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.633]  - attr(*, "where")=List of 2
[13:17:24.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.633]   ..$ ...          :<environment: 0x5647bad75c30> 
[13:17:24.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.633]  - attr(*, "resolved")= logi FALSE
[13:17:24.633]  - attr(*, "total_size")= num 1248
[13:17:24.636] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:24.636] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.640] future_lapply() ...
[13:17:24.644] Number of chunks: 2
[13:17:24.644] getGlobalsAndPackagesXApply() ...
[13:17:24.644]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.644]  - use_args: TRUE
[13:17:24.644] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.645] List of 2
[13:17:24.645]  $ ...          : list()
[13:17:24.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.645]  $ ...future.FUN:function (x, ...)  
[13:17:24.645]  - attr(*, "where")=List of 2
[13:17:24.645]   ..$ ...          :<environment: 0x5647bad75c30> 
[13:17:24.645]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:17:24.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.645]  - attr(*, "resolved")= logi FALSE
[13:17:24.645]  - attr(*, "total_size")= num NA
[13:17:24.647] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:24.648] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.648] Number of futures (= number of chunks): 2
[13:17:24.648] Launching 2 futures (chunks) ...
[13:17:24.648] Chunk #1 of 2 ...
[13:17:24.648]  - seeds: <none>
[13:17:24.648] getGlobalsAndPackages() ...
[13:17:24.648] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.648] Resolving globals: FALSE
[13:17:24.649] Tweak future expression to call with '...' arguments ...
[13:17:24.649] {
[13:17:24.649]     do.call(function(...) {
[13:17:24.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.649]             on.exit(options(oopts), add = TRUE)
[13:17:24.649]         }
[13:17:24.649]         {
[13:17:24.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.649]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.649]             })
[13:17:24.649]         }
[13:17:24.649]     }, args = future.call.arguments)
[13:17:24.649] }
[13:17:24.649] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.649] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.650] - packages: [1] ‘stats’
[13:17:24.650] getGlobalsAndPackages() ... DONE
[13:17:24.650] run() for ‘Future’ ...
[13:17:24.650] - state: ‘created’
[13:17:24.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.654] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.654]   - Field: ‘label’
[13:17:24.654]   - Field: ‘local’
[13:17:24.654]   - Field: ‘owner’
[13:17:24.654]   - Field: ‘envir’
[13:17:24.654]   - Field: ‘workers’
[13:17:24.655]   - Field: ‘packages’
[13:17:24.655]   - Field: ‘gc’
[13:17:24.655]   - Field: ‘job’
[13:17:24.655]   - Field: ‘conditions’
[13:17:24.655]   - Field: ‘expr’
[13:17:24.655]   - Field: ‘uuid’
[13:17:24.655]   - Field: ‘seed’
[13:17:24.655]   - Field: ‘version’
[13:17:24.656]   - Field: ‘result’
[13:17:24.656]   - Field: ‘asynchronous’
[13:17:24.656]   - Field: ‘calls’
[13:17:24.656]   - Field: ‘globals’
[13:17:24.656]   - Field: ‘stdout’
[13:17:24.656]   - Field: ‘earlySignal’
[13:17:24.656]   - Field: ‘lazy’
[13:17:24.656]   - Field: ‘state’
[13:17:24.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.657] - Launch lazy future ...
[13:17:24.657] Packages needed by the future expression (n = 1): ‘stats’
[13:17:24.657] Packages needed by future strategies (n = 0): <none>
[13:17:24.658] {
[13:17:24.658]     {
[13:17:24.658]         {
[13:17:24.658]             ...future.startTime <- base::Sys.time()
[13:17:24.658]             {
[13:17:24.658]                 {
[13:17:24.658]                   {
[13:17:24.658]                     {
[13:17:24.658]                       {
[13:17:24.658]                         base::local({
[13:17:24.658]                           has_future <- base::requireNamespace("future", 
[13:17:24.658]                             quietly = TRUE)
[13:17:24.658]                           if (has_future) {
[13:17:24.658]                             ns <- base::getNamespace("future")
[13:17:24.658]                             version <- ns[[".package"]][["version"]]
[13:17:24.658]                             if (is.null(version)) 
[13:17:24.658]                               version <- utils::packageVersion("future")
[13:17:24.658]                           }
[13:17:24.658]                           else {
[13:17:24.658]                             version <- NULL
[13:17:24.658]                           }
[13:17:24.658]                           if (!has_future || version < "1.8.0") {
[13:17:24.658]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.658]                               "", base::R.version$version.string), 
[13:17:24.658]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:24.658]                                 base::R.version$platform, 8 * 
[13:17:24.658]                                   base::.Machine$sizeof.pointer), 
[13:17:24.658]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.658]                                 "release", "version")], collapse = " "), 
[13:17:24.658]                               hostname = base::Sys.info()[["nodename"]])
[13:17:24.658]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.658]                               info)
[13:17:24.658]                             info <- base::paste(info, collapse = "; ")
[13:17:24.658]                             if (!has_future) {
[13:17:24.658]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.658]                                 info)
[13:17:24.658]                             }
[13:17:24.658]                             else {
[13:17:24.658]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.658]                                 info, version)
[13:17:24.658]                             }
[13:17:24.658]                             base::stop(msg)
[13:17:24.658]                           }
[13:17:24.658]                         })
[13:17:24.658]                       }
[13:17:24.658]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.658]                       base::options(mc.cores = 1L)
[13:17:24.658]                     }
[13:17:24.658]                     base::local({
[13:17:24.658]                       for (pkg in "stats") {
[13:17:24.658]                         base::loadNamespace(pkg)
[13:17:24.658]                         base::library(pkg, character.only = TRUE)
[13:17:24.658]                       }
[13:17:24.658]                     })
[13:17:24.658]                   }
[13:17:24.658]                   options(future.plan = NULL)
[13:17:24.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.658]                 }
[13:17:24.658]                 ...future.workdir <- getwd()
[13:17:24.658]             }
[13:17:24.658]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.658]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.658]         }
[13:17:24.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.658]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.658]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.658]             base::names(...future.oldOptions))
[13:17:24.658]     }
[13:17:24.658]     if (FALSE) {
[13:17:24.658]     }
[13:17:24.658]     else {
[13:17:24.658]         if (TRUE) {
[13:17:24.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.658]                 open = "w")
[13:17:24.658]         }
[13:17:24.658]         else {
[13:17:24.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.658]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.658]         }
[13:17:24.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.658]             base::sink(type = "output", split = FALSE)
[13:17:24.658]             base::close(...future.stdout)
[13:17:24.658]         }, add = TRUE)
[13:17:24.658]     }
[13:17:24.658]     ...future.frame <- base::sys.nframe()
[13:17:24.658]     ...future.conditions <- base::list()
[13:17:24.658]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.658]     if (FALSE) {
[13:17:24.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.658]     }
[13:17:24.658]     ...future.result <- base::tryCatch({
[13:17:24.658]         base::withCallingHandlers({
[13:17:24.658]             ...future.value <- base::withVisible(base::local({
[13:17:24.658]                 withCallingHandlers({
[13:17:24.658]                   {
[13:17:24.658]                     do.call(function(...) {
[13:17:24.658]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.658]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.658]                         ...future.globals.maxSize)) {
[13:17:24.658]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.658]                         on.exit(options(oopts), add = TRUE)
[13:17:24.658]                       }
[13:17:24.658]                       {
[13:17:24.658]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.658]                           FUN = function(jj) {
[13:17:24.658]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.658]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.658]                           })
[13:17:24.658]                       }
[13:17:24.658]                     }, args = future.call.arguments)
[13:17:24.658]                   }
[13:17:24.658]                 }, immediateCondition = function(cond) {
[13:17:24.658]                   save_rds <- function (object, pathname, ...) 
[13:17:24.658]                   {
[13:17:24.658]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.658]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.658]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.658]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.658]                         fi_tmp[["mtime"]])
[13:17:24.658]                     }
[13:17:24.658]                     tryCatch({
[13:17:24.658]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.658]                     }, error = function(ex) {
[13:17:24.658]                       msg <- conditionMessage(ex)
[13:17:24.658]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.658]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.658]                         fi_tmp[["mtime"]], msg)
[13:17:24.658]                       ex$message <- msg
[13:17:24.658]                       stop(ex)
[13:17:24.658]                     })
[13:17:24.658]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.658]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.658]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.658]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.658]                       fi <- file.info(pathname)
[13:17:24.658]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.658]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.658]                         fi[["size"]], fi[["mtime"]])
[13:17:24.658]                       stop(msg)
[13:17:24.658]                     }
[13:17:24.658]                     invisible(pathname)
[13:17:24.658]                   }
[13:17:24.658]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.658]                     rootPath = tempdir()) 
[13:17:24.658]                   {
[13:17:24.658]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.658]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.658]                       tmpdir = path, fileext = ".rds")
[13:17:24.658]                     save_rds(obj, file)
[13:17:24.658]                   }
[13:17:24.658]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.658]                   {
[13:17:24.658]                     inherits <- base::inherits
[13:17:24.658]                     invokeRestart <- base::invokeRestart
[13:17:24.658]                     is.null <- base::is.null
[13:17:24.658]                     muffled <- FALSE
[13:17:24.658]                     if (inherits(cond, "message")) {
[13:17:24.658]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.658]                       if (muffled) 
[13:17:24.658]                         invokeRestart("muffleMessage")
[13:17:24.658]                     }
[13:17:24.658]                     else if (inherits(cond, "warning")) {
[13:17:24.658]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.658]                       if (muffled) 
[13:17:24.658]                         invokeRestart("muffleWarning")
[13:17:24.658]                     }
[13:17:24.658]                     else if (inherits(cond, "condition")) {
[13:17:24.658]                       if (!is.null(pattern)) {
[13:17:24.658]                         computeRestarts <- base::computeRestarts
[13:17:24.658]                         grepl <- base::grepl
[13:17:24.658]                         restarts <- computeRestarts(cond)
[13:17:24.658]                         for (restart in restarts) {
[13:17:24.658]                           name <- restart$name
[13:17:24.658]                           if (is.null(name)) 
[13:17:24.658]                             next
[13:17:24.658]                           if (!grepl(pattern, name)) 
[13:17:24.658]                             next
[13:17:24.658]                           invokeRestart(restart)
[13:17:24.658]                           muffled <- TRUE
[13:17:24.658]                           break
[13:17:24.658]                         }
[13:17:24.658]                       }
[13:17:24.658]                     }
[13:17:24.658]                     invisible(muffled)
[13:17:24.658]                   }
[13:17:24.658]                   muffleCondition(cond)
[13:17:24.658]                 })
[13:17:24.658]             }))
[13:17:24.658]             future::FutureResult(value = ...future.value$value, 
[13:17:24.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.658]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.658]                     ...future.globalenv.names))
[13:17:24.658]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.658]         }, condition = base::local({
[13:17:24.658]             c <- base::c
[13:17:24.658]             inherits <- base::inherits
[13:17:24.658]             invokeRestart <- base::invokeRestart
[13:17:24.658]             length <- base::length
[13:17:24.658]             list <- base::list
[13:17:24.658]             seq.int <- base::seq.int
[13:17:24.658]             signalCondition <- base::signalCondition
[13:17:24.658]             sys.calls <- base::sys.calls
[13:17:24.658]             `[[` <- base::`[[`
[13:17:24.658]             `+` <- base::`+`
[13:17:24.658]             `<<-` <- base::`<<-`
[13:17:24.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.658]                   3L)]
[13:17:24.658]             }
[13:17:24.658]             function(cond) {
[13:17:24.658]                 is_error <- inherits(cond, "error")
[13:17:24.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.658]                   NULL)
[13:17:24.658]                 if (is_error) {
[13:17:24.658]                   sessionInformation <- function() {
[13:17:24.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.658]                       search = base::search(), system = base::Sys.info())
[13:17:24.658]                   }
[13:17:24.658]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.658]                     cond$call), session = sessionInformation(), 
[13:17:24.658]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.658]                   signalCondition(cond)
[13:17:24.658]                 }
[13:17:24.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.658]                 "immediateCondition"))) {
[13:17:24.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.658]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.658]                   if (TRUE && !signal) {
[13:17:24.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.658]                     {
[13:17:24.658]                       inherits <- base::inherits
[13:17:24.658]                       invokeRestart <- base::invokeRestart
[13:17:24.658]                       is.null <- base::is.null
[13:17:24.658]                       muffled <- FALSE
[13:17:24.658]                       if (inherits(cond, "message")) {
[13:17:24.658]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.658]                         if (muffled) 
[13:17:24.658]                           invokeRestart("muffleMessage")
[13:17:24.658]                       }
[13:17:24.658]                       else if (inherits(cond, "warning")) {
[13:17:24.658]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.658]                         if (muffled) 
[13:17:24.658]                           invokeRestart("muffleWarning")
[13:17:24.658]                       }
[13:17:24.658]                       else if (inherits(cond, "condition")) {
[13:17:24.658]                         if (!is.null(pattern)) {
[13:17:24.658]                           computeRestarts <- base::computeRestarts
[13:17:24.658]                           grepl <- base::grepl
[13:17:24.658]                           restarts <- computeRestarts(cond)
[13:17:24.658]                           for (restart in restarts) {
[13:17:24.658]                             name <- restart$name
[13:17:24.658]                             if (is.null(name)) 
[13:17:24.658]                               next
[13:17:24.658]                             if (!grepl(pattern, name)) 
[13:17:24.658]                               next
[13:17:24.658]                             invokeRestart(restart)
[13:17:24.658]                             muffled <- TRUE
[13:17:24.658]                             break
[13:17:24.658]                           }
[13:17:24.658]                         }
[13:17:24.658]                       }
[13:17:24.658]                       invisible(muffled)
[13:17:24.658]                     }
[13:17:24.658]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.658]                   }
[13:17:24.658]                 }
[13:17:24.658]                 else {
[13:17:24.658]                   if (TRUE) {
[13:17:24.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.658]                     {
[13:17:24.658]                       inherits <- base::inherits
[13:17:24.658]                       invokeRestart <- base::invokeRestart
[13:17:24.658]                       is.null <- base::is.null
[13:17:24.658]                       muffled <- FALSE
[13:17:24.658]                       if (inherits(cond, "message")) {
[13:17:24.658]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.658]                         if (muffled) 
[13:17:24.658]                           invokeRestart("muffleMessage")
[13:17:24.658]                       }
[13:17:24.658]                       else if (inherits(cond, "warning")) {
[13:17:24.658]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.658]                         if (muffled) 
[13:17:24.658]                           invokeRestart("muffleWarning")
[13:17:24.658]                       }
[13:17:24.658]                       else if (inherits(cond, "condition")) {
[13:17:24.658]                         if (!is.null(pattern)) {
[13:17:24.658]                           computeRestarts <- base::computeRestarts
[13:17:24.658]                           grepl <- base::grepl
[13:17:24.658]                           restarts <- computeRestarts(cond)
[13:17:24.658]                           for (restart in restarts) {
[13:17:24.658]                             name <- restart$name
[13:17:24.658]                             if (is.null(name)) 
[13:17:24.658]                               next
[13:17:24.658]                             if (!grepl(pattern, name)) 
[13:17:24.658]                               next
[13:17:24.658]                             invokeRestart(restart)
[13:17:24.658]                             muffled <- TRUE
[13:17:24.658]                             break
[13:17:24.658]                           }
[13:17:24.658]                         }
[13:17:24.658]                       }
[13:17:24.658]                       invisible(muffled)
[13:17:24.658]                     }
[13:17:24.658]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.658]                   }
[13:17:24.658]                 }
[13:17:24.658]             }
[13:17:24.658]         }))
[13:17:24.658]     }, error = function(ex) {
[13:17:24.658]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.658]                 ...future.rng), started = ...future.startTime, 
[13:17:24.658]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.658]             version = "1.8"), class = "FutureResult")
[13:17:24.658]     }, finally = {
[13:17:24.658]         if (!identical(...future.workdir, getwd())) 
[13:17:24.658]             setwd(...future.workdir)
[13:17:24.658]         {
[13:17:24.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.658]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.658]             }
[13:17:24.658]             base::options(...future.oldOptions)
[13:17:24.658]             if (.Platform$OS.type == "windows") {
[13:17:24.658]                 old_names <- names(...future.oldEnvVars)
[13:17:24.658]                 envs <- base::Sys.getenv()
[13:17:24.658]                 names <- names(envs)
[13:17:24.658]                 common <- intersect(names, old_names)
[13:17:24.658]                 added <- setdiff(names, old_names)
[13:17:24.658]                 removed <- setdiff(old_names, names)
[13:17:24.658]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.658]                   envs[common]]
[13:17:24.658]                 NAMES <- toupper(changed)
[13:17:24.658]                 args <- list()
[13:17:24.658]                 for (kk in seq_along(NAMES)) {
[13:17:24.658]                   name <- changed[[kk]]
[13:17:24.658]                   NAME <- NAMES[[kk]]
[13:17:24.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.658]                     next
[13:17:24.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.658]                 }
[13:17:24.658]                 NAMES <- toupper(added)
[13:17:24.658]                 for (kk in seq_along(NAMES)) {
[13:17:24.658]                   name <- added[[kk]]
[13:17:24.658]                   NAME <- NAMES[[kk]]
[13:17:24.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.658]                     next
[13:17:24.658]                   args[[name]] <- ""
[13:17:24.658]                 }
[13:17:24.658]                 NAMES <- toupper(removed)
[13:17:24.658]                 for (kk in seq_along(NAMES)) {
[13:17:24.658]                   name <- removed[[kk]]
[13:17:24.658]                   NAME <- NAMES[[kk]]
[13:17:24.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.658]                     next
[13:17:24.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.658]                 }
[13:17:24.658]                 if (length(args) > 0) 
[13:17:24.658]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.658]             }
[13:17:24.658]             else {
[13:17:24.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.658]             }
[13:17:24.658]             {
[13:17:24.658]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.658]                   0L) {
[13:17:24.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.658]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.658]                   base::options(opts)
[13:17:24.658]                 }
[13:17:24.658]                 {
[13:17:24.658]                   {
[13:17:24.658]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.658]                     NULL
[13:17:24.658]                   }
[13:17:24.658]                   options(future.plan = NULL)
[13:17:24.658]                   if (is.na(NA_character_)) 
[13:17:24.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.658]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.658]                     envir = parent.frame()) 
[13:17:24.658]                   {
[13:17:24.658]                     default_workers <- missing(workers)
[13:17:24.658]                     if (is.function(workers)) 
[13:17:24.658]                       workers <- workers()
[13:17:24.658]                     workers <- structure(as.integer(workers), 
[13:17:24.658]                       class = class(workers))
[13:17:24.658]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.658]                       1L)
[13:17:24.658]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.658]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.658]                       if (default_workers) 
[13:17:24.658]                         supportsMulticore(warn = TRUE)
[13:17:24.658]                       return(sequential(..., envir = envir))
[13:17:24.658]                     }
[13:17:24.658]                     oopts <- options(mc.cores = workers)
[13:17:24.658]                     on.exit(options(oopts))
[13:17:24.658]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.658]                       envir = envir)
[13:17:24.658]                     if (!future$lazy) 
[13:17:24.658]                       future <- run(future)
[13:17:24.658]                     invisible(future)
[13:17:24.658]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.658]                 }
[13:17:24.658]             }
[13:17:24.658]         }
[13:17:24.658]     })
[13:17:24.658]     if (TRUE) {
[13:17:24.658]         base::sink(type = "output", split = FALSE)
[13:17:24.658]         if (TRUE) {
[13:17:24.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.658]         }
[13:17:24.658]         else {
[13:17:24.658]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.658]         }
[13:17:24.658]         base::close(...future.stdout)
[13:17:24.658]         ...future.stdout <- NULL
[13:17:24.658]     }
[13:17:24.658]     ...future.result$conditions <- ...future.conditions
[13:17:24.658]     ...future.result$finished <- base::Sys.time()
[13:17:24.658]     ...future.result
[13:17:24.658] }
[13:17:24.660] assign_globals() ...
[13:17:24.660] List of 5
[13:17:24.660]  $ future.call.arguments    : list()
[13:17:24.660]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.660]  $ ...future.FUN            :function (x, ...)  
[13:17:24.660]  $ ...future.elements_ii    :List of 1
[13:17:24.660]   ..$ : num [1:4] 1 3 1 7
[13:17:24.660]  $ ...future.seeds_ii       : NULL
[13:17:24.660]  $ ...future.globals.maxSize: NULL
[13:17:24.660]  - attr(*, "where")=List of 5
[13:17:24.660]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.660]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.660]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.660]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.660]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.660]  - attr(*, "resolved")= logi FALSE
[13:17:24.660]  - attr(*, "total_size")= num NA
[13:17:24.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.660]  - attr(*, "already-done")= logi TRUE
[13:17:24.667] - copied ‘future.call.arguments’ to environment
[13:17:24.668] - copied ‘...future.FUN’ to environment
[13:17:24.668] - copied ‘...future.elements_ii’ to environment
[13:17:24.668] - copied ‘...future.seeds_ii’ to environment
[13:17:24.668] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.668] assign_globals() ... done
[13:17:24.668] requestCore(): workers = 2
[13:17:24.670] MulticoreFuture started
[13:17:24.671] - Launch lazy future ... done
[13:17:24.671] run() for ‘MulticoreFuture’ ... done
[13:17:24.671] Created future:
[13:17:24.672] plan(): Setting new future strategy stack:
[13:17:24.672] List of future strategies:
[13:17:24.672] 1. sequential:
[13:17:24.672]    - args: function (..., envir = parent.frame())
[13:17:24.672]    - tweaked: FALSE
[13:17:24.672]    - call: NULL
[13:17:24.673] plan(): nbrOfWorkers() = 1
[13:17:24.676] plan(): Setting new future strategy stack:
[13:17:24.676] List of future strategies:
[13:17:24.676] 1. multicore:
[13:17:24.676]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.676]    - tweaked: FALSE
[13:17:24.676]    - call: plan(strategy)
[13:17:24.682] plan(): nbrOfWorkers() = 2
[13:17:24.672] MulticoreFuture:
[13:17:24.672] Label: ‘future_apply-1’
[13:17:24.672] Expression:
[13:17:24.672] {
[13:17:24.672]     do.call(function(...) {
[13:17:24.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.672]             on.exit(options(oopts), add = TRUE)
[13:17:24.672]         }
[13:17:24.672]         {
[13:17:24.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.672]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.672]             })
[13:17:24.672]         }
[13:17:24.672]     }, args = future.call.arguments)
[13:17:24.672] }
[13:17:24.672] Lazy evaluation: FALSE
[13:17:24.672] Asynchronous evaluation: TRUE
[13:17:24.672] Local evaluation: TRUE
[13:17:24.672] Environment: R_GlobalEnv
[13:17:24.672] Capture standard output: TRUE
[13:17:24.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.672] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.672] Packages: 1 packages (‘stats’)
[13:17:24.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.672] Resolved: TRUE
[13:17:24.672] Value: <not collected>
[13:17:24.672] Conditions captured: <none>
[13:17:24.672] Early signaling: FALSE
[13:17:24.672] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.672] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.683] Chunk #1 of 2 ... DONE
[13:17:24.683] Chunk #2 of 2 ...
[13:17:24.683]  - seeds: <none>
[13:17:24.683] getGlobalsAndPackages() ...
[13:17:24.684] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.684] Resolving globals: FALSE
[13:17:24.684] Tweak future expression to call with '...' arguments ...
[13:17:24.684] {
[13:17:24.684]     do.call(function(...) {
[13:17:24.684]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.684]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.684]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.684]             on.exit(options(oopts), add = TRUE)
[13:17:24.684]         }
[13:17:24.684]         {
[13:17:24.684]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.684]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.684]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.684]             })
[13:17:24.684]         }
[13:17:24.684]     }, args = future.call.arguments)
[13:17:24.684] }
[13:17:24.684] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.685] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.685] - packages: [1] ‘stats’
[13:17:24.686] getGlobalsAndPackages() ... DONE
[13:17:24.686] run() for ‘Future’ ...
[13:17:24.686] - state: ‘created’
[13:17:24.687] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.691] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.691] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.691]   - Field: ‘label’
[13:17:24.692]   - Field: ‘local’
[13:17:24.692]   - Field: ‘owner’
[13:17:24.692]   - Field: ‘envir’
[13:17:24.692]   - Field: ‘workers’
[13:17:24.692]   - Field: ‘packages’
[13:17:24.692]   - Field: ‘gc’
[13:17:24.692]   - Field: ‘job’
[13:17:24.693]   - Field: ‘conditions’
[13:17:24.693]   - Field: ‘expr’
[13:17:24.693]   - Field: ‘uuid’
[13:17:24.693]   - Field: ‘seed’
[13:17:24.693]   - Field: ‘version’
[13:17:24.693]   - Field: ‘result’
[13:17:24.693]   - Field: ‘asynchronous’
[13:17:24.694]   - Field: ‘calls’
[13:17:24.694]   - Field: ‘globals’
[13:17:24.694]   - Field: ‘stdout’
[13:17:24.694]   - Field: ‘earlySignal’
[13:17:24.694]   - Field: ‘lazy’
[13:17:24.694]   - Field: ‘state’
[13:17:24.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.695] - Launch lazy future ...
[13:17:24.695] Packages needed by the future expression (n = 1): ‘stats’
[13:17:24.695] Packages needed by future strategies (n = 0): <none>
[13:17:24.696] {
[13:17:24.696]     {
[13:17:24.696]         {
[13:17:24.696]             ...future.startTime <- base::Sys.time()
[13:17:24.696]             {
[13:17:24.696]                 {
[13:17:24.696]                   {
[13:17:24.696]                     {
[13:17:24.696]                       {
[13:17:24.696]                         base::local({
[13:17:24.696]                           has_future <- base::requireNamespace("future", 
[13:17:24.696]                             quietly = TRUE)
[13:17:24.696]                           if (has_future) {
[13:17:24.696]                             ns <- base::getNamespace("future")
[13:17:24.696]                             version <- ns[[".package"]][["version"]]
[13:17:24.696]                             if (is.null(version)) 
[13:17:24.696]                               version <- utils::packageVersion("future")
[13:17:24.696]                           }
[13:17:24.696]                           else {
[13:17:24.696]                             version <- NULL
[13:17:24.696]                           }
[13:17:24.696]                           if (!has_future || version < "1.8.0") {
[13:17:24.696]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.696]                               "", base::R.version$version.string), 
[13:17:24.696]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:24.696]                                 base::R.version$platform, 8 * 
[13:17:24.696]                                   base::.Machine$sizeof.pointer), 
[13:17:24.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.696]                                 "release", "version")], collapse = " "), 
[13:17:24.696]                               hostname = base::Sys.info()[["nodename"]])
[13:17:24.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.696]                               info)
[13:17:24.696]                             info <- base::paste(info, collapse = "; ")
[13:17:24.696]                             if (!has_future) {
[13:17:24.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.696]                                 info)
[13:17:24.696]                             }
[13:17:24.696]                             else {
[13:17:24.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.696]                                 info, version)
[13:17:24.696]                             }
[13:17:24.696]                             base::stop(msg)
[13:17:24.696]                           }
[13:17:24.696]                         })
[13:17:24.696]                       }
[13:17:24.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.696]                       base::options(mc.cores = 1L)
[13:17:24.696]                     }
[13:17:24.696]                     base::local({
[13:17:24.696]                       for (pkg in "stats") {
[13:17:24.696]                         base::loadNamespace(pkg)
[13:17:24.696]                         base::library(pkg, character.only = TRUE)
[13:17:24.696]                       }
[13:17:24.696]                     })
[13:17:24.696]                   }
[13:17:24.696]                   options(future.plan = NULL)
[13:17:24.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.696]                 }
[13:17:24.696]                 ...future.workdir <- getwd()
[13:17:24.696]             }
[13:17:24.696]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.696]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.696]         }
[13:17:24.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.696]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.696]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.696]             base::names(...future.oldOptions))
[13:17:24.696]     }
[13:17:24.696]     if (FALSE) {
[13:17:24.696]     }
[13:17:24.696]     else {
[13:17:24.696]         if (TRUE) {
[13:17:24.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.696]                 open = "w")
[13:17:24.696]         }
[13:17:24.696]         else {
[13:17:24.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.696]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.696]         }
[13:17:24.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.696]             base::sink(type = "output", split = FALSE)
[13:17:24.696]             base::close(...future.stdout)
[13:17:24.696]         }, add = TRUE)
[13:17:24.696]     }
[13:17:24.696]     ...future.frame <- base::sys.nframe()
[13:17:24.696]     ...future.conditions <- base::list()
[13:17:24.696]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.696]     if (FALSE) {
[13:17:24.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.696]     }
[13:17:24.696]     ...future.result <- base::tryCatch({
[13:17:24.696]         base::withCallingHandlers({
[13:17:24.696]             ...future.value <- base::withVisible(base::local({
[13:17:24.696]                 withCallingHandlers({
[13:17:24.696]                   {
[13:17:24.696]                     do.call(function(...) {
[13:17:24.696]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.696]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.696]                         ...future.globals.maxSize)) {
[13:17:24.696]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.696]                         on.exit(options(oopts), add = TRUE)
[13:17:24.696]                       }
[13:17:24.696]                       {
[13:17:24.696]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.696]                           FUN = function(jj) {
[13:17:24.696]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.696]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.696]                           })
[13:17:24.696]                       }
[13:17:24.696]                     }, args = future.call.arguments)
[13:17:24.696]                   }
[13:17:24.696]                 }, immediateCondition = function(cond) {
[13:17:24.696]                   save_rds <- function (object, pathname, ...) 
[13:17:24.696]                   {
[13:17:24.696]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.696]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.696]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.696]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.696]                         fi_tmp[["mtime"]])
[13:17:24.696]                     }
[13:17:24.696]                     tryCatch({
[13:17:24.696]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.696]                     }, error = function(ex) {
[13:17:24.696]                       msg <- conditionMessage(ex)
[13:17:24.696]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.696]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.696]                         fi_tmp[["mtime"]], msg)
[13:17:24.696]                       ex$message <- msg
[13:17:24.696]                       stop(ex)
[13:17:24.696]                     })
[13:17:24.696]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.696]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.696]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.696]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.696]                       fi <- file.info(pathname)
[13:17:24.696]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.696]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.696]                         fi[["size"]], fi[["mtime"]])
[13:17:24.696]                       stop(msg)
[13:17:24.696]                     }
[13:17:24.696]                     invisible(pathname)
[13:17:24.696]                   }
[13:17:24.696]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.696]                     rootPath = tempdir()) 
[13:17:24.696]                   {
[13:17:24.696]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.696]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.696]                       tmpdir = path, fileext = ".rds")
[13:17:24.696]                     save_rds(obj, file)
[13:17:24.696]                   }
[13:17:24.696]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.696]                   {
[13:17:24.696]                     inherits <- base::inherits
[13:17:24.696]                     invokeRestart <- base::invokeRestart
[13:17:24.696]                     is.null <- base::is.null
[13:17:24.696]                     muffled <- FALSE
[13:17:24.696]                     if (inherits(cond, "message")) {
[13:17:24.696]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.696]                       if (muffled) 
[13:17:24.696]                         invokeRestart("muffleMessage")
[13:17:24.696]                     }
[13:17:24.696]                     else if (inherits(cond, "warning")) {
[13:17:24.696]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.696]                       if (muffled) 
[13:17:24.696]                         invokeRestart("muffleWarning")
[13:17:24.696]                     }
[13:17:24.696]                     else if (inherits(cond, "condition")) {
[13:17:24.696]                       if (!is.null(pattern)) {
[13:17:24.696]                         computeRestarts <- base::computeRestarts
[13:17:24.696]                         grepl <- base::grepl
[13:17:24.696]                         restarts <- computeRestarts(cond)
[13:17:24.696]                         for (restart in restarts) {
[13:17:24.696]                           name <- restart$name
[13:17:24.696]                           if (is.null(name)) 
[13:17:24.696]                             next
[13:17:24.696]                           if (!grepl(pattern, name)) 
[13:17:24.696]                             next
[13:17:24.696]                           invokeRestart(restart)
[13:17:24.696]                           muffled <- TRUE
[13:17:24.696]                           break
[13:17:24.696]                         }
[13:17:24.696]                       }
[13:17:24.696]                     }
[13:17:24.696]                     invisible(muffled)
[13:17:24.696]                   }
[13:17:24.696]                   muffleCondition(cond)
[13:17:24.696]                 })
[13:17:24.696]             }))
[13:17:24.696]             future::FutureResult(value = ...future.value$value, 
[13:17:24.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.696]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.696]                     ...future.globalenv.names))
[13:17:24.696]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.696]         }, condition = base::local({
[13:17:24.696]             c <- base::c
[13:17:24.696]             inherits <- base::inherits
[13:17:24.696]             invokeRestart <- base::invokeRestart
[13:17:24.696]             length <- base::length
[13:17:24.696]             list <- base::list
[13:17:24.696]             seq.int <- base::seq.int
[13:17:24.696]             signalCondition <- base::signalCondition
[13:17:24.696]             sys.calls <- base::sys.calls
[13:17:24.696]             `[[` <- base::`[[`
[13:17:24.696]             `+` <- base::`+`
[13:17:24.696]             `<<-` <- base::`<<-`
[13:17:24.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.696]                   3L)]
[13:17:24.696]             }
[13:17:24.696]             function(cond) {
[13:17:24.696]                 is_error <- inherits(cond, "error")
[13:17:24.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.696]                   NULL)
[13:17:24.696]                 if (is_error) {
[13:17:24.696]                   sessionInformation <- function() {
[13:17:24.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.696]                       search = base::search(), system = base::Sys.info())
[13:17:24.696]                   }
[13:17:24.696]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.696]                     cond$call), session = sessionInformation(), 
[13:17:24.696]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.696]                   signalCondition(cond)
[13:17:24.696]                 }
[13:17:24.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.696]                 "immediateCondition"))) {
[13:17:24.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.696]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.696]                   if (TRUE && !signal) {
[13:17:24.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.696]                     {
[13:17:24.696]                       inherits <- base::inherits
[13:17:24.696]                       invokeRestart <- base::invokeRestart
[13:17:24.696]                       is.null <- base::is.null
[13:17:24.696]                       muffled <- FALSE
[13:17:24.696]                       if (inherits(cond, "message")) {
[13:17:24.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.696]                         if (muffled) 
[13:17:24.696]                           invokeRestart("muffleMessage")
[13:17:24.696]                       }
[13:17:24.696]                       else if (inherits(cond, "warning")) {
[13:17:24.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.696]                         if (muffled) 
[13:17:24.696]                           invokeRestart("muffleWarning")
[13:17:24.696]                       }
[13:17:24.696]                       else if (inherits(cond, "condition")) {
[13:17:24.696]                         if (!is.null(pattern)) {
[13:17:24.696]                           computeRestarts <- base::computeRestarts
[13:17:24.696]                           grepl <- base::grepl
[13:17:24.696]                           restarts <- computeRestarts(cond)
[13:17:24.696]                           for (restart in restarts) {
[13:17:24.696]                             name <- restart$name
[13:17:24.696]                             if (is.null(name)) 
[13:17:24.696]                               next
[13:17:24.696]                             if (!grepl(pattern, name)) 
[13:17:24.696]                               next
[13:17:24.696]                             invokeRestart(restart)
[13:17:24.696]                             muffled <- TRUE
[13:17:24.696]                             break
[13:17:24.696]                           }
[13:17:24.696]                         }
[13:17:24.696]                       }
[13:17:24.696]                       invisible(muffled)
[13:17:24.696]                     }
[13:17:24.696]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.696]                   }
[13:17:24.696]                 }
[13:17:24.696]                 else {
[13:17:24.696]                   if (TRUE) {
[13:17:24.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.696]                     {
[13:17:24.696]                       inherits <- base::inherits
[13:17:24.696]                       invokeRestart <- base::invokeRestart
[13:17:24.696]                       is.null <- base::is.null
[13:17:24.696]                       muffled <- FALSE
[13:17:24.696]                       if (inherits(cond, "message")) {
[13:17:24.696]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.696]                         if (muffled) 
[13:17:24.696]                           invokeRestart("muffleMessage")
[13:17:24.696]                       }
[13:17:24.696]                       else if (inherits(cond, "warning")) {
[13:17:24.696]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.696]                         if (muffled) 
[13:17:24.696]                           invokeRestart("muffleWarning")
[13:17:24.696]                       }
[13:17:24.696]                       else if (inherits(cond, "condition")) {
[13:17:24.696]                         if (!is.null(pattern)) {
[13:17:24.696]                           computeRestarts <- base::computeRestarts
[13:17:24.696]                           grepl <- base::grepl
[13:17:24.696]                           restarts <- computeRestarts(cond)
[13:17:24.696]                           for (restart in restarts) {
[13:17:24.696]                             name <- restart$name
[13:17:24.696]                             if (is.null(name)) 
[13:17:24.696]                               next
[13:17:24.696]                             if (!grepl(pattern, name)) 
[13:17:24.696]                               next
[13:17:24.696]                             invokeRestart(restart)
[13:17:24.696]                             muffled <- TRUE
[13:17:24.696]                             break
[13:17:24.696]                           }
[13:17:24.696]                         }
[13:17:24.696]                       }
[13:17:24.696]                       invisible(muffled)
[13:17:24.696]                     }
[13:17:24.696]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.696]                   }
[13:17:24.696]                 }
[13:17:24.696]             }
[13:17:24.696]         }))
[13:17:24.696]     }, error = function(ex) {
[13:17:24.696]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.696]                 ...future.rng), started = ...future.startTime, 
[13:17:24.696]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.696]             version = "1.8"), class = "FutureResult")
[13:17:24.696]     }, finally = {
[13:17:24.696]         if (!identical(...future.workdir, getwd())) 
[13:17:24.696]             setwd(...future.workdir)
[13:17:24.696]         {
[13:17:24.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.696]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.696]             }
[13:17:24.696]             base::options(...future.oldOptions)
[13:17:24.696]             if (.Platform$OS.type == "windows") {
[13:17:24.696]                 old_names <- names(...future.oldEnvVars)
[13:17:24.696]                 envs <- base::Sys.getenv()
[13:17:24.696]                 names <- names(envs)
[13:17:24.696]                 common <- intersect(names, old_names)
[13:17:24.696]                 added <- setdiff(names, old_names)
[13:17:24.696]                 removed <- setdiff(old_names, names)
[13:17:24.696]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.696]                   envs[common]]
[13:17:24.696]                 NAMES <- toupper(changed)
[13:17:24.696]                 args <- list()
[13:17:24.696]                 for (kk in seq_along(NAMES)) {
[13:17:24.696]                   name <- changed[[kk]]
[13:17:24.696]                   NAME <- NAMES[[kk]]
[13:17:24.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.696]                     next
[13:17:24.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.696]                 }
[13:17:24.696]                 NAMES <- toupper(added)
[13:17:24.696]                 for (kk in seq_along(NAMES)) {
[13:17:24.696]                   name <- added[[kk]]
[13:17:24.696]                   NAME <- NAMES[[kk]]
[13:17:24.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.696]                     next
[13:17:24.696]                   args[[name]] <- ""
[13:17:24.696]                 }
[13:17:24.696]                 NAMES <- toupper(removed)
[13:17:24.696]                 for (kk in seq_along(NAMES)) {
[13:17:24.696]                   name <- removed[[kk]]
[13:17:24.696]                   NAME <- NAMES[[kk]]
[13:17:24.696]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.696]                     next
[13:17:24.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.696]                 }
[13:17:24.696]                 if (length(args) > 0) 
[13:17:24.696]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.696]             }
[13:17:24.696]             else {
[13:17:24.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.696]             }
[13:17:24.696]             {
[13:17:24.696]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.696]                   0L) {
[13:17:24.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.696]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.696]                   base::options(opts)
[13:17:24.696]                 }
[13:17:24.696]                 {
[13:17:24.696]                   {
[13:17:24.696]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.696]                     NULL
[13:17:24.696]                   }
[13:17:24.696]                   options(future.plan = NULL)
[13:17:24.696]                   if (is.na(NA_character_)) 
[13:17:24.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.696]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.696]                     envir = parent.frame()) 
[13:17:24.696]                   {
[13:17:24.696]                     default_workers <- missing(workers)
[13:17:24.696]                     if (is.function(workers)) 
[13:17:24.696]                       workers <- workers()
[13:17:24.696]                     workers <- structure(as.integer(workers), 
[13:17:24.696]                       class = class(workers))
[13:17:24.696]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.696]                       1L)
[13:17:24.696]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.696]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.696]                       if (default_workers) 
[13:17:24.696]                         supportsMulticore(warn = TRUE)
[13:17:24.696]                       return(sequential(..., envir = envir))
[13:17:24.696]                     }
[13:17:24.696]                     oopts <- options(mc.cores = workers)
[13:17:24.696]                     on.exit(options(oopts))
[13:17:24.696]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.696]                       envir = envir)
[13:17:24.696]                     if (!future$lazy) 
[13:17:24.696]                       future <- run(future)
[13:17:24.696]                     invisible(future)
[13:17:24.696]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.696]                 }
[13:17:24.696]             }
[13:17:24.696]         }
[13:17:24.696]     })
[13:17:24.696]     if (TRUE) {
[13:17:24.696]         base::sink(type = "output", split = FALSE)
[13:17:24.696]         if (TRUE) {
[13:17:24.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.696]         }
[13:17:24.696]         else {
[13:17:24.696]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.696]         }
[13:17:24.696]         base::close(...future.stdout)
[13:17:24.696]         ...future.stdout <- NULL
[13:17:24.696]     }
[13:17:24.696]     ...future.result$conditions <- ...future.conditions
[13:17:24.696]     ...future.result$finished <- base::Sys.time()
[13:17:24.696]     ...future.result
[13:17:24.696] }
[13:17:24.700] assign_globals() ...
[13:17:24.700] List of 5
[13:17:24.700]  $ future.call.arguments    : list()
[13:17:24.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.700]  $ ...future.FUN            :function (x, ...)  
[13:17:24.700]  $ ...future.elements_ii    :List of 1
[13:17:24.700]   ..$ : num [1:4] 2 4 6 8
[13:17:24.700]  $ ...future.seeds_ii       : NULL
[13:17:24.700]  $ ...future.globals.maxSize: NULL
[13:17:24.700]  - attr(*, "where")=List of 5
[13:17:24.700]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.700]  - attr(*, "resolved")= logi FALSE
[13:17:24.700]  - attr(*, "total_size")= num NA
[13:17:24.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.700]  - attr(*, "already-done")= logi TRUE
[13:17:24.707] - copied ‘future.call.arguments’ to environment
[13:17:24.707] - copied ‘...future.FUN’ to environment
[13:17:24.707] - copied ‘...future.elements_ii’ to environment
[13:17:24.707] - copied ‘...future.seeds_ii’ to environment
[13:17:24.708] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.708] assign_globals() ... done
[13:17:24.708] requestCore(): workers = 2
[13:17:24.710] MulticoreFuture started
[13:17:24.711] - Launch lazy future ... done
[13:17:24.711] run() for ‘MulticoreFuture’ ... done
[13:17:24.711] Created future:
[13:17:24.711] plan(): Setting new future strategy stack:
[13:17:24.712] List of future strategies:
[13:17:24.712] 1. sequential:
[13:17:24.712]    - args: function (..., envir = parent.frame())
[13:17:24.712]    - tweaked: FALSE
[13:17:24.712]    - call: NULL
[13:17:24.713] plan(): nbrOfWorkers() = 1
[13:17:24.715] plan(): Setting new future strategy stack:
[13:17:24.715] List of future strategies:
[13:17:24.715] 1. multicore:
[13:17:24.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.715]    - tweaked: FALSE
[13:17:24.715]    - call: plan(strategy)
[13:17:24.711] MulticoreFuture:
[13:17:24.711] Label: ‘future_apply-2’
[13:17:24.711] Expression:
[13:17:24.711] {
[13:17:24.711]     do.call(function(...) {
[13:17:24.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.711]             on.exit(options(oopts), add = TRUE)
[13:17:24.711]         }
[13:17:24.711]         {
[13:17:24.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.711]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.711]             })
[13:17:24.711]         }
[13:17:24.711]     }, args = future.call.arguments)
[13:17:24.711] }
[13:17:24.711] Lazy evaluation: FALSE
[13:17:24.711] Asynchronous evaluation: TRUE
[13:17:24.711] Local evaluation: TRUE
[13:17:24.711] Environment: R_GlobalEnv
[13:17:24.711] Capture standard output: TRUE
[13:17:24.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.711] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.711] Packages: 1 packages (‘stats’)
[13:17:24.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.711] Resolved: FALSE
[13:17:24.711] Value: <not collected>
[13:17:24.711] Conditions captured: <none>
[13:17:24.711] Early signaling: FALSE
[13:17:24.711] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.711] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.724] Chunk #2 of 2 ... DONE
[13:17:24.724] Launching 2 futures (chunks) ... DONE
[13:17:24.724] Resolving 2 futures (chunks) ...
[13:17:24.725] resolve() on list ...
[13:17:24.725]  recursive: 0
[13:17:24.725]  length: 2
[13:17:24.726] plan(): nbrOfWorkers() = 2
[13:17:24.725] 
[13:17:24.728] Future #1
[13:17:24.730] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:24.730] - nx: 2
[13:17:24.730] - relay: TRUE
[13:17:24.731] - stdout: TRUE
[13:17:24.731] - signal: TRUE
[13:17:24.731] - resignal: FALSE
[13:17:24.731] - force: TRUE
[13:17:24.732] - relayed: [n=2] FALSE, FALSE
[13:17:24.732] - queued futures: [n=2] FALSE, FALSE
[13:17:24.732]  - until=1
[13:17:24.733]  - relaying element #1
[13:17:24.733] - relayed: [n=2] TRUE, FALSE
[13:17:24.734] - queued futures: [n=2] TRUE, FALSE
[13:17:24.734] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:24.734]  length: 1 (resolved future 1)
[13:17:24.735] Future #2
[13:17:24.736] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:24.736] - nx: 2
[13:17:24.736] - relay: TRUE
[13:17:24.737] - stdout: TRUE
[13:17:24.737] - signal: TRUE
[13:17:24.737] - resignal: FALSE
[13:17:24.737] - force: TRUE
[13:17:24.737] - relayed: [n=2] TRUE, FALSE
[13:17:24.737] - queued futures: [n=2] TRUE, FALSE
[13:17:24.737]  - until=2
[13:17:24.738]  - relaying element #2
[13:17:24.738] - relayed: [n=2] TRUE, TRUE
[13:17:24.738] - queued futures: [n=2] TRUE, TRUE
[13:17:24.738] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:24.738]  length: 0 (resolved future 2)
[13:17:24.738] Relaying remaining futures
[13:17:24.739] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.739] - nx: 2
[13:17:24.739] - relay: TRUE
[13:17:24.739] - stdout: TRUE
[13:17:24.739] - signal: TRUE
[13:17:24.739] - resignal: FALSE
[13:17:24.739] - force: TRUE
[13:17:24.739] - relayed: [n=2] TRUE, TRUE
[13:17:24.739] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:24.740] - relayed: [n=2] TRUE, TRUE
[13:17:24.740] - queued futures: [n=2] TRUE, TRUE
[13:17:24.740] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.740] resolve() on list ... DONE
[13:17:24.740]  - Number of value chunks collected: 2
[13:17:24.740] Resolving 2 futures (chunks) ... DONE
[13:17:24.740] Reducing values from 2 chunks ...
[13:17:24.741]  - Number of values collected after concatenation: 2
[13:17:24.741]  - Number of values expected: 2
[13:17:24.741] Reducing values from 2 chunks ... DONE
[13:17:24.741] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:17:24.742] getGlobalsAndPackagesXApply() ...
[13:17:24.742]  - future.globals: TRUE
[13:17:24.742] getGlobalsAndPackages() ...
[13:17:24.742] Searching for globals...
[13:17:24.743] - globals found: [1] ‘FUN’
[13:17:24.743] Searching for globals ... DONE
[13:17:24.743] Resolving globals: FALSE
[13:17:24.744] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:24.744] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:24.744] - globals: [1] ‘FUN’
[13:17:24.745] 
[13:17:24.745] getGlobalsAndPackages() ... DONE
[13:17:24.745]  - globals found/used: [n=1] ‘FUN’
[13:17:24.745]  - needed namespaces: [n=0] 
[13:17:24.745] Finding globals ... DONE
[13:17:24.745]  - use_args: TRUE
[13:17:24.745]  - Getting '...' globals ...
[13:17:24.746] resolve() on list ...
[13:17:24.746]  recursive: 0
[13:17:24.746]  length: 1
[13:17:24.746]  elements: ‘...’
[13:17:24.746]  length: 0 (resolved future 1)
[13:17:24.746] resolve() on list ... DONE
[13:17:24.746]    - '...' content: [n=0] 
[13:17:24.746] List of 1
[13:17:24.746]  $ ...: list()
[13:17:24.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.746]  - attr(*, "where")=List of 1
[13:17:24.746]   ..$ ...:<environment: 0x5647b95d1768> 
[13:17:24.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.746]  - attr(*, "resolved")= logi TRUE
[13:17:24.746]  - attr(*, "total_size")= num NA
[13:17:24.749]  - Getting '...' globals ... DONE
[13:17:24.750] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.750] List of 2
[13:17:24.750]  $ ...future.FUN:function (x)  
[13:17:24.750]  $ ...          : list()
[13:17:24.750]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.750]  - attr(*, "where")=List of 2
[13:17:24.750]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.750]   ..$ ...          :<environment: 0x5647b95d1768> 
[13:17:24.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.750]  - attr(*, "resolved")= logi FALSE
[13:17:24.750]  - attr(*, "total_size")= num 848
[13:17:24.753] Packages to be attached in all futures: [n=0] 
[13:17:24.753] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.757] future_lapply() ...
[13:17:24.760] Number of chunks: 2
[13:17:24.761] getGlobalsAndPackagesXApply() ...
[13:17:24.761]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.761]  - use_args: TRUE
[13:17:24.761] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.761] List of 2
[13:17:24.761]  $ ...          : list()
[13:17:24.761]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.761]  $ ...future.FUN:function (x)  
[13:17:24.761]  - attr(*, "where")=List of 2
[13:17:24.761]   ..$ ...          :<environment: 0x5647b95d1768> 
[13:17:24.761]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.761]  - attr(*, "resolved")= logi FALSE
[13:17:24.761]  - attr(*, "total_size")= num NA
[13:17:24.766] Packages to be attached in all futures: [n=0] 
[13:17:24.767] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.767] Number of futures (= number of chunks): 2
[13:17:24.767] Launching 2 futures (chunks) ...
[13:17:24.767] Chunk #1 of 2 ...
[13:17:24.767]  - seeds: <none>
[13:17:24.767] getGlobalsAndPackages() ...
[13:17:24.767] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.768] Resolving globals: FALSE
[13:17:24.768] Tweak future expression to call with '...' arguments ...
[13:17:24.768] {
[13:17:24.768]     do.call(function(...) {
[13:17:24.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.768]             on.exit(options(oopts), add = TRUE)
[13:17:24.768]         }
[13:17:24.768]         {
[13:17:24.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.768]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.768]             })
[13:17:24.768]         }
[13:17:24.768]     }, args = future.call.arguments)
[13:17:24.768] }
[13:17:24.768] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.768] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.769] 
[13:17:24.769] getGlobalsAndPackages() ... DONE
[13:17:24.769] run() for ‘Future’ ...
[13:17:24.769] - state: ‘created’
[13:17:24.769] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.773] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.773] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.773]   - Field: ‘label’
[13:17:24.773]   - Field: ‘local’
[13:17:24.773]   - Field: ‘owner’
[13:17:24.773]   - Field: ‘envir’
[13:17:24.773]   - Field: ‘workers’
[13:17:24.773]   - Field: ‘packages’
[13:17:24.773]   - Field: ‘gc’
[13:17:24.774]   - Field: ‘job’
[13:17:24.774]   - Field: ‘conditions’
[13:17:24.774]   - Field: ‘expr’
[13:17:24.774]   - Field: ‘uuid’
[13:17:24.774]   - Field: ‘seed’
[13:17:24.774]   - Field: ‘version’
[13:17:24.774]   - Field: ‘result’
[13:17:24.774]   - Field: ‘asynchronous’
[13:17:24.774]   - Field: ‘calls’
[13:17:24.774]   - Field: ‘globals’
[13:17:24.775]   - Field: ‘stdout’
[13:17:24.775]   - Field: ‘earlySignal’
[13:17:24.775]   - Field: ‘lazy’
[13:17:24.775]   - Field: ‘state’
[13:17:24.775] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.775] - Launch lazy future ...
[13:17:24.775] Packages needed by the future expression (n = 0): <none>
[13:17:24.775] Packages needed by future strategies (n = 0): <none>
[13:17:24.776] {
[13:17:24.776]     {
[13:17:24.776]         {
[13:17:24.776]             ...future.startTime <- base::Sys.time()
[13:17:24.776]             {
[13:17:24.776]                 {
[13:17:24.776]                   {
[13:17:24.776]                     {
[13:17:24.776]                       base::local({
[13:17:24.776]                         has_future <- base::requireNamespace("future", 
[13:17:24.776]                           quietly = TRUE)
[13:17:24.776]                         if (has_future) {
[13:17:24.776]                           ns <- base::getNamespace("future")
[13:17:24.776]                           version <- ns[[".package"]][["version"]]
[13:17:24.776]                           if (is.null(version)) 
[13:17:24.776]                             version <- utils::packageVersion("future")
[13:17:24.776]                         }
[13:17:24.776]                         else {
[13:17:24.776]                           version <- NULL
[13:17:24.776]                         }
[13:17:24.776]                         if (!has_future || version < "1.8.0") {
[13:17:24.776]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.776]                             "", base::R.version$version.string), 
[13:17:24.776]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.776]                               "release", "version")], collapse = " "), 
[13:17:24.776]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.776]                             info)
[13:17:24.776]                           info <- base::paste(info, collapse = "; ")
[13:17:24.776]                           if (!has_future) {
[13:17:24.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.776]                               info)
[13:17:24.776]                           }
[13:17:24.776]                           else {
[13:17:24.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.776]                               info, version)
[13:17:24.776]                           }
[13:17:24.776]                           base::stop(msg)
[13:17:24.776]                         }
[13:17:24.776]                       })
[13:17:24.776]                     }
[13:17:24.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.776]                     base::options(mc.cores = 1L)
[13:17:24.776]                   }
[13:17:24.776]                   options(future.plan = NULL)
[13:17:24.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.776]                 }
[13:17:24.776]                 ...future.workdir <- getwd()
[13:17:24.776]             }
[13:17:24.776]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.776]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.776]         }
[13:17:24.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.776]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.776]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.776]             base::names(...future.oldOptions))
[13:17:24.776]     }
[13:17:24.776]     if (FALSE) {
[13:17:24.776]     }
[13:17:24.776]     else {
[13:17:24.776]         if (TRUE) {
[13:17:24.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.776]                 open = "w")
[13:17:24.776]         }
[13:17:24.776]         else {
[13:17:24.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.776]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.776]         }
[13:17:24.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.776]             base::sink(type = "output", split = FALSE)
[13:17:24.776]             base::close(...future.stdout)
[13:17:24.776]         }, add = TRUE)
[13:17:24.776]     }
[13:17:24.776]     ...future.frame <- base::sys.nframe()
[13:17:24.776]     ...future.conditions <- base::list()
[13:17:24.776]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.776]     if (FALSE) {
[13:17:24.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.776]     }
[13:17:24.776]     ...future.result <- base::tryCatch({
[13:17:24.776]         base::withCallingHandlers({
[13:17:24.776]             ...future.value <- base::withVisible(base::local({
[13:17:24.776]                 withCallingHandlers({
[13:17:24.776]                   {
[13:17:24.776]                     do.call(function(...) {
[13:17:24.776]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.776]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.776]                         ...future.globals.maxSize)) {
[13:17:24.776]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.776]                         on.exit(options(oopts), add = TRUE)
[13:17:24.776]                       }
[13:17:24.776]                       {
[13:17:24.776]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.776]                           FUN = function(jj) {
[13:17:24.776]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.776]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.776]                           })
[13:17:24.776]                       }
[13:17:24.776]                     }, args = future.call.arguments)
[13:17:24.776]                   }
[13:17:24.776]                 }, immediateCondition = function(cond) {
[13:17:24.776]                   save_rds <- function (object, pathname, ...) 
[13:17:24.776]                   {
[13:17:24.776]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.776]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.776]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.776]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.776]                         fi_tmp[["mtime"]])
[13:17:24.776]                     }
[13:17:24.776]                     tryCatch({
[13:17:24.776]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.776]                     }, error = function(ex) {
[13:17:24.776]                       msg <- conditionMessage(ex)
[13:17:24.776]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.776]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.776]                         fi_tmp[["mtime"]], msg)
[13:17:24.776]                       ex$message <- msg
[13:17:24.776]                       stop(ex)
[13:17:24.776]                     })
[13:17:24.776]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.776]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.776]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.776]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.776]                       fi <- file.info(pathname)
[13:17:24.776]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.776]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.776]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.776]                         fi[["size"]], fi[["mtime"]])
[13:17:24.776]                       stop(msg)
[13:17:24.776]                     }
[13:17:24.776]                     invisible(pathname)
[13:17:24.776]                   }
[13:17:24.776]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.776]                     rootPath = tempdir()) 
[13:17:24.776]                   {
[13:17:24.776]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.776]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.776]                       tmpdir = path, fileext = ".rds")
[13:17:24.776]                     save_rds(obj, file)
[13:17:24.776]                   }
[13:17:24.776]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.776]                   {
[13:17:24.776]                     inherits <- base::inherits
[13:17:24.776]                     invokeRestart <- base::invokeRestart
[13:17:24.776]                     is.null <- base::is.null
[13:17:24.776]                     muffled <- FALSE
[13:17:24.776]                     if (inherits(cond, "message")) {
[13:17:24.776]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.776]                       if (muffled) 
[13:17:24.776]                         invokeRestart("muffleMessage")
[13:17:24.776]                     }
[13:17:24.776]                     else if (inherits(cond, "warning")) {
[13:17:24.776]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.776]                       if (muffled) 
[13:17:24.776]                         invokeRestart("muffleWarning")
[13:17:24.776]                     }
[13:17:24.776]                     else if (inherits(cond, "condition")) {
[13:17:24.776]                       if (!is.null(pattern)) {
[13:17:24.776]                         computeRestarts <- base::computeRestarts
[13:17:24.776]                         grepl <- base::grepl
[13:17:24.776]                         restarts <- computeRestarts(cond)
[13:17:24.776]                         for (restart in restarts) {
[13:17:24.776]                           name <- restart$name
[13:17:24.776]                           if (is.null(name)) 
[13:17:24.776]                             next
[13:17:24.776]                           if (!grepl(pattern, name)) 
[13:17:24.776]                             next
[13:17:24.776]                           invokeRestart(restart)
[13:17:24.776]                           muffled <- TRUE
[13:17:24.776]                           break
[13:17:24.776]                         }
[13:17:24.776]                       }
[13:17:24.776]                     }
[13:17:24.776]                     invisible(muffled)
[13:17:24.776]                   }
[13:17:24.776]                   muffleCondition(cond)
[13:17:24.776]                 })
[13:17:24.776]             }))
[13:17:24.776]             future::FutureResult(value = ...future.value$value, 
[13:17:24.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.776]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.776]                     ...future.globalenv.names))
[13:17:24.776]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.776]         }, condition = base::local({
[13:17:24.776]             c <- base::c
[13:17:24.776]             inherits <- base::inherits
[13:17:24.776]             invokeRestart <- base::invokeRestart
[13:17:24.776]             length <- base::length
[13:17:24.776]             list <- base::list
[13:17:24.776]             seq.int <- base::seq.int
[13:17:24.776]             signalCondition <- base::signalCondition
[13:17:24.776]             sys.calls <- base::sys.calls
[13:17:24.776]             `[[` <- base::`[[`
[13:17:24.776]             `+` <- base::`+`
[13:17:24.776]             `<<-` <- base::`<<-`
[13:17:24.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.776]                   3L)]
[13:17:24.776]             }
[13:17:24.776]             function(cond) {
[13:17:24.776]                 is_error <- inherits(cond, "error")
[13:17:24.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.776]                   NULL)
[13:17:24.776]                 if (is_error) {
[13:17:24.776]                   sessionInformation <- function() {
[13:17:24.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.776]                       search = base::search(), system = base::Sys.info())
[13:17:24.776]                   }
[13:17:24.776]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.776]                     cond$call), session = sessionInformation(), 
[13:17:24.776]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.776]                   signalCondition(cond)
[13:17:24.776]                 }
[13:17:24.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.776]                 "immediateCondition"))) {
[13:17:24.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.776]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.776]                   if (TRUE && !signal) {
[13:17:24.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.776]                     {
[13:17:24.776]                       inherits <- base::inherits
[13:17:24.776]                       invokeRestart <- base::invokeRestart
[13:17:24.776]                       is.null <- base::is.null
[13:17:24.776]                       muffled <- FALSE
[13:17:24.776]                       if (inherits(cond, "message")) {
[13:17:24.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.776]                         if (muffled) 
[13:17:24.776]                           invokeRestart("muffleMessage")
[13:17:24.776]                       }
[13:17:24.776]                       else if (inherits(cond, "warning")) {
[13:17:24.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.776]                         if (muffled) 
[13:17:24.776]                           invokeRestart("muffleWarning")
[13:17:24.776]                       }
[13:17:24.776]                       else if (inherits(cond, "condition")) {
[13:17:24.776]                         if (!is.null(pattern)) {
[13:17:24.776]                           computeRestarts <- base::computeRestarts
[13:17:24.776]                           grepl <- base::grepl
[13:17:24.776]                           restarts <- computeRestarts(cond)
[13:17:24.776]                           for (restart in restarts) {
[13:17:24.776]                             name <- restart$name
[13:17:24.776]                             if (is.null(name)) 
[13:17:24.776]                               next
[13:17:24.776]                             if (!grepl(pattern, name)) 
[13:17:24.776]                               next
[13:17:24.776]                             invokeRestart(restart)
[13:17:24.776]                             muffled <- TRUE
[13:17:24.776]                             break
[13:17:24.776]                           }
[13:17:24.776]                         }
[13:17:24.776]                       }
[13:17:24.776]                       invisible(muffled)
[13:17:24.776]                     }
[13:17:24.776]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.776]                   }
[13:17:24.776]                 }
[13:17:24.776]                 else {
[13:17:24.776]                   if (TRUE) {
[13:17:24.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.776]                     {
[13:17:24.776]                       inherits <- base::inherits
[13:17:24.776]                       invokeRestart <- base::invokeRestart
[13:17:24.776]                       is.null <- base::is.null
[13:17:24.776]                       muffled <- FALSE
[13:17:24.776]                       if (inherits(cond, "message")) {
[13:17:24.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.776]                         if (muffled) 
[13:17:24.776]                           invokeRestart("muffleMessage")
[13:17:24.776]                       }
[13:17:24.776]                       else if (inherits(cond, "warning")) {
[13:17:24.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.776]                         if (muffled) 
[13:17:24.776]                           invokeRestart("muffleWarning")
[13:17:24.776]                       }
[13:17:24.776]                       else if (inherits(cond, "condition")) {
[13:17:24.776]                         if (!is.null(pattern)) {
[13:17:24.776]                           computeRestarts <- base::computeRestarts
[13:17:24.776]                           grepl <- base::grepl
[13:17:24.776]                           restarts <- computeRestarts(cond)
[13:17:24.776]                           for (restart in restarts) {
[13:17:24.776]                             name <- restart$name
[13:17:24.776]                             if (is.null(name)) 
[13:17:24.776]                               next
[13:17:24.776]                             if (!grepl(pattern, name)) 
[13:17:24.776]                               next
[13:17:24.776]                             invokeRestart(restart)
[13:17:24.776]                             muffled <- TRUE
[13:17:24.776]                             break
[13:17:24.776]                           }
[13:17:24.776]                         }
[13:17:24.776]                       }
[13:17:24.776]                       invisible(muffled)
[13:17:24.776]                     }
[13:17:24.776]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.776]                   }
[13:17:24.776]                 }
[13:17:24.776]             }
[13:17:24.776]         }))
[13:17:24.776]     }, error = function(ex) {
[13:17:24.776]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.776]                 ...future.rng), started = ...future.startTime, 
[13:17:24.776]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.776]             version = "1.8"), class = "FutureResult")
[13:17:24.776]     }, finally = {
[13:17:24.776]         if (!identical(...future.workdir, getwd())) 
[13:17:24.776]             setwd(...future.workdir)
[13:17:24.776]         {
[13:17:24.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.776]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.776]             }
[13:17:24.776]             base::options(...future.oldOptions)
[13:17:24.776]             if (.Platform$OS.type == "windows") {
[13:17:24.776]                 old_names <- names(...future.oldEnvVars)
[13:17:24.776]                 envs <- base::Sys.getenv()
[13:17:24.776]                 names <- names(envs)
[13:17:24.776]                 common <- intersect(names, old_names)
[13:17:24.776]                 added <- setdiff(names, old_names)
[13:17:24.776]                 removed <- setdiff(old_names, names)
[13:17:24.776]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.776]                   envs[common]]
[13:17:24.776]                 NAMES <- toupper(changed)
[13:17:24.776]                 args <- list()
[13:17:24.776]                 for (kk in seq_along(NAMES)) {
[13:17:24.776]                   name <- changed[[kk]]
[13:17:24.776]                   NAME <- NAMES[[kk]]
[13:17:24.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.776]                     next
[13:17:24.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.776]                 }
[13:17:24.776]                 NAMES <- toupper(added)
[13:17:24.776]                 for (kk in seq_along(NAMES)) {
[13:17:24.776]                   name <- added[[kk]]
[13:17:24.776]                   NAME <- NAMES[[kk]]
[13:17:24.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.776]                     next
[13:17:24.776]                   args[[name]] <- ""
[13:17:24.776]                 }
[13:17:24.776]                 NAMES <- toupper(removed)
[13:17:24.776]                 for (kk in seq_along(NAMES)) {
[13:17:24.776]                   name <- removed[[kk]]
[13:17:24.776]                   NAME <- NAMES[[kk]]
[13:17:24.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.776]                     next
[13:17:24.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.776]                 }
[13:17:24.776]                 if (length(args) > 0) 
[13:17:24.776]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.776]             }
[13:17:24.776]             else {
[13:17:24.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.776]             }
[13:17:24.776]             {
[13:17:24.776]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.776]                   0L) {
[13:17:24.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.776]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.776]                   base::options(opts)
[13:17:24.776]                 }
[13:17:24.776]                 {
[13:17:24.776]                   {
[13:17:24.776]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.776]                     NULL
[13:17:24.776]                   }
[13:17:24.776]                   options(future.plan = NULL)
[13:17:24.776]                   if (is.na(NA_character_)) 
[13:17:24.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.776]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.776]                     envir = parent.frame()) 
[13:17:24.776]                   {
[13:17:24.776]                     default_workers <- missing(workers)
[13:17:24.776]                     if (is.function(workers)) 
[13:17:24.776]                       workers <- workers()
[13:17:24.776]                     workers <- structure(as.integer(workers), 
[13:17:24.776]                       class = class(workers))
[13:17:24.776]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.776]                       1L)
[13:17:24.776]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.776]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.776]                       if (default_workers) 
[13:17:24.776]                         supportsMulticore(warn = TRUE)
[13:17:24.776]                       return(sequential(..., envir = envir))
[13:17:24.776]                     }
[13:17:24.776]                     oopts <- options(mc.cores = workers)
[13:17:24.776]                     on.exit(options(oopts))
[13:17:24.776]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.776]                       envir = envir)
[13:17:24.776]                     if (!future$lazy) 
[13:17:24.776]                       future <- run(future)
[13:17:24.776]                     invisible(future)
[13:17:24.776]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.776]                 }
[13:17:24.776]             }
[13:17:24.776]         }
[13:17:24.776]     })
[13:17:24.776]     if (TRUE) {
[13:17:24.776]         base::sink(type = "output", split = FALSE)
[13:17:24.776]         if (TRUE) {
[13:17:24.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.776]         }
[13:17:24.776]         else {
[13:17:24.776]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.776]         }
[13:17:24.776]         base::close(...future.stdout)
[13:17:24.776]         ...future.stdout <- NULL
[13:17:24.776]     }
[13:17:24.776]     ...future.result$conditions <- ...future.conditions
[13:17:24.776]     ...future.result$finished <- base::Sys.time()
[13:17:24.776]     ...future.result
[13:17:24.776] }
[13:17:24.778] assign_globals() ...
[13:17:24.778] List of 5
[13:17:24.778]  $ future.call.arguments    : list()
[13:17:24.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.778]  $ ...future.FUN            :function (x)  
[13:17:24.778]  $ ...future.elements_ii    :List of 1
[13:17:24.778]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.778]  $ ...future.seeds_ii       : NULL
[13:17:24.778]  $ ...future.globals.maxSize: NULL
[13:17:24.778]  - attr(*, "where")=List of 5
[13:17:24.778]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.778]  - attr(*, "resolved")= logi FALSE
[13:17:24.778]  - attr(*, "total_size")= num NA
[13:17:24.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.778]  - attr(*, "already-done")= logi TRUE
[13:17:24.783] - copied ‘future.call.arguments’ to environment
[13:17:24.783] - copied ‘...future.FUN’ to environment
[13:17:24.783] - copied ‘...future.elements_ii’ to environment
[13:17:24.783] - copied ‘...future.seeds_ii’ to environment
[13:17:24.784] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.784] assign_globals() ... done
[13:17:24.784] requestCore(): workers = 2
[13:17:24.786] MulticoreFuture started
[13:17:24.786] - Launch lazy future ... done
[13:17:24.787] run() for ‘MulticoreFuture’ ... done
[13:17:24.787] Created future:
[13:17:24.787] plan(): Setting new future strategy stack:
[13:17:24.787] List of future strategies:
[13:17:24.787] 1. sequential:
[13:17:24.787]    - args: function (..., envir = parent.frame())
[13:17:24.787]    - tweaked: FALSE
[13:17:24.787]    - call: NULL
[13:17:24.788] plan(): nbrOfWorkers() = 1
[13:17:24.790] plan(): Setting new future strategy stack:
[13:17:24.790] List of future strategies:
[13:17:24.790] 1. multicore:
[13:17:24.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.790]    - tweaked: FALSE
[13:17:24.790]    - call: plan(strategy)
[13:17:24.795] plan(): nbrOfWorkers() = 2
[13:17:24.787] MulticoreFuture:
[13:17:24.787] Label: ‘future_apply-1’
[13:17:24.787] Expression:
[13:17:24.787] {
[13:17:24.787]     do.call(function(...) {
[13:17:24.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.787]             on.exit(options(oopts), add = TRUE)
[13:17:24.787]         }
[13:17:24.787]         {
[13:17:24.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.787]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.787]             })
[13:17:24.787]         }
[13:17:24.787]     }, args = future.call.arguments)
[13:17:24.787] }
[13:17:24.787] Lazy evaluation: FALSE
[13:17:24.787] Asynchronous evaluation: TRUE
[13:17:24.787] Local evaluation: TRUE
[13:17:24.787] Environment: R_GlobalEnv
[13:17:24.787] Capture standard output: TRUE
[13:17:24.787] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.787] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.787] Packages: <none>
[13:17:24.787] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.787] Resolved: TRUE
[13:17:24.787] Value: <not collected>
[13:17:24.787] Conditions captured: <none>
[13:17:24.787] Early signaling: FALSE
[13:17:24.787] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.787] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.796] Chunk #1 of 2 ... DONE
[13:17:24.797] Chunk #2 of 2 ...
[13:17:24.797]  - seeds: <none>
[13:17:24.797] getGlobalsAndPackages() ...
[13:17:24.797] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.797] Resolving globals: FALSE
[13:17:24.797] Tweak future expression to call with '...' arguments ...
[13:17:24.798] {
[13:17:24.798]     do.call(function(...) {
[13:17:24.798]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.798]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.798]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.798]             on.exit(options(oopts), add = TRUE)
[13:17:24.798]         }
[13:17:24.798]         {
[13:17:24.798]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.798]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.798]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.798]             })
[13:17:24.798]         }
[13:17:24.798]     }, args = future.call.arguments)
[13:17:24.798] }
[13:17:24.798] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.799] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.799] 
[13:17:24.799] getGlobalsAndPackages() ... DONE
[13:17:24.799] run() for ‘Future’ ...
[13:17:24.800] - state: ‘created’
[13:17:24.800] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.804] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.805]   - Field: ‘label’
[13:17:24.808]   - Field: ‘local’
[13:17:24.808]   - Field: ‘owner’
[13:17:24.809]   - Field: ‘envir’
[13:17:24.809]   - Field: ‘workers’
[13:17:24.809]   - Field: ‘packages’
[13:17:24.810]   - Field: ‘gc’
[13:17:24.810]   - Field: ‘job’
[13:17:24.810]   - Field: ‘conditions’
[13:17:24.811]   - Field: ‘expr’
[13:17:24.811]   - Field: ‘uuid’
[13:17:24.811]   - Field: ‘seed’
[13:17:24.811]   - Field: ‘version’
[13:17:24.812]   - Field: ‘result’
[13:17:24.812]   - Field: ‘asynchronous’
[13:17:24.812]   - Field: ‘calls’
[13:17:24.812]   - Field: ‘globals’
[13:17:24.813]   - Field: ‘stdout’
[13:17:24.813]   - Field: ‘earlySignal’
[13:17:24.813]   - Field: ‘lazy’
[13:17:24.813]   - Field: ‘state’
[13:17:24.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.814] - Launch lazy future ...
[13:17:24.814] Packages needed by the future expression (n = 0): <none>
[13:17:24.815] Packages needed by future strategies (n = 0): <none>
[13:17:24.816] {
[13:17:24.816]     {
[13:17:24.816]         {
[13:17:24.816]             ...future.startTime <- base::Sys.time()
[13:17:24.816]             {
[13:17:24.816]                 {
[13:17:24.816]                   {
[13:17:24.816]                     {
[13:17:24.816]                       base::local({
[13:17:24.816]                         has_future <- base::requireNamespace("future", 
[13:17:24.816]                           quietly = TRUE)
[13:17:24.816]                         if (has_future) {
[13:17:24.816]                           ns <- base::getNamespace("future")
[13:17:24.816]                           version <- ns[[".package"]][["version"]]
[13:17:24.816]                           if (is.null(version)) 
[13:17:24.816]                             version <- utils::packageVersion("future")
[13:17:24.816]                         }
[13:17:24.816]                         else {
[13:17:24.816]                           version <- NULL
[13:17:24.816]                         }
[13:17:24.816]                         if (!has_future || version < "1.8.0") {
[13:17:24.816]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.816]                             "", base::R.version$version.string), 
[13:17:24.816]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.816]                               "release", "version")], collapse = " "), 
[13:17:24.816]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.816]                             info)
[13:17:24.816]                           info <- base::paste(info, collapse = "; ")
[13:17:24.816]                           if (!has_future) {
[13:17:24.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.816]                               info)
[13:17:24.816]                           }
[13:17:24.816]                           else {
[13:17:24.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.816]                               info, version)
[13:17:24.816]                           }
[13:17:24.816]                           base::stop(msg)
[13:17:24.816]                         }
[13:17:24.816]                       })
[13:17:24.816]                     }
[13:17:24.816]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.816]                     base::options(mc.cores = 1L)
[13:17:24.816]                   }
[13:17:24.816]                   options(future.plan = NULL)
[13:17:24.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.816]                 }
[13:17:24.816]                 ...future.workdir <- getwd()
[13:17:24.816]             }
[13:17:24.816]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.816]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.816]         }
[13:17:24.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.816]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.816]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.816]             base::names(...future.oldOptions))
[13:17:24.816]     }
[13:17:24.816]     if (FALSE) {
[13:17:24.816]     }
[13:17:24.816]     else {
[13:17:24.816]         if (TRUE) {
[13:17:24.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.816]                 open = "w")
[13:17:24.816]         }
[13:17:24.816]         else {
[13:17:24.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.816]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.816]         }
[13:17:24.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.816]             base::sink(type = "output", split = FALSE)
[13:17:24.816]             base::close(...future.stdout)
[13:17:24.816]         }, add = TRUE)
[13:17:24.816]     }
[13:17:24.816]     ...future.frame <- base::sys.nframe()
[13:17:24.816]     ...future.conditions <- base::list()
[13:17:24.816]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.816]     if (FALSE) {
[13:17:24.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.816]     }
[13:17:24.816]     ...future.result <- base::tryCatch({
[13:17:24.816]         base::withCallingHandlers({
[13:17:24.816]             ...future.value <- base::withVisible(base::local({
[13:17:24.816]                 withCallingHandlers({
[13:17:24.816]                   {
[13:17:24.816]                     do.call(function(...) {
[13:17:24.816]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.816]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.816]                         ...future.globals.maxSize)) {
[13:17:24.816]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.816]                         on.exit(options(oopts), add = TRUE)
[13:17:24.816]                       }
[13:17:24.816]                       {
[13:17:24.816]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.816]                           FUN = function(jj) {
[13:17:24.816]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.816]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.816]                           })
[13:17:24.816]                       }
[13:17:24.816]                     }, args = future.call.arguments)
[13:17:24.816]                   }
[13:17:24.816]                 }, immediateCondition = function(cond) {
[13:17:24.816]                   save_rds <- function (object, pathname, ...) 
[13:17:24.816]                   {
[13:17:24.816]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.816]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.816]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.816]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.816]                         fi_tmp[["mtime"]])
[13:17:24.816]                     }
[13:17:24.816]                     tryCatch({
[13:17:24.816]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.816]                     }, error = function(ex) {
[13:17:24.816]                       msg <- conditionMessage(ex)
[13:17:24.816]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.816]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.816]                         fi_tmp[["mtime"]], msg)
[13:17:24.816]                       ex$message <- msg
[13:17:24.816]                       stop(ex)
[13:17:24.816]                     })
[13:17:24.816]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.816]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.816]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.816]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.816]                       fi <- file.info(pathname)
[13:17:24.816]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.816]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.816]                         fi[["size"]], fi[["mtime"]])
[13:17:24.816]                       stop(msg)
[13:17:24.816]                     }
[13:17:24.816]                     invisible(pathname)
[13:17:24.816]                   }
[13:17:24.816]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.816]                     rootPath = tempdir()) 
[13:17:24.816]                   {
[13:17:24.816]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.816]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.816]                       tmpdir = path, fileext = ".rds")
[13:17:24.816]                     save_rds(obj, file)
[13:17:24.816]                   }
[13:17:24.816]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.816]                   {
[13:17:24.816]                     inherits <- base::inherits
[13:17:24.816]                     invokeRestart <- base::invokeRestart
[13:17:24.816]                     is.null <- base::is.null
[13:17:24.816]                     muffled <- FALSE
[13:17:24.816]                     if (inherits(cond, "message")) {
[13:17:24.816]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.816]                       if (muffled) 
[13:17:24.816]                         invokeRestart("muffleMessage")
[13:17:24.816]                     }
[13:17:24.816]                     else if (inherits(cond, "warning")) {
[13:17:24.816]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.816]                       if (muffled) 
[13:17:24.816]                         invokeRestart("muffleWarning")
[13:17:24.816]                     }
[13:17:24.816]                     else if (inherits(cond, "condition")) {
[13:17:24.816]                       if (!is.null(pattern)) {
[13:17:24.816]                         computeRestarts <- base::computeRestarts
[13:17:24.816]                         grepl <- base::grepl
[13:17:24.816]                         restarts <- computeRestarts(cond)
[13:17:24.816]                         for (restart in restarts) {
[13:17:24.816]                           name <- restart$name
[13:17:24.816]                           if (is.null(name)) 
[13:17:24.816]                             next
[13:17:24.816]                           if (!grepl(pattern, name)) 
[13:17:24.816]                             next
[13:17:24.816]                           invokeRestart(restart)
[13:17:24.816]                           muffled <- TRUE
[13:17:24.816]                           break
[13:17:24.816]                         }
[13:17:24.816]                       }
[13:17:24.816]                     }
[13:17:24.816]                     invisible(muffled)
[13:17:24.816]                   }
[13:17:24.816]                   muffleCondition(cond)
[13:17:24.816]                 })
[13:17:24.816]             }))
[13:17:24.816]             future::FutureResult(value = ...future.value$value, 
[13:17:24.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.816]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.816]                     ...future.globalenv.names))
[13:17:24.816]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.816]         }, condition = base::local({
[13:17:24.816]             c <- base::c
[13:17:24.816]             inherits <- base::inherits
[13:17:24.816]             invokeRestart <- base::invokeRestart
[13:17:24.816]             length <- base::length
[13:17:24.816]             list <- base::list
[13:17:24.816]             seq.int <- base::seq.int
[13:17:24.816]             signalCondition <- base::signalCondition
[13:17:24.816]             sys.calls <- base::sys.calls
[13:17:24.816]             `[[` <- base::`[[`
[13:17:24.816]             `+` <- base::`+`
[13:17:24.816]             `<<-` <- base::`<<-`
[13:17:24.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.816]                   3L)]
[13:17:24.816]             }
[13:17:24.816]             function(cond) {
[13:17:24.816]                 is_error <- inherits(cond, "error")
[13:17:24.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.816]                   NULL)
[13:17:24.816]                 if (is_error) {
[13:17:24.816]                   sessionInformation <- function() {
[13:17:24.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.816]                       search = base::search(), system = base::Sys.info())
[13:17:24.816]                   }
[13:17:24.816]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.816]                     cond$call), session = sessionInformation(), 
[13:17:24.816]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.816]                   signalCondition(cond)
[13:17:24.816]                 }
[13:17:24.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.816]                 "immediateCondition"))) {
[13:17:24.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.816]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.816]                   if (TRUE && !signal) {
[13:17:24.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.816]                     {
[13:17:24.816]                       inherits <- base::inherits
[13:17:24.816]                       invokeRestart <- base::invokeRestart
[13:17:24.816]                       is.null <- base::is.null
[13:17:24.816]                       muffled <- FALSE
[13:17:24.816]                       if (inherits(cond, "message")) {
[13:17:24.816]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.816]                         if (muffled) 
[13:17:24.816]                           invokeRestart("muffleMessage")
[13:17:24.816]                       }
[13:17:24.816]                       else if (inherits(cond, "warning")) {
[13:17:24.816]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.816]                         if (muffled) 
[13:17:24.816]                           invokeRestart("muffleWarning")
[13:17:24.816]                       }
[13:17:24.816]                       else if (inherits(cond, "condition")) {
[13:17:24.816]                         if (!is.null(pattern)) {
[13:17:24.816]                           computeRestarts <- base::computeRestarts
[13:17:24.816]                           grepl <- base::grepl
[13:17:24.816]                           restarts <- computeRestarts(cond)
[13:17:24.816]                           for (restart in restarts) {
[13:17:24.816]                             name <- restart$name
[13:17:24.816]                             if (is.null(name)) 
[13:17:24.816]                               next
[13:17:24.816]                             if (!grepl(pattern, name)) 
[13:17:24.816]                               next
[13:17:24.816]                             invokeRestart(restart)
[13:17:24.816]                             muffled <- TRUE
[13:17:24.816]                             break
[13:17:24.816]                           }
[13:17:24.816]                         }
[13:17:24.816]                       }
[13:17:24.816]                       invisible(muffled)
[13:17:24.816]                     }
[13:17:24.816]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.816]                   }
[13:17:24.816]                 }
[13:17:24.816]                 else {
[13:17:24.816]                   if (TRUE) {
[13:17:24.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.816]                     {
[13:17:24.816]                       inherits <- base::inherits
[13:17:24.816]                       invokeRestart <- base::invokeRestart
[13:17:24.816]                       is.null <- base::is.null
[13:17:24.816]                       muffled <- FALSE
[13:17:24.816]                       if (inherits(cond, "message")) {
[13:17:24.816]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.816]                         if (muffled) 
[13:17:24.816]                           invokeRestart("muffleMessage")
[13:17:24.816]                       }
[13:17:24.816]                       else if (inherits(cond, "warning")) {
[13:17:24.816]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.816]                         if (muffled) 
[13:17:24.816]                           invokeRestart("muffleWarning")
[13:17:24.816]                       }
[13:17:24.816]                       else if (inherits(cond, "condition")) {
[13:17:24.816]                         if (!is.null(pattern)) {
[13:17:24.816]                           computeRestarts <- base::computeRestarts
[13:17:24.816]                           grepl <- base::grepl
[13:17:24.816]                           restarts <- computeRestarts(cond)
[13:17:24.816]                           for (restart in restarts) {
[13:17:24.816]                             name <- restart$name
[13:17:24.816]                             if (is.null(name)) 
[13:17:24.816]                               next
[13:17:24.816]                             if (!grepl(pattern, name)) 
[13:17:24.816]                               next
[13:17:24.816]                             invokeRestart(restart)
[13:17:24.816]                             muffled <- TRUE
[13:17:24.816]                             break
[13:17:24.816]                           }
[13:17:24.816]                         }
[13:17:24.816]                       }
[13:17:24.816]                       invisible(muffled)
[13:17:24.816]                     }
[13:17:24.816]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.816]                   }
[13:17:24.816]                 }
[13:17:24.816]             }
[13:17:24.816]         }))
[13:17:24.816]     }, error = function(ex) {
[13:17:24.816]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.816]                 ...future.rng), started = ...future.startTime, 
[13:17:24.816]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.816]             version = "1.8"), class = "FutureResult")
[13:17:24.816]     }, finally = {
[13:17:24.816]         if (!identical(...future.workdir, getwd())) 
[13:17:24.816]             setwd(...future.workdir)
[13:17:24.816]         {
[13:17:24.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.816]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.816]             }
[13:17:24.816]             base::options(...future.oldOptions)
[13:17:24.816]             if (.Platform$OS.type == "windows") {
[13:17:24.816]                 old_names <- names(...future.oldEnvVars)
[13:17:24.816]                 envs <- base::Sys.getenv()
[13:17:24.816]                 names <- names(envs)
[13:17:24.816]                 common <- intersect(names, old_names)
[13:17:24.816]                 added <- setdiff(names, old_names)
[13:17:24.816]                 removed <- setdiff(old_names, names)
[13:17:24.816]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.816]                   envs[common]]
[13:17:24.816]                 NAMES <- toupper(changed)
[13:17:24.816]                 args <- list()
[13:17:24.816]                 for (kk in seq_along(NAMES)) {
[13:17:24.816]                   name <- changed[[kk]]
[13:17:24.816]                   NAME <- NAMES[[kk]]
[13:17:24.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.816]                     next
[13:17:24.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.816]                 }
[13:17:24.816]                 NAMES <- toupper(added)
[13:17:24.816]                 for (kk in seq_along(NAMES)) {
[13:17:24.816]                   name <- added[[kk]]
[13:17:24.816]                   NAME <- NAMES[[kk]]
[13:17:24.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.816]                     next
[13:17:24.816]                   args[[name]] <- ""
[13:17:24.816]                 }
[13:17:24.816]                 NAMES <- toupper(removed)
[13:17:24.816]                 for (kk in seq_along(NAMES)) {
[13:17:24.816]                   name <- removed[[kk]]
[13:17:24.816]                   NAME <- NAMES[[kk]]
[13:17:24.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.816]                     next
[13:17:24.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.816]                 }
[13:17:24.816]                 if (length(args) > 0) 
[13:17:24.816]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.816]             }
[13:17:24.816]             else {
[13:17:24.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.816]             }
[13:17:24.816]             {
[13:17:24.816]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.816]                   0L) {
[13:17:24.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.816]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.816]                   base::options(opts)
[13:17:24.816]                 }
[13:17:24.816]                 {
[13:17:24.816]                   {
[13:17:24.816]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.816]                     NULL
[13:17:24.816]                   }
[13:17:24.816]                   options(future.plan = NULL)
[13:17:24.816]                   if (is.na(NA_character_)) 
[13:17:24.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.816]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.816]                     envir = parent.frame()) 
[13:17:24.816]                   {
[13:17:24.816]                     default_workers <- missing(workers)
[13:17:24.816]                     if (is.function(workers)) 
[13:17:24.816]                       workers <- workers()
[13:17:24.816]                     workers <- structure(as.integer(workers), 
[13:17:24.816]                       class = class(workers))
[13:17:24.816]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.816]                       1L)
[13:17:24.816]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.816]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.816]                       if (default_workers) 
[13:17:24.816]                         supportsMulticore(warn = TRUE)
[13:17:24.816]                       return(sequential(..., envir = envir))
[13:17:24.816]                     }
[13:17:24.816]                     oopts <- options(mc.cores = workers)
[13:17:24.816]                     on.exit(options(oopts))
[13:17:24.816]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.816]                       envir = envir)
[13:17:24.816]                     if (!future$lazy) 
[13:17:24.816]                       future <- run(future)
[13:17:24.816]                     invisible(future)
[13:17:24.816]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.816]                 }
[13:17:24.816]             }
[13:17:24.816]         }
[13:17:24.816]     })
[13:17:24.816]     if (TRUE) {
[13:17:24.816]         base::sink(type = "output", split = FALSE)
[13:17:24.816]         if (TRUE) {
[13:17:24.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.816]         }
[13:17:24.816]         else {
[13:17:24.816]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.816]         }
[13:17:24.816]         base::close(...future.stdout)
[13:17:24.816]         ...future.stdout <- NULL
[13:17:24.816]     }
[13:17:24.816]     ...future.result$conditions <- ...future.conditions
[13:17:24.816]     ...future.result$finished <- base::Sys.time()
[13:17:24.816]     ...future.result
[13:17:24.816] }
[13:17:24.818] assign_globals() ...
[13:17:24.819] List of 5
[13:17:24.819]  $ future.call.arguments    : list()
[13:17:24.819]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.819]  $ ...future.FUN            :function (x)  
[13:17:24.819]  $ ...future.elements_ii    :List of 1
[13:17:24.819]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.819]  $ ...future.seeds_ii       : NULL
[13:17:24.819]  $ ...future.globals.maxSize: NULL
[13:17:24.819]  - attr(*, "where")=List of 5
[13:17:24.819]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.819]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.819]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.819]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.819]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.819]  - attr(*, "resolved")= logi FALSE
[13:17:24.819]  - attr(*, "total_size")= num NA
[13:17:24.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.819]  - attr(*, "already-done")= logi TRUE
[13:17:24.826] - copied ‘future.call.arguments’ to environment
[13:17:24.826] - copied ‘...future.FUN’ to environment
[13:17:24.827] - copied ‘...future.elements_ii’ to environment
[13:17:24.827] - copied ‘...future.seeds_ii’ to environment
[13:17:24.827] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.827] assign_globals() ... done
[13:17:24.827] requestCore(): workers = 2
[13:17:24.829] MulticoreFuture started
[13:17:24.830] - Launch lazy future ... done
[13:17:24.830] run() for ‘MulticoreFuture’ ... done
[13:17:24.830] Created future:
[13:17:24.831] plan(): Setting new future strategy stack:
[13:17:24.831] List of future strategies:
[13:17:24.831] 1. sequential:
[13:17:24.831]    - args: function (..., envir = parent.frame())
[13:17:24.831]    - tweaked: FALSE
[13:17:24.831]    - call: NULL
[13:17:24.832] plan(): nbrOfWorkers() = 1
[13:17:24.834] plan(): Setting new future strategy stack:
[13:17:24.834] List of future strategies:
[13:17:24.834] 1. multicore:
[13:17:24.834]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.834]    - tweaked: FALSE
[13:17:24.834]    - call: plan(strategy)
[13:17:24.839] plan(): nbrOfWorkers() = 2
[13:17:24.830] MulticoreFuture:
[13:17:24.830] Label: ‘future_apply-2’
[13:17:24.830] Expression:
[13:17:24.830] {
[13:17:24.830]     do.call(function(...) {
[13:17:24.830]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.830]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.830]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.830]             on.exit(options(oopts), add = TRUE)
[13:17:24.830]         }
[13:17:24.830]         {
[13:17:24.830]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.830]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.830]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.830]             })
[13:17:24.830]         }
[13:17:24.830]     }, args = future.call.arguments)
[13:17:24.830] }
[13:17:24.830] Lazy evaluation: FALSE
[13:17:24.830] Asynchronous evaluation: TRUE
[13:17:24.830] Local evaluation: TRUE
[13:17:24.830] Environment: R_GlobalEnv
[13:17:24.830] Capture standard output: TRUE
[13:17:24.830] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.830] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:24.830] Packages: <none>
[13:17:24.830] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.830] Resolved: TRUE
[13:17:24.830] Value: <not collected>
[13:17:24.830] Conditions captured: <none>
[13:17:24.830] Early signaling: FALSE
[13:17:24.830] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.830] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.840] Chunk #2 of 2 ... DONE
[13:17:24.840] Launching 2 futures (chunks) ... DONE
[13:17:24.840] Resolving 2 futures (chunks) ...
[13:17:24.841] resolve() on list ...
[13:17:24.841]  recursive: 0
[13:17:24.841]  length: 2
[13:17:24.841] 
[13:17:24.841] Future #1
[13:17:24.842] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:24.842] - nx: 2
[13:17:24.843] - relay: TRUE
[13:17:24.843] - stdout: TRUE
[13:17:24.843] - signal: TRUE
[13:17:24.843] - resignal: FALSE
[13:17:24.843] - force: TRUE
[13:17:24.843] - relayed: [n=2] FALSE, FALSE
[13:17:24.843] - queued futures: [n=2] FALSE, FALSE
[13:17:24.844]  - until=1
[13:17:24.844]  - relaying element #1
[13:17:24.844] - relayed: [n=2] TRUE, FALSE
[13:17:24.844] - queued futures: [n=2] TRUE, FALSE
[13:17:24.844] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:24.845]  length: 1 (resolved future 1)
[13:17:24.845] Future #2
[13:17:24.846] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:24.846] - nx: 2
[13:17:24.846] - relay: TRUE
[13:17:24.846] - stdout: TRUE
[13:17:24.847] - signal: TRUE
[13:17:24.847] - resignal: FALSE
[13:17:24.847] - force: TRUE
[13:17:24.847] - relayed: [n=2] TRUE, FALSE
[13:17:24.847] - queued futures: [n=2] TRUE, FALSE
[13:17:24.847]  - until=2
[13:17:24.848]  - relaying element #2
[13:17:24.848] - relayed: [n=2] TRUE, TRUE
[13:17:24.848] - queued futures: [n=2] TRUE, TRUE
[13:17:24.848] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:24.848]  length: 0 (resolved future 2)
[13:17:24.848] Relaying remaining futures
[13:17:24.849] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.849] - nx: 2
[13:17:24.849] - relay: TRUE
[13:17:24.849] - stdout: TRUE
[13:17:24.849] - signal: TRUE
[13:17:24.849] - resignal: FALSE
[13:17:24.849] - force: TRUE
[13:17:24.849] - relayed: [n=2] TRUE, TRUE
[13:17:24.849] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:24.850] - relayed: [n=2] TRUE, TRUE
[13:17:24.850] - queued futures: [n=2] TRUE, TRUE
[13:17:24.850] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.850] resolve() on list ... DONE
[13:17:24.850]  - Number of value chunks collected: 2
[13:17:24.850] Resolving 2 futures (chunks) ... DONE
[13:17:24.850] Reducing values from 2 chunks ...
[13:17:24.850]  - Number of values collected after concatenation: 2
[13:17:24.851]  - Number of values expected: 2
[13:17:24.851] Reducing values from 2 chunks ... DONE
[13:17:24.851] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:17:24.851] getGlobalsAndPackagesXApply() ...
[13:17:24.851]  - future.globals: TRUE
[13:17:24.852] getGlobalsAndPackages() ...
[13:17:24.852] Searching for globals...
[13:17:24.853] - globals found: [1] ‘FUN’
[13:17:24.853] Searching for globals ... DONE
[13:17:24.853] Resolving globals: FALSE
[13:17:24.854] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:24.854] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:24.854] - globals: [1] ‘FUN’
[13:17:24.854] 
[13:17:24.855] getGlobalsAndPackages() ... DONE
[13:17:24.857]  - globals found/used: [n=1] ‘FUN’
[13:17:24.857]  - needed namespaces: [n=0] 
[13:17:24.857] Finding globals ... DONE
[13:17:24.857]  - use_args: TRUE
[13:17:24.857]  - Getting '...' globals ...
[13:17:24.858] resolve() on list ...
[13:17:24.858]  recursive: 0
[13:17:24.858]  length: 1
[13:17:24.858]  elements: ‘...’
[13:17:24.859]  length: 0 (resolved future 1)
[13:17:24.859] resolve() on list ... DONE
[13:17:24.859]    - '...' content: [n=0] 
[13:17:24.859] List of 1
[13:17:24.859]  $ ...: list()
[13:17:24.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.859]  - attr(*, "where")=List of 1
[13:17:24.859]   ..$ ...:<environment: 0x5647baf67328> 
[13:17:24.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.859]  - attr(*, "resolved")= logi TRUE
[13:17:24.859]  - attr(*, "total_size")= num NA
[13:17:24.863]  - Getting '...' globals ... DONE
[13:17:24.863] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.863] List of 2
[13:17:24.863]  $ ...future.FUN:function (x)  
[13:17:24.863]  $ ...          : list()
[13:17:24.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.863]  - attr(*, "where")=List of 2
[13:17:24.863]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.863]   ..$ ...          :<environment: 0x5647baf67328> 
[13:17:24.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.863]  - attr(*, "resolved")= logi FALSE
[13:17:24.863]  - attr(*, "total_size")= num 848
[13:17:24.867] Packages to be attached in all futures: [n=0] 
[13:17:24.867] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.871] future_lapply() ...
[13:17:24.874] Number of chunks: 2
[13:17:24.875] getGlobalsAndPackagesXApply() ...
[13:17:24.875]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.875]  - use_args: TRUE
[13:17:24.875] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.875] List of 2
[13:17:24.875]  $ ...          : list()
[13:17:24.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.875]  $ ...future.FUN:function (x)  
[13:17:24.875]  - attr(*, "where")=List of 2
[13:17:24.875]   ..$ ...          :<environment: 0x5647baf67328> 
[13:17:24.875]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:24.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.875]  - attr(*, "resolved")= logi FALSE
[13:17:24.875]  - attr(*, "total_size")= num NA
[13:17:24.878] Packages to be attached in all futures: [n=0] 
[13:17:24.878] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.879] Number of futures (= number of chunks): 2
[13:17:24.879] Launching 2 futures (chunks) ...
[13:17:24.879] Chunk #1 of 2 ...
[13:17:24.879]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:24.879]  - seeds: <none>
[13:17:24.879] getGlobalsAndPackages() ...
[13:17:24.879] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.879] Resolving globals: FALSE
[13:17:24.879] Tweak future expression to call with '...' arguments ...
[13:17:24.880] {
[13:17:24.880]     do.call(function(...) {
[13:17:24.880]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.880]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.880]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.880]             on.exit(options(oopts), add = TRUE)
[13:17:24.880]         }
[13:17:24.880]         {
[13:17:24.880]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.880]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.880]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.880]             })
[13:17:24.880]         }
[13:17:24.880]     }, args = future.call.arguments)
[13:17:24.880] }
[13:17:24.880] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.880] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.880] 
[13:17:24.880] getGlobalsAndPackages() ... DONE
[13:17:24.881] run() for ‘Future’ ...
[13:17:24.881] - state: ‘created’
[13:17:24.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.884] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.884]   - Field: ‘label’
[13:17:24.885]   - Field: ‘local’
[13:17:24.885]   - Field: ‘owner’
[13:17:24.885]   - Field: ‘envir’
[13:17:24.885]   - Field: ‘workers’
[13:17:24.885]   - Field: ‘packages’
[13:17:24.885]   - Field: ‘gc’
[13:17:24.885]   - Field: ‘job’
[13:17:24.885]   - Field: ‘conditions’
[13:17:24.885]   - Field: ‘expr’
[13:17:24.885]   - Field: ‘uuid’
[13:17:24.886]   - Field: ‘seed’
[13:17:24.886]   - Field: ‘version’
[13:17:24.886]   - Field: ‘result’
[13:17:24.886]   - Field: ‘asynchronous’
[13:17:24.886]   - Field: ‘calls’
[13:17:24.886]   - Field: ‘globals’
[13:17:24.886]   - Field: ‘stdout’
[13:17:24.886]   - Field: ‘earlySignal’
[13:17:24.886]   - Field: ‘lazy’
[13:17:24.886]   - Field: ‘state’
[13:17:24.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.887] - Launch lazy future ...
[13:17:24.888] Packages needed by the future expression (n = 0): <none>
[13:17:24.888] Packages needed by future strategies (n = 0): <none>
[13:17:24.889] {
[13:17:24.889]     {
[13:17:24.889]         {
[13:17:24.889]             ...future.startTime <- base::Sys.time()
[13:17:24.889]             {
[13:17:24.889]                 {
[13:17:24.889]                   {
[13:17:24.889]                     {
[13:17:24.889]                       base::local({
[13:17:24.889]                         has_future <- base::requireNamespace("future", 
[13:17:24.889]                           quietly = TRUE)
[13:17:24.889]                         if (has_future) {
[13:17:24.889]                           ns <- base::getNamespace("future")
[13:17:24.889]                           version <- ns[[".package"]][["version"]]
[13:17:24.889]                           if (is.null(version)) 
[13:17:24.889]                             version <- utils::packageVersion("future")
[13:17:24.889]                         }
[13:17:24.889]                         else {
[13:17:24.889]                           version <- NULL
[13:17:24.889]                         }
[13:17:24.889]                         if (!has_future || version < "1.8.0") {
[13:17:24.889]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.889]                             "", base::R.version$version.string), 
[13:17:24.889]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.889]                               "release", "version")], collapse = " "), 
[13:17:24.889]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.889]                             info)
[13:17:24.889]                           info <- base::paste(info, collapse = "; ")
[13:17:24.889]                           if (!has_future) {
[13:17:24.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.889]                               info)
[13:17:24.889]                           }
[13:17:24.889]                           else {
[13:17:24.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.889]                               info, version)
[13:17:24.889]                           }
[13:17:24.889]                           base::stop(msg)
[13:17:24.889]                         }
[13:17:24.889]                       })
[13:17:24.889]                     }
[13:17:24.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.889]                     base::options(mc.cores = 1L)
[13:17:24.889]                   }
[13:17:24.889]                   options(future.plan = NULL)
[13:17:24.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.889]                 }
[13:17:24.889]                 ...future.workdir <- getwd()
[13:17:24.889]             }
[13:17:24.889]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.889]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.889]         }
[13:17:24.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.889]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.889]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.889]             base::names(...future.oldOptions))
[13:17:24.889]     }
[13:17:24.889]     if (FALSE) {
[13:17:24.889]     }
[13:17:24.889]     else {
[13:17:24.889]         if (TRUE) {
[13:17:24.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.889]                 open = "w")
[13:17:24.889]         }
[13:17:24.889]         else {
[13:17:24.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.889]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.889]         }
[13:17:24.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.889]             base::sink(type = "output", split = FALSE)
[13:17:24.889]             base::close(...future.stdout)
[13:17:24.889]         }, add = TRUE)
[13:17:24.889]     }
[13:17:24.889]     ...future.frame <- base::sys.nframe()
[13:17:24.889]     ...future.conditions <- base::list()
[13:17:24.889]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.889]     if (FALSE) {
[13:17:24.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.889]     }
[13:17:24.889]     ...future.result <- base::tryCatch({
[13:17:24.889]         base::withCallingHandlers({
[13:17:24.889]             ...future.value <- base::withVisible(base::local({
[13:17:24.889]                 withCallingHandlers({
[13:17:24.889]                   {
[13:17:24.889]                     do.call(function(...) {
[13:17:24.889]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.889]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.889]                         ...future.globals.maxSize)) {
[13:17:24.889]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.889]                         on.exit(options(oopts), add = TRUE)
[13:17:24.889]                       }
[13:17:24.889]                       {
[13:17:24.889]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.889]                           FUN = function(jj) {
[13:17:24.889]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.889]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.889]                           })
[13:17:24.889]                       }
[13:17:24.889]                     }, args = future.call.arguments)
[13:17:24.889]                   }
[13:17:24.889]                 }, immediateCondition = function(cond) {
[13:17:24.889]                   save_rds <- function (object, pathname, ...) 
[13:17:24.889]                   {
[13:17:24.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.889]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.889]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.889]                         fi_tmp[["mtime"]])
[13:17:24.889]                     }
[13:17:24.889]                     tryCatch({
[13:17:24.889]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.889]                     }, error = function(ex) {
[13:17:24.889]                       msg <- conditionMessage(ex)
[13:17:24.889]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.889]                         fi_tmp[["mtime"]], msg)
[13:17:24.889]                       ex$message <- msg
[13:17:24.889]                       stop(ex)
[13:17:24.889]                     })
[13:17:24.889]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.889]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.889]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.889]                       fi <- file.info(pathname)
[13:17:24.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.889]                         fi[["size"]], fi[["mtime"]])
[13:17:24.889]                       stop(msg)
[13:17:24.889]                     }
[13:17:24.889]                     invisible(pathname)
[13:17:24.889]                   }
[13:17:24.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.889]                     rootPath = tempdir()) 
[13:17:24.889]                   {
[13:17:24.889]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.889]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.889]                       tmpdir = path, fileext = ".rds")
[13:17:24.889]                     save_rds(obj, file)
[13:17:24.889]                   }
[13:17:24.889]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.889]                   {
[13:17:24.889]                     inherits <- base::inherits
[13:17:24.889]                     invokeRestart <- base::invokeRestart
[13:17:24.889]                     is.null <- base::is.null
[13:17:24.889]                     muffled <- FALSE
[13:17:24.889]                     if (inherits(cond, "message")) {
[13:17:24.889]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.889]                       if (muffled) 
[13:17:24.889]                         invokeRestart("muffleMessage")
[13:17:24.889]                     }
[13:17:24.889]                     else if (inherits(cond, "warning")) {
[13:17:24.889]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.889]                       if (muffled) 
[13:17:24.889]                         invokeRestart("muffleWarning")
[13:17:24.889]                     }
[13:17:24.889]                     else if (inherits(cond, "condition")) {
[13:17:24.889]                       if (!is.null(pattern)) {
[13:17:24.889]                         computeRestarts <- base::computeRestarts
[13:17:24.889]                         grepl <- base::grepl
[13:17:24.889]                         restarts <- computeRestarts(cond)
[13:17:24.889]                         for (restart in restarts) {
[13:17:24.889]                           name <- restart$name
[13:17:24.889]                           if (is.null(name)) 
[13:17:24.889]                             next
[13:17:24.889]                           if (!grepl(pattern, name)) 
[13:17:24.889]                             next
[13:17:24.889]                           invokeRestart(restart)
[13:17:24.889]                           muffled <- TRUE
[13:17:24.889]                           break
[13:17:24.889]                         }
[13:17:24.889]                       }
[13:17:24.889]                     }
[13:17:24.889]                     invisible(muffled)
[13:17:24.889]                   }
[13:17:24.889]                   muffleCondition(cond)
[13:17:24.889]                 })
[13:17:24.889]             }))
[13:17:24.889]             future::FutureResult(value = ...future.value$value, 
[13:17:24.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.889]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.889]                     ...future.globalenv.names))
[13:17:24.889]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.889]         }, condition = base::local({
[13:17:24.889]             c <- base::c
[13:17:24.889]             inherits <- base::inherits
[13:17:24.889]             invokeRestart <- base::invokeRestart
[13:17:24.889]             length <- base::length
[13:17:24.889]             list <- base::list
[13:17:24.889]             seq.int <- base::seq.int
[13:17:24.889]             signalCondition <- base::signalCondition
[13:17:24.889]             sys.calls <- base::sys.calls
[13:17:24.889]             `[[` <- base::`[[`
[13:17:24.889]             `+` <- base::`+`
[13:17:24.889]             `<<-` <- base::`<<-`
[13:17:24.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.889]                   3L)]
[13:17:24.889]             }
[13:17:24.889]             function(cond) {
[13:17:24.889]                 is_error <- inherits(cond, "error")
[13:17:24.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.889]                   NULL)
[13:17:24.889]                 if (is_error) {
[13:17:24.889]                   sessionInformation <- function() {
[13:17:24.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.889]                       search = base::search(), system = base::Sys.info())
[13:17:24.889]                   }
[13:17:24.889]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.889]                     cond$call), session = sessionInformation(), 
[13:17:24.889]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.889]                   signalCondition(cond)
[13:17:24.889]                 }
[13:17:24.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.889]                 "immediateCondition"))) {
[13:17:24.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.889]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.889]                   if (TRUE && !signal) {
[13:17:24.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.889]                     {
[13:17:24.889]                       inherits <- base::inherits
[13:17:24.889]                       invokeRestart <- base::invokeRestart
[13:17:24.889]                       is.null <- base::is.null
[13:17:24.889]                       muffled <- FALSE
[13:17:24.889]                       if (inherits(cond, "message")) {
[13:17:24.889]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.889]                         if (muffled) 
[13:17:24.889]                           invokeRestart("muffleMessage")
[13:17:24.889]                       }
[13:17:24.889]                       else if (inherits(cond, "warning")) {
[13:17:24.889]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.889]                         if (muffled) 
[13:17:24.889]                           invokeRestart("muffleWarning")
[13:17:24.889]                       }
[13:17:24.889]                       else if (inherits(cond, "condition")) {
[13:17:24.889]                         if (!is.null(pattern)) {
[13:17:24.889]                           computeRestarts <- base::computeRestarts
[13:17:24.889]                           grepl <- base::grepl
[13:17:24.889]                           restarts <- computeRestarts(cond)
[13:17:24.889]                           for (restart in restarts) {
[13:17:24.889]                             name <- restart$name
[13:17:24.889]                             if (is.null(name)) 
[13:17:24.889]                               next
[13:17:24.889]                             if (!grepl(pattern, name)) 
[13:17:24.889]                               next
[13:17:24.889]                             invokeRestart(restart)
[13:17:24.889]                             muffled <- TRUE
[13:17:24.889]                             break
[13:17:24.889]                           }
[13:17:24.889]                         }
[13:17:24.889]                       }
[13:17:24.889]                       invisible(muffled)
[13:17:24.889]                     }
[13:17:24.889]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.889]                   }
[13:17:24.889]                 }
[13:17:24.889]                 else {
[13:17:24.889]                   if (TRUE) {
[13:17:24.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.889]                     {
[13:17:24.889]                       inherits <- base::inherits
[13:17:24.889]                       invokeRestart <- base::invokeRestart
[13:17:24.889]                       is.null <- base::is.null
[13:17:24.889]                       muffled <- FALSE
[13:17:24.889]                       if (inherits(cond, "message")) {
[13:17:24.889]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.889]                         if (muffled) 
[13:17:24.889]                           invokeRestart("muffleMessage")
[13:17:24.889]                       }
[13:17:24.889]                       else if (inherits(cond, "warning")) {
[13:17:24.889]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.889]                         if (muffled) 
[13:17:24.889]                           invokeRestart("muffleWarning")
[13:17:24.889]                       }
[13:17:24.889]                       else if (inherits(cond, "condition")) {
[13:17:24.889]                         if (!is.null(pattern)) {
[13:17:24.889]                           computeRestarts <- base::computeRestarts
[13:17:24.889]                           grepl <- base::grepl
[13:17:24.889]                           restarts <- computeRestarts(cond)
[13:17:24.889]                           for (restart in restarts) {
[13:17:24.889]                             name <- restart$name
[13:17:24.889]                             if (is.null(name)) 
[13:17:24.889]                               next
[13:17:24.889]                             if (!grepl(pattern, name)) 
[13:17:24.889]                               next
[13:17:24.889]                             invokeRestart(restart)
[13:17:24.889]                             muffled <- TRUE
[13:17:24.889]                             break
[13:17:24.889]                           }
[13:17:24.889]                         }
[13:17:24.889]                       }
[13:17:24.889]                       invisible(muffled)
[13:17:24.889]                     }
[13:17:24.889]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.889]                   }
[13:17:24.889]                 }
[13:17:24.889]             }
[13:17:24.889]         }))
[13:17:24.889]     }, error = function(ex) {
[13:17:24.889]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.889]                 ...future.rng), started = ...future.startTime, 
[13:17:24.889]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.889]             version = "1.8"), class = "FutureResult")
[13:17:24.889]     }, finally = {
[13:17:24.889]         if (!identical(...future.workdir, getwd())) 
[13:17:24.889]             setwd(...future.workdir)
[13:17:24.889]         {
[13:17:24.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.889]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.889]             }
[13:17:24.889]             base::options(...future.oldOptions)
[13:17:24.889]             if (.Platform$OS.type == "windows") {
[13:17:24.889]                 old_names <- names(...future.oldEnvVars)
[13:17:24.889]                 envs <- base::Sys.getenv()
[13:17:24.889]                 names <- names(envs)
[13:17:24.889]                 common <- intersect(names, old_names)
[13:17:24.889]                 added <- setdiff(names, old_names)
[13:17:24.889]                 removed <- setdiff(old_names, names)
[13:17:24.889]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.889]                   envs[common]]
[13:17:24.889]                 NAMES <- toupper(changed)
[13:17:24.889]                 args <- list()
[13:17:24.889]                 for (kk in seq_along(NAMES)) {
[13:17:24.889]                   name <- changed[[kk]]
[13:17:24.889]                   NAME <- NAMES[[kk]]
[13:17:24.889]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.889]                     next
[13:17:24.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.889]                 }
[13:17:24.889]                 NAMES <- toupper(added)
[13:17:24.889]                 for (kk in seq_along(NAMES)) {
[13:17:24.889]                   name <- added[[kk]]
[13:17:24.889]                   NAME <- NAMES[[kk]]
[13:17:24.889]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.889]                     next
[13:17:24.889]                   args[[name]] <- ""
[13:17:24.889]                 }
[13:17:24.889]                 NAMES <- toupper(removed)
[13:17:24.889]                 for (kk in seq_along(NAMES)) {
[13:17:24.889]                   name <- removed[[kk]]
[13:17:24.889]                   NAME <- NAMES[[kk]]
[13:17:24.889]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.889]                     next
[13:17:24.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.889]                 }
[13:17:24.889]                 if (length(args) > 0) 
[13:17:24.889]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.889]             }
[13:17:24.889]             else {
[13:17:24.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.889]             }
[13:17:24.889]             {
[13:17:24.889]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.889]                   0L) {
[13:17:24.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.889]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.889]                   base::options(opts)
[13:17:24.889]                 }
[13:17:24.889]                 {
[13:17:24.889]                   {
[13:17:24.889]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.889]                     NULL
[13:17:24.889]                   }
[13:17:24.889]                   options(future.plan = NULL)
[13:17:24.889]                   if (is.na(NA_character_)) 
[13:17:24.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.889]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.889]                     envir = parent.frame()) 
[13:17:24.889]                   {
[13:17:24.889]                     default_workers <- missing(workers)
[13:17:24.889]                     if (is.function(workers)) 
[13:17:24.889]                       workers <- workers()
[13:17:24.889]                     workers <- structure(as.integer(workers), 
[13:17:24.889]                       class = class(workers))
[13:17:24.889]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.889]                       1L)
[13:17:24.889]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.889]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.889]                       if (default_workers) 
[13:17:24.889]                         supportsMulticore(warn = TRUE)
[13:17:24.889]                       return(sequential(..., envir = envir))
[13:17:24.889]                     }
[13:17:24.889]                     oopts <- options(mc.cores = workers)
[13:17:24.889]                     on.exit(options(oopts))
[13:17:24.889]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.889]                       envir = envir)
[13:17:24.889]                     if (!future$lazy) 
[13:17:24.889]                       future <- run(future)
[13:17:24.889]                     invisible(future)
[13:17:24.889]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.889]                 }
[13:17:24.889]             }
[13:17:24.889]         }
[13:17:24.889]     })
[13:17:24.889]     if (TRUE) {
[13:17:24.889]         base::sink(type = "output", split = FALSE)
[13:17:24.889]         if (TRUE) {
[13:17:24.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.889]         }
[13:17:24.889]         else {
[13:17:24.889]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.889]         }
[13:17:24.889]         base::close(...future.stdout)
[13:17:24.889]         ...future.stdout <- NULL
[13:17:24.889]     }
[13:17:24.889]     ...future.result$conditions <- ...future.conditions
[13:17:24.889]     ...future.result$finished <- base::Sys.time()
[13:17:24.889]     ...future.result
[13:17:24.889] }
[13:17:24.891] assign_globals() ...
[13:17:24.891] List of 5
[13:17:24.891]  $ future.call.arguments    : list()
[13:17:24.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.891]  $ ...future.FUN            :function (x)  
[13:17:24.891]  $ ...future.elements_ii    :List of 3
[13:17:24.891]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.891]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.891]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.891]  $ ...future.seeds_ii       : NULL
[13:17:24.891]  $ ...future.globals.maxSize: num Inf
[13:17:24.891]  - attr(*, "resolved")= logi FALSE
[13:17:24.891]  - attr(*, "total_size")= num NA
[13:17:24.891]  - attr(*, "where")=List of 5
[13:17:24.891]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.891]  - attr(*, "already-done")= logi TRUE
[13:17:24.897] - copied ‘future.call.arguments’ to environment
[13:17:24.897] - copied ‘...future.FUN’ to environment
[13:17:24.897] - copied ‘...future.elements_ii’ to environment
[13:17:24.897] - copied ‘...future.seeds_ii’ to environment
[13:17:24.897] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.897] assign_globals() ... done
[13:17:24.897] requestCore(): workers = 2
[13:17:24.899] MulticoreFuture started
[13:17:24.899] - Launch lazy future ... done
[13:17:24.900] run() for ‘MulticoreFuture’ ... done
[13:17:24.900] Created future:
[13:17:24.900] plan(): Setting new future strategy stack:
[13:17:24.900] List of future strategies:
[13:17:24.900] 1. sequential:
[13:17:24.900]    - args: function (..., envir = parent.frame())
[13:17:24.900]    - tweaked: FALSE
[13:17:24.900]    - call: NULL
[13:17:24.901] plan(): nbrOfWorkers() = 1
[13:17:24.903] plan(): Setting new future strategy stack:
[13:17:24.903] List of future strategies:
[13:17:24.903] 1. multicore:
[13:17:24.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.903]    - tweaked: FALSE
[13:17:24.903]    - call: plan(strategy)
[13:17:24.908] plan(): nbrOfWorkers() = 2
[13:17:24.900] MulticoreFuture:
[13:17:24.900] Label: ‘future_apply-1’
[13:17:24.900] Expression:
[13:17:24.900] {
[13:17:24.900]     do.call(function(...) {
[13:17:24.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.900]             on.exit(options(oopts), add = TRUE)
[13:17:24.900]         }
[13:17:24.900]         {
[13:17:24.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.900]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.900]             })
[13:17:24.900]         }
[13:17:24.900]     }, args = future.call.arguments)
[13:17:24.900] }
[13:17:24.900] Lazy evaluation: FALSE
[13:17:24.900] Asynchronous evaluation: TRUE
[13:17:24.900] Local evaluation: TRUE
[13:17:24.900] Environment: R_GlobalEnv
[13:17:24.900] Capture standard output: TRUE
[13:17:24.900] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.900] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.900] Packages: <none>
[13:17:24.900] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.900] Resolved: TRUE
[13:17:24.900] Value: <not collected>
[13:17:24.900] Conditions captured: <none>
[13:17:24.900] Early signaling: FALSE
[13:17:24.900] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.900] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.909] Chunk #1 of 2 ... DONE
[13:17:24.910] Chunk #2 of 2 ...
[13:17:24.910]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:24.910]  - seeds: <none>
[13:17:24.910] getGlobalsAndPackages() ...
[13:17:24.910] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.910] Resolving globals: FALSE
[13:17:24.911] Tweak future expression to call with '...' arguments ...
[13:17:24.911] {
[13:17:24.911]     do.call(function(...) {
[13:17:24.911]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.911]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.911]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.911]             on.exit(options(oopts), add = TRUE)
[13:17:24.911]         }
[13:17:24.911]         {
[13:17:24.911]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.911]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.911]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.911]             })
[13:17:24.911]         }
[13:17:24.911]     }, args = future.call.arguments)
[13:17:24.911] }
[13:17:24.911] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.912] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.912] 
[13:17:24.912] getGlobalsAndPackages() ... DONE
[13:17:24.913] run() for ‘Future’ ...
[13:17:24.913] - state: ‘created’
[13:17:24.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.918]   - Field: ‘label’
[13:17:24.918]   - Field: ‘local’
[13:17:24.918]   - Field: ‘owner’
[13:17:24.919]   - Field: ‘envir’
[13:17:24.919]   - Field: ‘workers’
[13:17:24.919]   - Field: ‘packages’
[13:17:24.919]   - Field: ‘gc’
[13:17:24.919]   - Field: ‘job’
[13:17:24.919]   - Field: ‘conditions’
[13:17:24.919]   - Field: ‘expr’
[13:17:24.920]   - Field: ‘uuid’
[13:17:24.920]   - Field: ‘seed’
[13:17:24.920]   - Field: ‘version’
[13:17:24.920]   - Field: ‘result’
[13:17:24.920]   - Field: ‘asynchronous’
[13:17:24.920]   - Field: ‘calls’
[13:17:24.921]   - Field: ‘globals’
[13:17:24.921]   - Field: ‘stdout’
[13:17:24.921]   - Field: ‘earlySignal’
[13:17:24.921]   - Field: ‘lazy’
[13:17:24.921]   - Field: ‘state’
[13:17:24.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:24.921] - Launch lazy future ...
[13:17:24.922] Packages needed by the future expression (n = 0): <none>
[13:17:24.922] Packages needed by future strategies (n = 0): <none>
[13:17:24.923] {
[13:17:24.923]     {
[13:17:24.923]         {
[13:17:24.923]             ...future.startTime <- base::Sys.time()
[13:17:24.923]             {
[13:17:24.923]                 {
[13:17:24.923]                   {
[13:17:24.923]                     {
[13:17:24.923]                       base::local({
[13:17:24.923]                         has_future <- base::requireNamespace("future", 
[13:17:24.923]                           quietly = TRUE)
[13:17:24.923]                         if (has_future) {
[13:17:24.923]                           ns <- base::getNamespace("future")
[13:17:24.923]                           version <- ns[[".package"]][["version"]]
[13:17:24.923]                           if (is.null(version)) 
[13:17:24.923]                             version <- utils::packageVersion("future")
[13:17:24.923]                         }
[13:17:24.923]                         else {
[13:17:24.923]                           version <- NULL
[13:17:24.923]                         }
[13:17:24.923]                         if (!has_future || version < "1.8.0") {
[13:17:24.923]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:24.923]                             "", base::R.version$version.string), 
[13:17:24.923]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:24.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:24.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:24.923]                               "release", "version")], collapse = " "), 
[13:17:24.923]                             hostname = base::Sys.info()[["nodename"]])
[13:17:24.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:24.923]                             info)
[13:17:24.923]                           info <- base::paste(info, collapse = "; ")
[13:17:24.923]                           if (!has_future) {
[13:17:24.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:24.923]                               info)
[13:17:24.923]                           }
[13:17:24.923]                           else {
[13:17:24.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:24.923]                               info, version)
[13:17:24.923]                           }
[13:17:24.923]                           base::stop(msg)
[13:17:24.923]                         }
[13:17:24.923]                       })
[13:17:24.923]                     }
[13:17:24.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:24.923]                     base::options(mc.cores = 1L)
[13:17:24.923]                   }
[13:17:24.923]                   options(future.plan = NULL)
[13:17:24.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:24.923]                 }
[13:17:24.923]                 ...future.workdir <- getwd()
[13:17:24.923]             }
[13:17:24.923]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:24.923]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:24.923]         }
[13:17:24.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:24.923]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:24.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:24.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:24.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:24.923]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:24.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:24.923]             base::names(...future.oldOptions))
[13:17:24.923]     }
[13:17:24.923]     if (FALSE) {
[13:17:24.923]     }
[13:17:24.923]     else {
[13:17:24.923]         if (TRUE) {
[13:17:24.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:24.923]                 open = "w")
[13:17:24.923]         }
[13:17:24.923]         else {
[13:17:24.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:24.923]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:24.923]         }
[13:17:24.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:24.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:24.923]             base::sink(type = "output", split = FALSE)
[13:17:24.923]             base::close(...future.stdout)
[13:17:24.923]         }, add = TRUE)
[13:17:24.923]     }
[13:17:24.923]     ...future.frame <- base::sys.nframe()
[13:17:24.923]     ...future.conditions <- base::list()
[13:17:24.923]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:24.923]     if (FALSE) {
[13:17:24.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:24.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:24.923]     }
[13:17:24.923]     ...future.result <- base::tryCatch({
[13:17:24.923]         base::withCallingHandlers({
[13:17:24.923]             ...future.value <- base::withVisible(base::local({
[13:17:24.923]                 withCallingHandlers({
[13:17:24.923]                   {
[13:17:24.923]                     do.call(function(...) {
[13:17:24.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.923]                       if (!identical(...future.globals.maxSize.org, 
[13:17:24.923]                         ...future.globals.maxSize)) {
[13:17:24.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.923]                         on.exit(options(oopts), add = TRUE)
[13:17:24.923]                       }
[13:17:24.923]                       {
[13:17:24.923]                         lapply(seq_along(...future.elements_ii), 
[13:17:24.923]                           FUN = function(jj) {
[13:17:24.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.923]                             ...future.FUN(...future.X_jj, ...)
[13:17:24.923]                           })
[13:17:24.923]                       }
[13:17:24.923]                     }, args = future.call.arguments)
[13:17:24.923]                   }
[13:17:24.923]                 }, immediateCondition = function(cond) {
[13:17:24.923]                   save_rds <- function (object, pathname, ...) 
[13:17:24.923]                   {
[13:17:24.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:24.923]                     if (file_test("-f", pathname_tmp)) {
[13:17:24.923]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:24.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.923]                         fi_tmp[["mtime"]])
[13:17:24.923]                     }
[13:17:24.923]                     tryCatch({
[13:17:24.923]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:24.923]                     }, error = function(ex) {
[13:17:24.923]                       msg <- conditionMessage(ex)
[13:17:24.923]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:24.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.923]                         fi_tmp[["mtime"]], msg)
[13:17:24.923]                       ex$message <- msg
[13:17:24.923]                       stop(ex)
[13:17:24.923]                     })
[13:17:24.923]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:24.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:24.923]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:24.923]                       fi_tmp <- file.info(pathname_tmp)
[13:17:24.923]                       fi <- file.info(pathname)
[13:17:24.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:24.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:24.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:24.923]                         fi[["size"]], fi[["mtime"]])
[13:17:24.923]                       stop(msg)
[13:17:24.923]                     }
[13:17:24.923]                     invisible(pathname)
[13:17:24.923]                   }
[13:17:24.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:24.923]                     rootPath = tempdir()) 
[13:17:24.923]                   {
[13:17:24.923]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:24.923]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:24.923]                       tmpdir = path, fileext = ".rds")
[13:17:24.923]                     save_rds(obj, file)
[13:17:24.923]                   }
[13:17:24.923]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:24.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.923]                   {
[13:17:24.923]                     inherits <- base::inherits
[13:17:24.923]                     invokeRestart <- base::invokeRestart
[13:17:24.923]                     is.null <- base::is.null
[13:17:24.923]                     muffled <- FALSE
[13:17:24.923]                     if (inherits(cond, "message")) {
[13:17:24.923]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:24.923]                       if (muffled) 
[13:17:24.923]                         invokeRestart("muffleMessage")
[13:17:24.923]                     }
[13:17:24.923]                     else if (inherits(cond, "warning")) {
[13:17:24.923]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:24.923]                       if (muffled) 
[13:17:24.923]                         invokeRestart("muffleWarning")
[13:17:24.923]                     }
[13:17:24.923]                     else if (inherits(cond, "condition")) {
[13:17:24.923]                       if (!is.null(pattern)) {
[13:17:24.923]                         computeRestarts <- base::computeRestarts
[13:17:24.923]                         grepl <- base::grepl
[13:17:24.923]                         restarts <- computeRestarts(cond)
[13:17:24.923]                         for (restart in restarts) {
[13:17:24.923]                           name <- restart$name
[13:17:24.923]                           if (is.null(name)) 
[13:17:24.923]                             next
[13:17:24.923]                           if (!grepl(pattern, name)) 
[13:17:24.923]                             next
[13:17:24.923]                           invokeRestart(restart)
[13:17:24.923]                           muffled <- TRUE
[13:17:24.923]                           break
[13:17:24.923]                         }
[13:17:24.923]                       }
[13:17:24.923]                     }
[13:17:24.923]                     invisible(muffled)
[13:17:24.923]                   }
[13:17:24.923]                   muffleCondition(cond)
[13:17:24.923]                 })
[13:17:24.923]             }))
[13:17:24.923]             future::FutureResult(value = ...future.value$value, 
[13:17:24.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.923]                   ...future.rng), globalenv = if (FALSE) 
[13:17:24.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:24.923]                     ...future.globalenv.names))
[13:17:24.923]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:24.923]         }, condition = base::local({
[13:17:24.923]             c <- base::c
[13:17:24.923]             inherits <- base::inherits
[13:17:24.923]             invokeRestart <- base::invokeRestart
[13:17:24.923]             length <- base::length
[13:17:24.923]             list <- base::list
[13:17:24.923]             seq.int <- base::seq.int
[13:17:24.923]             signalCondition <- base::signalCondition
[13:17:24.923]             sys.calls <- base::sys.calls
[13:17:24.923]             `[[` <- base::`[[`
[13:17:24.923]             `+` <- base::`+`
[13:17:24.923]             `<<-` <- base::`<<-`
[13:17:24.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:24.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:24.923]                   3L)]
[13:17:24.923]             }
[13:17:24.923]             function(cond) {
[13:17:24.923]                 is_error <- inherits(cond, "error")
[13:17:24.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:24.923]                   NULL)
[13:17:24.923]                 if (is_error) {
[13:17:24.923]                   sessionInformation <- function() {
[13:17:24.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:24.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:24.923]                       search = base::search(), system = base::Sys.info())
[13:17:24.923]                   }
[13:17:24.923]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:24.923]                     cond$call), session = sessionInformation(), 
[13:17:24.923]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:24.923]                   signalCondition(cond)
[13:17:24.923]                 }
[13:17:24.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:24.923]                 "immediateCondition"))) {
[13:17:24.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:24.923]                   ...future.conditions[[length(...future.conditions) + 
[13:17:24.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:24.923]                   if (TRUE && !signal) {
[13:17:24.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.923]                     {
[13:17:24.923]                       inherits <- base::inherits
[13:17:24.923]                       invokeRestart <- base::invokeRestart
[13:17:24.923]                       is.null <- base::is.null
[13:17:24.923]                       muffled <- FALSE
[13:17:24.923]                       if (inherits(cond, "message")) {
[13:17:24.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.923]                         if (muffled) 
[13:17:24.923]                           invokeRestart("muffleMessage")
[13:17:24.923]                       }
[13:17:24.923]                       else if (inherits(cond, "warning")) {
[13:17:24.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.923]                         if (muffled) 
[13:17:24.923]                           invokeRestart("muffleWarning")
[13:17:24.923]                       }
[13:17:24.923]                       else if (inherits(cond, "condition")) {
[13:17:24.923]                         if (!is.null(pattern)) {
[13:17:24.923]                           computeRestarts <- base::computeRestarts
[13:17:24.923]                           grepl <- base::grepl
[13:17:24.923]                           restarts <- computeRestarts(cond)
[13:17:24.923]                           for (restart in restarts) {
[13:17:24.923]                             name <- restart$name
[13:17:24.923]                             if (is.null(name)) 
[13:17:24.923]                               next
[13:17:24.923]                             if (!grepl(pattern, name)) 
[13:17:24.923]                               next
[13:17:24.923]                             invokeRestart(restart)
[13:17:24.923]                             muffled <- TRUE
[13:17:24.923]                             break
[13:17:24.923]                           }
[13:17:24.923]                         }
[13:17:24.923]                       }
[13:17:24.923]                       invisible(muffled)
[13:17:24.923]                     }
[13:17:24.923]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.923]                   }
[13:17:24.923]                 }
[13:17:24.923]                 else {
[13:17:24.923]                   if (TRUE) {
[13:17:24.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:24.923]                     {
[13:17:24.923]                       inherits <- base::inherits
[13:17:24.923]                       invokeRestart <- base::invokeRestart
[13:17:24.923]                       is.null <- base::is.null
[13:17:24.923]                       muffled <- FALSE
[13:17:24.923]                       if (inherits(cond, "message")) {
[13:17:24.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:24.923]                         if (muffled) 
[13:17:24.923]                           invokeRestart("muffleMessage")
[13:17:24.923]                       }
[13:17:24.923]                       else if (inherits(cond, "warning")) {
[13:17:24.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:24.923]                         if (muffled) 
[13:17:24.923]                           invokeRestart("muffleWarning")
[13:17:24.923]                       }
[13:17:24.923]                       else if (inherits(cond, "condition")) {
[13:17:24.923]                         if (!is.null(pattern)) {
[13:17:24.923]                           computeRestarts <- base::computeRestarts
[13:17:24.923]                           grepl <- base::grepl
[13:17:24.923]                           restarts <- computeRestarts(cond)
[13:17:24.923]                           for (restart in restarts) {
[13:17:24.923]                             name <- restart$name
[13:17:24.923]                             if (is.null(name)) 
[13:17:24.923]                               next
[13:17:24.923]                             if (!grepl(pattern, name)) 
[13:17:24.923]                               next
[13:17:24.923]                             invokeRestart(restart)
[13:17:24.923]                             muffled <- TRUE
[13:17:24.923]                             break
[13:17:24.923]                           }
[13:17:24.923]                         }
[13:17:24.923]                       }
[13:17:24.923]                       invisible(muffled)
[13:17:24.923]                     }
[13:17:24.923]                     muffleCondition(cond, pattern = "^muffle")
[13:17:24.923]                   }
[13:17:24.923]                 }
[13:17:24.923]             }
[13:17:24.923]         }))
[13:17:24.923]     }, error = function(ex) {
[13:17:24.923]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:24.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:24.923]                 ...future.rng), started = ...future.startTime, 
[13:17:24.923]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:24.923]             version = "1.8"), class = "FutureResult")
[13:17:24.923]     }, finally = {
[13:17:24.923]         if (!identical(...future.workdir, getwd())) 
[13:17:24.923]             setwd(...future.workdir)
[13:17:24.923]         {
[13:17:24.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:24.923]                 ...future.oldOptions$nwarnings <- NULL
[13:17:24.923]             }
[13:17:24.923]             base::options(...future.oldOptions)
[13:17:24.923]             if (.Platform$OS.type == "windows") {
[13:17:24.923]                 old_names <- names(...future.oldEnvVars)
[13:17:24.923]                 envs <- base::Sys.getenv()
[13:17:24.923]                 names <- names(envs)
[13:17:24.923]                 common <- intersect(names, old_names)
[13:17:24.923]                 added <- setdiff(names, old_names)
[13:17:24.923]                 removed <- setdiff(old_names, names)
[13:17:24.923]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:24.923]                   envs[common]]
[13:17:24.923]                 NAMES <- toupper(changed)
[13:17:24.923]                 args <- list()
[13:17:24.923]                 for (kk in seq_along(NAMES)) {
[13:17:24.923]                   name <- changed[[kk]]
[13:17:24.923]                   NAME <- NAMES[[kk]]
[13:17:24.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.923]                     next
[13:17:24.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.923]                 }
[13:17:24.923]                 NAMES <- toupper(added)
[13:17:24.923]                 for (kk in seq_along(NAMES)) {
[13:17:24.923]                   name <- added[[kk]]
[13:17:24.923]                   NAME <- NAMES[[kk]]
[13:17:24.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.923]                     next
[13:17:24.923]                   args[[name]] <- ""
[13:17:24.923]                 }
[13:17:24.923]                 NAMES <- toupper(removed)
[13:17:24.923]                 for (kk in seq_along(NAMES)) {
[13:17:24.923]                   name <- removed[[kk]]
[13:17:24.923]                   NAME <- NAMES[[kk]]
[13:17:24.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:24.923]                     next
[13:17:24.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:24.923]                 }
[13:17:24.923]                 if (length(args) > 0) 
[13:17:24.923]                   base::do.call(base::Sys.setenv, args = args)
[13:17:24.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:24.923]             }
[13:17:24.923]             else {
[13:17:24.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:24.923]             }
[13:17:24.923]             {
[13:17:24.923]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:24.923]                   0L) {
[13:17:24.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:24.923]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:24.923]                   base::options(opts)
[13:17:24.923]                 }
[13:17:24.923]                 {
[13:17:24.923]                   {
[13:17:24.923]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:24.923]                     NULL
[13:17:24.923]                   }
[13:17:24.923]                   options(future.plan = NULL)
[13:17:24.923]                   if (is.na(NA_character_)) 
[13:17:24.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:24.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:24.923]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:24.923]                     envir = parent.frame()) 
[13:17:24.923]                   {
[13:17:24.923]                     default_workers <- missing(workers)
[13:17:24.923]                     if (is.function(workers)) 
[13:17:24.923]                       workers <- workers()
[13:17:24.923]                     workers <- structure(as.integer(workers), 
[13:17:24.923]                       class = class(workers))
[13:17:24.923]                     stop_if_not(is.finite(workers), workers >= 
[13:17:24.923]                       1L)
[13:17:24.923]                     if ((workers == 1L && !inherits(workers, 
[13:17:24.923]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:24.923]                       if (default_workers) 
[13:17:24.923]                         supportsMulticore(warn = TRUE)
[13:17:24.923]                       return(sequential(..., envir = envir))
[13:17:24.923]                     }
[13:17:24.923]                     oopts <- options(mc.cores = workers)
[13:17:24.923]                     on.exit(options(oopts))
[13:17:24.923]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:24.923]                       envir = envir)
[13:17:24.923]                     if (!future$lazy) 
[13:17:24.923]                       future <- run(future)
[13:17:24.923]                     invisible(future)
[13:17:24.923]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:24.923]                 }
[13:17:24.923]             }
[13:17:24.923]         }
[13:17:24.923]     })
[13:17:24.923]     if (TRUE) {
[13:17:24.923]         base::sink(type = "output", split = FALSE)
[13:17:24.923]         if (TRUE) {
[13:17:24.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:24.923]         }
[13:17:24.923]         else {
[13:17:24.923]             ...future.result["stdout"] <- base::list(NULL)
[13:17:24.923]         }
[13:17:24.923]         base::close(...future.stdout)
[13:17:24.923]         ...future.stdout <- NULL
[13:17:24.923]     }
[13:17:24.923]     ...future.result$conditions <- ...future.conditions
[13:17:24.923]     ...future.result$finished <- base::Sys.time()
[13:17:24.923]     ...future.result
[13:17:24.923] }
[13:17:24.926] assign_globals() ...
[13:17:24.926] List of 5
[13:17:24.926]  $ future.call.arguments    : list()
[13:17:24.926]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.926]  $ ...future.FUN            :function (x)  
[13:17:24.926]  $ ...future.elements_ii    :List of 3
[13:17:24.926]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.926]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[13:17:24.926]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[13:17:24.926]  $ ...future.seeds_ii       : NULL
[13:17:24.926]  $ ...future.globals.maxSize: num Inf
[13:17:24.926]  - attr(*, "resolved")= logi FALSE
[13:17:24.926]  - attr(*, "total_size")= num NA
[13:17:24.926]  - attr(*, "where")=List of 5
[13:17:24.926]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:24.926]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:24.926]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:24.926]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:24.926]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:24.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.926]  - attr(*, "already-done")= logi TRUE
[13:17:24.939] - copied ‘future.call.arguments’ to environment
[13:17:24.939] - copied ‘...future.FUN’ to environment
[13:17:24.939] - copied ‘...future.elements_ii’ to environment
[13:17:24.940] - copied ‘...future.seeds_ii’ to environment
[13:17:24.940] - copied ‘...future.globals.maxSize’ to environment
[13:17:24.940] assign_globals() ... done
[13:17:24.940] requestCore(): workers = 2
[13:17:24.942] MulticoreFuture started
[13:17:24.943] - Launch lazy future ... done
[13:17:24.943] run() for ‘MulticoreFuture’ ... done
[13:17:24.943] plan(): Setting new future strategy stack:
[13:17:24.943] Created future:
[13:17:24.944] List of future strategies:
[13:17:24.944] 1. sequential:
[13:17:24.944]    - args: function (..., envir = parent.frame())
[13:17:24.944]    - tweaked: FALSE
[13:17:24.944]    - call: NULL
[13:17:24.945] plan(): nbrOfWorkers() = 1
[13:17:24.947] plan(): Setting new future strategy stack:
[13:17:24.947] List of future strategies:
[13:17:24.947] 1. multicore:
[13:17:24.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:24.947]    - tweaked: FALSE
[13:17:24.947]    - call: plan(strategy)
[13:17:24.953] plan(): nbrOfWorkers() = 2
[13:17:24.944] MulticoreFuture:
[13:17:24.944] Label: ‘future_apply-2’
[13:17:24.944] Expression:
[13:17:24.944] {
[13:17:24.944]     do.call(function(...) {
[13:17:24.944]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.944]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.944]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.944]             on.exit(options(oopts), add = TRUE)
[13:17:24.944]         }
[13:17:24.944]         {
[13:17:24.944]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.944]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.944]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.944]             })
[13:17:24.944]         }
[13:17:24.944]     }, args = future.call.arguments)
[13:17:24.944] }
[13:17:24.944] Lazy evaluation: FALSE
[13:17:24.944] Asynchronous evaluation: TRUE
[13:17:24.944] Local evaluation: TRUE
[13:17:24.944] Environment: R_GlobalEnv
[13:17:24.944] Capture standard output: TRUE
[13:17:24.944] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:24.944] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:24.944] Packages: <none>
[13:17:24.944] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:24.944] Resolved: TRUE
[13:17:24.944] Value: <not collected>
[13:17:24.944] Conditions captured: <none>
[13:17:24.944] Early signaling: FALSE
[13:17:24.944] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:24.944] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.954] Chunk #2 of 2 ... DONE
[13:17:24.955] Launching 2 futures (chunks) ... DONE
[13:17:24.955] Resolving 2 futures (chunks) ...
[13:17:24.955] resolve() on list ...
[13:17:24.955]  recursive: 0
[13:17:24.956]  length: 2
[13:17:24.956] 
[13:17:24.956] Future #1
[13:17:24.958] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:24.958] - nx: 2
[13:17:24.958] - relay: TRUE
[13:17:24.958] - stdout: TRUE
[13:17:24.958] - signal: TRUE
[13:17:24.958] - resignal: FALSE
[13:17:24.958] - force: TRUE
[13:17:24.959] - relayed: [n=2] FALSE, FALSE
[13:17:24.959] - queued futures: [n=2] FALSE, FALSE
[13:17:24.959]  - until=1
[13:17:24.959]  - relaying element #1
[13:17:24.960] - relayed: [n=2] TRUE, FALSE
[13:17:24.960] - queued futures: [n=2] TRUE, FALSE
[13:17:24.960] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:24.960]  length: 1 (resolved future 1)
[13:17:24.961] Future #2
[13:17:24.961] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:24.962] - nx: 2
[13:17:24.962] - relay: TRUE
[13:17:24.962] - stdout: TRUE
[13:17:24.962] - signal: TRUE
[13:17:24.962] - resignal: FALSE
[13:17:24.962] - force: TRUE
[13:17:24.963] - relayed: [n=2] TRUE, FALSE
[13:17:24.963] - queued futures: [n=2] TRUE, FALSE
[13:17:24.963]  - until=2
[13:17:24.963]  - relaying element #2
[13:17:24.963] - relayed: [n=2] TRUE, TRUE
[13:17:24.964] - queued futures: [n=2] TRUE, TRUE
[13:17:24.964] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:24.964]  length: 0 (resolved future 2)
[13:17:24.964] Relaying remaining futures
[13:17:24.964] signalConditionsASAP(NULL, pos=0) ...
[13:17:24.964] - nx: 2
[13:17:24.964] - relay: TRUE
[13:17:24.965] - stdout: TRUE
[13:17:24.965] - signal: TRUE
[13:17:24.965] - resignal: FALSE
[13:17:24.965] - force: TRUE
[13:17:24.965] - relayed: [n=2] TRUE, TRUE
[13:17:24.965] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:24.965] - relayed: [n=2] TRUE, TRUE
[13:17:24.965] - queued futures: [n=2] TRUE, TRUE
[13:17:24.966] signalConditionsASAP(NULL, pos=0) ... done
[13:17:24.966] resolve() on list ... DONE
[13:17:24.966]  - Number of value chunks collected: 2
[13:17:24.966] Resolving 2 futures (chunks) ... DONE
[13:17:24.966] Reducing values from 2 chunks ...
[13:17:24.966]  - Number of values collected after concatenation: 6
[13:17:24.966]  - Number of values expected: 6
[13:17:24.966] Reducing values from 2 chunks ... DONE
[13:17:24.967] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:17:24.967] getGlobalsAndPackagesXApply() ...
[13:17:24.967]  - future.globals: TRUE
[13:17:24.967] getGlobalsAndPackages() ...
[13:17:24.968] Searching for globals...
[13:17:24.969] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:17:24.969] Searching for globals ... DONE
[13:17:24.969] Resolving globals: FALSE
[13:17:24.970] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:17:24.970] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:17:24.971] - globals: [1] ‘FUN’
[13:17:24.971] 
[13:17:24.971] getGlobalsAndPackages() ... DONE
[13:17:24.971]  - globals found/used: [n=1] ‘FUN’
[13:17:24.971]  - needed namespaces: [n=0] 
[13:17:24.971] Finding globals ... DONE
[13:17:24.971]  - use_args: TRUE
[13:17:24.971]  - Getting '...' globals ...
[13:17:24.972] resolve() on list ...
[13:17:24.972]  recursive: 0
[13:17:24.972]  length: 1
[13:17:24.972]  elements: ‘...’
[13:17:24.972]  length: 0 (resolved future 1)
[13:17:24.972] resolve() on list ... DONE
[13:17:24.972]    - '...' content: [n=0] 
[13:17:24.973] List of 1
[13:17:24.973]  $ ...: list()
[13:17:24.973]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.973]  - attr(*, "where")=List of 1
[13:17:24.973]   ..$ ...:<environment: 0x5647ba7b7c88> 
[13:17:24.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.973]  - attr(*, "resolved")= logi TRUE
[13:17:24.973]  - attr(*, "total_size")= num NA
[13:17:24.976]  - Getting '...' globals ... DONE
[13:17:24.976] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:24.976] List of 2
[13:17:24.976]  $ ...future.FUN:function (x)  
[13:17:24.976]  $ ...          : list()
[13:17:24.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.976]  - attr(*, "where")=List of 2
[13:17:24.976]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:24.976]   ..$ ...          :<environment: 0x5647ba7b7c88> 
[13:17:24.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.976]  - attr(*, "resolved")= logi FALSE
[13:17:24.976]  - attr(*, "total_size")= num 1768
[13:17:24.982] Packages to be attached in all futures: [n=0] 
[13:17:24.982] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.986] future_lapply() ...
[13:17:24.989] Number of chunks: 2
[13:17:24.990] getGlobalsAndPackagesXApply() ...
[13:17:24.990]  - future.globals: <name-value list> with names ‘list()’
[13:17:24.990]  - use_args: TRUE
[13:17:24.990] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:24.990] List of 2
[13:17:24.990]  $ ...          : list()
[13:17:24.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:24.990]  $ ...future.FUN:function (x)  
[13:17:24.990]  - attr(*, "where")=List of 2
[13:17:24.990]   ..$ ...          :<environment: 0x5647ba7b7c88> 
[13:17:24.990]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:17:24.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:24.990]  - attr(*, "resolved")= logi FALSE
[13:17:24.990]  - attr(*, "total_size")= num NA
[13:17:24.993] Packages to be attached in all futures: [n=0] 
[13:17:24.993] getGlobalsAndPackagesXApply() ... DONE
[13:17:24.993] Number of futures (= number of chunks): 2
[13:17:24.993] Launching 2 futures (chunks) ...
[13:17:24.993] Chunk #1 of 2 ...
[13:17:24.994]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:24.994]  - seeds: <none>
[13:17:24.994] getGlobalsAndPackages() ...
[13:17:24.994] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.994] Resolving globals: FALSE
[13:17:24.994] Tweak future expression to call with '...' arguments ...
[13:17:24.994] {
[13:17:24.994]     do.call(function(...) {
[13:17:24.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:24.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:24.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:24.994]             on.exit(options(oopts), add = TRUE)
[13:17:24.994]         }
[13:17:24.994]         {
[13:17:24.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:24.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:24.994]                 ...future.FUN(...future.X_jj, ...)
[13:17:24.994]             })
[13:17:24.994]         }
[13:17:24.994]     }, args = future.call.arguments)
[13:17:24.994] }
[13:17:24.995] Tweak future expression to call with '...' arguments ... DONE
[13:17:24.995] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:24.995] 
[13:17:24.995] getGlobalsAndPackages() ... DONE
[13:17:24.995] run() for ‘Future’ ...
[13:17:24.996] - state: ‘created’
[13:17:24.996] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:24.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:24.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:24.999]   - Field: ‘label’
[13:17:25.000]   - Field: ‘local’
[13:17:25.000]   - Field: ‘owner’
[13:17:25.000]   - Field: ‘envir’
[13:17:25.000]   - Field: ‘workers’
[13:17:25.000]   - Field: ‘packages’
[13:17:25.000]   - Field: ‘gc’
[13:17:25.000]   - Field: ‘job’
[13:17:25.000]   - Field: ‘conditions’
[13:17:25.000]   - Field: ‘expr’
[13:17:25.000]   - Field: ‘uuid’
[13:17:25.001]   - Field: ‘seed’
[13:17:25.001]   - Field: ‘version’
[13:17:25.001]   - Field: ‘result’
[13:17:25.001]   - Field: ‘asynchronous’
[13:17:25.001]   - Field: ‘calls’
[13:17:25.001]   - Field: ‘globals’
[13:17:25.001]   - Field: ‘stdout’
[13:17:25.001]   - Field: ‘earlySignal’
[13:17:25.001]   - Field: ‘lazy’
[13:17:25.001]   - Field: ‘state’
[13:17:25.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.002] - Launch lazy future ...
[13:17:25.002] Packages needed by the future expression (n = 0): <none>
[13:17:25.002] Packages needed by future strategies (n = 0): <none>
[13:17:25.003] {
[13:17:25.003]     {
[13:17:25.003]         {
[13:17:25.003]             ...future.startTime <- base::Sys.time()
[13:17:25.003]             {
[13:17:25.003]                 {
[13:17:25.003]                   {
[13:17:25.003]                     {
[13:17:25.003]                       base::local({
[13:17:25.003]                         has_future <- base::requireNamespace("future", 
[13:17:25.003]                           quietly = TRUE)
[13:17:25.003]                         if (has_future) {
[13:17:25.003]                           ns <- base::getNamespace("future")
[13:17:25.003]                           version <- ns[[".package"]][["version"]]
[13:17:25.003]                           if (is.null(version)) 
[13:17:25.003]                             version <- utils::packageVersion("future")
[13:17:25.003]                         }
[13:17:25.003]                         else {
[13:17:25.003]                           version <- NULL
[13:17:25.003]                         }
[13:17:25.003]                         if (!has_future || version < "1.8.0") {
[13:17:25.003]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.003]                             "", base::R.version$version.string), 
[13:17:25.003]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.003]                               "release", "version")], collapse = " "), 
[13:17:25.003]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.003]                             info)
[13:17:25.003]                           info <- base::paste(info, collapse = "; ")
[13:17:25.003]                           if (!has_future) {
[13:17:25.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.003]                               info)
[13:17:25.003]                           }
[13:17:25.003]                           else {
[13:17:25.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.003]                               info, version)
[13:17:25.003]                           }
[13:17:25.003]                           base::stop(msg)
[13:17:25.003]                         }
[13:17:25.003]                       })
[13:17:25.003]                     }
[13:17:25.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.003]                     base::options(mc.cores = 1L)
[13:17:25.003]                   }
[13:17:25.003]                   options(future.plan = NULL)
[13:17:25.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.003]                 }
[13:17:25.003]                 ...future.workdir <- getwd()
[13:17:25.003]             }
[13:17:25.003]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.003]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.003]         }
[13:17:25.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.003]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.003]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.003]             base::names(...future.oldOptions))
[13:17:25.003]     }
[13:17:25.003]     if (FALSE) {
[13:17:25.003]     }
[13:17:25.003]     else {
[13:17:25.003]         if (TRUE) {
[13:17:25.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.003]                 open = "w")
[13:17:25.003]         }
[13:17:25.003]         else {
[13:17:25.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.003]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.003]         }
[13:17:25.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.003]             base::sink(type = "output", split = FALSE)
[13:17:25.003]             base::close(...future.stdout)
[13:17:25.003]         }, add = TRUE)
[13:17:25.003]     }
[13:17:25.003]     ...future.frame <- base::sys.nframe()
[13:17:25.003]     ...future.conditions <- base::list()
[13:17:25.003]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.003]     if (FALSE) {
[13:17:25.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.003]     }
[13:17:25.003]     ...future.result <- base::tryCatch({
[13:17:25.003]         base::withCallingHandlers({
[13:17:25.003]             ...future.value <- base::withVisible(base::local({
[13:17:25.003]                 withCallingHandlers({
[13:17:25.003]                   {
[13:17:25.003]                     do.call(function(...) {
[13:17:25.003]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.003]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.003]                         ...future.globals.maxSize)) {
[13:17:25.003]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.003]                         on.exit(options(oopts), add = TRUE)
[13:17:25.003]                       }
[13:17:25.003]                       {
[13:17:25.003]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.003]                           FUN = function(jj) {
[13:17:25.003]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.003]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.003]                           })
[13:17:25.003]                       }
[13:17:25.003]                     }, args = future.call.arguments)
[13:17:25.003]                   }
[13:17:25.003]                 }, immediateCondition = function(cond) {
[13:17:25.003]                   save_rds <- function (object, pathname, ...) 
[13:17:25.003]                   {
[13:17:25.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.003]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.003]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.003]                         fi_tmp[["mtime"]])
[13:17:25.003]                     }
[13:17:25.003]                     tryCatch({
[13:17:25.003]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.003]                     }, error = function(ex) {
[13:17:25.003]                       msg <- conditionMessage(ex)
[13:17:25.003]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.003]                         fi_tmp[["mtime"]], msg)
[13:17:25.003]                       ex$message <- msg
[13:17:25.003]                       stop(ex)
[13:17:25.003]                     })
[13:17:25.003]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.003]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.003]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.003]                       fi <- file.info(pathname)
[13:17:25.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.003]                         fi[["size"]], fi[["mtime"]])
[13:17:25.003]                       stop(msg)
[13:17:25.003]                     }
[13:17:25.003]                     invisible(pathname)
[13:17:25.003]                   }
[13:17:25.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.003]                     rootPath = tempdir()) 
[13:17:25.003]                   {
[13:17:25.003]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.003]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.003]                       tmpdir = path, fileext = ".rds")
[13:17:25.003]                     save_rds(obj, file)
[13:17:25.003]                   }
[13:17:25.003]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.003]                   {
[13:17:25.003]                     inherits <- base::inherits
[13:17:25.003]                     invokeRestart <- base::invokeRestart
[13:17:25.003]                     is.null <- base::is.null
[13:17:25.003]                     muffled <- FALSE
[13:17:25.003]                     if (inherits(cond, "message")) {
[13:17:25.003]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.003]                       if (muffled) 
[13:17:25.003]                         invokeRestart("muffleMessage")
[13:17:25.003]                     }
[13:17:25.003]                     else if (inherits(cond, "warning")) {
[13:17:25.003]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.003]                       if (muffled) 
[13:17:25.003]                         invokeRestart("muffleWarning")
[13:17:25.003]                     }
[13:17:25.003]                     else if (inherits(cond, "condition")) {
[13:17:25.003]                       if (!is.null(pattern)) {
[13:17:25.003]                         computeRestarts <- base::computeRestarts
[13:17:25.003]                         grepl <- base::grepl
[13:17:25.003]                         restarts <- computeRestarts(cond)
[13:17:25.003]                         for (restart in restarts) {
[13:17:25.003]                           name <- restart$name
[13:17:25.003]                           if (is.null(name)) 
[13:17:25.003]                             next
[13:17:25.003]                           if (!grepl(pattern, name)) 
[13:17:25.003]                             next
[13:17:25.003]                           invokeRestart(restart)
[13:17:25.003]                           muffled <- TRUE
[13:17:25.003]                           break
[13:17:25.003]                         }
[13:17:25.003]                       }
[13:17:25.003]                     }
[13:17:25.003]                     invisible(muffled)
[13:17:25.003]                   }
[13:17:25.003]                   muffleCondition(cond)
[13:17:25.003]                 })
[13:17:25.003]             }))
[13:17:25.003]             future::FutureResult(value = ...future.value$value, 
[13:17:25.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.003]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.003]                     ...future.globalenv.names))
[13:17:25.003]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.003]         }, condition = base::local({
[13:17:25.003]             c <- base::c
[13:17:25.003]             inherits <- base::inherits
[13:17:25.003]             invokeRestart <- base::invokeRestart
[13:17:25.003]             length <- base::length
[13:17:25.003]             list <- base::list
[13:17:25.003]             seq.int <- base::seq.int
[13:17:25.003]             signalCondition <- base::signalCondition
[13:17:25.003]             sys.calls <- base::sys.calls
[13:17:25.003]             `[[` <- base::`[[`
[13:17:25.003]             `+` <- base::`+`
[13:17:25.003]             `<<-` <- base::`<<-`
[13:17:25.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.003]                   3L)]
[13:17:25.003]             }
[13:17:25.003]             function(cond) {
[13:17:25.003]                 is_error <- inherits(cond, "error")
[13:17:25.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.003]                   NULL)
[13:17:25.003]                 if (is_error) {
[13:17:25.003]                   sessionInformation <- function() {
[13:17:25.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.003]                       search = base::search(), system = base::Sys.info())
[13:17:25.003]                   }
[13:17:25.003]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.003]                     cond$call), session = sessionInformation(), 
[13:17:25.003]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.003]                   signalCondition(cond)
[13:17:25.003]                 }
[13:17:25.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.003]                 "immediateCondition"))) {
[13:17:25.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.003]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.003]                   if (TRUE && !signal) {
[13:17:25.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.003]                     {
[13:17:25.003]                       inherits <- base::inherits
[13:17:25.003]                       invokeRestart <- base::invokeRestart
[13:17:25.003]                       is.null <- base::is.null
[13:17:25.003]                       muffled <- FALSE
[13:17:25.003]                       if (inherits(cond, "message")) {
[13:17:25.003]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.003]                         if (muffled) 
[13:17:25.003]                           invokeRestart("muffleMessage")
[13:17:25.003]                       }
[13:17:25.003]                       else if (inherits(cond, "warning")) {
[13:17:25.003]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.003]                         if (muffled) 
[13:17:25.003]                           invokeRestart("muffleWarning")
[13:17:25.003]                       }
[13:17:25.003]                       else if (inherits(cond, "condition")) {
[13:17:25.003]                         if (!is.null(pattern)) {
[13:17:25.003]                           computeRestarts <- base::computeRestarts
[13:17:25.003]                           grepl <- base::grepl
[13:17:25.003]                           restarts <- computeRestarts(cond)
[13:17:25.003]                           for (restart in restarts) {
[13:17:25.003]                             name <- restart$name
[13:17:25.003]                             if (is.null(name)) 
[13:17:25.003]                               next
[13:17:25.003]                             if (!grepl(pattern, name)) 
[13:17:25.003]                               next
[13:17:25.003]                             invokeRestart(restart)
[13:17:25.003]                             muffled <- TRUE
[13:17:25.003]                             break
[13:17:25.003]                           }
[13:17:25.003]                         }
[13:17:25.003]                       }
[13:17:25.003]                       invisible(muffled)
[13:17:25.003]                     }
[13:17:25.003]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.003]                   }
[13:17:25.003]                 }
[13:17:25.003]                 else {
[13:17:25.003]                   if (TRUE) {
[13:17:25.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.003]                     {
[13:17:25.003]                       inherits <- base::inherits
[13:17:25.003]                       invokeRestart <- base::invokeRestart
[13:17:25.003]                       is.null <- base::is.null
[13:17:25.003]                       muffled <- FALSE
[13:17:25.003]                       if (inherits(cond, "message")) {
[13:17:25.003]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.003]                         if (muffled) 
[13:17:25.003]                           invokeRestart("muffleMessage")
[13:17:25.003]                       }
[13:17:25.003]                       else if (inherits(cond, "warning")) {
[13:17:25.003]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.003]                         if (muffled) 
[13:17:25.003]                           invokeRestart("muffleWarning")
[13:17:25.003]                       }
[13:17:25.003]                       else if (inherits(cond, "condition")) {
[13:17:25.003]                         if (!is.null(pattern)) {
[13:17:25.003]                           computeRestarts <- base::computeRestarts
[13:17:25.003]                           grepl <- base::grepl
[13:17:25.003]                           restarts <- computeRestarts(cond)
[13:17:25.003]                           for (restart in restarts) {
[13:17:25.003]                             name <- restart$name
[13:17:25.003]                             if (is.null(name)) 
[13:17:25.003]                               next
[13:17:25.003]                             if (!grepl(pattern, name)) 
[13:17:25.003]                               next
[13:17:25.003]                             invokeRestart(restart)
[13:17:25.003]                             muffled <- TRUE
[13:17:25.003]                             break
[13:17:25.003]                           }
[13:17:25.003]                         }
[13:17:25.003]                       }
[13:17:25.003]                       invisible(muffled)
[13:17:25.003]                     }
[13:17:25.003]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.003]                   }
[13:17:25.003]                 }
[13:17:25.003]             }
[13:17:25.003]         }))
[13:17:25.003]     }, error = function(ex) {
[13:17:25.003]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.003]                 ...future.rng), started = ...future.startTime, 
[13:17:25.003]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.003]             version = "1.8"), class = "FutureResult")
[13:17:25.003]     }, finally = {
[13:17:25.003]         if (!identical(...future.workdir, getwd())) 
[13:17:25.003]             setwd(...future.workdir)
[13:17:25.003]         {
[13:17:25.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.003]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.003]             }
[13:17:25.003]             base::options(...future.oldOptions)
[13:17:25.003]             if (.Platform$OS.type == "windows") {
[13:17:25.003]                 old_names <- names(...future.oldEnvVars)
[13:17:25.003]                 envs <- base::Sys.getenv()
[13:17:25.003]                 names <- names(envs)
[13:17:25.003]                 common <- intersect(names, old_names)
[13:17:25.003]                 added <- setdiff(names, old_names)
[13:17:25.003]                 removed <- setdiff(old_names, names)
[13:17:25.003]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.003]                   envs[common]]
[13:17:25.003]                 NAMES <- toupper(changed)
[13:17:25.003]                 args <- list()
[13:17:25.003]                 for (kk in seq_along(NAMES)) {
[13:17:25.003]                   name <- changed[[kk]]
[13:17:25.003]                   NAME <- NAMES[[kk]]
[13:17:25.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.003]                     next
[13:17:25.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.003]                 }
[13:17:25.003]                 NAMES <- toupper(added)
[13:17:25.003]                 for (kk in seq_along(NAMES)) {
[13:17:25.003]                   name <- added[[kk]]
[13:17:25.003]                   NAME <- NAMES[[kk]]
[13:17:25.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.003]                     next
[13:17:25.003]                   args[[name]] <- ""
[13:17:25.003]                 }
[13:17:25.003]                 NAMES <- toupper(removed)
[13:17:25.003]                 for (kk in seq_along(NAMES)) {
[13:17:25.003]                   name <- removed[[kk]]
[13:17:25.003]                   NAME <- NAMES[[kk]]
[13:17:25.003]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.003]                     next
[13:17:25.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.003]                 }
[13:17:25.003]                 if (length(args) > 0) 
[13:17:25.003]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.003]             }
[13:17:25.003]             else {
[13:17:25.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.003]             }
[13:17:25.003]             {
[13:17:25.003]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.003]                   0L) {
[13:17:25.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.003]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.003]                   base::options(opts)
[13:17:25.003]                 }
[13:17:25.003]                 {
[13:17:25.003]                   {
[13:17:25.003]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.003]                     NULL
[13:17:25.003]                   }
[13:17:25.003]                   options(future.plan = NULL)
[13:17:25.003]                   if (is.na(NA_character_)) 
[13:17:25.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.003]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.003]                     envir = parent.frame()) 
[13:17:25.003]                   {
[13:17:25.003]                     default_workers <- missing(workers)
[13:17:25.003]                     if (is.function(workers)) 
[13:17:25.003]                       workers <- workers()
[13:17:25.003]                     workers <- structure(as.integer(workers), 
[13:17:25.003]                       class = class(workers))
[13:17:25.003]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.003]                       1L)
[13:17:25.003]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.003]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.003]                       if (default_workers) 
[13:17:25.003]                         supportsMulticore(warn = TRUE)
[13:17:25.003]                       return(sequential(..., envir = envir))
[13:17:25.003]                     }
[13:17:25.003]                     oopts <- options(mc.cores = workers)
[13:17:25.003]                     on.exit(options(oopts))
[13:17:25.003]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.003]                       envir = envir)
[13:17:25.003]                     if (!future$lazy) 
[13:17:25.003]                       future <- run(future)
[13:17:25.003]                     invisible(future)
[13:17:25.003]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.003]                 }
[13:17:25.003]             }
[13:17:25.003]         }
[13:17:25.003]     })
[13:17:25.003]     if (TRUE) {
[13:17:25.003]         base::sink(type = "output", split = FALSE)
[13:17:25.003]         if (TRUE) {
[13:17:25.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.003]         }
[13:17:25.003]         else {
[13:17:25.003]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.003]         }
[13:17:25.003]         base::close(...future.stdout)
[13:17:25.003]         ...future.stdout <- NULL
[13:17:25.003]     }
[13:17:25.003]     ...future.result$conditions <- ...future.conditions
[13:17:25.003]     ...future.result$finished <- base::Sys.time()
[13:17:25.003]     ...future.result
[13:17:25.003] }
[13:17:25.005] assign_globals() ...
[13:17:25.005] List of 5
[13:17:25.005]  $ future.call.arguments    : list()
[13:17:25.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.005]  $ ...future.FUN            :function (x)  
[13:17:25.005]  $ ...future.elements_ii    :List of 3
[13:17:25.005]   ..$ : int [1:4] 1 7 13 19
[13:17:25.005]   ..$ : int [1:4] 2 8 14 20
[13:17:25.005]   ..$ : int [1:4] 3 9 15 21
[13:17:25.005]  $ ...future.seeds_ii       : NULL
[13:17:25.005]  $ ...future.globals.maxSize: num Inf
[13:17:25.005]  - attr(*, "resolved")= logi FALSE
[13:17:25.005]  - attr(*, "total_size")= num NA
[13:17:25.005]  - attr(*, "where")=List of 5
[13:17:25.005]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.005]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.005]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.005]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.005]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.005]  - attr(*, "already-done")= logi TRUE
[13:17:25.013] - copied ‘future.call.arguments’ to environment
[13:17:25.013] - reassign environment for ‘...future.FUN’
[13:17:25.013] - copied ‘...future.FUN’ to environment
[13:17:25.014] - copied ‘...future.elements_ii’ to environment
[13:17:25.014] - copied ‘...future.seeds_ii’ to environment
[13:17:25.014] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.014] assign_globals() ... done
[13:17:25.014] requestCore(): workers = 2
[13:17:25.016] MulticoreFuture started
[13:17:25.017] - Launch lazy future ... done
[13:17:25.017] run() for ‘MulticoreFuture’ ... done
[13:17:25.018] Created future:
[13:17:25.018] plan(): Setting new future strategy stack:
[13:17:25.018] List of future strategies:
[13:17:25.018] 1. sequential:
[13:17:25.018]    - args: function (..., envir = parent.frame())
[13:17:25.018]    - tweaked: FALSE
[13:17:25.018]    - call: NULL
[13:17:25.019] plan(): nbrOfWorkers() = 1
[13:17:25.021] plan(): Setting new future strategy stack:
[13:17:25.021] List of future strategies:
[13:17:25.021] 1. multicore:
[13:17:25.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.021]    - tweaked: FALSE
[13:17:25.021]    - call: plan(strategy)
[13:17:25.027] plan(): nbrOfWorkers() = 2
[13:17:25.018] MulticoreFuture:
[13:17:25.018] Label: ‘future_apply-1’
[13:17:25.018] Expression:
[13:17:25.018] {
[13:17:25.018]     do.call(function(...) {
[13:17:25.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.018]             on.exit(options(oopts), add = TRUE)
[13:17:25.018]         }
[13:17:25.018]         {
[13:17:25.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.018]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.018]             })
[13:17:25.018]         }
[13:17:25.018]     }, args = future.call.arguments)
[13:17:25.018] }
[13:17:25.018] Lazy evaluation: FALSE
[13:17:25.018] Asynchronous evaluation: TRUE
[13:17:25.018] Local evaluation: TRUE
[13:17:25.018] Environment: R_GlobalEnv
[13:17:25.018] Capture standard output: TRUE
[13:17:25.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.018] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:25.018] Packages: <none>
[13:17:25.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.018] Resolved: TRUE
[13:17:25.018] Value: <not collected>
[13:17:25.018] Conditions captured: <none>
[13:17:25.018] Early signaling: FALSE
[13:17:25.018] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.018] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.028] Chunk #1 of 2 ... DONE
[13:17:25.029] Chunk #2 of 2 ...
[13:17:25.029]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:25.029]  - seeds: <none>
[13:17:25.029] getGlobalsAndPackages() ...
[13:17:25.030] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.030] Resolving globals: FALSE
[13:17:25.030] Tweak future expression to call with '...' arguments ...
[13:17:25.030] {
[13:17:25.030]     do.call(function(...) {
[13:17:25.030]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.030]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.030]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.030]             on.exit(options(oopts), add = TRUE)
[13:17:25.030]         }
[13:17:25.030]         {
[13:17:25.030]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.030]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.030]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.030]             })
[13:17:25.030]         }
[13:17:25.030]     }, args = future.call.arguments)
[13:17:25.030] }
[13:17:25.031] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.031] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.031] 
[13:17:25.031] getGlobalsAndPackages() ... DONE
[13:17:25.032] run() for ‘Future’ ...
[13:17:25.032] - state: ‘created’
[13:17:25.033] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.037] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.037] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.038]   - Field: ‘label’
[13:17:25.038]   - Field: ‘local’
[13:17:25.038]   - Field: ‘owner’
[13:17:25.038]   - Field: ‘envir’
[13:17:25.038]   - Field: ‘workers’
[13:17:25.038]   - Field: ‘packages’
[13:17:25.039]   - Field: ‘gc’
[13:17:25.039]   - Field: ‘job’
[13:17:25.039]   - Field: ‘conditions’
[13:17:25.039]   - Field: ‘expr’
[13:17:25.039]   - Field: ‘uuid’
[13:17:25.039]   - Field: ‘seed’
[13:17:25.040]   - Field: ‘version’
[13:17:25.040]   - Field: ‘result’
[13:17:25.040]   - Field: ‘asynchronous’
[13:17:25.040]   - Field: ‘calls’
[13:17:25.040]   - Field: ‘globals’
[13:17:25.040]   - Field: ‘stdout’
[13:17:25.040]   - Field: ‘earlySignal’
[13:17:25.041]   - Field: ‘lazy’
[13:17:25.041]   - Field: ‘state’
[13:17:25.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.041] - Launch lazy future ...
[13:17:25.041] Packages needed by the future expression (n = 0): <none>
[13:17:25.042] Packages needed by future strategies (n = 0): <none>
[13:17:25.042] {
[13:17:25.042]     {
[13:17:25.042]         {
[13:17:25.042]             ...future.startTime <- base::Sys.time()
[13:17:25.042]             {
[13:17:25.042]                 {
[13:17:25.042]                   {
[13:17:25.042]                     {
[13:17:25.042]                       base::local({
[13:17:25.042]                         has_future <- base::requireNamespace("future", 
[13:17:25.042]                           quietly = TRUE)
[13:17:25.042]                         if (has_future) {
[13:17:25.042]                           ns <- base::getNamespace("future")
[13:17:25.042]                           version <- ns[[".package"]][["version"]]
[13:17:25.042]                           if (is.null(version)) 
[13:17:25.042]                             version <- utils::packageVersion("future")
[13:17:25.042]                         }
[13:17:25.042]                         else {
[13:17:25.042]                           version <- NULL
[13:17:25.042]                         }
[13:17:25.042]                         if (!has_future || version < "1.8.0") {
[13:17:25.042]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.042]                             "", base::R.version$version.string), 
[13:17:25.042]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.042]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.042]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.042]                               "release", "version")], collapse = " "), 
[13:17:25.042]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.042]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.042]                             info)
[13:17:25.042]                           info <- base::paste(info, collapse = "; ")
[13:17:25.042]                           if (!has_future) {
[13:17:25.042]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.042]                               info)
[13:17:25.042]                           }
[13:17:25.042]                           else {
[13:17:25.042]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.042]                               info, version)
[13:17:25.042]                           }
[13:17:25.042]                           base::stop(msg)
[13:17:25.042]                         }
[13:17:25.042]                       })
[13:17:25.042]                     }
[13:17:25.042]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.042]                     base::options(mc.cores = 1L)
[13:17:25.042]                   }
[13:17:25.042]                   options(future.plan = NULL)
[13:17:25.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.042]                 }
[13:17:25.042]                 ...future.workdir <- getwd()
[13:17:25.042]             }
[13:17:25.042]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.042]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.042]         }
[13:17:25.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.042]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.042]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.042]             base::names(...future.oldOptions))
[13:17:25.042]     }
[13:17:25.042]     if (FALSE) {
[13:17:25.042]     }
[13:17:25.042]     else {
[13:17:25.042]         if (TRUE) {
[13:17:25.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.042]                 open = "w")
[13:17:25.042]         }
[13:17:25.042]         else {
[13:17:25.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.042]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.042]         }
[13:17:25.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.042]             base::sink(type = "output", split = FALSE)
[13:17:25.042]             base::close(...future.stdout)
[13:17:25.042]         }, add = TRUE)
[13:17:25.042]     }
[13:17:25.042]     ...future.frame <- base::sys.nframe()
[13:17:25.042]     ...future.conditions <- base::list()
[13:17:25.042]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.042]     if (FALSE) {
[13:17:25.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.042]     }
[13:17:25.042]     ...future.result <- base::tryCatch({
[13:17:25.042]         base::withCallingHandlers({
[13:17:25.042]             ...future.value <- base::withVisible(base::local({
[13:17:25.042]                 withCallingHandlers({
[13:17:25.042]                   {
[13:17:25.042]                     do.call(function(...) {
[13:17:25.042]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.042]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.042]                         ...future.globals.maxSize)) {
[13:17:25.042]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.042]                         on.exit(options(oopts), add = TRUE)
[13:17:25.042]                       }
[13:17:25.042]                       {
[13:17:25.042]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.042]                           FUN = function(jj) {
[13:17:25.042]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.042]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.042]                           })
[13:17:25.042]                       }
[13:17:25.042]                     }, args = future.call.arguments)
[13:17:25.042]                   }
[13:17:25.042]                 }, immediateCondition = function(cond) {
[13:17:25.042]                   save_rds <- function (object, pathname, ...) 
[13:17:25.042]                   {
[13:17:25.042]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.042]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.042]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.042]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.042]                         fi_tmp[["mtime"]])
[13:17:25.042]                     }
[13:17:25.042]                     tryCatch({
[13:17:25.042]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.042]                     }, error = function(ex) {
[13:17:25.042]                       msg <- conditionMessage(ex)
[13:17:25.042]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.042]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.042]                         fi_tmp[["mtime"]], msg)
[13:17:25.042]                       ex$message <- msg
[13:17:25.042]                       stop(ex)
[13:17:25.042]                     })
[13:17:25.042]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.042]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.042]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.042]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.042]                       fi <- file.info(pathname)
[13:17:25.042]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.042]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.042]                         fi[["size"]], fi[["mtime"]])
[13:17:25.042]                       stop(msg)
[13:17:25.042]                     }
[13:17:25.042]                     invisible(pathname)
[13:17:25.042]                   }
[13:17:25.042]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.042]                     rootPath = tempdir()) 
[13:17:25.042]                   {
[13:17:25.042]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.042]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.042]                       tmpdir = path, fileext = ".rds")
[13:17:25.042]                     save_rds(obj, file)
[13:17:25.042]                   }
[13:17:25.042]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.042]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.042]                   {
[13:17:25.042]                     inherits <- base::inherits
[13:17:25.042]                     invokeRestart <- base::invokeRestart
[13:17:25.042]                     is.null <- base::is.null
[13:17:25.042]                     muffled <- FALSE
[13:17:25.042]                     if (inherits(cond, "message")) {
[13:17:25.042]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.042]                       if (muffled) 
[13:17:25.042]                         invokeRestart("muffleMessage")
[13:17:25.042]                     }
[13:17:25.042]                     else if (inherits(cond, "warning")) {
[13:17:25.042]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.042]                       if (muffled) 
[13:17:25.042]                         invokeRestart("muffleWarning")
[13:17:25.042]                     }
[13:17:25.042]                     else if (inherits(cond, "condition")) {
[13:17:25.042]                       if (!is.null(pattern)) {
[13:17:25.042]                         computeRestarts <- base::computeRestarts
[13:17:25.042]                         grepl <- base::grepl
[13:17:25.042]                         restarts <- computeRestarts(cond)
[13:17:25.042]                         for (restart in restarts) {
[13:17:25.042]                           name <- restart$name
[13:17:25.042]                           if (is.null(name)) 
[13:17:25.042]                             next
[13:17:25.042]                           if (!grepl(pattern, name)) 
[13:17:25.042]                             next
[13:17:25.042]                           invokeRestart(restart)
[13:17:25.042]                           muffled <- TRUE
[13:17:25.042]                           break
[13:17:25.042]                         }
[13:17:25.042]                       }
[13:17:25.042]                     }
[13:17:25.042]                     invisible(muffled)
[13:17:25.042]                   }
[13:17:25.042]                   muffleCondition(cond)
[13:17:25.042]                 })
[13:17:25.042]             }))
[13:17:25.042]             future::FutureResult(value = ...future.value$value, 
[13:17:25.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.042]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.042]                     ...future.globalenv.names))
[13:17:25.042]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.042]         }, condition = base::local({
[13:17:25.042]             c <- base::c
[13:17:25.042]             inherits <- base::inherits
[13:17:25.042]             invokeRestart <- base::invokeRestart
[13:17:25.042]             length <- base::length
[13:17:25.042]             list <- base::list
[13:17:25.042]             seq.int <- base::seq.int
[13:17:25.042]             signalCondition <- base::signalCondition
[13:17:25.042]             sys.calls <- base::sys.calls
[13:17:25.042]             `[[` <- base::`[[`
[13:17:25.042]             `+` <- base::`+`
[13:17:25.042]             `<<-` <- base::`<<-`
[13:17:25.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.042]                   3L)]
[13:17:25.042]             }
[13:17:25.042]             function(cond) {
[13:17:25.042]                 is_error <- inherits(cond, "error")
[13:17:25.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.042]                   NULL)
[13:17:25.042]                 if (is_error) {
[13:17:25.042]                   sessionInformation <- function() {
[13:17:25.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.042]                       search = base::search(), system = base::Sys.info())
[13:17:25.042]                   }
[13:17:25.042]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.042]                     cond$call), session = sessionInformation(), 
[13:17:25.042]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.042]                   signalCondition(cond)
[13:17:25.042]                 }
[13:17:25.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.042]                 "immediateCondition"))) {
[13:17:25.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.042]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.042]                   if (TRUE && !signal) {
[13:17:25.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.042]                     {
[13:17:25.042]                       inherits <- base::inherits
[13:17:25.042]                       invokeRestart <- base::invokeRestart
[13:17:25.042]                       is.null <- base::is.null
[13:17:25.042]                       muffled <- FALSE
[13:17:25.042]                       if (inherits(cond, "message")) {
[13:17:25.042]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.042]                         if (muffled) 
[13:17:25.042]                           invokeRestart("muffleMessage")
[13:17:25.042]                       }
[13:17:25.042]                       else if (inherits(cond, "warning")) {
[13:17:25.042]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.042]                         if (muffled) 
[13:17:25.042]                           invokeRestart("muffleWarning")
[13:17:25.042]                       }
[13:17:25.042]                       else if (inherits(cond, "condition")) {
[13:17:25.042]                         if (!is.null(pattern)) {
[13:17:25.042]                           computeRestarts <- base::computeRestarts
[13:17:25.042]                           grepl <- base::grepl
[13:17:25.042]                           restarts <- computeRestarts(cond)
[13:17:25.042]                           for (restart in restarts) {
[13:17:25.042]                             name <- restart$name
[13:17:25.042]                             if (is.null(name)) 
[13:17:25.042]                               next
[13:17:25.042]                             if (!grepl(pattern, name)) 
[13:17:25.042]                               next
[13:17:25.042]                             invokeRestart(restart)
[13:17:25.042]                             muffled <- TRUE
[13:17:25.042]                             break
[13:17:25.042]                           }
[13:17:25.042]                         }
[13:17:25.042]                       }
[13:17:25.042]                       invisible(muffled)
[13:17:25.042]                     }
[13:17:25.042]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.042]                   }
[13:17:25.042]                 }
[13:17:25.042]                 else {
[13:17:25.042]                   if (TRUE) {
[13:17:25.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.042]                     {
[13:17:25.042]                       inherits <- base::inherits
[13:17:25.042]                       invokeRestart <- base::invokeRestart
[13:17:25.042]                       is.null <- base::is.null
[13:17:25.042]                       muffled <- FALSE
[13:17:25.042]                       if (inherits(cond, "message")) {
[13:17:25.042]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.042]                         if (muffled) 
[13:17:25.042]                           invokeRestart("muffleMessage")
[13:17:25.042]                       }
[13:17:25.042]                       else if (inherits(cond, "warning")) {
[13:17:25.042]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.042]                         if (muffled) 
[13:17:25.042]                           invokeRestart("muffleWarning")
[13:17:25.042]                       }
[13:17:25.042]                       else if (inherits(cond, "condition")) {
[13:17:25.042]                         if (!is.null(pattern)) {
[13:17:25.042]                           computeRestarts <- base::computeRestarts
[13:17:25.042]                           grepl <- base::grepl
[13:17:25.042]                           restarts <- computeRestarts(cond)
[13:17:25.042]                           for (restart in restarts) {
[13:17:25.042]                             name <- restart$name
[13:17:25.042]                             if (is.null(name)) 
[13:17:25.042]                               next
[13:17:25.042]                             if (!grepl(pattern, name)) 
[13:17:25.042]                               next
[13:17:25.042]                             invokeRestart(restart)
[13:17:25.042]                             muffled <- TRUE
[13:17:25.042]                             break
[13:17:25.042]                           }
[13:17:25.042]                         }
[13:17:25.042]                       }
[13:17:25.042]                       invisible(muffled)
[13:17:25.042]                     }
[13:17:25.042]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.042]                   }
[13:17:25.042]                 }
[13:17:25.042]             }
[13:17:25.042]         }))
[13:17:25.042]     }, error = function(ex) {
[13:17:25.042]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.042]                 ...future.rng), started = ...future.startTime, 
[13:17:25.042]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.042]             version = "1.8"), class = "FutureResult")
[13:17:25.042]     }, finally = {
[13:17:25.042]         if (!identical(...future.workdir, getwd())) 
[13:17:25.042]             setwd(...future.workdir)
[13:17:25.042]         {
[13:17:25.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.042]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.042]             }
[13:17:25.042]             base::options(...future.oldOptions)
[13:17:25.042]             if (.Platform$OS.type == "windows") {
[13:17:25.042]                 old_names <- names(...future.oldEnvVars)
[13:17:25.042]                 envs <- base::Sys.getenv()
[13:17:25.042]                 names <- names(envs)
[13:17:25.042]                 common <- intersect(names, old_names)
[13:17:25.042]                 added <- setdiff(names, old_names)
[13:17:25.042]                 removed <- setdiff(old_names, names)
[13:17:25.042]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.042]                   envs[common]]
[13:17:25.042]                 NAMES <- toupper(changed)
[13:17:25.042]                 args <- list()
[13:17:25.042]                 for (kk in seq_along(NAMES)) {
[13:17:25.042]                   name <- changed[[kk]]
[13:17:25.042]                   NAME <- NAMES[[kk]]
[13:17:25.042]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.042]                     next
[13:17:25.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.042]                 }
[13:17:25.042]                 NAMES <- toupper(added)
[13:17:25.042]                 for (kk in seq_along(NAMES)) {
[13:17:25.042]                   name <- added[[kk]]
[13:17:25.042]                   NAME <- NAMES[[kk]]
[13:17:25.042]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.042]                     next
[13:17:25.042]                   args[[name]] <- ""
[13:17:25.042]                 }
[13:17:25.042]                 NAMES <- toupper(removed)
[13:17:25.042]                 for (kk in seq_along(NAMES)) {
[13:17:25.042]                   name <- removed[[kk]]
[13:17:25.042]                   NAME <- NAMES[[kk]]
[13:17:25.042]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.042]                     next
[13:17:25.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.042]                 }
[13:17:25.042]                 if (length(args) > 0) 
[13:17:25.042]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.042]             }
[13:17:25.042]             else {
[13:17:25.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.042]             }
[13:17:25.042]             {
[13:17:25.042]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.042]                   0L) {
[13:17:25.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.042]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.042]                   base::options(opts)
[13:17:25.042]                 }
[13:17:25.042]                 {
[13:17:25.042]                   {
[13:17:25.042]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.042]                     NULL
[13:17:25.042]                   }
[13:17:25.042]                   options(future.plan = NULL)
[13:17:25.042]                   if (is.na(NA_character_)) 
[13:17:25.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.042]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.042]                     envir = parent.frame()) 
[13:17:25.042]                   {
[13:17:25.042]                     default_workers <- missing(workers)
[13:17:25.042]                     if (is.function(workers)) 
[13:17:25.042]                       workers <- workers()
[13:17:25.042]                     workers <- structure(as.integer(workers), 
[13:17:25.042]                       class = class(workers))
[13:17:25.042]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.042]                       1L)
[13:17:25.042]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.042]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.042]                       if (default_workers) 
[13:17:25.042]                         supportsMulticore(warn = TRUE)
[13:17:25.042]                       return(sequential(..., envir = envir))
[13:17:25.042]                     }
[13:17:25.042]                     oopts <- options(mc.cores = workers)
[13:17:25.042]                     on.exit(options(oopts))
[13:17:25.042]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.042]                       envir = envir)
[13:17:25.042]                     if (!future$lazy) 
[13:17:25.042]                       future <- run(future)
[13:17:25.042]                     invisible(future)
[13:17:25.042]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.042]                 }
[13:17:25.042]             }
[13:17:25.042]         }
[13:17:25.042]     })
[13:17:25.042]     if (TRUE) {
[13:17:25.042]         base::sink(type = "output", split = FALSE)
[13:17:25.042]         if (TRUE) {
[13:17:25.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.042]         }
[13:17:25.042]         else {
[13:17:25.042]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.042]         }
[13:17:25.042]         base::close(...future.stdout)
[13:17:25.042]         ...future.stdout <- NULL
[13:17:25.042]     }
[13:17:25.042]     ...future.result$conditions <- ...future.conditions
[13:17:25.042]     ...future.result$finished <- base::Sys.time()
[13:17:25.042]     ...future.result
[13:17:25.042] }
[13:17:25.046] assign_globals() ...
[13:17:25.046] List of 5
[13:17:25.046]  $ future.call.arguments    : list()
[13:17:25.046]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.046]  $ ...future.FUN            :function (x)  
[13:17:25.046]  $ ...future.elements_ii    :List of 3
[13:17:25.046]   ..$ : int [1:4] 4 10 16 22
[13:17:25.046]   ..$ : int [1:4] 5 11 17 23
[13:17:25.046]   ..$ : int [1:4] 6 12 18 24
[13:17:25.046]  $ ...future.seeds_ii       : NULL
[13:17:25.046]  $ ...future.globals.maxSize: num Inf
[13:17:25.046]  - attr(*, "resolved")= logi FALSE
[13:17:25.046]  - attr(*, "total_size")= num NA
[13:17:25.046]  - attr(*, "where")=List of 5
[13:17:25.046]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.046]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.046]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.046]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.046]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.046]  - attr(*, "already-done")= logi TRUE
[13:17:25.054] - copied ‘future.call.arguments’ to environment
[13:17:25.054] - reassign environment for ‘...future.FUN’
[13:17:25.055] - copied ‘...future.FUN’ to environment
[13:17:25.055] - copied ‘...future.elements_ii’ to environment
[13:17:25.055] - copied ‘...future.seeds_ii’ to environment
[13:17:25.055] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.055] assign_globals() ... done
[13:17:25.055] requestCore(): workers = 2
[13:17:25.058] MulticoreFuture started
[13:17:25.058] - Launch lazy future ... done
[13:17:25.058] run() for ‘MulticoreFuture’ ... done
[13:17:25.059] Created future:
[13:17:25.059] plan(): Setting new future strategy stack:
[13:17:25.059] List of future strategies:
[13:17:25.059] 1. sequential:
[13:17:25.059]    - args: function (..., envir = parent.frame())
[13:17:25.059]    - tweaked: FALSE
[13:17:25.059]    - call: NULL
[13:17:25.063] plan(): nbrOfWorkers() = 1
[13:17:25.066] plan(): Setting new future strategy stack:
[13:17:25.066] List of future strategies:
[13:17:25.066] 1. multicore:
[13:17:25.066]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.066]    - tweaked: FALSE
[13:17:25.066]    - call: plan(strategy)
[13:17:25.073] plan(): nbrOfWorkers() = 2
[13:17:25.059] MulticoreFuture:
[13:17:25.059] Label: ‘future_apply-2’
[13:17:25.059] Expression:
[13:17:25.059] {
[13:17:25.059]     do.call(function(...) {
[13:17:25.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.059]             on.exit(options(oopts), add = TRUE)
[13:17:25.059]         }
[13:17:25.059]         {
[13:17:25.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.059]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.059]             })
[13:17:25.059]         }
[13:17:25.059]     }, args = future.call.arguments)
[13:17:25.059] }
[13:17:25.059] Lazy evaluation: FALSE
[13:17:25.059] Asynchronous evaluation: TRUE
[13:17:25.059] Local evaluation: TRUE
[13:17:25.059] Environment: R_GlobalEnv
[13:17:25.059] Capture standard output: TRUE
[13:17:25.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.059] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:25.059] Packages: <none>
[13:17:25.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.059] Resolved: TRUE
[13:17:25.059] Value: <not collected>
[13:17:25.059] Conditions captured: <none>
[13:17:25.059] Early signaling: FALSE
[13:17:25.059] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.059] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.075] Chunk #2 of 2 ... DONE
[13:17:25.075] Launching 2 futures (chunks) ... DONE
[13:17:25.075] Resolving 2 futures (chunks) ...
[13:17:25.076] resolve() on list ...
[13:17:25.076]  recursive: 0
[13:17:25.076]  length: 2
[13:17:25.077] 
[13:17:25.077] Future #1
[13:17:25.078] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:25.079] - nx: 2
[13:17:25.079] - relay: TRUE
[13:17:25.079] - stdout: TRUE
[13:17:25.079] - signal: TRUE
[13:17:25.080] - resignal: FALSE
[13:17:25.080] - force: TRUE
[13:17:25.080] - relayed: [n=2] FALSE, FALSE
[13:17:25.080] - queued futures: [n=2] FALSE, FALSE
[13:17:25.080]  - until=1
[13:17:25.081]  - relaying element #1
[13:17:25.081] - relayed: [n=2] TRUE, FALSE
[13:17:25.081] - queued futures: [n=2] TRUE, FALSE
[13:17:25.081] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:25.082]  length: 1 (resolved future 1)
[13:17:25.082] Future #2
[13:17:25.083] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:25.083] - nx: 2
[13:17:25.083] - relay: TRUE
[13:17:25.083] - stdout: TRUE
[13:17:25.084] - signal: TRUE
[13:17:25.084] - resignal: FALSE
[13:17:25.084] - force: TRUE
[13:17:25.084] - relayed: [n=2] TRUE, FALSE
[13:17:25.084] - queued futures: [n=2] TRUE, FALSE
[13:17:25.084]  - until=2
[13:17:25.084]  - relaying element #2
[13:17:25.085] - relayed: [n=2] TRUE, TRUE
[13:17:25.085] - queued futures: [n=2] TRUE, TRUE
[13:17:25.085] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:25.085]  length: 0 (resolved future 2)
[13:17:25.085] Relaying remaining futures
[13:17:25.085] signalConditionsASAP(NULL, pos=0) ...
[13:17:25.085] - nx: 2
[13:17:25.085] - relay: TRUE
[13:17:25.086] - stdout: TRUE
[13:17:25.086] - signal: TRUE
[13:17:25.086] - resignal: FALSE
[13:17:25.086] - force: TRUE
[13:17:25.086] - relayed: [n=2] TRUE, TRUE
[13:17:25.086] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:25.086] - relayed: [n=2] TRUE, TRUE
[13:17:25.086] - queued futures: [n=2] TRUE, TRUE
[13:17:25.086] signalConditionsASAP(NULL, pos=0) ... done
[13:17:25.087] resolve() on list ... DONE
[13:17:25.087]  - Number of value chunks collected: 2
[13:17:25.087] Resolving 2 futures (chunks) ... DONE
[13:17:25.087] Reducing values from 2 chunks ...
[13:17:25.087]  - Number of values collected after concatenation: 6
[13:17:25.087]  - Number of values expected: 6
[13:17:25.087] Reducing values from 2 chunks ... DONE
[13:17:25.088] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:17:25.088] getGlobalsAndPackagesXApply() ...
[13:17:25.088]  - future.globals: TRUE
[13:17:25.088] getGlobalsAndPackages() ...
[13:17:25.088] Searching for globals...
[13:17:25.090] - globals found: [1] ‘FUN’
[13:17:25.090] Searching for globals ... DONE
[13:17:25.090] Resolving globals: FALSE
[13:17:25.090] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:25.091] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:25.091] - globals: [1] ‘FUN’
[13:17:25.091] 
[13:17:25.091] getGlobalsAndPackages() ... DONE
[13:17:25.091]  - globals found/used: [n=1] ‘FUN’
[13:17:25.091]  - needed namespaces: [n=0] 
[13:17:25.091] Finding globals ... DONE
[13:17:25.091]  - use_args: TRUE
[13:17:25.091]  - Getting '...' globals ...
[13:17:25.092] resolve() on list ...
[13:17:25.092]  recursive: 0
[13:17:25.092]  length: 1
[13:17:25.092]  elements: ‘...’
[13:17:25.092]  length: 0 (resolved future 1)
[13:17:25.092] resolve() on list ... DONE
[13:17:25.092]    - '...' content: [n=0] 
[13:17:25.093] List of 1
[13:17:25.093]  $ ...: list()
[13:17:25.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.093]  - attr(*, "where")=List of 1
[13:17:25.093]   ..$ ...:<environment: 0x5647b8e5a930> 
[13:17:25.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.093]  - attr(*, "resolved")= logi TRUE
[13:17:25.093]  - attr(*, "total_size")= num NA
[13:17:25.096]  - Getting '...' globals ... DONE
[13:17:25.096] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:25.096] List of 2
[13:17:25.096]  $ ...future.FUN:function (x)  
[13:17:25.096]  $ ...          : list()
[13:17:25.096]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.096]  - attr(*, "where")=List of 2
[13:17:25.096]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:25.096]   ..$ ...          :<environment: 0x5647b8e5a930> 
[13:17:25.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.096]  - attr(*, "resolved")= logi FALSE
[13:17:25.096]  - attr(*, "total_size")= num 848
[13:17:25.099] Packages to be attached in all futures: [n=0] 
[13:17:25.099] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.103] future_lapply() ...
[13:17:25.109] Number of chunks: 2
[13:17:25.109] getGlobalsAndPackagesXApply() ...
[13:17:25.110]  - future.globals: <name-value list> with names ‘list()’
[13:17:25.110]  - use_args: TRUE
[13:17:25.110] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:25.110] List of 2
[13:17:25.110]  $ ...          : list()
[13:17:25.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.110]  $ ...future.FUN:function (x)  
[13:17:25.110]  - attr(*, "where")=List of 2
[13:17:25.110]   ..$ ...          :<environment: 0x5647b8e5a930> 
[13:17:25.110]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:25.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.110]  - attr(*, "resolved")= logi FALSE
[13:17:25.110]  - attr(*, "total_size")= num NA
[13:17:25.114] Packages to be attached in all futures: [n=0] 
[13:17:25.114] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.114] Number of futures (= number of chunks): 2
[13:17:25.114] Launching 2 futures (chunks) ...
[13:17:25.114] Chunk #1 of 2 ...
[13:17:25.114]  - seeds: <none>
[13:17:25.115] getGlobalsAndPackages() ...
[13:17:25.115] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.115] Resolving globals: FALSE
[13:17:25.115] Tweak future expression to call with '...' arguments ...
[13:17:25.115] {
[13:17:25.115]     do.call(function(...) {
[13:17:25.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.115]             on.exit(options(oopts), add = TRUE)
[13:17:25.115]         }
[13:17:25.115]         {
[13:17:25.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.115]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.115]             })
[13:17:25.115]         }
[13:17:25.115]     }, args = future.call.arguments)
[13:17:25.115] }
[13:17:25.115] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.116] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.116] 
[13:17:25.116] getGlobalsAndPackages() ... DONE
[13:17:25.116] run() for ‘Future’ ...
[13:17:25.116] - state: ‘created’
[13:17:25.116] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.120]   - Field: ‘label’
[13:17:25.120]   - Field: ‘local’
[13:17:25.120]   - Field: ‘owner’
[13:17:25.121]   - Field: ‘envir’
[13:17:25.121]   - Field: ‘workers’
[13:17:25.121]   - Field: ‘packages’
[13:17:25.121]   - Field: ‘gc’
[13:17:25.121]   - Field: ‘job’
[13:17:25.121]   - Field: ‘conditions’
[13:17:25.121]   - Field: ‘expr’
[13:17:25.121]   - Field: ‘uuid’
[13:17:25.121]   - Field: ‘seed’
[13:17:25.121]   - Field: ‘version’
[13:17:25.122]   - Field: ‘result’
[13:17:25.122]   - Field: ‘asynchronous’
[13:17:25.122]   - Field: ‘calls’
[13:17:25.122]   - Field: ‘globals’
[13:17:25.122]   - Field: ‘stdout’
[13:17:25.122]   - Field: ‘earlySignal’
[13:17:25.122]   - Field: ‘lazy’
[13:17:25.122]   - Field: ‘state’
[13:17:25.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.122] - Launch lazy future ...
[13:17:25.123] Packages needed by the future expression (n = 0): <none>
[13:17:25.123] Packages needed by future strategies (n = 0): <none>
[13:17:25.123] {
[13:17:25.123]     {
[13:17:25.123]         {
[13:17:25.123]             ...future.startTime <- base::Sys.time()
[13:17:25.123]             {
[13:17:25.123]                 {
[13:17:25.123]                   {
[13:17:25.123]                     {
[13:17:25.123]                       base::local({
[13:17:25.123]                         has_future <- base::requireNamespace("future", 
[13:17:25.123]                           quietly = TRUE)
[13:17:25.123]                         if (has_future) {
[13:17:25.123]                           ns <- base::getNamespace("future")
[13:17:25.123]                           version <- ns[[".package"]][["version"]]
[13:17:25.123]                           if (is.null(version)) 
[13:17:25.123]                             version <- utils::packageVersion("future")
[13:17:25.123]                         }
[13:17:25.123]                         else {
[13:17:25.123]                           version <- NULL
[13:17:25.123]                         }
[13:17:25.123]                         if (!has_future || version < "1.8.0") {
[13:17:25.123]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.123]                             "", base::R.version$version.string), 
[13:17:25.123]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.123]                               "release", "version")], collapse = " "), 
[13:17:25.123]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.123]                             info)
[13:17:25.123]                           info <- base::paste(info, collapse = "; ")
[13:17:25.123]                           if (!has_future) {
[13:17:25.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.123]                               info)
[13:17:25.123]                           }
[13:17:25.123]                           else {
[13:17:25.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.123]                               info, version)
[13:17:25.123]                           }
[13:17:25.123]                           base::stop(msg)
[13:17:25.123]                         }
[13:17:25.123]                       })
[13:17:25.123]                     }
[13:17:25.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.123]                     base::options(mc.cores = 1L)
[13:17:25.123]                   }
[13:17:25.123]                   options(future.plan = NULL)
[13:17:25.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.123]                 }
[13:17:25.123]                 ...future.workdir <- getwd()
[13:17:25.123]             }
[13:17:25.123]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.123]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.123]         }
[13:17:25.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.123]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.123]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.123]             base::names(...future.oldOptions))
[13:17:25.123]     }
[13:17:25.123]     if (FALSE) {
[13:17:25.123]     }
[13:17:25.123]     else {
[13:17:25.123]         if (TRUE) {
[13:17:25.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.123]                 open = "w")
[13:17:25.123]         }
[13:17:25.123]         else {
[13:17:25.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.123]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.123]         }
[13:17:25.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.123]             base::sink(type = "output", split = FALSE)
[13:17:25.123]             base::close(...future.stdout)
[13:17:25.123]         }, add = TRUE)
[13:17:25.123]     }
[13:17:25.123]     ...future.frame <- base::sys.nframe()
[13:17:25.123]     ...future.conditions <- base::list()
[13:17:25.123]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.123]     if (FALSE) {
[13:17:25.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.123]     }
[13:17:25.123]     ...future.result <- base::tryCatch({
[13:17:25.123]         base::withCallingHandlers({
[13:17:25.123]             ...future.value <- base::withVisible(base::local({
[13:17:25.123]                 withCallingHandlers({
[13:17:25.123]                   {
[13:17:25.123]                     do.call(function(...) {
[13:17:25.123]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.123]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.123]                         ...future.globals.maxSize)) {
[13:17:25.123]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.123]                         on.exit(options(oopts), add = TRUE)
[13:17:25.123]                       }
[13:17:25.123]                       {
[13:17:25.123]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.123]                           FUN = function(jj) {
[13:17:25.123]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.123]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.123]                           })
[13:17:25.123]                       }
[13:17:25.123]                     }, args = future.call.arguments)
[13:17:25.123]                   }
[13:17:25.123]                 }, immediateCondition = function(cond) {
[13:17:25.123]                   save_rds <- function (object, pathname, ...) 
[13:17:25.123]                   {
[13:17:25.123]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.123]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.123]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.123]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.123]                         fi_tmp[["mtime"]])
[13:17:25.123]                     }
[13:17:25.123]                     tryCatch({
[13:17:25.123]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.123]                     }, error = function(ex) {
[13:17:25.123]                       msg <- conditionMessage(ex)
[13:17:25.123]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.123]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.123]                         fi_tmp[["mtime"]], msg)
[13:17:25.123]                       ex$message <- msg
[13:17:25.123]                       stop(ex)
[13:17:25.123]                     })
[13:17:25.123]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.123]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.123]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.123]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.123]                       fi <- file.info(pathname)
[13:17:25.123]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.123]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.123]                         fi[["size"]], fi[["mtime"]])
[13:17:25.123]                       stop(msg)
[13:17:25.123]                     }
[13:17:25.123]                     invisible(pathname)
[13:17:25.123]                   }
[13:17:25.123]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.123]                     rootPath = tempdir()) 
[13:17:25.123]                   {
[13:17:25.123]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.123]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.123]                       tmpdir = path, fileext = ".rds")
[13:17:25.123]                     save_rds(obj, file)
[13:17:25.123]                   }
[13:17:25.123]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.123]                   {
[13:17:25.123]                     inherits <- base::inherits
[13:17:25.123]                     invokeRestart <- base::invokeRestart
[13:17:25.123]                     is.null <- base::is.null
[13:17:25.123]                     muffled <- FALSE
[13:17:25.123]                     if (inherits(cond, "message")) {
[13:17:25.123]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.123]                       if (muffled) 
[13:17:25.123]                         invokeRestart("muffleMessage")
[13:17:25.123]                     }
[13:17:25.123]                     else if (inherits(cond, "warning")) {
[13:17:25.123]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.123]                       if (muffled) 
[13:17:25.123]                         invokeRestart("muffleWarning")
[13:17:25.123]                     }
[13:17:25.123]                     else if (inherits(cond, "condition")) {
[13:17:25.123]                       if (!is.null(pattern)) {
[13:17:25.123]                         computeRestarts <- base::computeRestarts
[13:17:25.123]                         grepl <- base::grepl
[13:17:25.123]                         restarts <- computeRestarts(cond)
[13:17:25.123]                         for (restart in restarts) {
[13:17:25.123]                           name <- restart$name
[13:17:25.123]                           if (is.null(name)) 
[13:17:25.123]                             next
[13:17:25.123]                           if (!grepl(pattern, name)) 
[13:17:25.123]                             next
[13:17:25.123]                           invokeRestart(restart)
[13:17:25.123]                           muffled <- TRUE
[13:17:25.123]                           break
[13:17:25.123]                         }
[13:17:25.123]                       }
[13:17:25.123]                     }
[13:17:25.123]                     invisible(muffled)
[13:17:25.123]                   }
[13:17:25.123]                   muffleCondition(cond)
[13:17:25.123]                 })
[13:17:25.123]             }))
[13:17:25.123]             future::FutureResult(value = ...future.value$value, 
[13:17:25.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.123]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.123]                     ...future.globalenv.names))
[13:17:25.123]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.123]         }, condition = base::local({
[13:17:25.123]             c <- base::c
[13:17:25.123]             inherits <- base::inherits
[13:17:25.123]             invokeRestart <- base::invokeRestart
[13:17:25.123]             length <- base::length
[13:17:25.123]             list <- base::list
[13:17:25.123]             seq.int <- base::seq.int
[13:17:25.123]             signalCondition <- base::signalCondition
[13:17:25.123]             sys.calls <- base::sys.calls
[13:17:25.123]             `[[` <- base::`[[`
[13:17:25.123]             `+` <- base::`+`
[13:17:25.123]             `<<-` <- base::`<<-`
[13:17:25.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.123]                   3L)]
[13:17:25.123]             }
[13:17:25.123]             function(cond) {
[13:17:25.123]                 is_error <- inherits(cond, "error")
[13:17:25.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.123]                   NULL)
[13:17:25.123]                 if (is_error) {
[13:17:25.123]                   sessionInformation <- function() {
[13:17:25.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.123]                       search = base::search(), system = base::Sys.info())
[13:17:25.123]                   }
[13:17:25.123]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.123]                     cond$call), session = sessionInformation(), 
[13:17:25.123]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.123]                   signalCondition(cond)
[13:17:25.123]                 }
[13:17:25.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.123]                 "immediateCondition"))) {
[13:17:25.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.123]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.123]                   if (TRUE && !signal) {
[13:17:25.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.123]                     {
[13:17:25.123]                       inherits <- base::inherits
[13:17:25.123]                       invokeRestart <- base::invokeRestart
[13:17:25.123]                       is.null <- base::is.null
[13:17:25.123]                       muffled <- FALSE
[13:17:25.123]                       if (inherits(cond, "message")) {
[13:17:25.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.123]                         if (muffled) 
[13:17:25.123]                           invokeRestart("muffleMessage")
[13:17:25.123]                       }
[13:17:25.123]                       else if (inherits(cond, "warning")) {
[13:17:25.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.123]                         if (muffled) 
[13:17:25.123]                           invokeRestart("muffleWarning")
[13:17:25.123]                       }
[13:17:25.123]                       else if (inherits(cond, "condition")) {
[13:17:25.123]                         if (!is.null(pattern)) {
[13:17:25.123]                           computeRestarts <- base::computeRestarts
[13:17:25.123]                           grepl <- base::grepl
[13:17:25.123]                           restarts <- computeRestarts(cond)
[13:17:25.123]                           for (restart in restarts) {
[13:17:25.123]                             name <- restart$name
[13:17:25.123]                             if (is.null(name)) 
[13:17:25.123]                               next
[13:17:25.123]                             if (!grepl(pattern, name)) 
[13:17:25.123]                               next
[13:17:25.123]                             invokeRestart(restart)
[13:17:25.123]                             muffled <- TRUE
[13:17:25.123]                             break
[13:17:25.123]                           }
[13:17:25.123]                         }
[13:17:25.123]                       }
[13:17:25.123]                       invisible(muffled)
[13:17:25.123]                     }
[13:17:25.123]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.123]                   }
[13:17:25.123]                 }
[13:17:25.123]                 else {
[13:17:25.123]                   if (TRUE) {
[13:17:25.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.123]                     {
[13:17:25.123]                       inherits <- base::inherits
[13:17:25.123]                       invokeRestart <- base::invokeRestart
[13:17:25.123]                       is.null <- base::is.null
[13:17:25.123]                       muffled <- FALSE
[13:17:25.123]                       if (inherits(cond, "message")) {
[13:17:25.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.123]                         if (muffled) 
[13:17:25.123]                           invokeRestart("muffleMessage")
[13:17:25.123]                       }
[13:17:25.123]                       else if (inherits(cond, "warning")) {
[13:17:25.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.123]                         if (muffled) 
[13:17:25.123]                           invokeRestart("muffleWarning")
[13:17:25.123]                       }
[13:17:25.123]                       else if (inherits(cond, "condition")) {
[13:17:25.123]                         if (!is.null(pattern)) {
[13:17:25.123]                           computeRestarts <- base::computeRestarts
[13:17:25.123]                           grepl <- base::grepl
[13:17:25.123]                           restarts <- computeRestarts(cond)
[13:17:25.123]                           for (restart in restarts) {
[13:17:25.123]                             name <- restart$name
[13:17:25.123]                             if (is.null(name)) 
[13:17:25.123]                               next
[13:17:25.123]                             if (!grepl(pattern, name)) 
[13:17:25.123]                               next
[13:17:25.123]                             invokeRestart(restart)
[13:17:25.123]                             muffled <- TRUE
[13:17:25.123]                             break
[13:17:25.123]                           }
[13:17:25.123]                         }
[13:17:25.123]                       }
[13:17:25.123]                       invisible(muffled)
[13:17:25.123]                     }
[13:17:25.123]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.123]                   }
[13:17:25.123]                 }
[13:17:25.123]             }
[13:17:25.123]         }))
[13:17:25.123]     }, error = function(ex) {
[13:17:25.123]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.123]                 ...future.rng), started = ...future.startTime, 
[13:17:25.123]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.123]             version = "1.8"), class = "FutureResult")
[13:17:25.123]     }, finally = {
[13:17:25.123]         if (!identical(...future.workdir, getwd())) 
[13:17:25.123]             setwd(...future.workdir)
[13:17:25.123]         {
[13:17:25.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.123]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.123]             }
[13:17:25.123]             base::options(...future.oldOptions)
[13:17:25.123]             if (.Platform$OS.type == "windows") {
[13:17:25.123]                 old_names <- names(...future.oldEnvVars)
[13:17:25.123]                 envs <- base::Sys.getenv()
[13:17:25.123]                 names <- names(envs)
[13:17:25.123]                 common <- intersect(names, old_names)
[13:17:25.123]                 added <- setdiff(names, old_names)
[13:17:25.123]                 removed <- setdiff(old_names, names)
[13:17:25.123]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.123]                   envs[common]]
[13:17:25.123]                 NAMES <- toupper(changed)
[13:17:25.123]                 args <- list()
[13:17:25.123]                 for (kk in seq_along(NAMES)) {
[13:17:25.123]                   name <- changed[[kk]]
[13:17:25.123]                   NAME <- NAMES[[kk]]
[13:17:25.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.123]                     next
[13:17:25.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.123]                 }
[13:17:25.123]                 NAMES <- toupper(added)
[13:17:25.123]                 for (kk in seq_along(NAMES)) {
[13:17:25.123]                   name <- added[[kk]]
[13:17:25.123]                   NAME <- NAMES[[kk]]
[13:17:25.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.123]                     next
[13:17:25.123]                   args[[name]] <- ""
[13:17:25.123]                 }
[13:17:25.123]                 NAMES <- toupper(removed)
[13:17:25.123]                 for (kk in seq_along(NAMES)) {
[13:17:25.123]                   name <- removed[[kk]]
[13:17:25.123]                   NAME <- NAMES[[kk]]
[13:17:25.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.123]                     next
[13:17:25.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.123]                 }
[13:17:25.123]                 if (length(args) > 0) 
[13:17:25.123]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.123]             }
[13:17:25.123]             else {
[13:17:25.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.123]             }
[13:17:25.123]             {
[13:17:25.123]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.123]                   0L) {
[13:17:25.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.123]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.123]                   base::options(opts)
[13:17:25.123]                 }
[13:17:25.123]                 {
[13:17:25.123]                   {
[13:17:25.123]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.123]                     NULL
[13:17:25.123]                   }
[13:17:25.123]                   options(future.plan = NULL)
[13:17:25.123]                   if (is.na(NA_character_)) 
[13:17:25.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.123]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.123]                     envir = parent.frame()) 
[13:17:25.123]                   {
[13:17:25.123]                     default_workers <- missing(workers)
[13:17:25.123]                     if (is.function(workers)) 
[13:17:25.123]                       workers <- workers()
[13:17:25.123]                     workers <- structure(as.integer(workers), 
[13:17:25.123]                       class = class(workers))
[13:17:25.123]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.123]                       1L)
[13:17:25.123]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.123]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.123]                       if (default_workers) 
[13:17:25.123]                         supportsMulticore(warn = TRUE)
[13:17:25.123]                       return(sequential(..., envir = envir))
[13:17:25.123]                     }
[13:17:25.123]                     oopts <- options(mc.cores = workers)
[13:17:25.123]                     on.exit(options(oopts))
[13:17:25.123]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.123]                       envir = envir)
[13:17:25.123]                     if (!future$lazy) 
[13:17:25.123]                       future <- run(future)
[13:17:25.123]                     invisible(future)
[13:17:25.123]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.123]                 }
[13:17:25.123]             }
[13:17:25.123]         }
[13:17:25.123]     })
[13:17:25.123]     if (TRUE) {
[13:17:25.123]         base::sink(type = "output", split = FALSE)
[13:17:25.123]         if (TRUE) {
[13:17:25.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.123]         }
[13:17:25.123]         else {
[13:17:25.123]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.123]         }
[13:17:25.123]         base::close(...future.stdout)
[13:17:25.123]         ...future.stdout <- NULL
[13:17:25.123]     }
[13:17:25.123]     ...future.result$conditions <- ...future.conditions
[13:17:25.123]     ...future.result$finished <- base::Sys.time()
[13:17:25.123]     ...future.result
[13:17:25.123] }
[13:17:25.126] assign_globals() ...
[13:17:25.126] List of 5
[13:17:25.126]  $ future.call.arguments    : list()
[13:17:25.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.126]  $ ...future.FUN            :function (x)  
[13:17:25.126]  $ ...future.elements_ii    :List of 1
[13:17:25.126]   ..$ : int 1
[13:17:25.126]  $ ...future.seeds_ii       : NULL
[13:17:25.126]  $ ...future.globals.maxSize: NULL
[13:17:25.126]  - attr(*, "where")=List of 5
[13:17:25.126]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.126]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.126]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.126]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.126]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.126]  - attr(*, "resolved")= logi FALSE
[13:17:25.126]  - attr(*, "total_size")= num NA
[13:17:25.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.126]  - attr(*, "already-done")= logi TRUE
[13:17:25.131] - copied ‘future.call.arguments’ to environment
[13:17:25.131] - copied ‘...future.FUN’ to environment
[13:17:25.131] - copied ‘...future.elements_ii’ to environment
[13:17:25.131] - copied ‘...future.seeds_ii’ to environment
[13:17:25.131] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.131] assign_globals() ... done
[13:17:25.131] requestCore(): workers = 2
[13:17:25.133] MulticoreFuture started
[13:17:25.134] - Launch lazy future ... done
[13:17:25.134] run() for ‘MulticoreFuture’ ... done
[13:17:25.134] Created future:
[13:17:25.134] plan(): Setting new future strategy stack:
[13:17:25.135] List of future strategies:
[13:17:25.135] 1. sequential:
[13:17:25.135]    - args: function (..., envir = parent.frame())
[13:17:25.135]    - tweaked: FALSE
[13:17:25.135]    - call: NULL
[13:17:25.136] plan(): nbrOfWorkers() = 1
[13:17:25.140] plan(): Setting new future strategy stack:
[13:17:25.141] List of future strategies:
[13:17:25.141] 1. multicore:
[13:17:25.141]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.141]    - tweaked: FALSE
[13:17:25.141]    - call: plan(strategy)
[13:17:25.148] plan(): nbrOfWorkers() = 2
[13:17:25.135] MulticoreFuture:
[13:17:25.135] Label: ‘future_apply-1’
[13:17:25.135] Expression:
[13:17:25.135] {
[13:17:25.135]     do.call(function(...) {
[13:17:25.135]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.135]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.135]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.135]             on.exit(options(oopts), add = TRUE)
[13:17:25.135]         }
[13:17:25.135]         {
[13:17:25.135]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.135]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.135]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.135]             })
[13:17:25.135]         }
[13:17:25.135]     }, args = future.call.arguments)
[13:17:25.135] }
[13:17:25.135] Lazy evaluation: FALSE
[13:17:25.135] Asynchronous evaluation: TRUE
[13:17:25.135] Local evaluation: TRUE
[13:17:25.135] Environment: R_GlobalEnv
[13:17:25.135] Capture standard output: TRUE
[13:17:25.135] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.135] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.135] Packages: <none>
[13:17:25.135] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.135] Resolved: TRUE
[13:17:25.135] Value: <not collected>
[13:17:25.135] Conditions captured: <none>
[13:17:25.135] Early signaling: FALSE
[13:17:25.135] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.135] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.150] Chunk #1 of 2 ... DONE
[13:17:25.150] Chunk #2 of 2 ...
[13:17:25.150]  - seeds: <none>
[13:17:25.150] getGlobalsAndPackages() ...
[13:17:25.151] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.151] Resolving globals: FALSE
[13:17:25.151] Tweak future expression to call with '...' arguments ...
[13:17:25.151] {
[13:17:25.151]     do.call(function(...) {
[13:17:25.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.151]             on.exit(options(oopts), add = TRUE)
[13:17:25.151]         }
[13:17:25.151]         {
[13:17:25.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.151]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.151]             })
[13:17:25.151]         }
[13:17:25.151]     }, args = future.call.arguments)
[13:17:25.151] }
[13:17:25.152] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.153] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.153] 
[13:17:25.153] getGlobalsAndPackages() ... DONE
[13:17:25.154] run() for ‘Future’ ...
[13:17:25.154] - state: ‘created’
[13:17:25.155] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.160]   - Field: ‘label’
[13:17:25.160]   - Field: ‘local’
[13:17:25.160]   - Field: ‘owner’
[13:17:25.161]   - Field: ‘envir’
[13:17:25.161]   - Field: ‘workers’
[13:17:25.161]   - Field: ‘packages’
[13:17:25.161]   - Field: ‘gc’
[13:17:25.162]   - Field: ‘job’
[13:17:25.162]   - Field: ‘conditions’
[13:17:25.162]   - Field: ‘expr’
[13:17:25.162]   - Field: ‘uuid’
[13:17:25.162]   - Field: ‘seed’
[13:17:25.162]   - Field: ‘version’
[13:17:25.163]   - Field: ‘result’
[13:17:25.163]   - Field: ‘asynchronous’
[13:17:25.163]   - Field: ‘calls’
[13:17:25.163]   - Field: ‘globals’
[13:17:25.163]   - Field: ‘stdout’
[13:17:25.163]   - Field: ‘earlySignal’
[13:17:25.164]   - Field: ‘lazy’
[13:17:25.164]   - Field: ‘state’
[13:17:25.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.164] - Launch lazy future ...
[13:17:25.164] Packages needed by the future expression (n = 0): <none>
[13:17:25.165] Packages needed by future strategies (n = 0): <none>
[13:17:25.165] {
[13:17:25.165]     {
[13:17:25.165]         {
[13:17:25.165]             ...future.startTime <- base::Sys.time()
[13:17:25.165]             {
[13:17:25.165]                 {
[13:17:25.165]                   {
[13:17:25.165]                     {
[13:17:25.165]                       base::local({
[13:17:25.165]                         has_future <- base::requireNamespace("future", 
[13:17:25.165]                           quietly = TRUE)
[13:17:25.165]                         if (has_future) {
[13:17:25.165]                           ns <- base::getNamespace("future")
[13:17:25.165]                           version <- ns[[".package"]][["version"]]
[13:17:25.165]                           if (is.null(version)) 
[13:17:25.165]                             version <- utils::packageVersion("future")
[13:17:25.165]                         }
[13:17:25.165]                         else {
[13:17:25.165]                           version <- NULL
[13:17:25.165]                         }
[13:17:25.165]                         if (!has_future || version < "1.8.0") {
[13:17:25.165]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.165]                             "", base::R.version$version.string), 
[13:17:25.165]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.165]                               "release", "version")], collapse = " "), 
[13:17:25.165]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.165]                             info)
[13:17:25.165]                           info <- base::paste(info, collapse = "; ")
[13:17:25.165]                           if (!has_future) {
[13:17:25.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.165]                               info)
[13:17:25.165]                           }
[13:17:25.165]                           else {
[13:17:25.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.165]                               info, version)
[13:17:25.165]                           }
[13:17:25.165]                           base::stop(msg)
[13:17:25.165]                         }
[13:17:25.165]                       })
[13:17:25.165]                     }
[13:17:25.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.165]                     base::options(mc.cores = 1L)
[13:17:25.165]                   }
[13:17:25.165]                   options(future.plan = NULL)
[13:17:25.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.165]                 }
[13:17:25.165]                 ...future.workdir <- getwd()
[13:17:25.165]             }
[13:17:25.165]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.165]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.165]         }
[13:17:25.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.165]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.165]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.165]             base::names(...future.oldOptions))
[13:17:25.165]     }
[13:17:25.165]     if (FALSE) {
[13:17:25.165]     }
[13:17:25.165]     else {
[13:17:25.165]         if (TRUE) {
[13:17:25.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.165]                 open = "w")
[13:17:25.165]         }
[13:17:25.165]         else {
[13:17:25.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.165]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.165]         }
[13:17:25.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.165]             base::sink(type = "output", split = FALSE)
[13:17:25.165]             base::close(...future.stdout)
[13:17:25.165]         }, add = TRUE)
[13:17:25.165]     }
[13:17:25.165]     ...future.frame <- base::sys.nframe()
[13:17:25.165]     ...future.conditions <- base::list()
[13:17:25.165]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.165]     if (FALSE) {
[13:17:25.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.165]     }
[13:17:25.165]     ...future.result <- base::tryCatch({
[13:17:25.165]         base::withCallingHandlers({
[13:17:25.165]             ...future.value <- base::withVisible(base::local({
[13:17:25.165]                 withCallingHandlers({
[13:17:25.165]                   {
[13:17:25.165]                     do.call(function(...) {
[13:17:25.165]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.165]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.165]                         ...future.globals.maxSize)) {
[13:17:25.165]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.165]                         on.exit(options(oopts), add = TRUE)
[13:17:25.165]                       }
[13:17:25.165]                       {
[13:17:25.165]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.165]                           FUN = function(jj) {
[13:17:25.165]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.165]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.165]                           })
[13:17:25.165]                       }
[13:17:25.165]                     }, args = future.call.arguments)
[13:17:25.165]                   }
[13:17:25.165]                 }, immediateCondition = function(cond) {
[13:17:25.165]                   save_rds <- function (object, pathname, ...) 
[13:17:25.165]                   {
[13:17:25.165]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.165]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.165]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.165]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.165]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.165]                         fi_tmp[["mtime"]])
[13:17:25.165]                     }
[13:17:25.165]                     tryCatch({
[13:17:25.165]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.165]                     }, error = function(ex) {
[13:17:25.165]                       msg <- conditionMessage(ex)
[13:17:25.165]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.165]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.165]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.165]                         fi_tmp[["mtime"]], msg)
[13:17:25.165]                       ex$message <- msg
[13:17:25.165]                       stop(ex)
[13:17:25.165]                     })
[13:17:25.165]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.165]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.165]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.165]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.165]                       fi <- file.info(pathname)
[13:17:25.165]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.165]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.165]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.165]                         fi[["size"]], fi[["mtime"]])
[13:17:25.165]                       stop(msg)
[13:17:25.165]                     }
[13:17:25.165]                     invisible(pathname)
[13:17:25.165]                   }
[13:17:25.165]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.165]                     rootPath = tempdir()) 
[13:17:25.165]                   {
[13:17:25.165]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.165]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.165]                       tmpdir = path, fileext = ".rds")
[13:17:25.165]                     save_rds(obj, file)
[13:17:25.165]                   }
[13:17:25.165]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.165]                   {
[13:17:25.165]                     inherits <- base::inherits
[13:17:25.165]                     invokeRestart <- base::invokeRestart
[13:17:25.165]                     is.null <- base::is.null
[13:17:25.165]                     muffled <- FALSE
[13:17:25.165]                     if (inherits(cond, "message")) {
[13:17:25.165]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.165]                       if (muffled) 
[13:17:25.165]                         invokeRestart("muffleMessage")
[13:17:25.165]                     }
[13:17:25.165]                     else if (inherits(cond, "warning")) {
[13:17:25.165]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.165]                       if (muffled) 
[13:17:25.165]                         invokeRestart("muffleWarning")
[13:17:25.165]                     }
[13:17:25.165]                     else if (inherits(cond, "condition")) {
[13:17:25.165]                       if (!is.null(pattern)) {
[13:17:25.165]                         computeRestarts <- base::computeRestarts
[13:17:25.165]                         grepl <- base::grepl
[13:17:25.165]                         restarts <- computeRestarts(cond)
[13:17:25.165]                         for (restart in restarts) {
[13:17:25.165]                           name <- restart$name
[13:17:25.165]                           if (is.null(name)) 
[13:17:25.165]                             next
[13:17:25.165]                           if (!grepl(pattern, name)) 
[13:17:25.165]                             next
[13:17:25.165]                           invokeRestart(restart)
[13:17:25.165]                           muffled <- TRUE
[13:17:25.165]                           break
[13:17:25.165]                         }
[13:17:25.165]                       }
[13:17:25.165]                     }
[13:17:25.165]                     invisible(muffled)
[13:17:25.165]                   }
[13:17:25.165]                   muffleCondition(cond)
[13:17:25.165]                 })
[13:17:25.165]             }))
[13:17:25.165]             future::FutureResult(value = ...future.value$value, 
[13:17:25.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.165]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.165]                     ...future.globalenv.names))
[13:17:25.165]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.165]         }, condition = base::local({
[13:17:25.165]             c <- base::c
[13:17:25.165]             inherits <- base::inherits
[13:17:25.165]             invokeRestart <- base::invokeRestart
[13:17:25.165]             length <- base::length
[13:17:25.165]             list <- base::list
[13:17:25.165]             seq.int <- base::seq.int
[13:17:25.165]             signalCondition <- base::signalCondition
[13:17:25.165]             sys.calls <- base::sys.calls
[13:17:25.165]             `[[` <- base::`[[`
[13:17:25.165]             `+` <- base::`+`
[13:17:25.165]             `<<-` <- base::`<<-`
[13:17:25.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.165]                   3L)]
[13:17:25.165]             }
[13:17:25.165]             function(cond) {
[13:17:25.165]                 is_error <- inherits(cond, "error")
[13:17:25.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.165]                   NULL)
[13:17:25.165]                 if (is_error) {
[13:17:25.165]                   sessionInformation <- function() {
[13:17:25.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.165]                       search = base::search(), system = base::Sys.info())
[13:17:25.165]                   }
[13:17:25.165]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.165]                     cond$call), session = sessionInformation(), 
[13:17:25.165]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.165]                   signalCondition(cond)
[13:17:25.165]                 }
[13:17:25.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.165]                 "immediateCondition"))) {
[13:17:25.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.165]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.165]                   if (TRUE && !signal) {
[13:17:25.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.165]                     {
[13:17:25.165]                       inherits <- base::inherits
[13:17:25.165]                       invokeRestart <- base::invokeRestart
[13:17:25.165]                       is.null <- base::is.null
[13:17:25.165]                       muffled <- FALSE
[13:17:25.165]                       if (inherits(cond, "message")) {
[13:17:25.165]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.165]                         if (muffled) 
[13:17:25.165]                           invokeRestart("muffleMessage")
[13:17:25.165]                       }
[13:17:25.165]                       else if (inherits(cond, "warning")) {
[13:17:25.165]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.165]                         if (muffled) 
[13:17:25.165]                           invokeRestart("muffleWarning")
[13:17:25.165]                       }
[13:17:25.165]                       else if (inherits(cond, "condition")) {
[13:17:25.165]                         if (!is.null(pattern)) {
[13:17:25.165]                           computeRestarts <- base::computeRestarts
[13:17:25.165]                           grepl <- base::grepl
[13:17:25.165]                           restarts <- computeRestarts(cond)
[13:17:25.165]                           for (restart in restarts) {
[13:17:25.165]                             name <- restart$name
[13:17:25.165]                             if (is.null(name)) 
[13:17:25.165]                               next
[13:17:25.165]                             if (!grepl(pattern, name)) 
[13:17:25.165]                               next
[13:17:25.165]                             invokeRestart(restart)
[13:17:25.165]                             muffled <- TRUE
[13:17:25.165]                             break
[13:17:25.165]                           }
[13:17:25.165]                         }
[13:17:25.165]                       }
[13:17:25.165]                       invisible(muffled)
[13:17:25.165]                     }
[13:17:25.165]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.165]                   }
[13:17:25.165]                 }
[13:17:25.165]                 else {
[13:17:25.165]                   if (TRUE) {
[13:17:25.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.165]                     {
[13:17:25.165]                       inherits <- base::inherits
[13:17:25.165]                       invokeRestart <- base::invokeRestart
[13:17:25.165]                       is.null <- base::is.null
[13:17:25.165]                       muffled <- FALSE
[13:17:25.165]                       if (inherits(cond, "message")) {
[13:17:25.165]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.165]                         if (muffled) 
[13:17:25.165]                           invokeRestart("muffleMessage")
[13:17:25.165]                       }
[13:17:25.165]                       else if (inherits(cond, "warning")) {
[13:17:25.165]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.165]                         if (muffled) 
[13:17:25.165]                           invokeRestart("muffleWarning")
[13:17:25.165]                       }
[13:17:25.165]                       else if (inherits(cond, "condition")) {
[13:17:25.165]                         if (!is.null(pattern)) {
[13:17:25.165]                           computeRestarts <- base::computeRestarts
[13:17:25.165]                           grepl <- base::grepl
[13:17:25.165]                           restarts <- computeRestarts(cond)
[13:17:25.165]                           for (restart in restarts) {
[13:17:25.165]                             name <- restart$name
[13:17:25.165]                             if (is.null(name)) 
[13:17:25.165]                               next
[13:17:25.165]                             if (!grepl(pattern, name)) 
[13:17:25.165]                               next
[13:17:25.165]                             invokeRestart(restart)
[13:17:25.165]                             muffled <- TRUE
[13:17:25.165]                             break
[13:17:25.165]                           }
[13:17:25.165]                         }
[13:17:25.165]                       }
[13:17:25.165]                       invisible(muffled)
[13:17:25.165]                     }
[13:17:25.165]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.165]                   }
[13:17:25.165]                 }
[13:17:25.165]             }
[13:17:25.165]         }))
[13:17:25.165]     }, error = function(ex) {
[13:17:25.165]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.165]                 ...future.rng), started = ...future.startTime, 
[13:17:25.165]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.165]             version = "1.8"), class = "FutureResult")
[13:17:25.165]     }, finally = {
[13:17:25.165]         if (!identical(...future.workdir, getwd())) 
[13:17:25.165]             setwd(...future.workdir)
[13:17:25.165]         {
[13:17:25.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.165]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.165]             }
[13:17:25.165]             base::options(...future.oldOptions)
[13:17:25.165]             if (.Platform$OS.type == "windows") {
[13:17:25.165]                 old_names <- names(...future.oldEnvVars)
[13:17:25.165]                 envs <- base::Sys.getenv()
[13:17:25.165]                 names <- names(envs)
[13:17:25.165]                 common <- intersect(names, old_names)
[13:17:25.165]                 added <- setdiff(names, old_names)
[13:17:25.165]                 removed <- setdiff(old_names, names)
[13:17:25.165]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.165]                   envs[common]]
[13:17:25.165]                 NAMES <- toupper(changed)
[13:17:25.165]                 args <- list()
[13:17:25.165]                 for (kk in seq_along(NAMES)) {
[13:17:25.165]                   name <- changed[[kk]]
[13:17:25.165]                   NAME <- NAMES[[kk]]
[13:17:25.165]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.165]                     next
[13:17:25.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.165]                 }
[13:17:25.165]                 NAMES <- toupper(added)
[13:17:25.165]                 for (kk in seq_along(NAMES)) {
[13:17:25.165]                   name <- added[[kk]]
[13:17:25.165]                   NAME <- NAMES[[kk]]
[13:17:25.165]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.165]                     next
[13:17:25.165]                   args[[name]] <- ""
[13:17:25.165]                 }
[13:17:25.165]                 NAMES <- toupper(removed)
[13:17:25.165]                 for (kk in seq_along(NAMES)) {
[13:17:25.165]                   name <- removed[[kk]]
[13:17:25.165]                   NAME <- NAMES[[kk]]
[13:17:25.165]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.165]                     next
[13:17:25.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.165]                 }
[13:17:25.165]                 if (length(args) > 0) 
[13:17:25.165]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.165]             }
[13:17:25.165]             else {
[13:17:25.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.165]             }
[13:17:25.165]             {
[13:17:25.165]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.165]                   0L) {
[13:17:25.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.165]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.165]                   base::options(opts)
[13:17:25.165]                 }
[13:17:25.165]                 {
[13:17:25.165]                   {
[13:17:25.165]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.165]                     NULL
[13:17:25.165]                   }
[13:17:25.165]                   options(future.plan = NULL)
[13:17:25.165]                   if (is.na(NA_character_)) 
[13:17:25.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.165]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.165]                     envir = parent.frame()) 
[13:17:25.165]                   {
[13:17:25.165]                     default_workers <- missing(workers)
[13:17:25.165]                     if (is.function(workers)) 
[13:17:25.165]                       workers <- workers()
[13:17:25.165]                     workers <- structure(as.integer(workers), 
[13:17:25.165]                       class = class(workers))
[13:17:25.165]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.165]                       1L)
[13:17:25.165]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.165]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.165]                       if (default_workers) 
[13:17:25.165]                         supportsMulticore(warn = TRUE)
[13:17:25.165]                       return(sequential(..., envir = envir))
[13:17:25.165]                     }
[13:17:25.165]                     oopts <- options(mc.cores = workers)
[13:17:25.165]                     on.exit(options(oopts))
[13:17:25.165]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.165]                       envir = envir)
[13:17:25.165]                     if (!future$lazy) 
[13:17:25.165]                       future <- run(future)
[13:17:25.165]                     invisible(future)
[13:17:25.165]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.165]                 }
[13:17:25.165]             }
[13:17:25.165]         }
[13:17:25.165]     })
[13:17:25.165]     if (TRUE) {
[13:17:25.165]         base::sink(type = "output", split = FALSE)
[13:17:25.165]         if (TRUE) {
[13:17:25.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.165]         }
[13:17:25.165]         else {
[13:17:25.165]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.165]         }
[13:17:25.165]         base::close(...future.stdout)
[13:17:25.165]         ...future.stdout <- NULL
[13:17:25.165]     }
[13:17:25.165]     ...future.result$conditions <- ...future.conditions
[13:17:25.165]     ...future.result$finished <- base::Sys.time()
[13:17:25.165]     ...future.result
[13:17:25.165] }
[13:17:25.168] assign_globals() ...
[13:17:25.168] List of 5
[13:17:25.168]  $ future.call.arguments    : list()
[13:17:25.168]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.168]  $ ...future.FUN            :function (x)  
[13:17:25.168]  $ ...future.elements_ii    :List of 1
[13:17:25.168]   ..$ : int 2
[13:17:25.168]  $ ...future.seeds_ii       : NULL
[13:17:25.168]  $ ...future.globals.maxSize: NULL
[13:17:25.168]  - attr(*, "where")=List of 5
[13:17:25.168]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.168]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.168]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.168]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.168]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.168]  - attr(*, "resolved")= logi FALSE
[13:17:25.168]  - attr(*, "total_size")= num NA
[13:17:25.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.168]  - attr(*, "already-done")= logi TRUE
[13:17:25.175] - copied ‘future.call.arguments’ to environment
[13:17:25.175] - copied ‘...future.FUN’ to environment
[13:17:25.175] - copied ‘...future.elements_ii’ to environment
[13:17:25.175] - copied ‘...future.seeds_ii’ to environment
[13:17:25.175] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.175] assign_globals() ... done
[13:17:25.176] requestCore(): workers = 2
[13:17:25.178] MulticoreFuture started
[13:17:25.178] - Launch lazy future ... done
[13:17:25.178] run() for ‘MulticoreFuture’ ... done
[13:17:25.179] Created future:
[13:17:25.179] plan(): Setting new future strategy stack:
[13:17:25.179] List of future strategies:
[13:17:25.179] 1. sequential:
[13:17:25.179]    - args: function (..., envir = parent.frame())
[13:17:25.179]    - tweaked: FALSE
[13:17:25.179]    - call: NULL
[13:17:25.180] plan(): nbrOfWorkers() = 1
[13:17:25.182] plan(): Setting new future strategy stack:
[13:17:25.182] List of future strategies:
[13:17:25.182] 1. multicore:
[13:17:25.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.182]    - tweaked: FALSE
[13:17:25.182]    - call: plan(strategy)
[13:17:25.188] plan(): nbrOfWorkers() = 2
[13:17:25.179] MulticoreFuture:
[13:17:25.179] Label: ‘future_apply-2’
[13:17:25.179] Expression:
[13:17:25.179] {
[13:17:25.179]     do.call(function(...) {
[13:17:25.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.179]             on.exit(options(oopts), add = TRUE)
[13:17:25.179]         }
[13:17:25.179]         {
[13:17:25.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.179]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.179]             })
[13:17:25.179]         }
[13:17:25.179]     }, args = future.call.arguments)
[13:17:25.179] }
[13:17:25.179] Lazy evaluation: FALSE
[13:17:25.179] Asynchronous evaluation: TRUE
[13:17:25.179] Local evaluation: TRUE
[13:17:25.179] Environment: R_GlobalEnv
[13:17:25.179] Capture standard output: TRUE
[13:17:25.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.179] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.179] Packages: <none>
[13:17:25.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.179] Resolved: TRUE
[13:17:25.179] Value: <not collected>
[13:17:25.179] Conditions captured: <none>
[13:17:25.179] Early signaling: FALSE
[13:17:25.179] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.179] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.189] Chunk #2 of 2 ... DONE
[13:17:25.189] Launching 2 futures (chunks) ... DONE
[13:17:25.189] Resolving 2 futures (chunks) ...
[13:17:25.189] resolve() on list ...
[13:17:25.190]  recursive: 0
[13:17:25.190]  length: 2
[13:17:25.190] 
[13:17:25.190] Future #1
[13:17:25.191] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:25.191] - nx: 2
[13:17:25.191] - relay: TRUE
[13:17:25.192] - stdout: TRUE
[13:17:25.192] - signal: TRUE
[13:17:25.192] - resignal: FALSE
[13:17:25.192] - force: TRUE
[13:17:25.192] - relayed: [n=2] FALSE, FALSE
[13:17:25.192] - queued futures: [n=2] FALSE, FALSE
[13:17:25.193]  - until=1
[13:17:25.193]  - relaying element #1
[13:17:25.193] - relayed: [n=2] TRUE, FALSE
[13:17:25.193] - queued futures: [n=2] TRUE, FALSE
[13:17:25.193] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:25.194]  length: 1 (resolved future 1)
[13:17:25.194] Future #2
[13:17:25.195] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:25.195] - nx: 2
[13:17:25.195] - relay: TRUE
[13:17:25.195] - stdout: TRUE
[13:17:25.195] - signal: TRUE
[13:17:25.195] - resignal: FALSE
[13:17:25.196] - force: TRUE
[13:17:25.196] - relayed: [n=2] TRUE, FALSE
[13:17:25.196] - queued futures: [n=2] TRUE, FALSE
[13:17:25.196]  - until=2
[13:17:25.196]  - relaying element #2
[13:17:25.196] - relayed: [n=2] TRUE, TRUE
[13:17:25.199] - queued futures: [n=2] TRUE, TRUE
[13:17:25.199] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:25.199]  length: 0 (resolved future 2)
[13:17:25.200] Relaying remaining futures
[13:17:25.200] signalConditionsASAP(NULL, pos=0) ...
[13:17:25.200] - nx: 2
[13:17:25.200] - relay: TRUE
[13:17:25.200] - stdout: TRUE
[13:17:25.200] - signal: TRUE
[13:17:25.201] - resignal: FALSE
[13:17:25.201] - force: TRUE
[13:17:25.201] - relayed: [n=2] TRUE, TRUE
[13:17:25.201] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:25.201] - relayed: [n=2] TRUE, TRUE
[13:17:25.202] - queued futures: [n=2] TRUE, TRUE
[13:17:25.202] signalConditionsASAP(NULL, pos=0) ... done
[13:17:25.202] resolve() on list ... DONE
[13:17:25.202]  - Number of value chunks collected: 2
[13:17:25.202] Resolving 2 futures (chunks) ... DONE
[13:17:25.203] Reducing values from 2 chunks ...
[13:17:25.203]  - Number of values collected after concatenation: 2
[13:17:25.203]  - Number of values expected: 2
[13:17:25.203] Reducing values from 2 chunks ... DONE
[13:17:25.203] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:17:25.204] getGlobalsAndPackagesXApply() ...
[13:17:25.204]  - future.globals: TRUE
[13:17:25.204] getGlobalsAndPackages() ...
[13:17:25.204] Searching for globals...
[13:17:25.205] - globals found: [1] ‘FUN’
[13:17:25.206] Searching for globals ... DONE
[13:17:25.206] Resolving globals: FALSE
[13:17:25.206] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:25.207] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:25.207] - globals: [1] ‘FUN’
[13:17:25.207] 
[13:17:25.207] getGlobalsAndPackages() ... DONE
[13:17:25.207]  - globals found/used: [n=1] ‘FUN’
[13:17:25.207]  - needed namespaces: [n=0] 
[13:17:25.208] Finding globals ... DONE
[13:17:25.208]  - use_args: TRUE
[13:17:25.208]  - Getting '...' globals ...
[13:17:25.208] resolve() on list ...
[13:17:25.208]  recursive: 0
[13:17:25.208]  length: 1
[13:17:25.208]  elements: ‘...’
[13:17:25.209]  length: 0 (resolved future 1)
[13:17:25.209] resolve() on list ... DONE
[13:17:25.209]    - '...' content: [n=0] 
[13:17:25.209] List of 1
[13:17:25.209]  $ ...: list()
[13:17:25.209]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.209]  - attr(*, "where")=List of 1
[13:17:25.209]   ..$ ...:<environment: 0x5647bb4be3e8> 
[13:17:25.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.209]  - attr(*, "resolved")= logi TRUE
[13:17:25.209]  - attr(*, "total_size")= num NA
[13:17:25.212]  - Getting '...' globals ... DONE
[13:17:25.212] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:25.212] List of 2
[13:17:25.212]  $ ...future.FUN:function (x)  
[13:17:25.212]  $ ...          : list()
[13:17:25.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.212]  - attr(*, "where")=List of 2
[13:17:25.212]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:25.212]   ..$ ...          :<environment: 0x5647bb4be3e8> 
[13:17:25.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.212]  - attr(*, "resolved")= logi FALSE
[13:17:25.212]  - attr(*, "total_size")= num 848
[13:17:25.215] Packages to be attached in all futures: [n=0] 
[13:17:25.216] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.220] future_lapply() ...
[13:17:25.223] Number of chunks: 2
[13:17:25.224] getGlobalsAndPackagesXApply() ...
[13:17:25.224]  - future.globals: <name-value list> with names ‘list()’
[13:17:25.224]  - use_args: TRUE
[13:17:25.224] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:25.224] List of 2
[13:17:25.224]  $ ...          : list()
[13:17:25.224]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.224]  $ ...future.FUN:function (x)  
[13:17:25.224]  - attr(*, "where")=List of 2
[13:17:25.224]   ..$ ...          :<environment: 0x5647bb4be3e8> 
[13:17:25.224]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:25.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.224]  - attr(*, "resolved")= logi FALSE
[13:17:25.224]  - attr(*, "total_size")= num NA
[13:17:25.229] Packages to be attached in all futures: [n=0] 
[13:17:25.229] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.229] Number of futures (= number of chunks): 2
[13:17:25.229] Launching 2 futures (chunks) ...
[13:17:25.230] Chunk #1 of 2 ...
[13:17:25.230]  - seeds: <none>
[13:17:25.230] getGlobalsAndPackages() ...
[13:17:25.230] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.230] Resolving globals: FALSE
[13:17:25.230] Tweak future expression to call with '...' arguments ...
[13:17:25.230] {
[13:17:25.230]     do.call(function(...) {
[13:17:25.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.230]             on.exit(options(oopts), add = TRUE)
[13:17:25.230]         }
[13:17:25.230]         {
[13:17:25.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.230]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.230]             })
[13:17:25.230]         }
[13:17:25.230]     }, args = future.call.arguments)
[13:17:25.230] }
[13:17:25.231] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.231] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.231] 
[13:17:25.231] getGlobalsAndPackages() ... DONE
[13:17:25.232] run() for ‘Future’ ...
[13:17:25.232] - state: ‘created’
[13:17:25.232] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.235] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.236]   - Field: ‘label’
[13:17:25.236]   - Field: ‘local’
[13:17:25.236]   - Field: ‘owner’
[13:17:25.236]   - Field: ‘envir’
[13:17:25.236]   - Field: ‘workers’
[13:17:25.236]   - Field: ‘packages’
[13:17:25.236]   - Field: ‘gc’
[13:17:25.236]   - Field: ‘job’
[13:17:25.236]   - Field: ‘conditions’
[13:17:25.237]   - Field: ‘expr’
[13:17:25.237]   - Field: ‘uuid’
[13:17:25.237]   - Field: ‘seed’
[13:17:25.237]   - Field: ‘version’
[13:17:25.237]   - Field: ‘result’
[13:17:25.237]   - Field: ‘asynchronous’
[13:17:25.237]   - Field: ‘calls’
[13:17:25.237]   - Field: ‘globals’
[13:17:25.237]   - Field: ‘stdout’
[13:17:25.237]   - Field: ‘earlySignal’
[13:17:25.238]   - Field: ‘lazy’
[13:17:25.238]   - Field: ‘state’
[13:17:25.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.238] - Launch lazy future ...
[13:17:25.238] Packages needed by the future expression (n = 0): <none>
[13:17:25.238] Packages needed by future strategies (n = 0): <none>
[13:17:25.239] {
[13:17:25.239]     {
[13:17:25.239]         {
[13:17:25.239]             ...future.startTime <- base::Sys.time()
[13:17:25.239]             {
[13:17:25.239]                 {
[13:17:25.239]                   {
[13:17:25.239]                     {
[13:17:25.239]                       base::local({
[13:17:25.239]                         has_future <- base::requireNamespace("future", 
[13:17:25.239]                           quietly = TRUE)
[13:17:25.239]                         if (has_future) {
[13:17:25.239]                           ns <- base::getNamespace("future")
[13:17:25.239]                           version <- ns[[".package"]][["version"]]
[13:17:25.239]                           if (is.null(version)) 
[13:17:25.239]                             version <- utils::packageVersion("future")
[13:17:25.239]                         }
[13:17:25.239]                         else {
[13:17:25.239]                           version <- NULL
[13:17:25.239]                         }
[13:17:25.239]                         if (!has_future || version < "1.8.0") {
[13:17:25.239]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.239]                             "", base::R.version$version.string), 
[13:17:25.239]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.239]                               "release", "version")], collapse = " "), 
[13:17:25.239]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.239]                             info)
[13:17:25.239]                           info <- base::paste(info, collapse = "; ")
[13:17:25.239]                           if (!has_future) {
[13:17:25.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.239]                               info)
[13:17:25.239]                           }
[13:17:25.239]                           else {
[13:17:25.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.239]                               info, version)
[13:17:25.239]                           }
[13:17:25.239]                           base::stop(msg)
[13:17:25.239]                         }
[13:17:25.239]                       })
[13:17:25.239]                     }
[13:17:25.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.239]                     base::options(mc.cores = 1L)
[13:17:25.239]                   }
[13:17:25.239]                   options(future.plan = NULL)
[13:17:25.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.239]                 }
[13:17:25.239]                 ...future.workdir <- getwd()
[13:17:25.239]             }
[13:17:25.239]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.239]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.239]         }
[13:17:25.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.239]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.239]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.239]             base::names(...future.oldOptions))
[13:17:25.239]     }
[13:17:25.239]     if (FALSE) {
[13:17:25.239]     }
[13:17:25.239]     else {
[13:17:25.239]         if (TRUE) {
[13:17:25.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.239]                 open = "w")
[13:17:25.239]         }
[13:17:25.239]         else {
[13:17:25.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.239]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.239]         }
[13:17:25.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.239]             base::sink(type = "output", split = FALSE)
[13:17:25.239]             base::close(...future.stdout)
[13:17:25.239]         }, add = TRUE)
[13:17:25.239]     }
[13:17:25.239]     ...future.frame <- base::sys.nframe()
[13:17:25.239]     ...future.conditions <- base::list()
[13:17:25.239]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.239]     if (FALSE) {
[13:17:25.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.239]     }
[13:17:25.239]     ...future.result <- base::tryCatch({
[13:17:25.239]         base::withCallingHandlers({
[13:17:25.239]             ...future.value <- base::withVisible(base::local({
[13:17:25.239]                 withCallingHandlers({
[13:17:25.239]                   {
[13:17:25.239]                     do.call(function(...) {
[13:17:25.239]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.239]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.239]                         ...future.globals.maxSize)) {
[13:17:25.239]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.239]                         on.exit(options(oopts), add = TRUE)
[13:17:25.239]                       }
[13:17:25.239]                       {
[13:17:25.239]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.239]                           FUN = function(jj) {
[13:17:25.239]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.239]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.239]                           })
[13:17:25.239]                       }
[13:17:25.239]                     }, args = future.call.arguments)
[13:17:25.239]                   }
[13:17:25.239]                 }, immediateCondition = function(cond) {
[13:17:25.239]                   save_rds <- function (object, pathname, ...) 
[13:17:25.239]                   {
[13:17:25.239]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.239]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.239]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.239]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.239]                         fi_tmp[["mtime"]])
[13:17:25.239]                     }
[13:17:25.239]                     tryCatch({
[13:17:25.239]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.239]                     }, error = function(ex) {
[13:17:25.239]                       msg <- conditionMessage(ex)
[13:17:25.239]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.239]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.239]                         fi_tmp[["mtime"]], msg)
[13:17:25.239]                       ex$message <- msg
[13:17:25.239]                       stop(ex)
[13:17:25.239]                     })
[13:17:25.239]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.239]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.239]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.239]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.239]                       fi <- file.info(pathname)
[13:17:25.239]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.239]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.239]                         fi[["size"]], fi[["mtime"]])
[13:17:25.239]                       stop(msg)
[13:17:25.239]                     }
[13:17:25.239]                     invisible(pathname)
[13:17:25.239]                   }
[13:17:25.239]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.239]                     rootPath = tempdir()) 
[13:17:25.239]                   {
[13:17:25.239]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.239]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.239]                       tmpdir = path, fileext = ".rds")
[13:17:25.239]                     save_rds(obj, file)
[13:17:25.239]                   }
[13:17:25.239]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.239]                   {
[13:17:25.239]                     inherits <- base::inherits
[13:17:25.239]                     invokeRestart <- base::invokeRestart
[13:17:25.239]                     is.null <- base::is.null
[13:17:25.239]                     muffled <- FALSE
[13:17:25.239]                     if (inherits(cond, "message")) {
[13:17:25.239]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.239]                       if (muffled) 
[13:17:25.239]                         invokeRestart("muffleMessage")
[13:17:25.239]                     }
[13:17:25.239]                     else if (inherits(cond, "warning")) {
[13:17:25.239]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.239]                       if (muffled) 
[13:17:25.239]                         invokeRestart("muffleWarning")
[13:17:25.239]                     }
[13:17:25.239]                     else if (inherits(cond, "condition")) {
[13:17:25.239]                       if (!is.null(pattern)) {
[13:17:25.239]                         computeRestarts <- base::computeRestarts
[13:17:25.239]                         grepl <- base::grepl
[13:17:25.239]                         restarts <- computeRestarts(cond)
[13:17:25.239]                         for (restart in restarts) {
[13:17:25.239]                           name <- restart$name
[13:17:25.239]                           if (is.null(name)) 
[13:17:25.239]                             next
[13:17:25.239]                           if (!grepl(pattern, name)) 
[13:17:25.239]                             next
[13:17:25.239]                           invokeRestart(restart)
[13:17:25.239]                           muffled <- TRUE
[13:17:25.239]                           break
[13:17:25.239]                         }
[13:17:25.239]                       }
[13:17:25.239]                     }
[13:17:25.239]                     invisible(muffled)
[13:17:25.239]                   }
[13:17:25.239]                   muffleCondition(cond)
[13:17:25.239]                 })
[13:17:25.239]             }))
[13:17:25.239]             future::FutureResult(value = ...future.value$value, 
[13:17:25.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.239]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.239]                     ...future.globalenv.names))
[13:17:25.239]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.239]         }, condition = base::local({
[13:17:25.239]             c <- base::c
[13:17:25.239]             inherits <- base::inherits
[13:17:25.239]             invokeRestart <- base::invokeRestart
[13:17:25.239]             length <- base::length
[13:17:25.239]             list <- base::list
[13:17:25.239]             seq.int <- base::seq.int
[13:17:25.239]             signalCondition <- base::signalCondition
[13:17:25.239]             sys.calls <- base::sys.calls
[13:17:25.239]             `[[` <- base::`[[`
[13:17:25.239]             `+` <- base::`+`
[13:17:25.239]             `<<-` <- base::`<<-`
[13:17:25.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.239]                   3L)]
[13:17:25.239]             }
[13:17:25.239]             function(cond) {
[13:17:25.239]                 is_error <- inherits(cond, "error")
[13:17:25.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.239]                   NULL)
[13:17:25.239]                 if (is_error) {
[13:17:25.239]                   sessionInformation <- function() {
[13:17:25.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.239]                       search = base::search(), system = base::Sys.info())
[13:17:25.239]                   }
[13:17:25.239]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.239]                     cond$call), session = sessionInformation(), 
[13:17:25.239]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.239]                   signalCondition(cond)
[13:17:25.239]                 }
[13:17:25.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.239]                 "immediateCondition"))) {
[13:17:25.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.239]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.239]                   if (TRUE && !signal) {
[13:17:25.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.239]                     {
[13:17:25.239]                       inherits <- base::inherits
[13:17:25.239]                       invokeRestart <- base::invokeRestart
[13:17:25.239]                       is.null <- base::is.null
[13:17:25.239]                       muffled <- FALSE
[13:17:25.239]                       if (inherits(cond, "message")) {
[13:17:25.239]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.239]                         if (muffled) 
[13:17:25.239]                           invokeRestart("muffleMessage")
[13:17:25.239]                       }
[13:17:25.239]                       else if (inherits(cond, "warning")) {
[13:17:25.239]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.239]                         if (muffled) 
[13:17:25.239]                           invokeRestart("muffleWarning")
[13:17:25.239]                       }
[13:17:25.239]                       else if (inherits(cond, "condition")) {
[13:17:25.239]                         if (!is.null(pattern)) {
[13:17:25.239]                           computeRestarts <- base::computeRestarts
[13:17:25.239]                           grepl <- base::grepl
[13:17:25.239]                           restarts <- computeRestarts(cond)
[13:17:25.239]                           for (restart in restarts) {
[13:17:25.239]                             name <- restart$name
[13:17:25.239]                             if (is.null(name)) 
[13:17:25.239]                               next
[13:17:25.239]                             if (!grepl(pattern, name)) 
[13:17:25.239]                               next
[13:17:25.239]                             invokeRestart(restart)
[13:17:25.239]                             muffled <- TRUE
[13:17:25.239]                             break
[13:17:25.239]                           }
[13:17:25.239]                         }
[13:17:25.239]                       }
[13:17:25.239]                       invisible(muffled)
[13:17:25.239]                     }
[13:17:25.239]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.239]                   }
[13:17:25.239]                 }
[13:17:25.239]                 else {
[13:17:25.239]                   if (TRUE) {
[13:17:25.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.239]                     {
[13:17:25.239]                       inherits <- base::inherits
[13:17:25.239]                       invokeRestart <- base::invokeRestart
[13:17:25.239]                       is.null <- base::is.null
[13:17:25.239]                       muffled <- FALSE
[13:17:25.239]                       if (inherits(cond, "message")) {
[13:17:25.239]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.239]                         if (muffled) 
[13:17:25.239]                           invokeRestart("muffleMessage")
[13:17:25.239]                       }
[13:17:25.239]                       else if (inherits(cond, "warning")) {
[13:17:25.239]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.239]                         if (muffled) 
[13:17:25.239]                           invokeRestart("muffleWarning")
[13:17:25.239]                       }
[13:17:25.239]                       else if (inherits(cond, "condition")) {
[13:17:25.239]                         if (!is.null(pattern)) {
[13:17:25.239]                           computeRestarts <- base::computeRestarts
[13:17:25.239]                           grepl <- base::grepl
[13:17:25.239]                           restarts <- computeRestarts(cond)
[13:17:25.239]                           for (restart in restarts) {
[13:17:25.239]                             name <- restart$name
[13:17:25.239]                             if (is.null(name)) 
[13:17:25.239]                               next
[13:17:25.239]                             if (!grepl(pattern, name)) 
[13:17:25.239]                               next
[13:17:25.239]                             invokeRestart(restart)
[13:17:25.239]                             muffled <- TRUE
[13:17:25.239]                             break
[13:17:25.239]                           }
[13:17:25.239]                         }
[13:17:25.239]                       }
[13:17:25.239]                       invisible(muffled)
[13:17:25.239]                     }
[13:17:25.239]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.239]                   }
[13:17:25.239]                 }
[13:17:25.239]             }
[13:17:25.239]         }))
[13:17:25.239]     }, error = function(ex) {
[13:17:25.239]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.239]                 ...future.rng), started = ...future.startTime, 
[13:17:25.239]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.239]             version = "1.8"), class = "FutureResult")
[13:17:25.239]     }, finally = {
[13:17:25.239]         if (!identical(...future.workdir, getwd())) 
[13:17:25.239]             setwd(...future.workdir)
[13:17:25.239]         {
[13:17:25.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.239]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.239]             }
[13:17:25.239]             base::options(...future.oldOptions)
[13:17:25.239]             if (.Platform$OS.type == "windows") {
[13:17:25.239]                 old_names <- names(...future.oldEnvVars)
[13:17:25.239]                 envs <- base::Sys.getenv()
[13:17:25.239]                 names <- names(envs)
[13:17:25.239]                 common <- intersect(names, old_names)
[13:17:25.239]                 added <- setdiff(names, old_names)
[13:17:25.239]                 removed <- setdiff(old_names, names)
[13:17:25.239]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.239]                   envs[common]]
[13:17:25.239]                 NAMES <- toupper(changed)
[13:17:25.239]                 args <- list()
[13:17:25.239]                 for (kk in seq_along(NAMES)) {
[13:17:25.239]                   name <- changed[[kk]]
[13:17:25.239]                   NAME <- NAMES[[kk]]
[13:17:25.239]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.239]                     next
[13:17:25.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.239]                 }
[13:17:25.239]                 NAMES <- toupper(added)
[13:17:25.239]                 for (kk in seq_along(NAMES)) {
[13:17:25.239]                   name <- added[[kk]]
[13:17:25.239]                   NAME <- NAMES[[kk]]
[13:17:25.239]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.239]                     next
[13:17:25.239]                   args[[name]] <- ""
[13:17:25.239]                 }
[13:17:25.239]                 NAMES <- toupper(removed)
[13:17:25.239]                 for (kk in seq_along(NAMES)) {
[13:17:25.239]                   name <- removed[[kk]]
[13:17:25.239]                   NAME <- NAMES[[kk]]
[13:17:25.239]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.239]                     next
[13:17:25.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.239]                 }
[13:17:25.239]                 if (length(args) > 0) 
[13:17:25.239]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.239]             }
[13:17:25.239]             else {
[13:17:25.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.239]             }
[13:17:25.239]             {
[13:17:25.239]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.239]                   0L) {
[13:17:25.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.239]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.239]                   base::options(opts)
[13:17:25.239]                 }
[13:17:25.239]                 {
[13:17:25.239]                   {
[13:17:25.239]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.239]                     NULL
[13:17:25.239]                   }
[13:17:25.239]                   options(future.plan = NULL)
[13:17:25.239]                   if (is.na(NA_character_)) 
[13:17:25.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.239]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.239]                     envir = parent.frame()) 
[13:17:25.239]                   {
[13:17:25.239]                     default_workers <- missing(workers)
[13:17:25.239]                     if (is.function(workers)) 
[13:17:25.239]                       workers <- workers()
[13:17:25.239]                     workers <- structure(as.integer(workers), 
[13:17:25.239]                       class = class(workers))
[13:17:25.239]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.239]                       1L)
[13:17:25.239]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.239]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.239]                       if (default_workers) 
[13:17:25.239]                         supportsMulticore(warn = TRUE)
[13:17:25.239]                       return(sequential(..., envir = envir))
[13:17:25.239]                     }
[13:17:25.239]                     oopts <- options(mc.cores = workers)
[13:17:25.239]                     on.exit(options(oopts))
[13:17:25.239]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.239]                       envir = envir)
[13:17:25.239]                     if (!future$lazy) 
[13:17:25.239]                       future <- run(future)
[13:17:25.239]                     invisible(future)
[13:17:25.239]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.239]                 }
[13:17:25.239]             }
[13:17:25.239]         }
[13:17:25.239]     })
[13:17:25.239]     if (TRUE) {
[13:17:25.239]         base::sink(type = "output", split = FALSE)
[13:17:25.239]         if (TRUE) {
[13:17:25.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.239]         }
[13:17:25.239]         else {
[13:17:25.239]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.239]         }
[13:17:25.239]         base::close(...future.stdout)
[13:17:25.239]         ...future.stdout <- NULL
[13:17:25.239]     }
[13:17:25.239]     ...future.result$conditions <- ...future.conditions
[13:17:25.239]     ...future.result$finished <- base::Sys.time()
[13:17:25.239]     ...future.result
[13:17:25.239] }
[13:17:25.241] assign_globals() ...
[13:17:25.241] List of 5
[13:17:25.241]  $ future.call.arguments    : list()
[13:17:25.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.241]  $ ...future.FUN            :function (x)  
[13:17:25.241]  $ ...future.elements_ii    :List of 1
[13:17:25.241]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[13:17:25.241]  $ ...future.seeds_ii       : NULL
[13:17:25.241]  $ ...future.globals.maxSize: NULL
[13:17:25.241]  - attr(*, "where")=List of 5
[13:17:25.241]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.241]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.241]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.241]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.241]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.241]  - attr(*, "resolved")= logi FALSE
[13:17:25.241]  - attr(*, "total_size")= num NA
[13:17:25.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.241]  - attr(*, "already-done")= logi TRUE
[13:17:25.246] - copied ‘future.call.arguments’ to environment
[13:17:25.246] - copied ‘...future.FUN’ to environment
[13:17:25.246] - copied ‘...future.elements_ii’ to environment
[13:17:25.246] - copied ‘...future.seeds_ii’ to environment
[13:17:25.246] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.247] assign_globals() ... done
[13:17:25.247] requestCore(): workers = 2
[13:17:25.249] MulticoreFuture started
[13:17:25.249] - Launch lazy future ... done
[13:17:25.249] run() for ‘MulticoreFuture’ ... done
[13:17:25.250] Created future:
[13:17:25.250] plan(): Setting new future strategy stack:
[13:17:25.250] List of future strategies:
[13:17:25.250] 1. sequential:
[13:17:25.250]    - args: function (..., envir = parent.frame())
[13:17:25.250]    - tweaked: FALSE
[13:17:25.250]    - call: NULL
[13:17:25.251] plan(): nbrOfWorkers() = 1
[13:17:25.253] plan(): Setting new future strategy stack:
[13:17:25.253] List of future strategies:
[13:17:25.253] 1. multicore:
[13:17:25.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.253]    - tweaked: FALSE
[13:17:25.253]    - call: plan(strategy)
[13:17:25.258] plan(): nbrOfWorkers() = 2
[13:17:25.250] MulticoreFuture:
[13:17:25.250] Label: ‘future_apply-1’
[13:17:25.250] Expression:
[13:17:25.250] {
[13:17:25.250]     do.call(function(...) {
[13:17:25.250]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.250]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.250]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.250]             on.exit(options(oopts), add = TRUE)
[13:17:25.250]         }
[13:17:25.250]         {
[13:17:25.250]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.250]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.250]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.250]             })
[13:17:25.250]         }
[13:17:25.250]     }, args = future.call.arguments)
[13:17:25.250] }
[13:17:25.250] Lazy evaluation: FALSE
[13:17:25.250] Asynchronous evaluation: TRUE
[13:17:25.250] Local evaluation: TRUE
[13:17:25.250] Environment: R_GlobalEnv
[13:17:25.250] Capture standard output: TRUE
[13:17:25.250] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.250] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.250] Packages: <none>
[13:17:25.250] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.250] Resolved: TRUE
[13:17:25.250] Value: <not collected>
[13:17:25.250] Conditions captured: <none>
[13:17:25.250] Early signaling: FALSE
[13:17:25.250] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.250] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.259] Chunk #1 of 2 ... DONE
[13:17:25.259] Chunk #2 of 2 ...
[13:17:25.260]  - seeds: <none>
[13:17:25.260] getGlobalsAndPackages() ...
[13:17:25.260] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.260] Resolving globals: FALSE
[13:17:25.260] Tweak future expression to call with '...' arguments ...
[13:17:25.260] {
[13:17:25.260]     do.call(function(...) {
[13:17:25.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.260]             on.exit(options(oopts), add = TRUE)
[13:17:25.260]         }
[13:17:25.260]         {
[13:17:25.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.260]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.260]             })
[13:17:25.260]         }
[13:17:25.260]     }, args = future.call.arguments)
[13:17:25.260] }
[13:17:25.261] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.262] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.262] 
[13:17:25.262] getGlobalsAndPackages() ... DONE
[13:17:25.262] run() for ‘Future’ ...
[13:17:25.263] - state: ‘created’
[13:17:25.263] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.267] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.268]   - Field: ‘label’
[13:17:25.268]   - Field: ‘local’
[13:17:25.268]   - Field: ‘owner’
[13:17:25.268]   - Field: ‘envir’
[13:17:25.268]   - Field: ‘workers’
[13:17:25.268]   - Field: ‘packages’
[13:17:25.269]   - Field: ‘gc’
[13:17:25.272]   - Field: ‘job’
[13:17:25.272]   - Field: ‘conditions’
[13:17:25.273]   - Field: ‘expr’
[13:17:25.273]   - Field: ‘uuid’
[13:17:25.273]   - Field: ‘seed’
[13:17:25.274]   - Field: ‘version’
[13:17:25.274]   - Field: ‘result’
[13:17:25.274]   - Field: ‘asynchronous’
[13:17:25.274]   - Field: ‘calls’
[13:17:25.275]   - Field: ‘globals’
[13:17:25.275]   - Field: ‘stdout’
[13:17:25.275]   - Field: ‘earlySignal’
[13:17:25.275]   - Field: ‘lazy’
[13:17:25.276]   - Field: ‘state’
[13:17:25.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.276] - Launch lazy future ...
[13:17:25.277] Packages needed by the future expression (n = 0): <none>
[13:17:25.277] Packages needed by future strategies (n = 0): <none>
[13:17:25.278] {
[13:17:25.278]     {
[13:17:25.278]         {
[13:17:25.278]             ...future.startTime <- base::Sys.time()
[13:17:25.278]             {
[13:17:25.278]                 {
[13:17:25.278]                   {
[13:17:25.278]                     {
[13:17:25.278]                       base::local({
[13:17:25.278]                         has_future <- base::requireNamespace("future", 
[13:17:25.278]                           quietly = TRUE)
[13:17:25.278]                         if (has_future) {
[13:17:25.278]                           ns <- base::getNamespace("future")
[13:17:25.278]                           version <- ns[[".package"]][["version"]]
[13:17:25.278]                           if (is.null(version)) 
[13:17:25.278]                             version <- utils::packageVersion("future")
[13:17:25.278]                         }
[13:17:25.278]                         else {
[13:17:25.278]                           version <- NULL
[13:17:25.278]                         }
[13:17:25.278]                         if (!has_future || version < "1.8.0") {
[13:17:25.278]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.278]                             "", base::R.version$version.string), 
[13:17:25.278]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.278]                               "release", "version")], collapse = " "), 
[13:17:25.278]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.278]                             info)
[13:17:25.278]                           info <- base::paste(info, collapse = "; ")
[13:17:25.278]                           if (!has_future) {
[13:17:25.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.278]                               info)
[13:17:25.278]                           }
[13:17:25.278]                           else {
[13:17:25.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.278]                               info, version)
[13:17:25.278]                           }
[13:17:25.278]                           base::stop(msg)
[13:17:25.278]                         }
[13:17:25.278]                       })
[13:17:25.278]                     }
[13:17:25.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.278]                     base::options(mc.cores = 1L)
[13:17:25.278]                   }
[13:17:25.278]                   options(future.plan = NULL)
[13:17:25.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.278]                 }
[13:17:25.278]                 ...future.workdir <- getwd()
[13:17:25.278]             }
[13:17:25.278]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.278]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.278]         }
[13:17:25.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.278]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.278]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.278]             base::names(...future.oldOptions))
[13:17:25.278]     }
[13:17:25.278]     if (FALSE) {
[13:17:25.278]     }
[13:17:25.278]     else {
[13:17:25.278]         if (TRUE) {
[13:17:25.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.278]                 open = "w")
[13:17:25.278]         }
[13:17:25.278]         else {
[13:17:25.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.278]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.278]         }
[13:17:25.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.278]             base::sink(type = "output", split = FALSE)
[13:17:25.278]             base::close(...future.stdout)
[13:17:25.278]         }, add = TRUE)
[13:17:25.278]     }
[13:17:25.278]     ...future.frame <- base::sys.nframe()
[13:17:25.278]     ...future.conditions <- base::list()
[13:17:25.278]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.278]     if (FALSE) {
[13:17:25.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.278]     }
[13:17:25.278]     ...future.result <- base::tryCatch({
[13:17:25.278]         base::withCallingHandlers({
[13:17:25.278]             ...future.value <- base::withVisible(base::local({
[13:17:25.278]                 withCallingHandlers({
[13:17:25.278]                   {
[13:17:25.278]                     do.call(function(...) {
[13:17:25.278]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.278]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.278]                         ...future.globals.maxSize)) {
[13:17:25.278]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.278]                         on.exit(options(oopts), add = TRUE)
[13:17:25.278]                       }
[13:17:25.278]                       {
[13:17:25.278]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.278]                           FUN = function(jj) {
[13:17:25.278]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.278]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.278]                           })
[13:17:25.278]                       }
[13:17:25.278]                     }, args = future.call.arguments)
[13:17:25.278]                   }
[13:17:25.278]                 }, immediateCondition = function(cond) {
[13:17:25.278]                   save_rds <- function (object, pathname, ...) 
[13:17:25.278]                   {
[13:17:25.278]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.278]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.278]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.278]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.278]                         fi_tmp[["mtime"]])
[13:17:25.278]                     }
[13:17:25.278]                     tryCatch({
[13:17:25.278]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.278]                     }, error = function(ex) {
[13:17:25.278]                       msg <- conditionMessage(ex)
[13:17:25.278]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.278]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.278]                         fi_tmp[["mtime"]], msg)
[13:17:25.278]                       ex$message <- msg
[13:17:25.278]                       stop(ex)
[13:17:25.278]                     })
[13:17:25.278]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.278]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.278]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.278]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.278]                       fi <- file.info(pathname)
[13:17:25.278]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.278]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.278]                         fi[["size"]], fi[["mtime"]])
[13:17:25.278]                       stop(msg)
[13:17:25.278]                     }
[13:17:25.278]                     invisible(pathname)
[13:17:25.278]                   }
[13:17:25.278]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.278]                     rootPath = tempdir()) 
[13:17:25.278]                   {
[13:17:25.278]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.278]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.278]                       tmpdir = path, fileext = ".rds")
[13:17:25.278]                     save_rds(obj, file)
[13:17:25.278]                   }
[13:17:25.278]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.278]                   {
[13:17:25.278]                     inherits <- base::inherits
[13:17:25.278]                     invokeRestart <- base::invokeRestart
[13:17:25.278]                     is.null <- base::is.null
[13:17:25.278]                     muffled <- FALSE
[13:17:25.278]                     if (inherits(cond, "message")) {
[13:17:25.278]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.278]                       if (muffled) 
[13:17:25.278]                         invokeRestart("muffleMessage")
[13:17:25.278]                     }
[13:17:25.278]                     else if (inherits(cond, "warning")) {
[13:17:25.278]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.278]                       if (muffled) 
[13:17:25.278]                         invokeRestart("muffleWarning")
[13:17:25.278]                     }
[13:17:25.278]                     else if (inherits(cond, "condition")) {
[13:17:25.278]                       if (!is.null(pattern)) {
[13:17:25.278]                         computeRestarts <- base::computeRestarts
[13:17:25.278]                         grepl <- base::grepl
[13:17:25.278]                         restarts <- computeRestarts(cond)
[13:17:25.278]                         for (restart in restarts) {
[13:17:25.278]                           name <- restart$name
[13:17:25.278]                           if (is.null(name)) 
[13:17:25.278]                             next
[13:17:25.278]                           if (!grepl(pattern, name)) 
[13:17:25.278]                             next
[13:17:25.278]                           invokeRestart(restart)
[13:17:25.278]                           muffled <- TRUE
[13:17:25.278]                           break
[13:17:25.278]                         }
[13:17:25.278]                       }
[13:17:25.278]                     }
[13:17:25.278]                     invisible(muffled)
[13:17:25.278]                   }
[13:17:25.278]                   muffleCondition(cond)
[13:17:25.278]                 })
[13:17:25.278]             }))
[13:17:25.278]             future::FutureResult(value = ...future.value$value, 
[13:17:25.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.278]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.278]                     ...future.globalenv.names))
[13:17:25.278]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.278]         }, condition = base::local({
[13:17:25.278]             c <- base::c
[13:17:25.278]             inherits <- base::inherits
[13:17:25.278]             invokeRestart <- base::invokeRestart
[13:17:25.278]             length <- base::length
[13:17:25.278]             list <- base::list
[13:17:25.278]             seq.int <- base::seq.int
[13:17:25.278]             signalCondition <- base::signalCondition
[13:17:25.278]             sys.calls <- base::sys.calls
[13:17:25.278]             `[[` <- base::`[[`
[13:17:25.278]             `+` <- base::`+`
[13:17:25.278]             `<<-` <- base::`<<-`
[13:17:25.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.278]                   3L)]
[13:17:25.278]             }
[13:17:25.278]             function(cond) {
[13:17:25.278]                 is_error <- inherits(cond, "error")
[13:17:25.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.278]                   NULL)
[13:17:25.278]                 if (is_error) {
[13:17:25.278]                   sessionInformation <- function() {
[13:17:25.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.278]                       search = base::search(), system = base::Sys.info())
[13:17:25.278]                   }
[13:17:25.278]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.278]                     cond$call), session = sessionInformation(), 
[13:17:25.278]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.278]                   signalCondition(cond)
[13:17:25.278]                 }
[13:17:25.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.278]                 "immediateCondition"))) {
[13:17:25.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.278]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.278]                   if (TRUE && !signal) {
[13:17:25.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.278]                     {
[13:17:25.278]                       inherits <- base::inherits
[13:17:25.278]                       invokeRestart <- base::invokeRestart
[13:17:25.278]                       is.null <- base::is.null
[13:17:25.278]                       muffled <- FALSE
[13:17:25.278]                       if (inherits(cond, "message")) {
[13:17:25.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.278]                         if (muffled) 
[13:17:25.278]                           invokeRestart("muffleMessage")
[13:17:25.278]                       }
[13:17:25.278]                       else if (inherits(cond, "warning")) {
[13:17:25.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.278]                         if (muffled) 
[13:17:25.278]                           invokeRestart("muffleWarning")
[13:17:25.278]                       }
[13:17:25.278]                       else if (inherits(cond, "condition")) {
[13:17:25.278]                         if (!is.null(pattern)) {
[13:17:25.278]                           computeRestarts <- base::computeRestarts
[13:17:25.278]                           grepl <- base::grepl
[13:17:25.278]                           restarts <- computeRestarts(cond)
[13:17:25.278]                           for (restart in restarts) {
[13:17:25.278]                             name <- restart$name
[13:17:25.278]                             if (is.null(name)) 
[13:17:25.278]                               next
[13:17:25.278]                             if (!grepl(pattern, name)) 
[13:17:25.278]                               next
[13:17:25.278]                             invokeRestart(restart)
[13:17:25.278]                             muffled <- TRUE
[13:17:25.278]                             break
[13:17:25.278]                           }
[13:17:25.278]                         }
[13:17:25.278]                       }
[13:17:25.278]                       invisible(muffled)
[13:17:25.278]                     }
[13:17:25.278]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.278]                   }
[13:17:25.278]                 }
[13:17:25.278]                 else {
[13:17:25.278]                   if (TRUE) {
[13:17:25.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.278]                     {
[13:17:25.278]                       inherits <- base::inherits
[13:17:25.278]                       invokeRestart <- base::invokeRestart
[13:17:25.278]                       is.null <- base::is.null
[13:17:25.278]                       muffled <- FALSE
[13:17:25.278]                       if (inherits(cond, "message")) {
[13:17:25.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.278]                         if (muffled) 
[13:17:25.278]                           invokeRestart("muffleMessage")
[13:17:25.278]                       }
[13:17:25.278]                       else if (inherits(cond, "warning")) {
[13:17:25.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.278]                         if (muffled) 
[13:17:25.278]                           invokeRestart("muffleWarning")
[13:17:25.278]                       }
[13:17:25.278]                       else if (inherits(cond, "condition")) {
[13:17:25.278]                         if (!is.null(pattern)) {
[13:17:25.278]                           computeRestarts <- base::computeRestarts
[13:17:25.278]                           grepl <- base::grepl
[13:17:25.278]                           restarts <- computeRestarts(cond)
[13:17:25.278]                           for (restart in restarts) {
[13:17:25.278]                             name <- restart$name
[13:17:25.278]                             if (is.null(name)) 
[13:17:25.278]                               next
[13:17:25.278]                             if (!grepl(pattern, name)) 
[13:17:25.278]                               next
[13:17:25.278]                             invokeRestart(restart)
[13:17:25.278]                             muffled <- TRUE
[13:17:25.278]                             break
[13:17:25.278]                           }
[13:17:25.278]                         }
[13:17:25.278]                       }
[13:17:25.278]                       invisible(muffled)
[13:17:25.278]                     }
[13:17:25.278]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.278]                   }
[13:17:25.278]                 }
[13:17:25.278]             }
[13:17:25.278]         }))
[13:17:25.278]     }, error = function(ex) {
[13:17:25.278]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.278]                 ...future.rng), started = ...future.startTime, 
[13:17:25.278]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.278]             version = "1.8"), class = "FutureResult")
[13:17:25.278]     }, finally = {
[13:17:25.278]         if (!identical(...future.workdir, getwd())) 
[13:17:25.278]             setwd(...future.workdir)
[13:17:25.278]         {
[13:17:25.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.278]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.278]             }
[13:17:25.278]             base::options(...future.oldOptions)
[13:17:25.278]             if (.Platform$OS.type == "windows") {
[13:17:25.278]                 old_names <- names(...future.oldEnvVars)
[13:17:25.278]                 envs <- base::Sys.getenv()
[13:17:25.278]                 names <- names(envs)
[13:17:25.278]                 common <- intersect(names, old_names)
[13:17:25.278]                 added <- setdiff(names, old_names)
[13:17:25.278]                 removed <- setdiff(old_names, names)
[13:17:25.278]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.278]                   envs[common]]
[13:17:25.278]                 NAMES <- toupper(changed)
[13:17:25.278]                 args <- list()
[13:17:25.278]                 for (kk in seq_along(NAMES)) {
[13:17:25.278]                   name <- changed[[kk]]
[13:17:25.278]                   NAME <- NAMES[[kk]]
[13:17:25.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.278]                     next
[13:17:25.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.278]                 }
[13:17:25.278]                 NAMES <- toupper(added)
[13:17:25.278]                 for (kk in seq_along(NAMES)) {
[13:17:25.278]                   name <- added[[kk]]
[13:17:25.278]                   NAME <- NAMES[[kk]]
[13:17:25.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.278]                     next
[13:17:25.278]                   args[[name]] <- ""
[13:17:25.278]                 }
[13:17:25.278]                 NAMES <- toupper(removed)
[13:17:25.278]                 for (kk in seq_along(NAMES)) {
[13:17:25.278]                   name <- removed[[kk]]
[13:17:25.278]                   NAME <- NAMES[[kk]]
[13:17:25.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.278]                     next
[13:17:25.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.278]                 }
[13:17:25.278]                 if (length(args) > 0) 
[13:17:25.278]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.278]             }
[13:17:25.278]             else {
[13:17:25.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.278]             }
[13:17:25.278]             {
[13:17:25.278]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.278]                   0L) {
[13:17:25.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.278]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.278]                   base::options(opts)
[13:17:25.278]                 }
[13:17:25.278]                 {
[13:17:25.278]                   {
[13:17:25.278]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.278]                     NULL
[13:17:25.278]                   }
[13:17:25.278]                   options(future.plan = NULL)
[13:17:25.278]                   if (is.na(NA_character_)) 
[13:17:25.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.278]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.278]                     envir = parent.frame()) 
[13:17:25.278]                   {
[13:17:25.278]                     default_workers <- missing(workers)
[13:17:25.278]                     if (is.function(workers)) 
[13:17:25.278]                       workers <- workers()
[13:17:25.278]                     workers <- structure(as.integer(workers), 
[13:17:25.278]                       class = class(workers))
[13:17:25.278]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.278]                       1L)
[13:17:25.278]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.278]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.278]                       if (default_workers) 
[13:17:25.278]                         supportsMulticore(warn = TRUE)
[13:17:25.278]                       return(sequential(..., envir = envir))
[13:17:25.278]                     }
[13:17:25.278]                     oopts <- options(mc.cores = workers)
[13:17:25.278]                     on.exit(options(oopts))
[13:17:25.278]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.278]                       envir = envir)
[13:17:25.278]                     if (!future$lazy) 
[13:17:25.278]                       future <- run(future)
[13:17:25.278]                     invisible(future)
[13:17:25.278]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.278]                 }
[13:17:25.278]             }
[13:17:25.278]         }
[13:17:25.278]     })
[13:17:25.278]     if (TRUE) {
[13:17:25.278]         base::sink(type = "output", split = FALSE)
[13:17:25.278]         if (TRUE) {
[13:17:25.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.278]         }
[13:17:25.278]         else {
[13:17:25.278]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.278]         }
[13:17:25.278]         base::close(...future.stdout)
[13:17:25.278]         ...future.stdout <- NULL
[13:17:25.278]     }
[13:17:25.278]     ...future.result$conditions <- ...future.conditions
[13:17:25.278]     ...future.result$finished <- base::Sys.time()
[13:17:25.278]     ...future.result
[13:17:25.278] }
[13:17:25.281] assign_globals() ...
[13:17:25.281] List of 5
[13:17:25.281]  $ future.call.arguments    : list()
[13:17:25.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.281]  $ ...future.FUN            :function (x)  
[13:17:25.281]  $ ...future.elements_ii    :List of 1
[13:17:25.281]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[13:17:25.281]  $ ...future.seeds_ii       : NULL
[13:17:25.281]  $ ...future.globals.maxSize: NULL
[13:17:25.281]  - attr(*, "where")=List of 5
[13:17:25.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.281]  - attr(*, "resolved")= logi FALSE
[13:17:25.281]  - attr(*, "total_size")= num NA
[13:17:25.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.281]  - attr(*, "already-done")= logi TRUE
[13:17:25.289] - copied ‘future.call.arguments’ to environment
[13:17:25.289] - copied ‘...future.FUN’ to environment
[13:17:25.290] - copied ‘...future.elements_ii’ to environment
[13:17:25.290] - copied ‘...future.seeds_ii’ to environment
[13:17:25.290] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.290] assign_globals() ... done
[13:17:25.290] requestCore(): workers = 2
[13:17:25.292] MulticoreFuture started
[13:17:25.293] - Launch lazy future ... done
[13:17:25.293] run() for ‘MulticoreFuture’ ... done
[13:17:25.293] Created future:
[13:17:25.293] plan(): Setting new future strategy stack:
[13:17:25.294] List of future strategies:
[13:17:25.294] 1. sequential:
[13:17:25.294]    - args: function (..., envir = parent.frame())
[13:17:25.294]    - tweaked: FALSE
[13:17:25.294]    - call: NULL
[13:17:25.295] plan(): nbrOfWorkers() = 1
[13:17:25.297] plan(): Setting new future strategy stack:
[13:17:25.297] List of future strategies:
[13:17:25.297] 1. multicore:
[13:17:25.297]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.297]    - tweaked: FALSE
[13:17:25.297]    - call: plan(strategy)
[13:17:25.302] plan(): nbrOfWorkers() = 2
[13:17:25.293] MulticoreFuture:
[13:17:25.293] Label: ‘future_apply-2’
[13:17:25.293] Expression:
[13:17:25.293] {
[13:17:25.293]     do.call(function(...) {
[13:17:25.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.293]             on.exit(options(oopts), add = TRUE)
[13:17:25.293]         }
[13:17:25.293]         {
[13:17:25.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.293]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.293]             })
[13:17:25.293]         }
[13:17:25.293]     }, args = future.call.arguments)
[13:17:25.293] }
[13:17:25.293] Lazy evaluation: FALSE
[13:17:25.293] Asynchronous evaluation: TRUE
[13:17:25.293] Local evaluation: TRUE
[13:17:25.293] Environment: R_GlobalEnv
[13:17:25.293] Capture standard output: TRUE
[13:17:25.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.293] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.293] Packages: <none>
[13:17:25.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.293] Resolved: TRUE
[13:17:25.293] Value: <not collected>
[13:17:25.293] Conditions captured: <none>
[13:17:25.293] Early signaling: FALSE
[13:17:25.293] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.293] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.303] Chunk #2 of 2 ... DONE
[13:17:25.303] Launching 2 futures (chunks) ... DONE
[13:17:25.303] Resolving 2 futures (chunks) ...
[13:17:25.303] resolve() on list ...
[13:17:25.304]  recursive: 0
[13:17:25.304]  length: 2
[13:17:25.304] 
[13:17:25.304] Future #1
[13:17:25.305] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:25.305] - nx: 2
[13:17:25.306] - relay: TRUE
[13:17:25.306] - stdout: TRUE
[13:17:25.306] - signal: TRUE
[13:17:25.306] - resignal: FALSE
[13:17:25.306] - force: TRUE
[13:17:25.306] - relayed: [n=2] FALSE, FALSE
[13:17:25.306] - queued futures: [n=2] FALSE, FALSE
[13:17:25.307]  - until=1
[13:17:25.307]  - relaying element #1
[13:17:25.307] - relayed: [n=2] TRUE, FALSE
[13:17:25.307] - queued futures: [n=2] TRUE, FALSE
[13:17:25.307] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:25.308]  length: 1 (resolved future 1)
[13:17:25.308] Future #2
[13:17:25.309] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:25.309] - nx: 2
[13:17:25.309] - relay: TRUE
[13:17:25.309] - stdout: TRUE
[13:17:25.309] - signal: TRUE
[13:17:25.309] - resignal: FALSE
[13:17:25.310] - force: TRUE
[13:17:25.310] - relayed: [n=2] TRUE, FALSE
[13:17:25.310] - queued futures: [n=2] TRUE, FALSE
[13:17:25.310]  - until=2
[13:17:25.310]  - relaying element #2
[13:17:25.310] - relayed: [n=2] TRUE, TRUE
[13:17:25.310] - queued futures: [n=2] TRUE, TRUE
[13:17:25.310] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:25.311]  length: 0 (resolved future 2)
[13:17:25.311] Relaying remaining futures
[13:17:25.311] signalConditionsASAP(NULL, pos=0) ...
[13:17:25.311] - nx: 2
[13:17:25.311] - relay: TRUE
[13:17:25.311] - stdout: TRUE
[13:17:25.311] - signal: TRUE
[13:17:25.311] - resignal: FALSE
[13:17:25.311] - force: TRUE
[13:17:25.312] - relayed: [n=2] TRUE, TRUE
[13:17:25.312] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:25.312] - relayed: [n=2] TRUE, TRUE
[13:17:25.312] - queued futures: [n=2] TRUE, TRUE
[13:17:25.312] signalConditionsASAP(NULL, pos=0) ... done
[13:17:25.312] resolve() on list ... DONE
[13:17:25.312]  - Number of value chunks collected: 2
[13:17:25.313] Resolving 2 futures (chunks) ... DONE
[13:17:25.313] Reducing values from 2 chunks ...
[13:17:25.313]  - Number of values collected after concatenation: 2
[13:17:25.313]  - Number of values expected: 2
[13:17:25.313] Reducing values from 2 chunks ... DONE
[13:17:25.313] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:17:25.314] getGlobalsAndPackagesXApply() ...
[13:17:25.314]  - future.globals: TRUE
[13:17:25.314] getGlobalsAndPackages() ...
[13:17:25.314] Searching for globals...
[13:17:25.320] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:17:25.321] Searching for globals ... DONE
[13:17:25.321] Resolving globals: FALSE
[13:17:25.322] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:17:25.322] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:17:25.322] - globals: [1] ‘FUN’
[13:17:25.322] 
[13:17:25.323] getGlobalsAndPackages() ... DONE
[13:17:25.323]  - globals found/used: [n=1] ‘FUN’
[13:17:25.323]  - needed namespaces: [n=0] 
[13:17:25.323] Finding globals ... DONE
[13:17:25.323]  - use_args: TRUE
[13:17:25.323]  - Getting '...' globals ...
[13:17:25.324] resolve() on list ...
[13:17:25.324]  recursive: 0
[13:17:25.324]  length: 1
[13:17:25.324]  elements: ‘...’
[13:17:25.324]  length: 0 (resolved future 1)
[13:17:25.324] resolve() on list ... DONE
[13:17:25.324]    - '...' content: [n=0] 
[13:17:25.324] List of 1
[13:17:25.324]  $ ...: list()
[13:17:25.324]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.324]  - attr(*, "where")=List of 1
[13:17:25.324]   ..$ ...:<environment: 0x5647baf71408> 
[13:17:25.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.324]  - attr(*, "resolved")= logi TRUE
[13:17:25.324]  - attr(*, "total_size")= num NA
[13:17:25.328]  - Getting '...' globals ... DONE
[13:17:25.328] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:25.328] List of 2
[13:17:25.328]  $ ...future.FUN:function (x)  
[13:17:25.328]  $ ...          : list()
[13:17:25.328]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.328]  - attr(*, "where")=List of 2
[13:17:25.328]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:25.328]   ..$ ...          :<environment: 0x5647baf71408> 
[13:17:25.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.328]  - attr(*, "resolved")= logi FALSE
[13:17:25.328]  - attr(*, "total_size")= num 9888
[13:17:25.331] Packages to be attached in all futures: [n=0] 
[13:17:25.331] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.335] future_lapply() ...
[13:17:25.340] Number of chunks: 2
[13:17:25.340] getGlobalsAndPackagesXApply() ...
[13:17:25.340]  - future.globals: <name-value list> with names ‘list()’
[13:17:25.340]  - use_args: TRUE
[13:17:25.340] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:25.340] List of 2
[13:17:25.340]  $ ...          : list()
[13:17:25.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.340]  $ ...future.FUN:function (x)  
[13:17:25.340]  - attr(*, "where")=List of 2
[13:17:25.340]   ..$ ...          :<environment: 0x5647baf71408> 
[13:17:25.340]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:17:25.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.340]  - attr(*, "resolved")= logi FALSE
[13:17:25.340]  - attr(*, "total_size")= num NA
[13:17:25.343] Packages to be attached in all futures: [n=0] 
[13:17:25.343] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.346] Number of futures (= number of chunks): 2
[13:17:25.346] Launching 2 futures (chunks) ...
[13:17:25.346] Chunk #1 of 2 ...
[13:17:25.346]  - seeds: <none>
[13:17:25.346] getGlobalsAndPackages() ...
[13:17:25.346] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.346] Resolving globals: FALSE
[13:17:25.347] Tweak future expression to call with '...' arguments ...
[13:17:25.347] {
[13:17:25.347]     do.call(function(...) {
[13:17:25.347]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.347]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.347]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.347]             on.exit(options(oopts), add = TRUE)
[13:17:25.347]         }
[13:17:25.347]         {
[13:17:25.347]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.347]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.347]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.347]             })
[13:17:25.347]         }
[13:17:25.347]     }, args = future.call.arguments)
[13:17:25.347] }
[13:17:25.347] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.347] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.348] 
[13:17:25.348] getGlobalsAndPackages() ... DONE
[13:17:25.348] run() for ‘Future’ ...
[13:17:25.348] - state: ‘created’
[13:17:25.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.352] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.352] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.352]   - Field: ‘label’
[13:17:25.352]   - Field: ‘local’
[13:17:25.353]   - Field: ‘owner’
[13:17:25.353]   - Field: ‘envir’
[13:17:25.353]   - Field: ‘workers’
[13:17:25.353]   - Field: ‘packages’
[13:17:25.353]   - Field: ‘gc’
[13:17:25.353]   - Field: ‘job’
[13:17:25.353]   - Field: ‘conditions’
[13:17:25.353]   - Field: ‘expr’
[13:17:25.353]   - Field: ‘uuid’
[13:17:25.354]   - Field: ‘seed’
[13:17:25.354]   - Field: ‘version’
[13:17:25.354]   - Field: ‘result’
[13:17:25.354]   - Field: ‘asynchronous’
[13:17:25.354]   - Field: ‘calls’
[13:17:25.354]   - Field: ‘globals’
[13:17:25.354]   - Field: ‘stdout’
[13:17:25.354]   - Field: ‘earlySignal’
[13:17:25.354]   - Field: ‘lazy’
[13:17:25.354]   - Field: ‘state’
[13:17:25.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.355] - Launch lazy future ...
[13:17:25.355] Packages needed by the future expression (n = 0): <none>
[13:17:25.355] Packages needed by future strategies (n = 0): <none>
[13:17:25.355] {
[13:17:25.355]     {
[13:17:25.355]         {
[13:17:25.355]             ...future.startTime <- base::Sys.time()
[13:17:25.355]             {
[13:17:25.355]                 {
[13:17:25.355]                   {
[13:17:25.355]                     {
[13:17:25.355]                       base::local({
[13:17:25.355]                         has_future <- base::requireNamespace("future", 
[13:17:25.355]                           quietly = TRUE)
[13:17:25.355]                         if (has_future) {
[13:17:25.355]                           ns <- base::getNamespace("future")
[13:17:25.355]                           version <- ns[[".package"]][["version"]]
[13:17:25.355]                           if (is.null(version)) 
[13:17:25.355]                             version <- utils::packageVersion("future")
[13:17:25.355]                         }
[13:17:25.355]                         else {
[13:17:25.355]                           version <- NULL
[13:17:25.355]                         }
[13:17:25.355]                         if (!has_future || version < "1.8.0") {
[13:17:25.355]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.355]                             "", base::R.version$version.string), 
[13:17:25.355]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.355]                               "release", "version")], collapse = " "), 
[13:17:25.355]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.355]                             info)
[13:17:25.355]                           info <- base::paste(info, collapse = "; ")
[13:17:25.355]                           if (!has_future) {
[13:17:25.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.355]                               info)
[13:17:25.355]                           }
[13:17:25.355]                           else {
[13:17:25.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.355]                               info, version)
[13:17:25.355]                           }
[13:17:25.355]                           base::stop(msg)
[13:17:25.355]                         }
[13:17:25.355]                       })
[13:17:25.355]                     }
[13:17:25.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.355]                     base::options(mc.cores = 1L)
[13:17:25.355]                   }
[13:17:25.355]                   options(future.plan = NULL)
[13:17:25.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.355]                 }
[13:17:25.355]                 ...future.workdir <- getwd()
[13:17:25.355]             }
[13:17:25.355]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.355]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.355]         }
[13:17:25.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.355]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.355]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.355]             base::names(...future.oldOptions))
[13:17:25.355]     }
[13:17:25.355]     if (FALSE) {
[13:17:25.355]     }
[13:17:25.355]     else {
[13:17:25.355]         if (TRUE) {
[13:17:25.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.355]                 open = "w")
[13:17:25.355]         }
[13:17:25.355]         else {
[13:17:25.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.355]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.355]         }
[13:17:25.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.355]             base::sink(type = "output", split = FALSE)
[13:17:25.355]             base::close(...future.stdout)
[13:17:25.355]         }, add = TRUE)
[13:17:25.355]     }
[13:17:25.355]     ...future.frame <- base::sys.nframe()
[13:17:25.355]     ...future.conditions <- base::list()
[13:17:25.355]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.355]     if (FALSE) {
[13:17:25.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.355]     }
[13:17:25.355]     ...future.result <- base::tryCatch({
[13:17:25.355]         base::withCallingHandlers({
[13:17:25.355]             ...future.value <- base::withVisible(base::local({
[13:17:25.355]                 withCallingHandlers({
[13:17:25.355]                   {
[13:17:25.355]                     do.call(function(...) {
[13:17:25.355]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.355]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.355]                         ...future.globals.maxSize)) {
[13:17:25.355]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.355]                         on.exit(options(oopts), add = TRUE)
[13:17:25.355]                       }
[13:17:25.355]                       {
[13:17:25.355]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.355]                           FUN = function(jj) {
[13:17:25.355]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.355]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.355]                           })
[13:17:25.355]                       }
[13:17:25.355]                     }, args = future.call.arguments)
[13:17:25.355]                   }
[13:17:25.355]                 }, immediateCondition = function(cond) {
[13:17:25.355]                   save_rds <- function (object, pathname, ...) 
[13:17:25.355]                   {
[13:17:25.355]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.355]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.355]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.355]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.355]                         fi_tmp[["mtime"]])
[13:17:25.355]                     }
[13:17:25.355]                     tryCatch({
[13:17:25.355]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.355]                     }, error = function(ex) {
[13:17:25.355]                       msg <- conditionMessage(ex)
[13:17:25.355]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.355]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.355]                         fi_tmp[["mtime"]], msg)
[13:17:25.355]                       ex$message <- msg
[13:17:25.355]                       stop(ex)
[13:17:25.355]                     })
[13:17:25.355]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.355]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.355]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.355]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.355]                       fi <- file.info(pathname)
[13:17:25.355]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.355]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.355]                         fi[["size"]], fi[["mtime"]])
[13:17:25.355]                       stop(msg)
[13:17:25.355]                     }
[13:17:25.355]                     invisible(pathname)
[13:17:25.355]                   }
[13:17:25.355]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.355]                     rootPath = tempdir()) 
[13:17:25.355]                   {
[13:17:25.355]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.355]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.355]                       tmpdir = path, fileext = ".rds")
[13:17:25.355]                     save_rds(obj, file)
[13:17:25.355]                   }
[13:17:25.355]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.355]                   {
[13:17:25.355]                     inherits <- base::inherits
[13:17:25.355]                     invokeRestart <- base::invokeRestart
[13:17:25.355]                     is.null <- base::is.null
[13:17:25.355]                     muffled <- FALSE
[13:17:25.355]                     if (inherits(cond, "message")) {
[13:17:25.355]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.355]                       if (muffled) 
[13:17:25.355]                         invokeRestart("muffleMessage")
[13:17:25.355]                     }
[13:17:25.355]                     else if (inherits(cond, "warning")) {
[13:17:25.355]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.355]                       if (muffled) 
[13:17:25.355]                         invokeRestart("muffleWarning")
[13:17:25.355]                     }
[13:17:25.355]                     else if (inherits(cond, "condition")) {
[13:17:25.355]                       if (!is.null(pattern)) {
[13:17:25.355]                         computeRestarts <- base::computeRestarts
[13:17:25.355]                         grepl <- base::grepl
[13:17:25.355]                         restarts <- computeRestarts(cond)
[13:17:25.355]                         for (restart in restarts) {
[13:17:25.355]                           name <- restart$name
[13:17:25.355]                           if (is.null(name)) 
[13:17:25.355]                             next
[13:17:25.355]                           if (!grepl(pattern, name)) 
[13:17:25.355]                             next
[13:17:25.355]                           invokeRestart(restart)
[13:17:25.355]                           muffled <- TRUE
[13:17:25.355]                           break
[13:17:25.355]                         }
[13:17:25.355]                       }
[13:17:25.355]                     }
[13:17:25.355]                     invisible(muffled)
[13:17:25.355]                   }
[13:17:25.355]                   muffleCondition(cond)
[13:17:25.355]                 })
[13:17:25.355]             }))
[13:17:25.355]             future::FutureResult(value = ...future.value$value, 
[13:17:25.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.355]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.355]                     ...future.globalenv.names))
[13:17:25.355]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.355]         }, condition = base::local({
[13:17:25.355]             c <- base::c
[13:17:25.355]             inherits <- base::inherits
[13:17:25.355]             invokeRestart <- base::invokeRestart
[13:17:25.355]             length <- base::length
[13:17:25.355]             list <- base::list
[13:17:25.355]             seq.int <- base::seq.int
[13:17:25.355]             signalCondition <- base::signalCondition
[13:17:25.355]             sys.calls <- base::sys.calls
[13:17:25.355]             `[[` <- base::`[[`
[13:17:25.355]             `+` <- base::`+`
[13:17:25.355]             `<<-` <- base::`<<-`
[13:17:25.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.355]                   3L)]
[13:17:25.355]             }
[13:17:25.355]             function(cond) {
[13:17:25.355]                 is_error <- inherits(cond, "error")
[13:17:25.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.355]                   NULL)
[13:17:25.355]                 if (is_error) {
[13:17:25.355]                   sessionInformation <- function() {
[13:17:25.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.355]                       search = base::search(), system = base::Sys.info())
[13:17:25.355]                   }
[13:17:25.355]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.355]                     cond$call), session = sessionInformation(), 
[13:17:25.355]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.355]                   signalCondition(cond)
[13:17:25.355]                 }
[13:17:25.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.355]                 "immediateCondition"))) {
[13:17:25.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.355]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.355]                   if (TRUE && !signal) {
[13:17:25.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.355]                     {
[13:17:25.355]                       inherits <- base::inherits
[13:17:25.355]                       invokeRestart <- base::invokeRestart
[13:17:25.355]                       is.null <- base::is.null
[13:17:25.355]                       muffled <- FALSE
[13:17:25.355]                       if (inherits(cond, "message")) {
[13:17:25.355]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.355]                         if (muffled) 
[13:17:25.355]                           invokeRestart("muffleMessage")
[13:17:25.355]                       }
[13:17:25.355]                       else if (inherits(cond, "warning")) {
[13:17:25.355]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.355]                         if (muffled) 
[13:17:25.355]                           invokeRestart("muffleWarning")
[13:17:25.355]                       }
[13:17:25.355]                       else if (inherits(cond, "condition")) {
[13:17:25.355]                         if (!is.null(pattern)) {
[13:17:25.355]                           computeRestarts <- base::computeRestarts
[13:17:25.355]                           grepl <- base::grepl
[13:17:25.355]                           restarts <- computeRestarts(cond)
[13:17:25.355]                           for (restart in restarts) {
[13:17:25.355]                             name <- restart$name
[13:17:25.355]                             if (is.null(name)) 
[13:17:25.355]                               next
[13:17:25.355]                             if (!grepl(pattern, name)) 
[13:17:25.355]                               next
[13:17:25.355]                             invokeRestart(restart)
[13:17:25.355]                             muffled <- TRUE
[13:17:25.355]                             break
[13:17:25.355]                           }
[13:17:25.355]                         }
[13:17:25.355]                       }
[13:17:25.355]                       invisible(muffled)
[13:17:25.355]                     }
[13:17:25.355]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.355]                   }
[13:17:25.355]                 }
[13:17:25.355]                 else {
[13:17:25.355]                   if (TRUE) {
[13:17:25.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.355]                     {
[13:17:25.355]                       inherits <- base::inherits
[13:17:25.355]                       invokeRestart <- base::invokeRestart
[13:17:25.355]                       is.null <- base::is.null
[13:17:25.355]                       muffled <- FALSE
[13:17:25.355]                       if (inherits(cond, "message")) {
[13:17:25.355]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.355]                         if (muffled) 
[13:17:25.355]                           invokeRestart("muffleMessage")
[13:17:25.355]                       }
[13:17:25.355]                       else if (inherits(cond, "warning")) {
[13:17:25.355]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.355]                         if (muffled) 
[13:17:25.355]                           invokeRestart("muffleWarning")
[13:17:25.355]                       }
[13:17:25.355]                       else if (inherits(cond, "condition")) {
[13:17:25.355]                         if (!is.null(pattern)) {
[13:17:25.355]                           computeRestarts <- base::computeRestarts
[13:17:25.355]                           grepl <- base::grepl
[13:17:25.355]                           restarts <- computeRestarts(cond)
[13:17:25.355]                           for (restart in restarts) {
[13:17:25.355]                             name <- restart$name
[13:17:25.355]                             if (is.null(name)) 
[13:17:25.355]                               next
[13:17:25.355]                             if (!grepl(pattern, name)) 
[13:17:25.355]                               next
[13:17:25.355]                             invokeRestart(restart)
[13:17:25.355]                             muffled <- TRUE
[13:17:25.355]                             break
[13:17:25.355]                           }
[13:17:25.355]                         }
[13:17:25.355]                       }
[13:17:25.355]                       invisible(muffled)
[13:17:25.355]                     }
[13:17:25.355]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.355]                   }
[13:17:25.355]                 }
[13:17:25.355]             }
[13:17:25.355]         }))
[13:17:25.355]     }, error = function(ex) {
[13:17:25.355]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.355]                 ...future.rng), started = ...future.startTime, 
[13:17:25.355]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.355]             version = "1.8"), class = "FutureResult")
[13:17:25.355]     }, finally = {
[13:17:25.355]         if (!identical(...future.workdir, getwd())) 
[13:17:25.355]             setwd(...future.workdir)
[13:17:25.355]         {
[13:17:25.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.355]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.355]             }
[13:17:25.355]             base::options(...future.oldOptions)
[13:17:25.355]             if (.Platform$OS.type == "windows") {
[13:17:25.355]                 old_names <- names(...future.oldEnvVars)
[13:17:25.355]                 envs <- base::Sys.getenv()
[13:17:25.355]                 names <- names(envs)
[13:17:25.355]                 common <- intersect(names, old_names)
[13:17:25.355]                 added <- setdiff(names, old_names)
[13:17:25.355]                 removed <- setdiff(old_names, names)
[13:17:25.355]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.355]                   envs[common]]
[13:17:25.355]                 NAMES <- toupper(changed)
[13:17:25.355]                 args <- list()
[13:17:25.355]                 for (kk in seq_along(NAMES)) {
[13:17:25.355]                   name <- changed[[kk]]
[13:17:25.355]                   NAME <- NAMES[[kk]]
[13:17:25.355]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.355]                     next
[13:17:25.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.355]                 }
[13:17:25.355]                 NAMES <- toupper(added)
[13:17:25.355]                 for (kk in seq_along(NAMES)) {
[13:17:25.355]                   name <- added[[kk]]
[13:17:25.355]                   NAME <- NAMES[[kk]]
[13:17:25.355]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.355]                     next
[13:17:25.355]                   args[[name]] <- ""
[13:17:25.355]                 }
[13:17:25.355]                 NAMES <- toupper(removed)
[13:17:25.355]                 for (kk in seq_along(NAMES)) {
[13:17:25.355]                   name <- removed[[kk]]
[13:17:25.355]                   NAME <- NAMES[[kk]]
[13:17:25.355]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.355]                     next
[13:17:25.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.355]                 }
[13:17:25.355]                 if (length(args) > 0) 
[13:17:25.355]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.355]             }
[13:17:25.355]             else {
[13:17:25.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.355]             }
[13:17:25.355]             {
[13:17:25.355]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.355]                   0L) {
[13:17:25.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.355]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.355]                   base::options(opts)
[13:17:25.355]                 }
[13:17:25.355]                 {
[13:17:25.355]                   {
[13:17:25.355]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.355]                     NULL
[13:17:25.355]                   }
[13:17:25.355]                   options(future.plan = NULL)
[13:17:25.355]                   if (is.na(NA_character_)) 
[13:17:25.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.355]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.355]                     envir = parent.frame()) 
[13:17:25.355]                   {
[13:17:25.355]                     default_workers <- missing(workers)
[13:17:25.355]                     if (is.function(workers)) 
[13:17:25.355]                       workers <- workers()
[13:17:25.355]                     workers <- structure(as.integer(workers), 
[13:17:25.355]                       class = class(workers))
[13:17:25.355]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.355]                       1L)
[13:17:25.355]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.355]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.355]                       if (default_workers) 
[13:17:25.355]                         supportsMulticore(warn = TRUE)
[13:17:25.355]                       return(sequential(..., envir = envir))
[13:17:25.355]                     }
[13:17:25.355]                     oopts <- options(mc.cores = workers)
[13:17:25.355]                     on.exit(options(oopts))
[13:17:25.355]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.355]                       envir = envir)
[13:17:25.355]                     if (!future$lazy) 
[13:17:25.355]                       future <- run(future)
[13:17:25.355]                     invisible(future)
[13:17:25.355]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.355]                 }
[13:17:25.355]             }
[13:17:25.355]         }
[13:17:25.355]     })
[13:17:25.355]     if (TRUE) {
[13:17:25.355]         base::sink(type = "output", split = FALSE)
[13:17:25.355]         if (TRUE) {
[13:17:25.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.355]         }
[13:17:25.355]         else {
[13:17:25.355]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.355]         }
[13:17:25.355]         base::close(...future.stdout)
[13:17:25.355]         ...future.stdout <- NULL
[13:17:25.355]     }
[13:17:25.355]     ...future.result$conditions <- ...future.conditions
[13:17:25.355]     ...future.result$finished <- base::Sys.time()
[13:17:25.355]     ...future.result
[13:17:25.355] }
[13:17:25.358] assign_globals() ...
[13:17:25.358] List of 5
[13:17:25.358]  $ future.call.arguments    : list()
[13:17:25.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.358]  $ ...future.FUN            :function (x)  
[13:17:25.358]  $ ...future.elements_ii    :List of 1
[13:17:25.358]   ..$ : int [1:2] 1 3
[13:17:25.358]  $ ...future.seeds_ii       : NULL
[13:17:25.358]  $ ...future.globals.maxSize: NULL
[13:17:25.358]  - attr(*, "where")=List of 5
[13:17:25.358]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.358]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.358]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.358]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.358]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.358]  - attr(*, "resolved")= logi FALSE
[13:17:25.358]  - attr(*, "total_size")= num NA
[13:17:25.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.358]  - attr(*, "already-done")= logi TRUE
[13:17:25.363] - copied ‘future.call.arguments’ to environment
[13:17:25.363] - reassign environment for ‘...future.FUN’
[13:17:25.363] - copied ‘...future.FUN’ to environment
[13:17:25.363] - copied ‘...future.elements_ii’ to environment
[13:17:25.363] - copied ‘...future.seeds_ii’ to environment
[13:17:25.363] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.363] assign_globals() ... done
[13:17:25.364] requestCore(): workers = 2
[13:17:25.366] MulticoreFuture started
[13:17:25.366] - Launch lazy future ... done
[13:17:25.366] run() for ‘MulticoreFuture’ ... done
[13:17:25.367] Created future:
[13:17:25.367] plan(): Setting new future strategy stack:
[13:17:25.367] List of future strategies:
[13:17:25.367] 1. sequential:
[13:17:25.367]    - args: function (..., envir = parent.frame())
[13:17:25.367]    - tweaked: FALSE
[13:17:25.367]    - call: NULL
[13:17:25.368] plan(): nbrOfWorkers() = 1
[13:17:25.370] plan(): Setting new future strategy stack:
[13:17:25.370] List of future strategies:
[13:17:25.370] 1. multicore:
[13:17:25.370]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.370]    - tweaked: FALSE
[13:17:25.370]    - call: plan(strategy)
[13:17:25.375] plan(): nbrOfWorkers() = 2
[13:17:25.367] MulticoreFuture:
[13:17:25.367] Label: ‘future_apply-1’
[13:17:25.367] Expression:
[13:17:25.367] {
[13:17:25.367]     do.call(function(...) {
[13:17:25.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.367]             on.exit(options(oopts), add = TRUE)
[13:17:25.367]         }
[13:17:25.367]         {
[13:17:25.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.367]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.367]             })
[13:17:25.367]         }
[13:17:25.367]     }, args = future.call.arguments)
[13:17:25.367] }
[13:17:25.367] Lazy evaluation: FALSE
[13:17:25.367] Asynchronous evaluation: TRUE
[13:17:25.367] Local evaluation: TRUE
[13:17:25.367] Environment: R_GlobalEnv
[13:17:25.367] Capture standard output: TRUE
[13:17:25.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.367] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.367] Packages: <none>
[13:17:25.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.367] Resolved: TRUE
[13:17:25.367] Value: <not collected>
[13:17:25.367] Conditions captured: <none>
[13:17:25.367] Early signaling: FALSE
[13:17:25.367] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.367] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.376] Chunk #1 of 2 ... DONE
[13:17:25.377] Chunk #2 of 2 ...
[13:17:25.377]  - seeds: <none>
[13:17:25.377] getGlobalsAndPackages() ...
[13:17:25.377] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.377] Resolving globals: FALSE
[13:17:25.377] Tweak future expression to call with '...' arguments ...
[13:17:25.378] {
[13:17:25.378]     do.call(function(...) {
[13:17:25.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.378]             on.exit(options(oopts), add = TRUE)
[13:17:25.378]         }
[13:17:25.378]         {
[13:17:25.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.378]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.378]             })
[13:17:25.378]         }
[13:17:25.378]     }, args = future.call.arguments)
[13:17:25.378] }
[13:17:25.378] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.379] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.379] 
[13:17:25.379] getGlobalsAndPackages() ... DONE
[13:17:25.379] run() for ‘Future’ ...
[13:17:25.380] - state: ‘created’
[13:17:25.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.384] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.385]   - Field: ‘label’
[13:17:25.385]   - Field: ‘local’
[13:17:25.385]   - Field: ‘owner’
[13:17:25.385]   - Field: ‘envir’
[13:17:25.385]   - Field: ‘workers’
[13:17:25.389]   - Field: ‘packages’
[13:17:25.389]   - Field: ‘gc’
[13:17:25.389]   - Field: ‘job’
[13:17:25.390]   - Field: ‘conditions’
[13:17:25.390]   - Field: ‘expr’
[13:17:25.390]   - Field: ‘uuid’
[13:17:25.391]   - Field: ‘seed’
[13:17:25.391]   - Field: ‘version’
[13:17:25.391]   - Field: ‘result’
[13:17:25.392]   - Field: ‘asynchronous’
[13:17:25.392]   - Field: ‘calls’
[13:17:25.392]   - Field: ‘globals’
[13:17:25.392]   - Field: ‘stdout’
[13:17:25.392]   - Field: ‘earlySignal’
[13:17:25.393]   - Field: ‘lazy’
[13:17:25.393]   - Field: ‘state’
[13:17:25.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.394] - Launch lazy future ...
[13:17:25.394] Packages needed by the future expression (n = 0): <none>
[13:17:25.394] Packages needed by future strategies (n = 0): <none>
[13:17:25.396] {
[13:17:25.396]     {
[13:17:25.396]         {
[13:17:25.396]             ...future.startTime <- base::Sys.time()
[13:17:25.396]             {
[13:17:25.396]                 {
[13:17:25.396]                   {
[13:17:25.396]                     {
[13:17:25.396]                       base::local({
[13:17:25.396]                         has_future <- base::requireNamespace("future", 
[13:17:25.396]                           quietly = TRUE)
[13:17:25.396]                         if (has_future) {
[13:17:25.396]                           ns <- base::getNamespace("future")
[13:17:25.396]                           version <- ns[[".package"]][["version"]]
[13:17:25.396]                           if (is.null(version)) 
[13:17:25.396]                             version <- utils::packageVersion("future")
[13:17:25.396]                         }
[13:17:25.396]                         else {
[13:17:25.396]                           version <- NULL
[13:17:25.396]                         }
[13:17:25.396]                         if (!has_future || version < "1.8.0") {
[13:17:25.396]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.396]                             "", base::R.version$version.string), 
[13:17:25.396]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.396]                               "release", "version")], collapse = " "), 
[13:17:25.396]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.396]                             info)
[13:17:25.396]                           info <- base::paste(info, collapse = "; ")
[13:17:25.396]                           if (!has_future) {
[13:17:25.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.396]                               info)
[13:17:25.396]                           }
[13:17:25.396]                           else {
[13:17:25.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.396]                               info, version)
[13:17:25.396]                           }
[13:17:25.396]                           base::stop(msg)
[13:17:25.396]                         }
[13:17:25.396]                       })
[13:17:25.396]                     }
[13:17:25.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.396]                     base::options(mc.cores = 1L)
[13:17:25.396]                   }
[13:17:25.396]                   options(future.plan = NULL)
[13:17:25.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.396]                 }
[13:17:25.396]                 ...future.workdir <- getwd()
[13:17:25.396]             }
[13:17:25.396]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.396]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.396]         }
[13:17:25.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.396]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.396]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.396]             base::names(...future.oldOptions))
[13:17:25.396]     }
[13:17:25.396]     if (FALSE) {
[13:17:25.396]     }
[13:17:25.396]     else {
[13:17:25.396]         if (TRUE) {
[13:17:25.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.396]                 open = "w")
[13:17:25.396]         }
[13:17:25.396]         else {
[13:17:25.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.396]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.396]         }
[13:17:25.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.396]             base::sink(type = "output", split = FALSE)
[13:17:25.396]             base::close(...future.stdout)
[13:17:25.396]         }, add = TRUE)
[13:17:25.396]     }
[13:17:25.396]     ...future.frame <- base::sys.nframe()
[13:17:25.396]     ...future.conditions <- base::list()
[13:17:25.396]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.396]     if (FALSE) {
[13:17:25.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.396]     }
[13:17:25.396]     ...future.result <- base::tryCatch({
[13:17:25.396]         base::withCallingHandlers({
[13:17:25.396]             ...future.value <- base::withVisible(base::local({
[13:17:25.396]                 withCallingHandlers({
[13:17:25.396]                   {
[13:17:25.396]                     do.call(function(...) {
[13:17:25.396]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.396]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.396]                         ...future.globals.maxSize)) {
[13:17:25.396]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.396]                         on.exit(options(oopts), add = TRUE)
[13:17:25.396]                       }
[13:17:25.396]                       {
[13:17:25.396]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.396]                           FUN = function(jj) {
[13:17:25.396]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.396]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.396]                           })
[13:17:25.396]                       }
[13:17:25.396]                     }, args = future.call.arguments)
[13:17:25.396]                   }
[13:17:25.396]                 }, immediateCondition = function(cond) {
[13:17:25.396]                   save_rds <- function (object, pathname, ...) 
[13:17:25.396]                   {
[13:17:25.396]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.396]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.396]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.396]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.396]                         fi_tmp[["mtime"]])
[13:17:25.396]                     }
[13:17:25.396]                     tryCatch({
[13:17:25.396]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.396]                     }, error = function(ex) {
[13:17:25.396]                       msg <- conditionMessage(ex)
[13:17:25.396]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.396]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.396]                         fi_tmp[["mtime"]], msg)
[13:17:25.396]                       ex$message <- msg
[13:17:25.396]                       stop(ex)
[13:17:25.396]                     })
[13:17:25.396]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.396]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.396]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.396]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.396]                       fi <- file.info(pathname)
[13:17:25.396]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.396]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.396]                         fi[["size"]], fi[["mtime"]])
[13:17:25.396]                       stop(msg)
[13:17:25.396]                     }
[13:17:25.396]                     invisible(pathname)
[13:17:25.396]                   }
[13:17:25.396]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.396]                     rootPath = tempdir()) 
[13:17:25.396]                   {
[13:17:25.396]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.396]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.396]                       tmpdir = path, fileext = ".rds")
[13:17:25.396]                     save_rds(obj, file)
[13:17:25.396]                   }
[13:17:25.396]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.396]                   {
[13:17:25.396]                     inherits <- base::inherits
[13:17:25.396]                     invokeRestart <- base::invokeRestart
[13:17:25.396]                     is.null <- base::is.null
[13:17:25.396]                     muffled <- FALSE
[13:17:25.396]                     if (inherits(cond, "message")) {
[13:17:25.396]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.396]                       if (muffled) 
[13:17:25.396]                         invokeRestart("muffleMessage")
[13:17:25.396]                     }
[13:17:25.396]                     else if (inherits(cond, "warning")) {
[13:17:25.396]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.396]                       if (muffled) 
[13:17:25.396]                         invokeRestart("muffleWarning")
[13:17:25.396]                     }
[13:17:25.396]                     else if (inherits(cond, "condition")) {
[13:17:25.396]                       if (!is.null(pattern)) {
[13:17:25.396]                         computeRestarts <- base::computeRestarts
[13:17:25.396]                         grepl <- base::grepl
[13:17:25.396]                         restarts <- computeRestarts(cond)
[13:17:25.396]                         for (restart in restarts) {
[13:17:25.396]                           name <- restart$name
[13:17:25.396]                           if (is.null(name)) 
[13:17:25.396]                             next
[13:17:25.396]                           if (!grepl(pattern, name)) 
[13:17:25.396]                             next
[13:17:25.396]                           invokeRestart(restart)
[13:17:25.396]                           muffled <- TRUE
[13:17:25.396]                           break
[13:17:25.396]                         }
[13:17:25.396]                       }
[13:17:25.396]                     }
[13:17:25.396]                     invisible(muffled)
[13:17:25.396]                   }
[13:17:25.396]                   muffleCondition(cond)
[13:17:25.396]                 })
[13:17:25.396]             }))
[13:17:25.396]             future::FutureResult(value = ...future.value$value, 
[13:17:25.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.396]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.396]                     ...future.globalenv.names))
[13:17:25.396]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.396]         }, condition = base::local({
[13:17:25.396]             c <- base::c
[13:17:25.396]             inherits <- base::inherits
[13:17:25.396]             invokeRestart <- base::invokeRestart
[13:17:25.396]             length <- base::length
[13:17:25.396]             list <- base::list
[13:17:25.396]             seq.int <- base::seq.int
[13:17:25.396]             signalCondition <- base::signalCondition
[13:17:25.396]             sys.calls <- base::sys.calls
[13:17:25.396]             `[[` <- base::`[[`
[13:17:25.396]             `+` <- base::`+`
[13:17:25.396]             `<<-` <- base::`<<-`
[13:17:25.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.396]                   3L)]
[13:17:25.396]             }
[13:17:25.396]             function(cond) {
[13:17:25.396]                 is_error <- inherits(cond, "error")
[13:17:25.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.396]                   NULL)
[13:17:25.396]                 if (is_error) {
[13:17:25.396]                   sessionInformation <- function() {
[13:17:25.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.396]                       search = base::search(), system = base::Sys.info())
[13:17:25.396]                   }
[13:17:25.396]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.396]                     cond$call), session = sessionInformation(), 
[13:17:25.396]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.396]                   signalCondition(cond)
[13:17:25.396]                 }
[13:17:25.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:25.396]                 "immediateCondition"))) {
[13:17:25.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.396]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.396]                   if (TRUE && !signal) {
[13:17:25.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.396]                     {
[13:17:25.396]                       inherits <- base::inherits
[13:17:25.396]                       invokeRestart <- base::invokeRestart
[13:17:25.396]                       is.null <- base::is.null
[13:17:25.396]                       muffled <- FALSE
[13:17:25.396]                       if (inherits(cond, "message")) {
[13:17:25.396]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.396]                         if (muffled) 
[13:17:25.396]                           invokeRestart("muffleMessage")
[13:17:25.396]                       }
[13:17:25.396]                       else if (inherits(cond, "warning")) {
[13:17:25.396]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.396]                         if (muffled) 
[13:17:25.396]                           invokeRestart("muffleWarning")
[13:17:25.396]                       }
[13:17:25.396]                       else if (inherits(cond, "condition")) {
[13:17:25.396]                         if (!is.null(pattern)) {
[13:17:25.396]                           computeRestarts <- base::computeRestarts
[13:17:25.396]                           grepl <- base::grepl
[13:17:25.396]                           restarts <- computeRestarts(cond)
[13:17:25.396]                           for (restart in restarts) {
[13:17:25.396]                             name <- restart$name
[13:17:25.396]                             if (is.null(name)) 
[13:17:25.396]                               next
[13:17:25.396]                             if (!grepl(pattern, name)) 
[13:17:25.396]                               next
[13:17:25.396]                             invokeRestart(restart)
[13:17:25.396]                             muffled <- TRUE
[13:17:25.396]                             break
[13:17:25.396]                           }
[13:17:25.396]                         }
[13:17:25.396]                       }
[13:17:25.396]                       invisible(muffled)
[13:17:25.396]                     }
[13:17:25.396]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.396]                   }
[13:17:25.396]                 }
[13:17:25.396]                 else {
[13:17:25.396]                   if (TRUE) {
[13:17:25.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.396]                     {
[13:17:25.396]                       inherits <- base::inherits
[13:17:25.396]                       invokeRestart <- base::invokeRestart
[13:17:25.396]                       is.null <- base::is.null
[13:17:25.396]                       muffled <- FALSE
[13:17:25.396]                       if (inherits(cond, "message")) {
[13:17:25.396]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.396]                         if (muffled) 
[13:17:25.396]                           invokeRestart("muffleMessage")
[13:17:25.396]                       }
[13:17:25.396]                       else if (inherits(cond, "warning")) {
[13:17:25.396]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.396]                         if (muffled) 
[13:17:25.396]                           invokeRestart("muffleWarning")
[13:17:25.396]                       }
[13:17:25.396]                       else if (inherits(cond, "condition")) {
[13:17:25.396]                         if (!is.null(pattern)) {
[13:17:25.396]                           computeRestarts <- base::computeRestarts
[13:17:25.396]                           grepl <- base::grepl
[13:17:25.396]                           restarts <- computeRestarts(cond)
[13:17:25.396]                           for (restart in restarts) {
[13:17:25.396]                             name <- restart$name
[13:17:25.396]                             if (is.null(name)) 
[13:17:25.396]                               next
[13:17:25.396]                             if (!grepl(pattern, name)) 
[13:17:25.396]                               next
[13:17:25.396]                             invokeRestart(restart)
[13:17:25.396]                             muffled <- TRUE
[13:17:25.396]                             break
[13:17:25.396]                           }
[13:17:25.396]                         }
[13:17:25.396]                       }
[13:17:25.396]                       invisible(muffled)
[13:17:25.396]                     }
[13:17:25.396]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.396]                   }
[13:17:25.396]                 }
[13:17:25.396]             }
[13:17:25.396]         }))
[13:17:25.396]     }, error = function(ex) {
[13:17:25.396]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.396]                 ...future.rng), started = ...future.startTime, 
[13:17:25.396]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.396]             version = "1.8"), class = "FutureResult")
[13:17:25.396]     }, finally = {
[13:17:25.396]         if (!identical(...future.workdir, getwd())) 
[13:17:25.396]             setwd(...future.workdir)
[13:17:25.396]         {
[13:17:25.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.396]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.396]             }
[13:17:25.396]             base::options(...future.oldOptions)
[13:17:25.396]             if (.Platform$OS.type == "windows") {
[13:17:25.396]                 old_names <- names(...future.oldEnvVars)
[13:17:25.396]                 envs <- base::Sys.getenv()
[13:17:25.396]                 names <- names(envs)
[13:17:25.396]                 common <- intersect(names, old_names)
[13:17:25.396]                 added <- setdiff(names, old_names)
[13:17:25.396]                 removed <- setdiff(old_names, names)
[13:17:25.396]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.396]                   envs[common]]
[13:17:25.396]                 NAMES <- toupper(changed)
[13:17:25.396]                 args <- list()
[13:17:25.396]                 for (kk in seq_along(NAMES)) {
[13:17:25.396]                   name <- changed[[kk]]
[13:17:25.396]                   NAME <- NAMES[[kk]]
[13:17:25.396]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.396]                     next
[13:17:25.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.396]                 }
[13:17:25.396]                 NAMES <- toupper(added)
[13:17:25.396]                 for (kk in seq_along(NAMES)) {
[13:17:25.396]                   name <- added[[kk]]
[13:17:25.396]                   NAME <- NAMES[[kk]]
[13:17:25.396]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.396]                     next
[13:17:25.396]                   args[[name]] <- ""
[13:17:25.396]                 }
[13:17:25.396]                 NAMES <- toupper(removed)
[13:17:25.396]                 for (kk in seq_along(NAMES)) {
[13:17:25.396]                   name <- removed[[kk]]
[13:17:25.396]                   NAME <- NAMES[[kk]]
[13:17:25.396]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.396]                     next
[13:17:25.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.396]                 }
[13:17:25.396]                 if (length(args) > 0) 
[13:17:25.396]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.396]             }
[13:17:25.396]             else {
[13:17:25.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.396]             }
[13:17:25.396]             {
[13:17:25.396]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.396]                   0L) {
[13:17:25.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.396]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.396]                   base::options(opts)
[13:17:25.396]                 }
[13:17:25.396]                 {
[13:17:25.396]                   {
[13:17:25.396]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.396]                     NULL
[13:17:25.396]                   }
[13:17:25.396]                   options(future.plan = NULL)
[13:17:25.396]                   if (is.na(NA_character_)) 
[13:17:25.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.396]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.396]                     envir = parent.frame()) 
[13:17:25.396]                   {
[13:17:25.396]                     default_workers <- missing(workers)
[13:17:25.396]                     if (is.function(workers)) 
[13:17:25.396]                       workers <- workers()
[13:17:25.396]                     workers <- structure(as.integer(workers), 
[13:17:25.396]                       class = class(workers))
[13:17:25.396]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.396]                       1L)
[13:17:25.396]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.396]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.396]                       if (default_workers) 
[13:17:25.396]                         supportsMulticore(warn = TRUE)
[13:17:25.396]                       return(sequential(..., envir = envir))
[13:17:25.396]                     }
[13:17:25.396]                     oopts <- options(mc.cores = workers)
[13:17:25.396]                     on.exit(options(oopts))
[13:17:25.396]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.396]                       envir = envir)
[13:17:25.396]                     if (!future$lazy) 
[13:17:25.396]                       future <- run(future)
[13:17:25.396]                     invisible(future)
[13:17:25.396]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.396]                 }
[13:17:25.396]             }
[13:17:25.396]         }
[13:17:25.396]     })
[13:17:25.396]     if (TRUE) {
[13:17:25.396]         base::sink(type = "output", split = FALSE)
[13:17:25.396]         if (TRUE) {
[13:17:25.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.396]         }
[13:17:25.396]         else {
[13:17:25.396]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.396]         }
[13:17:25.396]         base::close(...future.stdout)
[13:17:25.396]         ...future.stdout <- NULL
[13:17:25.396]     }
[13:17:25.396]     ...future.result$conditions <- ...future.conditions
[13:17:25.396]     ...future.result$finished <- base::Sys.time()
[13:17:25.396]     ...future.result
[13:17:25.396] }
[13:17:25.399] assign_globals() ...
[13:17:25.399] List of 5
[13:17:25.399]  $ future.call.arguments    : list()
[13:17:25.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.399]  $ ...future.FUN            :function (x)  
[13:17:25.399]  $ ...future.elements_ii    :List of 1
[13:17:25.399]   ..$ : int [1:2] 2 4
[13:17:25.399]  $ ...future.seeds_ii       : NULL
[13:17:25.399]  $ ...future.globals.maxSize: NULL
[13:17:25.399]  - attr(*, "where")=List of 5
[13:17:25.399]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.399]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.399]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.399]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.399]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.399]  - attr(*, "resolved")= logi FALSE
[13:17:25.399]  - attr(*, "total_size")= num NA
[13:17:25.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.399]  - attr(*, "already-done")= logi TRUE
[13:17:25.406] - copied ‘future.call.arguments’ to environment
[13:17:25.407] - reassign environment for ‘...future.FUN’
[13:17:25.407] - copied ‘...future.FUN’ to environment
[13:17:25.407] - copied ‘...future.elements_ii’ to environment
[13:17:25.407] - copied ‘...future.seeds_ii’ to environment
[13:17:25.407] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.407] assign_globals() ... done
[13:17:25.408] requestCore(): workers = 2
[13:17:25.410] MulticoreFuture started
[13:17:25.410] - Launch lazy future ... done
[13:17:25.411] run() for ‘MulticoreFuture’ ... done
[13:17:25.411] Created future:
[13:17:25.411] plan(): Setting new future strategy stack:
[13:17:25.411] List of future strategies:
[13:17:25.411] 1. sequential:
[13:17:25.411]    - args: function (..., envir = parent.frame())
[13:17:25.411]    - tweaked: FALSE
[13:17:25.411]    - call: NULL
[13:17:25.412] plan(): nbrOfWorkers() = 1
[13:17:25.414] plan(): Setting new future strategy stack:
[13:17:25.414] List of future strategies:
[13:17:25.414] 1. multicore:
[13:17:25.414]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.414]    - tweaked: FALSE
[13:17:25.414]    - call: plan(strategy)
[13:17:25.419] plan(): nbrOfWorkers() = 2
[13:17:25.411] MulticoreFuture:
[13:17:25.411] Label: ‘future_apply-2’
[13:17:25.411] Expression:
[13:17:25.411] {
[13:17:25.411]     do.call(function(...) {
[13:17:25.411]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.411]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.411]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.411]             on.exit(options(oopts), add = TRUE)
[13:17:25.411]         }
[13:17:25.411]         {
[13:17:25.411]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.411]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.411]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.411]             })
[13:17:25.411]         }
[13:17:25.411]     }, args = future.call.arguments)
[13:17:25.411] }
[13:17:25.411] Lazy evaluation: FALSE
[13:17:25.411] Asynchronous evaluation: TRUE
[13:17:25.411] Local evaluation: TRUE
[13:17:25.411] Environment: R_GlobalEnv
[13:17:25.411] Capture standard output: TRUE
[13:17:25.411] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:25.411] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.411] Packages: <none>
[13:17:25.411] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:25.411] Resolved: TRUE
[13:17:25.411] Value: <not collected>
[13:17:25.411] Conditions captured: <none>
[13:17:25.411] Early signaling: FALSE
[13:17:25.411] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.411] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.421] Chunk #2 of 2 ... DONE
[13:17:25.421] Launching 2 futures (chunks) ... DONE
[13:17:25.421] Resolving 2 futures (chunks) ...
[13:17:25.421] resolve() on list ...
[13:17:25.421]  recursive: 0
[13:17:25.421]  length: 2
[13:17:25.422] 
[13:17:25.422] Future #1
[13:17:25.423] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:25.423] - nx: 2
[13:17:25.423] - relay: TRUE
[13:17:25.423] - stdout: TRUE
[13:17:25.424] - signal: TRUE
[13:17:25.424] - resignal: FALSE
[13:17:25.424] - force: TRUE
[13:17:25.424] - relayed: [n=2] FALSE, FALSE
[13:17:25.424] - queued futures: [n=2] FALSE, FALSE
[13:17:25.424]  - until=1
[13:17:25.424]  - relaying element #1
[13:17:25.425] - relayed: [n=2] TRUE, FALSE
[13:17:25.425] - queued futures: [n=2] TRUE, FALSE
[13:17:25.425] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:25.425]  length: 1 (resolved future 1)
[13:17:25.425] Future #2
[13:17:25.426] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:25.426] - nx: 2
[13:17:25.427] - relay: TRUE
[13:17:25.427] - stdout: TRUE
[13:17:25.427] - signal: TRUE
[13:17:25.427] - resignal: FALSE
[13:17:25.427] - force: TRUE
[13:17:25.427] - relayed: [n=2] TRUE, FALSE
[13:17:25.427] - queued futures: [n=2] TRUE, FALSE
[13:17:25.428]  - until=2
[13:17:25.428]  - relaying element #2
[13:17:25.428] - relayed: [n=2] TRUE, TRUE
[13:17:25.428] - queued futures: [n=2] TRUE, TRUE
[13:17:25.428] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:25.428]  length: 0 (resolved future 2)
[13:17:25.428] Relaying remaining futures
[13:17:25.429] signalConditionsASAP(NULL, pos=0) ...
[13:17:25.429] - nx: 2
[13:17:25.429] - relay: TRUE
[13:17:25.429] - stdout: TRUE
[13:17:25.429] - signal: TRUE
[13:17:25.429] - resignal: FALSE
[13:17:25.429] - force: TRUE
[13:17:25.429] - relayed: [n=2] TRUE, TRUE
[13:17:25.429] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:25.430] - relayed: [n=2] TRUE, TRUE
[13:17:25.430] - queued futures: [n=2] TRUE, TRUE
[13:17:25.430] signalConditionsASAP(NULL, pos=0) ... done
[13:17:25.430] resolve() on list ... DONE
[13:17:25.430]  - Number of value chunks collected: 2
[13:17:25.430] Resolving 2 futures (chunks) ... DONE
[13:17:25.430] Reducing values from 2 chunks ...
[13:17:25.431]  - Number of values collected after concatenation: 2
[13:17:25.431]  - Number of values expected: 2
[13:17:25.431] Reducing values from 2 chunks ... DONE
[13:17:25.431] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:17:25.431] getGlobalsAndPackagesXApply() ...
[13:17:25.431]  - future.globals: TRUE
[13:17:25.432] getGlobalsAndPackages() ...
[13:17:25.432] Searching for globals...
[13:17:25.439] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:17:25.439] Searching for globals ... DONE
[13:17:25.439] Resolving globals: FALSE
[13:17:25.440] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:17:25.441] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:17:25.441] - globals: [1] ‘FUN’
[13:17:25.441] 
[13:17:25.441] getGlobalsAndPackages() ... DONE
[13:17:25.441]  - globals found/used: [n=1] ‘FUN’
[13:17:25.441]  - needed namespaces: [n=0] 
[13:17:25.441] Finding globals ... DONE
[13:17:25.442]  - use_args: TRUE
[13:17:25.442]  - Getting '...' globals ...
[13:17:25.442] resolve() on list ...
[13:17:25.442]  recursive: 0
[13:17:25.443]  length: 1
[13:17:25.443]  elements: ‘...’
[13:17:25.443]  length: 0 (resolved future 1)
[13:17:25.443] resolve() on list ... DONE
[13:17:25.443]    - '...' content: [n=0] 
[13:17:25.443] List of 1
[13:17:25.443]  $ ...: list()
[13:17:25.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.443]  - attr(*, "where")=List of 1
[13:17:25.443]   ..$ ...:<environment: 0x5647bb01ef88> 
[13:17:25.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.443]  - attr(*, "resolved")= logi TRUE
[13:17:25.443]  - attr(*, "total_size")= num NA
[13:17:25.446]  - Getting '...' globals ... DONE
[13:17:25.446] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:25.447] List of 2
[13:17:25.447]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:17:25.447]  $ ...          : list()
[13:17:25.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.447]  - attr(*, "where")=List of 2
[13:17:25.447]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:25.447]   ..$ ...          :<environment: 0x5647bb01ef88> 
[13:17:25.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.447]  - attr(*, "resolved")= logi FALSE
[13:17:25.447]  - attr(*, "total_size")= num 36296
[13:17:25.449] Packages to be attached in all futures: [n=0] 
[13:17:25.449] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.453] future_lapply() ...
[13:17:25.455] Generating random seeds ...
[13:17:25.455] Generating random seed streams for 2 elements ...
[13:17:25.455] Generating random seed streams for 2 elements ... DONE
[13:17:25.456] Generating random seeds ... DONE
[13:17:25.456] Will set RNG state on exit: 10407, 814490448, 1101800072, 1741444439, 1304759412, 595559812, 190609906
[13:17:25.459] Number of chunks: 2
[13:17:25.459] getGlobalsAndPackagesXApply() ...
[13:17:25.459]  - future.globals: <name-value list> with names ‘list()’
[13:17:25.460]  - use_args: TRUE
[13:17:25.460] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:25.460] List of 2
[13:17:25.460]  $ ...          : list()
[13:17:25.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.460]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:17:25.460]  - attr(*, "where")=List of 2
[13:17:25.460]   ..$ ...          :<environment: 0x5647bb01ef88> 
[13:17:25.460]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:25.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.460]  - attr(*, "resolved")= logi FALSE
[13:17:25.460]  - attr(*, "total_size")= num NA
[13:17:25.466] Packages to be attached in all futures: [n=0] 
[13:17:25.466] getGlobalsAndPackagesXApply() ... DONE
[13:17:25.466] Number of futures (= number of chunks): 2
[13:17:25.466] Launching 2 futures (chunks) ...
[13:17:25.466] Chunk #1 of 2 ...
[13:17:25.466]  - seeds: [1] <seeds>
[13:17:25.466] getGlobalsAndPackages() ...
[13:17:25.467] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.467] Resolving globals: FALSE
[13:17:25.467] Tweak future expression to call with '...' arguments ...
[13:17:25.467] {
[13:17:25.467]     do.call(function(...) {
[13:17:25.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.467]             on.exit(options(oopts), add = TRUE)
[13:17:25.467]         }
[13:17:25.467]         {
[13:17:25.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.467]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:25.467]                   envir = globalenv(), inherits = FALSE)
[13:17:25.467]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.467]             })
[13:17:25.467]         }
[13:17:25.467]     }, args = future.call.arguments)
[13:17:25.467] }
[13:17:25.467] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.468] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.468] 
[13:17:25.468] getGlobalsAndPackages() ... DONE
[13:17:25.468] run() for ‘Future’ ...
[13:17:25.468] - state: ‘created’
[13:17:25.468] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.472] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.472]   - Field: ‘label’
[13:17:25.472]   - Field: ‘local’
[13:17:25.472]   - Field: ‘owner’
[13:17:25.473]   - Field: ‘envir’
[13:17:25.473]   - Field: ‘workers’
[13:17:25.473]   - Field: ‘packages’
[13:17:25.473]   - Field: ‘gc’
[13:17:25.473]   - Field: ‘job’
[13:17:25.473]   - Field: ‘conditions’
[13:17:25.473]   - Field: ‘expr’
[13:17:25.473]   - Field: ‘uuid’
[13:17:25.473]   - Field: ‘seed’
[13:17:25.473]   - Field: ‘version’
[13:17:25.474]   - Field: ‘result’
[13:17:25.474]   - Field: ‘asynchronous’
[13:17:25.474]   - Field: ‘calls’
[13:17:25.474]   - Field: ‘globals’
[13:17:25.474]   - Field: ‘stdout’
[13:17:25.474]   - Field: ‘earlySignal’
[13:17:25.474]   - Field: ‘lazy’
[13:17:25.474]   - Field: ‘state’
[13:17:25.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.474] - Launch lazy future ...
[13:17:25.475] Packages needed by the future expression (n = 0): <none>
[13:17:25.475] Packages needed by future strategies (n = 0): <none>
[13:17:25.475] {
[13:17:25.475]     {
[13:17:25.475]         {
[13:17:25.475]             ...future.startTime <- base::Sys.time()
[13:17:25.475]             {
[13:17:25.475]                 {
[13:17:25.475]                   {
[13:17:25.475]                     {
[13:17:25.475]                       base::local({
[13:17:25.475]                         has_future <- base::requireNamespace("future", 
[13:17:25.475]                           quietly = TRUE)
[13:17:25.475]                         if (has_future) {
[13:17:25.475]                           ns <- base::getNamespace("future")
[13:17:25.475]                           version <- ns[[".package"]][["version"]]
[13:17:25.475]                           if (is.null(version)) 
[13:17:25.475]                             version <- utils::packageVersion("future")
[13:17:25.475]                         }
[13:17:25.475]                         else {
[13:17:25.475]                           version <- NULL
[13:17:25.475]                         }
[13:17:25.475]                         if (!has_future || version < "1.8.0") {
[13:17:25.475]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.475]                             "", base::R.version$version.string), 
[13:17:25.475]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.475]                               "release", "version")], collapse = " "), 
[13:17:25.475]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.475]                             info)
[13:17:25.475]                           info <- base::paste(info, collapse = "; ")
[13:17:25.475]                           if (!has_future) {
[13:17:25.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.475]                               info)
[13:17:25.475]                           }
[13:17:25.475]                           else {
[13:17:25.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.475]                               info, version)
[13:17:25.475]                           }
[13:17:25.475]                           base::stop(msg)
[13:17:25.475]                         }
[13:17:25.475]                       })
[13:17:25.475]                     }
[13:17:25.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.475]                     base::options(mc.cores = 1L)
[13:17:25.475]                   }
[13:17:25.475]                   options(future.plan = NULL)
[13:17:25.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.475]                 }
[13:17:25.475]                 ...future.workdir <- getwd()
[13:17:25.475]             }
[13:17:25.475]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.475]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.475]         }
[13:17:25.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.475]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.475]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.475]             base::names(...future.oldOptions))
[13:17:25.475]     }
[13:17:25.475]     if (FALSE) {
[13:17:25.475]     }
[13:17:25.475]     else {
[13:17:25.475]         if (TRUE) {
[13:17:25.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.475]                 open = "w")
[13:17:25.475]         }
[13:17:25.475]         else {
[13:17:25.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.475]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.475]         }
[13:17:25.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.475]             base::sink(type = "output", split = FALSE)
[13:17:25.475]             base::close(...future.stdout)
[13:17:25.475]         }, add = TRUE)
[13:17:25.475]     }
[13:17:25.475]     ...future.frame <- base::sys.nframe()
[13:17:25.475]     ...future.conditions <- base::list()
[13:17:25.475]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.475]     if (FALSE) {
[13:17:25.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.475]     }
[13:17:25.475]     ...future.result <- base::tryCatch({
[13:17:25.475]         base::withCallingHandlers({
[13:17:25.475]             ...future.value <- base::withVisible(base::local({
[13:17:25.475]                 withCallingHandlers({
[13:17:25.475]                   {
[13:17:25.475]                     do.call(function(...) {
[13:17:25.475]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.475]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.475]                         ...future.globals.maxSize)) {
[13:17:25.475]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.475]                         on.exit(options(oopts), add = TRUE)
[13:17:25.475]                       }
[13:17:25.475]                       {
[13:17:25.475]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.475]                           FUN = function(jj) {
[13:17:25.475]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.475]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:25.475]                               envir = globalenv(), inherits = FALSE)
[13:17:25.475]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.475]                           })
[13:17:25.475]                       }
[13:17:25.475]                     }, args = future.call.arguments)
[13:17:25.475]                   }
[13:17:25.475]                 }, immediateCondition = function(cond) {
[13:17:25.475]                   save_rds <- function (object, pathname, ...) 
[13:17:25.475]                   {
[13:17:25.475]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.475]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.475]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.475]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.475]                         fi_tmp[["mtime"]])
[13:17:25.475]                     }
[13:17:25.475]                     tryCatch({
[13:17:25.475]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.475]                     }, error = function(ex) {
[13:17:25.475]                       msg <- conditionMessage(ex)
[13:17:25.475]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.475]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.475]                         fi_tmp[["mtime"]], msg)
[13:17:25.475]                       ex$message <- msg
[13:17:25.475]                       stop(ex)
[13:17:25.475]                     })
[13:17:25.475]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.475]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.475]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.475]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.475]                       fi <- file.info(pathname)
[13:17:25.475]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.475]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.475]                         fi[["size"]], fi[["mtime"]])
[13:17:25.475]                       stop(msg)
[13:17:25.475]                     }
[13:17:25.475]                     invisible(pathname)
[13:17:25.475]                   }
[13:17:25.475]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.475]                     rootPath = tempdir()) 
[13:17:25.475]                   {
[13:17:25.475]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.475]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.475]                       tmpdir = path, fileext = ".rds")
[13:17:25.475]                     save_rds(obj, file)
[13:17:25.475]                   }
[13:17:25.475]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.475]                   {
[13:17:25.475]                     inherits <- base::inherits
[13:17:25.475]                     invokeRestart <- base::invokeRestart
[13:17:25.475]                     is.null <- base::is.null
[13:17:25.475]                     muffled <- FALSE
[13:17:25.475]                     if (inherits(cond, "message")) {
[13:17:25.475]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.475]                       if (muffled) 
[13:17:25.475]                         invokeRestart("muffleMessage")
[13:17:25.475]                     }
[13:17:25.475]                     else if (inherits(cond, "warning")) {
[13:17:25.475]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.475]                       if (muffled) 
[13:17:25.475]                         invokeRestart("muffleWarning")
[13:17:25.475]                     }
[13:17:25.475]                     else if (inherits(cond, "condition")) {
[13:17:25.475]                       if (!is.null(pattern)) {
[13:17:25.475]                         computeRestarts <- base::computeRestarts
[13:17:25.475]                         grepl <- base::grepl
[13:17:25.475]                         restarts <- computeRestarts(cond)
[13:17:25.475]                         for (restart in restarts) {
[13:17:25.475]                           name <- restart$name
[13:17:25.475]                           if (is.null(name)) 
[13:17:25.475]                             next
[13:17:25.475]                           if (!grepl(pattern, name)) 
[13:17:25.475]                             next
[13:17:25.475]                           invokeRestart(restart)
[13:17:25.475]                           muffled <- TRUE
[13:17:25.475]                           break
[13:17:25.475]                         }
[13:17:25.475]                       }
[13:17:25.475]                     }
[13:17:25.475]                     invisible(muffled)
[13:17:25.475]                   }
[13:17:25.475]                   muffleCondition(cond)
[13:17:25.475]                 })
[13:17:25.475]             }))
[13:17:25.475]             future::FutureResult(value = ...future.value$value, 
[13:17:25.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.475]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.475]                     ...future.globalenv.names))
[13:17:25.475]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.475]         }, condition = base::local({
[13:17:25.475]             c <- base::c
[13:17:25.475]             inherits <- base::inherits
[13:17:25.475]             invokeRestart <- base::invokeRestart
[13:17:25.475]             length <- base::length
[13:17:25.475]             list <- base::list
[13:17:25.475]             seq.int <- base::seq.int
[13:17:25.475]             signalCondition <- base::signalCondition
[13:17:25.475]             sys.calls <- base::sys.calls
[13:17:25.475]             `[[` <- base::`[[`
[13:17:25.475]             `+` <- base::`+`
[13:17:25.475]             `<<-` <- base::`<<-`
[13:17:25.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.475]                   3L)]
[13:17:25.475]             }
[13:17:25.475]             function(cond) {
[13:17:25.475]                 is_error <- inherits(cond, "error")
[13:17:25.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.475]                   NULL)
[13:17:25.475]                 if (is_error) {
[13:17:25.475]                   sessionInformation <- function() {
[13:17:25.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.475]                       search = base::search(), system = base::Sys.info())
[13:17:25.475]                   }
[13:17:25.475]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.475]                     cond$call), session = sessionInformation(), 
[13:17:25.475]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.475]                   signalCondition(cond)
[13:17:25.475]                 }
[13:17:25.475]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:17:25.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.475]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.475]                   if (TRUE && !signal) {
[13:17:25.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.475]                     {
[13:17:25.475]                       inherits <- base::inherits
[13:17:25.475]                       invokeRestart <- base::invokeRestart
[13:17:25.475]                       is.null <- base::is.null
[13:17:25.475]                       muffled <- FALSE
[13:17:25.475]                       if (inherits(cond, "message")) {
[13:17:25.475]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.475]                         if (muffled) 
[13:17:25.475]                           invokeRestart("muffleMessage")
[13:17:25.475]                       }
[13:17:25.475]                       else if (inherits(cond, "warning")) {
[13:17:25.475]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.475]                         if (muffled) 
[13:17:25.475]                           invokeRestart("muffleWarning")
[13:17:25.475]                       }
[13:17:25.475]                       else if (inherits(cond, "condition")) {
[13:17:25.475]                         if (!is.null(pattern)) {
[13:17:25.475]                           computeRestarts <- base::computeRestarts
[13:17:25.475]                           grepl <- base::grepl
[13:17:25.475]                           restarts <- computeRestarts(cond)
[13:17:25.475]                           for (restart in restarts) {
[13:17:25.475]                             name <- restart$name
[13:17:25.475]                             if (is.null(name)) 
[13:17:25.475]                               next
[13:17:25.475]                             if (!grepl(pattern, name)) 
[13:17:25.475]                               next
[13:17:25.475]                             invokeRestart(restart)
[13:17:25.475]                             muffled <- TRUE
[13:17:25.475]                             break
[13:17:25.475]                           }
[13:17:25.475]                         }
[13:17:25.475]                       }
[13:17:25.475]                       invisible(muffled)
[13:17:25.475]                     }
[13:17:25.475]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.475]                   }
[13:17:25.475]                 }
[13:17:25.475]                 else {
[13:17:25.475]                   if (TRUE) {
[13:17:25.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.475]                     {
[13:17:25.475]                       inherits <- base::inherits
[13:17:25.475]                       invokeRestart <- base::invokeRestart
[13:17:25.475]                       is.null <- base::is.null
[13:17:25.475]                       muffled <- FALSE
[13:17:25.475]                       if (inherits(cond, "message")) {
[13:17:25.475]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.475]                         if (muffled) 
[13:17:25.475]                           invokeRestart("muffleMessage")
[13:17:25.475]                       }
[13:17:25.475]                       else if (inherits(cond, "warning")) {
[13:17:25.475]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.475]                         if (muffled) 
[13:17:25.475]                           invokeRestart("muffleWarning")
[13:17:25.475]                       }
[13:17:25.475]                       else if (inherits(cond, "condition")) {
[13:17:25.475]                         if (!is.null(pattern)) {
[13:17:25.475]                           computeRestarts <- base::computeRestarts
[13:17:25.475]                           grepl <- base::grepl
[13:17:25.475]                           restarts <- computeRestarts(cond)
[13:17:25.475]                           for (restart in restarts) {
[13:17:25.475]                             name <- restart$name
[13:17:25.475]                             if (is.null(name)) 
[13:17:25.475]                               next
[13:17:25.475]                             if (!grepl(pattern, name)) 
[13:17:25.475]                               next
[13:17:25.475]                             invokeRestart(restart)
[13:17:25.475]                             muffled <- TRUE
[13:17:25.475]                             break
[13:17:25.475]                           }
[13:17:25.475]                         }
[13:17:25.475]                       }
[13:17:25.475]                       invisible(muffled)
[13:17:25.475]                     }
[13:17:25.475]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.475]                   }
[13:17:25.475]                 }
[13:17:25.475]             }
[13:17:25.475]         }))
[13:17:25.475]     }, error = function(ex) {
[13:17:25.475]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.475]                 ...future.rng), started = ...future.startTime, 
[13:17:25.475]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.475]             version = "1.8"), class = "FutureResult")
[13:17:25.475]     }, finally = {
[13:17:25.475]         if (!identical(...future.workdir, getwd())) 
[13:17:25.475]             setwd(...future.workdir)
[13:17:25.475]         {
[13:17:25.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.475]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.475]             }
[13:17:25.475]             base::options(...future.oldOptions)
[13:17:25.475]             if (.Platform$OS.type == "windows") {
[13:17:25.475]                 old_names <- names(...future.oldEnvVars)
[13:17:25.475]                 envs <- base::Sys.getenv()
[13:17:25.475]                 names <- names(envs)
[13:17:25.475]                 common <- intersect(names, old_names)
[13:17:25.475]                 added <- setdiff(names, old_names)
[13:17:25.475]                 removed <- setdiff(old_names, names)
[13:17:25.475]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.475]                   envs[common]]
[13:17:25.475]                 NAMES <- toupper(changed)
[13:17:25.475]                 args <- list()
[13:17:25.475]                 for (kk in seq_along(NAMES)) {
[13:17:25.475]                   name <- changed[[kk]]
[13:17:25.475]                   NAME <- NAMES[[kk]]
[13:17:25.475]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.475]                     next
[13:17:25.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.475]                 }
[13:17:25.475]                 NAMES <- toupper(added)
[13:17:25.475]                 for (kk in seq_along(NAMES)) {
[13:17:25.475]                   name <- added[[kk]]
[13:17:25.475]                   NAME <- NAMES[[kk]]
[13:17:25.475]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.475]                     next
[13:17:25.475]                   args[[name]] <- ""
[13:17:25.475]                 }
[13:17:25.475]                 NAMES <- toupper(removed)
[13:17:25.475]                 for (kk in seq_along(NAMES)) {
[13:17:25.475]                   name <- removed[[kk]]
[13:17:25.475]                   NAME <- NAMES[[kk]]
[13:17:25.475]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.475]                     next
[13:17:25.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.475]                 }
[13:17:25.475]                 if (length(args) > 0) 
[13:17:25.475]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.475]             }
[13:17:25.475]             else {
[13:17:25.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.475]             }
[13:17:25.475]             {
[13:17:25.475]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.475]                   0L) {
[13:17:25.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.475]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.475]                   base::options(opts)
[13:17:25.475]                 }
[13:17:25.475]                 {
[13:17:25.475]                   {
[13:17:25.475]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.475]                     NULL
[13:17:25.475]                   }
[13:17:25.475]                   options(future.plan = NULL)
[13:17:25.475]                   if (is.na(NA_character_)) 
[13:17:25.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.475]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.475]                     envir = parent.frame()) 
[13:17:25.475]                   {
[13:17:25.475]                     default_workers <- missing(workers)
[13:17:25.475]                     if (is.function(workers)) 
[13:17:25.475]                       workers <- workers()
[13:17:25.475]                     workers <- structure(as.integer(workers), 
[13:17:25.475]                       class = class(workers))
[13:17:25.475]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.475]                       1L)
[13:17:25.475]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.475]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.475]                       if (default_workers) 
[13:17:25.475]                         supportsMulticore(warn = TRUE)
[13:17:25.475]                       return(sequential(..., envir = envir))
[13:17:25.475]                     }
[13:17:25.475]                     oopts <- options(mc.cores = workers)
[13:17:25.475]                     on.exit(options(oopts))
[13:17:25.475]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.475]                       envir = envir)
[13:17:25.475]                     if (!future$lazy) 
[13:17:25.475]                       future <- run(future)
[13:17:25.475]                     invisible(future)
[13:17:25.475]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.475]                 }
[13:17:25.475]             }
[13:17:25.475]         }
[13:17:25.475]     })
[13:17:25.475]     if (TRUE) {
[13:17:25.475]         base::sink(type = "output", split = FALSE)
[13:17:25.475]         if (TRUE) {
[13:17:25.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.475]         }
[13:17:25.475]         else {
[13:17:25.475]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.475]         }
[13:17:25.475]         base::close(...future.stdout)
[13:17:25.475]         ...future.stdout <- NULL
[13:17:25.475]     }
[13:17:25.475]     ...future.result$conditions <- ...future.conditions
[13:17:25.475]     ...future.result$finished <- base::Sys.time()
[13:17:25.475]     ...future.result
[13:17:25.475] }
[13:17:25.478] assign_globals() ...
[13:17:25.478] List of 5
[13:17:25.478]  $ future.call.arguments    : list()
[13:17:25.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.478]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:17:25.478]  $ ...future.elements_ii    :List of 1
[13:17:25.478]   ..$ : int [1:2] 1 3
[13:17:25.478]  $ ...future.seeds_ii       :List of 1
[13:17:25.478]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[13:17:25.478]  $ ...future.globals.maxSize: NULL
[13:17:25.478]  - attr(*, "where")=List of 5
[13:17:25.478]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.478]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.478]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.478]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.478]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.478]  - attr(*, "resolved")= logi FALSE
[13:17:25.478]  - attr(*, "total_size")= num NA
[13:17:25.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.478]  - attr(*, "already-done")= logi TRUE
[13:17:25.483] - copied ‘future.call.arguments’ to environment
[13:17:25.483] - copied ‘...future.FUN’ to environment
[13:17:25.483] - copied ‘...future.elements_ii’ to environment
[13:17:25.483] - copied ‘...future.seeds_ii’ to environment
[13:17:25.483] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.484] assign_globals() ... done
[13:17:25.484] requestCore(): workers = 2
[13:17:25.486] MulticoreFuture started
[13:17:25.486] - Launch lazy future ... done
[13:17:25.487] run() for ‘MulticoreFuture’ ... done
[13:17:25.487] Created future:
[13:17:25.487] plan(): Setting new future strategy stack:
[13:17:25.487] List of future strategies:
[13:17:25.487] 1. sequential:
[13:17:25.487]    - args: function (..., envir = parent.frame())
[13:17:25.487]    - tweaked: FALSE
[13:17:25.487]    - call: NULL
[13:17:25.488] plan(): nbrOfWorkers() = 1
[13:17:25.490] plan(): Setting new future strategy stack:
[13:17:25.491] List of future strategies:
[13:17:25.491] 1. multicore:
[13:17:25.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.491]    - tweaked: FALSE
[13:17:25.491]    - call: plan(strategy)
[13:17:25.487] MulticoreFuture:
[13:17:25.487] Label: ‘future_apply-1’
[13:17:25.487] Expression:
[13:17:25.487] {
[13:17:25.487]     do.call(function(...) {
[13:17:25.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.487]             on.exit(options(oopts), add = TRUE)
[13:17:25.487]         }
[13:17:25.487]         {
[13:17:25.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.487]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:25.487]                   envir = globalenv(), inherits = FALSE)
[13:17:25.487]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.487]             })
[13:17:25.487]         }
[13:17:25.487]     }, args = future.call.arguments)
[13:17:25.487] }
[13:17:25.487] Lazy evaluation: FALSE
[13:17:25.487] Asynchronous evaluation: TRUE
[13:17:25.487] Local evaluation: TRUE
[13:17:25.487] Environment: R_GlobalEnv
[13:17:25.487] Capture standard output: TRUE
[13:17:25.487] Capture condition classes: <none>
[13:17:25.487] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.487] Packages: <none>
[13:17:25.487] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:17:25.487] Resolved: FALSE
[13:17:25.487] Value: <not collected>
[13:17:25.487] Conditions captured: <none>
[13:17:25.487] Early signaling: FALSE
[13:17:25.487] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.487] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.500] Chunk #1 of 2 ... DONE
[13:17:25.500] Chunk #2 of 2 ...
[13:17:25.500]  - seeds: [1] <seeds>
[13:17:25.501] getGlobalsAndPackages() ...
[13:17:25.505] plan(): nbrOfWorkers() = 2
[13:17:25.501] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.508] Resolving globals: FALSE
[13:17:25.508] Tweak future expression to call with '...' arguments ...
[13:17:25.508] {
[13:17:25.508]     do.call(function(...) {
[13:17:25.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.508]             on.exit(options(oopts), add = TRUE)
[13:17:25.508]         }
[13:17:25.508]         {
[13:17:25.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.508]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:25.508]                   envir = globalenv(), inherits = FALSE)
[13:17:25.508]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.508]             })
[13:17:25.508]         }
[13:17:25.508]     }, args = future.call.arguments)
[13:17:25.508] }
[13:17:25.508] Tweak future expression to call with '...' arguments ... DONE
[13:17:25.509] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:25.509] 
[13:17:25.509] getGlobalsAndPackages() ... DONE
[13:17:25.510] run() for ‘Future’ ...
[13:17:25.510] - state: ‘created’
[13:17:25.510] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:17:25.515] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:17:25.516]   - Field: ‘label’
[13:17:25.516]   - Field: ‘local’
[13:17:25.516]   - Field: ‘owner’
[13:17:25.517]   - Field: ‘envir’
[13:17:25.517]   - Field: ‘workers’
[13:17:25.517]   - Field: ‘packages’
[13:17:25.517]   - Field: ‘gc’
[13:17:25.518]   - Field: ‘job’
[13:17:25.518]   - Field: ‘conditions’
[13:17:25.518]   - Field: ‘expr’
[13:17:25.518]   - Field: ‘uuid’
[13:17:25.518]   - Field: ‘seed’
[13:17:25.519]   - Field: ‘version’
[13:17:25.519]   - Field: ‘result’
[13:17:25.519]   - Field: ‘asynchronous’
[13:17:25.519]   - Field: ‘calls’
[13:17:25.519]   - Field: ‘globals’
[13:17:25.519]   - Field: ‘stdout’
[13:17:25.519]   - Field: ‘earlySignal’
[13:17:25.520]   - Field: ‘lazy’
[13:17:25.520]   - Field: ‘state’
[13:17:25.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:17:25.520] - Launch lazy future ...
[13:17:25.520] Packages needed by the future expression (n = 0): <none>
[13:17:25.521] Packages needed by future strategies (n = 0): <none>
[13:17:25.522] {
[13:17:25.522]     {
[13:17:25.522]         {
[13:17:25.522]             ...future.startTime <- base::Sys.time()
[13:17:25.522]             {
[13:17:25.522]                 {
[13:17:25.522]                   {
[13:17:25.522]                     {
[13:17:25.522]                       base::local({
[13:17:25.522]                         has_future <- base::requireNamespace("future", 
[13:17:25.522]                           quietly = TRUE)
[13:17:25.522]                         if (has_future) {
[13:17:25.522]                           ns <- base::getNamespace("future")
[13:17:25.522]                           version <- ns[[".package"]][["version"]]
[13:17:25.522]                           if (is.null(version)) 
[13:17:25.522]                             version <- utils::packageVersion("future")
[13:17:25.522]                         }
[13:17:25.522]                         else {
[13:17:25.522]                           version <- NULL
[13:17:25.522]                         }
[13:17:25.522]                         if (!has_future || version < "1.8.0") {
[13:17:25.522]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:25.522]                             "", base::R.version$version.string), 
[13:17:25.522]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:25.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:25.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:25.522]                               "release", "version")], collapse = " "), 
[13:17:25.522]                             hostname = base::Sys.info()[["nodename"]])
[13:17:25.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:25.522]                             info)
[13:17:25.522]                           info <- base::paste(info, collapse = "; ")
[13:17:25.522]                           if (!has_future) {
[13:17:25.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:25.522]                               info)
[13:17:25.522]                           }
[13:17:25.522]                           else {
[13:17:25.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:25.522]                               info, version)
[13:17:25.522]                           }
[13:17:25.522]                           base::stop(msg)
[13:17:25.522]                         }
[13:17:25.522]                       })
[13:17:25.522]                     }
[13:17:25.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:25.522]                     base::options(mc.cores = 1L)
[13:17:25.522]                   }
[13:17:25.522]                   options(future.plan = NULL)
[13:17:25.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:25.522]                 }
[13:17:25.522]                 ...future.workdir <- getwd()
[13:17:25.522]             }
[13:17:25.522]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:25.522]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:25.522]         }
[13:17:25.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:25.522]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:25.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:25.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:25.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:25.522]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:25.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:25.522]             base::names(...future.oldOptions))
[13:17:25.522]     }
[13:17:25.522]     if (FALSE) {
[13:17:25.522]     }
[13:17:25.522]     else {
[13:17:25.522]         if (TRUE) {
[13:17:25.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:25.522]                 open = "w")
[13:17:25.522]         }
[13:17:25.522]         else {
[13:17:25.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:25.522]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:25.522]         }
[13:17:25.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:25.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:25.522]             base::sink(type = "output", split = FALSE)
[13:17:25.522]             base::close(...future.stdout)
[13:17:25.522]         }, add = TRUE)
[13:17:25.522]     }
[13:17:25.522]     ...future.frame <- base::sys.nframe()
[13:17:25.522]     ...future.conditions <- base::list()
[13:17:25.522]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:25.522]     if (FALSE) {
[13:17:25.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:25.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:25.522]     }
[13:17:25.522]     ...future.result <- base::tryCatch({
[13:17:25.522]         base::withCallingHandlers({
[13:17:25.522]             ...future.value <- base::withVisible(base::local({
[13:17:25.522]                 withCallingHandlers({
[13:17:25.522]                   {
[13:17:25.522]                     do.call(function(...) {
[13:17:25.522]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.522]                       if (!identical(...future.globals.maxSize.org, 
[13:17:25.522]                         ...future.globals.maxSize)) {
[13:17:25.522]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.522]                         on.exit(options(oopts), add = TRUE)
[13:17:25.522]                       }
[13:17:25.522]                       {
[13:17:25.522]                         lapply(seq_along(...future.elements_ii), 
[13:17:25.522]                           FUN = function(jj) {
[13:17:25.522]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.522]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:25.522]                               envir = globalenv(), inherits = FALSE)
[13:17:25.522]                             ...future.FUN(...future.X_jj, ...)
[13:17:25.522]                           })
[13:17:25.522]                       }
[13:17:25.522]                     }, args = future.call.arguments)
[13:17:25.522]                   }
[13:17:25.522]                 }, immediateCondition = function(cond) {
[13:17:25.522]                   save_rds <- function (object, pathname, ...) 
[13:17:25.522]                   {
[13:17:25.522]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:17:25.522]                     if (file_test("-f", pathname_tmp)) {
[13:17:25.522]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.522]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:17:25.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.522]                         fi_tmp[["mtime"]])
[13:17:25.522]                     }
[13:17:25.522]                     tryCatch({
[13:17:25.522]                       saveRDS(object, file = pathname_tmp, ...)
[13:17:25.522]                     }, error = function(ex) {
[13:17:25.522]                       msg <- conditionMessage(ex)
[13:17:25.522]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.522]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:17:25.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.522]                         fi_tmp[["mtime"]], msg)
[13:17:25.522]                       ex$message <- msg
[13:17:25.522]                       stop(ex)
[13:17:25.522]                     })
[13:17:25.522]                     stopifnot(file_test("-f", pathname_tmp))
[13:17:25.522]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:17:25.522]                     if (!res || file_test("-f", pathname_tmp)) {
[13:17:25.522]                       fi_tmp <- file.info(pathname_tmp)
[13:17:25.522]                       fi <- file.info(pathname)
[13:17:25.522]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:17:25.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:17:25.522]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:17:25.522]                         fi[["size"]], fi[["mtime"]])
[13:17:25.522]                       stop(msg)
[13:17:25.522]                     }
[13:17:25.522]                     invisible(pathname)
[13:17:25.522]                   }
[13:17:25.522]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:17:25.522]                     rootPath = tempdir()) 
[13:17:25.522]                   {
[13:17:25.522]                     obj <- list(time = Sys.time(), condition = cond)
[13:17:25.522]                     file <- tempfile(pattern = class(cond)[1], 
[13:17:25.522]                       tmpdir = path, fileext = ".rds")
[13:17:25.522]                     save_rds(obj, file)
[13:17:25.522]                   }
[13:17:25.522]                   saveImmediateCondition(cond, path = "/tmp/RtmppqFfKI/.future/immediateConditions")
[13:17:25.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.522]                   {
[13:17:25.522]                     inherits <- base::inherits
[13:17:25.522]                     invokeRestart <- base::invokeRestart
[13:17:25.522]                     is.null <- base::is.null
[13:17:25.522]                     muffled <- FALSE
[13:17:25.522]                     if (inherits(cond, "message")) {
[13:17:25.522]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:25.522]                       if (muffled) 
[13:17:25.522]                         invokeRestart("muffleMessage")
[13:17:25.522]                     }
[13:17:25.522]                     else if (inherits(cond, "warning")) {
[13:17:25.522]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:25.522]                       if (muffled) 
[13:17:25.522]                         invokeRestart("muffleWarning")
[13:17:25.522]                     }
[13:17:25.522]                     else if (inherits(cond, "condition")) {
[13:17:25.522]                       if (!is.null(pattern)) {
[13:17:25.522]                         computeRestarts <- base::computeRestarts
[13:17:25.522]                         grepl <- base::grepl
[13:17:25.522]                         restarts <- computeRestarts(cond)
[13:17:25.522]                         for (restart in restarts) {
[13:17:25.522]                           name <- restart$name
[13:17:25.522]                           if (is.null(name)) 
[13:17:25.522]                             next
[13:17:25.522]                           if (!grepl(pattern, name)) 
[13:17:25.522]                             next
[13:17:25.522]                           invokeRestart(restart)
[13:17:25.522]                           muffled <- TRUE
[13:17:25.522]                           break
[13:17:25.522]                         }
[13:17:25.522]                       }
[13:17:25.522]                     }
[13:17:25.522]                     invisible(muffled)
[13:17:25.522]                   }
[13:17:25.522]                   muffleCondition(cond)
[13:17:25.522]                 })
[13:17:25.522]             }))
[13:17:25.522]             future::FutureResult(value = ...future.value$value, 
[13:17:25.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.522]                   ...future.rng), globalenv = if (FALSE) 
[13:17:25.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:25.522]                     ...future.globalenv.names))
[13:17:25.522]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:25.522]         }, condition = base::local({
[13:17:25.522]             c <- base::c
[13:17:25.522]             inherits <- base::inherits
[13:17:25.522]             invokeRestart <- base::invokeRestart
[13:17:25.522]             length <- base::length
[13:17:25.522]             list <- base::list
[13:17:25.522]             seq.int <- base::seq.int
[13:17:25.522]             signalCondition <- base::signalCondition
[13:17:25.522]             sys.calls <- base::sys.calls
[13:17:25.522]             `[[` <- base::`[[`
[13:17:25.522]             `+` <- base::`+`
[13:17:25.522]             `<<-` <- base::`<<-`
[13:17:25.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:25.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:25.522]                   3L)]
[13:17:25.522]             }
[13:17:25.522]             function(cond) {
[13:17:25.522]                 is_error <- inherits(cond, "error")
[13:17:25.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:25.522]                   NULL)
[13:17:25.522]                 if (is_error) {
[13:17:25.522]                   sessionInformation <- function() {
[13:17:25.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:25.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:25.522]                       search = base::search(), system = base::Sys.info())
[13:17:25.522]                   }
[13:17:25.522]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:25.522]                     cond$call), session = sessionInformation(), 
[13:17:25.522]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:25.522]                   signalCondition(cond)
[13:17:25.522]                 }
[13:17:25.522]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:17:25.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:25.522]                   ...future.conditions[[length(...future.conditions) + 
[13:17:25.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:25.522]                   if (TRUE && !signal) {
[13:17:25.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.522]                     {
[13:17:25.522]                       inherits <- base::inherits
[13:17:25.522]                       invokeRestart <- base::invokeRestart
[13:17:25.522]                       is.null <- base::is.null
[13:17:25.522]                       muffled <- FALSE
[13:17:25.522]                       if (inherits(cond, "message")) {
[13:17:25.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.522]                         if (muffled) 
[13:17:25.522]                           invokeRestart("muffleMessage")
[13:17:25.522]                       }
[13:17:25.522]                       else if (inherits(cond, "warning")) {
[13:17:25.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.522]                         if (muffled) 
[13:17:25.522]                           invokeRestart("muffleWarning")
[13:17:25.522]                       }
[13:17:25.522]                       else if (inherits(cond, "condition")) {
[13:17:25.522]                         if (!is.null(pattern)) {
[13:17:25.522]                           computeRestarts <- base::computeRestarts
[13:17:25.522]                           grepl <- base::grepl
[13:17:25.522]                           restarts <- computeRestarts(cond)
[13:17:25.522]                           for (restart in restarts) {
[13:17:25.522]                             name <- restart$name
[13:17:25.522]                             if (is.null(name)) 
[13:17:25.522]                               next
[13:17:25.522]                             if (!grepl(pattern, name)) 
[13:17:25.522]                               next
[13:17:25.522]                             invokeRestart(restart)
[13:17:25.522]                             muffled <- TRUE
[13:17:25.522]                             break
[13:17:25.522]                           }
[13:17:25.522]                         }
[13:17:25.522]                       }
[13:17:25.522]                       invisible(muffled)
[13:17:25.522]                     }
[13:17:25.522]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.522]                   }
[13:17:25.522]                 }
[13:17:25.522]                 else {
[13:17:25.522]                   if (TRUE) {
[13:17:25.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:25.522]                     {
[13:17:25.522]                       inherits <- base::inherits
[13:17:25.522]                       invokeRestart <- base::invokeRestart
[13:17:25.522]                       is.null <- base::is.null
[13:17:25.522]                       muffled <- FALSE
[13:17:25.522]                       if (inherits(cond, "message")) {
[13:17:25.522]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:25.522]                         if (muffled) 
[13:17:25.522]                           invokeRestart("muffleMessage")
[13:17:25.522]                       }
[13:17:25.522]                       else if (inherits(cond, "warning")) {
[13:17:25.522]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:25.522]                         if (muffled) 
[13:17:25.522]                           invokeRestart("muffleWarning")
[13:17:25.522]                       }
[13:17:25.522]                       else if (inherits(cond, "condition")) {
[13:17:25.522]                         if (!is.null(pattern)) {
[13:17:25.522]                           computeRestarts <- base::computeRestarts
[13:17:25.522]                           grepl <- base::grepl
[13:17:25.522]                           restarts <- computeRestarts(cond)
[13:17:25.522]                           for (restart in restarts) {
[13:17:25.522]                             name <- restart$name
[13:17:25.522]                             if (is.null(name)) 
[13:17:25.522]                               next
[13:17:25.522]                             if (!grepl(pattern, name)) 
[13:17:25.522]                               next
[13:17:25.522]                             invokeRestart(restart)
[13:17:25.522]                             muffled <- TRUE
[13:17:25.522]                             break
[13:17:25.522]                           }
[13:17:25.522]                         }
[13:17:25.522]                       }
[13:17:25.522]                       invisible(muffled)
[13:17:25.522]                     }
[13:17:25.522]                     muffleCondition(cond, pattern = "^muffle")
[13:17:25.522]                   }
[13:17:25.522]                 }
[13:17:25.522]             }
[13:17:25.522]         }))
[13:17:25.522]     }, error = function(ex) {
[13:17:25.522]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:25.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:25.522]                 ...future.rng), started = ...future.startTime, 
[13:17:25.522]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:25.522]             version = "1.8"), class = "FutureResult")
[13:17:25.522]     }, finally = {
[13:17:25.522]         if (!identical(...future.workdir, getwd())) 
[13:17:25.522]             setwd(...future.workdir)
[13:17:25.522]         {
[13:17:25.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:25.522]                 ...future.oldOptions$nwarnings <- NULL
[13:17:25.522]             }
[13:17:25.522]             base::options(...future.oldOptions)
[13:17:25.522]             if (.Platform$OS.type == "windows") {
[13:17:25.522]                 old_names <- names(...future.oldEnvVars)
[13:17:25.522]                 envs <- base::Sys.getenv()
[13:17:25.522]                 names <- names(envs)
[13:17:25.522]                 common <- intersect(names, old_names)
[13:17:25.522]                 added <- setdiff(names, old_names)
[13:17:25.522]                 removed <- setdiff(old_names, names)
[13:17:25.522]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:25.522]                   envs[common]]
[13:17:25.522]                 NAMES <- toupper(changed)
[13:17:25.522]                 args <- list()
[13:17:25.522]                 for (kk in seq_along(NAMES)) {
[13:17:25.522]                   name <- changed[[kk]]
[13:17:25.522]                   NAME <- NAMES[[kk]]
[13:17:25.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.522]                     next
[13:17:25.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.522]                 }
[13:17:25.522]                 NAMES <- toupper(added)
[13:17:25.522]                 for (kk in seq_along(NAMES)) {
[13:17:25.522]                   name <- added[[kk]]
[13:17:25.522]                   NAME <- NAMES[[kk]]
[13:17:25.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.522]                     next
[13:17:25.522]                   args[[name]] <- ""
[13:17:25.522]                 }
[13:17:25.522]                 NAMES <- toupper(removed)
[13:17:25.522]                 for (kk in seq_along(NAMES)) {
[13:17:25.522]                   name <- removed[[kk]]
[13:17:25.522]                   NAME <- NAMES[[kk]]
[13:17:25.522]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:25.522]                     next
[13:17:25.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:25.522]                 }
[13:17:25.522]                 if (length(args) > 0) 
[13:17:25.522]                   base::do.call(base::Sys.setenv, args = args)
[13:17:25.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:25.522]             }
[13:17:25.522]             else {
[13:17:25.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:25.522]             }
[13:17:25.522]             {
[13:17:25.522]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:25.522]                   0L) {
[13:17:25.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:25.522]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:25.522]                   base::options(opts)
[13:17:25.522]                 }
[13:17:25.522]                 {
[13:17:25.522]                   {
[13:17:25.522]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:25.522]                     NULL
[13:17:25.522]                   }
[13:17:25.522]                   options(future.plan = NULL)
[13:17:25.522]                   if (is.na(NA_character_)) 
[13:17:25.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:25.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:25.522]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:17:25.522]                     envir = parent.frame()) 
[13:17:25.522]                   {
[13:17:25.522]                     default_workers <- missing(workers)
[13:17:25.522]                     if (is.function(workers)) 
[13:17:25.522]                       workers <- workers()
[13:17:25.522]                     workers <- structure(as.integer(workers), 
[13:17:25.522]                       class = class(workers))
[13:17:25.522]                     stop_if_not(is.finite(workers), workers >= 
[13:17:25.522]                       1L)
[13:17:25.522]                     if ((workers == 1L && !inherits(workers, 
[13:17:25.522]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:17:25.522]                       if (default_workers) 
[13:17:25.522]                         supportsMulticore(warn = TRUE)
[13:17:25.522]                       return(sequential(..., envir = envir))
[13:17:25.522]                     }
[13:17:25.522]                     oopts <- options(mc.cores = workers)
[13:17:25.522]                     on.exit(options(oopts))
[13:17:25.522]                     future <- MulticoreFuture(..., workers = workers, 
[13:17:25.522]                       envir = envir)
[13:17:25.522]                     if (!future$lazy) 
[13:17:25.522]                       future <- run(future)
[13:17:25.522]                     invisible(future)
[13:17:25.522]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:25.522]                 }
[13:17:25.522]             }
[13:17:25.522]         }
[13:17:25.522]     })
[13:17:25.522]     if (TRUE) {
[13:17:25.522]         base::sink(type = "output", split = FALSE)
[13:17:25.522]         if (TRUE) {
[13:17:25.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:25.522]         }
[13:17:25.522]         else {
[13:17:25.522]             ...future.result["stdout"] <- base::list(NULL)
[13:17:25.522]         }
[13:17:25.522]         base::close(...future.stdout)
[13:17:25.522]         ...future.stdout <- NULL
[13:17:25.522]     }
[13:17:25.522]     ...future.result$conditions <- ...future.conditions
[13:17:25.522]     ...future.result$finished <- base::Sys.time()
[13:17:25.522]     ...future.result
[13:17:25.522] }
[13:17:25.525] assign_globals() ...
[13:17:25.525] List of 5
[13:17:25.525]  $ future.call.arguments    : list()
[13:17:25.525]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:25.525]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[13:17:25.525]  $ ...future.elements_ii    :List of 1
[13:17:25.525]   ..$ : int [1:2] 2 4
[13:17:25.525]  $ ...future.seeds_ii       :List of 1
[13:17:25.525]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[13:17:25.525]  $ ...future.globals.maxSize: NULL
[13:17:25.525]  - attr(*, "where")=List of 5
[13:17:25.525]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:17:25.525]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:17:25.525]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:17:25.525]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:17:25.525]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:17:25.525]  - attr(*, "resolved")= logi FALSE
[13:17:25.525]  - attr(*, "total_size")= num NA
[13:17:25.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:25.525]  - attr(*, "already-done")= logi TRUE
[13:17:25.532] - copied ‘future.call.arguments’ to environment
[13:17:25.532] - copied ‘...future.FUN’ to environment
[13:17:25.532] - copied ‘...future.elements_ii’ to environment
[13:17:25.532] - copied ‘...future.seeds_ii’ to environment
[13:17:25.532] - copied ‘...future.globals.maxSize’ to environment
[13:17:25.532] assign_globals() ... done
[13:17:25.532] requestCore(): workers = 2
[13:17:25.535] MulticoreFuture started
[13:17:25.535] - Launch lazy future ... done
[13:17:25.535] run() for ‘MulticoreFuture’ ... done
[13:17:25.536] Created future:
[13:17:25.536] plan(): Setting new future strategy stack:
[13:17:25.536] List of future strategies:
[13:17:25.536] 1. sequential:
[13:17:25.536]    - args: function (..., envir = parent.frame())
[13:17:25.536]    - tweaked: FALSE
[13:17:25.536]    - call: NULL
[13:17:25.537] plan(): nbrOfWorkers() = 1
[13:17:25.539] plan(): Setting new future strategy stack:
[13:17:25.539] List of future strategies:
[13:17:25.539] 1. multicore:
[13:17:25.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:17:25.539]    - tweaked: FALSE
[13:17:25.539]    - call: plan(strategy)
[13:17:25.544] plan(): nbrOfWorkers() = 2
[13:17:25.536] MulticoreFuture:
[13:17:25.536] Label: ‘future_apply-2’
[13:17:25.536] Expression:
[13:17:25.536] {
[13:17:25.536]     do.call(function(...) {
[13:17:25.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:25.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:25.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:25.536]             on.exit(options(oopts), add = TRUE)
[13:17:25.536]         }
[13:17:25.536]         {
[13:17:25.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:25.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:25.536]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:25.536]                   envir = globalenv(), inherits = FALSE)
[13:17:25.536]                 ...future.FUN(...future.X_jj, ...)
[13:17:25.536]             })
[13:17:25.536]         }
[13:17:25.536]     }, args = future.call.arguments)
[13:17:25.536] }
[13:17:25.536] Lazy evaluation: FALSE
[13:17:25.536] Asynchronous evaluation: TRUE
[13:17:25.536] Local evaluation: TRUE
[13:17:25.536] Environment: R_GlobalEnv
[13:17:25.536] Capture standard output: TRUE
[13:17:25.536] Capture condition classes: <none>
[13:17:25.536] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:25.536] Packages: <none>
[13:17:25.536] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:17:25.536] Resolved: TRUE
[13:17:25.536] Value: <not collected>
[13:17:25.536] Conditions captured: <none>
[13:17:25.536] Early signaling: FALSE
[13:17:25.536] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:25.536] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:25.545] Chunk #2 of 2 ... DONE
[13:17:25.546] Launching 2 futures (chunks) ... DONE
[13:17:25.546] Resolving 2 futures (chunks) ...
[13:17:25.546] resolve() on list ...
[13:17:25.546]  recursive: 0
[13:17:25.546]  length: 2
[13:17:25.546] 
[13:17:25.547] Future #1
[13:17:25.548] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:17:25.548] - nx: 2
[13:17:25.548] - relay: TRUE
[13:17:25.548] - stdout: TRUE
[13:17:25.548] - signal: TRUE
[13:17:25.548] - resignal: FALSE
[13:17:25.549] - force: TRUE
[13:17:25.549] - relayed: [n=2] FALSE, FALSE
[13:17:25.549] - queued futures: [n=2] FALSE, FALSE
[13:17:25.549]  - until=1
[13:17:25.549]  - relaying element #1
[13:17:25.549] - relayed: [n=2] TRUE, FALSE
[13:17:25.550] - queued futures: [n=2] TRUE, FALSE
[13:17:25.550] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:17:25.550]  length: 1 (resolved future 1)
[13:17:25.550] Future #2
[13:17:25.551] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:17:25.551] - nx: 2
[13:17:25.551] - relay: TRUE
[13:17:25.552] - stdout: TRUE
[13:17:25.552] - signal: TRUE
[13:17:25.552] - resignal: FALSE
[13:17:25.552] - force: TRUE
[13:17:25.552] - relayed: [n=2] TRUE, FALSE
[13:17:25.552] - queued futures: [n=2] TRUE, FALSE
[13:17:25.552]  - until=2
[13:17:25.552]  - relaying element #2
[13:17:25.553] - relayed: [n=2] TRUE, TRUE
[13:17:25.553] - queued futures: [n=2] TRUE, TRUE
[13:17:25.553] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:17:25.553]  length: 0 (resolved future 2)
[13:17:25.553] Relaying remaining futures
[13:17:25.553] signalConditionsASAP(NULL, pos=0) ...
[13:17:25.554] - nx: 2
[13:17:25.554] - relay: TRUE
[13:17:25.554] - stdout: TRUE
[13:17:25.554] - signal: TRUE
[13:17:25.554] - resignal: FALSE
[13:17:25.554] - force: TRUE
[13:17:25.554] - relayed: [n=2] TRUE, TRUE
[13:17:25.554] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:25.557] - relayed: [n=2] TRUE, TRUE
[13:17:25.557] - queued futures: [n=2] TRUE, TRUE
[13:17:25.557] signalConditionsASAP(NULL, pos=0) ... done
[13:17:25.558] resolve() on list ... DONE
[13:17:25.558]  - Number of value chunks collected: 2
[13:17:25.558] Resolving 2 futures (chunks) ... DONE
[13:17:25.558] Reducing values from 2 chunks ...
[13:17:25.558]  - Number of values collected after concatenation: 2
[13:17:25.559]  - Number of values expected: 2
[13:17:25.559] Reducing values from 2 chunks ... DONE
[13:17:25.559] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:17:25.559] plan(): Setting new future strategy stack:
[13:17:25.559] List of future strategies:
[13:17:25.559] 1. sequential:
[13:17:25.559]    - args: function (..., envir = parent.frame())
[13:17:25.559]    - tweaked: FALSE
[13:17:25.559]    - call: plan(sequential)
[13:17:25.560] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:17:25.561] plan(): Setting new future strategy stack:
[13:17:25.561] List of future strategies:
[13:17:25.561] 1. multisession:
[13:17:25.561]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:25.561]    - tweaked: FALSE
[13:17:25.561]    - call: plan(strategy)
[13:17:25.562] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:17:25.562] multisession:
[13:17:25.562] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:17:25.562] - tweaked: FALSE
[13:17:25.562] - call: plan(strategy)
[13:17:25.569] getGlobalsAndPackages() ...
[13:17:25.569] Not searching for globals
[13:17:25.570] - globals: [0] <none>
[13:17:25.570] getGlobalsAndPackages() ... DONE
[13:17:25.570] [local output] makeClusterPSOCK() ...
[13:17:25.612] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:17:25.617] [local output] Base port: 11252
[13:17:25.617] [local output] Getting setup options for 2 cluster nodes ...
[13:17:25.617] [local output]  - Node 1 of 2 ...
[13:17:25.618] [local output] localMachine=TRUE => revtunnel=FALSE

[13:17:25.618] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmppqFfKI/worker.rank=1.parallelly.parent=69910.1111620d0f992.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmppqFfKI/worker.rank=1.parallelly.parent=69910.1111620d0f992.pid")'’
[13:17:25.806] - Possible to infer worker's PID: TRUE
[13:17:25.806] [local output] Rscript port: 11252

[13:17:25.806] [local output]  - Node 2 of 2 ...
[13:17:25.807] [local output] localMachine=TRUE => revtunnel=FALSE

[13:17:25.807] [local output] Rscript port: 11252

[13:17:25.807] [local output] Getting setup options for 2 cluster nodes ... done
[13:17:25.808] [local output]  - Parallel setup requested for some PSOCK nodes
[13:17:25.808] [local output] Setting up PSOCK nodes in parallel
[13:17:25.808] List of 36
[13:17:25.808]  $ worker          : chr "localhost"
[13:17:25.808]   ..- attr(*, "localhost")= logi TRUE
[13:17:25.808]  $ master          : chr "localhost"
[13:17:25.808]  $ port            : int 11252
[13:17:25.808]  $ connectTimeout  : num 120
[13:17:25.808]  $ timeout         : num 2592000
[13:17:25.808]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:17:25.808]  $ homogeneous     : logi TRUE
[13:17:25.808]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:17:25.808]  $ rscript_envs    : NULL
[13:17:25.808]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:17:25.808]  $ rscript_startup : NULL
[13:17:25.808]  $ rscript_sh      : chr "sh"
[13:17:25.808]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:17:25.808]  $ methods         : logi TRUE
[13:17:25.808]  $ socketOptions   : chr "no-delay"
[13:17:25.808]  $ useXDR          : logi FALSE
[13:17:25.808]  $ outfile         : chr "/dev/null"
[13:17:25.808]  $ renice          : int NA
[13:17:25.808]  $ rshcmd          : NULL
[13:17:25.808]  $ user            : chr(0) 
[13:17:25.808]  $ revtunnel       : logi FALSE
[13:17:25.808]  $ rshlogfile      : NULL
[13:17:25.808]  $ rshopts         : chr(0) 
[13:17:25.808]  $ rank            : int 1
[13:17:25.808]  $ manual          : logi FALSE
[13:17:25.808]  $ dryrun          : logi FALSE
[13:17:25.808]  $ quiet           : logi FALSE
[13:17:25.808]  $ setup_strategy  : chr "parallel"
[13:17:25.808]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:17:25.808]  $ pidfile         : chr "/tmp/RtmppqFfKI/worker.rank=1.parallelly.parent=69910.1111620d0f992.pid"
[13:17:25.808]  $ rshcmd_label    : NULL
[13:17:25.808]  $ rsh_call        : NULL
[13:17:25.808]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:17:25.808]  $ localMachine    : logi TRUE
[13:17:25.808]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:17:25.808]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:17:25.808]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:17:25.808]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:17:25.808]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:17:25.808]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:17:25.808]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:17:25.808]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:17:25.808]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:17:25.808]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:17:25.808]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:17:25.808]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:17:25.808]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:17:25.808]  $ arguments       :List of 28
[13:17:25.808]   ..$ worker          : chr "localhost"
[13:17:25.808]   ..$ master          : NULL
[13:17:25.808]   ..$ port            : int 11252
[13:17:25.808]   ..$ connectTimeout  : num 120
[13:17:25.808]   ..$ timeout         : num 2592000
[13:17:25.808]   ..$ rscript         : NULL
[13:17:25.808]   ..$ homogeneous     : NULL
[13:17:25.808]   ..$ rscript_args    : NULL
[13:17:25.808]   ..$ rscript_envs    : NULL
[13:17:25.808]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:17:25.808]   ..$ rscript_startup : NULL
[13:17:25.808]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:17:25.808]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:17:25.808]   ..$ methods         : logi TRUE
[13:17:25.808]   ..$ socketOptions   : chr "no-delay"
[13:17:25.808]   ..$ useXDR          : logi FALSE
[13:17:25.808]   ..$ outfile         : chr "/dev/null"
[13:17:25.808]   ..$ renice          : int NA
[13:17:25.808]   ..$ rshcmd          : NULL
[13:17:25.808]   ..$ user            : NULL
[13:17:25.808]   ..$ revtunnel       : logi NA
[13:17:25.808]   ..$ rshlogfile      : NULL
[13:17:25.808]   ..$ rshopts         : NULL
[13:17:25.808]   ..$ rank            : int 1
[13:17:25.808]   ..$ manual          : logi FALSE
[13:17:25.808]   ..$ dryrun          : logi FALSE
[13:17:25.808]   ..$ quiet           : logi FALSE
[13:17:25.808]   ..$ setup_strategy  : chr "parallel"
[13:17:25.808]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:17:25.825] [local output] System call to launch all workers:
[13:17:25.825] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmppqFfKI/worker.rank=1.parallelly.parent=69910.1111620d0f992.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11252 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:17:25.825] [local output] Starting PSOCK main server
[13:17:25.827] [local output] Workers launched
[13:17:25.827] [local output] Waiting for workers to connect back
[13:17:25.827]  - [local output] 0 workers out of 2 ready
[13:17:26.074]  - [local output] 0 workers out of 2 ready
[13:17:26.074]  - [local output] 1 workers out of 2 ready
[13:17:26.075]  - [local output] 2 workers out of 2 ready
[13:17:26.075] [local output] Launching of workers completed
[13:17:26.075] [local output] Collecting session information from workers
[13:17:26.076] [local output]  - Worker #1 of 2
[13:17:26.076] [local output]  - Worker #2 of 2
[13:17:26.076] [local output] makeClusterPSOCK() ... done
[13:17:26.089] Packages needed by the future expression (n = 0): <none>
[13:17:26.089] Packages needed by future strategies (n = 0): <none>
[13:17:26.089] {
[13:17:26.089]     {
[13:17:26.089]         {
[13:17:26.089]             ...future.startTime <- base::Sys.time()
[13:17:26.089]             {
[13:17:26.089]                 {
[13:17:26.089]                   {
[13:17:26.089]                     {
[13:17:26.089]                       base::local({
[13:17:26.089]                         has_future <- base::requireNamespace("future", 
[13:17:26.089]                           quietly = TRUE)
[13:17:26.089]                         if (has_future) {
[13:17:26.089]                           ns <- base::getNamespace("future")
[13:17:26.089]                           version <- ns[[".package"]][["version"]]
[13:17:26.089]                           if (is.null(version)) 
[13:17:26.089]                             version <- utils::packageVersion("future")
[13:17:26.089]                         }
[13:17:26.089]                         else {
[13:17:26.089]                           version <- NULL
[13:17:26.089]                         }
[13:17:26.089]                         if (!has_future || version < "1.8.0") {
[13:17:26.089]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.089]                             "", base::R.version$version.string), 
[13:17:26.089]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:26.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:26.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.089]                               "release", "version")], collapse = " "), 
[13:17:26.089]                             hostname = base::Sys.info()[["nodename"]])
[13:17:26.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.089]                             info)
[13:17:26.089]                           info <- base::paste(info, collapse = "; ")
[13:17:26.089]                           if (!has_future) {
[13:17:26.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.089]                               info)
[13:17:26.089]                           }
[13:17:26.089]                           else {
[13:17:26.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.089]                               info, version)
[13:17:26.089]                           }
[13:17:26.089]                           base::stop(msg)
[13:17:26.089]                         }
[13:17:26.089]                       })
[13:17:26.089]                     }
[13:17:26.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.089]                     base::options(mc.cores = 1L)
[13:17:26.089]                   }
[13:17:26.089]                   options(future.plan = NULL)
[13:17:26.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.089]                 }
[13:17:26.089]                 ...future.workdir <- getwd()
[13:17:26.089]             }
[13:17:26.089]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.089]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.089]         }
[13:17:26.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:17:26.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.089]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.089]             base::names(...future.oldOptions))
[13:17:26.089]     }
[13:17:26.089]     if (FALSE) {
[13:17:26.089]     }
[13:17:26.089]     else {
[13:17:26.089]         if (TRUE) {
[13:17:26.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.089]                 open = "w")
[13:17:26.089]         }
[13:17:26.089]         else {
[13:17:26.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.089]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.089]         }
[13:17:26.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.089]             base::sink(type = "output", split = FALSE)
[13:17:26.089]             base::close(...future.stdout)
[13:17:26.089]         }, add = TRUE)
[13:17:26.089]     }
[13:17:26.089]     ...future.frame <- base::sys.nframe()
[13:17:26.089]     ...future.conditions <- base::list()
[13:17:26.089]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.089]     if (FALSE) {
[13:17:26.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.089]     }
[13:17:26.089]     ...future.result <- base::tryCatch({
[13:17:26.089]         base::withCallingHandlers({
[13:17:26.089]             ...future.value <- base::withVisible(base::local({
[13:17:26.089]                 ...future.makeSendCondition <- local({
[13:17:26.089]                   sendCondition <- NULL
[13:17:26.089]                   function(frame = 1L) {
[13:17:26.089]                     if (is.function(sendCondition)) 
[13:17:26.089]                       return(sendCondition)
[13:17:26.089]                     ns <- getNamespace("parallel")
[13:17:26.089]                     if (exists("sendData", mode = "function", 
[13:17:26.089]                       envir = ns)) {
[13:17:26.089]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.089]                         envir = ns)
[13:17:26.089]                       envir <- sys.frame(frame)
[13:17:26.089]                       master <- NULL
[13:17:26.089]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.089]                         !identical(envir, emptyenv())) {
[13:17:26.089]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.089]                           inherits = FALSE)) {
[13:17:26.089]                           master <- get("master", mode = "list", 
[13:17:26.089]                             envir = envir, inherits = FALSE)
[13:17:26.089]                           if (inherits(master, c("SOCKnode", 
[13:17:26.089]                             "SOCK0node"))) {
[13:17:26.089]                             sendCondition <<- function(cond) {
[13:17:26.089]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.089]                                 success = TRUE)
[13:17:26.089]                               parallel_sendData(master, data)
[13:17:26.089]                             }
[13:17:26.089]                             return(sendCondition)
[13:17:26.089]                           }
[13:17:26.089]                         }
[13:17:26.089]                         frame <- frame + 1L
[13:17:26.089]                         envir <- sys.frame(frame)
[13:17:26.089]                       }
[13:17:26.089]                     }
[13:17:26.089]                     sendCondition <<- function(cond) NULL
[13:17:26.089]                   }
[13:17:26.089]                 })
[13:17:26.089]                 withCallingHandlers({
[13:17:26.089]                   NA
[13:17:26.089]                 }, immediateCondition = function(cond) {
[13:17:26.089]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.089]                   sendCondition(cond)
[13:17:26.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.089]                   {
[13:17:26.089]                     inherits <- base::inherits
[13:17:26.089]                     invokeRestart <- base::invokeRestart
[13:17:26.089]                     is.null <- base::is.null
[13:17:26.089]                     muffled <- FALSE
[13:17:26.089]                     if (inherits(cond, "message")) {
[13:17:26.089]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.089]                       if (muffled) 
[13:17:26.089]                         invokeRestart("muffleMessage")
[13:17:26.089]                     }
[13:17:26.089]                     else if (inherits(cond, "warning")) {
[13:17:26.089]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.089]                       if (muffled) 
[13:17:26.089]                         invokeRestart("muffleWarning")
[13:17:26.089]                     }
[13:17:26.089]                     else if (inherits(cond, "condition")) {
[13:17:26.089]                       if (!is.null(pattern)) {
[13:17:26.089]                         computeRestarts <- base::computeRestarts
[13:17:26.089]                         grepl <- base::grepl
[13:17:26.089]                         restarts <- computeRestarts(cond)
[13:17:26.089]                         for (restart in restarts) {
[13:17:26.089]                           name <- restart$name
[13:17:26.089]                           if (is.null(name)) 
[13:17:26.089]                             next
[13:17:26.089]                           if (!grepl(pattern, name)) 
[13:17:26.089]                             next
[13:17:26.089]                           invokeRestart(restart)
[13:17:26.089]                           muffled <- TRUE
[13:17:26.089]                           break
[13:17:26.089]                         }
[13:17:26.089]                       }
[13:17:26.089]                     }
[13:17:26.089]                     invisible(muffled)
[13:17:26.089]                   }
[13:17:26.089]                   muffleCondition(cond)
[13:17:26.089]                 })
[13:17:26.089]             }))
[13:17:26.089]             future::FutureResult(value = ...future.value$value, 
[13:17:26.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.089]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.089]                     ...future.globalenv.names))
[13:17:26.089]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.089]         }, condition = base::local({
[13:17:26.089]             c <- base::c
[13:17:26.089]             inherits <- base::inherits
[13:17:26.089]             invokeRestart <- base::invokeRestart
[13:17:26.089]             length <- base::length
[13:17:26.089]             list <- base::list
[13:17:26.089]             seq.int <- base::seq.int
[13:17:26.089]             signalCondition <- base::signalCondition
[13:17:26.089]             sys.calls <- base::sys.calls
[13:17:26.089]             `[[` <- base::`[[`
[13:17:26.089]             `+` <- base::`+`
[13:17:26.089]             `<<-` <- base::`<<-`
[13:17:26.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.089]                   3L)]
[13:17:26.089]             }
[13:17:26.089]             function(cond) {
[13:17:26.089]                 is_error <- inherits(cond, "error")
[13:17:26.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.089]                   NULL)
[13:17:26.089]                 if (is_error) {
[13:17:26.089]                   sessionInformation <- function() {
[13:17:26.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.089]                       search = base::search(), system = base::Sys.info())
[13:17:26.089]                   }
[13:17:26.089]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.089]                     cond$call), session = sessionInformation(), 
[13:17:26.089]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.089]                   signalCondition(cond)
[13:17:26.089]                 }
[13:17:26.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.089]                 "immediateCondition"))) {
[13:17:26.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.089]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.089]                   if (TRUE && !signal) {
[13:17:26.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.089]                     {
[13:17:26.089]                       inherits <- base::inherits
[13:17:26.089]                       invokeRestart <- base::invokeRestart
[13:17:26.089]                       is.null <- base::is.null
[13:17:26.089]                       muffled <- FALSE
[13:17:26.089]                       if (inherits(cond, "message")) {
[13:17:26.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.089]                         if (muffled) 
[13:17:26.089]                           invokeRestart("muffleMessage")
[13:17:26.089]                       }
[13:17:26.089]                       else if (inherits(cond, "warning")) {
[13:17:26.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.089]                         if (muffled) 
[13:17:26.089]                           invokeRestart("muffleWarning")
[13:17:26.089]                       }
[13:17:26.089]                       else if (inherits(cond, "condition")) {
[13:17:26.089]                         if (!is.null(pattern)) {
[13:17:26.089]                           computeRestarts <- base::computeRestarts
[13:17:26.089]                           grepl <- base::grepl
[13:17:26.089]                           restarts <- computeRestarts(cond)
[13:17:26.089]                           for (restart in restarts) {
[13:17:26.089]                             name <- restart$name
[13:17:26.089]                             if (is.null(name)) 
[13:17:26.089]                               next
[13:17:26.089]                             if (!grepl(pattern, name)) 
[13:17:26.089]                               next
[13:17:26.089]                             invokeRestart(restart)
[13:17:26.089]                             muffled <- TRUE
[13:17:26.089]                             break
[13:17:26.089]                           }
[13:17:26.089]                         }
[13:17:26.089]                       }
[13:17:26.089]                       invisible(muffled)
[13:17:26.089]                     }
[13:17:26.089]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.089]                   }
[13:17:26.089]                 }
[13:17:26.089]                 else {
[13:17:26.089]                   if (TRUE) {
[13:17:26.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.089]                     {
[13:17:26.089]                       inherits <- base::inherits
[13:17:26.089]                       invokeRestart <- base::invokeRestart
[13:17:26.089]                       is.null <- base::is.null
[13:17:26.089]                       muffled <- FALSE
[13:17:26.089]                       if (inherits(cond, "message")) {
[13:17:26.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.089]                         if (muffled) 
[13:17:26.089]                           invokeRestart("muffleMessage")
[13:17:26.089]                       }
[13:17:26.089]                       else if (inherits(cond, "warning")) {
[13:17:26.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.089]                         if (muffled) 
[13:17:26.089]                           invokeRestart("muffleWarning")
[13:17:26.089]                       }
[13:17:26.089]                       else if (inherits(cond, "condition")) {
[13:17:26.089]                         if (!is.null(pattern)) {
[13:17:26.089]                           computeRestarts <- base::computeRestarts
[13:17:26.089]                           grepl <- base::grepl
[13:17:26.089]                           restarts <- computeRestarts(cond)
[13:17:26.089]                           for (restart in restarts) {
[13:17:26.089]                             name <- restart$name
[13:17:26.089]                             if (is.null(name)) 
[13:17:26.089]                               next
[13:17:26.089]                             if (!grepl(pattern, name)) 
[13:17:26.089]                               next
[13:17:26.089]                             invokeRestart(restart)
[13:17:26.089]                             muffled <- TRUE
[13:17:26.089]                             break
[13:17:26.089]                           }
[13:17:26.089]                         }
[13:17:26.089]                       }
[13:17:26.089]                       invisible(muffled)
[13:17:26.089]                     }
[13:17:26.089]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.089]                   }
[13:17:26.089]                 }
[13:17:26.089]             }
[13:17:26.089]         }))
[13:17:26.089]     }, error = function(ex) {
[13:17:26.089]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.089]                 ...future.rng), started = ...future.startTime, 
[13:17:26.089]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.089]             version = "1.8"), class = "FutureResult")
[13:17:26.089]     }, finally = {
[13:17:26.089]         if (!identical(...future.workdir, getwd())) 
[13:17:26.089]             setwd(...future.workdir)
[13:17:26.089]         {
[13:17:26.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.089]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.089]             }
[13:17:26.089]             base::options(...future.oldOptions)
[13:17:26.089]             if (.Platform$OS.type == "windows") {
[13:17:26.089]                 old_names <- names(...future.oldEnvVars)
[13:17:26.089]                 envs <- base::Sys.getenv()
[13:17:26.089]                 names <- names(envs)
[13:17:26.089]                 common <- intersect(names, old_names)
[13:17:26.089]                 added <- setdiff(names, old_names)
[13:17:26.089]                 removed <- setdiff(old_names, names)
[13:17:26.089]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.089]                   envs[common]]
[13:17:26.089]                 NAMES <- toupper(changed)
[13:17:26.089]                 args <- list()
[13:17:26.089]                 for (kk in seq_along(NAMES)) {
[13:17:26.089]                   name <- changed[[kk]]
[13:17:26.089]                   NAME <- NAMES[[kk]]
[13:17:26.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.089]                     next
[13:17:26.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.089]                 }
[13:17:26.089]                 NAMES <- toupper(added)
[13:17:26.089]                 for (kk in seq_along(NAMES)) {
[13:17:26.089]                   name <- added[[kk]]
[13:17:26.089]                   NAME <- NAMES[[kk]]
[13:17:26.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.089]                     next
[13:17:26.089]                   args[[name]] <- ""
[13:17:26.089]                 }
[13:17:26.089]                 NAMES <- toupper(removed)
[13:17:26.089]                 for (kk in seq_along(NAMES)) {
[13:17:26.089]                   name <- removed[[kk]]
[13:17:26.089]                   NAME <- NAMES[[kk]]
[13:17:26.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.089]                     next
[13:17:26.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.089]                 }
[13:17:26.089]                 if (length(args) > 0) 
[13:17:26.089]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.089]             }
[13:17:26.089]             else {
[13:17:26.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.089]             }
[13:17:26.089]             {
[13:17:26.089]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.089]                   0L) {
[13:17:26.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.089]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.089]                   base::options(opts)
[13:17:26.089]                 }
[13:17:26.089]                 {
[13:17:26.089]                   {
[13:17:26.089]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.089]                     NULL
[13:17:26.089]                   }
[13:17:26.089]                   options(future.plan = NULL)
[13:17:26.089]                   if (is.na(NA_character_)) 
[13:17:26.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.089]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.089]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.089]                     envir = parent.frame()) 
[13:17:26.089]                   {
[13:17:26.089]                     if (is.function(workers)) 
[13:17:26.089]                       workers <- workers()
[13:17:26.089]                     workers <- structure(as.integer(workers), 
[13:17:26.089]                       class = class(workers))
[13:17:26.089]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.089]                       workers >= 1)
[13:17:26.089]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.089]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.089]                     }
[13:17:26.089]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.089]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.089]                       envir = envir)
[13:17:26.089]                     if (!future$lazy) 
[13:17:26.089]                       future <- run(future)
[13:17:26.089]                     invisible(future)
[13:17:26.089]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.089]                 }
[13:17:26.089]             }
[13:17:26.089]         }
[13:17:26.089]     })
[13:17:26.089]     if (TRUE) {
[13:17:26.089]         base::sink(type = "output", split = FALSE)
[13:17:26.089]         if (TRUE) {
[13:17:26.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.089]         }
[13:17:26.089]         else {
[13:17:26.089]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.089]         }
[13:17:26.089]         base::close(...future.stdout)
[13:17:26.089]         ...future.stdout <- NULL
[13:17:26.089]     }
[13:17:26.089]     ...future.result$conditions <- ...future.conditions
[13:17:26.089]     ...future.result$finished <- base::Sys.time()
[13:17:26.089]     ...future.result
[13:17:26.089] }
[13:17:26.161] MultisessionFuture started
[13:17:26.162] result() for ClusterFuture ...
[13:17:26.163] receiveMessageFromWorker() for ClusterFuture ...
[13:17:26.163] - Validating connection of MultisessionFuture
[13:17:26.195] - received message: FutureResult
[13:17:26.195] - Received FutureResult
[13:17:26.196] - Erased future from FutureRegistry
[13:17:26.196] result() for ClusterFuture ...
[13:17:26.196] - result already collected: FutureResult
[13:17:26.196] result() for ClusterFuture ... done
[13:17:26.196] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:26.196] result() for ClusterFuture ... done
[13:17:26.196] result() for ClusterFuture ...
[13:17:26.196] - result already collected: FutureResult
[13:17:26.197] result() for ClusterFuture ... done
[13:17:26.197] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:17:26.200] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[13:17:26.201] getGlobalsAndPackagesXApply() ...
[13:17:26.201]  - future.globals: TRUE
[13:17:26.201] getGlobalsAndPackages() ...
[13:17:26.202] Searching for globals...
[13:17:26.246] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:17:26.246] Searching for globals ... DONE
[13:17:26.246] Resolving globals: FALSE
[13:17:26.248] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:17:26.248] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:17:26.248] - globals: [1] ‘FUN’
[13:17:26.248] 
[13:17:26.248] getGlobalsAndPackages() ... DONE
[13:17:26.248]  - globals found/used: [n=1] ‘FUN’
[13:17:26.249]  - needed namespaces: [n=0] 
[13:17:26.249] Finding globals ... DONE
[13:17:26.249]  - use_args: TRUE
[13:17:26.249]  - Getting '...' globals ...
[13:17:26.249] resolve() on list ...
[13:17:26.249]  recursive: 0
[13:17:26.249]  length: 1
[13:17:26.249]  elements: ‘...’
[13:17:26.250]  length: 0 (resolved future 1)
[13:17:26.250] resolve() on list ... DONE
[13:17:26.250]    - '...' content: [n=0] 
[13:17:26.250] List of 1
[13:17:26.250]  $ ...: list()
[13:17:26.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.250]  - attr(*, "where")=List of 1
[13:17:26.250]   ..$ ...:<environment: 0x5647bc0a5010> 
[13:17:26.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.250]  - attr(*, "resolved")= logi TRUE
[13:17:26.250]  - attr(*, "total_size")= num NA
[13:17:26.252]  - Getting '...' globals ... DONE
[13:17:26.252] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:26.253] List of 2
[13:17:26.253]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:26.253]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:26.253]  $ ...          : list()
[13:17:26.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.253]  - attr(*, "where")=List of 2
[13:17:26.253]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:26.253]   ..$ ...          :<environment: 0x5647bc0a5010> 
[13:17:26.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.253]  - attr(*, "resolved")= logi FALSE
[13:17:26.253]  - attr(*, "total_size")= num 354224
[13:17:26.255] Packages to be attached in all futures: [n=0] 
[13:17:26.255] getGlobalsAndPackagesXApply() ... DONE
[13:17:26.259] future_lapply() ...
[13:17:26.293] Number of chunks: 2
[13:17:26.294] getGlobalsAndPackagesXApply() ...
[13:17:26.294]  - future.globals: <name-value list> with names ‘list()’
[13:17:26.294]  - use_args: TRUE
[13:17:26.294] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:26.294] List of 2
[13:17:26.294]  $ ...          : list()
[13:17:26.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.294]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:26.294]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:26.294]  - attr(*, "where")=List of 2
[13:17:26.294]   ..$ ...          :<environment: 0x5647bc0a5010> 
[13:17:26.294]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:26.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.294]  - attr(*, "resolved")= logi FALSE
[13:17:26.294]  - attr(*, "total_size")= num NA
[13:17:26.298] Packages to be attached in all futures: [n=0] 
[13:17:26.298] getGlobalsAndPackagesXApply() ... DONE
[13:17:26.298] Number of futures (= number of chunks): 2
[13:17:26.298] Launching 2 futures (chunks) ...
[13:17:26.298] Chunk #1 of 2 ...
[13:17:26.298]  - seeds: <none>
[13:17:26.298] getGlobalsAndPackages() ...
[13:17:26.298] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.299] Resolving globals: FALSE
[13:17:26.299] Tweak future expression to call with '...' arguments ...
[13:17:26.299] {
[13:17:26.299]     do.call(function(...) {
[13:17:26.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.299]             on.exit(options(oopts), add = TRUE)
[13:17:26.299]         }
[13:17:26.299]         {
[13:17:26.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.299]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.299]             })
[13:17:26.299]         }
[13:17:26.299]     }, args = future.call.arguments)
[13:17:26.299] }
[13:17:26.299] Tweak future expression to call with '...' arguments ... DONE
[13:17:26.299] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.300] 
[13:17:26.300] getGlobalsAndPackages() ... DONE
[13:17:26.300] run() for ‘Future’ ...
[13:17:26.300] - state: ‘created’
[13:17:26.300] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:26.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:26.316]   - Field: ‘node’
[13:17:26.316]   - Field: ‘label’
[13:17:26.316]   - Field: ‘local’
[13:17:26.316]   - Field: ‘owner’
[13:17:26.316]   - Field: ‘envir’
[13:17:26.316]   - Field: ‘workers’
[13:17:26.316]   - Field: ‘packages’
[13:17:26.316]   - Field: ‘gc’
[13:17:26.316]   - Field: ‘conditions’
[13:17:26.316]   - Field: ‘persistent’
[13:17:26.317]   - Field: ‘expr’
[13:17:26.317]   - Field: ‘uuid’
[13:17:26.317]   - Field: ‘seed’
[13:17:26.317]   - Field: ‘version’
[13:17:26.317]   - Field: ‘result’
[13:17:26.317]   - Field: ‘asynchronous’
[13:17:26.317]   - Field: ‘calls’
[13:17:26.317]   - Field: ‘globals’
[13:17:26.317]   - Field: ‘stdout’
[13:17:26.317]   - Field: ‘earlySignal’
[13:17:26.317]   - Field: ‘lazy’
[13:17:26.318]   - Field: ‘state’
[13:17:26.318] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:26.318] - Launch lazy future ...
[13:17:26.318] Packages needed by the future expression (n = 0): <none>
[13:17:26.318] Packages needed by future strategies (n = 0): <none>
[13:17:26.319] {
[13:17:26.319]     {
[13:17:26.319]         {
[13:17:26.319]             ...future.startTime <- base::Sys.time()
[13:17:26.319]             {
[13:17:26.319]                 {
[13:17:26.319]                   {
[13:17:26.319]                     {
[13:17:26.319]                       base::local({
[13:17:26.319]                         has_future <- base::requireNamespace("future", 
[13:17:26.319]                           quietly = TRUE)
[13:17:26.319]                         if (has_future) {
[13:17:26.319]                           ns <- base::getNamespace("future")
[13:17:26.319]                           version <- ns[[".package"]][["version"]]
[13:17:26.319]                           if (is.null(version)) 
[13:17:26.319]                             version <- utils::packageVersion("future")
[13:17:26.319]                         }
[13:17:26.319]                         else {
[13:17:26.319]                           version <- NULL
[13:17:26.319]                         }
[13:17:26.319]                         if (!has_future || version < "1.8.0") {
[13:17:26.319]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.319]                             "", base::R.version$version.string), 
[13:17:26.319]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:26.319]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:26.319]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.319]                               "release", "version")], collapse = " "), 
[13:17:26.319]                             hostname = base::Sys.info()[["nodename"]])
[13:17:26.319]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.319]                             info)
[13:17:26.319]                           info <- base::paste(info, collapse = "; ")
[13:17:26.319]                           if (!has_future) {
[13:17:26.319]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.319]                               info)
[13:17:26.319]                           }
[13:17:26.319]                           else {
[13:17:26.319]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.319]                               info, version)
[13:17:26.319]                           }
[13:17:26.319]                           base::stop(msg)
[13:17:26.319]                         }
[13:17:26.319]                       })
[13:17:26.319]                     }
[13:17:26.319]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.319]                     base::options(mc.cores = 1L)
[13:17:26.319]                   }
[13:17:26.319]                   options(future.plan = NULL)
[13:17:26.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.319]                 }
[13:17:26.319]                 ...future.workdir <- getwd()
[13:17:26.319]             }
[13:17:26.319]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.319]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.319]         }
[13:17:26.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.319]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:26.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.319]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.319]             base::names(...future.oldOptions))
[13:17:26.319]     }
[13:17:26.319]     if (FALSE) {
[13:17:26.319]     }
[13:17:26.319]     else {
[13:17:26.319]         if (TRUE) {
[13:17:26.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.319]                 open = "w")
[13:17:26.319]         }
[13:17:26.319]         else {
[13:17:26.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.319]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.319]         }
[13:17:26.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.319]             base::sink(type = "output", split = FALSE)
[13:17:26.319]             base::close(...future.stdout)
[13:17:26.319]         }, add = TRUE)
[13:17:26.319]     }
[13:17:26.319]     ...future.frame <- base::sys.nframe()
[13:17:26.319]     ...future.conditions <- base::list()
[13:17:26.319]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.319]     if (FALSE) {
[13:17:26.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.319]     }
[13:17:26.319]     ...future.result <- base::tryCatch({
[13:17:26.319]         base::withCallingHandlers({
[13:17:26.319]             ...future.value <- base::withVisible(base::local({
[13:17:26.319]                 ...future.makeSendCondition <- local({
[13:17:26.319]                   sendCondition <- NULL
[13:17:26.319]                   function(frame = 1L) {
[13:17:26.319]                     if (is.function(sendCondition)) 
[13:17:26.319]                       return(sendCondition)
[13:17:26.319]                     ns <- getNamespace("parallel")
[13:17:26.319]                     if (exists("sendData", mode = "function", 
[13:17:26.319]                       envir = ns)) {
[13:17:26.319]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.319]                         envir = ns)
[13:17:26.319]                       envir <- sys.frame(frame)
[13:17:26.319]                       master <- NULL
[13:17:26.319]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.319]                         !identical(envir, emptyenv())) {
[13:17:26.319]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.319]                           inherits = FALSE)) {
[13:17:26.319]                           master <- get("master", mode = "list", 
[13:17:26.319]                             envir = envir, inherits = FALSE)
[13:17:26.319]                           if (inherits(master, c("SOCKnode", 
[13:17:26.319]                             "SOCK0node"))) {
[13:17:26.319]                             sendCondition <<- function(cond) {
[13:17:26.319]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.319]                                 success = TRUE)
[13:17:26.319]                               parallel_sendData(master, data)
[13:17:26.319]                             }
[13:17:26.319]                             return(sendCondition)
[13:17:26.319]                           }
[13:17:26.319]                         }
[13:17:26.319]                         frame <- frame + 1L
[13:17:26.319]                         envir <- sys.frame(frame)
[13:17:26.319]                       }
[13:17:26.319]                     }
[13:17:26.319]                     sendCondition <<- function(cond) NULL
[13:17:26.319]                   }
[13:17:26.319]                 })
[13:17:26.319]                 withCallingHandlers({
[13:17:26.319]                   {
[13:17:26.319]                     do.call(function(...) {
[13:17:26.319]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.319]                       if (!identical(...future.globals.maxSize.org, 
[13:17:26.319]                         ...future.globals.maxSize)) {
[13:17:26.319]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.319]                         on.exit(options(oopts), add = TRUE)
[13:17:26.319]                       }
[13:17:26.319]                       {
[13:17:26.319]                         lapply(seq_along(...future.elements_ii), 
[13:17:26.319]                           FUN = function(jj) {
[13:17:26.319]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.319]                             ...future.FUN(...future.X_jj, ...)
[13:17:26.319]                           })
[13:17:26.319]                       }
[13:17:26.319]                     }, args = future.call.arguments)
[13:17:26.319]                   }
[13:17:26.319]                 }, immediateCondition = function(cond) {
[13:17:26.319]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.319]                   sendCondition(cond)
[13:17:26.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.319]                   {
[13:17:26.319]                     inherits <- base::inherits
[13:17:26.319]                     invokeRestart <- base::invokeRestart
[13:17:26.319]                     is.null <- base::is.null
[13:17:26.319]                     muffled <- FALSE
[13:17:26.319]                     if (inherits(cond, "message")) {
[13:17:26.319]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.319]                       if (muffled) 
[13:17:26.319]                         invokeRestart("muffleMessage")
[13:17:26.319]                     }
[13:17:26.319]                     else if (inherits(cond, "warning")) {
[13:17:26.319]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.319]                       if (muffled) 
[13:17:26.319]                         invokeRestart("muffleWarning")
[13:17:26.319]                     }
[13:17:26.319]                     else if (inherits(cond, "condition")) {
[13:17:26.319]                       if (!is.null(pattern)) {
[13:17:26.319]                         computeRestarts <- base::computeRestarts
[13:17:26.319]                         grepl <- base::grepl
[13:17:26.319]                         restarts <- computeRestarts(cond)
[13:17:26.319]                         for (restart in restarts) {
[13:17:26.319]                           name <- restart$name
[13:17:26.319]                           if (is.null(name)) 
[13:17:26.319]                             next
[13:17:26.319]                           if (!grepl(pattern, name)) 
[13:17:26.319]                             next
[13:17:26.319]                           invokeRestart(restart)
[13:17:26.319]                           muffled <- TRUE
[13:17:26.319]                           break
[13:17:26.319]                         }
[13:17:26.319]                       }
[13:17:26.319]                     }
[13:17:26.319]                     invisible(muffled)
[13:17:26.319]                   }
[13:17:26.319]                   muffleCondition(cond)
[13:17:26.319]                 })
[13:17:26.319]             }))
[13:17:26.319]             future::FutureResult(value = ...future.value$value, 
[13:17:26.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.319]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.319]                     ...future.globalenv.names))
[13:17:26.319]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.319]         }, condition = base::local({
[13:17:26.319]             c <- base::c
[13:17:26.319]             inherits <- base::inherits
[13:17:26.319]             invokeRestart <- base::invokeRestart
[13:17:26.319]             length <- base::length
[13:17:26.319]             list <- base::list
[13:17:26.319]             seq.int <- base::seq.int
[13:17:26.319]             signalCondition <- base::signalCondition
[13:17:26.319]             sys.calls <- base::sys.calls
[13:17:26.319]             `[[` <- base::`[[`
[13:17:26.319]             `+` <- base::`+`
[13:17:26.319]             `<<-` <- base::`<<-`
[13:17:26.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.319]                   3L)]
[13:17:26.319]             }
[13:17:26.319]             function(cond) {
[13:17:26.319]                 is_error <- inherits(cond, "error")
[13:17:26.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.319]                   NULL)
[13:17:26.319]                 if (is_error) {
[13:17:26.319]                   sessionInformation <- function() {
[13:17:26.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.319]                       search = base::search(), system = base::Sys.info())
[13:17:26.319]                   }
[13:17:26.319]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.319]                     cond$call), session = sessionInformation(), 
[13:17:26.319]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.319]                   signalCondition(cond)
[13:17:26.319]                 }
[13:17:26.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.319]                 "immediateCondition"))) {
[13:17:26.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.319]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.319]                   if (TRUE && !signal) {
[13:17:26.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.319]                     {
[13:17:26.319]                       inherits <- base::inherits
[13:17:26.319]                       invokeRestart <- base::invokeRestart
[13:17:26.319]                       is.null <- base::is.null
[13:17:26.319]                       muffled <- FALSE
[13:17:26.319]                       if (inherits(cond, "message")) {
[13:17:26.319]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.319]                         if (muffled) 
[13:17:26.319]                           invokeRestart("muffleMessage")
[13:17:26.319]                       }
[13:17:26.319]                       else if (inherits(cond, "warning")) {
[13:17:26.319]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.319]                         if (muffled) 
[13:17:26.319]                           invokeRestart("muffleWarning")
[13:17:26.319]                       }
[13:17:26.319]                       else if (inherits(cond, "condition")) {
[13:17:26.319]                         if (!is.null(pattern)) {
[13:17:26.319]                           computeRestarts <- base::computeRestarts
[13:17:26.319]                           grepl <- base::grepl
[13:17:26.319]                           restarts <- computeRestarts(cond)
[13:17:26.319]                           for (restart in restarts) {
[13:17:26.319]                             name <- restart$name
[13:17:26.319]                             if (is.null(name)) 
[13:17:26.319]                               next
[13:17:26.319]                             if (!grepl(pattern, name)) 
[13:17:26.319]                               next
[13:17:26.319]                             invokeRestart(restart)
[13:17:26.319]                             muffled <- TRUE
[13:17:26.319]                             break
[13:17:26.319]                           }
[13:17:26.319]                         }
[13:17:26.319]                       }
[13:17:26.319]                       invisible(muffled)
[13:17:26.319]                     }
[13:17:26.319]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.319]                   }
[13:17:26.319]                 }
[13:17:26.319]                 else {
[13:17:26.319]                   if (TRUE) {
[13:17:26.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.319]                     {
[13:17:26.319]                       inherits <- base::inherits
[13:17:26.319]                       invokeRestart <- base::invokeRestart
[13:17:26.319]                       is.null <- base::is.null
[13:17:26.319]                       muffled <- FALSE
[13:17:26.319]                       if (inherits(cond, "message")) {
[13:17:26.319]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.319]                         if (muffled) 
[13:17:26.319]                           invokeRestart("muffleMessage")
[13:17:26.319]                       }
[13:17:26.319]                       else if (inherits(cond, "warning")) {
[13:17:26.319]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.319]                         if (muffled) 
[13:17:26.319]                           invokeRestart("muffleWarning")
[13:17:26.319]                       }
[13:17:26.319]                       else if (inherits(cond, "condition")) {
[13:17:26.319]                         if (!is.null(pattern)) {
[13:17:26.319]                           computeRestarts <- base::computeRestarts
[13:17:26.319]                           grepl <- base::grepl
[13:17:26.319]                           restarts <- computeRestarts(cond)
[13:17:26.319]                           for (restart in restarts) {
[13:17:26.319]                             name <- restart$name
[13:17:26.319]                             if (is.null(name)) 
[13:17:26.319]                               next
[13:17:26.319]                             if (!grepl(pattern, name)) 
[13:17:26.319]                               next
[13:17:26.319]                             invokeRestart(restart)
[13:17:26.319]                             muffled <- TRUE
[13:17:26.319]                             break
[13:17:26.319]                           }
[13:17:26.319]                         }
[13:17:26.319]                       }
[13:17:26.319]                       invisible(muffled)
[13:17:26.319]                     }
[13:17:26.319]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.319]                   }
[13:17:26.319]                 }
[13:17:26.319]             }
[13:17:26.319]         }))
[13:17:26.319]     }, error = function(ex) {
[13:17:26.319]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.319]                 ...future.rng), started = ...future.startTime, 
[13:17:26.319]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.319]             version = "1.8"), class = "FutureResult")
[13:17:26.319]     }, finally = {
[13:17:26.319]         if (!identical(...future.workdir, getwd())) 
[13:17:26.319]             setwd(...future.workdir)
[13:17:26.319]         {
[13:17:26.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.319]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.319]             }
[13:17:26.319]             base::options(...future.oldOptions)
[13:17:26.319]             if (.Platform$OS.type == "windows") {
[13:17:26.319]                 old_names <- names(...future.oldEnvVars)
[13:17:26.319]                 envs <- base::Sys.getenv()
[13:17:26.319]                 names <- names(envs)
[13:17:26.319]                 common <- intersect(names, old_names)
[13:17:26.319]                 added <- setdiff(names, old_names)
[13:17:26.319]                 removed <- setdiff(old_names, names)
[13:17:26.319]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.319]                   envs[common]]
[13:17:26.319]                 NAMES <- toupper(changed)
[13:17:26.319]                 args <- list()
[13:17:26.319]                 for (kk in seq_along(NAMES)) {
[13:17:26.319]                   name <- changed[[kk]]
[13:17:26.319]                   NAME <- NAMES[[kk]]
[13:17:26.319]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.319]                     next
[13:17:26.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.319]                 }
[13:17:26.319]                 NAMES <- toupper(added)
[13:17:26.319]                 for (kk in seq_along(NAMES)) {
[13:17:26.319]                   name <- added[[kk]]
[13:17:26.319]                   NAME <- NAMES[[kk]]
[13:17:26.319]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.319]                     next
[13:17:26.319]                   args[[name]] <- ""
[13:17:26.319]                 }
[13:17:26.319]                 NAMES <- toupper(removed)
[13:17:26.319]                 for (kk in seq_along(NAMES)) {
[13:17:26.319]                   name <- removed[[kk]]
[13:17:26.319]                   NAME <- NAMES[[kk]]
[13:17:26.319]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.319]                     next
[13:17:26.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.319]                 }
[13:17:26.319]                 if (length(args) > 0) 
[13:17:26.319]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.319]             }
[13:17:26.319]             else {
[13:17:26.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.319]             }
[13:17:26.319]             {
[13:17:26.319]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.319]                   0L) {
[13:17:26.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.319]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.319]                   base::options(opts)
[13:17:26.319]                 }
[13:17:26.319]                 {
[13:17:26.319]                   {
[13:17:26.319]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.319]                     NULL
[13:17:26.319]                   }
[13:17:26.319]                   options(future.plan = NULL)
[13:17:26.319]                   if (is.na(NA_character_)) 
[13:17:26.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.319]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.319]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.319]                     envir = parent.frame()) 
[13:17:26.319]                   {
[13:17:26.319]                     if (is.function(workers)) 
[13:17:26.319]                       workers <- workers()
[13:17:26.319]                     workers <- structure(as.integer(workers), 
[13:17:26.319]                       class = class(workers))
[13:17:26.319]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.319]                       workers >= 1)
[13:17:26.319]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.319]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.319]                     }
[13:17:26.319]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.319]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.319]                       envir = envir)
[13:17:26.319]                     if (!future$lazy) 
[13:17:26.319]                       future <- run(future)
[13:17:26.319]                     invisible(future)
[13:17:26.319]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.319]                 }
[13:17:26.319]             }
[13:17:26.319]         }
[13:17:26.319]     })
[13:17:26.319]     if (TRUE) {
[13:17:26.319]         base::sink(type = "output", split = FALSE)
[13:17:26.319]         if (TRUE) {
[13:17:26.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.319]         }
[13:17:26.319]         else {
[13:17:26.319]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.319]         }
[13:17:26.319]         base::close(...future.stdout)
[13:17:26.319]         ...future.stdout <- NULL
[13:17:26.319]     }
[13:17:26.319]     ...future.result$conditions <- ...future.conditions
[13:17:26.319]     ...future.result$finished <- base::Sys.time()
[13:17:26.319]     ...future.result
[13:17:26.319] }
[13:17:26.322] Exporting 5 global objects (346.00 KiB) to cluster node #1 ...
[13:17:26.322] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:26.323] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.323] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[13:17:26.365] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[13:17:26.365] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:17:26.366] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:17:26.366] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:26.366] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.366] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:26.367] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.367] Exporting 5 global objects (346.00 KiB) to cluster node #1 ... DONE
[13:17:26.367] MultisessionFuture started
[13:17:26.368] - Launch lazy future ... done
[13:17:26.368] run() for ‘MultisessionFuture’ ... done
[13:17:26.368] Created future:
[13:17:26.368] MultisessionFuture:
[13:17:26.368] Label: ‘future_apply-1’
[13:17:26.368] Expression:
[13:17:26.368] {
[13:17:26.368]     do.call(function(...) {
[13:17:26.368]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.368]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.368]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.368]             on.exit(options(oopts), add = TRUE)
[13:17:26.368]         }
[13:17:26.368]         {
[13:17:26.368]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.368]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.368]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.368]             })
[13:17:26.368]         }
[13:17:26.368]     }, args = future.call.arguments)
[13:17:26.368] }
[13:17:26.368] Lazy evaluation: FALSE
[13:17:26.368] Asynchronous evaluation: TRUE
[13:17:26.368] Local evaluation: TRUE
[13:17:26.368] Environment: R_GlobalEnv
[13:17:26.368] Capture standard output: TRUE
[13:17:26.368] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:26.368] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:26.368] Packages: <none>
[13:17:26.368] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:26.368] Resolved: FALSE
[13:17:26.368] Value: <not collected>
[13:17:26.368] Conditions captured: <none>
[13:17:26.368] Early signaling: FALSE
[13:17:26.368] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:26.368] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.380] Chunk #1 of 2 ... DONE
[13:17:26.380] Chunk #2 of 2 ...
[13:17:26.380]  - seeds: <none>
[13:17:26.380] getGlobalsAndPackages() ...
[13:17:26.380] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.381] Resolving globals: FALSE
[13:17:26.381] Tweak future expression to call with '...' arguments ...
[13:17:26.381] {
[13:17:26.381]     do.call(function(...) {
[13:17:26.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.381]             on.exit(options(oopts), add = TRUE)
[13:17:26.381]         }
[13:17:26.381]         {
[13:17:26.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.381]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.381]             })
[13:17:26.381]         }
[13:17:26.381]     }, args = future.call.arguments)
[13:17:26.381] }
[13:17:26.381] Tweak future expression to call with '...' arguments ... DONE
[13:17:26.382] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.382] 
[13:17:26.382] getGlobalsAndPackages() ... DONE
[13:17:26.382] run() for ‘Future’ ...
[13:17:26.382] - state: ‘created’
[13:17:26.382] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:26.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:26.398]   - Field: ‘node’
[13:17:26.398]   - Field: ‘label’
[13:17:26.399]   - Field: ‘local’
[13:17:26.399]   - Field: ‘owner’
[13:17:26.399]   - Field: ‘envir’
[13:17:26.399]   - Field: ‘workers’
[13:17:26.399]   - Field: ‘packages’
[13:17:26.399]   - Field: ‘gc’
[13:17:26.399]   - Field: ‘conditions’
[13:17:26.399]   - Field: ‘persistent’
[13:17:26.399]   - Field: ‘expr’
[13:17:26.401]   - Field: ‘uuid’
[13:17:26.401]   - Field: ‘seed’
[13:17:26.402]   - Field: ‘version’
[13:17:26.402]   - Field: ‘result’
[13:17:26.402]   - Field: ‘asynchronous’
[13:17:26.402]   - Field: ‘calls’
[13:17:26.402]   - Field: ‘globals’
[13:17:26.402]   - Field: ‘stdout’
[13:17:26.402]   - Field: ‘earlySignal’
[13:17:26.402]   - Field: ‘lazy’
[13:17:26.402]   - Field: ‘state’
[13:17:26.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:26.402] - Launch lazy future ...
[13:17:26.403] Packages needed by the future expression (n = 0): <none>
[13:17:26.403] Packages needed by future strategies (n = 0): <none>
[13:17:26.403] {
[13:17:26.403]     {
[13:17:26.403]         {
[13:17:26.403]             ...future.startTime <- base::Sys.time()
[13:17:26.403]             {
[13:17:26.403]                 {
[13:17:26.403]                   {
[13:17:26.403]                     {
[13:17:26.403]                       base::local({
[13:17:26.403]                         has_future <- base::requireNamespace("future", 
[13:17:26.403]                           quietly = TRUE)
[13:17:26.403]                         if (has_future) {
[13:17:26.403]                           ns <- base::getNamespace("future")
[13:17:26.403]                           version <- ns[[".package"]][["version"]]
[13:17:26.403]                           if (is.null(version)) 
[13:17:26.403]                             version <- utils::packageVersion("future")
[13:17:26.403]                         }
[13:17:26.403]                         else {
[13:17:26.403]                           version <- NULL
[13:17:26.403]                         }
[13:17:26.403]                         if (!has_future || version < "1.8.0") {
[13:17:26.403]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.403]                             "", base::R.version$version.string), 
[13:17:26.403]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:26.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:26.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.403]                               "release", "version")], collapse = " "), 
[13:17:26.403]                             hostname = base::Sys.info()[["nodename"]])
[13:17:26.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.403]                             info)
[13:17:26.403]                           info <- base::paste(info, collapse = "; ")
[13:17:26.403]                           if (!has_future) {
[13:17:26.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.403]                               info)
[13:17:26.403]                           }
[13:17:26.403]                           else {
[13:17:26.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.403]                               info, version)
[13:17:26.403]                           }
[13:17:26.403]                           base::stop(msg)
[13:17:26.403]                         }
[13:17:26.403]                       })
[13:17:26.403]                     }
[13:17:26.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.403]                     base::options(mc.cores = 1L)
[13:17:26.403]                   }
[13:17:26.403]                   options(future.plan = NULL)
[13:17:26.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.403]                 }
[13:17:26.403]                 ...future.workdir <- getwd()
[13:17:26.403]             }
[13:17:26.403]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.403]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.403]         }
[13:17:26.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.403]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:26.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.403]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.403]             base::names(...future.oldOptions))
[13:17:26.403]     }
[13:17:26.403]     if (FALSE) {
[13:17:26.403]     }
[13:17:26.403]     else {
[13:17:26.403]         if (TRUE) {
[13:17:26.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.403]                 open = "w")
[13:17:26.403]         }
[13:17:26.403]         else {
[13:17:26.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.403]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.403]         }
[13:17:26.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.403]             base::sink(type = "output", split = FALSE)
[13:17:26.403]             base::close(...future.stdout)
[13:17:26.403]         }, add = TRUE)
[13:17:26.403]     }
[13:17:26.403]     ...future.frame <- base::sys.nframe()
[13:17:26.403]     ...future.conditions <- base::list()
[13:17:26.403]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.403]     if (FALSE) {
[13:17:26.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.403]     }
[13:17:26.403]     ...future.result <- base::tryCatch({
[13:17:26.403]         base::withCallingHandlers({
[13:17:26.403]             ...future.value <- base::withVisible(base::local({
[13:17:26.403]                 ...future.makeSendCondition <- local({
[13:17:26.403]                   sendCondition <- NULL
[13:17:26.403]                   function(frame = 1L) {
[13:17:26.403]                     if (is.function(sendCondition)) 
[13:17:26.403]                       return(sendCondition)
[13:17:26.403]                     ns <- getNamespace("parallel")
[13:17:26.403]                     if (exists("sendData", mode = "function", 
[13:17:26.403]                       envir = ns)) {
[13:17:26.403]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.403]                         envir = ns)
[13:17:26.403]                       envir <- sys.frame(frame)
[13:17:26.403]                       master <- NULL
[13:17:26.403]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.403]                         !identical(envir, emptyenv())) {
[13:17:26.403]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.403]                           inherits = FALSE)) {
[13:17:26.403]                           master <- get("master", mode = "list", 
[13:17:26.403]                             envir = envir, inherits = FALSE)
[13:17:26.403]                           if (inherits(master, c("SOCKnode", 
[13:17:26.403]                             "SOCK0node"))) {
[13:17:26.403]                             sendCondition <<- function(cond) {
[13:17:26.403]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.403]                                 success = TRUE)
[13:17:26.403]                               parallel_sendData(master, data)
[13:17:26.403]                             }
[13:17:26.403]                             return(sendCondition)
[13:17:26.403]                           }
[13:17:26.403]                         }
[13:17:26.403]                         frame <- frame + 1L
[13:17:26.403]                         envir <- sys.frame(frame)
[13:17:26.403]                       }
[13:17:26.403]                     }
[13:17:26.403]                     sendCondition <<- function(cond) NULL
[13:17:26.403]                   }
[13:17:26.403]                 })
[13:17:26.403]                 withCallingHandlers({
[13:17:26.403]                   {
[13:17:26.403]                     do.call(function(...) {
[13:17:26.403]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.403]                       if (!identical(...future.globals.maxSize.org, 
[13:17:26.403]                         ...future.globals.maxSize)) {
[13:17:26.403]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.403]                         on.exit(options(oopts), add = TRUE)
[13:17:26.403]                       }
[13:17:26.403]                       {
[13:17:26.403]                         lapply(seq_along(...future.elements_ii), 
[13:17:26.403]                           FUN = function(jj) {
[13:17:26.403]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.403]                             ...future.FUN(...future.X_jj, ...)
[13:17:26.403]                           })
[13:17:26.403]                       }
[13:17:26.403]                     }, args = future.call.arguments)
[13:17:26.403]                   }
[13:17:26.403]                 }, immediateCondition = function(cond) {
[13:17:26.403]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.403]                   sendCondition(cond)
[13:17:26.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.403]                   {
[13:17:26.403]                     inherits <- base::inherits
[13:17:26.403]                     invokeRestart <- base::invokeRestart
[13:17:26.403]                     is.null <- base::is.null
[13:17:26.403]                     muffled <- FALSE
[13:17:26.403]                     if (inherits(cond, "message")) {
[13:17:26.403]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.403]                       if (muffled) 
[13:17:26.403]                         invokeRestart("muffleMessage")
[13:17:26.403]                     }
[13:17:26.403]                     else if (inherits(cond, "warning")) {
[13:17:26.403]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.403]                       if (muffled) 
[13:17:26.403]                         invokeRestart("muffleWarning")
[13:17:26.403]                     }
[13:17:26.403]                     else if (inherits(cond, "condition")) {
[13:17:26.403]                       if (!is.null(pattern)) {
[13:17:26.403]                         computeRestarts <- base::computeRestarts
[13:17:26.403]                         grepl <- base::grepl
[13:17:26.403]                         restarts <- computeRestarts(cond)
[13:17:26.403]                         for (restart in restarts) {
[13:17:26.403]                           name <- restart$name
[13:17:26.403]                           if (is.null(name)) 
[13:17:26.403]                             next
[13:17:26.403]                           if (!grepl(pattern, name)) 
[13:17:26.403]                             next
[13:17:26.403]                           invokeRestart(restart)
[13:17:26.403]                           muffled <- TRUE
[13:17:26.403]                           break
[13:17:26.403]                         }
[13:17:26.403]                       }
[13:17:26.403]                     }
[13:17:26.403]                     invisible(muffled)
[13:17:26.403]                   }
[13:17:26.403]                   muffleCondition(cond)
[13:17:26.403]                 })
[13:17:26.403]             }))
[13:17:26.403]             future::FutureResult(value = ...future.value$value, 
[13:17:26.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.403]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.403]                     ...future.globalenv.names))
[13:17:26.403]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.403]         }, condition = base::local({
[13:17:26.403]             c <- base::c
[13:17:26.403]             inherits <- base::inherits
[13:17:26.403]             invokeRestart <- base::invokeRestart
[13:17:26.403]             length <- base::length
[13:17:26.403]             list <- base::list
[13:17:26.403]             seq.int <- base::seq.int
[13:17:26.403]             signalCondition <- base::signalCondition
[13:17:26.403]             sys.calls <- base::sys.calls
[13:17:26.403]             `[[` <- base::`[[`
[13:17:26.403]             `+` <- base::`+`
[13:17:26.403]             `<<-` <- base::`<<-`
[13:17:26.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.403]                   3L)]
[13:17:26.403]             }
[13:17:26.403]             function(cond) {
[13:17:26.403]                 is_error <- inherits(cond, "error")
[13:17:26.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.403]                   NULL)
[13:17:26.403]                 if (is_error) {
[13:17:26.403]                   sessionInformation <- function() {
[13:17:26.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.403]                       search = base::search(), system = base::Sys.info())
[13:17:26.403]                   }
[13:17:26.403]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.403]                     cond$call), session = sessionInformation(), 
[13:17:26.403]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.403]                   signalCondition(cond)
[13:17:26.403]                 }
[13:17:26.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.403]                 "immediateCondition"))) {
[13:17:26.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.403]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.403]                   if (TRUE && !signal) {
[13:17:26.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.403]                     {
[13:17:26.403]                       inherits <- base::inherits
[13:17:26.403]                       invokeRestart <- base::invokeRestart
[13:17:26.403]                       is.null <- base::is.null
[13:17:26.403]                       muffled <- FALSE
[13:17:26.403]                       if (inherits(cond, "message")) {
[13:17:26.403]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.403]                         if (muffled) 
[13:17:26.403]                           invokeRestart("muffleMessage")
[13:17:26.403]                       }
[13:17:26.403]                       else if (inherits(cond, "warning")) {
[13:17:26.403]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.403]                         if (muffled) 
[13:17:26.403]                           invokeRestart("muffleWarning")
[13:17:26.403]                       }
[13:17:26.403]                       else if (inherits(cond, "condition")) {
[13:17:26.403]                         if (!is.null(pattern)) {
[13:17:26.403]                           computeRestarts <- base::computeRestarts
[13:17:26.403]                           grepl <- base::grepl
[13:17:26.403]                           restarts <- computeRestarts(cond)
[13:17:26.403]                           for (restart in restarts) {
[13:17:26.403]                             name <- restart$name
[13:17:26.403]                             if (is.null(name)) 
[13:17:26.403]                               next
[13:17:26.403]                             if (!grepl(pattern, name)) 
[13:17:26.403]                               next
[13:17:26.403]                             invokeRestart(restart)
[13:17:26.403]                             muffled <- TRUE
[13:17:26.403]                             break
[13:17:26.403]                           }
[13:17:26.403]                         }
[13:17:26.403]                       }
[13:17:26.403]                       invisible(muffled)
[13:17:26.403]                     }
[13:17:26.403]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.403]                   }
[13:17:26.403]                 }
[13:17:26.403]                 else {
[13:17:26.403]                   if (TRUE) {
[13:17:26.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.403]                     {
[13:17:26.403]                       inherits <- base::inherits
[13:17:26.403]                       invokeRestart <- base::invokeRestart
[13:17:26.403]                       is.null <- base::is.null
[13:17:26.403]                       muffled <- FALSE
[13:17:26.403]                       if (inherits(cond, "message")) {
[13:17:26.403]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.403]                         if (muffled) 
[13:17:26.403]                           invokeRestart("muffleMessage")
[13:17:26.403]                       }
[13:17:26.403]                       else if (inherits(cond, "warning")) {
[13:17:26.403]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.403]                         if (muffled) 
[13:17:26.403]                           invokeRestart("muffleWarning")
[13:17:26.403]                       }
[13:17:26.403]                       else if (inherits(cond, "condition")) {
[13:17:26.403]                         if (!is.null(pattern)) {
[13:17:26.403]                           computeRestarts <- base::computeRestarts
[13:17:26.403]                           grepl <- base::grepl
[13:17:26.403]                           restarts <- computeRestarts(cond)
[13:17:26.403]                           for (restart in restarts) {
[13:17:26.403]                             name <- restart$name
[13:17:26.403]                             if (is.null(name)) 
[13:17:26.403]                               next
[13:17:26.403]                             if (!grepl(pattern, name)) 
[13:17:26.403]                               next
[13:17:26.403]                             invokeRestart(restart)
[13:17:26.403]                             muffled <- TRUE
[13:17:26.403]                             break
[13:17:26.403]                           }
[13:17:26.403]                         }
[13:17:26.403]                       }
[13:17:26.403]                       invisible(muffled)
[13:17:26.403]                     }
[13:17:26.403]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.403]                   }
[13:17:26.403]                 }
[13:17:26.403]             }
[13:17:26.403]         }))
[13:17:26.403]     }, error = function(ex) {
[13:17:26.403]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.403]                 ...future.rng), started = ...future.startTime, 
[13:17:26.403]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.403]             version = "1.8"), class = "FutureResult")
[13:17:26.403]     }, finally = {
[13:17:26.403]         if (!identical(...future.workdir, getwd())) 
[13:17:26.403]             setwd(...future.workdir)
[13:17:26.403]         {
[13:17:26.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.403]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.403]             }
[13:17:26.403]             base::options(...future.oldOptions)
[13:17:26.403]             if (.Platform$OS.type == "windows") {
[13:17:26.403]                 old_names <- names(...future.oldEnvVars)
[13:17:26.403]                 envs <- base::Sys.getenv()
[13:17:26.403]                 names <- names(envs)
[13:17:26.403]                 common <- intersect(names, old_names)
[13:17:26.403]                 added <- setdiff(names, old_names)
[13:17:26.403]                 removed <- setdiff(old_names, names)
[13:17:26.403]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.403]                   envs[common]]
[13:17:26.403]                 NAMES <- toupper(changed)
[13:17:26.403]                 args <- list()
[13:17:26.403]                 for (kk in seq_along(NAMES)) {
[13:17:26.403]                   name <- changed[[kk]]
[13:17:26.403]                   NAME <- NAMES[[kk]]
[13:17:26.403]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.403]                     next
[13:17:26.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.403]                 }
[13:17:26.403]                 NAMES <- toupper(added)
[13:17:26.403]                 for (kk in seq_along(NAMES)) {
[13:17:26.403]                   name <- added[[kk]]
[13:17:26.403]                   NAME <- NAMES[[kk]]
[13:17:26.403]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.403]                     next
[13:17:26.403]                   args[[name]] <- ""
[13:17:26.403]                 }
[13:17:26.403]                 NAMES <- toupper(removed)
[13:17:26.403]                 for (kk in seq_along(NAMES)) {
[13:17:26.403]                   name <- removed[[kk]]
[13:17:26.403]                   NAME <- NAMES[[kk]]
[13:17:26.403]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.403]                     next
[13:17:26.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.403]                 }
[13:17:26.403]                 if (length(args) > 0) 
[13:17:26.403]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.403]             }
[13:17:26.403]             else {
[13:17:26.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.403]             }
[13:17:26.403]             {
[13:17:26.403]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.403]                   0L) {
[13:17:26.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.403]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.403]                   base::options(opts)
[13:17:26.403]                 }
[13:17:26.403]                 {
[13:17:26.403]                   {
[13:17:26.403]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.403]                     NULL
[13:17:26.403]                   }
[13:17:26.403]                   options(future.plan = NULL)
[13:17:26.403]                   if (is.na(NA_character_)) 
[13:17:26.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.403]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.403]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.403]                     envir = parent.frame()) 
[13:17:26.403]                   {
[13:17:26.403]                     if (is.function(workers)) 
[13:17:26.403]                       workers <- workers()
[13:17:26.403]                     workers <- structure(as.integer(workers), 
[13:17:26.403]                       class = class(workers))
[13:17:26.403]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.403]                       workers >= 1)
[13:17:26.403]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.403]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.403]                     }
[13:17:26.403]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.403]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.403]                       envir = envir)
[13:17:26.403]                     if (!future$lazy) 
[13:17:26.403]                       future <- run(future)
[13:17:26.403]                     invisible(future)
[13:17:26.403]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.403]                 }
[13:17:26.403]             }
[13:17:26.403]         }
[13:17:26.403]     })
[13:17:26.403]     if (TRUE) {
[13:17:26.403]         base::sink(type = "output", split = FALSE)
[13:17:26.403]         if (TRUE) {
[13:17:26.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.403]         }
[13:17:26.403]         else {
[13:17:26.403]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.403]         }
[13:17:26.403]         base::close(...future.stdout)
[13:17:26.403]         ...future.stdout <- NULL
[13:17:26.403]     }
[13:17:26.403]     ...future.result$conditions <- ...future.conditions
[13:17:26.403]     ...future.result$finished <- base::Sys.time()
[13:17:26.403]     ...future.result
[13:17:26.403] }
[13:17:26.477] Exporting 5 global objects (346.00 KiB) to cluster node #2 ...
[13:17:26.477] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:26.478] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:26.478] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[13:17:26.521] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[13:17:26.521] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:17:26.522] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:17:26.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:26.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:26.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:26.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:26.523] Exporting 5 global objects (346.00 KiB) to cluster node #2 ... DONE
[13:17:26.524] MultisessionFuture started
[13:17:26.524] - Launch lazy future ... done
[13:17:26.524] run() for ‘MultisessionFuture’ ... done
[13:17:26.524] Created future:
[13:17:26.524] MultisessionFuture:
[13:17:26.524] Label: ‘future_apply-2’
[13:17:26.524] Expression:
[13:17:26.524] {
[13:17:26.524]     do.call(function(...) {
[13:17:26.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.524]             on.exit(options(oopts), add = TRUE)
[13:17:26.524]         }
[13:17:26.524]         {
[13:17:26.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.524]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.524]             })
[13:17:26.524]         }
[13:17:26.524]     }, args = future.call.arguments)
[13:17:26.524] }
[13:17:26.524] Lazy evaluation: FALSE
[13:17:26.524] Asynchronous evaluation: TRUE
[13:17:26.524] Local evaluation: TRUE
[13:17:26.524] Environment: R_GlobalEnv
[13:17:26.524] Capture standard output: TRUE
[13:17:26.524] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:26.524] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:26.524] Packages: <none>
[13:17:26.524] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:26.524] Resolved: FALSE
[13:17:26.524] Value: <not collected>
[13:17:26.524] Conditions captured: <none>
[13:17:26.524] Early signaling: FALSE
[13:17:26.524] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:26.524] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.536] Chunk #2 of 2 ... DONE
[13:17:26.536] Launching 2 futures (chunks) ... DONE
[13:17:26.536] Resolving 2 futures (chunks) ...
[13:17:26.537] resolve() on list ...
[13:17:26.537]  recursive: 0
[13:17:26.537]  length: 2
[13:17:26.537] 
[13:17:26.537] receiveMessageFromWorker() for ClusterFuture ...
[13:17:26.537] - Validating connection of MultisessionFuture
[13:17:26.538] - received message: FutureResult
[13:17:26.538] - Received FutureResult
[13:17:26.538] - Erased future from FutureRegistry
[13:17:26.538] result() for ClusterFuture ...
[13:17:26.538] - result already collected: FutureResult
[13:17:26.538] result() for ClusterFuture ... done
[13:17:26.538] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:26.538] Future #1
[13:17:26.538] result() for ClusterFuture ...
[13:17:26.538] - result already collected: FutureResult
[13:17:26.539] result() for ClusterFuture ... done
[13:17:26.539] result() for ClusterFuture ...
[13:17:26.539] - result already collected: FutureResult
[13:17:26.539] result() for ClusterFuture ... done
[13:17:26.539] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:26.539] - nx: 2
[13:17:26.539] - relay: TRUE
[13:17:26.539] - stdout: TRUE
[13:17:26.539] - signal: TRUE
[13:17:26.539] - resignal: FALSE
[13:17:26.539] - force: TRUE
[13:17:26.539] - relayed: [n=2] FALSE, FALSE
[13:17:26.540] - queued futures: [n=2] FALSE, FALSE
[13:17:26.540]  - until=1
[13:17:26.540]  - relaying element #1
[13:17:26.540] result() for ClusterFuture ...
[13:17:26.540] - result already collected: FutureResult
[13:17:26.540] result() for ClusterFuture ... done
[13:17:26.540] result() for ClusterFuture ...
[13:17:26.540] - result already collected: FutureResult
[13:17:26.540] result() for ClusterFuture ... done
[13:17:26.540] result() for ClusterFuture ...
[13:17:26.540] - result already collected: FutureResult
[13:17:26.541] result() for ClusterFuture ... done
[13:17:26.541] result() for ClusterFuture ...
[13:17:26.541] - result already collected: FutureResult
[13:17:26.541] result() for ClusterFuture ... done
[13:17:26.541] - relayed: [n=2] TRUE, FALSE
[13:17:26.541] - queued futures: [n=2] TRUE, FALSE
[13:17:26.541] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:26.541]  length: 1 (resolved future 1)
[13:17:26.604] receiveMessageFromWorker() for ClusterFuture ...
[13:17:26.604] - Validating connection of MultisessionFuture
[13:17:26.604] - received message: FutureResult
[13:17:26.604] - Received FutureResult
[13:17:26.605] - Erased future from FutureRegistry
[13:17:26.605] result() for ClusterFuture ...
[13:17:26.605] - result already collected: FutureResult
[13:17:26.605] result() for ClusterFuture ... done
[13:17:26.605] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:26.605] Future #2
[13:17:26.605] result() for ClusterFuture ...
[13:17:26.606] - result already collected: FutureResult
[13:17:26.606] result() for ClusterFuture ... done
[13:17:26.606] result() for ClusterFuture ...
[13:17:26.606] - result already collected: FutureResult
[13:17:26.606] result() for ClusterFuture ... done
[13:17:26.606] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:26.606] - nx: 2
[13:17:26.607] - relay: TRUE
[13:17:26.607] - stdout: TRUE
[13:17:26.607] - signal: TRUE
[13:17:26.607] - resignal: FALSE
[13:17:26.607] - force: TRUE
[13:17:26.607] - relayed: [n=2] TRUE, FALSE
[13:17:26.607] - queued futures: [n=2] TRUE, FALSE
[13:17:26.607]  - until=2
[13:17:26.608]  - relaying element #2
[13:17:26.608] result() for ClusterFuture ...
[13:17:26.608] - result already collected: FutureResult
[13:17:26.608] result() for ClusterFuture ... done
[13:17:26.608] result() for ClusterFuture ...
[13:17:26.608] - result already collected: FutureResult
[13:17:26.608] result() for ClusterFuture ... done
[13:17:26.609] result() for ClusterFuture ...
[13:17:26.609] - result already collected: FutureResult
[13:17:26.609] result() for ClusterFuture ... done
[13:17:26.609] result() for ClusterFuture ...
[13:17:26.609] - result already collected: FutureResult
[13:17:26.609] result() for ClusterFuture ... done
[13:17:26.609] - relayed: [n=2] TRUE, TRUE
[13:17:26.609] - queued futures: [n=2] TRUE, TRUE
[13:17:26.610] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:26.610]  length: 0 (resolved future 2)
[13:17:26.610] Relaying remaining futures
[13:17:26.610] signalConditionsASAP(NULL, pos=0) ...
[13:17:26.610] - nx: 2
[13:17:26.610] - relay: TRUE
[13:17:26.610] - stdout: TRUE
[13:17:26.610] - signal: TRUE
[13:17:26.611] - resignal: FALSE
[13:17:26.611] - force: TRUE
[13:17:26.611] - relayed: [n=2] TRUE, TRUE
[13:17:26.611] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:26.611] - relayed: [n=2] TRUE, TRUE
[13:17:26.611] - queued futures: [n=2] TRUE, TRUE
[13:17:26.611] signalConditionsASAP(NULL, pos=0) ... done
[13:17:26.612] resolve() on list ... DONE
[13:17:26.612] result() for ClusterFuture ...
[13:17:26.612] - result already collected: FutureResult
[13:17:26.612] result() for ClusterFuture ... done
[13:17:26.612] result() for ClusterFuture ...
[13:17:26.612] - result already collected: FutureResult
[13:17:26.612] result() for ClusterFuture ... done
[13:17:26.613] result() for ClusterFuture ...
[13:17:26.613] - result already collected: FutureResult
[13:17:26.613] result() for ClusterFuture ... done
[13:17:26.613] result() for ClusterFuture ...
[13:17:26.613] - result already collected: FutureResult
[13:17:26.613] result() for ClusterFuture ... done
[13:17:26.613]  - Number of value chunks collected: 2
[13:17:26.614] Resolving 2 futures (chunks) ... DONE
[13:17:26.614] Reducing values from 2 chunks ...
[13:17:26.614]  - Number of values collected after concatenation: 2
[13:17:26.614]  - Number of values expected: 2
[13:17:26.614] Reducing values from 2 chunks ... DONE
[13:17:26.614] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:17:26.615] getGlobalsAndPackagesXApply() ...
[13:17:26.615]  - future.globals: TRUE
[13:17:26.615] getGlobalsAndPackages() ...
[13:17:26.615] Searching for globals...
[13:17:26.660] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[13:17:26.660] Searching for globals ... DONE
[13:17:26.660] Resolving globals: FALSE
[13:17:26.662] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[13:17:26.662] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[13:17:26.663] - globals: [1] ‘FUN’
[13:17:26.663] 
[13:17:26.663] getGlobalsAndPackages() ... DONE
[13:17:26.663]  - globals found/used: [n=1] ‘FUN’
[13:17:26.663]  - needed namespaces: [n=0] 
[13:17:26.663] Finding globals ... DONE
[13:17:26.663]  - use_args: TRUE
[13:17:26.663]  - Getting '...' globals ...
[13:17:26.664] resolve() on list ...
[13:17:26.664]  recursive: 0
[13:17:26.664]  length: 1
[13:17:26.664]  elements: ‘...’
[13:17:26.664]  length: 0 (resolved future 1)
[13:17:26.664] resolve() on list ... DONE
[13:17:26.664]    - '...' content: [n=0] 
[13:17:26.664] List of 1
[13:17:26.664]  $ ...: list()
[13:17:26.664]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.664]  - attr(*, "where")=List of 1
[13:17:26.664]   ..$ ...:<environment: 0x5647b9a45930> 
[13:17:26.664]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.664]  - attr(*, "resolved")= logi TRUE
[13:17:26.664]  - attr(*, "total_size")= num NA
[13:17:26.667]  - Getting '...' globals ... DONE
[13:17:26.667] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:26.667] List of 2
[13:17:26.667]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:26.667]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:26.667]  $ ...          : list()
[13:17:26.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.667]  - attr(*, "where")=List of 2
[13:17:26.667]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:26.667]   ..$ ...          :<environment: 0x5647b9a45930> 
[13:17:26.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.667]  - attr(*, "resolved")= logi FALSE
[13:17:26.667]  - attr(*, "total_size")= num 354224
[13:17:26.670] Packages to be attached in all futures: [n=0] 
[13:17:26.671] getGlobalsAndPackagesXApply() ... DONE
[13:17:26.675] future_lapply() ...
[13:17:26.712] Number of chunks: 2
[13:17:26.712] getGlobalsAndPackagesXApply() ...
[13:17:26.712]  - future.globals: <name-value list> with names ‘list()’
[13:17:26.712]  - use_args: TRUE
[13:17:26.712] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:26.712] List of 2
[13:17:26.712]  $ ...          : list()
[13:17:26.712]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.712]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[13:17:26.712]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[13:17:26.712]  - attr(*, "where")=List of 2
[13:17:26.712]   ..$ ...          :<environment: 0x5647b9a45930> 
[13:17:26.712]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:26.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.712]  - attr(*, "resolved")= logi FALSE
[13:17:26.712]  - attr(*, "total_size")= num NA
[13:17:26.716] Packages to be attached in all futures: [n=0] 
[13:17:26.716] getGlobalsAndPackagesXApply() ... DONE
[13:17:26.716] Number of futures (= number of chunks): 2
[13:17:26.716] Launching 2 futures (chunks) ...
[13:17:26.716] Chunk #1 of 2 ...
[13:17:26.716]  - seeds: <none>
[13:17:26.716] getGlobalsAndPackages() ...
[13:17:26.716] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.717] Resolving globals: FALSE
[13:17:26.717] Tweak future expression to call with '...' arguments ...
[13:17:26.717] {
[13:17:26.717]     do.call(function(...) {
[13:17:26.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.717]             on.exit(options(oopts), add = TRUE)
[13:17:26.717]         }
[13:17:26.717]         {
[13:17:26.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.717]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.717]             })
[13:17:26.717]         }
[13:17:26.717]     }, args = future.call.arguments)
[13:17:26.717] }
[13:17:26.717] Tweak future expression to call with '...' arguments ... DONE
[13:17:26.717] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.718] 
[13:17:26.718] getGlobalsAndPackages() ... DONE
[13:17:26.718] run() for ‘Future’ ...
[13:17:26.718] - state: ‘created’
[13:17:26.718] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:26.732] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:26.733]   - Field: ‘node’
[13:17:26.733]   - Field: ‘label’
[13:17:26.733]   - Field: ‘local’
[13:17:26.733]   - Field: ‘owner’
[13:17:26.733]   - Field: ‘envir’
[13:17:26.733]   - Field: ‘workers’
[13:17:26.733]   - Field: ‘packages’
[13:17:26.733]   - Field: ‘gc’
[13:17:26.733]   - Field: ‘conditions’
[13:17:26.734]   - Field: ‘persistent’
[13:17:26.734]   - Field: ‘expr’
[13:17:26.734]   - Field: ‘uuid’
[13:17:26.734]   - Field: ‘seed’
[13:17:26.734]   - Field: ‘version’
[13:17:26.734]   - Field: ‘result’
[13:17:26.734]   - Field: ‘asynchronous’
[13:17:26.734]   - Field: ‘calls’
[13:17:26.734]   - Field: ‘globals’
[13:17:26.734]   - Field: ‘stdout’
[13:17:26.734]   - Field: ‘earlySignal’
[13:17:26.735]   - Field: ‘lazy’
[13:17:26.735]   - Field: ‘state’
[13:17:26.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:26.735] - Launch lazy future ...
[13:17:26.735] Packages needed by the future expression (n = 0): <none>
[13:17:26.735] Packages needed by future strategies (n = 0): <none>
[13:17:26.736] {
[13:17:26.736]     {
[13:17:26.736]         {
[13:17:26.736]             ...future.startTime <- base::Sys.time()
[13:17:26.736]             {
[13:17:26.736]                 {
[13:17:26.736]                   {
[13:17:26.736]                     {
[13:17:26.736]                       base::local({
[13:17:26.736]                         has_future <- base::requireNamespace("future", 
[13:17:26.736]                           quietly = TRUE)
[13:17:26.736]                         if (has_future) {
[13:17:26.736]                           ns <- base::getNamespace("future")
[13:17:26.736]                           version <- ns[[".package"]][["version"]]
[13:17:26.736]                           if (is.null(version)) 
[13:17:26.736]                             version <- utils::packageVersion("future")
[13:17:26.736]                         }
[13:17:26.736]                         else {
[13:17:26.736]                           version <- NULL
[13:17:26.736]                         }
[13:17:26.736]                         if (!has_future || version < "1.8.0") {
[13:17:26.736]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.736]                             "", base::R.version$version.string), 
[13:17:26.736]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:26.736]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:26.736]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.736]                               "release", "version")], collapse = " "), 
[13:17:26.736]                             hostname = base::Sys.info()[["nodename"]])
[13:17:26.736]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.736]                             info)
[13:17:26.736]                           info <- base::paste(info, collapse = "; ")
[13:17:26.736]                           if (!has_future) {
[13:17:26.736]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.736]                               info)
[13:17:26.736]                           }
[13:17:26.736]                           else {
[13:17:26.736]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.736]                               info, version)
[13:17:26.736]                           }
[13:17:26.736]                           base::stop(msg)
[13:17:26.736]                         }
[13:17:26.736]                       })
[13:17:26.736]                     }
[13:17:26.736]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.736]                     base::options(mc.cores = 1L)
[13:17:26.736]                   }
[13:17:26.736]                   options(future.plan = NULL)
[13:17:26.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.736]                 }
[13:17:26.736]                 ...future.workdir <- getwd()
[13:17:26.736]             }
[13:17:26.736]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.736]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.736]         }
[13:17:26.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.736]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:26.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.736]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.736]             base::names(...future.oldOptions))
[13:17:26.736]     }
[13:17:26.736]     if (FALSE) {
[13:17:26.736]     }
[13:17:26.736]     else {
[13:17:26.736]         if (TRUE) {
[13:17:26.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.736]                 open = "w")
[13:17:26.736]         }
[13:17:26.736]         else {
[13:17:26.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.736]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.736]         }
[13:17:26.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.736]             base::sink(type = "output", split = FALSE)
[13:17:26.736]             base::close(...future.stdout)
[13:17:26.736]         }, add = TRUE)
[13:17:26.736]     }
[13:17:26.736]     ...future.frame <- base::sys.nframe()
[13:17:26.736]     ...future.conditions <- base::list()
[13:17:26.736]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.736]     if (FALSE) {
[13:17:26.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.736]     }
[13:17:26.736]     ...future.result <- base::tryCatch({
[13:17:26.736]         base::withCallingHandlers({
[13:17:26.736]             ...future.value <- base::withVisible(base::local({
[13:17:26.736]                 ...future.makeSendCondition <- local({
[13:17:26.736]                   sendCondition <- NULL
[13:17:26.736]                   function(frame = 1L) {
[13:17:26.736]                     if (is.function(sendCondition)) 
[13:17:26.736]                       return(sendCondition)
[13:17:26.736]                     ns <- getNamespace("parallel")
[13:17:26.736]                     if (exists("sendData", mode = "function", 
[13:17:26.736]                       envir = ns)) {
[13:17:26.736]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.736]                         envir = ns)
[13:17:26.736]                       envir <- sys.frame(frame)
[13:17:26.736]                       master <- NULL
[13:17:26.736]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.736]                         !identical(envir, emptyenv())) {
[13:17:26.736]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.736]                           inherits = FALSE)) {
[13:17:26.736]                           master <- get("master", mode = "list", 
[13:17:26.736]                             envir = envir, inherits = FALSE)
[13:17:26.736]                           if (inherits(master, c("SOCKnode", 
[13:17:26.736]                             "SOCK0node"))) {
[13:17:26.736]                             sendCondition <<- function(cond) {
[13:17:26.736]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.736]                                 success = TRUE)
[13:17:26.736]                               parallel_sendData(master, data)
[13:17:26.736]                             }
[13:17:26.736]                             return(sendCondition)
[13:17:26.736]                           }
[13:17:26.736]                         }
[13:17:26.736]                         frame <- frame + 1L
[13:17:26.736]                         envir <- sys.frame(frame)
[13:17:26.736]                       }
[13:17:26.736]                     }
[13:17:26.736]                     sendCondition <<- function(cond) NULL
[13:17:26.736]                   }
[13:17:26.736]                 })
[13:17:26.736]                 withCallingHandlers({
[13:17:26.736]                   {
[13:17:26.736]                     do.call(function(...) {
[13:17:26.736]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.736]                       if (!identical(...future.globals.maxSize.org, 
[13:17:26.736]                         ...future.globals.maxSize)) {
[13:17:26.736]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.736]                         on.exit(options(oopts), add = TRUE)
[13:17:26.736]                       }
[13:17:26.736]                       {
[13:17:26.736]                         lapply(seq_along(...future.elements_ii), 
[13:17:26.736]                           FUN = function(jj) {
[13:17:26.736]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.736]                             ...future.FUN(...future.X_jj, ...)
[13:17:26.736]                           })
[13:17:26.736]                       }
[13:17:26.736]                     }, args = future.call.arguments)
[13:17:26.736]                   }
[13:17:26.736]                 }, immediateCondition = function(cond) {
[13:17:26.736]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.736]                   sendCondition(cond)
[13:17:26.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.736]                   {
[13:17:26.736]                     inherits <- base::inherits
[13:17:26.736]                     invokeRestart <- base::invokeRestart
[13:17:26.736]                     is.null <- base::is.null
[13:17:26.736]                     muffled <- FALSE
[13:17:26.736]                     if (inherits(cond, "message")) {
[13:17:26.736]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.736]                       if (muffled) 
[13:17:26.736]                         invokeRestart("muffleMessage")
[13:17:26.736]                     }
[13:17:26.736]                     else if (inherits(cond, "warning")) {
[13:17:26.736]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.736]                       if (muffled) 
[13:17:26.736]                         invokeRestart("muffleWarning")
[13:17:26.736]                     }
[13:17:26.736]                     else if (inherits(cond, "condition")) {
[13:17:26.736]                       if (!is.null(pattern)) {
[13:17:26.736]                         computeRestarts <- base::computeRestarts
[13:17:26.736]                         grepl <- base::grepl
[13:17:26.736]                         restarts <- computeRestarts(cond)
[13:17:26.736]                         for (restart in restarts) {
[13:17:26.736]                           name <- restart$name
[13:17:26.736]                           if (is.null(name)) 
[13:17:26.736]                             next
[13:17:26.736]                           if (!grepl(pattern, name)) 
[13:17:26.736]                             next
[13:17:26.736]                           invokeRestart(restart)
[13:17:26.736]                           muffled <- TRUE
[13:17:26.736]                           break
[13:17:26.736]                         }
[13:17:26.736]                       }
[13:17:26.736]                     }
[13:17:26.736]                     invisible(muffled)
[13:17:26.736]                   }
[13:17:26.736]                   muffleCondition(cond)
[13:17:26.736]                 })
[13:17:26.736]             }))
[13:17:26.736]             future::FutureResult(value = ...future.value$value, 
[13:17:26.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.736]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.736]                     ...future.globalenv.names))
[13:17:26.736]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.736]         }, condition = base::local({
[13:17:26.736]             c <- base::c
[13:17:26.736]             inherits <- base::inherits
[13:17:26.736]             invokeRestart <- base::invokeRestart
[13:17:26.736]             length <- base::length
[13:17:26.736]             list <- base::list
[13:17:26.736]             seq.int <- base::seq.int
[13:17:26.736]             signalCondition <- base::signalCondition
[13:17:26.736]             sys.calls <- base::sys.calls
[13:17:26.736]             `[[` <- base::`[[`
[13:17:26.736]             `+` <- base::`+`
[13:17:26.736]             `<<-` <- base::`<<-`
[13:17:26.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.736]                   3L)]
[13:17:26.736]             }
[13:17:26.736]             function(cond) {
[13:17:26.736]                 is_error <- inherits(cond, "error")
[13:17:26.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.736]                   NULL)
[13:17:26.736]                 if (is_error) {
[13:17:26.736]                   sessionInformation <- function() {
[13:17:26.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.736]                       search = base::search(), system = base::Sys.info())
[13:17:26.736]                   }
[13:17:26.736]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.736]                     cond$call), session = sessionInformation(), 
[13:17:26.736]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.736]                   signalCondition(cond)
[13:17:26.736]                 }
[13:17:26.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.736]                 "immediateCondition"))) {
[13:17:26.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.736]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.736]                   if (TRUE && !signal) {
[13:17:26.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.736]                     {
[13:17:26.736]                       inherits <- base::inherits
[13:17:26.736]                       invokeRestart <- base::invokeRestart
[13:17:26.736]                       is.null <- base::is.null
[13:17:26.736]                       muffled <- FALSE
[13:17:26.736]                       if (inherits(cond, "message")) {
[13:17:26.736]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.736]                         if (muffled) 
[13:17:26.736]                           invokeRestart("muffleMessage")
[13:17:26.736]                       }
[13:17:26.736]                       else if (inherits(cond, "warning")) {
[13:17:26.736]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.736]                         if (muffled) 
[13:17:26.736]                           invokeRestart("muffleWarning")
[13:17:26.736]                       }
[13:17:26.736]                       else if (inherits(cond, "condition")) {
[13:17:26.736]                         if (!is.null(pattern)) {
[13:17:26.736]                           computeRestarts <- base::computeRestarts
[13:17:26.736]                           grepl <- base::grepl
[13:17:26.736]                           restarts <- computeRestarts(cond)
[13:17:26.736]                           for (restart in restarts) {
[13:17:26.736]                             name <- restart$name
[13:17:26.736]                             if (is.null(name)) 
[13:17:26.736]                               next
[13:17:26.736]                             if (!grepl(pattern, name)) 
[13:17:26.736]                               next
[13:17:26.736]                             invokeRestart(restart)
[13:17:26.736]                             muffled <- TRUE
[13:17:26.736]                             break
[13:17:26.736]                           }
[13:17:26.736]                         }
[13:17:26.736]                       }
[13:17:26.736]                       invisible(muffled)
[13:17:26.736]                     }
[13:17:26.736]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.736]                   }
[13:17:26.736]                 }
[13:17:26.736]                 else {
[13:17:26.736]                   if (TRUE) {
[13:17:26.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.736]                     {
[13:17:26.736]                       inherits <- base::inherits
[13:17:26.736]                       invokeRestart <- base::invokeRestart
[13:17:26.736]                       is.null <- base::is.null
[13:17:26.736]                       muffled <- FALSE
[13:17:26.736]                       if (inherits(cond, "message")) {
[13:17:26.736]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.736]                         if (muffled) 
[13:17:26.736]                           invokeRestart("muffleMessage")
[13:17:26.736]                       }
[13:17:26.736]                       else if (inherits(cond, "warning")) {
[13:17:26.736]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.736]                         if (muffled) 
[13:17:26.736]                           invokeRestart("muffleWarning")
[13:17:26.736]                       }
[13:17:26.736]                       else if (inherits(cond, "condition")) {
[13:17:26.736]                         if (!is.null(pattern)) {
[13:17:26.736]                           computeRestarts <- base::computeRestarts
[13:17:26.736]                           grepl <- base::grepl
[13:17:26.736]                           restarts <- computeRestarts(cond)
[13:17:26.736]                           for (restart in restarts) {
[13:17:26.736]                             name <- restart$name
[13:17:26.736]                             if (is.null(name)) 
[13:17:26.736]                               next
[13:17:26.736]                             if (!grepl(pattern, name)) 
[13:17:26.736]                               next
[13:17:26.736]                             invokeRestart(restart)
[13:17:26.736]                             muffled <- TRUE
[13:17:26.736]                             break
[13:17:26.736]                           }
[13:17:26.736]                         }
[13:17:26.736]                       }
[13:17:26.736]                       invisible(muffled)
[13:17:26.736]                     }
[13:17:26.736]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.736]                   }
[13:17:26.736]                 }
[13:17:26.736]             }
[13:17:26.736]         }))
[13:17:26.736]     }, error = function(ex) {
[13:17:26.736]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.736]                 ...future.rng), started = ...future.startTime, 
[13:17:26.736]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.736]             version = "1.8"), class = "FutureResult")
[13:17:26.736]     }, finally = {
[13:17:26.736]         if (!identical(...future.workdir, getwd())) 
[13:17:26.736]             setwd(...future.workdir)
[13:17:26.736]         {
[13:17:26.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.736]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.736]             }
[13:17:26.736]             base::options(...future.oldOptions)
[13:17:26.736]             if (.Platform$OS.type == "windows") {
[13:17:26.736]                 old_names <- names(...future.oldEnvVars)
[13:17:26.736]                 envs <- base::Sys.getenv()
[13:17:26.736]                 names <- names(envs)
[13:17:26.736]                 common <- intersect(names, old_names)
[13:17:26.736]                 added <- setdiff(names, old_names)
[13:17:26.736]                 removed <- setdiff(old_names, names)
[13:17:26.736]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.736]                   envs[common]]
[13:17:26.736]                 NAMES <- toupper(changed)
[13:17:26.736]                 args <- list()
[13:17:26.736]                 for (kk in seq_along(NAMES)) {
[13:17:26.736]                   name <- changed[[kk]]
[13:17:26.736]                   NAME <- NAMES[[kk]]
[13:17:26.736]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.736]                     next
[13:17:26.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.736]                 }
[13:17:26.736]                 NAMES <- toupper(added)
[13:17:26.736]                 for (kk in seq_along(NAMES)) {
[13:17:26.736]                   name <- added[[kk]]
[13:17:26.736]                   NAME <- NAMES[[kk]]
[13:17:26.736]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.736]                     next
[13:17:26.736]                   args[[name]] <- ""
[13:17:26.736]                 }
[13:17:26.736]                 NAMES <- toupper(removed)
[13:17:26.736]                 for (kk in seq_along(NAMES)) {
[13:17:26.736]                   name <- removed[[kk]]
[13:17:26.736]                   NAME <- NAMES[[kk]]
[13:17:26.736]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.736]                     next
[13:17:26.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.736]                 }
[13:17:26.736]                 if (length(args) > 0) 
[13:17:26.736]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.736]             }
[13:17:26.736]             else {
[13:17:26.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.736]             }
[13:17:26.736]             {
[13:17:26.736]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.736]                   0L) {
[13:17:26.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.736]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.736]                   base::options(opts)
[13:17:26.736]                 }
[13:17:26.736]                 {
[13:17:26.736]                   {
[13:17:26.736]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.736]                     NULL
[13:17:26.736]                   }
[13:17:26.736]                   options(future.plan = NULL)
[13:17:26.736]                   if (is.na(NA_character_)) 
[13:17:26.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.736]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.736]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.736]                     envir = parent.frame()) 
[13:17:26.736]                   {
[13:17:26.736]                     if (is.function(workers)) 
[13:17:26.736]                       workers <- workers()
[13:17:26.736]                     workers <- structure(as.integer(workers), 
[13:17:26.736]                       class = class(workers))
[13:17:26.736]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.736]                       workers >= 1)
[13:17:26.736]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.736]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.736]                     }
[13:17:26.736]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.736]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.736]                       envir = envir)
[13:17:26.736]                     if (!future$lazy) 
[13:17:26.736]                       future <- run(future)
[13:17:26.736]                     invisible(future)
[13:17:26.736]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.736]                 }
[13:17:26.736]             }
[13:17:26.736]         }
[13:17:26.736]     })
[13:17:26.736]     if (TRUE) {
[13:17:26.736]         base::sink(type = "output", split = FALSE)
[13:17:26.736]         if (TRUE) {
[13:17:26.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.736]         }
[13:17:26.736]         else {
[13:17:26.736]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.736]         }
[13:17:26.736]         base::close(...future.stdout)
[13:17:26.736]         ...future.stdout <- NULL
[13:17:26.736]     }
[13:17:26.736]     ...future.result$conditions <- ...future.conditions
[13:17:26.736]     ...future.result$finished <- base::Sys.time()
[13:17:26.736]     ...future.result
[13:17:26.736] }
[13:17:26.739] Exporting 5 global objects (346.00 KiB) to cluster node #1 ...
[13:17:26.739] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:26.739] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.740] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[13:17:26.781] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[13:17:26.781] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:17:26.782] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:17:26.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:26.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:26.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.783] Exporting 5 global objects (346.00 KiB) to cluster node #1 ... DONE
[13:17:26.783] MultisessionFuture started
[13:17:26.783] - Launch lazy future ... done
[13:17:26.783] run() for ‘MultisessionFuture’ ... done
[13:17:26.783] Created future:
[13:17:26.783] MultisessionFuture:
[13:17:26.783] Label: ‘future_apply-1’
[13:17:26.783] Expression:
[13:17:26.783] {
[13:17:26.783]     do.call(function(...) {
[13:17:26.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.783]             on.exit(options(oopts), add = TRUE)
[13:17:26.783]         }
[13:17:26.783]         {
[13:17:26.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.783]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.783]             })
[13:17:26.783]         }
[13:17:26.783]     }, args = future.call.arguments)
[13:17:26.783] }
[13:17:26.783] Lazy evaluation: FALSE
[13:17:26.783] Asynchronous evaluation: TRUE
[13:17:26.783] Local evaluation: TRUE
[13:17:26.783] Environment: R_GlobalEnv
[13:17:26.783] Capture standard output: TRUE
[13:17:26.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:26.783] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:26.783] Packages: <none>
[13:17:26.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:26.783] Resolved: FALSE
[13:17:26.783] Value: <not collected>
[13:17:26.783] Conditions captured: <none>
[13:17:26.783] Early signaling: FALSE
[13:17:26.783] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:26.783] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.795] Chunk #1 of 2 ... DONE
[13:17:26.795] Chunk #2 of 2 ...
[13:17:26.795]  - seeds: <none>
[13:17:26.796] getGlobalsAndPackages() ...
[13:17:26.796] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.796] Resolving globals: FALSE
[13:17:26.796] Tweak future expression to call with '...' arguments ...
[13:17:26.796] {
[13:17:26.796]     do.call(function(...) {
[13:17:26.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.796]             on.exit(options(oopts), add = TRUE)
[13:17:26.796]         }
[13:17:26.796]         {
[13:17:26.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.796]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.796]             })
[13:17:26.796]         }
[13:17:26.796]     }, args = future.call.arguments)
[13:17:26.796] }
[13:17:26.796] Tweak future expression to call with '...' arguments ... DONE
[13:17:26.797] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.797] 
[13:17:26.797] getGlobalsAndPackages() ... DONE
[13:17:26.797] run() for ‘Future’ ...
[13:17:26.797] - state: ‘created’
[13:17:26.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:26.812] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:26.812]   - Field: ‘node’
[13:17:26.812]   - Field: ‘label’
[13:17:26.813]   - Field: ‘local’
[13:17:26.813]   - Field: ‘owner’
[13:17:26.813]   - Field: ‘envir’
[13:17:26.813]   - Field: ‘workers’
[13:17:26.813]   - Field: ‘packages’
[13:17:26.813]   - Field: ‘gc’
[13:17:26.813]   - Field: ‘conditions’
[13:17:26.813]   - Field: ‘persistent’
[13:17:26.813]   - Field: ‘expr’
[13:17:26.813]   - Field: ‘uuid’
[13:17:26.813]   - Field: ‘seed’
[13:17:26.814]   - Field: ‘version’
[13:17:26.814]   - Field: ‘result’
[13:17:26.814]   - Field: ‘asynchronous’
[13:17:26.814]   - Field: ‘calls’
[13:17:26.814]   - Field: ‘globals’
[13:17:26.814]   - Field: ‘stdout’
[13:17:26.814]   - Field: ‘earlySignal’
[13:17:26.814]   - Field: ‘lazy’
[13:17:26.814]   - Field: ‘state’
[13:17:26.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:26.814] - Launch lazy future ...
[13:17:26.815] Packages needed by the future expression (n = 0): <none>
[13:17:26.815] Packages needed by future strategies (n = 0): <none>
[13:17:26.815] {
[13:17:26.815]     {
[13:17:26.815]         {
[13:17:26.815]             ...future.startTime <- base::Sys.time()
[13:17:26.815]             {
[13:17:26.815]                 {
[13:17:26.815]                   {
[13:17:26.815]                     {
[13:17:26.815]                       base::local({
[13:17:26.815]                         has_future <- base::requireNamespace("future", 
[13:17:26.815]                           quietly = TRUE)
[13:17:26.815]                         if (has_future) {
[13:17:26.815]                           ns <- base::getNamespace("future")
[13:17:26.815]                           version <- ns[[".package"]][["version"]]
[13:17:26.815]                           if (is.null(version)) 
[13:17:26.815]                             version <- utils::packageVersion("future")
[13:17:26.815]                         }
[13:17:26.815]                         else {
[13:17:26.815]                           version <- NULL
[13:17:26.815]                         }
[13:17:26.815]                         if (!has_future || version < "1.8.0") {
[13:17:26.815]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.815]                             "", base::R.version$version.string), 
[13:17:26.815]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:26.815]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:26.815]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.815]                               "release", "version")], collapse = " "), 
[13:17:26.815]                             hostname = base::Sys.info()[["nodename"]])
[13:17:26.815]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.815]                             info)
[13:17:26.815]                           info <- base::paste(info, collapse = "; ")
[13:17:26.815]                           if (!has_future) {
[13:17:26.815]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.815]                               info)
[13:17:26.815]                           }
[13:17:26.815]                           else {
[13:17:26.815]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.815]                               info, version)
[13:17:26.815]                           }
[13:17:26.815]                           base::stop(msg)
[13:17:26.815]                         }
[13:17:26.815]                       })
[13:17:26.815]                     }
[13:17:26.815]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.815]                     base::options(mc.cores = 1L)
[13:17:26.815]                   }
[13:17:26.815]                   options(future.plan = NULL)
[13:17:26.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.815]                 }
[13:17:26.815]                 ...future.workdir <- getwd()
[13:17:26.815]             }
[13:17:26.815]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.815]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.815]         }
[13:17:26.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.815]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:26.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.815]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.815]             base::names(...future.oldOptions))
[13:17:26.815]     }
[13:17:26.815]     if (FALSE) {
[13:17:26.815]     }
[13:17:26.815]     else {
[13:17:26.815]         if (TRUE) {
[13:17:26.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.815]                 open = "w")
[13:17:26.815]         }
[13:17:26.815]         else {
[13:17:26.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.815]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.815]         }
[13:17:26.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.815]             base::sink(type = "output", split = FALSE)
[13:17:26.815]             base::close(...future.stdout)
[13:17:26.815]         }, add = TRUE)
[13:17:26.815]     }
[13:17:26.815]     ...future.frame <- base::sys.nframe()
[13:17:26.815]     ...future.conditions <- base::list()
[13:17:26.815]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.815]     if (FALSE) {
[13:17:26.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.815]     }
[13:17:26.815]     ...future.result <- base::tryCatch({
[13:17:26.815]         base::withCallingHandlers({
[13:17:26.815]             ...future.value <- base::withVisible(base::local({
[13:17:26.815]                 ...future.makeSendCondition <- local({
[13:17:26.815]                   sendCondition <- NULL
[13:17:26.815]                   function(frame = 1L) {
[13:17:26.815]                     if (is.function(sendCondition)) 
[13:17:26.815]                       return(sendCondition)
[13:17:26.815]                     ns <- getNamespace("parallel")
[13:17:26.815]                     if (exists("sendData", mode = "function", 
[13:17:26.815]                       envir = ns)) {
[13:17:26.815]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.815]                         envir = ns)
[13:17:26.815]                       envir <- sys.frame(frame)
[13:17:26.815]                       master <- NULL
[13:17:26.815]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.815]                         !identical(envir, emptyenv())) {
[13:17:26.815]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.815]                           inherits = FALSE)) {
[13:17:26.815]                           master <- get("master", mode = "list", 
[13:17:26.815]                             envir = envir, inherits = FALSE)
[13:17:26.815]                           if (inherits(master, c("SOCKnode", 
[13:17:26.815]                             "SOCK0node"))) {
[13:17:26.815]                             sendCondition <<- function(cond) {
[13:17:26.815]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.815]                                 success = TRUE)
[13:17:26.815]                               parallel_sendData(master, data)
[13:17:26.815]                             }
[13:17:26.815]                             return(sendCondition)
[13:17:26.815]                           }
[13:17:26.815]                         }
[13:17:26.815]                         frame <- frame + 1L
[13:17:26.815]                         envir <- sys.frame(frame)
[13:17:26.815]                       }
[13:17:26.815]                     }
[13:17:26.815]                     sendCondition <<- function(cond) NULL
[13:17:26.815]                   }
[13:17:26.815]                 })
[13:17:26.815]                 withCallingHandlers({
[13:17:26.815]                   {
[13:17:26.815]                     do.call(function(...) {
[13:17:26.815]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.815]                       if (!identical(...future.globals.maxSize.org, 
[13:17:26.815]                         ...future.globals.maxSize)) {
[13:17:26.815]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.815]                         on.exit(options(oopts), add = TRUE)
[13:17:26.815]                       }
[13:17:26.815]                       {
[13:17:26.815]                         lapply(seq_along(...future.elements_ii), 
[13:17:26.815]                           FUN = function(jj) {
[13:17:26.815]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.815]                             ...future.FUN(...future.X_jj, ...)
[13:17:26.815]                           })
[13:17:26.815]                       }
[13:17:26.815]                     }, args = future.call.arguments)
[13:17:26.815]                   }
[13:17:26.815]                 }, immediateCondition = function(cond) {
[13:17:26.815]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.815]                   sendCondition(cond)
[13:17:26.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.815]                   {
[13:17:26.815]                     inherits <- base::inherits
[13:17:26.815]                     invokeRestart <- base::invokeRestart
[13:17:26.815]                     is.null <- base::is.null
[13:17:26.815]                     muffled <- FALSE
[13:17:26.815]                     if (inherits(cond, "message")) {
[13:17:26.815]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.815]                       if (muffled) 
[13:17:26.815]                         invokeRestart("muffleMessage")
[13:17:26.815]                     }
[13:17:26.815]                     else if (inherits(cond, "warning")) {
[13:17:26.815]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.815]                       if (muffled) 
[13:17:26.815]                         invokeRestart("muffleWarning")
[13:17:26.815]                     }
[13:17:26.815]                     else if (inherits(cond, "condition")) {
[13:17:26.815]                       if (!is.null(pattern)) {
[13:17:26.815]                         computeRestarts <- base::computeRestarts
[13:17:26.815]                         grepl <- base::grepl
[13:17:26.815]                         restarts <- computeRestarts(cond)
[13:17:26.815]                         for (restart in restarts) {
[13:17:26.815]                           name <- restart$name
[13:17:26.815]                           if (is.null(name)) 
[13:17:26.815]                             next
[13:17:26.815]                           if (!grepl(pattern, name)) 
[13:17:26.815]                             next
[13:17:26.815]                           invokeRestart(restart)
[13:17:26.815]                           muffled <- TRUE
[13:17:26.815]                           break
[13:17:26.815]                         }
[13:17:26.815]                       }
[13:17:26.815]                     }
[13:17:26.815]                     invisible(muffled)
[13:17:26.815]                   }
[13:17:26.815]                   muffleCondition(cond)
[13:17:26.815]                 })
[13:17:26.815]             }))
[13:17:26.815]             future::FutureResult(value = ...future.value$value, 
[13:17:26.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.815]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.815]                     ...future.globalenv.names))
[13:17:26.815]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.815]         }, condition = base::local({
[13:17:26.815]             c <- base::c
[13:17:26.815]             inherits <- base::inherits
[13:17:26.815]             invokeRestart <- base::invokeRestart
[13:17:26.815]             length <- base::length
[13:17:26.815]             list <- base::list
[13:17:26.815]             seq.int <- base::seq.int
[13:17:26.815]             signalCondition <- base::signalCondition
[13:17:26.815]             sys.calls <- base::sys.calls
[13:17:26.815]             `[[` <- base::`[[`
[13:17:26.815]             `+` <- base::`+`
[13:17:26.815]             `<<-` <- base::`<<-`
[13:17:26.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.815]                   3L)]
[13:17:26.815]             }
[13:17:26.815]             function(cond) {
[13:17:26.815]                 is_error <- inherits(cond, "error")
[13:17:26.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.815]                   NULL)
[13:17:26.815]                 if (is_error) {
[13:17:26.815]                   sessionInformation <- function() {
[13:17:26.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.815]                       search = base::search(), system = base::Sys.info())
[13:17:26.815]                   }
[13:17:26.815]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.815]                     cond$call), session = sessionInformation(), 
[13:17:26.815]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.815]                   signalCondition(cond)
[13:17:26.815]                 }
[13:17:26.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.815]                 "immediateCondition"))) {
[13:17:26.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.815]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.815]                   if (TRUE && !signal) {
[13:17:26.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.815]                     {
[13:17:26.815]                       inherits <- base::inherits
[13:17:26.815]                       invokeRestart <- base::invokeRestart
[13:17:26.815]                       is.null <- base::is.null
[13:17:26.815]                       muffled <- FALSE
[13:17:26.815]                       if (inherits(cond, "message")) {
[13:17:26.815]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.815]                         if (muffled) 
[13:17:26.815]                           invokeRestart("muffleMessage")
[13:17:26.815]                       }
[13:17:26.815]                       else if (inherits(cond, "warning")) {
[13:17:26.815]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.815]                         if (muffled) 
[13:17:26.815]                           invokeRestart("muffleWarning")
[13:17:26.815]                       }
[13:17:26.815]                       else if (inherits(cond, "condition")) {
[13:17:26.815]                         if (!is.null(pattern)) {
[13:17:26.815]                           computeRestarts <- base::computeRestarts
[13:17:26.815]                           grepl <- base::grepl
[13:17:26.815]                           restarts <- computeRestarts(cond)
[13:17:26.815]                           for (restart in restarts) {
[13:17:26.815]                             name <- restart$name
[13:17:26.815]                             if (is.null(name)) 
[13:17:26.815]                               next
[13:17:26.815]                             if (!grepl(pattern, name)) 
[13:17:26.815]                               next
[13:17:26.815]                             invokeRestart(restart)
[13:17:26.815]                             muffled <- TRUE
[13:17:26.815]                             break
[13:17:26.815]                           }
[13:17:26.815]                         }
[13:17:26.815]                       }
[13:17:26.815]                       invisible(muffled)
[13:17:26.815]                     }
[13:17:26.815]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.815]                   }
[13:17:26.815]                 }
[13:17:26.815]                 else {
[13:17:26.815]                   if (TRUE) {
[13:17:26.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.815]                     {
[13:17:26.815]                       inherits <- base::inherits
[13:17:26.815]                       invokeRestart <- base::invokeRestart
[13:17:26.815]                       is.null <- base::is.null
[13:17:26.815]                       muffled <- FALSE
[13:17:26.815]                       if (inherits(cond, "message")) {
[13:17:26.815]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.815]                         if (muffled) 
[13:17:26.815]                           invokeRestart("muffleMessage")
[13:17:26.815]                       }
[13:17:26.815]                       else if (inherits(cond, "warning")) {
[13:17:26.815]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.815]                         if (muffled) 
[13:17:26.815]                           invokeRestart("muffleWarning")
[13:17:26.815]                       }
[13:17:26.815]                       else if (inherits(cond, "condition")) {
[13:17:26.815]                         if (!is.null(pattern)) {
[13:17:26.815]                           computeRestarts <- base::computeRestarts
[13:17:26.815]                           grepl <- base::grepl
[13:17:26.815]                           restarts <- computeRestarts(cond)
[13:17:26.815]                           for (restart in restarts) {
[13:17:26.815]                             name <- restart$name
[13:17:26.815]                             if (is.null(name)) 
[13:17:26.815]                               next
[13:17:26.815]                             if (!grepl(pattern, name)) 
[13:17:26.815]                               next
[13:17:26.815]                             invokeRestart(restart)
[13:17:26.815]                             muffled <- TRUE
[13:17:26.815]                             break
[13:17:26.815]                           }
[13:17:26.815]                         }
[13:17:26.815]                       }
[13:17:26.815]                       invisible(muffled)
[13:17:26.815]                     }
[13:17:26.815]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.815]                   }
[13:17:26.815]                 }
[13:17:26.815]             }
[13:17:26.815]         }))
[13:17:26.815]     }, error = function(ex) {
[13:17:26.815]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.815]                 ...future.rng), started = ...future.startTime, 
[13:17:26.815]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.815]             version = "1.8"), class = "FutureResult")
[13:17:26.815]     }, finally = {
[13:17:26.815]         if (!identical(...future.workdir, getwd())) 
[13:17:26.815]             setwd(...future.workdir)
[13:17:26.815]         {
[13:17:26.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.815]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.815]             }
[13:17:26.815]             base::options(...future.oldOptions)
[13:17:26.815]             if (.Platform$OS.type == "windows") {
[13:17:26.815]                 old_names <- names(...future.oldEnvVars)
[13:17:26.815]                 envs <- base::Sys.getenv()
[13:17:26.815]                 names <- names(envs)
[13:17:26.815]                 common <- intersect(names, old_names)
[13:17:26.815]                 added <- setdiff(names, old_names)
[13:17:26.815]                 removed <- setdiff(old_names, names)
[13:17:26.815]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.815]                   envs[common]]
[13:17:26.815]                 NAMES <- toupper(changed)
[13:17:26.815]                 args <- list()
[13:17:26.815]                 for (kk in seq_along(NAMES)) {
[13:17:26.815]                   name <- changed[[kk]]
[13:17:26.815]                   NAME <- NAMES[[kk]]
[13:17:26.815]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.815]                     next
[13:17:26.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.815]                 }
[13:17:26.815]                 NAMES <- toupper(added)
[13:17:26.815]                 for (kk in seq_along(NAMES)) {
[13:17:26.815]                   name <- added[[kk]]
[13:17:26.815]                   NAME <- NAMES[[kk]]
[13:17:26.815]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.815]                     next
[13:17:26.815]                   args[[name]] <- ""
[13:17:26.815]                 }
[13:17:26.815]                 NAMES <- toupper(removed)
[13:17:26.815]                 for (kk in seq_along(NAMES)) {
[13:17:26.815]                   name <- removed[[kk]]
[13:17:26.815]                   NAME <- NAMES[[kk]]
[13:17:26.815]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.815]                     next
[13:17:26.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.815]                 }
[13:17:26.815]                 if (length(args) > 0) 
[13:17:26.815]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.815]             }
[13:17:26.815]             else {
[13:17:26.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.815]             }
[13:17:26.815]             {
[13:17:26.815]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.815]                   0L) {
[13:17:26.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.815]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.815]                   base::options(opts)
[13:17:26.815]                 }
[13:17:26.815]                 {
[13:17:26.815]                   {
[13:17:26.815]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.815]                     NULL
[13:17:26.815]                   }
[13:17:26.815]                   options(future.plan = NULL)
[13:17:26.815]                   if (is.na(NA_character_)) 
[13:17:26.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.815]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.815]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.815]                     envir = parent.frame()) 
[13:17:26.815]                   {
[13:17:26.815]                     if (is.function(workers)) 
[13:17:26.815]                       workers <- workers()
[13:17:26.815]                     workers <- structure(as.integer(workers), 
[13:17:26.815]                       class = class(workers))
[13:17:26.815]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.815]                       workers >= 1)
[13:17:26.815]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.815]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.815]                     }
[13:17:26.815]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.815]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.815]                       envir = envir)
[13:17:26.815]                     if (!future$lazy) 
[13:17:26.815]                       future <- run(future)
[13:17:26.815]                     invisible(future)
[13:17:26.815]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.815]                 }
[13:17:26.815]             }
[13:17:26.815]         }
[13:17:26.815]     })
[13:17:26.815]     if (TRUE) {
[13:17:26.815]         base::sink(type = "output", split = FALSE)
[13:17:26.815]         if (TRUE) {
[13:17:26.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.815]         }
[13:17:26.815]         else {
[13:17:26.815]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.815]         }
[13:17:26.815]         base::close(...future.stdout)
[13:17:26.815]         ...future.stdout <- NULL
[13:17:26.815]     }
[13:17:26.815]     ...future.result$conditions <- ...future.conditions
[13:17:26.815]     ...future.result$finished <- base::Sys.time()
[13:17:26.815]     ...future.result
[13:17:26.815] }
[13:17:26.818] Exporting 5 global objects (346.00 KiB) to cluster node #2 ...
[13:17:26.819] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:26.819] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:26.819] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[13:17:26.861] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[13:17:26.861] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:17:26.862] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:17:26.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:26.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:26.863] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:26.863] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:26.863] Exporting 5 global objects (346.00 KiB) to cluster node #2 ... DONE
[13:17:26.864] MultisessionFuture started
[13:17:26.864] - Launch lazy future ... done
[13:17:26.864] run() for ‘MultisessionFuture’ ... done
[13:17:26.864] Created future:
[13:17:26.864] MultisessionFuture:
[13:17:26.864] Label: ‘future_apply-2’
[13:17:26.864] Expression:
[13:17:26.864] {
[13:17:26.864]     do.call(function(...) {
[13:17:26.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.864]             on.exit(options(oopts), add = TRUE)
[13:17:26.864]         }
[13:17:26.864]         {
[13:17:26.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.864]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.864]             })
[13:17:26.864]         }
[13:17:26.864]     }, args = future.call.arguments)
[13:17:26.864] }
[13:17:26.864] Lazy evaluation: FALSE
[13:17:26.864] Asynchronous evaluation: TRUE
[13:17:26.864] Local evaluation: TRUE
[13:17:26.864] Environment: R_GlobalEnv
[13:17:26.864] Capture standard output: TRUE
[13:17:26.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:26.864] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:26.864] Packages: <none>
[13:17:26.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:26.864] Resolved: FALSE
[13:17:26.864] Value: <not collected>
[13:17:26.864] Conditions captured: <none>
[13:17:26.864] Early signaling: FALSE
[13:17:26.864] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:26.864] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.876] Chunk #2 of 2 ... DONE
[13:17:26.876] Launching 2 futures (chunks) ... DONE
[13:17:26.876] Resolving 2 futures (chunks) ...
[13:17:26.876] resolve() on list ...
[13:17:26.876]  recursive: 0
[13:17:26.876]  length: 2
[13:17:26.877] 
[13:17:26.877] receiveMessageFromWorker() for ClusterFuture ...
[13:17:26.877] - Validating connection of MultisessionFuture
[13:17:26.877] - received message: FutureResult
[13:17:26.877] - Received FutureResult
[13:17:26.878] - Erased future from FutureRegistry
[13:17:26.878] result() for ClusterFuture ...
[13:17:26.878] - result already collected: FutureResult
[13:17:26.878] result() for ClusterFuture ... done
[13:17:26.878] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:26.878] Future #1
[13:17:26.878] result() for ClusterFuture ...
[13:17:26.878] - result already collected: FutureResult
[13:17:26.878] result() for ClusterFuture ... done
[13:17:26.878] result() for ClusterFuture ...
[13:17:26.878] - result already collected: FutureResult
[13:17:26.879] result() for ClusterFuture ... done
[13:17:26.879] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:26.879] - nx: 2
[13:17:26.879] - relay: TRUE
[13:17:26.879] - stdout: TRUE
[13:17:26.879] - signal: TRUE
[13:17:26.879] - resignal: FALSE
[13:17:26.879] - force: TRUE
[13:17:26.879] - relayed: [n=2] FALSE, FALSE
[13:17:26.879] - queued futures: [n=2] FALSE, FALSE
[13:17:26.880]  - until=1
[13:17:26.880]  - relaying element #1
[13:17:26.880] result() for ClusterFuture ...
[13:17:26.880] - result already collected: FutureResult
[13:17:26.880] result() for ClusterFuture ... done
[13:17:26.880] result() for ClusterFuture ...
[13:17:26.880] - result already collected: FutureResult
[13:17:26.880] result() for ClusterFuture ... done
[13:17:26.880] result() for ClusterFuture ...
[13:17:26.880] - result already collected: FutureResult
[13:17:26.880] result() for ClusterFuture ... done
[13:17:26.881] result() for ClusterFuture ...
[13:17:26.881] - result already collected: FutureResult
[13:17:26.881] result() for ClusterFuture ... done
[13:17:26.881] - relayed: [n=2] TRUE, FALSE
[13:17:26.881] - queued futures: [n=2] TRUE, FALSE
[13:17:26.881] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:26.883]  length: 1 (resolved future 1)
[13:17:26.910] receiveMessageFromWorker() for ClusterFuture ...
[13:17:26.910] - Validating connection of MultisessionFuture
[13:17:26.910] - received message: FutureResult
[13:17:26.910] - Received FutureResult
[13:17:26.910] - Erased future from FutureRegistry
[13:17:26.910] result() for ClusterFuture ...
[13:17:26.910] - result already collected: FutureResult
[13:17:26.910] result() for ClusterFuture ... done
[13:17:26.911] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:26.911] Future #2
[13:17:26.911] result() for ClusterFuture ...
[13:17:26.911] - result already collected: FutureResult
[13:17:26.911] result() for ClusterFuture ... done
[13:17:26.911] result() for ClusterFuture ...
[13:17:26.911] - result already collected: FutureResult
[13:17:26.911] result() for ClusterFuture ... done
[13:17:26.911] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:26.911] - nx: 2
[13:17:26.911] - relay: TRUE
[13:17:26.912] - stdout: TRUE
[13:17:26.912] - signal: TRUE
[13:17:26.912] - resignal: FALSE
[13:17:26.912] - force: TRUE
[13:17:26.912] - relayed: [n=2] TRUE, FALSE
[13:17:26.912] - queued futures: [n=2] TRUE, FALSE
[13:17:26.912]  - until=2
[13:17:26.912]  - relaying element #2
[13:17:26.912] result() for ClusterFuture ...
[13:17:26.912] - result already collected: FutureResult
[13:17:26.912] result() for ClusterFuture ... done
[13:17:26.912] result() for ClusterFuture ...
[13:17:26.913] - result already collected: FutureResult
[13:17:26.913] result() for ClusterFuture ... done
[13:17:26.913] result() for ClusterFuture ...
[13:17:26.913] - result already collected: FutureResult
[13:17:26.913] result() for ClusterFuture ... done
[13:17:26.913] result() for ClusterFuture ...
[13:17:26.913] - result already collected: FutureResult
[13:17:26.913] result() for ClusterFuture ... done
[13:17:26.913] - relayed: [n=2] TRUE, TRUE
[13:17:26.913] - queued futures: [n=2] TRUE, TRUE
[13:17:26.914] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:26.914]  length: 0 (resolved future 2)
[13:17:26.914] Relaying remaining futures
[13:17:26.914] signalConditionsASAP(NULL, pos=0) ...
[13:17:26.914] - nx: 2
[13:17:26.914] - relay: TRUE
[13:17:26.914] - stdout: TRUE
[13:17:26.914] - signal: TRUE
[13:17:26.914] - resignal: FALSE
[13:17:26.914] - force: TRUE
[13:17:26.914] - relayed: [n=2] TRUE, TRUE
[13:17:26.915] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:26.915] - relayed: [n=2] TRUE, TRUE
[13:17:26.915] - queued futures: [n=2] TRUE, TRUE
[13:17:26.915] signalConditionsASAP(NULL, pos=0) ... done
[13:17:26.915] resolve() on list ... DONE
[13:17:26.915] result() for ClusterFuture ...
[13:17:26.915] - result already collected: FutureResult
[13:17:26.915] result() for ClusterFuture ... done
[13:17:26.915] result() for ClusterFuture ...
[13:17:26.915] - result already collected: FutureResult
[13:17:26.915] result() for ClusterFuture ... done
[13:17:26.916] result() for ClusterFuture ...
[13:17:26.916] - result already collected: FutureResult
[13:17:26.916] result() for ClusterFuture ... done
[13:17:26.916] result() for ClusterFuture ...
[13:17:26.916] - result already collected: FutureResult
[13:17:26.916] result() for ClusterFuture ... done
[13:17:26.916]  - Number of value chunks collected: 2
[13:17:26.916] Resolving 2 futures (chunks) ... DONE
[13:17:26.916] Reducing values from 2 chunks ...
[13:17:26.916]  - Number of values collected after concatenation: 2
[13:17:26.916]  - Number of values expected: 2
[13:17:26.917] Reducing values from 2 chunks ... DONE
[13:17:26.917] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[13:17:26.917] getGlobalsAndPackagesXApply() ...
[13:17:26.918]  - future.globals: TRUE
[13:17:26.918] getGlobalsAndPackages() ...
[13:17:26.918] Searching for globals...
[13:17:26.919] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:17:26.919] Searching for globals ... DONE
[13:17:26.919] Resolving globals: FALSE
[13:17:26.919] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:17:26.920] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:17:26.920] - globals: [1] ‘FUN’
[13:17:26.920] - packages: [1] ‘stats’
[13:17:26.920] getGlobalsAndPackages() ... DONE
[13:17:26.920]  - globals found/used: [n=1] ‘FUN’
[13:17:26.920]  - needed namespaces: [n=1] ‘stats’
[13:17:26.920] Finding globals ... DONE
[13:17:26.921]  - use_args: TRUE
[13:17:26.921]  - Getting '...' globals ...
[13:17:26.921] resolve() on list ...
[13:17:26.921]  recursive: 0
[13:17:26.921]  length: 1
[13:17:26.921]  elements: ‘...’
[13:17:26.921]  length: 0 (resolved future 1)
[13:17:26.922] resolve() on list ... DONE
[13:17:26.922]    - '...' content: [n=0] 
[13:17:26.922] List of 1
[13:17:26.922]  $ ...: list()
[13:17:26.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.922]  - attr(*, "where")=List of 1
[13:17:26.922]   ..$ ...:<environment: 0x5647bb04b0c0> 
[13:17:26.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.922]  - attr(*, "resolved")= logi TRUE
[13:17:26.922]  - attr(*, "total_size")= num NA
[13:17:26.924]  - Getting '...' globals ... DONE
[13:17:26.924] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:26.925] List of 2
[13:17:26.925]  $ ...future.FUN:function (x, ...)  
[13:17:26.925]  $ ...          : list()
[13:17:26.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.925]  - attr(*, "where")=List of 2
[13:17:26.925]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:26.925]   ..$ ...          :<environment: 0x5647bb04b0c0> 
[13:17:26.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.925]  - attr(*, "resolved")= logi FALSE
[13:17:26.925]  - attr(*, "total_size")= num 1248
[13:17:26.927] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:26.927] getGlobalsAndPackagesXApply() ... DONE
[13:17:26.931] future_lapply() ...
[13:17:26.934] Number of chunks: 2
[13:17:26.935] getGlobalsAndPackagesXApply() ...
[13:17:26.935]  - future.globals: <name-value list> with names ‘list()’
[13:17:26.935]  - use_args: TRUE
[13:17:26.935] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:26.935] List of 2
[13:17:26.935]  $ ...          : list()
[13:17:26.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:26.935]  $ ...future.FUN:function (x, ...)  
[13:17:26.935]  - attr(*, "where")=List of 2
[13:17:26.935]   ..$ ...          :<environment: 0x5647bb04b0c0> 
[13:17:26.935]   ..$ ...future.FUN:<environment: namespace:stats> 
[13:17:26.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:26.935]  - attr(*, "resolved")= logi FALSE
[13:17:26.935]  - attr(*, "total_size")= num NA
[13:17:26.938] Packages to be attached in all futures: [n=1] ‘stats’
[13:17:26.938] getGlobalsAndPackagesXApply() ... DONE
[13:17:26.938] Number of futures (= number of chunks): 2
[13:17:26.938] Launching 2 futures (chunks) ...
[13:17:26.939] Chunk #1 of 2 ...
[13:17:26.939]  - seeds: <none>
[13:17:26.939] getGlobalsAndPackages() ...
[13:17:26.939] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.939] Resolving globals: FALSE
[13:17:26.939] Tweak future expression to call with '...' arguments ...
[13:17:26.939] {
[13:17:26.939]     do.call(function(...) {
[13:17:26.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.939]             on.exit(options(oopts), add = TRUE)
[13:17:26.939]         }
[13:17:26.939]         {
[13:17:26.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.939]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.939]             })
[13:17:26.939]         }
[13:17:26.939]     }, args = future.call.arguments)
[13:17:26.939] }
[13:17:26.939] Tweak future expression to call with '...' arguments ... DONE
[13:17:26.940] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.940] - packages: [1] ‘stats’
[13:17:26.940] getGlobalsAndPackages() ... DONE
[13:17:26.940] run() for ‘Future’ ...
[13:17:26.940] - state: ‘created’
[13:17:26.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:26.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:26.955]   - Field: ‘node’
[13:17:26.955]   - Field: ‘label’
[13:17:26.955]   - Field: ‘local’
[13:17:26.955]   - Field: ‘owner’
[13:17:26.955]   - Field: ‘envir’
[13:17:26.955]   - Field: ‘workers’
[13:17:26.956]   - Field: ‘packages’
[13:17:26.956]   - Field: ‘gc’
[13:17:26.956]   - Field: ‘conditions’
[13:17:26.956]   - Field: ‘persistent’
[13:17:26.956]   - Field: ‘expr’
[13:17:26.956]   - Field: ‘uuid’
[13:17:26.956]   - Field: ‘seed’
[13:17:26.956]   - Field: ‘version’
[13:17:26.956]   - Field: ‘result’
[13:17:26.956]   - Field: ‘asynchronous’
[13:17:26.956]   - Field: ‘calls’
[13:17:26.957]   - Field: ‘globals’
[13:17:26.957]   - Field: ‘stdout’
[13:17:26.957]   - Field: ‘earlySignal’
[13:17:26.957]   - Field: ‘lazy’
[13:17:26.957]   - Field: ‘state’
[13:17:26.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:26.957] - Launch lazy future ...
[13:17:26.957] Packages needed by the future expression (n = 1): ‘stats’
[13:17:26.958] Packages needed by future strategies (n = 0): <none>
[13:17:26.958] {
[13:17:26.958]     {
[13:17:26.958]         {
[13:17:26.958]             ...future.startTime <- base::Sys.time()
[13:17:26.958]             {
[13:17:26.958]                 {
[13:17:26.958]                   {
[13:17:26.958]                     {
[13:17:26.958]                       {
[13:17:26.958]                         base::local({
[13:17:26.958]                           has_future <- base::requireNamespace("future", 
[13:17:26.958]                             quietly = TRUE)
[13:17:26.958]                           if (has_future) {
[13:17:26.958]                             ns <- base::getNamespace("future")
[13:17:26.958]                             version <- ns[[".package"]][["version"]]
[13:17:26.958]                             if (is.null(version)) 
[13:17:26.958]                               version <- utils::packageVersion("future")
[13:17:26.958]                           }
[13:17:26.958]                           else {
[13:17:26.958]                             version <- NULL
[13:17:26.958]                           }
[13:17:26.958]                           if (!has_future || version < "1.8.0") {
[13:17:26.958]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.958]                               "", base::R.version$version.string), 
[13:17:26.958]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:26.958]                                 base::R.version$platform, 8 * 
[13:17:26.958]                                   base::.Machine$sizeof.pointer), 
[13:17:26.958]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.958]                                 "release", "version")], collapse = " "), 
[13:17:26.958]                               hostname = base::Sys.info()[["nodename"]])
[13:17:26.958]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.958]                               info)
[13:17:26.958]                             info <- base::paste(info, collapse = "; ")
[13:17:26.958]                             if (!has_future) {
[13:17:26.958]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.958]                                 info)
[13:17:26.958]                             }
[13:17:26.958]                             else {
[13:17:26.958]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.958]                                 info, version)
[13:17:26.958]                             }
[13:17:26.958]                             base::stop(msg)
[13:17:26.958]                           }
[13:17:26.958]                         })
[13:17:26.958]                       }
[13:17:26.958]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.958]                       base::options(mc.cores = 1L)
[13:17:26.958]                     }
[13:17:26.958]                     base::local({
[13:17:26.958]                       for (pkg in "stats") {
[13:17:26.958]                         base::loadNamespace(pkg)
[13:17:26.958]                         base::library(pkg, character.only = TRUE)
[13:17:26.958]                       }
[13:17:26.958]                     })
[13:17:26.958]                   }
[13:17:26.958]                   options(future.plan = NULL)
[13:17:26.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.958]                 }
[13:17:26.958]                 ...future.workdir <- getwd()
[13:17:26.958]             }
[13:17:26.958]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.958]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.958]         }
[13:17:26.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.958]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:26.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.958]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.958]             base::names(...future.oldOptions))
[13:17:26.958]     }
[13:17:26.958]     if (FALSE) {
[13:17:26.958]     }
[13:17:26.958]     else {
[13:17:26.958]         if (TRUE) {
[13:17:26.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.958]                 open = "w")
[13:17:26.958]         }
[13:17:26.958]         else {
[13:17:26.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.958]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.958]         }
[13:17:26.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.958]             base::sink(type = "output", split = FALSE)
[13:17:26.958]             base::close(...future.stdout)
[13:17:26.958]         }, add = TRUE)
[13:17:26.958]     }
[13:17:26.958]     ...future.frame <- base::sys.nframe()
[13:17:26.958]     ...future.conditions <- base::list()
[13:17:26.958]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.958]     if (FALSE) {
[13:17:26.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.958]     }
[13:17:26.958]     ...future.result <- base::tryCatch({
[13:17:26.958]         base::withCallingHandlers({
[13:17:26.958]             ...future.value <- base::withVisible(base::local({
[13:17:26.958]                 ...future.makeSendCondition <- local({
[13:17:26.958]                   sendCondition <- NULL
[13:17:26.958]                   function(frame = 1L) {
[13:17:26.958]                     if (is.function(sendCondition)) 
[13:17:26.958]                       return(sendCondition)
[13:17:26.958]                     ns <- getNamespace("parallel")
[13:17:26.958]                     if (exists("sendData", mode = "function", 
[13:17:26.958]                       envir = ns)) {
[13:17:26.958]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.958]                         envir = ns)
[13:17:26.958]                       envir <- sys.frame(frame)
[13:17:26.958]                       master <- NULL
[13:17:26.958]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.958]                         !identical(envir, emptyenv())) {
[13:17:26.958]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.958]                           inherits = FALSE)) {
[13:17:26.958]                           master <- get("master", mode = "list", 
[13:17:26.958]                             envir = envir, inherits = FALSE)
[13:17:26.958]                           if (inherits(master, c("SOCKnode", 
[13:17:26.958]                             "SOCK0node"))) {
[13:17:26.958]                             sendCondition <<- function(cond) {
[13:17:26.958]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.958]                                 success = TRUE)
[13:17:26.958]                               parallel_sendData(master, data)
[13:17:26.958]                             }
[13:17:26.958]                             return(sendCondition)
[13:17:26.958]                           }
[13:17:26.958]                         }
[13:17:26.958]                         frame <- frame + 1L
[13:17:26.958]                         envir <- sys.frame(frame)
[13:17:26.958]                       }
[13:17:26.958]                     }
[13:17:26.958]                     sendCondition <<- function(cond) NULL
[13:17:26.958]                   }
[13:17:26.958]                 })
[13:17:26.958]                 withCallingHandlers({
[13:17:26.958]                   {
[13:17:26.958]                     do.call(function(...) {
[13:17:26.958]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.958]                       if (!identical(...future.globals.maxSize.org, 
[13:17:26.958]                         ...future.globals.maxSize)) {
[13:17:26.958]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.958]                         on.exit(options(oopts), add = TRUE)
[13:17:26.958]                       }
[13:17:26.958]                       {
[13:17:26.958]                         lapply(seq_along(...future.elements_ii), 
[13:17:26.958]                           FUN = function(jj) {
[13:17:26.958]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.958]                             ...future.FUN(...future.X_jj, ...)
[13:17:26.958]                           })
[13:17:26.958]                       }
[13:17:26.958]                     }, args = future.call.arguments)
[13:17:26.958]                   }
[13:17:26.958]                 }, immediateCondition = function(cond) {
[13:17:26.958]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.958]                   sendCondition(cond)
[13:17:26.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.958]                   {
[13:17:26.958]                     inherits <- base::inherits
[13:17:26.958]                     invokeRestart <- base::invokeRestart
[13:17:26.958]                     is.null <- base::is.null
[13:17:26.958]                     muffled <- FALSE
[13:17:26.958]                     if (inherits(cond, "message")) {
[13:17:26.958]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.958]                       if (muffled) 
[13:17:26.958]                         invokeRestart("muffleMessage")
[13:17:26.958]                     }
[13:17:26.958]                     else if (inherits(cond, "warning")) {
[13:17:26.958]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.958]                       if (muffled) 
[13:17:26.958]                         invokeRestart("muffleWarning")
[13:17:26.958]                     }
[13:17:26.958]                     else if (inherits(cond, "condition")) {
[13:17:26.958]                       if (!is.null(pattern)) {
[13:17:26.958]                         computeRestarts <- base::computeRestarts
[13:17:26.958]                         grepl <- base::grepl
[13:17:26.958]                         restarts <- computeRestarts(cond)
[13:17:26.958]                         for (restart in restarts) {
[13:17:26.958]                           name <- restart$name
[13:17:26.958]                           if (is.null(name)) 
[13:17:26.958]                             next
[13:17:26.958]                           if (!grepl(pattern, name)) 
[13:17:26.958]                             next
[13:17:26.958]                           invokeRestart(restart)
[13:17:26.958]                           muffled <- TRUE
[13:17:26.958]                           break
[13:17:26.958]                         }
[13:17:26.958]                       }
[13:17:26.958]                     }
[13:17:26.958]                     invisible(muffled)
[13:17:26.958]                   }
[13:17:26.958]                   muffleCondition(cond)
[13:17:26.958]                 })
[13:17:26.958]             }))
[13:17:26.958]             future::FutureResult(value = ...future.value$value, 
[13:17:26.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.958]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.958]                     ...future.globalenv.names))
[13:17:26.958]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.958]         }, condition = base::local({
[13:17:26.958]             c <- base::c
[13:17:26.958]             inherits <- base::inherits
[13:17:26.958]             invokeRestart <- base::invokeRestart
[13:17:26.958]             length <- base::length
[13:17:26.958]             list <- base::list
[13:17:26.958]             seq.int <- base::seq.int
[13:17:26.958]             signalCondition <- base::signalCondition
[13:17:26.958]             sys.calls <- base::sys.calls
[13:17:26.958]             `[[` <- base::`[[`
[13:17:26.958]             `+` <- base::`+`
[13:17:26.958]             `<<-` <- base::`<<-`
[13:17:26.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.958]                   3L)]
[13:17:26.958]             }
[13:17:26.958]             function(cond) {
[13:17:26.958]                 is_error <- inherits(cond, "error")
[13:17:26.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.958]                   NULL)
[13:17:26.958]                 if (is_error) {
[13:17:26.958]                   sessionInformation <- function() {
[13:17:26.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.958]                       search = base::search(), system = base::Sys.info())
[13:17:26.958]                   }
[13:17:26.958]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.958]                     cond$call), session = sessionInformation(), 
[13:17:26.958]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.958]                   signalCondition(cond)
[13:17:26.958]                 }
[13:17:26.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.958]                 "immediateCondition"))) {
[13:17:26.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.958]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.958]                   if (TRUE && !signal) {
[13:17:26.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.958]                     {
[13:17:26.958]                       inherits <- base::inherits
[13:17:26.958]                       invokeRestart <- base::invokeRestart
[13:17:26.958]                       is.null <- base::is.null
[13:17:26.958]                       muffled <- FALSE
[13:17:26.958]                       if (inherits(cond, "message")) {
[13:17:26.958]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.958]                         if (muffled) 
[13:17:26.958]                           invokeRestart("muffleMessage")
[13:17:26.958]                       }
[13:17:26.958]                       else if (inherits(cond, "warning")) {
[13:17:26.958]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.958]                         if (muffled) 
[13:17:26.958]                           invokeRestart("muffleWarning")
[13:17:26.958]                       }
[13:17:26.958]                       else if (inherits(cond, "condition")) {
[13:17:26.958]                         if (!is.null(pattern)) {
[13:17:26.958]                           computeRestarts <- base::computeRestarts
[13:17:26.958]                           grepl <- base::grepl
[13:17:26.958]                           restarts <- computeRestarts(cond)
[13:17:26.958]                           for (restart in restarts) {
[13:17:26.958]                             name <- restart$name
[13:17:26.958]                             if (is.null(name)) 
[13:17:26.958]                               next
[13:17:26.958]                             if (!grepl(pattern, name)) 
[13:17:26.958]                               next
[13:17:26.958]                             invokeRestart(restart)
[13:17:26.958]                             muffled <- TRUE
[13:17:26.958]                             break
[13:17:26.958]                           }
[13:17:26.958]                         }
[13:17:26.958]                       }
[13:17:26.958]                       invisible(muffled)
[13:17:26.958]                     }
[13:17:26.958]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.958]                   }
[13:17:26.958]                 }
[13:17:26.958]                 else {
[13:17:26.958]                   if (TRUE) {
[13:17:26.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.958]                     {
[13:17:26.958]                       inherits <- base::inherits
[13:17:26.958]                       invokeRestart <- base::invokeRestart
[13:17:26.958]                       is.null <- base::is.null
[13:17:26.958]                       muffled <- FALSE
[13:17:26.958]                       if (inherits(cond, "message")) {
[13:17:26.958]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.958]                         if (muffled) 
[13:17:26.958]                           invokeRestart("muffleMessage")
[13:17:26.958]                       }
[13:17:26.958]                       else if (inherits(cond, "warning")) {
[13:17:26.958]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.958]                         if (muffled) 
[13:17:26.958]                           invokeRestart("muffleWarning")
[13:17:26.958]                       }
[13:17:26.958]                       else if (inherits(cond, "condition")) {
[13:17:26.958]                         if (!is.null(pattern)) {
[13:17:26.958]                           computeRestarts <- base::computeRestarts
[13:17:26.958]                           grepl <- base::grepl
[13:17:26.958]                           restarts <- computeRestarts(cond)
[13:17:26.958]                           for (restart in restarts) {
[13:17:26.958]                             name <- restart$name
[13:17:26.958]                             if (is.null(name)) 
[13:17:26.958]                               next
[13:17:26.958]                             if (!grepl(pattern, name)) 
[13:17:26.958]                               next
[13:17:26.958]                             invokeRestart(restart)
[13:17:26.958]                             muffled <- TRUE
[13:17:26.958]                             break
[13:17:26.958]                           }
[13:17:26.958]                         }
[13:17:26.958]                       }
[13:17:26.958]                       invisible(muffled)
[13:17:26.958]                     }
[13:17:26.958]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.958]                   }
[13:17:26.958]                 }
[13:17:26.958]             }
[13:17:26.958]         }))
[13:17:26.958]     }, error = function(ex) {
[13:17:26.958]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.958]                 ...future.rng), started = ...future.startTime, 
[13:17:26.958]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.958]             version = "1.8"), class = "FutureResult")
[13:17:26.958]     }, finally = {
[13:17:26.958]         if (!identical(...future.workdir, getwd())) 
[13:17:26.958]             setwd(...future.workdir)
[13:17:26.958]         {
[13:17:26.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.958]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.958]             }
[13:17:26.958]             base::options(...future.oldOptions)
[13:17:26.958]             if (.Platform$OS.type == "windows") {
[13:17:26.958]                 old_names <- names(...future.oldEnvVars)
[13:17:26.958]                 envs <- base::Sys.getenv()
[13:17:26.958]                 names <- names(envs)
[13:17:26.958]                 common <- intersect(names, old_names)
[13:17:26.958]                 added <- setdiff(names, old_names)
[13:17:26.958]                 removed <- setdiff(old_names, names)
[13:17:26.958]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.958]                   envs[common]]
[13:17:26.958]                 NAMES <- toupper(changed)
[13:17:26.958]                 args <- list()
[13:17:26.958]                 for (kk in seq_along(NAMES)) {
[13:17:26.958]                   name <- changed[[kk]]
[13:17:26.958]                   NAME <- NAMES[[kk]]
[13:17:26.958]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.958]                     next
[13:17:26.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.958]                 }
[13:17:26.958]                 NAMES <- toupper(added)
[13:17:26.958]                 for (kk in seq_along(NAMES)) {
[13:17:26.958]                   name <- added[[kk]]
[13:17:26.958]                   NAME <- NAMES[[kk]]
[13:17:26.958]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.958]                     next
[13:17:26.958]                   args[[name]] <- ""
[13:17:26.958]                 }
[13:17:26.958]                 NAMES <- toupper(removed)
[13:17:26.958]                 for (kk in seq_along(NAMES)) {
[13:17:26.958]                   name <- removed[[kk]]
[13:17:26.958]                   NAME <- NAMES[[kk]]
[13:17:26.958]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.958]                     next
[13:17:26.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.958]                 }
[13:17:26.958]                 if (length(args) > 0) 
[13:17:26.958]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.958]             }
[13:17:26.958]             else {
[13:17:26.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.958]             }
[13:17:26.958]             {
[13:17:26.958]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.958]                   0L) {
[13:17:26.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.958]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.958]                   base::options(opts)
[13:17:26.958]                 }
[13:17:26.958]                 {
[13:17:26.958]                   {
[13:17:26.958]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.958]                     NULL
[13:17:26.958]                   }
[13:17:26.958]                   options(future.plan = NULL)
[13:17:26.958]                   if (is.na(NA_character_)) 
[13:17:26.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.958]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.958]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.958]                     envir = parent.frame()) 
[13:17:26.958]                   {
[13:17:26.958]                     if (is.function(workers)) 
[13:17:26.958]                       workers <- workers()
[13:17:26.958]                     workers <- structure(as.integer(workers), 
[13:17:26.958]                       class = class(workers))
[13:17:26.958]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.958]                       workers >= 1)
[13:17:26.958]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.958]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.958]                     }
[13:17:26.958]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.958]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.958]                       envir = envir)
[13:17:26.958]                     if (!future$lazy) 
[13:17:26.958]                       future <- run(future)
[13:17:26.958]                     invisible(future)
[13:17:26.958]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.958]                 }
[13:17:26.958]             }
[13:17:26.958]         }
[13:17:26.958]     })
[13:17:26.958]     if (TRUE) {
[13:17:26.958]         base::sink(type = "output", split = FALSE)
[13:17:26.958]         if (TRUE) {
[13:17:26.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.958]         }
[13:17:26.958]         else {
[13:17:26.958]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.958]         }
[13:17:26.958]         base::close(...future.stdout)
[13:17:26.958]         ...future.stdout <- NULL
[13:17:26.958]     }
[13:17:26.958]     ...future.result$conditions <- ...future.conditions
[13:17:26.958]     ...future.result$finished <- base::Sys.time()
[13:17:26.958]     ...future.result
[13:17:26.958] }
[13:17:26.961] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[13:17:26.961] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:26.962] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.962] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:17:26.962] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:17:26.962] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[13:17:26.963] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[13:17:26.963] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:26.963] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.963] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:26.964] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:26.964] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[13:17:26.964] MultisessionFuture started
[13:17:26.964] - Launch lazy future ... done
[13:17:26.964] run() for ‘MultisessionFuture’ ... done
[13:17:26.965] Created future:
[13:17:26.965] MultisessionFuture:
[13:17:26.965] Label: ‘future_apply-1’
[13:17:26.965] Expression:
[13:17:26.965] {
[13:17:26.965]     do.call(function(...) {
[13:17:26.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.965]             on.exit(options(oopts), add = TRUE)
[13:17:26.965]         }
[13:17:26.965]         {
[13:17:26.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.965]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.965]             })
[13:17:26.965]         }
[13:17:26.965]     }, args = future.call.arguments)
[13:17:26.965] }
[13:17:26.965] Lazy evaluation: FALSE
[13:17:26.965] Asynchronous evaluation: TRUE
[13:17:26.965] Local evaluation: TRUE
[13:17:26.965] Environment: R_GlobalEnv
[13:17:26.965] Capture standard output: TRUE
[13:17:26.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:26.965] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:26.965] Packages: 1 packages (‘stats’)
[13:17:26.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:26.965] Resolved: FALSE
[13:17:26.965] Value: <not collected>
[13:17:26.965] Conditions captured: <none>
[13:17:26.965] Early signaling: FALSE
[13:17:26.965] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:26.965] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.976] Chunk #1 of 2 ... DONE
[13:17:26.976] Chunk #2 of 2 ...
[13:17:26.976]  - seeds: <none>
[13:17:26.977] getGlobalsAndPackages() ...
[13:17:26.977] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.977] Resolving globals: FALSE
[13:17:26.977] Tweak future expression to call with '...' arguments ...
[13:17:26.977] {
[13:17:26.977]     do.call(function(...) {
[13:17:26.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:26.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.977]             on.exit(options(oopts), add = TRUE)
[13:17:26.977]         }
[13:17:26.977]         {
[13:17:26.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:26.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.977]                 ...future.FUN(...future.X_jj, ...)
[13:17:26.977]             })
[13:17:26.977]         }
[13:17:26.977]     }, args = future.call.arguments)
[13:17:26.977] }
[13:17:26.977] Tweak future expression to call with '...' arguments ... DONE
[13:17:26.978] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:26.978] - packages: [1] ‘stats’
[13:17:26.978] getGlobalsAndPackages() ... DONE
[13:17:26.978] run() for ‘Future’ ...
[13:17:26.978] - state: ‘created’
[13:17:26.979] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:26.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:26.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:26.993]   - Field: ‘node’
[13:17:26.993]   - Field: ‘label’
[13:17:26.993]   - Field: ‘local’
[13:17:26.993]   - Field: ‘owner’
[13:17:26.994]   - Field: ‘envir’
[13:17:26.994]   - Field: ‘workers’
[13:17:26.994]   - Field: ‘packages’
[13:17:26.994]   - Field: ‘gc’
[13:17:26.994]   - Field: ‘conditions’
[13:17:26.994]   - Field: ‘persistent’
[13:17:26.994]   - Field: ‘expr’
[13:17:26.994]   - Field: ‘uuid’
[13:17:26.994]   - Field: ‘seed’
[13:17:26.994]   - Field: ‘version’
[13:17:26.994]   - Field: ‘result’
[13:17:26.995]   - Field: ‘asynchronous’
[13:17:26.995]   - Field: ‘calls’
[13:17:26.995]   - Field: ‘globals’
[13:17:26.995]   - Field: ‘stdout’
[13:17:26.995]   - Field: ‘earlySignal’
[13:17:26.995]   - Field: ‘lazy’
[13:17:26.995]   - Field: ‘state’
[13:17:26.995] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:26.995] - Launch lazy future ...
[13:17:26.996] Packages needed by the future expression (n = 1): ‘stats’
[13:17:26.996] Packages needed by future strategies (n = 0): <none>
[13:17:26.996] {
[13:17:26.996]     {
[13:17:26.996]         {
[13:17:26.996]             ...future.startTime <- base::Sys.time()
[13:17:26.996]             {
[13:17:26.996]                 {
[13:17:26.996]                   {
[13:17:26.996]                     {
[13:17:26.996]                       {
[13:17:26.996]                         base::local({
[13:17:26.996]                           has_future <- base::requireNamespace("future", 
[13:17:26.996]                             quietly = TRUE)
[13:17:26.996]                           if (has_future) {
[13:17:26.996]                             ns <- base::getNamespace("future")
[13:17:26.996]                             version <- ns[[".package"]][["version"]]
[13:17:26.996]                             if (is.null(version)) 
[13:17:26.996]                               version <- utils::packageVersion("future")
[13:17:26.996]                           }
[13:17:26.996]                           else {
[13:17:26.996]                             version <- NULL
[13:17:26.996]                           }
[13:17:26.996]                           if (!has_future || version < "1.8.0") {
[13:17:26.996]                             info <- base::c(r_version = base::gsub("R version ", 
[13:17:26.996]                               "", base::R.version$version.string), 
[13:17:26.996]                               platform = base::sprintf("%s (%s-bit)", 
[13:17:26.996]                                 base::R.version$platform, 8 * 
[13:17:26.996]                                   base::.Machine$sizeof.pointer), 
[13:17:26.996]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:26.996]                                 "release", "version")], collapse = " "), 
[13:17:26.996]                               hostname = base::Sys.info()[["nodename"]])
[13:17:26.996]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:17:26.996]                               info)
[13:17:26.996]                             info <- base::paste(info, collapse = "; ")
[13:17:26.996]                             if (!has_future) {
[13:17:26.996]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:26.996]                                 info)
[13:17:26.996]                             }
[13:17:26.996]                             else {
[13:17:26.996]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:26.996]                                 info, version)
[13:17:26.996]                             }
[13:17:26.996]                             base::stop(msg)
[13:17:26.996]                           }
[13:17:26.996]                         })
[13:17:26.996]                       }
[13:17:26.996]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:26.996]                       base::options(mc.cores = 1L)
[13:17:26.996]                     }
[13:17:26.996]                     base::local({
[13:17:26.996]                       for (pkg in "stats") {
[13:17:26.996]                         base::loadNamespace(pkg)
[13:17:26.996]                         base::library(pkg, character.only = TRUE)
[13:17:26.996]                       }
[13:17:26.996]                     })
[13:17:26.996]                   }
[13:17:26.996]                   options(future.plan = NULL)
[13:17:26.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:26.996]                 }
[13:17:26.996]                 ...future.workdir <- getwd()
[13:17:26.996]             }
[13:17:26.996]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:26.996]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:26.996]         }
[13:17:26.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:26.996]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:26.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:26.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:26.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:26.996]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:26.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:26.996]             base::names(...future.oldOptions))
[13:17:26.996]     }
[13:17:26.996]     if (FALSE) {
[13:17:26.996]     }
[13:17:26.996]     else {
[13:17:26.996]         if (TRUE) {
[13:17:26.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:26.996]                 open = "w")
[13:17:26.996]         }
[13:17:26.996]         else {
[13:17:26.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:26.996]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:26.996]         }
[13:17:26.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:26.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:26.996]             base::sink(type = "output", split = FALSE)
[13:17:26.996]             base::close(...future.stdout)
[13:17:26.996]         }, add = TRUE)
[13:17:26.996]     }
[13:17:26.996]     ...future.frame <- base::sys.nframe()
[13:17:26.996]     ...future.conditions <- base::list()
[13:17:26.996]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:26.996]     if (FALSE) {
[13:17:26.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:26.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:26.996]     }
[13:17:26.996]     ...future.result <- base::tryCatch({
[13:17:26.996]         base::withCallingHandlers({
[13:17:26.996]             ...future.value <- base::withVisible(base::local({
[13:17:26.996]                 ...future.makeSendCondition <- local({
[13:17:26.996]                   sendCondition <- NULL
[13:17:26.996]                   function(frame = 1L) {
[13:17:26.996]                     if (is.function(sendCondition)) 
[13:17:26.996]                       return(sendCondition)
[13:17:26.996]                     ns <- getNamespace("parallel")
[13:17:26.996]                     if (exists("sendData", mode = "function", 
[13:17:26.996]                       envir = ns)) {
[13:17:26.996]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:26.996]                         envir = ns)
[13:17:26.996]                       envir <- sys.frame(frame)
[13:17:26.996]                       master <- NULL
[13:17:26.996]                       while (!identical(envir, .GlobalEnv) && 
[13:17:26.996]                         !identical(envir, emptyenv())) {
[13:17:26.996]                         if (exists("master", mode = "list", envir = envir, 
[13:17:26.996]                           inherits = FALSE)) {
[13:17:26.996]                           master <- get("master", mode = "list", 
[13:17:26.996]                             envir = envir, inherits = FALSE)
[13:17:26.996]                           if (inherits(master, c("SOCKnode", 
[13:17:26.996]                             "SOCK0node"))) {
[13:17:26.996]                             sendCondition <<- function(cond) {
[13:17:26.996]                               data <- list(type = "VALUE", value = cond, 
[13:17:26.996]                                 success = TRUE)
[13:17:26.996]                               parallel_sendData(master, data)
[13:17:26.996]                             }
[13:17:26.996]                             return(sendCondition)
[13:17:26.996]                           }
[13:17:26.996]                         }
[13:17:26.996]                         frame <- frame + 1L
[13:17:26.996]                         envir <- sys.frame(frame)
[13:17:26.996]                       }
[13:17:26.996]                     }
[13:17:26.996]                     sendCondition <<- function(cond) NULL
[13:17:26.996]                   }
[13:17:26.996]                 })
[13:17:26.996]                 withCallingHandlers({
[13:17:26.996]                   {
[13:17:26.996]                     do.call(function(...) {
[13:17:26.996]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:26.996]                       if (!identical(...future.globals.maxSize.org, 
[13:17:26.996]                         ...future.globals.maxSize)) {
[13:17:26.996]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:26.996]                         on.exit(options(oopts), add = TRUE)
[13:17:26.996]                       }
[13:17:26.996]                       {
[13:17:26.996]                         lapply(seq_along(...future.elements_ii), 
[13:17:26.996]                           FUN = function(jj) {
[13:17:26.996]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:26.996]                             ...future.FUN(...future.X_jj, ...)
[13:17:26.996]                           })
[13:17:26.996]                       }
[13:17:26.996]                     }, args = future.call.arguments)
[13:17:26.996]                   }
[13:17:26.996]                 }, immediateCondition = function(cond) {
[13:17:26.996]                   sendCondition <- ...future.makeSendCondition()
[13:17:26.996]                   sendCondition(cond)
[13:17:26.996]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.996]                   {
[13:17:26.996]                     inherits <- base::inherits
[13:17:26.996]                     invokeRestart <- base::invokeRestart
[13:17:26.996]                     is.null <- base::is.null
[13:17:26.996]                     muffled <- FALSE
[13:17:26.996]                     if (inherits(cond, "message")) {
[13:17:26.996]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:26.996]                       if (muffled) 
[13:17:26.996]                         invokeRestart("muffleMessage")
[13:17:26.996]                     }
[13:17:26.996]                     else if (inherits(cond, "warning")) {
[13:17:26.996]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:26.996]                       if (muffled) 
[13:17:26.996]                         invokeRestart("muffleWarning")
[13:17:26.996]                     }
[13:17:26.996]                     else if (inherits(cond, "condition")) {
[13:17:26.996]                       if (!is.null(pattern)) {
[13:17:26.996]                         computeRestarts <- base::computeRestarts
[13:17:26.996]                         grepl <- base::grepl
[13:17:26.996]                         restarts <- computeRestarts(cond)
[13:17:26.996]                         for (restart in restarts) {
[13:17:26.996]                           name <- restart$name
[13:17:26.996]                           if (is.null(name)) 
[13:17:26.996]                             next
[13:17:26.996]                           if (!grepl(pattern, name)) 
[13:17:26.996]                             next
[13:17:26.996]                           invokeRestart(restart)
[13:17:26.996]                           muffled <- TRUE
[13:17:26.996]                           break
[13:17:26.996]                         }
[13:17:26.996]                       }
[13:17:26.996]                     }
[13:17:26.996]                     invisible(muffled)
[13:17:26.996]                   }
[13:17:26.996]                   muffleCondition(cond)
[13:17:26.996]                 })
[13:17:26.996]             }))
[13:17:26.996]             future::FutureResult(value = ...future.value$value, 
[13:17:26.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.996]                   ...future.rng), globalenv = if (FALSE) 
[13:17:26.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:26.996]                     ...future.globalenv.names))
[13:17:26.996]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:26.996]         }, condition = base::local({
[13:17:26.996]             c <- base::c
[13:17:26.996]             inherits <- base::inherits
[13:17:26.996]             invokeRestart <- base::invokeRestart
[13:17:26.996]             length <- base::length
[13:17:26.996]             list <- base::list
[13:17:26.996]             seq.int <- base::seq.int
[13:17:26.996]             signalCondition <- base::signalCondition
[13:17:26.996]             sys.calls <- base::sys.calls
[13:17:26.996]             `[[` <- base::`[[`
[13:17:26.996]             `+` <- base::`+`
[13:17:26.996]             `<<-` <- base::`<<-`
[13:17:26.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:26.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:26.996]                   3L)]
[13:17:26.996]             }
[13:17:26.996]             function(cond) {
[13:17:26.996]                 is_error <- inherits(cond, "error")
[13:17:26.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:26.996]                   NULL)
[13:17:26.996]                 if (is_error) {
[13:17:26.996]                   sessionInformation <- function() {
[13:17:26.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:26.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:26.996]                       search = base::search(), system = base::Sys.info())
[13:17:26.996]                   }
[13:17:26.996]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:26.996]                     cond$call), session = sessionInformation(), 
[13:17:26.996]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:26.996]                   signalCondition(cond)
[13:17:26.996]                 }
[13:17:26.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:26.996]                 "immediateCondition"))) {
[13:17:26.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:26.996]                   ...future.conditions[[length(...future.conditions) + 
[13:17:26.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:26.996]                   if (TRUE && !signal) {
[13:17:26.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.996]                     {
[13:17:26.996]                       inherits <- base::inherits
[13:17:26.996]                       invokeRestart <- base::invokeRestart
[13:17:26.996]                       is.null <- base::is.null
[13:17:26.996]                       muffled <- FALSE
[13:17:26.996]                       if (inherits(cond, "message")) {
[13:17:26.996]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.996]                         if (muffled) 
[13:17:26.996]                           invokeRestart("muffleMessage")
[13:17:26.996]                       }
[13:17:26.996]                       else if (inherits(cond, "warning")) {
[13:17:26.996]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.996]                         if (muffled) 
[13:17:26.996]                           invokeRestart("muffleWarning")
[13:17:26.996]                       }
[13:17:26.996]                       else if (inherits(cond, "condition")) {
[13:17:26.996]                         if (!is.null(pattern)) {
[13:17:26.996]                           computeRestarts <- base::computeRestarts
[13:17:26.996]                           grepl <- base::grepl
[13:17:26.996]                           restarts <- computeRestarts(cond)
[13:17:26.996]                           for (restart in restarts) {
[13:17:26.996]                             name <- restart$name
[13:17:26.996]                             if (is.null(name)) 
[13:17:26.996]                               next
[13:17:26.996]                             if (!grepl(pattern, name)) 
[13:17:26.996]                               next
[13:17:26.996]                             invokeRestart(restart)
[13:17:26.996]                             muffled <- TRUE
[13:17:26.996]                             break
[13:17:26.996]                           }
[13:17:26.996]                         }
[13:17:26.996]                       }
[13:17:26.996]                       invisible(muffled)
[13:17:26.996]                     }
[13:17:26.996]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.996]                   }
[13:17:26.996]                 }
[13:17:26.996]                 else {
[13:17:26.996]                   if (TRUE) {
[13:17:26.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:26.996]                     {
[13:17:26.996]                       inherits <- base::inherits
[13:17:26.996]                       invokeRestart <- base::invokeRestart
[13:17:26.996]                       is.null <- base::is.null
[13:17:26.996]                       muffled <- FALSE
[13:17:26.996]                       if (inherits(cond, "message")) {
[13:17:26.996]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:26.996]                         if (muffled) 
[13:17:26.996]                           invokeRestart("muffleMessage")
[13:17:26.996]                       }
[13:17:26.996]                       else if (inherits(cond, "warning")) {
[13:17:26.996]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:26.996]                         if (muffled) 
[13:17:26.996]                           invokeRestart("muffleWarning")
[13:17:26.996]                       }
[13:17:26.996]                       else if (inherits(cond, "condition")) {
[13:17:26.996]                         if (!is.null(pattern)) {
[13:17:26.996]                           computeRestarts <- base::computeRestarts
[13:17:26.996]                           grepl <- base::grepl
[13:17:26.996]                           restarts <- computeRestarts(cond)
[13:17:26.996]                           for (restart in restarts) {
[13:17:26.996]                             name <- restart$name
[13:17:26.996]                             if (is.null(name)) 
[13:17:26.996]                               next
[13:17:26.996]                             if (!grepl(pattern, name)) 
[13:17:26.996]                               next
[13:17:26.996]                             invokeRestart(restart)
[13:17:26.996]                             muffled <- TRUE
[13:17:26.996]                             break
[13:17:26.996]                           }
[13:17:26.996]                         }
[13:17:26.996]                       }
[13:17:26.996]                       invisible(muffled)
[13:17:26.996]                     }
[13:17:26.996]                     muffleCondition(cond, pattern = "^muffle")
[13:17:26.996]                   }
[13:17:26.996]                 }
[13:17:26.996]             }
[13:17:26.996]         }))
[13:17:26.996]     }, error = function(ex) {
[13:17:26.996]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:26.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:26.996]                 ...future.rng), started = ...future.startTime, 
[13:17:26.996]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:26.996]             version = "1.8"), class = "FutureResult")
[13:17:26.996]     }, finally = {
[13:17:26.996]         if (!identical(...future.workdir, getwd())) 
[13:17:26.996]             setwd(...future.workdir)
[13:17:26.996]         {
[13:17:26.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:26.996]                 ...future.oldOptions$nwarnings <- NULL
[13:17:26.996]             }
[13:17:26.996]             base::options(...future.oldOptions)
[13:17:26.996]             if (.Platform$OS.type == "windows") {
[13:17:26.996]                 old_names <- names(...future.oldEnvVars)
[13:17:26.996]                 envs <- base::Sys.getenv()
[13:17:26.996]                 names <- names(envs)
[13:17:26.996]                 common <- intersect(names, old_names)
[13:17:26.996]                 added <- setdiff(names, old_names)
[13:17:26.996]                 removed <- setdiff(old_names, names)
[13:17:26.996]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:26.996]                   envs[common]]
[13:17:26.996]                 NAMES <- toupper(changed)
[13:17:26.996]                 args <- list()
[13:17:26.996]                 for (kk in seq_along(NAMES)) {
[13:17:26.996]                   name <- changed[[kk]]
[13:17:26.996]                   NAME <- NAMES[[kk]]
[13:17:26.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.996]                     next
[13:17:26.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.996]                 }
[13:17:26.996]                 NAMES <- toupper(added)
[13:17:26.996]                 for (kk in seq_along(NAMES)) {
[13:17:26.996]                   name <- added[[kk]]
[13:17:26.996]                   NAME <- NAMES[[kk]]
[13:17:26.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.996]                     next
[13:17:26.996]                   args[[name]] <- ""
[13:17:26.996]                 }
[13:17:26.996]                 NAMES <- toupper(removed)
[13:17:26.996]                 for (kk in seq_along(NAMES)) {
[13:17:26.996]                   name <- removed[[kk]]
[13:17:26.996]                   NAME <- NAMES[[kk]]
[13:17:26.996]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:26.996]                     next
[13:17:26.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:26.996]                 }
[13:17:26.996]                 if (length(args) > 0) 
[13:17:26.996]                   base::do.call(base::Sys.setenv, args = args)
[13:17:26.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:26.996]             }
[13:17:26.996]             else {
[13:17:26.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:26.996]             }
[13:17:26.996]             {
[13:17:26.996]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:26.996]                   0L) {
[13:17:26.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:26.996]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:26.996]                   base::options(opts)
[13:17:26.996]                 }
[13:17:26.996]                 {
[13:17:26.996]                   {
[13:17:26.996]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:26.996]                     NULL
[13:17:26.996]                   }
[13:17:26.996]                   options(future.plan = NULL)
[13:17:26.996]                   if (is.na(NA_character_)) 
[13:17:26.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:26.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:26.996]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:26.996]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:26.996]                     envir = parent.frame()) 
[13:17:26.996]                   {
[13:17:26.996]                     if (is.function(workers)) 
[13:17:26.996]                       workers <- workers()
[13:17:26.996]                     workers <- structure(as.integer(workers), 
[13:17:26.996]                       class = class(workers))
[13:17:26.996]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:26.996]                       workers >= 1)
[13:17:26.996]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:26.996]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:26.996]                     }
[13:17:26.996]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:26.996]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:26.996]                       envir = envir)
[13:17:26.996]                     if (!future$lazy) 
[13:17:26.996]                       future <- run(future)
[13:17:26.996]                     invisible(future)
[13:17:26.996]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:26.996]                 }
[13:17:26.996]             }
[13:17:26.996]         }
[13:17:26.996]     })
[13:17:26.996]     if (TRUE) {
[13:17:26.996]         base::sink(type = "output", split = FALSE)
[13:17:26.996]         if (TRUE) {
[13:17:26.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:26.996]         }
[13:17:26.996]         else {
[13:17:26.996]             ...future.result["stdout"] <- base::list(NULL)
[13:17:26.996]         }
[13:17:26.996]         base::close(...future.stdout)
[13:17:26.996]         ...future.stdout <- NULL
[13:17:26.996]     }
[13:17:26.996]     ...future.result$conditions <- ...future.conditions
[13:17:26.996]     ...future.result$finished <- base::Sys.time()
[13:17:26.996]     ...future.result
[13:17:26.996] }
[13:17:26.999] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[13:17:26.999] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.000] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.000] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:17:27.000] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:17:27.000] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[13:17:27.001] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[13:17:27.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.001] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:27.002] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.002] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[13:17:27.002] MultisessionFuture started
[13:17:27.002] - Launch lazy future ... done
[13:17:27.002] run() for ‘MultisessionFuture’ ... done
[13:17:27.002] Created future:
[13:17:27.003] MultisessionFuture:
[13:17:27.003] Label: ‘future_apply-2’
[13:17:27.003] Expression:
[13:17:27.003] {
[13:17:27.003]     do.call(function(...) {
[13:17:27.003]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.003]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.003]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.003]             on.exit(options(oopts), add = TRUE)
[13:17:27.003]         }
[13:17:27.003]         {
[13:17:27.003]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.003]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.003]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.003]             })
[13:17:27.003]         }
[13:17:27.003]     }, args = future.call.arguments)
[13:17:27.003] }
[13:17:27.003] Lazy evaluation: FALSE
[13:17:27.003] Asynchronous evaluation: TRUE
[13:17:27.003] Local evaluation: TRUE
[13:17:27.003] Environment: R_GlobalEnv
[13:17:27.003] Capture standard output: TRUE
[13:17:27.003] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.003] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.003] Packages: 1 packages (‘stats’)
[13:17:27.003] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.003] Resolved: FALSE
[13:17:27.003] Value: <not collected>
[13:17:27.003] Conditions captured: <none>
[13:17:27.003] Early signaling: FALSE
[13:17:27.003] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.003] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.014] Chunk #2 of 2 ... DONE
[13:17:27.014] Launching 2 futures (chunks) ... DONE
[13:17:27.014] Resolving 2 futures (chunks) ...
[13:17:27.014] resolve() on list ...
[13:17:27.014]  recursive: 0
[13:17:27.015]  length: 2
[13:17:27.015] 
[13:17:27.016] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.016] - Validating connection of MultisessionFuture
[13:17:27.016] - received message: FutureResult
[13:17:27.016] - Received FutureResult
[13:17:27.016] - Erased future from FutureRegistry
[13:17:27.017] result() for ClusterFuture ...
[13:17:27.017] - result already collected: FutureResult
[13:17:27.017] result() for ClusterFuture ... done
[13:17:27.017] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.017] Future #1
[13:17:27.017] result() for ClusterFuture ...
[13:17:27.017] - result already collected: FutureResult
[13:17:27.017] result() for ClusterFuture ... done
[13:17:27.017] result() for ClusterFuture ...
[13:17:27.017] - result already collected: FutureResult
[13:17:27.018] result() for ClusterFuture ... done
[13:17:27.018] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.018] - nx: 2
[13:17:27.018] - relay: TRUE
[13:17:27.018] - stdout: TRUE
[13:17:27.018] - signal: TRUE
[13:17:27.018] - resignal: FALSE
[13:17:27.018] - force: TRUE
[13:17:27.018] - relayed: [n=2] FALSE, FALSE
[13:17:27.018] - queued futures: [n=2] FALSE, FALSE
[13:17:27.018]  - until=1
[13:17:27.018]  - relaying element #1
[13:17:27.019] result() for ClusterFuture ...
[13:17:27.019] - result already collected: FutureResult
[13:17:27.019] result() for ClusterFuture ... done
[13:17:27.019] result() for ClusterFuture ...
[13:17:27.019] - result already collected: FutureResult
[13:17:27.019] result() for ClusterFuture ... done
[13:17:27.019] result() for ClusterFuture ...
[13:17:27.019] - result already collected: FutureResult
[13:17:27.019] result() for ClusterFuture ... done
[13:17:27.019] result() for ClusterFuture ...
[13:17:27.019] - result already collected: FutureResult
[13:17:27.020] result() for ClusterFuture ... done
[13:17:27.020] - relayed: [n=2] TRUE, FALSE
[13:17:27.020] - queued futures: [n=2] TRUE, FALSE
[13:17:27.020] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.020]  length: 1 (resolved future 1)
[13:17:27.062] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.062] - Validating connection of MultisessionFuture
[13:17:27.062] - received message: FutureResult
[13:17:27.062] - Received FutureResult
[13:17:27.062] - Erased future from FutureRegistry
[13:17:27.062] result() for ClusterFuture ...
[13:17:27.062] - result already collected: FutureResult
[13:17:27.063] result() for ClusterFuture ... done
[13:17:27.063] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.063] Future #2
[13:17:27.063] result() for ClusterFuture ...
[13:17:27.063] - result already collected: FutureResult
[13:17:27.063] result() for ClusterFuture ... done
[13:17:27.063] result() for ClusterFuture ...
[13:17:27.063] - result already collected: FutureResult
[13:17:27.063] result() for ClusterFuture ... done
[13:17:27.063] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.063] - nx: 2
[13:17:27.064] - relay: TRUE
[13:17:27.064] - stdout: TRUE
[13:17:27.064] - signal: TRUE
[13:17:27.064] - resignal: FALSE
[13:17:27.064] - force: TRUE
[13:17:27.064] - relayed: [n=2] TRUE, FALSE
[13:17:27.064] - queued futures: [n=2] TRUE, FALSE
[13:17:27.064]  - until=2
[13:17:27.064]  - relaying element #2
[13:17:27.064] result() for ClusterFuture ...
[13:17:27.064] - result already collected: FutureResult
[13:17:27.064] result() for ClusterFuture ... done
[13:17:27.065] result() for ClusterFuture ...
[13:17:27.065] - result already collected: FutureResult
[13:17:27.065] result() for ClusterFuture ... done
[13:17:27.065] result() for ClusterFuture ...
[13:17:27.065] - result already collected: FutureResult
[13:17:27.065] result() for ClusterFuture ... done
[13:17:27.065] result() for ClusterFuture ...
[13:17:27.065] - result already collected: FutureResult
[13:17:27.065] result() for ClusterFuture ... done
[13:17:27.065] - relayed: [n=2] TRUE, TRUE
[13:17:27.066] - queued futures: [n=2] TRUE, TRUE
[13:17:27.066] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.066]  length: 0 (resolved future 2)
[13:17:27.066] Relaying remaining futures
[13:17:27.066] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.066] - nx: 2
[13:17:27.066] - relay: TRUE
[13:17:27.066] - stdout: TRUE
[13:17:27.066] - signal: TRUE
[13:17:27.066] - resignal: FALSE
[13:17:27.066] - force: TRUE
[13:17:27.066] - relayed: [n=2] TRUE, TRUE
[13:17:27.067] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.067] - relayed: [n=2] TRUE, TRUE
[13:17:27.067] - queued futures: [n=2] TRUE, TRUE
[13:17:27.067] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.067] resolve() on list ... DONE
[13:17:27.067] result() for ClusterFuture ...
[13:17:27.067] - result already collected: FutureResult
[13:17:27.067] result() for ClusterFuture ... done
[13:17:27.067] result() for ClusterFuture ...
[13:17:27.067] - result already collected: FutureResult
[13:17:27.068] result() for ClusterFuture ... done
[13:17:27.068] result() for ClusterFuture ...
[13:17:27.068] - result already collected: FutureResult
[13:17:27.068] result() for ClusterFuture ... done
[13:17:27.068] result() for ClusterFuture ...
[13:17:27.068] - result already collected: FutureResult
[13:17:27.068] result() for ClusterFuture ... done
[13:17:27.068]  - Number of value chunks collected: 2
[13:17:27.068] Resolving 2 futures (chunks) ... DONE
[13:17:27.068] Reducing values from 2 chunks ...
[13:17:27.068]  - Number of values collected after concatenation: 2
[13:17:27.069]  - Number of values expected: 2
[13:17:27.069] Reducing values from 2 chunks ... DONE
[13:17:27.069] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[13:17:27.069] getGlobalsAndPackagesXApply() ...
[13:17:27.069]  - future.globals: TRUE
[13:17:27.070] getGlobalsAndPackages() ...
[13:17:27.070] Searching for globals...
[13:17:27.071] - globals found: [1] ‘FUN’
[13:17:27.071] Searching for globals ... DONE
[13:17:27.071] Resolving globals: FALSE
[13:17:27.071] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:27.072] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:27.072] - globals: [1] ‘FUN’
[13:17:27.072] 
[13:17:27.072] getGlobalsAndPackages() ... DONE
[13:17:27.072]  - globals found/used: [n=1] ‘FUN’
[13:17:27.072]  - needed namespaces: [n=0] 
[13:17:27.072] Finding globals ... DONE
[13:17:27.072]  - use_args: TRUE
[13:17:27.072]  - Getting '...' globals ...
[13:17:27.073] resolve() on list ...
[13:17:27.073]  recursive: 0
[13:17:27.073]  length: 1
[13:17:27.073]  elements: ‘...’
[13:17:27.073]  length: 0 (resolved future 1)
[13:17:27.073] resolve() on list ... DONE
[13:17:27.073]    - '...' content: [n=0] 
[13:17:27.073] List of 1
[13:17:27.073]  $ ...: list()
[13:17:27.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.073]  - attr(*, "where")=List of 1
[13:17:27.073]   ..$ ...:<environment: 0x5647bcd19370> 
[13:17:27.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.073]  - attr(*, "resolved")= logi TRUE
[13:17:27.073]  - attr(*, "total_size")= num NA
[13:17:27.076]  - Getting '...' globals ... DONE
[13:17:27.076] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.076] List of 2
[13:17:27.076]  $ ...future.FUN:function (x)  
[13:17:27.076]  $ ...          : list()
[13:17:27.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.076]  - attr(*, "where")=List of 2
[13:17:27.076]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.076]   ..$ ...          :<environment: 0x5647bcd19370> 
[13:17:27.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.076]  - attr(*, "resolved")= logi FALSE
[13:17:27.076]  - attr(*, "total_size")= num 848
[13:17:27.079] Packages to be attached in all futures: [n=0] 
[13:17:27.079] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.084] future_lapply() ...
[13:17:27.088] Number of chunks: 2
[13:17:27.088] getGlobalsAndPackagesXApply() ...
[13:17:27.088]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.088]  - use_args: TRUE
[13:17:27.088] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.089] List of 2
[13:17:27.089]  $ ...          : list()
[13:17:27.089]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.089]  $ ...future.FUN:function (x)  
[13:17:27.089]  - attr(*, "where")=List of 2
[13:17:27.089]   ..$ ...          :<environment: 0x5647bcd19370> 
[13:17:27.089]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:27.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.089]  - attr(*, "resolved")= logi FALSE
[13:17:27.089]  - attr(*, "total_size")= num NA
[13:17:27.092] Packages to be attached in all futures: [n=0] 
[13:17:27.092] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.092] Number of futures (= number of chunks): 2
[13:17:27.092] Launching 2 futures (chunks) ...
[13:17:27.092] Chunk #1 of 2 ...
[13:17:27.092]  - seeds: <none>
[13:17:27.093] getGlobalsAndPackages() ...
[13:17:27.093] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.093] Resolving globals: FALSE
[13:17:27.093] Tweak future expression to call with '...' arguments ...
[13:17:27.093] {
[13:17:27.093]     do.call(function(...) {
[13:17:27.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.093]             on.exit(options(oopts), add = TRUE)
[13:17:27.093]         }
[13:17:27.093]         {
[13:17:27.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.093]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.093]             })
[13:17:27.093]         }
[13:17:27.093]     }, args = future.call.arguments)
[13:17:27.093] }
[13:17:27.093] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.094] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.094] 
[13:17:27.094] getGlobalsAndPackages() ... DONE
[13:17:27.094] run() for ‘Future’ ...
[13:17:27.094] - state: ‘created’
[13:17:27.094] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.110]   - Field: ‘node’
[13:17:27.110]   - Field: ‘label’
[13:17:27.110]   - Field: ‘local’
[13:17:27.110]   - Field: ‘owner’
[13:17:27.110]   - Field: ‘envir’
[13:17:27.111]   - Field: ‘workers’
[13:17:27.111]   - Field: ‘packages’
[13:17:27.111]   - Field: ‘gc’
[13:17:27.111]   - Field: ‘conditions’
[13:17:27.111]   - Field: ‘persistent’
[13:17:27.111]   - Field: ‘expr’
[13:17:27.111]   - Field: ‘uuid’
[13:17:27.111]   - Field: ‘seed’
[13:17:27.111]   - Field: ‘version’
[13:17:27.111]   - Field: ‘result’
[13:17:27.111]   - Field: ‘asynchronous’
[13:17:27.112]   - Field: ‘calls’
[13:17:27.112]   - Field: ‘globals’
[13:17:27.112]   - Field: ‘stdout’
[13:17:27.112]   - Field: ‘earlySignal’
[13:17:27.112]   - Field: ‘lazy’
[13:17:27.112]   - Field: ‘state’
[13:17:27.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.112] - Launch lazy future ...
[13:17:27.112] Packages needed by the future expression (n = 0): <none>
[13:17:27.113] Packages needed by future strategies (n = 0): <none>
[13:17:27.113] {
[13:17:27.113]     {
[13:17:27.113]         {
[13:17:27.113]             ...future.startTime <- base::Sys.time()
[13:17:27.113]             {
[13:17:27.113]                 {
[13:17:27.113]                   {
[13:17:27.113]                     {
[13:17:27.113]                       base::local({
[13:17:27.113]                         has_future <- base::requireNamespace("future", 
[13:17:27.113]                           quietly = TRUE)
[13:17:27.113]                         if (has_future) {
[13:17:27.113]                           ns <- base::getNamespace("future")
[13:17:27.113]                           version <- ns[[".package"]][["version"]]
[13:17:27.113]                           if (is.null(version)) 
[13:17:27.113]                             version <- utils::packageVersion("future")
[13:17:27.113]                         }
[13:17:27.113]                         else {
[13:17:27.113]                           version <- NULL
[13:17:27.113]                         }
[13:17:27.113]                         if (!has_future || version < "1.8.0") {
[13:17:27.113]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.113]                             "", base::R.version$version.string), 
[13:17:27.113]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.113]                               "release", "version")], collapse = " "), 
[13:17:27.113]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.113]                             info)
[13:17:27.113]                           info <- base::paste(info, collapse = "; ")
[13:17:27.113]                           if (!has_future) {
[13:17:27.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.113]                               info)
[13:17:27.113]                           }
[13:17:27.113]                           else {
[13:17:27.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.113]                               info, version)
[13:17:27.113]                           }
[13:17:27.113]                           base::stop(msg)
[13:17:27.113]                         }
[13:17:27.113]                       })
[13:17:27.113]                     }
[13:17:27.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.113]                     base::options(mc.cores = 1L)
[13:17:27.113]                   }
[13:17:27.113]                   options(future.plan = NULL)
[13:17:27.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.113]                 }
[13:17:27.113]                 ...future.workdir <- getwd()
[13:17:27.113]             }
[13:17:27.113]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.113]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.113]         }
[13:17:27.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.113]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.113]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.113]             base::names(...future.oldOptions))
[13:17:27.113]     }
[13:17:27.113]     if (FALSE) {
[13:17:27.113]     }
[13:17:27.113]     else {
[13:17:27.113]         if (TRUE) {
[13:17:27.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.113]                 open = "w")
[13:17:27.113]         }
[13:17:27.113]         else {
[13:17:27.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.113]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.113]         }
[13:17:27.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.113]             base::sink(type = "output", split = FALSE)
[13:17:27.113]             base::close(...future.stdout)
[13:17:27.113]         }, add = TRUE)
[13:17:27.113]     }
[13:17:27.113]     ...future.frame <- base::sys.nframe()
[13:17:27.113]     ...future.conditions <- base::list()
[13:17:27.113]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.113]     if (FALSE) {
[13:17:27.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.113]     }
[13:17:27.113]     ...future.result <- base::tryCatch({
[13:17:27.113]         base::withCallingHandlers({
[13:17:27.113]             ...future.value <- base::withVisible(base::local({
[13:17:27.113]                 ...future.makeSendCondition <- local({
[13:17:27.113]                   sendCondition <- NULL
[13:17:27.113]                   function(frame = 1L) {
[13:17:27.113]                     if (is.function(sendCondition)) 
[13:17:27.113]                       return(sendCondition)
[13:17:27.113]                     ns <- getNamespace("parallel")
[13:17:27.113]                     if (exists("sendData", mode = "function", 
[13:17:27.113]                       envir = ns)) {
[13:17:27.113]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.113]                         envir = ns)
[13:17:27.113]                       envir <- sys.frame(frame)
[13:17:27.113]                       master <- NULL
[13:17:27.113]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.113]                         !identical(envir, emptyenv())) {
[13:17:27.113]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.113]                           inherits = FALSE)) {
[13:17:27.113]                           master <- get("master", mode = "list", 
[13:17:27.113]                             envir = envir, inherits = FALSE)
[13:17:27.113]                           if (inherits(master, c("SOCKnode", 
[13:17:27.113]                             "SOCK0node"))) {
[13:17:27.113]                             sendCondition <<- function(cond) {
[13:17:27.113]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.113]                                 success = TRUE)
[13:17:27.113]                               parallel_sendData(master, data)
[13:17:27.113]                             }
[13:17:27.113]                             return(sendCondition)
[13:17:27.113]                           }
[13:17:27.113]                         }
[13:17:27.113]                         frame <- frame + 1L
[13:17:27.113]                         envir <- sys.frame(frame)
[13:17:27.113]                       }
[13:17:27.113]                     }
[13:17:27.113]                     sendCondition <<- function(cond) NULL
[13:17:27.113]                   }
[13:17:27.113]                 })
[13:17:27.113]                 withCallingHandlers({
[13:17:27.113]                   {
[13:17:27.113]                     do.call(function(...) {
[13:17:27.113]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.113]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.113]                         ...future.globals.maxSize)) {
[13:17:27.113]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.113]                         on.exit(options(oopts), add = TRUE)
[13:17:27.113]                       }
[13:17:27.113]                       {
[13:17:27.113]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.113]                           FUN = function(jj) {
[13:17:27.113]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.113]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.113]                           })
[13:17:27.113]                       }
[13:17:27.113]                     }, args = future.call.arguments)
[13:17:27.113]                   }
[13:17:27.113]                 }, immediateCondition = function(cond) {
[13:17:27.113]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.113]                   sendCondition(cond)
[13:17:27.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.113]                   {
[13:17:27.113]                     inherits <- base::inherits
[13:17:27.113]                     invokeRestart <- base::invokeRestart
[13:17:27.113]                     is.null <- base::is.null
[13:17:27.113]                     muffled <- FALSE
[13:17:27.113]                     if (inherits(cond, "message")) {
[13:17:27.113]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.113]                       if (muffled) 
[13:17:27.113]                         invokeRestart("muffleMessage")
[13:17:27.113]                     }
[13:17:27.113]                     else if (inherits(cond, "warning")) {
[13:17:27.113]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.113]                       if (muffled) 
[13:17:27.113]                         invokeRestart("muffleWarning")
[13:17:27.113]                     }
[13:17:27.113]                     else if (inherits(cond, "condition")) {
[13:17:27.113]                       if (!is.null(pattern)) {
[13:17:27.113]                         computeRestarts <- base::computeRestarts
[13:17:27.113]                         grepl <- base::grepl
[13:17:27.113]                         restarts <- computeRestarts(cond)
[13:17:27.113]                         for (restart in restarts) {
[13:17:27.113]                           name <- restart$name
[13:17:27.113]                           if (is.null(name)) 
[13:17:27.113]                             next
[13:17:27.113]                           if (!grepl(pattern, name)) 
[13:17:27.113]                             next
[13:17:27.113]                           invokeRestart(restart)
[13:17:27.113]                           muffled <- TRUE
[13:17:27.113]                           break
[13:17:27.113]                         }
[13:17:27.113]                       }
[13:17:27.113]                     }
[13:17:27.113]                     invisible(muffled)
[13:17:27.113]                   }
[13:17:27.113]                   muffleCondition(cond)
[13:17:27.113]                 })
[13:17:27.113]             }))
[13:17:27.113]             future::FutureResult(value = ...future.value$value, 
[13:17:27.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.113]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.113]                     ...future.globalenv.names))
[13:17:27.113]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.113]         }, condition = base::local({
[13:17:27.113]             c <- base::c
[13:17:27.113]             inherits <- base::inherits
[13:17:27.113]             invokeRestart <- base::invokeRestart
[13:17:27.113]             length <- base::length
[13:17:27.113]             list <- base::list
[13:17:27.113]             seq.int <- base::seq.int
[13:17:27.113]             signalCondition <- base::signalCondition
[13:17:27.113]             sys.calls <- base::sys.calls
[13:17:27.113]             `[[` <- base::`[[`
[13:17:27.113]             `+` <- base::`+`
[13:17:27.113]             `<<-` <- base::`<<-`
[13:17:27.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.113]                   3L)]
[13:17:27.113]             }
[13:17:27.113]             function(cond) {
[13:17:27.113]                 is_error <- inherits(cond, "error")
[13:17:27.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.113]                   NULL)
[13:17:27.113]                 if (is_error) {
[13:17:27.113]                   sessionInformation <- function() {
[13:17:27.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.113]                       search = base::search(), system = base::Sys.info())
[13:17:27.113]                   }
[13:17:27.113]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.113]                     cond$call), session = sessionInformation(), 
[13:17:27.113]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.113]                   signalCondition(cond)
[13:17:27.113]                 }
[13:17:27.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.113]                 "immediateCondition"))) {
[13:17:27.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.113]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.113]                   if (TRUE && !signal) {
[13:17:27.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.113]                     {
[13:17:27.113]                       inherits <- base::inherits
[13:17:27.113]                       invokeRestart <- base::invokeRestart
[13:17:27.113]                       is.null <- base::is.null
[13:17:27.113]                       muffled <- FALSE
[13:17:27.113]                       if (inherits(cond, "message")) {
[13:17:27.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.113]                         if (muffled) 
[13:17:27.113]                           invokeRestart("muffleMessage")
[13:17:27.113]                       }
[13:17:27.113]                       else if (inherits(cond, "warning")) {
[13:17:27.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.113]                         if (muffled) 
[13:17:27.113]                           invokeRestart("muffleWarning")
[13:17:27.113]                       }
[13:17:27.113]                       else if (inherits(cond, "condition")) {
[13:17:27.113]                         if (!is.null(pattern)) {
[13:17:27.113]                           computeRestarts <- base::computeRestarts
[13:17:27.113]                           grepl <- base::grepl
[13:17:27.113]                           restarts <- computeRestarts(cond)
[13:17:27.113]                           for (restart in restarts) {
[13:17:27.113]                             name <- restart$name
[13:17:27.113]                             if (is.null(name)) 
[13:17:27.113]                               next
[13:17:27.113]                             if (!grepl(pattern, name)) 
[13:17:27.113]                               next
[13:17:27.113]                             invokeRestart(restart)
[13:17:27.113]                             muffled <- TRUE
[13:17:27.113]                             break
[13:17:27.113]                           }
[13:17:27.113]                         }
[13:17:27.113]                       }
[13:17:27.113]                       invisible(muffled)
[13:17:27.113]                     }
[13:17:27.113]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.113]                   }
[13:17:27.113]                 }
[13:17:27.113]                 else {
[13:17:27.113]                   if (TRUE) {
[13:17:27.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.113]                     {
[13:17:27.113]                       inherits <- base::inherits
[13:17:27.113]                       invokeRestart <- base::invokeRestart
[13:17:27.113]                       is.null <- base::is.null
[13:17:27.113]                       muffled <- FALSE
[13:17:27.113]                       if (inherits(cond, "message")) {
[13:17:27.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.113]                         if (muffled) 
[13:17:27.113]                           invokeRestart("muffleMessage")
[13:17:27.113]                       }
[13:17:27.113]                       else if (inherits(cond, "warning")) {
[13:17:27.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.113]                         if (muffled) 
[13:17:27.113]                           invokeRestart("muffleWarning")
[13:17:27.113]                       }
[13:17:27.113]                       else if (inherits(cond, "condition")) {
[13:17:27.113]                         if (!is.null(pattern)) {
[13:17:27.113]                           computeRestarts <- base::computeRestarts
[13:17:27.113]                           grepl <- base::grepl
[13:17:27.113]                           restarts <- computeRestarts(cond)
[13:17:27.113]                           for (restart in restarts) {
[13:17:27.113]                             name <- restart$name
[13:17:27.113]                             if (is.null(name)) 
[13:17:27.113]                               next
[13:17:27.113]                             if (!grepl(pattern, name)) 
[13:17:27.113]                               next
[13:17:27.113]                             invokeRestart(restart)
[13:17:27.113]                             muffled <- TRUE
[13:17:27.113]                             break
[13:17:27.113]                           }
[13:17:27.113]                         }
[13:17:27.113]                       }
[13:17:27.113]                       invisible(muffled)
[13:17:27.113]                     }
[13:17:27.113]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.113]                   }
[13:17:27.113]                 }
[13:17:27.113]             }
[13:17:27.113]         }))
[13:17:27.113]     }, error = function(ex) {
[13:17:27.113]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.113]                 ...future.rng), started = ...future.startTime, 
[13:17:27.113]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.113]             version = "1.8"), class = "FutureResult")
[13:17:27.113]     }, finally = {
[13:17:27.113]         if (!identical(...future.workdir, getwd())) 
[13:17:27.113]             setwd(...future.workdir)
[13:17:27.113]         {
[13:17:27.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.113]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.113]             }
[13:17:27.113]             base::options(...future.oldOptions)
[13:17:27.113]             if (.Platform$OS.type == "windows") {
[13:17:27.113]                 old_names <- names(...future.oldEnvVars)
[13:17:27.113]                 envs <- base::Sys.getenv()
[13:17:27.113]                 names <- names(envs)
[13:17:27.113]                 common <- intersect(names, old_names)
[13:17:27.113]                 added <- setdiff(names, old_names)
[13:17:27.113]                 removed <- setdiff(old_names, names)
[13:17:27.113]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.113]                   envs[common]]
[13:17:27.113]                 NAMES <- toupper(changed)
[13:17:27.113]                 args <- list()
[13:17:27.113]                 for (kk in seq_along(NAMES)) {
[13:17:27.113]                   name <- changed[[kk]]
[13:17:27.113]                   NAME <- NAMES[[kk]]
[13:17:27.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.113]                     next
[13:17:27.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.113]                 }
[13:17:27.113]                 NAMES <- toupper(added)
[13:17:27.113]                 for (kk in seq_along(NAMES)) {
[13:17:27.113]                   name <- added[[kk]]
[13:17:27.113]                   NAME <- NAMES[[kk]]
[13:17:27.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.113]                     next
[13:17:27.113]                   args[[name]] <- ""
[13:17:27.113]                 }
[13:17:27.113]                 NAMES <- toupper(removed)
[13:17:27.113]                 for (kk in seq_along(NAMES)) {
[13:17:27.113]                   name <- removed[[kk]]
[13:17:27.113]                   NAME <- NAMES[[kk]]
[13:17:27.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.113]                     next
[13:17:27.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.113]                 }
[13:17:27.113]                 if (length(args) > 0) 
[13:17:27.113]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.113]             }
[13:17:27.113]             else {
[13:17:27.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.113]             }
[13:17:27.113]             {
[13:17:27.113]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.113]                   0L) {
[13:17:27.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.113]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.113]                   base::options(opts)
[13:17:27.113]                 }
[13:17:27.113]                 {
[13:17:27.113]                   {
[13:17:27.113]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.113]                     NULL
[13:17:27.113]                   }
[13:17:27.113]                   options(future.plan = NULL)
[13:17:27.113]                   if (is.na(NA_character_)) 
[13:17:27.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.113]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.113]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.113]                     envir = parent.frame()) 
[13:17:27.113]                   {
[13:17:27.113]                     if (is.function(workers)) 
[13:17:27.113]                       workers <- workers()
[13:17:27.113]                     workers <- structure(as.integer(workers), 
[13:17:27.113]                       class = class(workers))
[13:17:27.113]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.113]                       workers >= 1)
[13:17:27.113]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.113]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.113]                     }
[13:17:27.113]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.113]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.113]                       envir = envir)
[13:17:27.113]                     if (!future$lazy) 
[13:17:27.113]                       future <- run(future)
[13:17:27.113]                     invisible(future)
[13:17:27.113]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.113]                 }
[13:17:27.113]             }
[13:17:27.113]         }
[13:17:27.113]     })
[13:17:27.113]     if (TRUE) {
[13:17:27.113]         base::sink(type = "output", split = FALSE)
[13:17:27.113]         if (TRUE) {
[13:17:27.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.113]         }
[13:17:27.113]         else {
[13:17:27.113]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.113]         }
[13:17:27.113]         base::close(...future.stdout)
[13:17:27.113]         ...future.stdout <- NULL
[13:17:27.113]     }
[13:17:27.113]     ...future.result$conditions <- ...future.conditions
[13:17:27.113]     ...future.result$finished <- base::Sys.time()
[13:17:27.113]     ...future.result
[13:17:27.113] }
[13:17:27.116] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[13:17:27.116] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.117] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.117] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:17:27.117] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:17:27.117] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:17:27.118] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:17:27.118] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:27.118] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:27.119] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.119] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[13:17:27.119] MultisessionFuture started
[13:17:27.120] - Launch lazy future ... done
[13:17:27.120] run() for ‘MultisessionFuture’ ... done
[13:17:27.120] Created future:
[13:17:27.120] MultisessionFuture:
[13:17:27.120] Label: ‘future_apply-1’
[13:17:27.120] Expression:
[13:17:27.120] {
[13:17:27.120]     do.call(function(...) {
[13:17:27.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.120]             on.exit(options(oopts), add = TRUE)
[13:17:27.120]         }
[13:17:27.120]         {
[13:17:27.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.120]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.120]             })
[13:17:27.120]         }
[13:17:27.120]     }, args = future.call.arguments)
[13:17:27.120] }
[13:17:27.120] Lazy evaluation: FALSE
[13:17:27.120] Asynchronous evaluation: TRUE
[13:17:27.120] Local evaluation: TRUE
[13:17:27.120] Environment: R_GlobalEnv
[13:17:27.120] Capture standard output: TRUE
[13:17:27.120] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.120] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.120] Packages: <none>
[13:17:27.120] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.120] Resolved: FALSE
[13:17:27.120] Value: <not collected>
[13:17:27.120] Conditions captured: <none>
[13:17:27.120] Early signaling: FALSE
[13:17:27.120] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.120] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.132] Chunk #1 of 2 ... DONE
[13:17:27.132] Chunk #2 of 2 ...
[13:17:27.132]  - seeds: <none>
[13:17:27.132] getGlobalsAndPackages() ...
[13:17:27.132] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.132] Resolving globals: FALSE
[13:17:27.132] Tweak future expression to call with '...' arguments ...
[13:17:27.132] {
[13:17:27.132]     do.call(function(...) {
[13:17:27.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.132]             on.exit(options(oopts), add = TRUE)
[13:17:27.132]         }
[13:17:27.132]         {
[13:17:27.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.132]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.132]             })
[13:17:27.132]         }
[13:17:27.132]     }, args = future.call.arguments)
[13:17:27.132] }
[13:17:27.133] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.133] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.133] 
[13:17:27.133] getGlobalsAndPackages() ... DONE
[13:17:27.133] run() for ‘Future’ ...
[13:17:27.134] - state: ‘created’
[13:17:27.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.149] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.149]   - Field: ‘node’
[13:17:27.149]   - Field: ‘label’
[13:17:27.149]   - Field: ‘local’
[13:17:27.150]   - Field: ‘owner’
[13:17:27.150]   - Field: ‘envir’
[13:17:27.150]   - Field: ‘workers’
[13:17:27.150]   - Field: ‘packages’
[13:17:27.150]   - Field: ‘gc’
[13:17:27.150]   - Field: ‘conditions’
[13:17:27.150]   - Field: ‘persistent’
[13:17:27.150]   - Field: ‘expr’
[13:17:27.150]   - Field: ‘uuid’
[13:17:27.150]   - Field: ‘seed’
[13:17:27.150]   - Field: ‘version’
[13:17:27.151]   - Field: ‘result’
[13:17:27.151]   - Field: ‘asynchronous’
[13:17:27.151]   - Field: ‘calls’
[13:17:27.151]   - Field: ‘globals’
[13:17:27.151]   - Field: ‘stdout’
[13:17:27.151]   - Field: ‘earlySignal’
[13:17:27.151]   - Field: ‘lazy’
[13:17:27.151]   - Field: ‘state’
[13:17:27.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.151] - Launch lazy future ...
[13:17:27.152] Packages needed by the future expression (n = 0): <none>
[13:17:27.152] Packages needed by future strategies (n = 0): <none>
[13:17:27.152] {
[13:17:27.152]     {
[13:17:27.152]         {
[13:17:27.152]             ...future.startTime <- base::Sys.time()
[13:17:27.152]             {
[13:17:27.152]                 {
[13:17:27.152]                   {
[13:17:27.152]                     {
[13:17:27.152]                       base::local({
[13:17:27.152]                         has_future <- base::requireNamespace("future", 
[13:17:27.152]                           quietly = TRUE)
[13:17:27.152]                         if (has_future) {
[13:17:27.152]                           ns <- base::getNamespace("future")
[13:17:27.152]                           version <- ns[[".package"]][["version"]]
[13:17:27.152]                           if (is.null(version)) 
[13:17:27.152]                             version <- utils::packageVersion("future")
[13:17:27.152]                         }
[13:17:27.152]                         else {
[13:17:27.152]                           version <- NULL
[13:17:27.152]                         }
[13:17:27.152]                         if (!has_future || version < "1.8.0") {
[13:17:27.152]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.152]                             "", base::R.version$version.string), 
[13:17:27.152]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.152]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.152]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.152]                               "release", "version")], collapse = " "), 
[13:17:27.152]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.152]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.152]                             info)
[13:17:27.152]                           info <- base::paste(info, collapse = "; ")
[13:17:27.152]                           if (!has_future) {
[13:17:27.152]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.152]                               info)
[13:17:27.152]                           }
[13:17:27.152]                           else {
[13:17:27.152]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.152]                               info, version)
[13:17:27.152]                           }
[13:17:27.152]                           base::stop(msg)
[13:17:27.152]                         }
[13:17:27.152]                       })
[13:17:27.152]                     }
[13:17:27.152]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.152]                     base::options(mc.cores = 1L)
[13:17:27.152]                   }
[13:17:27.152]                   options(future.plan = NULL)
[13:17:27.152]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.152]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.152]                 }
[13:17:27.152]                 ...future.workdir <- getwd()
[13:17:27.152]             }
[13:17:27.152]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.152]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.152]         }
[13:17:27.152]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.152]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.152]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.152]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.152]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.152]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.152]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.152]             base::names(...future.oldOptions))
[13:17:27.152]     }
[13:17:27.152]     if (FALSE) {
[13:17:27.152]     }
[13:17:27.152]     else {
[13:17:27.152]         if (TRUE) {
[13:17:27.152]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.152]                 open = "w")
[13:17:27.152]         }
[13:17:27.152]         else {
[13:17:27.152]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.152]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.152]         }
[13:17:27.152]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.152]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.152]             base::sink(type = "output", split = FALSE)
[13:17:27.152]             base::close(...future.stdout)
[13:17:27.152]         }, add = TRUE)
[13:17:27.152]     }
[13:17:27.152]     ...future.frame <- base::sys.nframe()
[13:17:27.152]     ...future.conditions <- base::list()
[13:17:27.152]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.152]     if (FALSE) {
[13:17:27.152]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.152]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.152]     }
[13:17:27.152]     ...future.result <- base::tryCatch({
[13:17:27.152]         base::withCallingHandlers({
[13:17:27.152]             ...future.value <- base::withVisible(base::local({
[13:17:27.152]                 ...future.makeSendCondition <- local({
[13:17:27.152]                   sendCondition <- NULL
[13:17:27.152]                   function(frame = 1L) {
[13:17:27.152]                     if (is.function(sendCondition)) 
[13:17:27.152]                       return(sendCondition)
[13:17:27.152]                     ns <- getNamespace("parallel")
[13:17:27.152]                     if (exists("sendData", mode = "function", 
[13:17:27.152]                       envir = ns)) {
[13:17:27.152]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.152]                         envir = ns)
[13:17:27.152]                       envir <- sys.frame(frame)
[13:17:27.152]                       master <- NULL
[13:17:27.152]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.152]                         !identical(envir, emptyenv())) {
[13:17:27.152]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.152]                           inherits = FALSE)) {
[13:17:27.152]                           master <- get("master", mode = "list", 
[13:17:27.152]                             envir = envir, inherits = FALSE)
[13:17:27.152]                           if (inherits(master, c("SOCKnode", 
[13:17:27.152]                             "SOCK0node"))) {
[13:17:27.152]                             sendCondition <<- function(cond) {
[13:17:27.152]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.152]                                 success = TRUE)
[13:17:27.152]                               parallel_sendData(master, data)
[13:17:27.152]                             }
[13:17:27.152]                             return(sendCondition)
[13:17:27.152]                           }
[13:17:27.152]                         }
[13:17:27.152]                         frame <- frame + 1L
[13:17:27.152]                         envir <- sys.frame(frame)
[13:17:27.152]                       }
[13:17:27.152]                     }
[13:17:27.152]                     sendCondition <<- function(cond) NULL
[13:17:27.152]                   }
[13:17:27.152]                 })
[13:17:27.152]                 withCallingHandlers({
[13:17:27.152]                   {
[13:17:27.152]                     do.call(function(...) {
[13:17:27.152]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.152]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.152]                         ...future.globals.maxSize)) {
[13:17:27.152]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.152]                         on.exit(options(oopts), add = TRUE)
[13:17:27.152]                       }
[13:17:27.152]                       {
[13:17:27.152]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.152]                           FUN = function(jj) {
[13:17:27.152]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.152]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.152]                           })
[13:17:27.152]                       }
[13:17:27.152]                     }, args = future.call.arguments)
[13:17:27.152]                   }
[13:17:27.152]                 }, immediateCondition = function(cond) {
[13:17:27.152]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.152]                   sendCondition(cond)
[13:17:27.152]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.152]                   {
[13:17:27.152]                     inherits <- base::inherits
[13:17:27.152]                     invokeRestart <- base::invokeRestart
[13:17:27.152]                     is.null <- base::is.null
[13:17:27.152]                     muffled <- FALSE
[13:17:27.152]                     if (inherits(cond, "message")) {
[13:17:27.152]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.152]                       if (muffled) 
[13:17:27.152]                         invokeRestart("muffleMessage")
[13:17:27.152]                     }
[13:17:27.152]                     else if (inherits(cond, "warning")) {
[13:17:27.152]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.152]                       if (muffled) 
[13:17:27.152]                         invokeRestart("muffleWarning")
[13:17:27.152]                     }
[13:17:27.152]                     else if (inherits(cond, "condition")) {
[13:17:27.152]                       if (!is.null(pattern)) {
[13:17:27.152]                         computeRestarts <- base::computeRestarts
[13:17:27.152]                         grepl <- base::grepl
[13:17:27.152]                         restarts <- computeRestarts(cond)
[13:17:27.152]                         for (restart in restarts) {
[13:17:27.152]                           name <- restart$name
[13:17:27.152]                           if (is.null(name)) 
[13:17:27.152]                             next
[13:17:27.152]                           if (!grepl(pattern, name)) 
[13:17:27.152]                             next
[13:17:27.152]                           invokeRestart(restart)
[13:17:27.152]                           muffled <- TRUE
[13:17:27.152]                           break
[13:17:27.152]                         }
[13:17:27.152]                       }
[13:17:27.152]                     }
[13:17:27.152]                     invisible(muffled)
[13:17:27.152]                   }
[13:17:27.152]                   muffleCondition(cond)
[13:17:27.152]                 })
[13:17:27.152]             }))
[13:17:27.152]             future::FutureResult(value = ...future.value$value, 
[13:17:27.152]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.152]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.152]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.152]                     ...future.globalenv.names))
[13:17:27.152]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.152]         }, condition = base::local({
[13:17:27.152]             c <- base::c
[13:17:27.152]             inherits <- base::inherits
[13:17:27.152]             invokeRestart <- base::invokeRestart
[13:17:27.152]             length <- base::length
[13:17:27.152]             list <- base::list
[13:17:27.152]             seq.int <- base::seq.int
[13:17:27.152]             signalCondition <- base::signalCondition
[13:17:27.152]             sys.calls <- base::sys.calls
[13:17:27.152]             `[[` <- base::`[[`
[13:17:27.152]             `+` <- base::`+`
[13:17:27.152]             `<<-` <- base::`<<-`
[13:17:27.152]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.152]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.152]                   3L)]
[13:17:27.152]             }
[13:17:27.152]             function(cond) {
[13:17:27.152]                 is_error <- inherits(cond, "error")
[13:17:27.152]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.152]                   NULL)
[13:17:27.152]                 if (is_error) {
[13:17:27.152]                   sessionInformation <- function() {
[13:17:27.152]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.152]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.152]                       search = base::search(), system = base::Sys.info())
[13:17:27.152]                   }
[13:17:27.152]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.152]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.152]                     cond$call), session = sessionInformation(), 
[13:17:27.152]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.152]                   signalCondition(cond)
[13:17:27.152]                 }
[13:17:27.152]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.152]                 "immediateCondition"))) {
[13:17:27.152]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.152]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.152]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.152]                   if (TRUE && !signal) {
[13:17:27.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.152]                     {
[13:17:27.152]                       inherits <- base::inherits
[13:17:27.152]                       invokeRestart <- base::invokeRestart
[13:17:27.152]                       is.null <- base::is.null
[13:17:27.152]                       muffled <- FALSE
[13:17:27.152]                       if (inherits(cond, "message")) {
[13:17:27.152]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.152]                         if (muffled) 
[13:17:27.152]                           invokeRestart("muffleMessage")
[13:17:27.152]                       }
[13:17:27.152]                       else if (inherits(cond, "warning")) {
[13:17:27.152]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.152]                         if (muffled) 
[13:17:27.152]                           invokeRestart("muffleWarning")
[13:17:27.152]                       }
[13:17:27.152]                       else if (inherits(cond, "condition")) {
[13:17:27.152]                         if (!is.null(pattern)) {
[13:17:27.152]                           computeRestarts <- base::computeRestarts
[13:17:27.152]                           grepl <- base::grepl
[13:17:27.152]                           restarts <- computeRestarts(cond)
[13:17:27.152]                           for (restart in restarts) {
[13:17:27.152]                             name <- restart$name
[13:17:27.152]                             if (is.null(name)) 
[13:17:27.152]                               next
[13:17:27.152]                             if (!grepl(pattern, name)) 
[13:17:27.152]                               next
[13:17:27.152]                             invokeRestart(restart)
[13:17:27.152]                             muffled <- TRUE
[13:17:27.152]                             break
[13:17:27.152]                           }
[13:17:27.152]                         }
[13:17:27.152]                       }
[13:17:27.152]                       invisible(muffled)
[13:17:27.152]                     }
[13:17:27.152]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.152]                   }
[13:17:27.152]                 }
[13:17:27.152]                 else {
[13:17:27.152]                   if (TRUE) {
[13:17:27.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.152]                     {
[13:17:27.152]                       inherits <- base::inherits
[13:17:27.152]                       invokeRestart <- base::invokeRestart
[13:17:27.152]                       is.null <- base::is.null
[13:17:27.152]                       muffled <- FALSE
[13:17:27.152]                       if (inherits(cond, "message")) {
[13:17:27.152]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.152]                         if (muffled) 
[13:17:27.152]                           invokeRestart("muffleMessage")
[13:17:27.152]                       }
[13:17:27.152]                       else if (inherits(cond, "warning")) {
[13:17:27.152]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.152]                         if (muffled) 
[13:17:27.152]                           invokeRestart("muffleWarning")
[13:17:27.152]                       }
[13:17:27.152]                       else if (inherits(cond, "condition")) {
[13:17:27.152]                         if (!is.null(pattern)) {
[13:17:27.152]                           computeRestarts <- base::computeRestarts
[13:17:27.152]                           grepl <- base::grepl
[13:17:27.152]                           restarts <- computeRestarts(cond)
[13:17:27.152]                           for (restart in restarts) {
[13:17:27.152]                             name <- restart$name
[13:17:27.152]                             if (is.null(name)) 
[13:17:27.152]                               next
[13:17:27.152]                             if (!grepl(pattern, name)) 
[13:17:27.152]                               next
[13:17:27.152]                             invokeRestart(restart)
[13:17:27.152]                             muffled <- TRUE
[13:17:27.152]                             break
[13:17:27.152]                           }
[13:17:27.152]                         }
[13:17:27.152]                       }
[13:17:27.152]                       invisible(muffled)
[13:17:27.152]                     }
[13:17:27.152]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.152]                   }
[13:17:27.152]                 }
[13:17:27.152]             }
[13:17:27.152]         }))
[13:17:27.152]     }, error = function(ex) {
[13:17:27.152]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.152]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.152]                 ...future.rng), started = ...future.startTime, 
[13:17:27.152]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.152]             version = "1.8"), class = "FutureResult")
[13:17:27.152]     }, finally = {
[13:17:27.152]         if (!identical(...future.workdir, getwd())) 
[13:17:27.152]             setwd(...future.workdir)
[13:17:27.152]         {
[13:17:27.152]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.152]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.152]             }
[13:17:27.152]             base::options(...future.oldOptions)
[13:17:27.152]             if (.Platform$OS.type == "windows") {
[13:17:27.152]                 old_names <- names(...future.oldEnvVars)
[13:17:27.152]                 envs <- base::Sys.getenv()
[13:17:27.152]                 names <- names(envs)
[13:17:27.152]                 common <- intersect(names, old_names)
[13:17:27.152]                 added <- setdiff(names, old_names)
[13:17:27.152]                 removed <- setdiff(old_names, names)
[13:17:27.152]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.152]                   envs[common]]
[13:17:27.152]                 NAMES <- toupper(changed)
[13:17:27.152]                 args <- list()
[13:17:27.152]                 for (kk in seq_along(NAMES)) {
[13:17:27.152]                   name <- changed[[kk]]
[13:17:27.152]                   NAME <- NAMES[[kk]]
[13:17:27.152]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.152]                     next
[13:17:27.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.152]                 }
[13:17:27.152]                 NAMES <- toupper(added)
[13:17:27.152]                 for (kk in seq_along(NAMES)) {
[13:17:27.152]                   name <- added[[kk]]
[13:17:27.152]                   NAME <- NAMES[[kk]]
[13:17:27.152]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.152]                     next
[13:17:27.152]                   args[[name]] <- ""
[13:17:27.152]                 }
[13:17:27.152]                 NAMES <- toupper(removed)
[13:17:27.152]                 for (kk in seq_along(NAMES)) {
[13:17:27.152]                   name <- removed[[kk]]
[13:17:27.152]                   NAME <- NAMES[[kk]]
[13:17:27.152]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.152]                     next
[13:17:27.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.152]                 }
[13:17:27.152]                 if (length(args) > 0) 
[13:17:27.152]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.152]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.152]             }
[13:17:27.152]             else {
[13:17:27.152]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.152]             }
[13:17:27.152]             {
[13:17:27.152]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.152]                   0L) {
[13:17:27.152]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.152]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.152]                   base::options(opts)
[13:17:27.152]                 }
[13:17:27.152]                 {
[13:17:27.152]                   {
[13:17:27.152]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.152]                     NULL
[13:17:27.152]                   }
[13:17:27.152]                   options(future.plan = NULL)
[13:17:27.152]                   if (is.na(NA_character_)) 
[13:17:27.152]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.152]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.152]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.152]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.152]                     envir = parent.frame()) 
[13:17:27.152]                   {
[13:17:27.152]                     if (is.function(workers)) 
[13:17:27.152]                       workers <- workers()
[13:17:27.152]                     workers <- structure(as.integer(workers), 
[13:17:27.152]                       class = class(workers))
[13:17:27.152]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.152]                       workers >= 1)
[13:17:27.152]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.152]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.152]                     }
[13:17:27.152]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.152]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.152]                       envir = envir)
[13:17:27.152]                     if (!future$lazy) 
[13:17:27.152]                       future <- run(future)
[13:17:27.152]                     invisible(future)
[13:17:27.152]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.152]                 }
[13:17:27.152]             }
[13:17:27.152]         }
[13:17:27.152]     })
[13:17:27.152]     if (TRUE) {
[13:17:27.152]         base::sink(type = "output", split = FALSE)
[13:17:27.152]         if (TRUE) {
[13:17:27.152]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.152]         }
[13:17:27.152]         else {
[13:17:27.152]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.152]         }
[13:17:27.152]         base::close(...future.stdout)
[13:17:27.152]         ...future.stdout <- NULL
[13:17:27.152]     }
[13:17:27.152]     ...future.result$conditions <- ...future.conditions
[13:17:27.152]     ...future.result$finished <- base::Sys.time()
[13:17:27.152]     ...future.result
[13:17:27.152] }
[13:17:27.155] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[13:17:27.156] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.156] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.156] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:17:27.156] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:17:27.156] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:17:27.157] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:17:27.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:27.158] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.158] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[13:17:27.158] MultisessionFuture started
[13:17:27.158] - Launch lazy future ... done
[13:17:27.159] run() for ‘MultisessionFuture’ ... done
[13:17:27.159] Created future:
[13:17:27.159] MultisessionFuture:
[13:17:27.159] Label: ‘future_apply-2’
[13:17:27.159] Expression:
[13:17:27.159] {
[13:17:27.159]     do.call(function(...) {
[13:17:27.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.159]             on.exit(options(oopts), add = TRUE)
[13:17:27.159]         }
[13:17:27.159]         {
[13:17:27.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.159]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.159]             })
[13:17:27.159]         }
[13:17:27.159]     }, args = future.call.arguments)
[13:17:27.159] }
[13:17:27.159] Lazy evaluation: FALSE
[13:17:27.159] Asynchronous evaluation: TRUE
[13:17:27.159] Local evaluation: TRUE
[13:17:27.159] Environment: R_GlobalEnv
[13:17:27.159] Capture standard output: TRUE
[13:17:27.159] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.159] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.159] Packages: <none>
[13:17:27.159] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.159] Resolved: FALSE
[13:17:27.159] Value: <not collected>
[13:17:27.159] Conditions captured: <none>
[13:17:27.159] Early signaling: FALSE
[13:17:27.159] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.159] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.170] Chunk #2 of 2 ... DONE
[13:17:27.170] Launching 2 futures (chunks) ... DONE
[13:17:27.170] Resolving 2 futures (chunks) ...
[13:17:27.171] resolve() on list ...
[13:17:27.171]  recursive: 0
[13:17:27.171]  length: 2
[13:17:27.171] 
[13:17:27.171] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.171] - Validating connection of MultisessionFuture
[13:17:27.172] - received message: FutureResult
[13:17:27.172] - Received FutureResult
[13:17:27.172] - Erased future from FutureRegistry
[13:17:27.172] result() for ClusterFuture ...
[13:17:27.172] - result already collected: FutureResult
[13:17:27.172] result() for ClusterFuture ... done
[13:17:27.172] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.172] Future #1
[13:17:27.172] result() for ClusterFuture ...
[13:17:27.173] - result already collected: FutureResult
[13:17:27.173] result() for ClusterFuture ... done
[13:17:27.173] result() for ClusterFuture ...
[13:17:27.173] - result already collected: FutureResult
[13:17:27.173] result() for ClusterFuture ... done
[13:17:27.173] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.173] - nx: 2
[13:17:27.173] - relay: TRUE
[13:17:27.173] - stdout: TRUE
[13:17:27.173] - signal: TRUE
[13:17:27.173] - resignal: FALSE
[13:17:27.174] - force: TRUE
[13:17:27.174] - relayed: [n=2] FALSE, FALSE
[13:17:27.174] - queued futures: [n=2] FALSE, FALSE
[13:17:27.174]  - until=1
[13:17:27.174]  - relaying element #1
[13:17:27.174] result() for ClusterFuture ...
[13:17:27.174] - result already collected: FutureResult
[13:17:27.174] result() for ClusterFuture ... done
[13:17:27.174] result() for ClusterFuture ...
[13:17:27.174] - result already collected: FutureResult
[13:17:27.174] result() for ClusterFuture ... done
[13:17:27.175] result() for ClusterFuture ...
[13:17:27.175] - result already collected: FutureResult
[13:17:27.175] result() for ClusterFuture ... done
[13:17:27.175] result() for ClusterFuture ...
[13:17:27.175] - result already collected: FutureResult
[13:17:27.175] result() for ClusterFuture ... done
[13:17:27.175] - relayed: [n=2] TRUE, FALSE
[13:17:27.175] - queued futures: [n=2] TRUE, FALSE
[13:17:27.175] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.175]  length: 1 (resolved future 1)
[13:17:27.217] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.217] - Validating connection of MultisessionFuture
[13:17:27.218] - received message: FutureResult
[13:17:27.218] - Received FutureResult
[13:17:27.218] - Erased future from FutureRegistry
[13:17:27.218] result() for ClusterFuture ...
[13:17:27.218] - result already collected: FutureResult
[13:17:27.218] result() for ClusterFuture ... done
[13:17:27.218] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.218] Future #2
[13:17:27.218] result() for ClusterFuture ...
[13:17:27.219] - result already collected: FutureResult
[13:17:27.219] result() for ClusterFuture ... done
[13:17:27.219] result() for ClusterFuture ...
[13:17:27.219] - result already collected: FutureResult
[13:17:27.219] result() for ClusterFuture ... done
[13:17:27.219] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.219] - nx: 2
[13:17:27.219] - relay: TRUE
[13:17:27.219] - stdout: TRUE
[13:17:27.219] - signal: TRUE
[13:17:27.219] - resignal: FALSE
[13:17:27.220] - force: TRUE
[13:17:27.220] - relayed: [n=2] TRUE, FALSE
[13:17:27.220] - queued futures: [n=2] TRUE, FALSE
[13:17:27.220]  - until=2
[13:17:27.220]  - relaying element #2
[13:17:27.220] result() for ClusterFuture ...
[13:17:27.220] - result already collected: FutureResult
[13:17:27.220] result() for ClusterFuture ... done
[13:17:27.220] result() for ClusterFuture ...
[13:17:27.220] - result already collected: FutureResult
[13:17:27.220] result() for ClusterFuture ... done
[13:17:27.221] result() for ClusterFuture ...
[13:17:27.221] - result already collected: FutureResult
[13:17:27.221] result() for ClusterFuture ... done
[13:17:27.221] result() for ClusterFuture ...
[13:17:27.221] - result already collected: FutureResult
[13:17:27.221] result() for ClusterFuture ... done
[13:17:27.221] - relayed: [n=2] TRUE, TRUE
[13:17:27.221] - queued futures: [n=2] TRUE, TRUE
[13:17:27.221] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.221]  length: 0 (resolved future 2)
[13:17:27.222] Relaying remaining futures
[13:17:27.222] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.222] - nx: 2
[13:17:27.222] - relay: TRUE
[13:17:27.222] - stdout: TRUE
[13:17:27.222] - signal: TRUE
[13:17:27.222] - resignal: FALSE
[13:17:27.222] - force: TRUE
[13:17:27.222] - relayed: [n=2] TRUE, TRUE
[13:17:27.222] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.222] - relayed: [n=2] TRUE, TRUE
[13:17:27.223] - queued futures: [n=2] TRUE, TRUE
[13:17:27.223] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.223] resolve() on list ... DONE
[13:17:27.223] result() for ClusterFuture ...
[13:17:27.223] - result already collected: FutureResult
[13:17:27.223] result() for ClusterFuture ... done
[13:17:27.223] result() for ClusterFuture ...
[13:17:27.223] - result already collected: FutureResult
[13:17:27.223] result() for ClusterFuture ... done
[13:17:27.223] result() for ClusterFuture ...
[13:17:27.223] - result already collected: FutureResult
[13:17:27.224] result() for ClusterFuture ... done
[13:17:27.224] result() for ClusterFuture ...
[13:17:27.224] - result already collected: FutureResult
[13:17:27.224] result() for ClusterFuture ... done
[13:17:27.224]  - Number of value chunks collected: 2
[13:17:27.224] Resolving 2 futures (chunks) ... DONE
[13:17:27.224] Reducing values from 2 chunks ...
[13:17:27.224]  - Number of values collected after concatenation: 2
[13:17:27.224]  - Number of values expected: 2
[13:17:27.224] Reducing values from 2 chunks ... DONE
[13:17:27.224] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[13:17:27.225] getGlobalsAndPackagesXApply() ...
[13:17:27.225]  - future.globals: TRUE
[13:17:27.225] getGlobalsAndPackages() ...
[13:17:27.225] Searching for globals...
[13:17:27.226] - globals found: [1] ‘FUN’
[13:17:27.226] Searching for globals ... DONE
[13:17:27.226] Resolving globals: FALSE
[13:17:27.227] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:27.227] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:27.227] - globals: [1] ‘FUN’
[13:17:27.227] 
[13:17:27.227] getGlobalsAndPackages() ... DONE
[13:17:27.228]  - globals found/used: [n=1] ‘FUN’
[13:17:27.228]  - needed namespaces: [n=0] 
[13:17:27.228] Finding globals ... DONE
[13:17:27.228]  - use_args: TRUE
[13:17:27.228]  - Getting '...' globals ...
[13:17:27.228] resolve() on list ...
[13:17:27.228]  recursive: 0
[13:17:27.228]  length: 1
[13:17:27.228]  elements: ‘...’
[13:17:27.229]  length: 0 (resolved future 1)
[13:17:27.229] resolve() on list ... DONE
[13:17:27.229]    - '...' content: [n=0] 
[13:17:27.229] List of 1
[13:17:27.229]  $ ...: list()
[13:17:27.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.229]  - attr(*, "where")=List of 1
[13:17:27.229]   ..$ ...:<environment: 0x5647bc4727a0> 
[13:17:27.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.229]  - attr(*, "resolved")= logi TRUE
[13:17:27.229]  - attr(*, "total_size")= num NA
[13:17:27.231]  - Getting '...' globals ... DONE
[13:17:27.232] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.232] List of 2
[13:17:27.232]  $ ...future.FUN:function (x)  
[13:17:27.232]  $ ...          : list()
[13:17:27.232]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.232]  - attr(*, "where")=List of 2
[13:17:27.232]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.232]   ..$ ...          :<environment: 0x5647bc4727a0> 
[13:17:27.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.232]  - attr(*, "resolved")= logi FALSE
[13:17:27.232]  - attr(*, "total_size")= num 848
[13:17:27.234] Packages to be attached in all futures: [n=0] 
[13:17:27.235] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.238] future_lapply() ...
[13:17:27.242] Number of chunks: 2
[13:17:27.242] getGlobalsAndPackagesXApply() ...
[13:17:27.242]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.242]  - use_args: TRUE
[13:17:27.242] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.242] List of 2
[13:17:27.242]  $ ...          : list()
[13:17:27.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.242]  $ ...future.FUN:function (x)  
[13:17:27.242]  - attr(*, "where")=List of 2
[13:17:27.242]   ..$ ...          :<environment: 0x5647bc4727a0> 
[13:17:27.242]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:27.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.242]  - attr(*, "resolved")= logi FALSE
[13:17:27.242]  - attr(*, "total_size")= num NA
[13:17:27.246] Packages to be attached in all futures: [n=0] 
[13:17:27.246] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.246] Number of futures (= number of chunks): 2
[13:17:27.246] Launching 2 futures (chunks) ...
[13:17:27.246] Chunk #1 of 2 ...
[13:17:27.246]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:27.247]  - seeds: <none>
[13:17:27.247] getGlobalsAndPackages() ...
[13:17:27.247] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.247] Resolving globals: FALSE
[13:17:27.247] Tweak future expression to call with '...' arguments ...
[13:17:27.247] {
[13:17:27.247]     do.call(function(...) {
[13:17:27.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.247]             on.exit(options(oopts), add = TRUE)
[13:17:27.247]         }
[13:17:27.247]         {
[13:17:27.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.247]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.247]             })
[13:17:27.247]         }
[13:17:27.247]     }, args = future.call.arguments)
[13:17:27.247] }
[13:17:27.247] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.248] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.248] 
[13:17:27.248] getGlobalsAndPackages() ... DONE
[13:17:27.248] run() for ‘Future’ ...
[13:17:27.248] - state: ‘created’
[13:17:27.249] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.263] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.263]   - Field: ‘node’
[13:17:27.263]   - Field: ‘label’
[13:17:27.263]   - Field: ‘local’
[13:17:27.264]   - Field: ‘owner’
[13:17:27.264]   - Field: ‘envir’
[13:17:27.264]   - Field: ‘workers’
[13:17:27.264]   - Field: ‘packages’
[13:17:27.264]   - Field: ‘gc’
[13:17:27.264]   - Field: ‘conditions’
[13:17:27.264]   - Field: ‘persistent’
[13:17:27.264]   - Field: ‘expr’
[13:17:27.264]   - Field: ‘uuid’
[13:17:27.264]   - Field: ‘seed’
[13:17:27.265]   - Field: ‘version’
[13:17:27.265]   - Field: ‘result’
[13:17:27.265]   - Field: ‘asynchronous’
[13:17:27.265]   - Field: ‘calls’
[13:17:27.265]   - Field: ‘globals’
[13:17:27.265]   - Field: ‘stdout’
[13:17:27.265]   - Field: ‘earlySignal’
[13:17:27.265]   - Field: ‘lazy’
[13:17:27.265]   - Field: ‘state’
[13:17:27.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.266] - Launch lazy future ...
[13:17:27.266] Packages needed by the future expression (n = 0): <none>
[13:17:27.266] Packages needed by future strategies (n = 0): <none>
[13:17:27.266] {
[13:17:27.266]     {
[13:17:27.266]         {
[13:17:27.266]             ...future.startTime <- base::Sys.time()
[13:17:27.266]             {
[13:17:27.266]                 {
[13:17:27.266]                   {
[13:17:27.266]                     {
[13:17:27.266]                       base::local({
[13:17:27.266]                         has_future <- base::requireNamespace("future", 
[13:17:27.266]                           quietly = TRUE)
[13:17:27.266]                         if (has_future) {
[13:17:27.266]                           ns <- base::getNamespace("future")
[13:17:27.266]                           version <- ns[[".package"]][["version"]]
[13:17:27.266]                           if (is.null(version)) 
[13:17:27.266]                             version <- utils::packageVersion("future")
[13:17:27.266]                         }
[13:17:27.266]                         else {
[13:17:27.266]                           version <- NULL
[13:17:27.266]                         }
[13:17:27.266]                         if (!has_future || version < "1.8.0") {
[13:17:27.266]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.266]                             "", base::R.version$version.string), 
[13:17:27.266]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.266]                               "release", "version")], collapse = " "), 
[13:17:27.266]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.266]                             info)
[13:17:27.266]                           info <- base::paste(info, collapse = "; ")
[13:17:27.266]                           if (!has_future) {
[13:17:27.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.266]                               info)
[13:17:27.266]                           }
[13:17:27.266]                           else {
[13:17:27.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.266]                               info, version)
[13:17:27.266]                           }
[13:17:27.266]                           base::stop(msg)
[13:17:27.266]                         }
[13:17:27.266]                       })
[13:17:27.266]                     }
[13:17:27.266]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.266]                     base::options(mc.cores = 1L)
[13:17:27.266]                   }
[13:17:27.266]                   options(future.plan = NULL)
[13:17:27.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.266]                 }
[13:17:27.266]                 ...future.workdir <- getwd()
[13:17:27.266]             }
[13:17:27.266]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.266]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.266]         }
[13:17:27.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.266]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.266]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.266]             base::names(...future.oldOptions))
[13:17:27.266]     }
[13:17:27.266]     if (FALSE) {
[13:17:27.266]     }
[13:17:27.266]     else {
[13:17:27.266]         if (TRUE) {
[13:17:27.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.266]                 open = "w")
[13:17:27.266]         }
[13:17:27.266]         else {
[13:17:27.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.266]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.266]         }
[13:17:27.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.266]             base::sink(type = "output", split = FALSE)
[13:17:27.266]             base::close(...future.stdout)
[13:17:27.266]         }, add = TRUE)
[13:17:27.266]     }
[13:17:27.266]     ...future.frame <- base::sys.nframe()
[13:17:27.266]     ...future.conditions <- base::list()
[13:17:27.266]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.266]     if (FALSE) {
[13:17:27.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.266]     }
[13:17:27.266]     ...future.result <- base::tryCatch({
[13:17:27.266]         base::withCallingHandlers({
[13:17:27.266]             ...future.value <- base::withVisible(base::local({
[13:17:27.266]                 ...future.makeSendCondition <- local({
[13:17:27.266]                   sendCondition <- NULL
[13:17:27.266]                   function(frame = 1L) {
[13:17:27.266]                     if (is.function(sendCondition)) 
[13:17:27.266]                       return(sendCondition)
[13:17:27.266]                     ns <- getNamespace("parallel")
[13:17:27.266]                     if (exists("sendData", mode = "function", 
[13:17:27.266]                       envir = ns)) {
[13:17:27.266]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.266]                         envir = ns)
[13:17:27.266]                       envir <- sys.frame(frame)
[13:17:27.266]                       master <- NULL
[13:17:27.266]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.266]                         !identical(envir, emptyenv())) {
[13:17:27.266]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.266]                           inherits = FALSE)) {
[13:17:27.266]                           master <- get("master", mode = "list", 
[13:17:27.266]                             envir = envir, inherits = FALSE)
[13:17:27.266]                           if (inherits(master, c("SOCKnode", 
[13:17:27.266]                             "SOCK0node"))) {
[13:17:27.266]                             sendCondition <<- function(cond) {
[13:17:27.266]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.266]                                 success = TRUE)
[13:17:27.266]                               parallel_sendData(master, data)
[13:17:27.266]                             }
[13:17:27.266]                             return(sendCondition)
[13:17:27.266]                           }
[13:17:27.266]                         }
[13:17:27.266]                         frame <- frame + 1L
[13:17:27.266]                         envir <- sys.frame(frame)
[13:17:27.266]                       }
[13:17:27.266]                     }
[13:17:27.266]                     sendCondition <<- function(cond) NULL
[13:17:27.266]                   }
[13:17:27.266]                 })
[13:17:27.266]                 withCallingHandlers({
[13:17:27.266]                   {
[13:17:27.266]                     do.call(function(...) {
[13:17:27.266]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.266]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.266]                         ...future.globals.maxSize)) {
[13:17:27.266]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.266]                         on.exit(options(oopts), add = TRUE)
[13:17:27.266]                       }
[13:17:27.266]                       {
[13:17:27.266]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.266]                           FUN = function(jj) {
[13:17:27.266]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.266]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.266]                           })
[13:17:27.266]                       }
[13:17:27.266]                     }, args = future.call.arguments)
[13:17:27.266]                   }
[13:17:27.266]                 }, immediateCondition = function(cond) {
[13:17:27.266]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.266]                   sendCondition(cond)
[13:17:27.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.266]                   {
[13:17:27.266]                     inherits <- base::inherits
[13:17:27.266]                     invokeRestart <- base::invokeRestart
[13:17:27.266]                     is.null <- base::is.null
[13:17:27.266]                     muffled <- FALSE
[13:17:27.266]                     if (inherits(cond, "message")) {
[13:17:27.266]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.266]                       if (muffled) 
[13:17:27.266]                         invokeRestart("muffleMessage")
[13:17:27.266]                     }
[13:17:27.266]                     else if (inherits(cond, "warning")) {
[13:17:27.266]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.266]                       if (muffled) 
[13:17:27.266]                         invokeRestart("muffleWarning")
[13:17:27.266]                     }
[13:17:27.266]                     else if (inherits(cond, "condition")) {
[13:17:27.266]                       if (!is.null(pattern)) {
[13:17:27.266]                         computeRestarts <- base::computeRestarts
[13:17:27.266]                         grepl <- base::grepl
[13:17:27.266]                         restarts <- computeRestarts(cond)
[13:17:27.266]                         for (restart in restarts) {
[13:17:27.266]                           name <- restart$name
[13:17:27.266]                           if (is.null(name)) 
[13:17:27.266]                             next
[13:17:27.266]                           if (!grepl(pattern, name)) 
[13:17:27.266]                             next
[13:17:27.266]                           invokeRestart(restart)
[13:17:27.266]                           muffled <- TRUE
[13:17:27.266]                           break
[13:17:27.266]                         }
[13:17:27.266]                       }
[13:17:27.266]                     }
[13:17:27.266]                     invisible(muffled)
[13:17:27.266]                   }
[13:17:27.266]                   muffleCondition(cond)
[13:17:27.266]                 })
[13:17:27.266]             }))
[13:17:27.266]             future::FutureResult(value = ...future.value$value, 
[13:17:27.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.266]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.266]                     ...future.globalenv.names))
[13:17:27.266]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.266]         }, condition = base::local({
[13:17:27.266]             c <- base::c
[13:17:27.266]             inherits <- base::inherits
[13:17:27.266]             invokeRestart <- base::invokeRestart
[13:17:27.266]             length <- base::length
[13:17:27.266]             list <- base::list
[13:17:27.266]             seq.int <- base::seq.int
[13:17:27.266]             signalCondition <- base::signalCondition
[13:17:27.266]             sys.calls <- base::sys.calls
[13:17:27.266]             `[[` <- base::`[[`
[13:17:27.266]             `+` <- base::`+`
[13:17:27.266]             `<<-` <- base::`<<-`
[13:17:27.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.266]                   3L)]
[13:17:27.266]             }
[13:17:27.266]             function(cond) {
[13:17:27.266]                 is_error <- inherits(cond, "error")
[13:17:27.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.266]                   NULL)
[13:17:27.266]                 if (is_error) {
[13:17:27.266]                   sessionInformation <- function() {
[13:17:27.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.266]                       search = base::search(), system = base::Sys.info())
[13:17:27.266]                   }
[13:17:27.266]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.266]                     cond$call), session = sessionInformation(), 
[13:17:27.266]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.266]                   signalCondition(cond)
[13:17:27.266]                 }
[13:17:27.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.266]                 "immediateCondition"))) {
[13:17:27.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.266]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.266]                   if (TRUE && !signal) {
[13:17:27.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.266]                     {
[13:17:27.266]                       inherits <- base::inherits
[13:17:27.266]                       invokeRestart <- base::invokeRestart
[13:17:27.266]                       is.null <- base::is.null
[13:17:27.266]                       muffled <- FALSE
[13:17:27.266]                       if (inherits(cond, "message")) {
[13:17:27.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.266]                         if (muffled) 
[13:17:27.266]                           invokeRestart("muffleMessage")
[13:17:27.266]                       }
[13:17:27.266]                       else if (inherits(cond, "warning")) {
[13:17:27.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.266]                         if (muffled) 
[13:17:27.266]                           invokeRestart("muffleWarning")
[13:17:27.266]                       }
[13:17:27.266]                       else if (inherits(cond, "condition")) {
[13:17:27.266]                         if (!is.null(pattern)) {
[13:17:27.266]                           computeRestarts <- base::computeRestarts
[13:17:27.266]                           grepl <- base::grepl
[13:17:27.266]                           restarts <- computeRestarts(cond)
[13:17:27.266]                           for (restart in restarts) {
[13:17:27.266]                             name <- restart$name
[13:17:27.266]                             if (is.null(name)) 
[13:17:27.266]                               next
[13:17:27.266]                             if (!grepl(pattern, name)) 
[13:17:27.266]                               next
[13:17:27.266]                             invokeRestart(restart)
[13:17:27.266]                             muffled <- TRUE
[13:17:27.266]                             break
[13:17:27.266]                           }
[13:17:27.266]                         }
[13:17:27.266]                       }
[13:17:27.266]                       invisible(muffled)
[13:17:27.266]                     }
[13:17:27.266]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.266]                   }
[13:17:27.266]                 }
[13:17:27.266]                 else {
[13:17:27.266]                   if (TRUE) {
[13:17:27.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.266]                     {
[13:17:27.266]                       inherits <- base::inherits
[13:17:27.266]                       invokeRestart <- base::invokeRestart
[13:17:27.266]                       is.null <- base::is.null
[13:17:27.266]                       muffled <- FALSE
[13:17:27.266]                       if (inherits(cond, "message")) {
[13:17:27.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.266]                         if (muffled) 
[13:17:27.266]                           invokeRestart("muffleMessage")
[13:17:27.266]                       }
[13:17:27.266]                       else if (inherits(cond, "warning")) {
[13:17:27.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.266]                         if (muffled) 
[13:17:27.266]                           invokeRestart("muffleWarning")
[13:17:27.266]                       }
[13:17:27.266]                       else if (inherits(cond, "condition")) {
[13:17:27.266]                         if (!is.null(pattern)) {
[13:17:27.266]                           computeRestarts <- base::computeRestarts
[13:17:27.266]                           grepl <- base::grepl
[13:17:27.266]                           restarts <- computeRestarts(cond)
[13:17:27.266]                           for (restart in restarts) {
[13:17:27.266]                             name <- restart$name
[13:17:27.266]                             if (is.null(name)) 
[13:17:27.266]                               next
[13:17:27.266]                             if (!grepl(pattern, name)) 
[13:17:27.266]                               next
[13:17:27.266]                             invokeRestart(restart)
[13:17:27.266]                             muffled <- TRUE
[13:17:27.266]                             break
[13:17:27.266]                           }
[13:17:27.266]                         }
[13:17:27.266]                       }
[13:17:27.266]                       invisible(muffled)
[13:17:27.266]                     }
[13:17:27.266]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.266]                   }
[13:17:27.266]                 }
[13:17:27.266]             }
[13:17:27.266]         }))
[13:17:27.266]     }, error = function(ex) {
[13:17:27.266]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.266]                 ...future.rng), started = ...future.startTime, 
[13:17:27.266]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.266]             version = "1.8"), class = "FutureResult")
[13:17:27.266]     }, finally = {
[13:17:27.266]         if (!identical(...future.workdir, getwd())) 
[13:17:27.266]             setwd(...future.workdir)
[13:17:27.266]         {
[13:17:27.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.266]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.266]             }
[13:17:27.266]             base::options(...future.oldOptions)
[13:17:27.266]             if (.Platform$OS.type == "windows") {
[13:17:27.266]                 old_names <- names(...future.oldEnvVars)
[13:17:27.266]                 envs <- base::Sys.getenv()
[13:17:27.266]                 names <- names(envs)
[13:17:27.266]                 common <- intersect(names, old_names)
[13:17:27.266]                 added <- setdiff(names, old_names)
[13:17:27.266]                 removed <- setdiff(old_names, names)
[13:17:27.266]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.266]                   envs[common]]
[13:17:27.266]                 NAMES <- toupper(changed)
[13:17:27.266]                 args <- list()
[13:17:27.266]                 for (kk in seq_along(NAMES)) {
[13:17:27.266]                   name <- changed[[kk]]
[13:17:27.266]                   NAME <- NAMES[[kk]]
[13:17:27.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.266]                     next
[13:17:27.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.266]                 }
[13:17:27.266]                 NAMES <- toupper(added)
[13:17:27.266]                 for (kk in seq_along(NAMES)) {
[13:17:27.266]                   name <- added[[kk]]
[13:17:27.266]                   NAME <- NAMES[[kk]]
[13:17:27.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.266]                     next
[13:17:27.266]                   args[[name]] <- ""
[13:17:27.266]                 }
[13:17:27.266]                 NAMES <- toupper(removed)
[13:17:27.266]                 for (kk in seq_along(NAMES)) {
[13:17:27.266]                   name <- removed[[kk]]
[13:17:27.266]                   NAME <- NAMES[[kk]]
[13:17:27.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.266]                     next
[13:17:27.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.266]                 }
[13:17:27.266]                 if (length(args) > 0) 
[13:17:27.266]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.266]             }
[13:17:27.266]             else {
[13:17:27.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.266]             }
[13:17:27.266]             {
[13:17:27.266]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.266]                   0L) {
[13:17:27.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.266]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.266]                   base::options(opts)
[13:17:27.266]                 }
[13:17:27.266]                 {
[13:17:27.266]                   {
[13:17:27.266]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.266]                     NULL
[13:17:27.266]                   }
[13:17:27.266]                   options(future.plan = NULL)
[13:17:27.266]                   if (is.na(NA_character_)) 
[13:17:27.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.266]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.266]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.266]                     envir = parent.frame()) 
[13:17:27.266]                   {
[13:17:27.266]                     if (is.function(workers)) 
[13:17:27.266]                       workers <- workers()
[13:17:27.266]                     workers <- structure(as.integer(workers), 
[13:17:27.266]                       class = class(workers))
[13:17:27.266]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.266]                       workers >= 1)
[13:17:27.266]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.266]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.266]                     }
[13:17:27.266]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.266]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.266]                       envir = envir)
[13:17:27.266]                     if (!future$lazy) 
[13:17:27.266]                       future <- run(future)
[13:17:27.266]                     invisible(future)
[13:17:27.266]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.266]                 }
[13:17:27.266]             }
[13:17:27.266]         }
[13:17:27.266]     })
[13:17:27.266]     if (TRUE) {
[13:17:27.266]         base::sink(type = "output", split = FALSE)
[13:17:27.266]         if (TRUE) {
[13:17:27.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.266]         }
[13:17:27.266]         else {
[13:17:27.266]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.266]         }
[13:17:27.266]         base::close(...future.stdout)
[13:17:27.266]         ...future.stdout <- NULL
[13:17:27.266]     }
[13:17:27.266]     ...future.result$conditions <- ...future.conditions
[13:17:27.266]     ...future.result$finished <- base::Sys.time()
[13:17:27.266]     ...future.result
[13:17:27.266] }
[13:17:27.270] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:17:27.270] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.270] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.270] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:17:27.271] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:17:27.271] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[13:17:27.271] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[13:17:27.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:27.272] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.272] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:17:27.272] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:17:27.272] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:17:27.273] MultisessionFuture started
[13:17:27.273] - Launch lazy future ... done
[13:17:27.274] run() for ‘MultisessionFuture’ ... done
[13:17:27.274] Created future:
[13:17:27.274] MultisessionFuture:
[13:17:27.274] Label: ‘future_apply-1’
[13:17:27.274] Expression:
[13:17:27.274] {
[13:17:27.274]     do.call(function(...) {
[13:17:27.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.274]             on.exit(options(oopts), add = TRUE)
[13:17:27.274]         }
[13:17:27.274]         {
[13:17:27.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.274]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.274]             })
[13:17:27.274]         }
[13:17:27.274]     }, args = future.call.arguments)
[13:17:27.274] }
[13:17:27.274] Lazy evaluation: FALSE
[13:17:27.274] Asynchronous evaluation: TRUE
[13:17:27.274] Local evaluation: TRUE
[13:17:27.274] Environment: R_GlobalEnv
[13:17:27.274] Capture standard output: TRUE
[13:17:27.274] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.274] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:27.274] Packages: <none>
[13:17:27.274] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.274] Resolved: FALSE
[13:17:27.274] Value: <not collected>
[13:17:27.274] Conditions captured: <none>
[13:17:27.274] Early signaling: FALSE
[13:17:27.274] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.274] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.285] Chunk #1 of 2 ... DONE
[13:17:27.285] Chunk #2 of 2 ...
[13:17:27.286]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:27.286]  - seeds: <none>
[13:17:27.286] getGlobalsAndPackages() ...
[13:17:27.286] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.286] Resolving globals: FALSE
[13:17:27.286] Tweak future expression to call with '...' arguments ...
[13:17:27.286] {
[13:17:27.286]     do.call(function(...) {
[13:17:27.286]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.286]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.286]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.286]             on.exit(options(oopts), add = TRUE)
[13:17:27.286]         }
[13:17:27.286]         {
[13:17:27.286]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.286]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.286]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.286]             })
[13:17:27.286]         }
[13:17:27.286]     }, args = future.call.arguments)
[13:17:27.286] }
[13:17:27.287] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.287] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.287] 
[13:17:27.287] getGlobalsAndPackages() ... DONE
[13:17:27.290] run() for ‘Future’ ...
[13:17:27.290] - state: ‘created’
[13:17:27.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.305] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.305]   - Field: ‘node’
[13:17:27.305]   - Field: ‘label’
[13:17:27.305]   - Field: ‘local’
[13:17:27.305]   - Field: ‘owner’
[13:17:27.305]   - Field: ‘envir’
[13:17:27.306]   - Field: ‘workers’
[13:17:27.306]   - Field: ‘packages’
[13:17:27.306]   - Field: ‘gc’
[13:17:27.306]   - Field: ‘conditions’
[13:17:27.306]   - Field: ‘persistent’
[13:17:27.306]   - Field: ‘expr’
[13:17:27.306]   - Field: ‘uuid’
[13:17:27.306]   - Field: ‘seed’
[13:17:27.306]   - Field: ‘version’
[13:17:27.306]   - Field: ‘result’
[13:17:27.306]   - Field: ‘asynchronous’
[13:17:27.307]   - Field: ‘calls’
[13:17:27.307]   - Field: ‘globals’
[13:17:27.307]   - Field: ‘stdout’
[13:17:27.307]   - Field: ‘earlySignal’
[13:17:27.307]   - Field: ‘lazy’
[13:17:27.307]   - Field: ‘state’
[13:17:27.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.307] - Launch lazy future ...
[13:17:27.307] Packages needed by the future expression (n = 0): <none>
[13:17:27.308] Packages needed by future strategies (n = 0): <none>
[13:17:27.308] {
[13:17:27.308]     {
[13:17:27.308]         {
[13:17:27.308]             ...future.startTime <- base::Sys.time()
[13:17:27.308]             {
[13:17:27.308]                 {
[13:17:27.308]                   {
[13:17:27.308]                     {
[13:17:27.308]                       base::local({
[13:17:27.308]                         has_future <- base::requireNamespace("future", 
[13:17:27.308]                           quietly = TRUE)
[13:17:27.308]                         if (has_future) {
[13:17:27.308]                           ns <- base::getNamespace("future")
[13:17:27.308]                           version <- ns[[".package"]][["version"]]
[13:17:27.308]                           if (is.null(version)) 
[13:17:27.308]                             version <- utils::packageVersion("future")
[13:17:27.308]                         }
[13:17:27.308]                         else {
[13:17:27.308]                           version <- NULL
[13:17:27.308]                         }
[13:17:27.308]                         if (!has_future || version < "1.8.0") {
[13:17:27.308]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.308]                             "", base::R.version$version.string), 
[13:17:27.308]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.308]                               "release", "version")], collapse = " "), 
[13:17:27.308]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.308]                             info)
[13:17:27.308]                           info <- base::paste(info, collapse = "; ")
[13:17:27.308]                           if (!has_future) {
[13:17:27.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.308]                               info)
[13:17:27.308]                           }
[13:17:27.308]                           else {
[13:17:27.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.308]                               info, version)
[13:17:27.308]                           }
[13:17:27.308]                           base::stop(msg)
[13:17:27.308]                         }
[13:17:27.308]                       })
[13:17:27.308]                     }
[13:17:27.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.308]                     base::options(mc.cores = 1L)
[13:17:27.308]                   }
[13:17:27.308]                   options(future.plan = NULL)
[13:17:27.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.308]                 }
[13:17:27.308]                 ...future.workdir <- getwd()
[13:17:27.308]             }
[13:17:27.308]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.308]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.308]         }
[13:17:27.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.308]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.308]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.308]             base::names(...future.oldOptions))
[13:17:27.308]     }
[13:17:27.308]     if (FALSE) {
[13:17:27.308]     }
[13:17:27.308]     else {
[13:17:27.308]         if (TRUE) {
[13:17:27.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.308]                 open = "w")
[13:17:27.308]         }
[13:17:27.308]         else {
[13:17:27.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.308]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.308]         }
[13:17:27.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.308]             base::sink(type = "output", split = FALSE)
[13:17:27.308]             base::close(...future.stdout)
[13:17:27.308]         }, add = TRUE)
[13:17:27.308]     }
[13:17:27.308]     ...future.frame <- base::sys.nframe()
[13:17:27.308]     ...future.conditions <- base::list()
[13:17:27.308]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.308]     if (FALSE) {
[13:17:27.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.308]     }
[13:17:27.308]     ...future.result <- base::tryCatch({
[13:17:27.308]         base::withCallingHandlers({
[13:17:27.308]             ...future.value <- base::withVisible(base::local({
[13:17:27.308]                 ...future.makeSendCondition <- local({
[13:17:27.308]                   sendCondition <- NULL
[13:17:27.308]                   function(frame = 1L) {
[13:17:27.308]                     if (is.function(sendCondition)) 
[13:17:27.308]                       return(sendCondition)
[13:17:27.308]                     ns <- getNamespace("parallel")
[13:17:27.308]                     if (exists("sendData", mode = "function", 
[13:17:27.308]                       envir = ns)) {
[13:17:27.308]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.308]                         envir = ns)
[13:17:27.308]                       envir <- sys.frame(frame)
[13:17:27.308]                       master <- NULL
[13:17:27.308]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.308]                         !identical(envir, emptyenv())) {
[13:17:27.308]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.308]                           inherits = FALSE)) {
[13:17:27.308]                           master <- get("master", mode = "list", 
[13:17:27.308]                             envir = envir, inherits = FALSE)
[13:17:27.308]                           if (inherits(master, c("SOCKnode", 
[13:17:27.308]                             "SOCK0node"))) {
[13:17:27.308]                             sendCondition <<- function(cond) {
[13:17:27.308]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.308]                                 success = TRUE)
[13:17:27.308]                               parallel_sendData(master, data)
[13:17:27.308]                             }
[13:17:27.308]                             return(sendCondition)
[13:17:27.308]                           }
[13:17:27.308]                         }
[13:17:27.308]                         frame <- frame + 1L
[13:17:27.308]                         envir <- sys.frame(frame)
[13:17:27.308]                       }
[13:17:27.308]                     }
[13:17:27.308]                     sendCondition <<- function(cond) NULL
[13:17:27.308]                   }
[13:17:27.308]                 })
[13:17:27.308]                 withCallingHandlers({
[13:17:27.308]                   {
[13:17:27.308]                     do.call(function(...) {
[13:17:27.308]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.308]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.308]                         ...future.globals.maxSize)) {
[13:17:27.308]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.308]                         on.exit(options(oopts), add = TRUE)
[13:17:27.308]                       }
[13:17:27.308]                       {
[13:17:27.308]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.308]                           FUN = function(jj) {
[13:17:27.308]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.308]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.308]                           })
[13:17:27.308]                       }
[13:17:27.308]                     }, args = future.call.arguments)
[13:17:27.308]                   }
[13:17:27.308]                 }, immediateCondition = function(cond) {
[13:17:27.308]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.308]                   sendCondition(cond)
[13:17:27.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.308]                   {
[13:17:27.308]                     inherits <- base::inherits
[13:17:27.308]                     invokeRestart <- base::invokeRestart
[13:17:27.308]                     is.null <- base::is.null
[13:17:27.308]                     muffled <- FALSE
[13:17:27.308]                     if (inherits(cond, "message")) {
[13:17:27.308]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.308]                       if (muffled) 
[13:17:27.308]                         invokeRestart("muffleMessage")
[13:17:27.308]                     }
[13:17:27.308]                     else if (inherits(cond, "warning")) {
[13:17:27.308]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.308]                       if (muffled) 
[13:17:27.308]                         invokeRestart("muffleWarning")
[13:17:27.308]                     }
[13:17:27.308]                     else if (inherits(cond, "condition")) {
[13:17:27.308]                       if (!is.null(pattern)) {
[13:17:27.308]                         computeRestarts <- base::computeRestarts
[13:17:27.308]                         grepl <- base::grepl
[13:17:27.308]                         restarts <- computeRestarts(cond)
[13:17:27.308]                         for (restart in restarts) {
[13:17:27.308]                           name <- restart$name
[13:17:27.308]                           if (is.null(name)) 
[13:17:27.308]                             next
[13:17:27.308]                           if (!grepl(pattern, name)) 
[13:17:27.308]                             next
[13:17:27.308]                           invokeRestart(restart)
[13:17:27.308]                           muffled <- TRUE
[13:17:27.308]                           break
[13:17:27.308]                         }
[13:17:27.308]                       }
[13:17:27.308]                     }
[13:17:27.308]                     invisible(muffled)
[13:17:27.308]                   }
[13:17:27.308]                   muffleCondition(cond)
[13:17:27.308]                 })
[13:17:27.308]             }))
[13:17:27.308]             future::FutureResult(value = ...future.value$value, 
[13:17:27.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.308]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.308]                     ...future.globalenv.names))
[13:17:27.308]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.308]         }, condition = base::local({
[13:17:27.308]             c <- base::c
[13:17:27.308]             inherits <- base::inherits
[13:17:27.308]             invokeRestart <- base::invokeRestart
[13:17:27.308]             length <- base::length
[13:17:27.308]             list <- base::list
[13:17:27.308]             seq.int <- base::seq.int
[13:17:27.308]             signalCondition <- base::signalCondition
[13:17:27.308]             sys.calls <- base::sys.calls
[13:17:27.308]             `[[` <- base::`[[`
[13:17:27.308]             `+` <- base::`+`
[13:17:27.308]             `<<-` <- base::`<<-`
[13:17:27.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.308]                   3L)]
[13:17:27.308]             }
[13:17:27.308]             function(cond) {
[13:17:27.308]                 is_error <- inherits(cond, "error")
[13:17:27.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.308]                   NULL)
[13:17:27.308]                 if (is_error) {
[13:17:27.308]                   sessionInformation <- function() {
[13:17:27.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.308]                       search = base::search(), system = base::Sys.info())
[13:17:27.308]                   }
[13:17:27.308]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.308]                     cond$call), session = sessionInformation(), 
[13:17:27.308]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.308]                   signalCondition(cond)
[13:17:27.308]                 }
[13:17:27.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.308]                 "immediateCondition"))) {
[13:17:27.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.308]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.308]                   if (TRUE && !signal) {
[13:17:27.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.308]                     {
[13:17:27.308]                       inherits <- base::inherits
[13:17:27.308]                       invokeRestart <- base::invokeRestart
[13:17:27.308]                       is.null <- base::is.null
[13:17:27.308]                       muffled <- FALSE
[13:17:27.308]                       if (inherits(cond, "message")) {
[13:17:27.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.308]                         if (muffled) 
[13:17:27.308]                           invokeRestart("muffleMessage")
[13:17:27.308]                       }
[13:17:27.308]                       else if (inherits(cond, "warning")) {
[13:17:27.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.308]                         if (muffled) 
[13:17:27.308]                           invokeRestart("muffleWarning")
[13:17:27.308]                       }
[13:17:27.308]                       else if (inherits(cond, "condition")) {
[13:17:27.308]                         if (!is.null(pattern)) {
[13:17:27.308]                           computeRestarts <- base::computeRestarts
[13:17:27.308]                           grepl <- base::grepl
[13:17:27.308]                           restarts <- computeRestarts(cond)
[13:17:27.308]                           for (restart in restarts) {
[13:17:27.308]                             name <- restart$name
[13:17:27.308]                             if (is.null(name)) 
[13:17:27.308]                               next
[13:17:27.308]                             if (!grepl(pattern, name)) 
[13:17:27.308]                               next
[13:17:27.308]                             invokeRestart(restart)
[13:17:27.308]                             muffled <- TRUE
[13:17:27.308]                             break
[13:17:27.308]                           }
[13:17:27.308]                         }
[13:17:27.308]                       }
[13:17:27.308]                       invisible(muffled)
[13:17:27.308]                     }
[13:17:27.308]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.308]                   }
[13:17:27.308]                 }
[13:17:27.308]                 else {
[13:17:27.308]                   if (TRUE) {
[13:17:27.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.308]                     {
[13:17:27.308]                       inherits <- base::inherits
[13:17:27.308]                       invokeRestart <- base::invokeRestart
[13:17:27.308]                       is.null <- base::is.null
[13:17:27.308]                       muffled <- FALSE
[13:17:27.308]                       if (inherits(cond, "message")) {
[13:17:27.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.308]                         if (muffled) 
[13:17:27.308]                           invokeRestart("muffleMessage")
[13:17:27.308]                       }
[13:17:27.308]                       else if (inherits(cond, "warning")) {
[13:17:27.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.308]                         if (muffled) 
[13:17:27.308]                           invokeRestart("muffleWarning")
[13:17:27.308]                       }
[13:17:27.308]                       else if (inherits(cond, "condition")) {
[13:17:27.308]                         if (!is.null(pattern)) {
[13:17:27.308]                           computeRestarts <- base::computeRestarts
[13:17:27.308]                           grepl <- base::grepl
[13:17:27.308]                           restarts <- computeRestarts(cond)
[13:17:27.308]                           for (restart in restarts) {
[13:17:27.308]                             name <- restart$name
[13:17:27.308]                             if (is.null(name)) 
[13:17:27.308]                               next
[13:17:27.308]                             if (!grepl(pattern, name)) 
[13:17:27.308]                               next
[13:17:27.308]                             invokeRestart(restart)
[13:17:27.308]                             muffled <- TRUE
[13:17:27.308]                             break
[13:17:27.308]                           }
[13:17:27.308]                         }
[13:17:27.308]                       }
[13:17:27.308]                       invisible(muffled)
[13:17:27.308]                     }
[13:17:27.308]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.308]                   }
[13:17:27.308]                 }
[13:17:27.308]             }
[13:17:27.308]         }))
[13:17:27.308]     }, error = function(ex) {
[13:17:27.308]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.308]                 ...future.rng), started = ...future.startTime, 
[13:17:27.308]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.308]             version = "1.8"), class = "FutureResult")
[13:17:27.308]     }, finally = {
[13:17:27.308]         if (!identical(...future.workdir, getwd())) 
[13:17:27.308]             setwd(...future.workdir)
[13:17:27.308]         {
[13:17:27.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.308]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.308]             }
[13:17:27.308]             base::options(...future.oldOptions)
[13:17:27.308]             if (.Platform$OS.type == "windows") {
[13:17:27.308]                 old_names <- names(...future.oldEnvVars)
[13:17:27.308]                 envs <- base::Sys.getenv()
[13:17:27.308]                 names <- names(envs)
[13:17:27.308]                 common <- intersect(names, old_names)
[13:17:27.308]                 added <- setdiff(names, old_names)
[13:17:27.308]                 removed <- setdiff(old_names, names)
[13:17:27.308]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.308]                   envs[common]]
[13:17:27.308]                 NAMES <- toupper(changed)
[13:17:27.308]                 args <- list()
[13:17:27.308]                 for (kk in seq_along(NAMES)) {
[13:17:27.308]                   name <- changed[[kk]]
[13:17:27.308]                   NAME <- NAMES[[kk]]
[13:17:27.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.308]                     next
[13:17:27.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.308]                 }
[13:17:27.308]                 NAMES <- toupper(added)
[13:17:27.308]                 for (kk in seq_along(NAMES)) {
[13:17:27.308]                   name <- added[[kk]]
[13:17:27.308]                   NAME <- NAMES[[kk]]
[13:17:27.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.308]                     next
[13:17:27.308]                   args[[name]] <- ""
[13:17:27.308]                 }
[13:17:27.308]                 NAMES <- toupper(removed)
[13:17:27.308]                 for (kk in seq_along(NAMES)) {
[13:17:27.308]                   name <- removed[[kk]]
[13:17:27.308]                   NAME <- NAMES[[kk]]
[13:17:27.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.308]                     next
[13:17:27.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.308]                 }
[13:17:27.308]                 if (length(args) > 0) 
[13:17:27.308]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.308]             }
[13:17:27.308]             else {
[13:17:27.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.308]             }
[13:17:27.308]             {
[13:17:27.308]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.308]                   0L) {
[13:17:27.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.308]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.308]                   base::options(opts)
[13:17:27.308]                 }
[13:17:27.308]                 {
[13:17:27.308]                   {
[13:17:27.308]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.308]                     NULL
[13:17:27.308]                   }
[13:17:27.308]                   options(future.plan = NULL)
[13:17:27.308]                   if (is.na(NA_character_)) 
[13:17:27.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.308]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.308]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.308]                     envir = parent.frame()) 
[13:17:27.308]                   {
[13:17:27.308]                     if (is.function(workers)) 
[13:17:27.308]                       workers <- workers()
[13:17:27.308]                     workers <- structure(as.integer(workers), 
[13:17:27.308]                       class = class(workers))
[13:17:27.308]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.308]                       workers >= 1)
[13:17:27.308]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.308]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.308]                     }
[13:17:27.308]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.308]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.308]                       envir = envir)
[13:17:27.308]                     if (!future$lazy) 
[13:17:27.308]                       future <- run(future)
[13:17:27.308]                     invisible(future)
[13:17:27.308]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.308]                 }
[13:17:27.308]             }
[13:17:27.308]         }
[13:17:27.308]     })
[13:17:27.308]     if (TRUE) {
[13:17:27.308]         base::sink(type = "output", split = FALSE)
[13:17:27.308]         if (TRUE) {
[13:17:27.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.308]         }
[13:17:27.308]         else {
[13:17:27.308]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.308]         }
[13:17:27.308]         base::close(...future.stdout)
[13:17:27.308]         ...future.stdout <- NULL
[13:17:27.308]     }
[13:17:27.308]     ...future.result$conditions <- ...future.conditions
[13:17:27.308]     ...future.result$finished <- base::Sys.time()
[13:17:27.308]     ...future.result
[13:17:27.308] }
[13:17:27.311] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:17:27.311] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.312] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.312] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:17:27.312] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:17:27.312] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[13:17:27.312] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[13:17:27.313] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.313] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.313] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:17:27.313] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:17:27.313] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:17:27.314] MultisessionFuture started
[13:17:27.314] - Launch lazy future ... done
[13:17:27.314] run() for ‘MultisessionFuture’ ... done
[13:17:27.314] Created future:
[13:17:27.314] MultisessionFuture:
[13:17:27.314] Label: ‘future_apply-2’
[13:17:27.314] Expression:
[13:17:27.314] {
[13:17:27.314]     do.call(function(...) {
[13:17:27.314]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.314]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.314]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.314]             on.exit(options(oopts), add = TRUE)
[13:17:27.314]         }
[13:17:27.314]         {
[13:17:27.314]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.314]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.314]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.314]             })
[13:17:27.314]         }
[13:17:27.314]     }, args = future.call.arguments)
[13:17:27.314] }
[13:17:27.314] Lazy evaluation: FALSE
[13:17:27.314] Asynchronous evaluation: TRUE
[13:17:27.314] Local evaluation: TRUE
[13:17:27.314] Environment: R_GlobalEnv
[13:17:27.314] Capture standard output: TRUE
[13:17:27.314] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.314] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:27.314] Packages: <none>
[13:17:27.314] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.314] Resolved: FALSE
[13:17:27.314] Value: <not collected>
[13:17:27.314] Conditions captured: <none>
[13:17:27.314] Early signaling: FALSE
[13:17:27.314] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.314] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.326] Chunk #2 of 2 ... DONE
[13:17:27.326] Launching 2 futures (chunks) ... DONE
[13:17:27.326] Resolving 2 futures (chunks) ...
[13:17:27.326] resolve() on list ...
[13:17:27.326]  recursive: 0
[13:17:27.326]  length: 2
[13:17:27.326] 
[13:17:27.327] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.327] - Validating connection of MultisessionFuture
[13:17:27.327] - received message: FutureResult
[13:17:27.327] - Received FutureResult
[13:17:27.327] - Erased future from FutureRegistry
[13:17:27.328] result() for ClusterFuture ...
[13:17:27.328] - result already collected: FutureResult
[13:17:27.328] result() for ClusterFuture ... done
[13:17:27.328] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.328] Future #1
[13:17:27.328] result() for ClusterFuture ...
[13:17:27.328] - result already collected: FutureResult
[13:17:27.328] result() for ClusterFuture ... done
[13:17:27.328] result() for ClusterFuture ...
[13:17:27.328] - result already collected: FutureResult
[13:17:27.328] result() for ClusterFuture ... done
[13:17:27.329] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.329] - nx: 2
[13:17:27.329] - relay: TRUE
[13:17:27.329] - stdout: TRUE
[13:17:27.329] - signal: TRUE
[13:17:27.329] - resignal: FALSE
[13:17:27.329] - force: TRUE
[13:17:27.329] - relayed: [n=2] FALSE, FALSE
[13:17:27.329] - queued futures: [n=2] FALSE, FALSE
[13:17:27.329]  - until=1
[13:17:27.330]  - relaying element #1
[13:17:27.330] result() for ClusterFuture ...
[13:17:27.330] - result already collected: FutureResult
[13:17:27.330] result() for ClusterFuture ... done
[13:17:27.330] result() for ClusterFuture ...
[13:17:27.330] - result already collected: FutureResult
[13:17:27.330] result() for ClusterFuture ... done
[13:17:27.330] result() for ClusterFuture ...
[13:17:27.330] - result already collected: FutureResult
[13:17:27.330] result() for ClusterFuture ... done
[13:17:27.330] result() for ClusterFuture ...
[13:17:27.331] - result already collected: FutureResult
[13:17:27.331] result() for ClusterFuture ... done
[13:17:27.331] - relayed: [n=2] TRUE, FALSE
[13:17:27.331] - queued futures: [n=2] TRUE, FALSE
[13:17:27.331] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.331]  length: 1 (resolved future 1)
[13:17:27.361] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.362] - Validating connection of MultisessionFuture
[13:17:27.362] - received message: FutureResult
[13:17:27.362] - Received FutureResult
[13:17:27.362] - Erased future from FutureRegistry
[13:17:27.362] result() for ClusterFuture ...
[13:17:27.362] - result already collected: FutureResult
[13:17:27.362] result() for ClusterFuture ... done
[13:17:27.362] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.363] Future #2
[13:17:27.363] result() for ClusterFuture ...
[13:17:27.363] - result already collected: FutureResult
[13:17:27.363] result() for ClusterFuture ... done
[13:17:27.363] result() for ClusterFuture ...
[13:17:27.363] - result already collected: FutureResult
[13:17:27.363] result() for ClusterFuture ... done
[13:17:27.363] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.363] - nx: 2
[13:17:27.363] - relay: TRUE
[13:17:27.364] - stdout: TRUE
[13:17:27.364] - signal: TRUE
[13:17:27.364] - resignal: FALSE
[13:17:27.364] - force: TRUE
[13:17:27.364] - relayed: [n=2] TRUE, FALSE
[13:17:27.364] - queued futures: [n=2] TRUE, FALSE
[13:17:27.364]  - until=2
[13:17:27.364]  - relaying element #2
[13:17:27.364] result() for ClusterFuture ...
[13:17:27.364] - result already collected: FutureResult
[13:17:27.364] result() for ClusterFuture ... done
[13:17:27.364] result() for ClusterFuture ...
[13:17:27.365] - result already collected: FutureResult
[13:17:27.365] result() for ClusterFuture ... done
[13:17:27.365] result() for ClusterFuture ...
[13:17:27.365] - result already collected: FutureResult
[13:17:27.365] result() for ClusterFuture ... done
[13:17:27.365] result() for ClusterFuture ...
[13:17:27.365] - result already collected: FutureResult
[13:17:27.365] result() for ClusterFuture ... done
[13:17:27.365] - relayed: [n=2] TRUE, TRUE
[13:17:27.365] - queued futures: [n=2] TRUE, TRUE
[13:17:27.366] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.366]  length: 0 (resolved future 2)
[13:17:27.366] Relaying remaining futures
[13:17:27.366] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.366] - nx: 2
[13:17:27.366] - relay: TRUE
[13:17:27.366] - stdout: TRUE
[13:17:27.366] - signal: TRUE
[13:17:27.366] - resignal: FALSE
[13:17:27.366] - force: TRUE
[13:17:27.366] - relayed: [n=2] TRUE, TRUE
[13:17:27.367] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.367] - relayed: [n=2] TRUE, TRUE
[13:17:27.367] - queued futures: [n=2] TRUE, TRUE
[13:17:27.367] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.367] resolve() on list ... DONE
[13:17:27.367] result() for ClusterFuture ...
[13:17:27.367] - result already collected: FutureResult
[13:17:27.367] result() for ClusterFuture ... done
[13:17:27.367] result() for ClusterFuture ...
[13:17:27.367] - result already collected: FutureResult
[13:17:27.367] result() for ClusterFuture ... done
[13:17:27.368] result() for ClusterFuture ...
[13:17:27.368] - result already collected: FutureResult
[13:17:27.368] result() for ClusterFuture ... done
[13:17:27.368] result() for ClusterFuture ...
[13:17:27.368] - result already collected: FutureResult
[13:17:27.368] result() for ClusterFuture ... done
[13:17:27.368]  - Number of value chunks collected: 2
[13:17:27.368] Resolving 2 futures (chunks) ... DONE
[13:17:27.368] Reducing values from 2 chunks ...
[13:17:27.368]  - Number of values collected after concatenation: 6
[13:17:27.369]  - Number of values expected: 6
[13:17:27.369] Reducing values from 2 chunks ... DONE
[13:17:27.369] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[13:17:27.369] getGlobalsAndPackagesXApply() ...
[13:17:27.369]  - future.globals: TRUE
[13:17:27.369] getGlobalsAndPackages() ...
[13:17:27.370] Searching for globals...
[13:17:27.371] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[13:17:27.371] Searching for globals ... DONE
[13:17:27.371] Resolving globals: FALSE
[13:17:27.371] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[13:17:27.372] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[13:17:27.372] - globals: [1] ‘FUN’
[13:17:27.372] 
[13:17:27.372] getGlobalsAndPackages() ... DONE
[13:17:27.372]  - globals found/used: [n=1] ‘FUN’
[13:17:27.372]  - needed namespaces: [n=0] 
[13:17:27.372] Finding globals ... DONE
[13:17:27.373]  - use_args: TRUE
[13:17:27.373]  - Getting '...' globals ...
[13:17:27.373] resolve() on list ...
[13:17:27.373]  recursive: 0
[13:17:27.373]  length: 1
[13:17:27.373]  elements: ‘...’
[13:17:27.373]  length: 0 (resolved future 1)
[13:17:27.373] resolve() on list ... DONE
[13:17:27.374]    - '...' content: [n=0] 
[13:17:27.374] List of 1
[13:17:27.374]  $ ...: list()
[13:17:27.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.374]  - attr(*, "where")=List of 1
[13:17:27.374]   ..$ ...:<environment: 0x5647b8db42e8> 
[13:17:27.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.374]  - attr(*, "resolved")= logi TRUE
[13:17:27.374]  - attr(*, "total_size")= num NA
[13:17:27.376]  - Getting '...' globals ... DONE
[13:17:27.376] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.377] List of 2
[13:17:27.377]  $ ...future.FUN:function (x)  
[13:17:27.377]  $ ...          : list()
[13:17:27.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.377]  - attr(*, "where")=List of 2
[13:17:27.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.377]   ..$ ...          :<environment: 0x5647b8db42e8> 
[13:17:27.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.377]  - attr(*, "resolved")= logi FALSE
[13:17:27.377]  - attr(*, "total_size")= num 1768
[13:17:27.379] Packages to be attached in all futures: [n=0] 
[13:17:27.379] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.383] future_lapply() ...
[13:17:27.387] Number of chunks: 2
[13:17:27.387] getGlobalsAndPackagesXApply() ...
[13:17:27.387]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.387]  - use_args: TRUE
[13:17:27.388] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.388] List of 2
[13:17:27.388]  $ ...          : list()
[13:17:27.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.388]  $ ...future.FUN:function (x)  
[13:17:27.388]  - attr(*, "where")=List of 2
[13:17:27.388]   ..$ ...          :<environment: 0x5647b8db42e8> 
[13:17:27.388]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:17:27.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.388]  - attr(*, "resolved")= logi FALSE
[13:17:27.388]  - attr(*, "total_size")= num NA
[13:17:27.390] Packages to be attached in all futures: [n=0] 
[13:17:27.391] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.391] Number of futures (= number of chunks): 2
[13:17:27.391] Launching 2 futures (chunks) ...
[13:17:27.391] Chunk #1 of 2 ...
[13:17:27.391]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:27.391]  - seeds: <none>
[13:17:27.391] getGlobalsAndPackages() ...
[13:17:27.391] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.392] Resolving globals: FALSE
[13:17:27.392] Tweak future expression to call with '...' arguments ...
[13:17:27.392] {
[13:17:27.392]     do.call(function(...) {
[13:17:27.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.392]             on.exit(options(oopts), add = TRUE)
[13:17:27.392]         }
[13:17:27.392]         {
[13:17:27.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.392]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.392]             })
[13:17:27.392]         }
[13:17:27.392]     }, args = future.call.arguments)
[13:17:27.392] }
[13:17:27.392] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.392] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.392] 
[13:17:27.393] getGlobalsAndPackages() ... DONE
[13:17:27.393] run() for ‘Future’ ...
[13:17:27.393] - state: ‘created’
[13:17:27.393] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.407] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.408]   - Field: ‘node’
[13:17:27.408]   - Field: ‘label’
[13:17:27.408]   - Field: ‘local’
[13:17:27.408]   - Field: ‘owner’
[13:17:27.408]   - Field: ‘envir’
[13:17:27.408]   - Field: ‘workers’
[13:17:27.408]   - Field: ‘packages’
[13:17:27.408]   - Field: ‘gc’
[13:17:27.408]   - Field: ‘conditions’
[13:17:27.409]   - Field: ‘persistent’
[13:17:27.409]   - Field: ‘expr’
[13:17:27.409]   - Field: ‘uuid’
[13:17:27.409]   - Field: ‘seed’
[13:17:27.409]   - Field: ‘version’
[13:17:27.409]   - Field: ‘result’
[13:17:27.409]   - Field: ‘asynchronous’
[13:17:27.409]   - Field: ‘calls’
[13:17:27.409]   - Field: ‘globals’
[13:17:27.409]   - Field: ‘stdout’
[13:17:27.410]   - Field: ‘earlySignal’
[13:17:27.410]   - Field: ‘lazy’
[13:17:27.410]   - Field: ‘state’
[13:17:27.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.410] - Launch lazy future ...
[13:17:27.410] Packages needed by the future expression (n = 0): <none>
[13:17:27.410] Packages needed by future strategies (n = 0): <none>
[13:17:27.411] {
[13:17:27.411]     {
[13:17:27.411]         {
[13:17:27.411]             ...future.startTime <- base::Sys.time()
[13:17:27.411]             {
[13:17:27.411]                 {
[13:17:27.411]                   {
[13:17:27.411]                     {
[13:17:27.411]                       base::local({
[13:17:27.411]                         has_future <- base::requireNamespace("future", 
[13:17:27.411]                           quietly = TRUE)
[13:17:27.411]                         if (has_future) {
[13:17:27.411]                           ns <- base::getNamespace("future")
[13:17:27.411]                           version <- ns[[".package"]][["version"]]
[13:17:27.411]                           if (is.null(version)) 
[13:17:27.411]                             version <- utils::packageVersion("future")
[13:17:27.411]                         }
[13:17:27.411]                         else {
[13:17:27.411]                           version <- NULL
[13:17:27.411]                         }
[13:17:27.411]                         if (!has_future || version < "1.8.0") {
[13:17:27.411]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.411]                             "", base::R.version$version.string), 
[13:17:27.411]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.411]                               "release", "version")], collapse = " "), 
[13:17:27.411]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.411]                             info)
[13:17:27.411]                           info <- base::paste(info, collapse = "; ")
[13:17:27.411]                           if (!has_future) {
[13:17:27.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.411]                               info)
[13:17:27.411]                           }
[13:17:27.411]                           else {
[13:17:27.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.411]                               info, version)
[13:17:27.411]                           }
[13:17:27.411]                           base::stop(msg)
[13:17:27.411]                         }
[13:17:27.411]                       })
[13:17:27.411]                     }
[13:17:27.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.411]                     base::options(mc.cores = 1L)
[13:17:27.411]                   }
[13:17:27.411]                   options(future.plan = NULL)
[13:17:27.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.411]                 }
[13:17:27.411]                 ...future.workdir <- getwd()
[13:17:27.411]             }
[13:17:27.411]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.411]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.411]         }
[13:17:27.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.411]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.411]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.411]             base::names(...future.oldOptions))
[13:17:27.411]     }
[13:17:27.411]     if (FALSE) {
[13:17:27.411]     }
[13:17:27.411]     else {
[13:17:27.411]         if (TRUE) {
[13:17:27.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.411]                 open = "w")
[13:17:27.411]         }
[13:17:27.411]         else {
[13:17:27.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.411]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.411]         }
[13:17:27.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.411]             base::sink(type = "output", split = FALSE)
[13:17:27.411]             base::close(...future.stdout)
[13:17:27.411]         }, add = TRUE)
[13:17:27.411]     }
[13:17:27.411]     ...future.frame <- base::sys.nframe()
[13:17:27.411]     ...future.conditions <- base::list()
[13:17:27.411]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.411]     if (FALSE) {
[13:17:27.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.411]     }
[13:17:27.411]     ...future.result <- base::tryCatch({
[13:17:27.411]         base::withCallingHandlers({
[13:17:27.411]             ...future.value <- base::withVisible(base::local({
[13:17:27.411]                 ...future.makeSendCondition <- local({
[13:17:27.411]                   sendCondition <- NULL
[13:17:27.411]                   function(frame = 1L) {
[13:17:27.411]                     if (is.function(sendCondition)) 
[13:17:27.411]                       return(sendCondition)
[13:17:27.411]                     ns <- getNamespace("parallel")
[13:17:27.411]                     if (exists("sendData", mode = "function", 
[13:17:27.411]                       envir = ns)) {
[13:17:27.411]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.411]                         envir = ns)
[13:17:27.411]                       envir <- sys.frame(frame)
[13:17:27.411]                       master <- NULL
[13:17:27.411]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.411]                         !identical(envir, emptyenv())) {
[13:17:27.411]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.411]                           inherits = FALSE)) {
[13:17:27.411]                           master <- get("master", mode = "list", 
[13:17:27.411]                             envir = envir, inherits = FALSE)
[13:17:27.411]                           if (inherits(master, c("SOCKnode", 
[13:17:27.411]                             "SOCK0node"))) {
[13:17:27.411]                             sendCondition <<- function(cond) {
[13:17:27.411]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.411]                                 success = TRUE)
[13:17:27.411]                               parallel_sendData(master, data)
[13:17:27.411]                             }
[13:17:27.411]                             return(sendCondition)
[13:17:27.411]                           }
[13:17:27.411]                         }
[13:17:27.411]                         frame <- frame + 1L
[13:17:27.411]                         envir <- sys.frame(frame)
[13:17:27.411]                       }
[13:17:27.411]                     }
[13:17:27.411]                     sendCondition <<- function(cond) NULL
[13:17:27.411]                   }
[13:17:27.411]                 })
[13:17:27.411]                 withCallingHandlers({
[13:17:27.411]                   {
[13:17:27.411]                     do.call(function(...) {
[13:17:27.411]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.411]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.411]                         ...future.globals.maxSize)) {
[13:17:27.411]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.411]                         on.exit(options(oopts), add = TRUE)
[13:17:27.411]                       }
[13:17:27.411]                       {
[13:17:27.411]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.411]                           FUN = function(jj) {
[13:17:27.411]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.411]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.411]                           })
[13:17:27.411]                       }
[13:17:27.411]                     }, args = future.call.arguments)
[13:17:27.411]                   }
[13:17:27.411]                 }, immediateCondition = function(cond) {
[13:17:27.411]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.411]                   sendCondition(cond)
[13:17:27.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.411]                   {
[13:17:27.411]                     inherits <- base::inherits
[13:17:27.411]                     invokeRestart <- base::invokeRestart
[13:17:27.411]                     is.null <- base::is.null
[13:17:27.411]                     muffled <- FALSE
[13:17:27.411]                     if (inherits(cond, "message")) {
[13:17:27.411]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.411]                       if (muffled) 
[13:17:27.411]                         invokeRestart("muffleMessage")
[13:17:27.411]                     }
[13:17:27.411]                     else if (inherits(cond, "warning")) {
[13:17:27.411]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.411]                       if (muffled) 
[13:17:27.411]                         invokeRestart("muffleWarning")
[13:17:27.411]                     }
[13:17:27.411]                     else if (inherits(cond, "condition")) {
[13:17:27.411]                       if (!is.null(pattern)) {
[13:17:27.411]                         computeRestarts <- base::computeRestarts
[13:17:27.411]                         grepl <- base::grepl
[13:17:27.411]                         restarts <- computeRestarts(cond)
[13:17:27.411]                         for (restart in restarts) {
[13:17:27.411]                           name <- restart$name
[13:17:27.411]                           if (is.null(name)) 
[13:17:27.411]                             next
[13:17:27.411]                           if (!grepl(pattern, name)) 
[13:17:27.411]                             next
[13:17:27.411]                           invokeRestart(restart)
[13:17:27.411]                           muffled <- TRUE
[13:17:27.411]                           break
[13:17:27.411]                         }
[13:17:27.411]                       }
[13:17:27.411]                     }
[13:17:27.411]                     invisible(muffled)
[13:17:27.411]                   }
[13:17:27.411]                   muffleCondition(cond)
[13:17:27.411]                 })
[13:17:27.411]             }))
[13:17:27.411]             future::FutureResult(value = ...future.value$value, 
[13:17:27.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.411]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.411]                     ...future.globalenv.names))
[13:17:27.411]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.411]         }, condition = base::local({
[13:17:27.411]             c <- base::c
[13:17:27.411]             inherits <- base::inherits
[13:17:27.411]             invokeRestart <- base::invokeRestart
[13:17:27.411]             length <- base::length
[13:17:27.411]             list <- base::list
[13:17:27.411]             seq.int <- base::seq.int
[13:17:27.411]             signalCondition <- base::signalCondition
[13:17:27.411]             sys.calls <- base::sys.calls
[13:17:27.411]             `[[` <- base::`[[`
[13:17:27.411]             `+` <- base::`+`
[13:17:27.411]             `<<-` <- base::`<<-`
[13:17:27.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.411]                   3L)]
[13:17:27.411]             }
[13:17:27.411]             function(cond) {
[13:17:27.411]                 is_error <- inherits(cond, "error")
[13:17:27.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.411]                   NULL)
[13:17:27.411]                 if (is_error) {
[13:17:27.411]                   sessionInformation <- function() {
[13:17:27.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.411]                       search = base::search(), system = base::Sys.info())
[13:17:27.411]                   }
[13:17:27.411]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.411]                     cond$call), session = sessionInformation(), 
[13:17:27.411]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.411]                   signalCondition(cond)
[13:17:27.411]                 }
[13:17:27.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.411]                 "immediateCondition"))) {
[13:17:27.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.411]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.411]                   if (TRUE && !signal) {
[13:17:27.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.411]                     {
[13:17:27.411]                       inherits <- base::inherits
[13:17:27.411]                       invokeRestart <- base::invokeRestart
[13:17:27.411]                       is.null <- base::is.null
[13:17:27.411]                       muffled <- FALSE
[13:17:27.411]                       if (inherits(cond, "message")) {
[13:17:27.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.411]                         if (muffled) 
[13:17:27.411]                           invokeRestart("muffleMessage")
[13:17:27.411]                       }
[13:17:27.411]                       else if (inherits(cond, "warning")) {
[13:17:27.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.411]                         if (muffled) 
[13:17:27.411]                           invokeRestart("muffleWarning")
[13:17:27.411]                       }
[13:17:27.411]                       else if (inherits(cond, "condition")) {
[13:17:27.411]                         if (!is.null(pattern)) {
[13:17:27.411]                           computeRestarts <- base::computeRestarts
[13:17:27.411]                           grepl <- base::grepl
[13:17:27.411]                           restarts <- computeRestarts(cond)
[13:17:27.411]                           for (restart in restarts) {
[13:17:27.411]                             name <- restart$name
[13:17:27.411]                             if (is.null(name)) 
[13:17:27.411]                               next
[13:17:27.411]                             if (!grepl(pattern, name)) 
[13:17:27.411]                               next
[13:17:27.411]                             invokeRestart(restart)
[13:17:27.411]                             muffled <- TRUE
[13:17:27.411]                             break
[13:17:27.411]                           }
[13:17:27.411]                         }
[13:17:27.411]                       }
[13:17:27.411]                       invisible(muffled)
[13:17:27.411]                     }
[13:17:27.411]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.411]                   }
[13:17:27.411]                 }
[13:17:27.411]                 else {
[13:17:27.411]                   if (TRUE) {
[13:17:27.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.411]                     {
[13:17:27.411]                       inherits <- base::inherits
[13:17:27.411]                       invokeRestart <- base::invokeRestart
[13:17:27.411]                       is.null <- base::is.null
[13:17:27.411]                       muffled <- FALSE
[13:17:27.411]                       if (inherits(cond, "message")) {
[13:17:27.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.411]                         if (muffled) 
[13:17:27.411]                           invokeRestart("muffleMessage")
[13:17:27.411]                       }
[13:17:27.411]                       else if (inherits(cond, "warning")) {
[13:17:27.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.411]                         if (muffled) 
[13:17:27.411]                           invokeRestart("muffleWarning")
[13:17:27.411]                       }
[13:17:27.411]                       else if (inherits(cond, "condition")) {
[13:17:27.411]                         if (!is.null(pattern)) {
[13:17:27.411]                           computeRestarts <- base::computeRestarts
[13:17:27.411]                           grepl <- base::grepl
[13:17:27.411]                           restarts <- computeRestarts(cond)
[13:17:27.411]                           for (restart in restarts) {
[13:17:27.411]                             name <- restart$name
[13:17:27.411]                             if (is.null(name)) 
[13:17:27.411]                               next
[13:17:27.411]                             if (!grepl(pattern, name)) 
[13:17:27.411]                               next
[13:17:27.411]                             invokeRestart(restart)
[13:17:27.411]                             muffled <- TRUE
[13:17:27.411]                             break
[13:17:27.411]                           }
[13:17:27.411]                         }
[13:17:27.411]                       }
[13:17:27.411]                       invisible(muffled)
[13:17:27.411]                     }
[13:17:27.411]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.411]                   }
[13:17:27.411]                 }
[13:17:27.411]             }
[13:17:27.411]         }))
[13:17:27.411]     }, error = function(ex) {
[13:17:27.411]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.411]                 ...future.rng), started = ...future.startTime, 
[13:17:27.411]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.411]             version = "1.8"), class = "FutureResult")
[13:17:27.411]     }, finally = {
[13:17:27.411]         if (!identical(...future.workdir, getwd())) 
[13:17:27.411]             setwd(...future.workdir)
[13:17:27.411]         {
[13:17:27.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.411]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.411]             }
[13:17:27.411]             base::options(...future.oldOptions)
[13:17:27.411]             if (.Platform$OS.type == "windows") {
[13:17:27.411]                 old_names <- names(...future.oldEnvVars)
[13:17:27.411]                 envs <- base::Sys.getenv()
[13:17:27.411]                 names <- names(envs)
[13:17:27.411]                 common <- intersect(names, old_names)
[13:17:27.411]                 added <- setdiff(names, old_names)
[13:17:27.411]                 removed <- setdiff(old_names, names)
[13:17:27.411]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.411]                   envs[common]]
[13:17:27.411]                 NAMES <- toupper(changed)
[13:17:27.411]                 args <- list()
[13:17:27.411]                 for (kk in seq_along(NAMES)) {
[13:17:27.411]                   name <- changed[[kk]]
[13:17:27.411]                   NAME <- NAMES[[kk]]
[13:17:27.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.411]                     next
[13:17:27.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.411]                 }
[13:17:27.411]                 NAMES <- toupper(added)
[13:17:27.411]                 for (kk in seq_along(NAMES)) {
[13:17:27.411]                   name <- added[[kk]]
[13:17:27.411]                   NAME <- NAMES[[kk]]
[13:17:27.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.411]                     next
[13:17:27.411]                   args[[name]] <- ""
[13:17:27.411]                 }
[13:17:27.411]                 NAMES <- toupper(removed)
[13:17:27.411]                 for (kk in seq_along(NAMES)) {
[13:17:27.411]                   name <- removed[[kk]]
[13:17:27.411]                   NAME <- NAMES[[kk]]
[13:17:27.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.411]                     next
[13:17:27.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.411]                 }
[13:17:27.411]                 if (length(args) > 0) 
[13:17:27.411]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.411]             }
[13:17:27.411]             else {
[13:17:27.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.411]             }
[13:17:27.411]             {
[13:17:27.411]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.411]                   0L) {
[13:17:27.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.411]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.411]                   base::options(opts)
[13:17:27.411]                 }
[13:17:27.411]                 {
[13:17:27.411]                   {
[13:17:27.411]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.411]                     NULL
[13:17:27.411]                   }
[13:17:27.411]                   options(future.plan = NULL)
[13:17:27.411]                   if (is.na(NA_character_)) 
[13:17:27.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.411]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.411]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.411]                     envir = parent.frame()) 
[13:17:27.411]                   {
[13:17:27.411]                     if (is.function(workers)) 
[13:17:27.411]                       workers <- workers()
[13:17:27.411]                     workers <- structure(as.integer(workers), 
[13:17:27.411]                       class = class(workers))
[13:17:27.411]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.411]                       workers >= 1)
[13:17:27.411]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.411]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.411]                     }
[13:17:27.411]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.411]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.411]                       envir = envir)
[13:17:27.411]                     if (!future$lazy) 
[13:17:27.411]                       future <- run(future)
[13:17:27.411]                     invisible(future)
[13:17:27.411]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.411]                 }
[13:17:27.411]             }
[13:17:27.411]         }
[13:17:27.411]     })
[13:17:27.411]     if (TRUE) {
[13:17:27.411]         base::sink(type = "output", split = FALSE)
[13:17:27.411]         if (TRUE) {
[13:17:27.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.411]         }
[13:17:27.411]         else {
[13:17:27.411]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.411]         }
[13:17:27.411]         base::close(...future.stdout)
[13:17:27.411]         ...future.stdout <- NULL
[13:17:27.411]     }
[13:17:27.411]     ...future.result$conditions <- ...future.conditions
[13:17:27.411]     ...future.result$finished <- base::Sys.time()
[13:17:27.411]     ...future.result
[13:17:27.411] }
[13:17:27.414] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[13:17:27.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.415] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[13:17:27.415] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[13:17:27.415] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[13:17:27.416] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[13:17:27.416] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:27.416] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.416] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[13:17:27.417] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[13:17:27.417] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[13:17:27.417] MultisessionFuture started
[13:17:27.418] - Launch lazy future ... done
[13:17:27.418] run() for ‘MultisessionFuture’ ... done
[13:17:27.418] Created future:
[13:17:27.418] MultisessionFuture:
[13:17:27.418] Label: ‘future_apply-1’
[13:17:27.418] Expression:
[13:17:27.418] {
[13:17:27.418]     do.call(function(...) {
[13:17:27.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.418]             on.exit(options(oopts), add = TRUE)
[13:17:27.418]         }
[13:17:27.418]         {
[13:17:27.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.418]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.418]             })
[13:17:27.418]         }
[13:17:27.418]     }, args = future.call.arguments)
[13:17:27.418] }
[13:17:27.418] Lazy evaluation: FALSE
[13:17:27.418] Asynchronous evaluation: TRUE
[13:17:27.418] Local evaluation: TRUE
[13:17:27.418] Environment: R_GlobalEnv
[13:17:27.418] Capture standard output: TRUE
[13:17:27.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.418] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:27.418] Packages: <none>
[13:17:27.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.418] Resolved: FALSE
[13:17:27.418] Value: <not collected>
[13:17:27.418] Conditions captured: <none>
[13:17:27.418] Early signaling: FALSE
[13:17:27.418] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.418] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.429] Chunk #1 of 2 ... DONE
[13:17:27.430] Chunk #2 of 2 ...
[13:17:27.430]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[13:17:27.430]  - seeds: <none>
[13:17:27.430] getGlobalsAndPackages() ...
[13:17:27.430] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.430] Resolving globals: FALSE
[13:17:27.430] Tweak future expression to call with '...' arguments ...
[13:17:27.430] {
[13:17:27.430]     do.call(function(...) {
[13:17:27.430]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.430]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.430]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.430]             on.exit(options(oopts), add = TRUE)
[13:17:27.430]         }
[13:17:27.430]         {
[13:17:27.430]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.430]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.430]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.430]             })
[13:17:27.430]         }
[13:17:27.430]     }, args = future.call.arguments)
[13:17:27.430] }
[13:17:27.431] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.431] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.431] 
[13:17:27.431] getGlobalsAndPackages() ... DONE
[13:17:27.432] run() for ‘Future’ ...
[13:17:27.432] - state: ‘created’
[13:17:27.432] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.446]   - Field: ‘node’
[13:17:27.447]   - Field: ‘label’
[13:17:27.447]   - Field: ‘local’
[13:17:27.447]   - Field: ‘owner’
[13:17:27.447]   - Field: ‘envir’
[13:17:27.447]   - Field: ‘workers’
[13:17:27.447]   - Field: ‘packages’
[13:17:27.447]   - Field: ‘gc’
[13:17:27.447]   - Field: ‘conditions’
[13:17:27.447]   - Field: ‘persistent’
[13:17:27.447]   - Field: ‘expr’
[13:17:27.448]   - Field: ‘uuid’
[13:17:27.448]   - Field: ‘seed’
[13:17:27.448]   - Field: ‘version’
[13:17:27.448]   - Field: ‘result’
[13:17:27.448]   - Field: ‘asynchronous’
[13:17:27.448]   - Field: ‘calls’
[13:17:27.448]   - Field: ‘globals’
[13:17:27.448]   - Field: ‘stdout’
[13:17:27.448]   - Field: ‘earlySignal’
[13:17:27.448]   - Field: ‘lazy’
[13:17:27.448]   - Field: ‘state’
[13:17:27.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.449] - Launch lazy future ...
[13:17:27.449] Packages needed by the future expression (n = 0): <none>
[13:17:27.449] Packages needed by future strategies (n = 0): <none>
[13:17:27.450] {
[13:17:27.450]     {
[13:17:27.450]         {
[13:17:27.450]             ...future.startTime <- base::Sys.time()
[13:17:27.450]             {
[13:17:27.450]                 {
[13:17:27.450]                   {
[13:17:27.450]                     {
[13:17:27.450]                       base::local({
[13:17:27.450]                         has_future <- base::requireNamespace("future", 
[13:17:27.450]                           quietly = TRUE)
[13:17:27.450]                         if (has_future) {
[13:17:27.450]                           ns <- base::getNamespace("future")
[13:17:27.450]                           version <- ns[[".package"]][["version"]]
[13:17:27.450]                           if (is.null(version)) 
[13:17:27.450]                             version <- utils::packageVersion("future")
[13:17:27.450]                         }
[13:17:27.450]                         else {
[13:17:27.450]                           version <- NULL
[13:17:27.450]                         }
[13:17:27.450]                         if (!has_future || version < "1.8.0") {
[13:17:27.450]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.450]                             "", base::R.version$version.string), 
[13:17:27.450]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.450]                               "release", "version")], collapse = " "), 
[13:17:27.450]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.450]                             info)
[13:17:27.450]                           info <- base::paste(info, collapse = "; ")
[13:17:27.450]                           if (!has_future) {
[13:17:27.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.450]                               info)
[13:17:27.450]                           }
[13:17:27.450]                           else {
[13:17:27.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.450]                               info, version)
[13:17:27.450]                           }
[13:17:27.450]                           base::stop(msg)
[13:17:27.450]                         }
[13:17:27.450]                       })
[13:17:27.450]                     }
[13:17:27.450]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.450]                     base::options(mc.cores = 1L)
[13:17:27.450]                   }
[13:17:27.450]                   options(future.plan = NULL)
[13:17:27.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.450]                 }
[13:17:27.450]                 ...future.workdir <- getwd()
[13:17:27.450]             }
[13:17:27.450]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.450]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.450]         }
[13:17:27.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.450]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.450]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.450]             base::names(...future.oldOptions))
[13:17:27.450]     }
[13:17:27.450]     if (FALSE) {
[13:17:27.450]     }
[13:17:27.450]     else {
[13:17:27.450]         if (TRUE) {
[13:17:27.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.450]                 open = "w")
[13:17:27.450]         }
[13:17:27.450]         else {
[13:17:27.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.450]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.450]         }
[13:17:27.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.450]             base::sink(type = "output", split = FALSE)
[13:17:27.450]             base::close(...future.stdout)
[13:17:27.450]         }, add = TRUE)
[13:17:27.450]     }
[13:17:27.450]     ...future.frame <- base::sys.nframe()
[13:17:27.450]     ...future.conditions <- base::list()
[13:17:27.450]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.450]     if (FALSE) {
[13:17:27.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.450]     }
[13:17:27.450]     ...future.result <- base::tryCatch({
[13:17:27.450]         base::withCallingHandlers({
[13:17:27.450]             ...future.value <- base::withVisible(base::local({
[13:17:27.450]                 ...future.makeSendCondition <- local({
[13:17:27.450]                   sendCondition <- NULL
[13:17:27.450]                   function(frame = 1L) {
[13:17:27.450]                     if (is.function(sendCondition)) 
[13:17:27.450]                       return(sendCondition)
[13:17:27.450]                     ns <- getNamespace("parallel")
[13:17:27.450]                     if (exists("sendData", mode = "function", 
[13:17:27.450]                       envir = ns)) {
[13:17:27.450]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.450]                         envir = ns)
[13:17:27.450]                       envir <- sys.frame(frame)
[13:17:27.450]                       master <- NULL
[13:17:27.450]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.450]                         !identical(envir, emptyenv())) {
[13:17:27.450]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.450]                           inherits = FALSE)) {
[13:17:27.450]                           master <- get("master", mode = "list", 
[13:17:27.450]                             envir = envir, inherits = FALSE)
[13:17:27.450]                           if (inherits(master, c("SOCKnode", 
[13:17:27.450]                             "SOCK0node"))) {
[13:17:27.450]                             sendCondition <<- function(cond) {
[13:17:27.450]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.450]                                 success = TRUE)
[13:17:27.450]                               parallel_sendData(master, data)
[13:17:27.450]                             }
[13:17:27.450]                             return(sendCondition)
[13:17:27.450]                           }
[13:17:27.450]                         }
[13:17:27.450]                         frame <- frame + 1L
[13:17:27.450]                         envir <- sys.frame(frame)
[13:17:27.450]                       }
[13:17:27.450]                     }
[13:17:27.450]                     sendCondition <<- function(cond) NULL
[13:17:27.450]                   }
[13:17:27.450]                 })
[13:17:27.450]                 withCallingHandlers({
[13:17:27.450]                   {
[13:17:27.450]                     do.call(function(...) {
[13:17:27.450]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.450]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.450]                         ...future.globals.maxSize)) {
[13:17:27.450]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.450]                         on.exit(options(oopts), add = TRUE)
[13:17:27.450]                       }
[13:17:27.450]                       {
[13:17:27.450]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.450]                           FUN = function(jj) {
[13:17:27.450]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.450]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.450]                           })
[13:17:27.450]                       }
[13:17:27.450]                     }, args = future.call.arguments)
[13:17:27.450]                   }
[13:17:27.450]                 }, immediateCondition = function(cond) {
[13:17:27.450]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.450]                   sendCondition(cond)
[13:17:27.450]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.450]                   {
[13:17:27.450]                     inherits <- base::inherits
[13:17:27.450]                     invokeRestart <- base::invokeRestart
[13:17:27.450]                     is.null <- base::is.null
[13:17:27.450]                     muffled <- FALSE
[13:17:27.450]                     if (inherits(cond, "message")) {
[13:17:27.450]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.450]                       if (muffled) 
[13:17:27.450]                         invokeRestart("muffleMessage")
[13:17:27.450]                     }
[13:17:27.450]                     else if (inherits(cond, "warning")) {
[13:17:27.450]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.450]                       if (muffled) 
[13:17:27.450]                         invokeRestart("muffleWarning")
[13:17:27.450]                     }
[13:17:27.450]                     else if (inherits(cond, "condition")) {
[13:17:27.450]                       if (!is.null(pattern)) {
[13:17:27.450]                         computeRestarts <- base::computeRestarts
[13:17:27.450]                         grepl <- base::grepl
[13:17:27.450]                         restarts <- computeRestarts(cond)
[13:17:27.450]                         for (restart in restarts) {
[13:17:27.450]                           name <- restart$name
[13:17:27.450]                           if (is.null(name)) 
[13:17:27.450]                             next
[13:17:27.450]                           if (!grepl(pattern, name)) 
[13:17:27.450]                             next
[13:17:27.450]                           invokeRestart(restart)
[13:17:27.450]                           muffled <- TRUE
[13:17:27.450]                           break
[13:17:27.450]                         }
[13:17:27.450]                       }
[13:17:27.450]                     }
[13:17:27.450]                     invisible(muffled)
[13:17:27.450]                   }
[13:17:27.450]                   muffleCondition(cond)
[13:17:27.450]                 })
[13:17:27.450]             }))
[13:17:27.450]             future::FutureResult(value = ...future.value$value, 
[13:17:27.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.450]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.450]                     ...future.globalenv.names))
[13:17:27.450]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.450]         }, condition = base::local({
[13:17:27.450]             c <- base::c
[13:17:27.450]             inherits <- base::inherits
[13:17:27.450]             invokeRestart <- base::invokeRestart
[13:17:27.450]             length <- base::length
[13:17:27.450]             list <- base::list
[13:17:27.450]             seq.int <- base::seq.int
[13:17:27.450]             signalCondition <- base::signalCondition
[13:17:27.450]             sys.calls <- base::sys.calls
[13:17:27.450]             `[[` <- base::`[[`
[13:17:27.450]             `+` <- base::`+`
[13:17:27.450]             `<<-` <- base::`<<-`
[13:17:27.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.450]                   3L)]
[13:17:27.450]             }
[13:17:27.450]             function(cond) {
[13:17:27.450]                 is_error <- inherits(cond, "error")
[13:17:27.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.450]                   NULL)
[13:17:27.450]                 if (is_error) {
[13:17:27.450]                   sessionInformation <- function() {
[13:17:27.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.450]                       search = base::search(), system = base::Sys.info())
[13:17:27.450]                   }
[13:17:27.450]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.450]                     cond$call), session = sessionInformation(), 
[13:17:27.450]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.450]                   signalCondition(cond)
[13:17:27.450]                 }
[13:17:27.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.450]                 "immediateCondition"))) {
[13:17:27.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.450]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.450]                   if (TRUE && !signal) {
[13:17:27.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.450]                     {
[13:17:27.450]                       inherits <- base::inherits
[13:17:27.450]                       invokeRestart <- base::invokeRestart
[13:17:27.450]                       is.null <- base::is.null
[13:17:27.450]                       muffled <- FALSE
[13:17:27.450]                       if (inherits(cond, "message")) {
[13:17:27.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.450]                         if (muffled) 
[13:17:27.450]                           invokeRestart("muffleMessage")
[13:17:27.450]                       }
[13:17:27.450]                       else if (inherits(cond, "warning")) {
[13:17:27.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.450]                         if (muffled) 
[13:17:27.450]                           invokeRestart("muffleWarning")
[13:17:27.450]                       }
[13:17:27.450]                       else if (inherits(cond, "condition")) {
[13:17:27.450]                         if (!is.null(pattern)) {
[13:17:27.450]                           computeRestarts <- base::computeRestarts
[13:17:27.450]                           grepl <- base::grepl
[13:17:27.450]                           restarts <- computeRestarts(cond)
[13:17:27.450]                           for (restart in restarts) {
[13:17:27.450]                             name <- restart$name
[13:17:27.450]                             if (is.null(name)) 
[13:17:27.450]                               next
[13:17:27.450]                             if (!grepl(pattern, name)) 
[13:17:27.450]                               next
[13:17:27.450]                             invokeRestart(restart)
[13:17:27.450]                             muffled <- TRUE
[13:17:27.450]                             break
[13:17:27.450]                           }
[13:17:27.450]                         }
[13:17:27.450]                       }
[13:17:27.450]                       invisible(muffled)
[13:17:27.450]                     }
[13:17:27.450]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.450]                   }
[13:17:27.450]                 }
[13:17:27.450]                 else {
[13:17:27.450]                   if (TRUE) {
[13:17:27.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.450]                     {
[13:17:27.450]                       inherits <- base::inherits
[13:17:27.450]                       invokeRestart <- base::invokeRestart
[13:17:27.450]                       is.null <- base::is.null
[13:17:27.450]                       muffled <- FALSE
[13:17:27.450]                       if (inherits(cond, "message")) {
[13:17:27.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.450]                         if (muffled) 
[13:17:27.450]                           invokeRestart("muffleMessage")
[13:17:27.450]                       }
[13:17:27.450]                       else if (inherits(cond, "warning")) {
[13:17:27.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.450]                         if (muffled) 
[13:17:27.450]                           invokeRestart("muffleWarning")
[13:17:27.450]                       }
[13:17:27.450]                       else if (inherits(cond, "condition")) {
[13:17:27.450]                         if (!is.null(pattern)) {
[13:17:27.450]                           computeRestarts <- base::computeRestarts
[13:17:27.450]                           grepl <- base::grepl
[13:17:27.450]                           restarts <- computeRestarts(cond)
[13:17:27.450]                           for (restart in restarts) {
[13:17:27.450]                             name <- restart$name
[13:17:27.450]                             if (is.null(name)) 
[13:17:27.450]                               next
[13:17:27.450]                             if (!grepl(pattern, name)) 
[13:17:27.450]                               next
[13:17:27.450]                             invokeRestart(restart)
[13:17:27.450]                             muffled <- TRUE
[13:17:27.450]                             break
[13:17:27.450]                           }
[13:17:27.450]                         }
[13:17:27.450]                       }
[13:17:27.450]                       invisible(muffled)
[13:17:27.450]                     }
[13:17:27.450]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.450]                   }
[13:17:27.450]                 }
[13:17:27.450]             }
[13:17:27.450]         }))
[13:17:27.450]     }, error = function(ex) {
[13:17:27.450]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.450]                 ...future.rng), started = ...future.startTime, 
[13:17:27.450]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.450]             version = "1.8"), class = "FutureResult")
[13:17:27.450]     }, finally = {
[13:17:27.450]         if (!identical(...future.workdir, getwd())) 
[13:17:27.450]             setwd(...future.workdir)
[13:17:27.450]         {
[13:17:27.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.450]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.450]             }
[13:17:27.450]             base::options(...future.oldOptions)
[13:17:27.450]             if (.Platform$OS.type == "windows") {
[13:17:27.450]                 old_names <- names(...future.oldEnvVars)
[13:17:27.450]                 envs <- base::Sys.getenv()
[13:17:27.450]                 names <- names(envs)
[13:17:27.450]                 common <- intersect(names, old_names)
[13:17:27.450]                 added <- setdiff(names, old_names)
[13:17:27.450]                 removed <- setdiff(old_names, names)
[13:17:27.450]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.450]                   envs[common]]
[13:17:27.450]                 NAMES <- toupper(changed)
[13:17:27.450]                 args <- list()
[13:17:27.450]                 for (kk in seq_along(NAMES)) {
[13:17:27.450]                   name <- changed[[kk]]
[13:17:27.450]                   NAME <- NAMES[[kk]]
[13:17:27.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.450]                     next
[13:17:27.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.450]                 }
[13:17:27.450]                 NAMES <- toupper(added)
[13:17:27.450]                 for (kk in seq_along(NAMES)) {
[13:17:27.450]                   name <- added[[kk]]
[13:17:27.450]                   NAME <- NAMES[[kk]]
[13:17:27.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.450]                     next
[13:17:27.450]                   args[[name]] <- ""
[13:17:27.450]                 }
[13:17:27.450]                 NAMES <- toupper(removed)
[13:17:27.450]                 for (kk in seq_along(NAMES)) {
[13:17:27.450]                   name <- removed[[kk]]
[13:17:27.450]                   NAME <- NAMES[[kk]]
[13:17:27.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.450]                     next
[13:17:27.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.450]                 }
[13:17:27.450]                 if (length(args) > 0) 
[13:17:27.450]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.450]             }
[13:17:27.450]             else {
[13:17:27.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.450]             }
[13:17:27.450]             {
[13:17:27.450]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.450]                   0L) {
[13:17:27.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.450]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.450]                   base::options(opts)
[13:17:27.450]                 }
[13:17:27.450]                 {
[13:17:27.450]                   {
[13:17:27.450]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.450]                     NULL
[13:17:27.450]                   }
[13:17:27.450]                   options(future.plan = NULL)
[13:17:27.450]                   if (is.na(NA_character_)) 
[13:17:27.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.450]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.450]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.450]                     envir = parent.frame()) 
[13:17:27.450]                   {
[13:17:27.450]                     if (is.function(workers)) 
[13:17:27.450]                       workers <- workers()
[13:17:27.450]                     workers <- structure(as.integer(workers), 
[13:17:27.450]                       class = class(workers))
[13:17:27.450]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.450]                       workers >= 1)
[13:17:27.450]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.450]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.450]                     }
[13:17:27.450]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.450]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.450]                       envir = envir)
[13:17:27.450]                     if (!future$lazy) 
[13:17:27.450]                       future <- run(future)
[13:17:27.450]                     invisible(future)
[13:17:27.450]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.450]                 }
[13:17:27.450]             }
[13:17:27.450]         }
[13:17:27.450]     })
[13:17:27.450]     if (TRUE) {
[13:17:27.450]         base::sink(type = "output", split = FALSE)
[13:17:27.450]         if (TRUE) {
[13:17:27.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.450]         }
[13:17:27.450]         else {
[13:17:27.450]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.450]         }
[13:17:27.450]         base::close(...future.stdout)
[13:17:27.450]         ...future.stdout <- NULL
[13:17:27.450]     }
[13:17:27.450]     ...future.result$conditions <- ...future.conditions
[13:17:27.450]     ...future.result$finished <- base::Sys.time()
[13:17:27.450]     ...future.result
[13:17:27.450] }
[13:17:27.453] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[13:17:27.453] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.453] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.454] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[13:17:27.454] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[13:17:27.454] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[13:17:27.454] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[13:17:27.454] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.455] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.455] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[13:17:27.455] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[13:17:27.455] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[13:17:27.456] MultisessionFuture started
[13:17:27.456] - Launch lazy future ... done
[13:17:27.456] run() for ‘MultisessionFuture’ ... done
[13:17:27.456] Created future:
[13:17:27.456] MultisessionFuture:
[13:17:27.456] Label: ‘future_apply-2’
[13:17:27.456] Expression:
[13:17:27.456] {
[13:17:27.456]     do.call(function(...) {
[13:17:27.456]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.456]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.456]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.456]             on.exit(options(oopts), add = TRUE)
[13:17:27.456]         }
[13:17:27.456]         {
[13:17:27.456]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.456]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.456]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.456]             })
[13:17:27.456]         }
[13:17:27.456]     }, args = future.call.arguments)
[13:17:27.456] }
[13:17:27.456] Lazy evaluation: FALSE
[13:17:27.456] Asynchronous evaluation: TRUE
[13:17:27.456] Local evaluation: TRUE
[13:17:27.456] Environment: R_GlobalEnv
[13:17:27.456] Capture standard output: TRUE
[13:17:27.456] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.456] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[13:17:27.456] Packages: <none>
[13:17:27.456] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.456] Resolved: FALSE
[13:17:27.456] Value: <not collected>
[13:17:27.456] Conditions captured: <none>
[13:17:27.456] Early signaling: FALSE
[13:17:27.456] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.456] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.468] Chunk #2 of 2 ... DONE
[13:17:27.468] Launching 2 futures (chunks) ... DONE
[13:17:27.468] Resolving 2 futures (chunks) ...
[13:17:27.468] resolve() on list ...
[13:17:27.468]  recursive: 0
[13:17:27.469]  length: 2
[13:17:27.469] 
[13:17:27.470] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.470] - Validating connection of MultisessionFuture
[13:17:27.470] - received message: FutureResult
[13:17:27.470] - Received FutureResult
[13:17:27.471] - Erased future from FutureRegistry
[13:17:27.471] result() for ClusterFuture ...
[13:17:27.471] - result already collected: FutureResult
[13:17:27.471] result() for ClusterFuture ... done
[13:17:27.471] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.471] Future #1
[13:17:27.471] result() for ClusterFuture ...
[13:17:27.471] - result already collected: FutureResult
[13:17:27.471] result() for ClusterFuture ... done
[13:17:27.471] result() for ClusterFuture ...
[13:17:27.472] - result already collected: FutureResult
[13:17:27.472] result() for ClusterFuture ... done
[13:17:27.472] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.472] - nx: 2
[13:17:27.472] - relay: TRUE
[13:17:27.472] - stdout: TRUE
[13:17:27.472] - signal: TRUE
[13:17:27.472] - resignal: FALSE
[13:17:27.472] - force: TRUE
[13:17:27.472] - relayed: [n=2] FALSE, FALSE
[13:17:27.472] - queued futures: [n=2] FALSE, FALSE
[13:17:27.473]  - until=1
[13:17:27.473]  - relaying element #1
[13:17:27.473] result() for ClusterFuture ...
[13:17:27.473] - result already collected: FutureResult
[13:17:27.473] result() for ClusterFuture ... done
[13:17:27.473] result() for ClusterFuture ...
[13:17:27.473] - result already collected: FutureResult
[13:17:27.473] result() for ClusterFuture ... done
[13:17:27.473] result() for ClusterFuture ...
[13:17:27.473] - result already collected: FutureResult
[13:17:27.474] result() for ClusterFuture ... done
[13:17:27.474] result() for ClusterFuture ...
[13:17:27.474] - result already collected: FutureResult
[13:17:27.474] result() for ClusterFuture ... done
[13:17:27.474] - relayed: [n=2] TRUE, FALSE
[13:17:27.474] - queued futures: [n=2] TRUE, FALSE
[13:17:27.474] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.474]  length: 1 (resolved future 1)
[13:17:27.501] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.502] - Validating connection of MultisessionFuture
[13:17:27.502] - received message: FutureResult
[13:17:27.502] - Received FutureResult
[13:17:27.502] - Erased future from FutureRegistry
[13:17:27.502] result() for ClusterFuture ...
[13:17:27.503] - result already collected: FutureResult
[13:17:27.503] result() for ClusterFuture ... done
[13:17:27.503] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.503] Future #2
[13:17:27.503] result() for ClusterFuture ...
[13:17:27.503] - result already collected: FutureResult
[13:17:27.503] result() for ClusterFuture ... done
[13:17:27.503] result() for ClusterFuture ...
[13:17:27.504] - result already collected: FutureResult
[13:17:27.504] result() for ClusterFuture ... done
[13:17:27.504] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.504] - nx: 2
[13:17:27.504] - relay: TRUE
[13:17:27.504] - stdout: TRUE
[13:17:27.504] - signal: TRUE
[13:17:27.504] - resignal: FALSE
[13:17:27.504] - force: TRUE
[13:17:27.504] - relayed: [n=2] TRUE, FALSE
[13:17:27.505] - queued futures: [n=2] TRUE, FALSE
[13:17:27.505]  - until=2
[13:17:27.505]  - relaying element #2
[13:17:27.505] result() for ClusterFuture ...
[13:17:27.507] - result already collected: FutureResult
[13:17:27.507] result() for ClusterFuture ... done
[13:17:27.507] result() for ClusterFuture ...
[13:17:27.508] - result already collected: FutureResult
[13:17:27.508] result() for ClusterFuture ... done
[13:17:27.508] result() for ClusterFuture ...
[13:17:27.508] - result already collected: FutureResult
[13:17:27.508] result() for ClusterFuture ... done
[13:17:27.508] result() for ClusterFuture ...
[13:17:27.508] - result already collected: FutureResult
[13:17:27.508] result() for ClusterFuture ... done
[13:17:27.508] - relayed: [n=2] TRUE, TRUE
[13:17:27.508] - queued futures: [n=2] TRUE, TRUE
[13:17:27.508] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.509]  length: 0 (resolved future 2)
[13:17:27.509] Relaying remaining futures
[13:17:27.509] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.509] - nx: 2
[13:17:27.509] - relay: TRUE
[13:17:27.509] - stdout: TRUE
[13:17:27.509] - signal: TRUE
[13:17:27.509] - resignal: FALSE
[13:17:27.509] - force: TRUE
[13:17:27.509] - relayed: [n=2] TRUE, TRUE
[13:17:27.509] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.510] - relayed: [n=2] TRUE, TRUE
[13:17:27.510] - queued futures: [n=2] TRUE, TRUE
[13:17:27.510] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.510] resolve() on list ... DONE
[13:17:27.510] result() for ClusterFuture ...
[13:17:27.510] - result already collected: FutureResult
[13:17:27.510] result() for ClusterFuture ... done
[13:17:27.510] result() for ClusterFuture ...
[13:17:27.510] - result already collected: FutureResult
[13:17:27.510] result() for ClusterFuture ... done
[13:17:27.510] result() for ClusterFuture ...
[13:17:27.511] - result already collected: FutureResult
[13:17:27.511] result() for ClusterFuture ... done
[13:17:27.511] result() for ClusterFuture ...
[13:17:27.511] - result already collected: FutureResult
[13:17:27.511] result() for ClusterFuture ... done
[13:17:27.511]  - Number of value chunks collected: 2
[13:17:27.511] Resolving 2 futures (chunks) ... DONE
[13:17:27.511] Reducing values from 2 chunks ...
[13:17:27.511]  - Number of values collected after concatenation: 6
[13:17:27.511]  - Number of values expected: 6
[13:17:27.511] Reducing values from 2 chunks ... DONE
[13:17:27.512] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[13:17:27.512] getGlobalsAndPackagesXApply() ...
[13:17:27.512]  - future.globals: TRUE
[13:17:27.512] getGlobalsAndPackages() ...
[13:17:27.512] Searching for globals...
[13:17:27.513] - globals found: [1] ‘FUN’
[13:17:27.513] Searching for globals ... DONE
[13:17:27.514] Resolving globals: FALSE
[13:17:27.514] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:27.514] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:27.514] - globals: [1] ‘FUN’
[13:17:27.514] 
[13:17:27.515] getGlobalsAndPackages() ... DONE
[13:17:27.515]  - globals found/used: [n=1] ‘FUN’
[13:17:27.515]  - needed namespaces: [n=0] 
[13:17:27.515] Finding globals ... DONE
[13:17:27.515]  - use_args: TRUE
[13:17:27.515]  - Getting '...' globals ...
[13:17:27.515] resolve() on list ...
[13:17:27.515]  recursive: 0
[13:17:27.516]  length: 1
[13:17:27.516]  elements: ‘...’
[13:17:27.516]  length: 0 (resolved future 1)
[13:17:27.516] resolve() on list ... DONE
[13:17:27.516]    - '...' content: [n=0] 
[13:17:27.516] List of 1
[13:17:27.516]  $ ...: list()
[13:17:27.516]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.516]  - attr(*, "where")=List of 1
[13:17:27.516]   ..$ ...:<environment: 0x5647bb49b060> 
[13:17:27.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.516]  - attr(*, "resolved")= logi TRUE
[13:17:27.516]  - attr(*, "total_size")= num NA
[13:17:27.519]  - Getting '...' globals ... DONE
[13:17:27.519] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.519] List of 2
[13:17:27.519]  $ ...future.FUN:function (x)  
[13:17:27.519]  $ ...          : list()
[13:17:27.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.519]  - attr(*, "where")=List of 2
[13:17:27.519]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.519]   ..$ ...          :<environment: 0x5647bb49b060> 
[13:17:27.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.519]  - attr(*, "resolved")= logi FALSE
[13:17:27.519]  - attr(*, "total_size")= num 848
[13:17:27.521] Packages to be attached in all futures: [n=0] 
[13:17:27.522] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.525] future_lapply() ...
[13:17:27.529] Number of chunks: 2
[13:17:27.529] getGlobalsAndPackagesXApply() ...
[13:17:27.529]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.529]  - use_args: TRUE
[13:17:27.529] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.529] List of 2
[13:17:27.529]  $ ...          : list()
[13:17:27.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.529]  $ ...future.FUN:function (x)  
[13:17:27.529]  - attr(*, "where")=List of 2
[13:17:27.529]   ..$ ...          :<environment: 0x5647bb49b060> 
[13:17:27.529]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:27.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.529]  - attr(*, "resolved")= logi FALSE
[13:17:27.529]  - attr(*, "total_size")= num NA
[13:17:27.533] Packages to be attached in all futures: [n=0] 
[13:17:27.533] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.533] Number of futures (= number of chunks): 2
[13:17:27.533] Launching 2 futures (chunks) ...
[13:17:27.533] Chunk #1 of 2 ...
[13:17:27.534]  - seeds: <none>
[13:17:27.534] getGlobalsAndPackages() ...
[13:17:27.534] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.534] Resolving globals: FALSE
[13:17:27.534] Tweak future expression to call with '...' arguments ...
[13:17:27.534] {
[13:17:27.534]     do.call(function(...) {
[13:17:27.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.534]             on.exit(options(oopts), add = TRUE)
[13:17:27.534]         }
[13:17:27.534]         {
[13:17:27.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.534]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.534]             })
[13:17:27.534]         }
[13:17:27.534]     }, args = future.call.arguments)
[13:17:27.534] }
[13:17:27.534] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.535] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.535] 
[13:17:27.535] getGlobalsAndPackages() ... DONE
[13:17:27.535] run() for ‘Future’ ...
[13:17:27.535] - state: ‘created’
[13:17:27.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.551]   - Field: ‘node’
[13:17:27.551]   - Field: ‘label’
[13:17:27.551]   - Field: ‘local’
[13:17:27.551]   - Field: ‘owner’
[13:17:27.551]   - Field: ‘envir’
[13:17:27.551]   - Field: ‘workers’
[13:17:27.551]   - Field: ‘packages’
[13:17:27.552]   - Field: ‘gc’
[13:17:27.552]   - Field: ‘conditions’
[13:17:27.552]   - Field: ‘persistent’
[13:17:27.552]   - Field: ‘expr’
[13:17:27.552]   - Field: ‘uuid’
[13:17:27.552]   - Field: ‘seed’
[13:17:27.552]   - Field: ‘version’
[13:17:27.552]   - Field: ‘result’
[13:17:27.552]   - Field: ‘asynchronous’
[13:17:27.552]   - Field: ‘calls’
[13:17:27.552]   - Field: ‘globals’
[13:17:27.553]   - Field: ‘stdout’
[13:17:27.553]   - Field: ‘earlySignal’
[13:17:27.553]   - Field: ‘lazy’
[13:17:27.553]   - Field: ‘state’
[13:17:27.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.553] - Launch lazy future ...
[13:17:27.553] Packages needed by the future expression (n = 0): <none>
[13:17:27.553] Packages needed by future strategies (n = 0): <none>
[13:17:27.554] {
[13:17:27.554]     {
[13:17:27.554]         {
[13:17:27.554]             ...future.startTime <- base::Sys.time()
[13:17:27.554]             {
[13:17:27.554]                 {
[13:17:27.554]                   {
[13:17:27.554]                     {
[13:17:27.554]                       base::local({
[13:17:27.554]                         has_future <- base::requireNamespace("future", 
[13:17:27.554]                           quietly = TRUE)
[13:17:27.554]                         if (has_future) {
[13:17:27.554]                           ns <- base::getNamespace("future")
[13:17:27.554]                           version <- ns[[".package"]][["version"]]
[13:17:27.554]                           if (is.null(version)) 
[13:17:27.554]                             version <- utils::packageVersion("future")
[13:17:27.554]                         }
[13:17:27.554]                         else {
[13:17:27.554]                           version <- NULL
[13:17:27.554]                         }
[13:17:27.554]                         if (!has_future || version < "1.8.0") {
[13:17:27.554]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.554]                             "", base::R.version$version.string), 
[13:17:27.554]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.554]                               "release", "version")], collapse = " "), 
[13:17:27.554]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.554]                             info)
[13:17:27.554]                           info <- base::paste(info, collapse = "; ")
[13:17:27.554]                           if (!has_future) {
[13:17:27.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.554]                               info)
[13:17:27.554]                           }
[13:17:27.554]                           else {
[13:17:27.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.554]                               info, version)
[13:17:27.554]                           }
[13:17:27.554]                           base::stop(msg)
[13:17:27.554]                         }
[13:17:27.554]                       })
[13:17:27.554]                     }
[13:17:27.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.554]                     base::options(mc.cores = 1L)
[13:17:27.554]                   }
[13:17:27.554]                   options(future.plan = NULL)
[13:17:27.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.554]                 }
[13:17:27.554]                 ...future.workdir <- getwd()
[13:17:27.554]             }
[13:17:27.554]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.554]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.554]         }
[13:17:27.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.554]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.554]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.554]             base::names(...future.oldOptions))
[13:17:27.554]     }
[13:17:27.554]     if (FALSE) {
[13:17:27.554]     }
[13:17:27.554]     else {
[13:17:27.554]         if (TRUE) {
[13:17:27.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.554]                 open = "w")
[13:17:27.554]         }
[13:17:27.554]         else {
[13:17:27.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.554]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.554]         }
[13:17:27.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.554]             base::sink(type = "output", split = FALSE)
[13:17:27.554]             base::close(...future.stdout)
[13:17:27.554]         }, add = TRUE)
[13:17:27.554]     }
[13:17:27.554]     ...future.frame <- base::sys.nframe()
[13:17:27.554]     ...future.conditions <- base::list()
[13:17:27.554]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.554]     if (FALSE) {
[13:17:27.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.554]     }
[13:17:27.554]     ...future.result <- base::tryCatch({
[13:17:27.554]         base::withCallingHandlers({
[13:17:27.554]             ...future.value <- base::withVisible(base::local({
[13:17:27.554]                 ...future.makeSendCondition <- local({
[13:17:27.554]                   sendCondition <- NULL
[13:17:27.554]                   function(frame = 1L) {
[13:17:27.554]                     if (is.function(sendCondition)) 
[13:17:27.554]                       return(sendCondition)
[13:17:27.554]                     ns <- getNamespace("parallel")
[13:17:27.554]                     if (exists("sendData", mode = "function", 
[13:17:27.554]                       envir = ns)) {
[13:17:27.554]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.554]                         envir = ns)
[13:17:27.554]                       envir <- sys.frame(frame)
[13:17:27.554]                       master <- NULL
[13:17:27.554]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.554]                         !identical(envir, emptyenv())) {
[13:17:27.554]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.554]                           inherits = FALSE)) {
[13:17:27.554]                           master <- get("master", mode = "list", 
[13:17:27.554]                             envir = envir, inherits = FALSE)
[13:17:27.554]                           if (inherits(master, c("SOCKnode", 
[13:17:27.554]                             "SOCK0node"))) {
[13:17:27.554]                             sendCondition <<- function(cond) {
[13:17:27.554]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.554]                                 success = TRUE)
[13:17:27.554]                               parallel_sendData(master, data)
[13:17:27.554]                             }
[13:17:27.554]                             return(sendCondition)
[13:17:27.554]                           }
[13:17:27.554]                         }
[13:17:27.554]                         frame <- frame + 1L
[13:17:27.554]                         envir <- sys.frame(frame)
[13:17:27.554]                       }
[13:17:27.554]                     }
[13:17:27.554]                     sendCondition <<- function(cond) NULL
[13:17:27.554]                   }
[13:17:27.554]                 })
[13:17:27.554]                 withCallingHandlers({
[13:17:27.554]                   {
[13:17:27.554]                     do.call(function(...) {
[13:17:27.554]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.554]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.554]                         ...future.globals.maxSize)) {
[13:17:27.554]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.554]                         on.exit(options(oopts), add = TRUE)
[13:17:27.554]                       }
[13:17:27.554]                       {
[13:17:27.554]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.554]                           FUN = function(jj) {
[13:17:27.554]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.554]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.554]                           })
[13:17:27.554]                       }
[13:17:27.554]                     }, args = future.call.arguments)
[13:17:27.554]                   }
[13:17:27.554]                 }, immediateCondition = function(cond) {
[13:17:27.554]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.554]                   sendCondition(cond)
[13:17:27.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.554]                   {
[13:17:27.554]                     inherits <- base::inherits
[13:17:27.554]                     invokeRestart <- base::invokeRestart
[13:17:27.554]                     is.null <- base::is.null
[13:17:27.554]                     muffled <- FALSE
[13:17:27.554]                     if (inherits(cond, "message")) {
[13:17:27.554]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.554]                       if (muffled) 
[13:17:27.554]                         invokeRestart("muffleMessage")
[13:17:27.554]                     }
[13:17:27.554]                     else if (inherits(cond, "warning")) {
[13:17:27.554]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.554]                       if (muffled) 
[13:17:27.554]                         invokeRestart("muffleWarning")
[13:17:27.554]                     }
[13:17:27.554]                     else if (inherits(cond, "condition")) {
[13:17:27.554]                       if (!is.null(pattern)) {
[13:17:27.554]                         computeRestarts <- base::computeRestarts
[13:17:27.554]                         grepl <- base::grepl
[13:17:27.554]                         restarts <- computeRestarts(cond)
[13:17:27.554]                         for (restart in restarts) {
[13:17:27.554]                           name <- restart$name
[13:17:27.554]                           if (is.null(name)) 
[13:17:27.554]                             next
[13:17:27.554]                           if (!grepl(pattern, name)) 
[13:17:27.554]                             next
[13:17:27.554]                           invokeRestart(restart)
[13:17:27.554]                           muffled <- TRUE
[13:17:27.554]                           break
[13:17:27.554]                         }
[13:17:27.554]                       }
[13:17:27.554]                     }
[13:17:27.554]                     invisible(muffled)
[13:17:27.554]                   }
[13:17:27.554]                   muffleCondition(cond)
[13:17:27.554]                 })
[13:17:27.554]             }))
[13:17:27.554]             future::FutureResult(value = ...future.value$value, 
[13:17:27.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.554]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.554]                     ...future.globalenv.names))
[13:17:27.554]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.554]         }, condition = base::local({
[13:17:27.554]             c <- base::c
[13:17:27.554]             inherits <- base::inherits
[13:17:27.554]             invokeRestart <- base::invokeRestart
[13:17:27.554]             length <- base::length
[13:17:27.554]             list <- base::list
[13:17:27.554]             seq.int <- base::seq.int
[13:17:27.554]             signalCondition <- base::signalCondition
[13:17:27.554]             sys.calls <- base::sys.calls
[13:17:27.554]             `[[` <- base::`[[`
[13:17:27.554]             `+` <- base::`+`
[13:17:27.554]             `<<-` <- base::`<<-`
[13:17:27.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.554]                   3L)]
[13:17:27.554]             }
[13:17:27.554]             function(cond) {
[13:17:27.554]                 is_error <- inherits(cond, "error")
[13:17:27.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.554]                   NULL)
[13:17:27.554]                 if (is_error) {
[13:17:27.554]                   sessionInformation <- function() {
[13:17:27.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.554]                       search = base::search(), system = base::Sys.info())
[13:17:27.554]                   }
[13:17:27.554]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.554]                     cond$call), session = sessionInformation(), 
[13:17:27.554]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.554]                   signalCondition(cond)
[13:17:27.554]                 }
[13:17:27.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.554]                 "immediateCondition"))) {
[13:17:27.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.554]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.554]                   if (TRUE && !signal) {
[13:17:27.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.554]                     {
[13:17:27.554]                       inherits <- base::inherits
[13:17:27.554]                       invokeRestart <- base::invokeRestart
[13:17:27.554]                       is.null <- base::is.null
[13:17:27.554]                       muffled <- FALSE
[13:17:27.554]                       if (inherits(cond, "message")) {
[13:17:27.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.554]                         if (muffled) 
[13:17:27.554]                           invokeRestart("muffleMessage")
[13:17:27.554]                       }
[13:17:27.554]                       else if (inherits(cond, "warning")) {
[13:17:27.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.554]                         if (muffled) 
[13:17:27.554]                           invokeRestart("muffleWarning")
[13:17:27.554]                       }
[13:17:27.554]                       else if (inherits(cond, "condition")) {
[13:17:27.554]                         if (!is.null(pattern)) {
[13:17:27.554]                           computeRestarts <- base::computeRestarts
[13:17:27.554]                           grepl <- base::grepl
[13:17:27.554]                           restarts <- computeRestarts(cond)
[13:17:27.554]                           for (restart in restarts) {
[13:17:27.554]                             name <- restart$name
[13:17:27.554]                             if (is.null(name)) 
[13:17:27.554]                               next
[13:17:27.554]                             if (!grepl(pattern, name)) 
[13:17:27.554]                               next
[13:17:27.554]                             invokeRestart(restart)
[13:17:27.554]                             muffled <- TRUE
[13:17:27.554]                             break
[13:17:27.554]                           }
[13:17:27.554]                         }
[13:17:27.554]                       }
[13:17:27.554]                       invisible(muffled)
[13:17:27.554]                     }
[13:17:27.554]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.554]                   }
[13:17:27.554]                 }
[13:17:27.554]                 else {
[13:17:27.554]                   if (TRUE) {
[13:17:27.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.554]                     {
[13:17:27.554]                       inherits <- base::inherits
[13:17:27.554]                       invokeRestart <- base::invokeRestart
[13:17:27.554]                       is.null <- base::is.null
[13:17:27.554]                       muffled <- FALSE
[13:17:27.554]                       if (inherits(cond, "message")) {
[13:17:27.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.554]                         if (muffled) 
[13:17:27.554]                           invokeRestart("muffleMessage")
[13:17:27.554]                       }
[13:17:27.554]                       else if (inherits(cond, "warning")) {
[13:17:27.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.554]                         if (muffled) 
[13:17:27.554]                           invokeRestart("muffleWarning")
[13:17:27.554]                       }
[13:17:27.554]                       else if (inherits(cond, "condition")) {
[13:17:27.554]                         if (!is.null(pattern)) {
[13:17:27.554]                           computeRestarts <- base::computeRestarts
[13:17:27.554]                           grepl <- base::grepl
[13:17:27.554]                           restarts <- computeRestarts(cond)
[13:17:27.554]                           for (restart in restarts) {
[13:17:27.554]                             name <- restart$name
[13:17:27.554]                             if (is.null(name)) 
[13:17:27.554]                               next
[13:17:27.554]                             if (!grepl(pattern, name)) 
[13:17:27.554]                               next
[13:17:27.554]                             invokeRestart(restart)
[13:17:27.554]                             muffled <- TRUE
[13:17:27.554]                             break
[13:17:27.554]                           }
[13:17:27.554]                         }
[13:17:27.554]                       }
[13:17:27.554]                       invisible(muffled)
[13:17:27.554]                     }
[13:17:27.554]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.554]                   }
[13:17:27.554]                 }
[13:17:27.554]             }
[13:17:27.554]         }))
[13:17:27.554]     }, error = function(ex) {
[13:17:27.554]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.554]                 ...future.rng), started = ...future.startTime, 
[13:17:27.554]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.554]             version = "1.8"), class = "FutureResult")
[13:17:27.554]     }, finally = {
[13:17:27.554]         if (!identical(...future.workdir, getwd())) 
[13:17:27.554]             setwd(...future.workdir)
[13:17:27.554]         {
[13:17:27.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.554]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.554]             }
[13:17:27.554]             base::options(...future.oldOptions)
[13:17:27.554]             if (.Platform$OS.type == "windows") {
[13:17:27.554]                 old_names <- names(...future.oldEnvVars)
[13:17:27.554]                 envs <- base::Sys.getenv()
[13:17:27.554]                 names <- names(envs)
[13:17:27.554]                 common <- intersect(names, old_names)
[13:17:27.554]                 added <- setdiff(names, old_names)
[13:17:27.554]                 removed <- setdiff(old_names, names)
[13:17:27.554]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.554]                   envs[common]]
[13:17:27.554]                 NAMES <- toupper(changed)
[13:17:27.554]                 args <- list()
[13:17:27.554]                 for (kk in seq_along(NAMES)) {
[13:17:27.554]                   name <- changed[[kk]]
[13:17:27.554]                   NAME <- NAMES[[kk]]
[13:17:27.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.554]                     next
[13:17:27.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.554]                 }
[13:17:27.554]                 NAMES <- toupper(added)
[13:17:27.554]                 for (kk in seq_along(NAMES)) {
[13:17:27.554]                   name <- added[[kk]]
[13:17:27.554]                   NAME <- NAMES[[kk]]
[13:17:27.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.554]                     next
[13:17:27.554]                   args[[name]] <- ""
[13:17:27.554]                 }
[13:17:27.554]                 NAMES <- toupper(removed)
[13:17:27.554]                 for (kk in seq_along(NAMES)) {
[13:17:27.554]                   name <- removed[[kk]]
[13:17:27.554]                   NAME <- NAMES[[kk]]
[13:17:27.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.554]                     next
[13:17:27.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.554]                 }
[13:17:27.554]                 if (length(args) > 0) 
[13:17:27.554]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.554]             }
[13:17:27.554]             else {
[13:17:27.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.554]             }
[13:17:27.554]             {
[13:17:27.554]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.554]                   0L) {
[13:17:27.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.554]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.554]                   base::options(opts)
[13:17:27.554]                 }
[13:17:27.554]                 {
[13:17:27.554]                   {
[13:17:27.554]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.554]                     NULL
[13:17:27.554]                   }
[13:17:27.554]                   options(future.plan = NULL)
[13:17:27.554]                   if (is.na(NA_character_)) 
[13:17:27.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.554]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.554]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.554]                     envir = parent.frame()) 
[13:17:27.554]                   {
[13:17:27.554]                     if (is.function(workers)) 
[13:17:27.554]                       workers <- workers()
[13:17:27.554]                     workers <- structure(as.integer(workers), 
[13:17:27.554]                       class = class(workers))
[13:17:27.554]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.554]                       workers >= 1)
[13:17:27.554]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.554]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.554]                     }
[13:17:27.554]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.554]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.554]                       envir = envir)
[13:17:27.554]                     if (!future$lazy) 
[13:17:27.554]                       future <- run(future)
[13:17:27.554]                     invisible(future)
[13:17:27.554]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.554]                 }
[13:17:27.554]             }
[13:17:27.554]         }
[13:17:27.554]     })
[13:17:27.554]     if (TRUE) {
[13:17:27.554]         base::sink(type = "output", split = FALSE)
[13:17:27.554]         if (TRUE) {
[13:17:27.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.554]         }
[13:17:27.554]         else {
[13:17:27.554]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.554]         }
[13:17:27.554]         base::close(...future.stdout)
[13:17:27.554]         ...future.stdout <- NULL
[13:17:27.554]     }
[13:17:27.554]     ...future.result$conditions <- ...future.conditions
[13:17:27.554]     ...future.result$finished <- base::Sys.time()
[13:17:27.554]     ...future.result
[13:17:27.554] }
[13:17:27.557] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[13:17:27.557] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.558] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.558] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:17:27.558] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:17:27.558] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:17:27.559] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:17:27.559] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:27.559] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.559] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:27.559] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.560] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[13:17:27.560] MultisessionFuture started
[13:17:27.560] - Launch lazy future ... done
[13:17:27.560] run() for ‘MultisessionFuture’ ... done
[13:17:27.560] Created future:
[13:17:27.561] MultisessionFuture:
[13:17:27.561] Label: ‘future_apply-1’
[13:17:27.561] Expression:
[13:17:27.561] {
[13:17:27.561]     do.call(function(...) {
[13:17:27.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.561]             on.exit(options(oopts), add = TRUE)
[13:17:27.561]         }
[13:17:27.561]         {
[13:17:27.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.561]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.561]             })
[13:17:27.561]         }
[13:17:27.561]     }, args = future.call.arguments)
[13:17:27.561] }
[13:17:27.561] Lazy evaluation: FALSE
[13:17:27.561] Asynchronous evaluation: TRUE
[13:17:27.561] Local evaluation: TRUE
[13:17:27.561] Environment: R_GlobalEnv
[13:17:27.561] Capture standard output: TRUE
[13:17:27.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.561] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.561] Packages: <none>
[13:17:27.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.561] Resolved: FALSE
[13:17:27.561] Value: <not collected>
[13:17:27.561] Conditions captured: <none>
[13:17:27.561] Early signaling: FALSE
[13:17:27.561] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.561] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.572] Chunk #1 of 2 ... DONE
[13:17:27.572] Chunk #2 of 2 ...
[13:17:27.572]  - seeds: <none>
[13:17:27.573] getGlobalsAndPackages() ...
[13:17:27.573] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.573] Resolving globals: FALSE
[13:17:27.573] Tweak future expression to call with '...' arguments ...
[13:17:27.573] {
[13:17:27.573]     do.call(function(...) {
[13:17:27.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.573]             on.exit(options(oopts), add = TRUE)
[13:17:27.573]         }
[13:17:27.573]         {
[13:17:27.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.573]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.573]             })
[13:17:27.573]         }
[13:17:27.573]     }, args = future.call.arguments)
[13:17:27.573] }
[13:17:27.573] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.574] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.574] 
[13:17:27.574] getGlobalsAndPackages() ... DONE
[13:17:27.574] run() for ‘Future’ ...
[13:17:27.574] - state: ‘created’
[13:17:27.575] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.589] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.589]   - Field: ‘node’
[13:17:27.590]   - Field: ‘label’
[13:17:27.590]   - Field: ‘local’
[13:17:27.590]   - Field: ‘owner’
[13:17:27.590]   - Field: ‘envir’
[13:17:27.590]   - Field: ‘workers’
[13:17:27.590]   - Field: ‘packages’
[13:17:27.590]   - Field: ‘gc’
[13:17:27.590]   - Field: ‘conditions’
[13:17:27.590]   - Field: ‘persistent’
[13:17:27.590]   - Field: ‘expr’
[13:17:27.591]   - Field: ‘uuid’
[13:17:27.591]   - Field: ‘seed’
[13:17:27.591]   - Field: ‘version’
[13:17:27.591]   - Field: ‘result’
[13:17:27.591]   - Field: ‘asynchronous’
[13:17:27.591]   - Field: ‘calls’
[13:17:27.591]   - Field: ‘globals’
[13:17:27.591]   - Field: ‘stdout’
[13:17:27.591]   - Field: ‘earlySignal’
[13:17:27.591]   - Field: ‘lazy’
[13:17:27.591]   - Field: ‘state’
[13:17:27.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.592] - Launch lazy future ...
[13:17:27.592] Packages needed by the future expression (n = 0): <none>
[13:17:27.592] Packages needed by future strategies (n = 0): <none>
[13:17:27.592] {
[13:17:27.592]     {
[13:17:27.592]         {
[13:17:27.592]             ...future.startTime <- base::Sys.time()
[13:17:27.592]             {
[13:17:27.592]                 {
[13:17:27.592]                   {
[13:17:27.592]                     {
[13:17:27.592]                       base::local({
[13:17:27.592]                         has_future <- base::requireNamespace("future", 
[13:17:27.592]                           quietly = TRUE)
[13:17:27.592]                         if (has_future) {
[13:17:27.592]                           ns <- base::getNamespace("future")
[13:17:27.592]                           version <- ns[[".package"]][["version"]]
[13:17:27.592]                           if (is.null(version)) 
[13:17:27.592]                             version <- utils::packageVersion("future")
[13:17:27.592]                         }
[13:17:27.592]                         else {
[13:17:27.592]                           version <- NULL
[13:17:27.592]                         }
[13:17:27.592]                         if (!has_future || version < "1.8.0") {
[13:17:27.592]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.592]                             "", base::R.version$version.string), 
[13:17:27.592]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.592]                               "release", "version")], collapse = " "), 
[13:17:27.592]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.592]                             info)
[13:17:27.592]                           info <- base::paste(info, collapse = "; ")
[13:17:27.592]                           if (!has_future) {
[13:17:27.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.592]                               info)
[13:17:27.592]                           }
[13:17:27.592]                           else {
[13:17:27.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.592]                               info, version)
[13:17:27.592]                           }
[13:17:27.592]                           base::stop(msg)
[13:17:27.592]                         }
[13:17:27.592]                       })
[13:17:27.592]                     }
[13:17:27.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.592]                     base::options(mc.cores = 1L)
[13:17:27.592]                   }
[13:17:27.592]                   options(future.plan = NULL)
[13:17:27.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.592]                 }
[13:17:27.592]                 ...future.workdir <- getwd()
[13:17:27.592]             }
[13:17:27.592]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.592]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.592]         }
[13:17:27.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.592]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.592]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.592]             base::names(...future.oldOptions))
[13:17:27.592]     }
[13:17:27.592]     if (FALSE) {
[13:17:27.592]     }
[13:17:27.592]     else {
[13:17:27.592]         if (TRUE) {
[13:17:27.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.592]                 open = "w")
[13:17:27.592]         }
[13:17:27.592]         else {
[13:17:27.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.592]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.592]         }
[13:17:27.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.592]             base::sink(type = "output", split = FALSE)
[13:17:27.592]             base::close(...future.stdout)
[13:17:27.592]         }, add = TRUE)
[13:17:27.592]     }
[13:17:27.592]     ...future.frame <- base::sys.nframe()
[13:17:27.592]     ...future.conditions <- base::list()
[13:17:27.592]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.592]     if (FALSE) {
[13:17:27.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.592]     }
[13:17:27.592]     ...future.result <- base::tryCatch({
[13:17:27.592]         base::withCallingHandlers({
[13:17:27.592]             ...future.value <- base::withVisible(base::local({
[13:17:27.592]                 ...future.makeSendCondition <- local({
[13:17:27.592]                   sendCondition <- NULL
[13:17:27.592]                   function(frame = 1L) {
[13:17:27.592]                     if (is.function(sendCondition)) 
[13:17:27.592]                       return(sendCondition)
[13:17:27.592]                     ns <- getNamespace("parallel")
[13:17:27.592]                     if (exists("sendData", mode = "function", 
[13:17:27.592]                       envir = ns)) {
[13:17:27.592]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.592]                         envir = ns)
[13:17:27.592]                       envir <- sys.frame(frame)
[13:17:27.592]                       master <- NULL
[13:17:27.592]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.592]                         !identical(envir, emptyenv())) {
[13:17:27.592]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.592]                           inherits = FALSE)) {
[13:17:27.592]                           master <- get("master", mode = "list", 
[13:17:27.592]                             envir = envir, inherits = FALSE)
[13:17:27.592]                           if (inherits(master, c("SOCKnode", 
[13:17:27.592]                             "SOCK0node"))) {
[13:17:27.592]                             sendCondition <<- function(cond) {
[13:17:27.592]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.592]                                 success = TRUE)
[13:17:27.592]                               parallel_sendData(master, data)
[13:17:27.592]                             }
[13:17:27.592]                             return(sendCondition)
[13:17:27.592]                           }
[13:17:27.592]                         }
[13:17:27.592]                         frame <- frame + 1L
[13:17:27.592]                         envir <- sys.frame(frame)
[13:17:27.592]                       }
[13:17:27.592]                     }
[13:17:27.592]                     sendCondition <<- function(cond) NULL
[13:17:27.592]                   }
[13:17:27.592]                 })
[13:17:27.592]                 withCallingHandlers({
[13:17:27.592]                   {
[13:17:27.592]                     do.call(function(...) {
[13:17:27.592]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.592]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.592]                         ...future.globals.maxSize)) {
[13:17:27.592]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.592]                         on.exit(options(oopts), add = TRUE)
[13:17:27.592]                       }
[13:17:27.592]                       {
[13:17:27.592]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.592]                           FUN = function(jj) {
[13:17:27.592]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.592]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.592]                           })
[13:17:27.592]                       }
[13:17:27.592]                     }, args = future.call.arguments)
[13:17:27.592]                   }
[13:17:27.592]                 }, immediateCondition = function(cond) {
[13:17:27.592]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.592]                   sendCondition(cond)
[13:17:27.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.592]                   {
[13:17:27.592]                     inherits <- base::inherits
[13:17:27.592]                     invokeRestart <- base::invokeRestart
[13:17:27.592]                     is.null <- base::is.null
[13:17:27.592]                     muffled <- FALSE
[13:17:27.592]                     if (inherits(cond, "message")) {
[13:17:27.592]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.592]                       if (muffled) 
[13:17:27.592]                         invokeRestart("muffleMessage")
[13:17:27.592]                     }
[13:17:27.592]                     else if (inherits(cond, "warning")) {
[13:17:27.592]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.592]                       if (muffled) 
[13:17:27.592]                         invokeRestart("muffleWarning")
[13:17:27.592]                     }
[13:17:27.592]                     else if (inherits(cond, "condition")) {
[13:17:27.592]                       if (!is.null(pattern)) {
[13:17:27.592]                         computeRestarts <- base::computeRestarts
[13:17:27.592]                         grepl <- base::grepl
[13:17:27.592]                         restarts <- computeRestarts(cond)
[13:17:27.592]                         for (restart in restarts) {
[13:17:27.592]                           name <- restart$name
[13:17:27.592]                           if (is.null(name)) 
[13:17:27.592]                             next
[13:17:27.592]                           if (!grepl(pattern, name)) 
[13:17:27.592]                             next
[13:17:27.592]                           invokeRestart(restart)
[13:17:27.592]                           muffled <- TRUE
[13:17:27.592]                           break
[13:17:27.592]                         }
[13:17:27.592]                       }
[13:17:27.592]                     }
[13:17:27.592]                     invisible(muffled)
[13:17:27.592]                   }
[13:17:27.592]                   muffleCondition(cond)
[13:17:27.592]                 })
[13:17:27.592]             }))
[13:17:27.592]             future::FutureResult(value = ...future.value$value, 
[13:17:27.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.592]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.592]                     ...future.globalenv.names))
[13:17:27.592]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.592]         }, condition = base::local({
[13:17:27.592]             c <- base::c
[13:17:27.592]             inherits <- base::inherits
[13:17:27.592]             invokeRestart <- base::invokeRestart
[13:17:27.592]             length <- base::length
[13:17:27.592]             list <- base::list
[13:17:27.592]             seq.int <- base::seq.int
[13:17:27.592]             signalCondition <- base::signalCondition
[13:17:27.592]             sys.calls <- base::sys.calls
[13:17:27.592]             `[[` <- base::`[[`
[13:17:27.592]             `+` <- base::`+`
[13:17:27.592]             `<<-` <- base::`<<-`
[13:17:27.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.592]                   3L)]
[13:17:27.592]             }
[13:17:27.592]             function(cond) {
[13:17:27.592]                 is_error <- inherits(cond, "error")
[13:17:27.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.592]                   NULL)
[13:17:27.592]                 if (is_error) {
[13:17:27.592]                   sessionInformation <- function() {
[13:17:27.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.592]                       search = base::search(), system = base::Sys.info())
[13:17:27.592]                   }
[13:17:27.592]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.592]                     cond$call), session = sessionInformation(), 
[13:17:27.592]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.592]                   signalCondition(cond)
[13:17:27.592]                 }
[13:17:27.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.592]                 "immediateCondition"))) {
[13:17:27.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.592]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.592]                   if (TRUE && !signal) {
[13:17:27.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.592]                     {
[13:17:27.592]                       inherits <- base::inherits
[13:17:27.592]                       invokeRestart <- base::invokeRestart
[13:17:27.592]                       is.null <- base::is.null
[13:17:27.592]                       muffled <- FALSE
[13:17:27.592]                       if (inherits(cond, "message")) {
[13:17:27.592]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.592]                         if (muffled) 
[13:17:27.592]                           invokeRestart("muffleMessage")
[13:17:27.592]                       }
[13:17:27.592]                       else if (inherits(cond, "warning")) {
[13:17:27.592]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.592]                         if (muffled) 
[13:17:27.592]                           invokeRestart("muffleWarning")
[13:17:27.592]                       }
[13:17:27.592]                       else if (inherits(cond, "condition")) {
[13:17:27.592]                         if (!is.null(pattern)) {
[13:17:27.592]                           computeRestarts <- base::computeRestarts
[13:17:27.592]                           grepl <- base::grepl
[13:17:27.592]                           restarts <- computeRestarts(cond)
[13:17:27.592]                           for (restart in restarts) {
[13:17:27.592]                             name <- restart$name
[13:17:27.592]                             if (is.null(name)) 
[13:17:27.592]                               next
[13:17:27.592]                             if (!grepl(pattern, name)) 
[13:17:27.592]                               next
[13:17:27.592]                             invokeRestart(restart)
[13:17:27.592]                             muffled <- TRUE
[13:17:27.592]                             break
[13:17:27.592]                           }
[13:17:27.592]                         }
[13:17:27.592]                       }
[13:17:27.592]                       invisible(muffled)
[13:17:27.592]                     }
[13:17:27.592]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.592]                   }
[13:17:27.592]                 }
[13:17:27.592]                 else {
[13:17:27.592]                   if (TRUE) {
[13:17:27.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.592]                     {
[13:17:27.592]                       inherits <- base::inherits
[13:17:27.592]                       invokeRestart <- base::invokeRestart
[13:17:27.592]                       is.null <- base::is.null
[13:17:27.592]                       muffled <- FALSE
[13:17:27.592]                       if (inherits(cond, "message")) {
[13:17:27.592]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.592]                         if (muffled) 
[13:17:27.592]                           invokeRestart("muffleMessage")
[13:17:27.592]                       }
[13:17:27.592]                       else if (inherits(cond, "warning")) {
[13:17:27.592]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.592]                         if (muffled) 
[13:17:27.592]                           invokeRestart("muffleWarning")
[13:17:27.592]                       }
[13:17:27.592]                       else if (inherits(cond, "condition")) {
[13:17:27.592]                         if (!is.null(pattern)) {
[13:17:27.592]                           computeRestarts <- base::computeRestarts
[13:17:27.592]                           grepl <- base::grepl
[13:17:27.592]                           restarts <- computeRestarts(cond)
[13:17:27.592]                           for (restart in restarts) {
[13:17:27.592]                             name <- restart$name
[13:17:27.592]                             if (is.null(name)) 
[13:17:27.592]                               next
[13:17:27.592]                             if (!grepl(pattern, name)) 
[13:17:27.592]                               next
[13:17:27.592]                             invokeRestart(restart)
[13:17:27.592]                             muffled <- TRUE
[13:17:27.592]                             break
[13:17:27.592]                           }
[13:17:27.592]                         }
[13:17:27.592]                       }
[13:17:27.592]                       invisible(muffled)
[13:17:27.592]                     }
[13:17:27.592]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.592]                   }
[13:17:27.592]                 }
[13:17:27.592]             }
[13:17:27.592]         }))
[13:17:27.592]     }, error = function(ex) {
[13:17:27.592]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.592]                 ...future.rng), started = ...future.startTime, 
[13:17:27.592]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.592]             version = "1.8"), class = "FutureResult")
[13:17:27.592]     }, finally = {
[13:17:27.592]         if (!identical(...future.workdir, getwd())) 
[13:17:27.592]             setwd(...future.workdir)
[13:17:27.592]         {
[13:17:27.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.592]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.592]             }
[13:17:27.592]             base::options(...future.oldOptions)
[13:17:27.592]             if (.Platform$OS.type == "windows") {
[13:17:27.592]                 old_names <- names(...future.oldEnvVars)
[13:17:27.592]                 envs <- base::Sys.getenv()
[13:17:27.592]                 names <- names(envs)
[13:17:27.592]                 common <- intersect(names, old_names)
[13:17:27.592]                 added <- setdiff(names, old_names)
[13:17:27.592]                 removed <- setdiff(old_names, names)
[13:17:27.592]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.592]                   envs[common]]
[13:17:27.592]                 NAMES <- toupper(changed)
[13:17:27.592]                 args <- list()
[13:17:27.592]                 for (kk in seq_along(NAMES)) {
[13:17:27.592]                   name <- changed[[kk]]
[13:17:27.592]                   NAME <- NAMES[[kk]]
[13:17:27.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.592]                     next
[13:17:27.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.592]                 }
[13:17:27.592]                 NAMES <- toupper(added)
[13:17:27.592]                 for (kk in seq_along(NAMES)) {
[13:17:27.592]                   name <- added[[kk]]
[13:17:27.592]                   NAME <- NAMES[[kk]]
[13:17:27.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.592]                     next
[13:17:27.592]                   args[[name]] <- ""
[13:17:27.592]                 }
[13:17:27.592]                 NAMES <- toupper(removed)
[13:17:27.592]                 for (kk in seq_along(NAMES)) {
[13:17:27.592]                   name <- removed[[kk]]
[13:17:27.592]                   NAME <- NAMES[[kk]]
[13:17:27.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.592]                     next
[13:17:27.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.592]                 }
[13:17:27.592]                 if (length(args) > 0) 
[13:17:27.592]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.592]             }
[13:17:27.592]             else {
[13:17:27.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.592]             }
[13:17:27.592]             {
[13:17:27.592]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.592]                   0L) {
[13:17:27.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.592]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.592]                   base::options(opts)
[13:17:27.592]                 }
[13:17:27.592]                 {
[13:17:27.592]                   {
[13:17:27.592]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.592]                     NULL
[13:17:27.592]                   }
[13:17:27.592]                   options(future.plan = NULL)
[13:17:27.592]                   if (is.na(NA_character_)) 
[13:17:27.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.592]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.592]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.592]                     envir = parent.frame()) 
[13:17:27.592]                   {
[13:17:27.592]                     if (is.function(workers)) 
[13:17:27.592]                       workers <- workers()
[13:17:27.592]                     workers <- structure(as.integer(workers), 
[13:17:27.592]                       class = class(workers))
[13:17:27.592]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.592]                       workers >= 1)
[13:17:27.592]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.592]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.592]                     }
[13:17:27.592]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.592]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.592]                       envir = envir)
[13:17:27.592]                     if (!future$lazy) 
[13:17:27.592]                       future <- run(future)
[13:17:27.592]                     invisible(future)
[13:17:27.592]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.592]                 }
[13:17:27.592]             }
[13:17:27.592]         }
[13:17:27.592]     })
[13:17:27.592]     if (TRUE) {
[13:17:27.592]         base::sink(type = "output", split = FALSE)
[13:17:27.592]         if (TRUE) {
[13:17:27.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.592]         }
[13:17:27.592]         else {
[13:17:27.592]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.592]         }
[13:17:27.592]         base::close(...future.stdout)
[13:17:27.592]         ...future.stdout <- NULL
[13:17:27.592]     }
[13:17:27.592]     ...future.result$conditions <- ...future.conditions
[13:17:27.592]     ...future.result$finished <- base::Sys.time()
[13:17:27.592]     ...future.result
[13:17:27.592] }
[13:17:27.596] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[13:17:27.596] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.596] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.596] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:17:27.597] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:17:27.597] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:17:27.597] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:17:27.597] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.598] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.598] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:27.598] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.598] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[13:17:27.599] MultisessionFuture started
[13:17:27.599] - Launch lazy future ... done
[13:17:27.599] run() for ‘MultisessionFuture’ ... done
[13:17:27.599] Created future:
[13:17:27.599] MultisessionFuture:
[13:17:27.599] Label: ‘future_apply-2’
[13:17:27.599] Expression:
[13:17:27.599] {
[13:17:27.599]     do.call(function(...) {
[13:17:27.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.599]             on.exit(options(oopts), add = TRUE)
[13:17:27.599]         }
[13:17:27.599]         {
[13:17:27.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.599]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.599]             })
[13:17:27.599]         }
[13:17:27.599]     }, args = future.call.arguments)
[13:17:27.599] }
[13:17:27.599] Lazy evaluation: FALSE
[13:17:27.599] Asynchronous evaluation: TRUE
[13:17:27.599] Local evaluation: TRUE
[13:17:27.599] Environment: R_GlobalEnv
[13:17:27.599] Capture standard output: TRUE
[13:17:27.599] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.599] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.599] Packages: <none>
[13:17:27.599] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.599] Resolved: FALSE
[13:17:27.599] Value: <not collected>
[13:17:27.599] Conditions captured: <none>
[13:17:27.599] Early signaling: FALSE
[13:17:27.599] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.599] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.610] Chunk #2 of 2 ... DONE
[13:17:27.611] Launching 2 futures (chunks) ... DONE
[13:17:27.611] Resolving 2 futures (chunks) ...
[13:17:27.611] resolve() on list ...
[13:17:27.611]  recursive: 0
[13:17:27.611]  length: 2
[13:17:27.611] 
[13:17:27.612] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.612] - Validating connection of MultisessionFuture
[13:17:27.612] - received message: FutureResult
[13:17:27.612] - Received FutureResult
[13:17:27.612] - Erased future from FutureRegistry
[13:17:27.612] result() for ClusterFuture ...
[13:17:27.612] - result already collected: FutureResult
[13:17:27.612] result() for ClusterFuture ... done
[13:17:27.613] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.613] Future #1
[13:17:27.613] result() for ClusterFuture ...
[13:17:27.613] - result already collected: FutureResult
[13:17:27.613] result() for ClusterFuture ... done
[13:17:27.613] result() for ClusterFuture ...
[13:17:27.613] - result already collected: FutureResult
[13:17:27.613] result() for ClusterFuture ... done
[13:17:27.613] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.613] - nx: 2
[13:17:27.613] - relay: TRUE
[13:17:27.614] - stdout: TRUE
[13:17:27.614] - signal: TRUE
[13:17:27.614] - resignal: FALSE
[13:17:27.614] - force: TRUE
[13:17:27.614] - relayed: [n=2] FALSE, FALSE
[13:17:27.614] - queued futures: [n=2] FALSE, FALSE
[13:17:27.614]  - until=1
[13:17:27.614]  - relaying element #1
[13:17:27.614] result() for ClusterFuture ...
[13:17:27.614] - result already collected: FutureResult
[13:17:27.614] result() for ClusterFuture ... done
[13:17:27.615] result() for ClusterFuture ...
[13:17:27.615] - result already collected: FutureResult
[13:17:27.615] result() for ClusterFuture ... done
[13:17:27.615] result() for ClusterFuture ...
[13:17:27.615] - result already collected: FutureResult
[13:17:27.615] result() for ClusterFuture ... done
[13:17:27.615] result() for ClusterFuture ...
[13:17:27.615] - result already collected: FutureResult
[13:17:27.615] result() for ClusterFuture ... done
[13:17:27.615] - relayed: [n=2] TRUE, FALSE
[13:17:27.615] - queued futures: [n=2] TRUE, FALSE
[13:17:27.616] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.616]  length: 1 (resolved future 1)
[13:17:27.646] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.646] - Validating connection of MultisessionFuture
[13:17:27.646] - received message: FutureResult
[13:17:27.646] - Received FutureResult
[13:17:27.646] - Erased future from FutureRegistry
[13:17:27.646] result() for ClusterFuture ...
[13:17:27.646] - result already collected: FutureResult
[13:17:27.647] result() for ClusterFuture ... done
[13:17:27.647] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.647] Future #2
[13:17:27.647] result() for ClusterFuture ...
[13:17:27.647] - result already collected: FutureResult
[13:17:27.647] result() for ClusterFuture ... done
[13:17:27.647] result() for ClusterFuture ...
[13:17:27.647] - result already collected: FutureResult
[13:17:27.647] result() for ClusterFuture ... done
[13:17:27.647] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.647] - nx: 2
[13:17:27.648] - relay: TRUE
[13:17:27.648] - stdout: TRUE
[13:17:27.648] - signal: TRUE
[13:17:27.648] - resignal: FALSE
[13:17:27.648] - force: TRUE
[13:17:27.648] - relayed: [n=2] TRUE, FALSE
[13:17:27.648] - queued futures: [n=2] TRUE, FALSE
[13:17:27.648]  - until=2
[13:17:27.648]  - relaying element #2
[13:17:27.648] result() for ClusterFuture ...
[13:17:27.648] - result already collected: FutureResult
[13:17:27.649] result() for ClusterFuture ... done
[13:17:27.649] result() for ClusterFuture ...
[13:17:27.649] - result already collected: FutureResult
[13:17:27.649] result() for ClusterFuture ... done
[13:17:27.649] result() for ClusterFuture ...
[13:17:27.649] - result already collected: FutureResult
[13:17:27.649] result() for ClusterFuture ... done
[13:17:27.649] result() for ClusterFuture ...
[13:17:27.649] - result already collected: FutureResult
[13:17:27.649] result() for ClusterFuture ... done
[13:17:27.650] - relayed: [n=2] TRUE, TRUE
[13:17:27.650] - queued futures: [n=2] TRUE, TRUE
[13:17:27.650] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.650]  length: 0 (resolved future 2)
[13:17:27.650] Relaying remaining futures
[13:17:27.650] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.650] - nx: 2
[13:17:27.650] - relay: TRUE
[13:17:27.650] - stdout: TRUE
[13:17:27.650] - signal: TRUE
[13:17:27.650] - resignal: FALSE
[13:17:27.650] - force: TRUE
[13:17:27.651] - relayed: [n=2] TRUE, TRUE
[13:17:27.651] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.651] - relayed: [n=2] TRUE, TRUE
[13:17:27.651] - queued futures: [n=2] TRUE, TRUE
[13:17:27.651] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.651] resolve() on list ... DONE
[13:17:27.651] result() for ClusterFuture ...
[13:17:27.651] - result already collected: FutureResult
[13:17:27.651] result() for ClusterFuture ... done
[13:17:27.651] result() for ClusterFuture ...
[13:17:27.652] - result already collected: FutureResult
[13:17:27.652] result() for ClusterFuture ... done
[13:17:27.652] result() for ClusterFuture ...
[13:17:27.652] - result already collected: FutureResult
[13:17:27.652] result() for ClusterFuture ... done
[13:17:27.652] result() for ClusterFuture ...
[13:17:27.652] - result already collected: FutureResult
[13:17:27.652] result() for ClusterFuture ... done
[13:17:27.652]  - Number of value chunks collected: 2
[13:17:27.652] Resolving 2 futures (chunks) ... DONE
[13:17:27.652] Reducing values from 2 chunks ...
[13:17:27.653]  - Number of values collected after concatenation: 2
[13:17:27.653]  - Number of values expected: 2
[13:17:27.653] Reducing values from 2 chunks ... DONE
[13:17:27.653] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[13:17:27.653] getGlobalsAndPackagesXApply() ...
[13:17:27.653]  - future.globals: TRUE
[13:17:27.653] getGlobalsAndPackages() ...
[13:17:27.653] Searching for globals...
[13:17:27.654] - globals found: [1] ‘FUN’
[13:17:27.655] Searching for globals ... DONE
[13:17:27.655] Resolving globals: FALSE
[13:17:27.655] The total size of the 1 globals is 848 bytes (848 bytes)
[13:17:27.655] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[13:17:27.655] - globals: [1] ‘FUN’
[13:17:27.656] 
[13:17:27.656] getGlobalsAndPackages() ... DONE
[13:17:27.656]  - globals found/used: [n=1] ‘FUN’
[13:17:27.656]  - needed namespaces: [n=0] 
[13:17:27.656] Finding globals ... DONE
[13:17:27.656]  - use_args: TRUE
[13:17:27.656]  - Getting '...' globals ...
[13:17:27.656] resolve() on list ...
[13:17:27.657]  recursive: 0
[13:17:27.657]  length: 1
[13:17:27.657]  elements: ‘...’
[13:17:27.657]  length: 0 (resolved future 1)
[13:17:27.657] resolve() on list ... DONE
[13:17:27.657]    - '...' content: [n=0] 
[13:17:27.657] List of 1
[13:17:27.657]  $ ...: list()
[13:17:27.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.657]  - attr(*, "where")=List of 1
[13:17:27.657]   ..$ ...:<environment: 0x5647bcb07198> 
[13:17:27.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.657]  - attr(*, "resolved")= logi TRUE
[13:17:27.657]  - attr(*, "total_size")= num NA
[13:17:27.660]  - Getting '...' globals ... DONE
[13:17:27.660] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.660] List of 2
[13:17:27.660]  $ ...future.FUN:function (x)  
[13:17:27.660]  $ ...          : list()
[13:17:27.660]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.660]  - attr(*, "where")=List of 2
[13:17:27.660]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.660]   ..$ ...          :<environment: 0x5647bcb07198> 
[13:17:27.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.660]  - attr(*, "resolved")= logi FALSE
[13:17:27.660]  - attr(*, "total_size")= num 848
[13:17:27.663] Packages to be attached in all futures: [n=0] 
[13:17:27.663] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.667] future_lapply() ...
[13:17:27.671] Number of chunks: 2
[13:17:27.671] getGlobalsAndPackagesXApply() ...
[13:17:27.671]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.671]  - use_args: TRUE
[13:17:27.671] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.671] List of 2
[13:17:27.671]  $ ...          : list()
[13:17:27.671]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.671]  $ ...future.FUN:function (x)  
[13:17:27.671]  - attr(*, "where")=List of 2
[13:17:27.671]   ..$ ...          :<environment: 0x5647bcb07198> 
[13:17:27.671]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:27.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.671]  - attr(*, "resolved")= logi FALSE
[13:17:27.671]  - attr(*, "total_size")= num NA
[13:17:27.677] Packages to be attached in all futures: [n=0] 
[13:17:27.677] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.677] Number of futures (= number of chunks): 2
[13:17:27.677] Launching 2 futures (chunks) ...
[13:17:27.677] Chunk #1 of 2 ...
[13:17:27.677]  - seeds: <none>
[13:17:27.678] getGlobalsAndPackages() ...
[13:17:27.678] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.678] Resolving globals: FALSE
[13:17:27.678] Tweak future expression to call with '...' arguments ...
[13:17:27.678] {
[13:17:27.678]     do.call(function(...) {
[13:17:27.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.678]             on.exit(options(oopts), add = TRUE)
[13:17:27.678]         }
[13:17:27.678]         {
[13:17:27.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.678]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.678]             })
[13:17:27.678]         }
[13:17:27.678]     }, args = future.call.arguments)
[13:17:27.678] }
[13:17:27.678] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.679] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.679] 
[13:17:27.679] getGlobalsAndPackages() ... DONE
[13:17:27.679] run() for ‘Future’ ...
[13:17:27.679] - state: ‘created’
[13:17:27.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.696]   - Field: ‘node’
[13:17:27.697]   - Field: ‘label’
[13:17:27.697]   - Field: ‘local’
[13:17:27.697]   - Field: ‘owner’
[13:17:27.697]   - Field: ‘envir’
[13:17:27.697]   - Field: ‘workers’
[13:17:27.697]   - Field: ‘packages’
[13:17:27.697]   - Field: ‘gc’
[13:17:27.698]   - Field: ‘conditions’
[13:17:27.698]   - Field: ‘persistent’
[13:17:27.698]   - Field: ‘expr’
[13:17:27.698]   - Field: ‘uuid’
[13:17:27.698]   - Field: ‘seed’
[13:17:27.698]   - Field: ‘version’
[13:17:27.698]   - Field: ‘result’
[13:17:27.699]   - Field: ‘asynchronous’
[13:17:27.699]   - Field: ‘calls’
[13:17:27.699]   - Field: ‘globals’
[13:17:27.699]   - Field: ‘stdout’
[13:17:27.699]   - Field: ‘earlySignal’
[13:17:27.699]   - Field: ‘lazy’
[13:17:27.699]   - Field: ‘state’
[13:17:27.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.700] - Launch lazy future ...
[13:17:27.700] Packages needed by the future expression (n = 0): <none>
[13:17:27.700] Packages needed by future strategies (n = 0): <none>
[13:17:27.701] {
[13:17:27.701]     {
[13:17:27.701]         {
[13:17:27.701]             ...future.startTime <- base::Sys.time()
[13:17:27.701]             {
[13:17:27.701]                 {
[13:17:27.701]                   {
[13:17:27.701]                     {
[13:17:27.701]                       base::local({
[13:17:27.701]                         has_future <- base::requireNamespace("future", 
[13:17:27.701]                           quietly = TRUE)
[13:17:27.701]                         if (has_future) {
[13:17:27.701]                           ns <- base::getNamespace("future")
[13:17:27.701]                           version <- ns[[".package"]][["version"]]
[13:17:27.701]                           if (is.null(version)) 
[13:17:27.701]                             version <- utils::packageVersion("future")
[13:17:27.701]                         }
[13:17:27.701]                         else {
[13:17:27.701]                           version <- NULL
[13:17:27.701]                         }
[13:17:27.701]                         if (!has_future || version < "1.8.0") {
[13:17:27.701]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.701]                             "", base::R.version$version.string), 
[13:17:27.701]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.701]                               "release", "version")], collapse = " "), 
[13:17:27.701]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.701]                             info)
[13:17:27.701]                           info <- base::paste(info, collapse = "; ")
[13:17:27.701]                           if (!has_future) {
[13:17:27.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.701]                               info)
[13:17:27.701]                           }
[13:17:27.701]                           else {
[13:17:27.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.701]                               info, version)
[13:17:27.701]                           }
[13:17:27.701]                           base::stop(msg)
[13:17:27.701]                         }
[13:17:27.701]                       })
[13:17:27.701]                     }
[13:17:27.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.701]                     base::options(mc.cores = 1L)
[13:17:27.701]                   }
[13:17:27.701]                   options(future.plan = NULL)
[13:17:27.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.701]                 }
[13:17:27.701]                 ...future.workdir <- getwd()
[13:17:27.701]             }
[13:17:27.701]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.701]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.701]         }
[13:17:27.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.701]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.701]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.701]             base::names(...future.oldOptions))
[13:17:27.701]     }
[13:17:27.701]     if (FALSE) {
[13:17:27.701]     }
[13:17:27.701]     else {
[13:17:27.701]         if (TRUE) {
[13:17:27.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.701]                 open = "w")
[13:17:27.701]         }
[13:17:27.701]         else {
[13:17:27.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.701]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.701]         }
[13:17:27.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.701]             base::sink(type = "output", split = FALSE)
[13:17:27.701]             base::close(...future.stdout)
[13:17:27.701]         }, add = TRUE)
[13:17:27.701]     }
[13:17:27.701]     ...future.frame <- base::sys.nframe()
[13:17:27.701]     ...future.conditions <- base::list()
[13:17:27.701]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.701]     if (FALSE) {
[13:17:27.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.701]     }
[13:17:27.701]     ...future.result <- base::tryCatch({
[13:17:27.701]         base::withCallingHandlers({
[13:17:27.701]             ...future.value <- base::withVisible(base::local({
[13:17:27.701]                 ...future.makeSendCondition <- local({
[13:17:27.701]                   sendCondition <- NULL
[13:17:27.701]                   function(frame = 1L) {
[13:17:27.701]                     if (is.function(sendCondition)) 
[13:17:27.701]                       return(sendCondition)
[13:17:27.701]                     ns <- getNamespace("parallel")
[13:17:27.701]                     if (exists("sendData", mode = "function", 
[13:17:27.701]                       envir = ns)) {
[13:17:27.701]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.701]                         envir = ns)
[13:17:27.701]                       envir <- sys.frame(frame)
[13:17:27.701]                       master <- NULL
[13:17:27.701]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.701]                         !identical(envir, emptyenv())) {
[13:17:27.701]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.701]                           inherits = FALSE)) {
[13:17:27.701]                           master <- get("master", mode = "list", 
[13:17:27.701]                             envir = envir, inherits = FALSE)
[13:17:27.701]                           if (inherits(master, c("SOCKnode", 
[13:17:27.701]                             "SOCK0node"))) {
[13:17:27.701]                             sendCondition <<- function(cond) {
[13:17:27.701]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.701]                                 success = TRUE)
[13:17:27.701]                               parallel_sendData(master, data)
[13:17:27.701]                             }
[13:17:27.701]                             return(sendCondition)
[13:17:27.701]                           }
[13:17:27.701]                         }
[13:17:27.701]                         frame <- frame + 1L
[13:17:27.701]                         envir <- sys.frame(frame)
[13:17:27.701]                       }
[13:17:27.701]                     }
[13:17:27.701]                     sendCondition <<- function(cond) NULL
[13:17:27.701]                   }
[13:17:27.701]                 })
[13:17:27.701]                 withCallingHandlers({
[13:17:27.701]                   {
[13:17:27.701]                     do.call(function(...) {
[13:17:27.701]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.701]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.701]                         ...future.globals.maxSize)) {
[13:17:27.701]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.701]                         on.exit(options(oopts), add = TRUE)
[13:17:27.701]                       }
[13:17:27.701]                       {
[13:17:27.701]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.701]                           FUN = function(jj) {
[13:17:27.701]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.701]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.701]                           })
[13:17:27.701]                       }
[13:17:27.701]                     }, args = future.call.arguments)
[13:17:27.701]                   }
[13:17:27.701]                 }, immediateCondition = function(cond) {
[13:17:27.701]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.701]                   sendCondition(cond)
[13:17:27.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.701]                   {
[13:17:27.701]                     inherits <- base::inherits
[13:17:27.701]                     invokeRestart <- base::invokeRestart
[13:17:27.701]                     is.null <- base::is.null
[13:17:27.701]                     muffled <- FALSE
[13:17:27.701]                     if (inherits(cond, "message")) {
[13:17:27.701]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.701]                       if (muffled) 
[13:17:27.701]                         invokeRestart("muffleMessage")
[13:17:27.701]                     }
[13:17:27.701]                     else if (inherits(cond, "warning")) {
[13:17:27.701]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.701]                       if (muffled) 
[13:17:27.701]                         invokeRestart("muffleWarning")
[13:17:27.701]                     }
[13:17:27.701]                     else if (inherits(cond, "condition")) {
[13:17:27.701]                       if (!is.null(pattern)) {
[13:17:27.701]                         computeRestarts <- base::computeRestarts
[13:17:27.701]                         grepl <- base::grepl
[13:17:27.701]                         restarts <- computeRestarts(cond)
[13:17:27.701]                         for (restart in restarts) {
[13:17:27.701]                           name <- restart$name
[13:17:27.701]                           if (is.null(name)) 
[13:17:27.701]                             next
[13:17:27.701]                           if (!grepl(pattern, name)) 
[13:17:27.701]                             next
[13:17:27.701]                           invokeRestart(restart)
[13:17:27.701]                           muffled <- TRUE
[13:17:27.701]                           break
[13:17:27.701]                         }
[13:17:27.701]                       }
[13:17:27.701]                     }
[13:17:27.701]                     invisible(muffled)
[13:17:27.701]                   }
[13:17:27.701]                   muffleCondition(cond)
[13:17:27.701]                 })
[13:17:27.701]             }))
[13:17:27.701]             future::FutureResult(value = ...future.value$value, 
[13:17:27.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.701]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.701]                     ...future.globalenv.names))
[13:17:27.701]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.701]         }, condition = base::local({
[13:17:27.701]             c <- base::c
[13:17:27.701]             inherits <- base::inherits
[13:17:27.701]             invokeRestart <- base::invokeRestart
[13:17:27.701]             length <- base::length
[13:17:27.701]             list <- base::list
[13:17:27.701]             seq.int <- base::seq.int
[13:17:27.701]             signalCondition <- base::signalCondition
[13:17:27.701]             sys.calls <- base::sys.calls
[13:17:27.701]             `[[` <- base::`[[`
[13:17:27.701]             `+` <- base::`+`
[13:17:27.701]             `<<-` <- base::`<<-`
[13:17:27.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.701]                   3L)]
[13:17:27.701]             }
[13:17:27.701]             function(cond) {
[13:17:27.701]                 is_error <- inherits(cond, "error")
[13:17:27.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.701]                   NULL)
[13:17:27.701]                 if (is_error) {
[13:17:27.701]                   sessionInformation <- function() {
[13:17:27.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.701]                       search = base::search(), system = base::Sys.info())
[13:17:27.701]                   }
[13:17:27.701]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.701]                     cond$call), session = sessionInformation(), 
[13:17:27.701]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.701]                   signalCondition(cond)
[13:17:27.701]                 }
[13:17:27.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.701]                 "immediateCondition"))) {
[13:17:27.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.701]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.701]                   if (TRUE && !signal) {
[13:17:27.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.701]                     {
[13:17:27.701]                       inherits <- base::inherits
[13:17:27.701]                       invokeRestart <- base::invokeRestart
[13:17:27.701]                       is.null <- base::is.null
[13:17:27.701]                       muffled <- FALSE
[13:17:27.701]                       if (inherits(cond, "message")) {
[13:17:27.701]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.701]                         if (muffled) 
[13:17:27.701]                           invokeRestart("muffleMessage")
[13:17:27.701]                       }
[13:17:27.701]                       else if (inherits(cond, "warning")) {
[13:17:27.701]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.701]                         if (muffled) 
[13:17:27.701]                           invokeRestart("muffleWarning")
[13:17:27.701]                       }
[13:17:27.701]                       else if (inherits(cond, "condition")) {
[13:17:27.701]                         if (!is.null(pattern)) {
[13:17:27.701]                           computeRestarts <- base::computeRestarts
[13:17:27.701]                           grepl <- base::grepl
[13:17:27.701]                           restarts <- computeRestarts(cond)
[13:17:27.701]                           for (restart in restarts) {
[13:17:27.701]                             name <- restart$name
[13:17:27.701]                             if (is.null(name)) 
[13:17:27.701]                               next
[13:17:27.701]                             if (!grepl(pattern, name)) 
[13:17:27.701]                               next
[13:17:27.701]                             invokeRestart(restart)
[13:17:27.701]                             muffled <- TRUE
[13:17:27.701]                             break
[13:17:27.701]                           }
[13:17:27.701]                         }
[13:17:27.701]                       }
[13:17:27.701]                       invisible(muffled)
[13:17:27.701]                     }
[13:17:27.701]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.701]                   }
[13:17:27.701]                 }
[13:17:27.701]                 else {
[13:17:27.701]                   if (TRUE) {
[13:17:27.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.701]                     {
[13:17:27.701]                       inherits <- base::inherits
[13:17:27.701]                       invokeRestart <- base::invokeRestart
[13:17:27.701]                       is.null <- base::is.null
[13:17:27.701]                       muffled <- FALSE
[13:17:27.701]                       if (inherits(cond, "message")) {
[13:17:27.701]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.701]                         if (muffled) 
[13:17:27.701]                           invokeRestart("muffleMessage")
[13:17:27.701]                       }
[13:17:27.701]                       else if (inherits(cond, "warning")) {
[13:17:27.701]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.701]                         if (muffled) 
[13:17:27.701]                           invokeRestart("muffleWarning")
[13:17:27.701]                       }
[13:17:27.701]                       else if (inherits(cond, "condition")) {
[13:17:27.701]                         if (!is.null(pattern)) {
[13:17:27.701]                           computeRestarts <- base::computeRestarts
[13:17:27.701]                           grepl <- base::grepl
[13:17:27.701]                           restarts <- computeRestarts(cond)
[13:17:27.701]                           for (restart in restarts) {
[13:17:27.701]                             name <- restart$name
[13:17:27.701]                             if (is.null(name)) 
[13:17:27.701]                               next
[13:17:27.701]                             if (!grepl(pattern, name)) 
[13:17:27.701]                               next
[13:17:27.701]                             invokeRestart(restart)
[13:17:27.701]                             muffled <- TRUE
[13:17:27.701]                             break
[13:17:27.701]                           }
[13:17:27.701]                         }
[13:17:27.701]                       }
[13:17:27.701]                       invisible(muffled)
[13:17:27.701]                     }
[13:17:27.701]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.701]                   }
[13:17:27.701]                 }
[13:17:27.701]             }
[13:17:27.701]         }))
[13:17:27.701]     }, error = function(ex) {
[13:17:27.701]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.701]                 ...future.rng), started = ...future.startTime, 
[13:17:27.701]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.701]             version = "1.8"), class = "FutureResult")
[13:17:27.701]     }, finally = {
[13:17:27.701]         if (!identical(...future.workdir, getwd())) 
[13:17:27.701]             setwd(...future.workdir)
[13:17:27.701]         {
[13:17:27.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.701]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.701]             }
[13:17:27.701]             base::options(...future.oldOptions)
[13:17:27.701]             if (.Platform$OS.type == "windows") {
[13:17:27.701]                 old_names <- names(...future.oldEnvVars)
[13:17:27.701]                 envs <- base::Sys.getenv()
[13:17:27.701]                 names <- names(envs)
[13:17:27.701]                 common <- intersect(names, old_names)
[13:17:27.701]                 added <- setdiff(names, old_names)
[13:17:27.701]                 removed <- setdiff(old_names, names)
[13:17:27.701]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.701]                   envs[common]]
[13:17:27.701]                 NAMES <- toupper(changed)
[13:17:27.701]                 args <- list()
[13:17:27.701]                 for (kk in seq_along(NAMES)) {
[13:17:27.701]                   name <- changed[[kk]]
[13:17:27.701]                   NAME <- NAMES[[kk]]
[13:17:27.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.701]                     next
[13:17:27.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.701]                 }
[13:17:27.701]                 NAMES <- toupper(added)
[13:17:27.701]                 for (kk in seq_along(NAMES)) {
[13:17:27.701]                   name <- added[[kk]]
[13:17:27.701]                   NAME <- NAMES[[kk]]
[13:17:27.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.701]                     next
[13:17:27.701]                   args[[name]] <- ""
[13:17:27.701]                 }
[13:17:27.701]                 NAMES <- toupper(removed)
[13:17:27.701]                 for (kk in seq_along(NAMES)) {
[13:17:27.701]                   name <- removed[[kk]]
[13:17:27.701]                   NAME <- NAMES[[kk]]
[13:17:27.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.701]                     next
[13:17:27.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.701]                 }
[13:17:27.701]                 if (length(args) > 0) 
[13:17:27.701]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.701]             }
[13:17:27.701]             else {
[13:17:27.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.701]             }
[13:17:27.701]             {
[13:17:27.701]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.701]                   0L) {
[13:17:27.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.701]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.701]                   base::options(opts)
[13:17:27.701]                 }
[13:17:27.701]                 {
[13:17:27.701]                   {
[13:17:27.701]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.701]                     NULL
[13:17:27.701]                   }
[13:17:27.701]                   options(future.plan = NULL)
[13:17:27.701]                   if (is.na(NA_character_)) 
[13:17:27.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.701]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.701]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.701]                     envir = parent.frame()) 
[13:17:27.701]                   {
[13:17:27.701]                     if (is.function(workers)) 
[13:17:27.701]                       workers <- workers()
[13:17:27.701]                     workers <- structure(as.integer(workers), 
[13:17:27.701]                       class = class(workers))
[13:17:27.701]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.701]                       workers >= 1)
[13:17:27.701]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.701]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.701]                     }
[13:17:27.701]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.701]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.701]                       envir = envir)
[13:17:27.701]                     if (!future$lazy) 
[13:17:27.701]                       future <- run(future)
[13:17:27.701]                     invisible(future)
[13:17:27.701]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.701]                 }
[13:17:27.701]             }
[13:17:27.701]         }
[13:17:27.701]     })
[13:17:27.701]     if (TRUE) {
[13:17:27.701]         base::sink(type = "output", split = FALSE)
[13:17:27.701]         if (TRUE) {
[13:17:27.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.701]         }
[13:17:27.701]         else {
[13:17:27.701]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.701]         }
[13:17:27.701]         base::close(...future.stdout)
[13:17:27.701]         ...future.stdout <- NULL
[13:17:27.701]     }
[13:17:27.701]     ...future.result$conditions <- ...future.conditions
[13:17:27.701]     ...future.result$finished <- base::Sys.time()
[13:17:27.701]     ...future.result
[13:17:27.701] }
[13:17:27.706] Exporting 5 global objects (1.07 KiB) to cluster node #1 ...
[13:17:27.706] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.706] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.706] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[13:17:27.707] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[13:17:27.707] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[13:17:27.707] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[13:17:27.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:27.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.708] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:27.708] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.709] Exporting 5 global objects (1.07 KiB) to cluster node #1 ... DONE
[13:17:27.709] MultisessionFuture started
[13:17:27.709] - Launch lazy future ... done
[13:17:27.710] run() for ‘MultisessionFuture’ ... done
[13:17:27.710] Created future:
[13:17:27.710] MultisessionFuture:
[13:17:27.710] Label: ‘future_apply-1’
[13:17:27.710] Expression:
[13:17:27.710] {
[13:17:27.710]     do.call(function(...) {
[13:17:27.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.710]             on.exit(options(oopts), add = TRUE)
[13:17:27.710]         }
[13:17:27.710]         {
[13:17:27.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.710]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.710]             })
[13:17:27.710]         }
[13:17:27.710]     }, args = future.call.arguments)
[13:17:27.710] }
[13:17:27.710] Lazy evaluation: FALSE
[13:17:27.710] Asynchronous evaluation: TRUE
[13:17:27.710] Local evaluation: TRUE
[13:17:27.710] Environment: R_GlobalEnv
[13:17:27.710] Capture standard output: TRUE
[13:17:27.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.710] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.710] Packages: <none>
[13:17:27.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.710] Resolved: FALSE
[13:17:27.710] Value: <not collected>
[13:17:27.710] Conditions captured: <none>
[13:17:27.710] Early signaling: FALSE
[13:17:27.710] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.710] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.721] Chunk #1 of 2 ... DONE
[13:17:27.721] Chunk #2 of 2 ...
[13:17:27.722]  - seeds: <none>
[13:17:27.722] getGlobalsAndPackages() ...
[13:17:27.722] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.722] Resolving globals: FALSE
[13:17:27.722] Tweak future expression to call with '...' arguments ...
[13:17:27.722] {
[13:17:27.722]     do.call(function(...) {
[13:17:27.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.722]             on.exit(options(oopts), add = TRUE)
[13:17:27.722]         }
[13:17:27.722]         {
[13:17:27.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.722]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.722]             })
[13:17:27.722]         }
[13:17:27.722]     }, args = future.call.arguments)
[13:17:27.722] }
[13:17:27.723] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.723] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.723] 
[13:17:27.723] getGlobalsAndPackages() ... DONE
[13:17:27.723] run() for ‘Future’ ...
[13:17:27.724] - state: ‘created’
[13:17:27.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.738] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.739]   - Field: ‘node’
[13:17:27.739]   - Field: ‘label’
[13:17:27.739]   - Field: ‘local’
[13:17:27.739]   - Field: ‘owner’
[13:17:27.739]   - Field: ‘envir’
[13:17:27.739]   - Field: ‘workers’
[13:17:27.739]   - Field: ‘packages’
[13:17:27.739]   - Field: ‘gc’
[13:17:27.739]   - Field: ‘conditions’
[13:17:27.740]   - Field: ‘persistent’
[13:17:27.740]   - Field: ‘expr’
[13:17:27.740]   - Field: ‘uuid’
[13:17:27.740]   - Field: ‘seed’
[13:17:27.740]   - Field: ‘version’
[13:17:27.740]   - Field: ‘result’
[13:17:27.740]   - Field: ‘asynchronous’
[13:17:27.740]   - Field: ‘calls’
[13:17:27.740]   - Field: ‘globals’
[13:17:27.740]   - Field: ‘stdout’
[13:17:27.741]   - Field: ‘earlySignal’
[13:17:27.741]   - Field: ‘lazy’
[13:17:27.741]   - Field: ‘state’
[13:17:27.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.741] - Launch lazy future ...
[13:17:27.741] Packages needed by the future expression (n = 0): <none>
[13:17:27.741] Packages needed by future strategies (n = 0): <none>
[13:17:27.742] {
[13:17:27.742]     {
[13:17:27.742]         {
[13:17:27.742]             ...future.startTime <- base::Sys.time()
[13:17:27.742]             {
[13:17:27.742]                 {
[13:17:27.742]                   {
[13:17:27.742]                     {
[13:17:27.742]                       base::local({
[13:17:27.742]                         has_future <- base::requireNamespace("future", 
[13:17:27.742]                           quietly = TRUE)
[13:17:27.742]                         if (has_future) {
[13:17:27.742]                           ns <- base::getNamespace("future")
[13:17:27.742]                           version <- ns[[".package"]][["version"]]
[13:17:27.742]                           if (is.null(version)) 
[13:17:27.742]                             version <- utils::packageVersion("future")
[13:17:27.742]                         }
[13:17:27.742]                         else {
[13:17:27.742]                           version <- NULL
[13:17:27.742]                         }
[13:17:27.742]                         if (!has_future || version < "1.8.0") {
[13:17:27.742]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.742]                             "", base::R.version$version.string), 
[13:17:27.742]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.742]                               "release", "version")], collapse = " "), 
[13:17:27.742]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.742]                             info)
[13:17:27.742]                           info <- base::paste(info, collapse = "; ")
[13:17:27.742]                           if (!has_future) {
[13:17:27.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.742]                               info)
[13:17:27.742]                           }
[13:17:27.742]                           else {
[13:17:27.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.742]                               info, version)
[13:17:27.742]                           }
[13:17:27.742]                           base::stop(msg)
[13:17:27.742]                         }
[13:17:27.742]                       })
[13:17:27.742]                     }
[13:17:27.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.742]                     base::options(mc.cores = 1L)
[13:17:27.742]                   }
[13:17:27.742]                   options(future.plan = NULL)
[13:17:27.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.742]                 }
[13:17:27.742]                 ...future.workdir <- getwd()
[13:17:27.742]             }
[13:17:27.742]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.742]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.742]         }
[13:17:27.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.742]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.742]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.742]             base::names(...future.oldOptions))
[13:17:27.742]     }
[13:17:27.742]     if (FALSE) {
[13:17:27.742]     }
[13:17:27.742]     else {
[13:17:27.742]         if (TRUE) {
[13:17:27.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.742]                 open = "w")
[13:17:27.742]         }
[13:17:27.742]         else {
[13:17:27.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.742]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.742]         }
[13:17:27.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.742]             base::sink(type = "output", split = FALSE)
[13:17:27.742]             base::close(...future.stdout)
[13:17:27.742]         }, add = TRUE)
[13:17:27.742]     }
[13:17:27.742]     ...future.frame <- base::sys.nframe()
[13:17:27.742]     ...future.conditions <- base::list()
[13:17:27.742]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.742]     if (FALSE) {
[13:17:27.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.742]     }
[13:17:27.742]     ...future.result <- base::tryCatch({
[13:17:27.742]         base::withCallingHandlers({
[13:17:27.742]             ...future.value <- base::withVisible(base::local({
[13:17:27.742]                 ...future.makeSendCondition <- local({
[13:17:27.742]                   sendCondition <- NULL
[13:17:27.742]                   function(frame = 1L) {
[13:17:27.742]                     if (is.function(sendCondition)) 
[13:17:27.742]                       return(sendCondition)
[13:17:27.742]                     ns <- getNamespace("parallel")
[13:17:27.742]                     if (exists("sendData", mode = "function", 
[13:17:27.742]                       envir = ns)) {
[13:17:27.742]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.742]                         envir = ns)
[13:17:27.742]                       envir <- sys.frame(frame)
[13:17:27.742]                       master <- NULL
[13:17:27.742]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.742]                         !identical(envir, emptyenv())) {
[13:17:27.742]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.742]                           inherits = FALSE)) {
[13:17:27.742]                           master <- get("master", mode = "list", 
[13:17:27.742]                             envir = envir, inherits = FALSE)
[13:17:27.742]                           if (inherits(master, c("SOCKnode", 
[13:17:27.742]                             "SOCK0node"))) {
[13:17:27.742]                             sendCondition <<- function(cond) {
[13:17:27.742]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.742]                                 success = TRUE)
[13:17:27.742]                               parallel_sendData(master, data)
[13:17:27.742]                             }
[13:17:27.742]                             return(sendCondition)
[13:17:27.742]                           }
[13:17:27.742]                         }
[13:17:27.742]                         frame <- frame + 1L
[13:17:27.742]                         envir <- sys.frame(frame)
[13:17:27.742]                       }
[13:17:27.742]                     }
[13:17:27.742]                     sendCondition <<- function(cond) NULL
[13:17:27.742]                   }
[13:17:27.742]                 })
[13:17:27.742]                 withCallingHandlers({
[13:17:27.742]                   {
[13:17:27.742]                     do.call(function(...) {
[13:17:27.742]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.742]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.742]                         ...future.globals.maxSize)) {
[13:17:27.742]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.742]                         on.exit(options(oopts), add = TRUE)
[13:17:27.742]                       }
[13:17:27.742]                       {
[13:17:27.742]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.742]                           FUN = function(jj) {
[13:17:27.742]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.742]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.742]                           })
[13:17:27.742]                       }
[13:17:27.742]                     }, args = future.call.arguments)
[13:17:27.742]                   }
[13:17:27.742]                 }, immediateCondition = function(cond) {
[13:17:27.742]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.742]                   sendCondition(cond)
[13:17:27.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.742]                   {
[13:17:27.742]                     inherits <- base::inherits
[13:17:27.742]                     invokeRestart <- base::invokeRestart
[13:17:27.742]                     is.null <- base::is.null
[13:17:27.742]                     muffled <- FALSE
[13:17:27.742]                     if (inherits(cond, "message")) {
[13:17:27.742]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.742]                       if (muffled) 
[13:17:27.742]                         invokeRestart("muffleMessage")
[13:17:27.742]                     }
[13:17:27.742]                     else if (inherits(cond, "warning")) {
[13:17:27.742]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.742]                       if (muffled) 
[13:17:27.742]                         invokeRestart("muffleWarning")
[13:17:27.742]                     }
[13:17:27.742]                     else if (inherits(cond, "condition")) {
[13:17:27.742]                       if (!is.null(pattern)) {
[13:17:27.742]                         computeRestarts <- base::computeRestarts
[13:17:27.742]                         grepl <- base::grepl
[13:17:27.742]                         restarts <- computeRestarts(cond)
[13:17:27.742]                         for (restart in restarts) {
[13:17:27.742]                           name <- restart$name
[13:17:27.742]                           if (is.null(name)) 
[13:17:27.742]                             next
[13:17:27.742]                           if (!grepl(pattern, name)) 
[13:17:27.742]                             next
[13:17:27.742]                           invokeRestart(restart)
[13:17:27.742]                           muffled <- TRUE
[13:17:27.742]                           break
[13:17:27.742]                         }
[13:17:27.742]                       }
[13:17:27.742]                     }
[13:17:27.742]                     invisible(muffled)
[13:17:27.742]                   }
[13:17:27.742]                   muffleCondition(cond)
[13:17:27.742]                 })
[13:17:27.742]             }))
[13:17:27.742]             future::FutureResult(value = ...future.value$value, 
[13:17:27.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.742]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.742]                     ...future.globalenv.names))
[13:17:27.742]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.742]         }, condition = base::local({
[13:17:27.742]             c <- base::c
[13:17:27.742]             inherits <- base::inherits
[13:17:27.742]             invokeRestart <- base::invokeRestart
[13:17:27.742]             length <- base::length
[13:17:27.742]             list <- base::list
[13:17:27.742]             seq.int <- base::seq.int
[13:17:27.742]             signalCondition <- base::signalCondition
[13:17:27.742]             sys.calls <- base::sys.calls
[13:17:27.742]             `[[` <- base::`[[`
[13:17:27.742]             `+` <- base::`+`
[13:17:27.742]             `<<-` <- base::`<<-`
[13:17:27.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.742]                   3L)]
[13:17:27.742]             }
[13:17:27.742]             function(cond) {
[13:17:27.742]                 is_error <- inherits(cond, "error")
[13:17:27.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.742]                   NULL)
[13:17:27.742]                 if (is_error) {
[13:17:27.742]                   sessionInformation <- function() {
[13:17:27.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.742]                       search = base::search(), system = base::Sys.info())
[13:17:27.742]                   }
[13:17:27.742]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.742]                     cond$call), session = sessionInformation(), 
[13:17:27.742]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.742]                   signalCondition(cond)
[13:17:27.742]                 }
[13:17:27.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.742]                 "immediateCondition"))) {
[13:17:27.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.742]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.742]                   if (TRUE && !signal) {
[13:17:27.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.742]                     {
[13:17:27.742]                       inherits <- base::inherits
[13:17:27.742]                       invokeRestart <- base::invokeRestart
[13:17:27.742]                       is.null <- base::is.null
[13:17:27.742]                       muffled <- FALSE
[13:17:27.742]                       if (inherits(cond, "message")) {
[13:17:27.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.742]                         if (muffled) 
[13:17:27.742]                           invokeRestart("muffleMessage")
[13:17:27.742]                       }
[13:17:27.742]                       else if (inherits(cond, "warning")) {
[13:17:27.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.742]                         if (muffled) 
[13:17:27.742]                           invokeRestart("muffleWarning")
[13:17:27.742]                       }
[13:17:27.742]                       else if (inherits(cond, "condition")) {
[13:17:27.742]                         if (!is.null(pattern)) {
[13:17:27.742]                           computeRestarts <- base::computeRestarts
[13:17:27.742]                           grepl <- base::grepl
[13:17:27.742]                           restarts <- computeRestarts(cond)
[13:17:27.742]                           for (restart in restarts) {
[13:17:27.742]                             name <- restart$name
[13:17:27.742]                             if (is.null(name)) 
[13:17:27.742]                               next
[13:17:27.742]                             if (!grepl(pattern, name)) 
[13:17:27.742]                               next
[13:17:27.742]                             invokeRestart(restart)
[13:17:27.742]                             muffled <- TRUE
[13:17:27.742]                             break
[13:17:27.742]                           }
[13:17:27.742]                         }
[13:17:27.742]                       }
[13:17:27.742]                       invisible(muffled)
[13:17:27.742]                     }
[13:17:27.742]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.742]                   }
[13:17:27.742]                 }
[13:17:27.742]                 else {
[13:17:27.742]                   if (TRUE) {
[13:17:27.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.742]                     {
[13:17:27.742]                       inherits <- base::inherits
[13:17:27.742]                       invokeRestart <- base::invokeRestart
[13:17:27.742]                       is.null <- base::is.null
[13:17:27.742]                       muffled <- FALSE
[13:17:27.742]                       if (inherits(cond, "message")) {
[13:17:27.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.742]                         if (muffled) 
[13:17:27.742]                           invokeRestart("muffleMessage")
[13:17:27.742]                       }
[13:17:27.742]                       else if (inherits(cond, "warning")) {
[13:17:27.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.742]                         if (muffled) 
[13:17:27.742]                           invokeRestart("muffleWarning")
[13:17:27.742]                       }
[13:17:27.742]                       else if (inherits(cond, "condition")) {
[13:17:27.742]                         if (!is.null(pattern)) {
[13:17:27.742]                           computeRestarts <- base::computeRestarts
[13:17:27.742]                           grepl <- base::grepl
[13:17:27.742]                           restarts <- computeRestarts(cond)
[13:17:27.742]                           for (restart in restarts) {
[13:17:27.742]                             name <- restart$name
[13:17:27.742]                             if (is.null(name)) 
[13:17:27.742]                               next
[13:17:27.742]                             if (!grepl(pattern, name)) 
[13:17:27.742]                               next
[13:17:27.742]                             invokeRestart(restart)
[13:17:27.742]                             muffled <- TRUE
[13:17:27.742]                             break
[13:17:27.742]                           }
[13:17:27.742]                         }
[13:17:27.742]                       }
[13:17:27.742]                       invisible(muffled)
[13:17:27.742]                     }
[13:17:27.742]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.742]                   }
[13:17:27.742]                 }
[13:17:27.742]             }
[13:17:27.742]         }))
[13:17:27.742]     }, error = function(ex) {
[13:17:27.742]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.742]                 ...future.rng), started = ...future.startTime, 
[13:17:27.742]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.742]             version = "1.8"), class = "FutureResult")
[13:17:27.742]     }, finally = {
[13:17:27.742]         if (!identical(...future.workdir, getwd())) 
[13:17:27.742]             setwd(...future.workdir)
[13:17:27.742]         {
[13:17:27.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.742]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.742]             }
[13:17:27.742]             base::options(...future.oldOptions)
[13:17:27.742]             if (.Platform$OS.type == "windows") {
[13:17:27.742]                 old_names <- names(...future.oldEnvVars)
[13:17:27.742]                 envs <- base::Sys.getenv()
[13:17:27.742]                 names <- names(envs)
[13:17:27.742]                 common <- intersect(names, old_names)
[13:17:27.742]                 added <- setdiff(names, old_names)
[13:17:27.742]                 removed <- setdiff(old_names, names)
[13:17:27.742]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.742]                   envs[common]]
[13:17:27.742]                 NAMES <- toupper(changed)
[13:17:27.742]                 args <- list()
[13:17:27.742]                 for (kk in seq_along(NAMES)) {
[13:17:27.742]                   name <- changed[[kk]]
[13:17:27.742]                   NAME <- NAMES[[kk]]
[13:17:27.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.742]                     next
[13:17:27.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.742]                 }
[13:17:27.742]                 NAMES <- toupper(added)
[13:17:27.742]                 for (kk in seq_along(NAMES)) {
[13:17:27.742]                   name <- added[[kk]]
[13:17:27.742]                   NAME <- NAMES[[kk]]
[13:17:27.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.742]                     next
[13:17:27.742]                   args[[name]] <- ""
[13:17:27.742]                 }
[13:17:27.742]                 NAMES <- toupper(removed)
[13:17:27.742]                 for (kk in seq_along(NAMES)) {
[13:17:27.742]                   name <- removed[[kk]]
[13:17:27.742]                   NAME <- NAMES[[kk]]
[13:17:27.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.742]                     next
[13:17:27.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.742]                 }
[13:17:27.742]                 if (length(args) > 0) 
[13:17:27.742]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.742]             }
[13:17:27.742]             else {
[13:17:27.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.742]             }
[13:17:27.742]             {
[13:17:27.742]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.742]                   0L) {
[13:17:27.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.742]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.742]                   base::options(opts)
[13:17:27.742]                 }
[13:17:27.742]                 {
[13:17:27.742]                   {
[13:17:27.742]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.742]                     NULL
[13:17:27.742]                   }
[13:17:27.742]                   options(future.plan = NULL)
[13:17:27.742]                   if (is.na(NA_character_)) 
[13:17:27.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.742]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.742]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.742]                     envir = parent.frame()) 
[13:17:27.742]                   {
[13:17:27.742]                     if (is.function(workers)) 
[13:17:27.742]                       workers <- workers()
[13:17:27.742]                     workers <- structure(as.integer(workers), 
[13:17:27.742]                       class = class(workers))
[13:17:27.742]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.742]                       workers >= 1)
[13:17:27.742]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.742]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.742]                     }
[13:17:27.742]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.742]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.742]                       envir = envir)
[13:17:27.742]                     if (!future$lazy) 
[13:17:27.742]                       future <- run(future)
[13:17:27.742]                     invisible(future)
[13:17:27.742]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.742]                 }
[13:17:27.742]             }
[13:17:27.742]         }
[13:17:27.742]     })
[13:17:27.742]     if (TRUE) {
[13:17:27.742]         base::sink(type = "output", split = FALSE)
[13:17:27.742]         if (TRUE) {
[13:17:27.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.742]         }
[13:17:27.742]         else {
[13:17:27.742]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.742]         }
[13:17:27.742]         base::close(...future.stdout)
[13:17:27.742]         ...future.stdout <- NULL
[13:17:27.742]     }
[13:17:27.742]     ...future.result$conditions <- ...future.conditions
[13:17:27.742]     ...future.result$finished <- base::Sys.time()
[13:17:27.742]     ...future.result
[13:17:27.742] }
[13:17:27.745] Exporting 5 global objects (1.07 KiB) to cluster node #2 ...
[13:17:27.745] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.745] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.746] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[13:17:27.746] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[13:17:27.746] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[13:17:27.746] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[13:17:27.746] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.747] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.747] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:27.747] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.747] Exporting 5 global objects (1.07 KiB) to cluster node #2 ... DONE
[13:17:27.748] MultisessionFuture started
[13:17:27.748] - Launch lazy future ... done
[13:17:27.748] run() for ‘MultisessionFuture’ ... done
[13:17:27.748] Created future:
[13:17:27.748] MultisessionFuture:
[13:17:27.748] Label: ‘future_apply-2’
[13:17:27.748] Expression:
[13:17:27.748] {
[13:17:27.748]     do.call(function(...) {
[13:17:27.748]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.748]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.748]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.748]             on.exit(options(oopts), add = TRUE)
[13:17:27.748]         }
[13:17:27.748]         {
[13:17:27.748]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.748]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.748]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.748]             })
[13:17:27.748]         }
[13:17:27.748]     }, args = future.call.arguments)
[13:17:27.748] }
[13:17:27.748] Lazy evaluation: FALSE
[13:17:27.748] Asynchronous evaluation: TRUE
[13:17:27.748] Local evaluation: TRUE
[13:17:27.748] Environment: R_GlobalEnv
[13:17:27.748] Capture standard output: TRUE
[13:17:27.748] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.748] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.748] Packages: <none>
[13:17:27.748] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.748] Resolved: FALSE
[13:17:27.748] Value: <not collected>
[13:17:27.748] Conditions captured: <none>
[13:17:27.748] Early signaling: FALSE
[13:17:27.748] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.748] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.760] Chunk #2 of 2 ... DONE
[13:17:27.760] Launching 2 futures (chunks) ... DONE
[13:17:27.760] Resolving 2 futures (chunks) ...
[13:17:27.760] resolve() on list ...
[13:17:27.760]  recursive: 0
[13:17:27.760]  length: 2
[13:17:27.761] 
[13:17:27.761] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.761] - Validating connection of MultisessionFuture
[13:17:27.761] - received message: FutureResult
[13:17:27.761] - Received FutureResult
[13:17:27.762] - Erased future from FutureRegistry
[13:17:27.762] result() for ClusterFuture ...
[13:17:27.762] - result already collected: FutureResult
[13:17:27.762] result() for ClusterFuture ... done
[13:17:27.762] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.762] Future #1
[13:17:27.762] result() for ClusterFuture ...
[13:17:27.762] - result already collected: FutureResult
[13:17:27.762] result() for ClusterFuture ... done
[13:17:27.762] result() for ClusterFuture ...
[13:17:27.762] - result already collected: FutureResult
[13:17:27.763] result() for ClusterFuture ... done
[13:17:27.763] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.763] - nx: 2
[13:17:27.763] - relay: TRUE
[13:17:27.763] - stdout: TRUE
[13:17:27.763] - signal: TRUE
[13:17:27.763] - resignal: FALSE
[13:17:27.763] - force: TRUE
[13:17:27.763] - relayed: [n=2] FALSE, FALSE
[13:17:27.763] - queued futures: [n=2] FALSE, FALSE
[13:17:27.763]  - until=1
[13:17:27.764]  - relaying element #1
[13:17:27.764] result() for ClusterFuture ...
[13:17:27.764] - result already collected: FutureResult
[13:17:27.764] result() for ClusterFuture ... done
[13:17:27.764] result() for ClusterFuture ...
[13:17:27.764] - result already collected: FutureResult
[13:17:27.764] result() for ClusterFuture ... done
[13:17:27.764] result() for ClusterFuture ...
[13:17:27.764] - result already collected: FutureResult
[13:17:27.764] result() for ClusterFuture ... done
[13:17:27.764] result() for ClusterFuture ...
[13:17:27.765] - result already collected: FutureResult
[13:17:27.765] result() for ClusterFuture ... done
[13:17:27.765] - relayed: [n=2] TRUE, FALSE
[13:17:27.765] - queued futures: [n=2] TRUE, FALSE
[13:17:27.765] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.765]  length: 1 (resolved future 1)
[13:17:27.793] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.793] - Validating connection of MultisessionFuture
[13:17:27.794] - received message: FutureResult
[13:17:27.794] - Received FutureResult
[13:17:27.794] - Erased future from FutureRegistry
[13:17:27.794] result() for ClusterFuture ...
[13:17:27.794] - result already collected: FutureResult
[13:17:27.794] result() for ClusterFuture ... done
[13:17:27.794] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.794] Future #2
[13:17:27.795] result() for ClusterFuture ...
[13:17:27.795] - result already collected: FutureResult
[13:17:27.795] result() for ClusterFuture ... done
[13:17:27.795] result() for ClusterFuture ...
[13:17:27.795] - result already collected: FutureResult
[13:17:27.795] result() for ClusterFuture ... done
[13:17:27.795] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.795] - nx: 2
[13:17:27.795] - relay: TRUE
[13:17:27.795] - stdout: TRUE
[13:17:27.796] - signal: TRUE
[13:17:27.796] - resignal: FALSE
[13:17:27.796] - force: TRUE
[13:17:27.796] - relayed: [n=2] TRUE, FALSE
[13:17:27.796] - queued futures: [n=2] TRUE, FALSE
[13:17:27.796]  - until=2
[13:17:27.796]  - relaying element #2
[13:17:27.796] result() for ClusterFuture ...
[13:17:27.796] - result already collected: FutureResult
[13:17:27.796] result() for ClusterFuture ... done
[13:17:27.796] result() for ClusterFuture ...
[13:17:27.797] - result already collected: FutureResult
[13:17:27.797] result() for ClusterFuture ... done
[13:17:27.797] result() for ClusterFuture ...
[13:17:27.797] - result already collected: FutureResult
[13:17:27.797] result() for ClusterFuture ... done
[13:17:27.797] result() for ClusterFuture ...
[13:17:27.797] - result already collected: FutureResult
[13:17:27.797] result() for ClusterFuture ... done
[13:17:27.797] - relayed: [n=2] TRUE, TRUE
[13:17:27.797] - queued futures: [n=2] TRUE, TRUE
[13:17:27.798] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.798]  length: 0 (resolved future 2)
[13:17:27.798] Relaying remaining futures
[13:17:27.798] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.798] - nx: 2
[13:17:27.798] - relay: TRUE
[13:17:27.798] - stdout: TRUE
[13:17:27.798] - signal: TRUE
[13:17:27.798] - resignal: FALSE
[13:17:27.798] - force: TRUE
[13:17:27.798] - relayed: [n=2] TRUE, TRUE
[13:17:27.798] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.799] - relayed: [n=2] TRUE, TRUE
[13:17:27.799] - queued futures: [n=2] TRUE, TRUE
[13:17:27.799] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.799] resolve() on list ... DONE
[13:17:27.799] result() for ClusterFuture ...
[13:17:27.799] - result already collected: FutureResult
[13:17:27.799] result() for ClusterFuture ... done
[13:17:27.799] result() for ClusterFuture ...
[13:17:27.799] - result already collected: FutureResult
[13:17:27.799] result() for ClusterFuture ... done
[13:17:27.800] result() for ClusterFuture ...
[13:17:27.800] - result already collected: FutureResult
[13:17:27.800] result() for ClusterFuture ... done
[13:17:27.800] result() for ClusterFuture ...
[13:17:27.800] - result already collected: FutureResult
[13:17:27.800] result() for ClusterFuture ... done
[13:17:27.800]  - Number of value chunks collected: 2
[13:17:27.800] Resolving 2 futures (chunks) ... DONE
[13:17:27.800] Reducing values from 2 chunks ...
[13:17:27.800]  - Number of values collected after concatenation: 2
[13:17:27.800]  - Number of values expected: 2
[13:17:27.801] Reducing values from 2 chunks ... DONE
[13:17:27.801] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[13:17:27.801] getGlobalsAndPackagesXApply() ...
[13:17:27.801]  - future.globals: TRUE
[13:17:27.801] getGlobalsAndPackages() ...
[13:17:27.801] Searching for globals...
[13:17:27.804] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[13:17:27.804] Searching for globals ... DONE
[13:17:27.804] Resolving globals: FALSE
[13:17:27.804] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[13:17:27.805] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[13:17:27.805] - globals: [1] ‘FUN’
[13:17:27.805] 
[13:17:27.805] getGlobalsAndPackages() ... DONE
[13:17:27.805]  - globals found/used: [n=1] ‘FUN’
[13:17:27.805]  - needed namespaces: [n=0] 
[13:17:27.806] Finding globals ... DONE
[13:17:27.806]  - use_args: TRUE
[13:17:27.806]  - Getting '...' globals ...
[13:17:27.806] resolve() on list ...
[13:17:27.806]  recursive: 0
[13:17:27.806]  length: 1
[13:17:27.806]  elements: ‘...’
[13:17:27.806]  length: 0 (resolved future 1)
[13:17:27.807] resolve() on list ... DONE
[13:17:27.807]    - '...' content: [n=0] 
[13:17:27.807] List of 1
[13:17:27.807]  $ ...: list()
[13:17:27.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.807]  - attr(*, "where")=List of 1
[13:17:27.807]   ..$ ...:<environment: 0x5647bc2da408> 
[13:17:27.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.807]  - attr(*, "resolved")= logi TRUE
[13:17:27.807]  - attr(*, "total_size")= num NA
[13:17:27.809]  - Getting '...' globals ... DONE
[13:17:27.809] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.810] List of 2
[13:17:27.810]  $ ...future.FUN:function (x)  
[13:17:27.810]  $ ...          : list()
[13:17:27.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.810]  - attr(*, "where")=List of 2
[13:17:27.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.810]   ..$ ...          :<environment: 0x5647bc2da408> 
[13:17:27.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.810]  - attr(*, "resolved")= logi FALSE
[13:17:27.810]  - attr(*, "total_size")= num 9888
[13:17:27.812] Packages to be attached in all futures: [n=0] 
[13:17:27.812] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.815] future_lapply() ...
[13:17:27.820] Number of chunks: 2
[13:17:27.820] getGlobalsAndPackagesXApply() ...
[13:17:27.820]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.820]  - use_args: TRUE
[13:17:27.820] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.821] List of 2
[13:17:27.821]  $ ...          : list()
[13:17:27.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.821]  $ ...future.FUN:function (x)  
[13:17:27.821]  - attr(*, "where")=List of 2
[13:17:27.821]   ..$ ...          :<environment: 0x5647bc2da408> 
[13:17:27.821]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[13:17:27.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.821]  - attr(*, "resolved")= logi FALSE
[13:17:27.821]  - attr(*, "total_size")= num NA
[13:17:27.823] Packages to be attached in all futures: [n=0] 
[13:17:27.823] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.824] Number of futures (= number of chunks): 2
[13:17:27.824] Launching 2 futures (chunks) ...
[13:17:27.824] Chunk #1 of 2 ...
[13:17:27.824]  - seeds: <none>
[13:17:27.824] getGlobalsAndPackages() ...
[13:17:27.824] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.824] Resolving globals: FALSE
[13:17:27.824] Tweak future expression to call with '...' arguments ...
[13:17:27.824] {
[13:17:27.824]     do.call(function(...) {
[13:17:27.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.824]             on.exit(options(oopts), add = TRUE)
[13:17:27.824]         }
[13:17:27.824]         {
[13:17:27.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.824]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.824]             })
[13:17:27.824]         }
[13:17:27.824]     }, args = future.call.arguments)
[13:17:27.824] }
[13:17:27.825] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.825] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.825] 
[13:17:27.825] getGlobalsAndPackages() ... DONE
[13:17:27.826] run() for ‘Future’ ...
[13:17:27.826] - state: ‘created’
[13:17:27.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.840]   - Field: ‘node’
[13:17:27.840]   - Field: ‘label’
[13:17:27.840]   - Field: ‘local’
[13:17:27.841]   - Field: ‘owner’
[13:17:27.841]   - Field: ‘envir’
[13:17:27.841]   - Field: ‘workers’
[13:17:27.841]   - Field: ‘packages’
[13:17:27.841]   - Field: ‘gc’
[13:17:27.841]   - Field: ‘conditions’
[13:17:27.841]   - Field: ‘persistent’
[13:17:27.841]   - Field: ‘expr’
[13:17:27.841]   - Field: ‘uuid’
[13:17:27.841]   - Field: ‘seed’
[13:17:27.842]   - Field: ‘version’
[13:17:27.842]   - Field: ‘result’
[13:17:27.842]   - Field: ‘asynchronous’
[13:17:27.842]   - Field: ‘calls’
[13:17:27.842]   - Field: ‘globals’
[13:17:27.842]   - Field: ‘stdout’
[13:17:27.842]   - Field: ‘earlySignal’
[13:17:27.842]   - Field: ‘lazy’
[13:17:27.842]   - Field: ‘state’
[13:17:27.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.842] - Launch lazy future ...
[13:17:27.843] Packages needed by the future expression (n = 0): <none>
[13:17:27.843] Packages needed by future strategies (n = 0): <none>
[13:17:27.843] {
[13:17:27.843]     {
[13:17:27.843]         {
[13:17:27.843]             ...future.startTime <- base::Sys.time()
[13:17:27.843]             {
[13:17:27.843]                 {
[13:17:27.843]                   {
[13:17:27.843]                     {
[13:17:27.843]                       base::local({
[13:17:27.843]                         has_future <- base::requireNamespace("future", 
[13:17:27.843]                           quietly = TRUE)
[13:17:27.843]                         if (has_future) {
[13:17:27.843]                           ns <- base::getNamespace("future")
[13:17:27.843]                           version <- ns[[".package"]][["version"]]
[13:17:27.843]                           if (is.null(version)) 
[13:17:27.843]                             version <- utils::packageVersion("future")
[13:17:27.843]                         }
[13:17:27.843]                         else {
[13:17:27.843]                           version <- NULL
[13:17:27.843]                         }
[13:17:27.843]                         if (!has_future || version < "1.8.0") {
[13:17:27.843]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.843]                             "", base::R.version$version.string), 
[13:17:27.843]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.843]                               "release", "version")], collapse = " "), 
[13:17:27.843]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.843]                             info)
[13:17:27.843]                           info <- base::paste(info, collapse = "; ")
[13:17:27.843]                           if (!has_future) {
[13:17:27.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.843]                               info)
[13:17:27.843]                           }
[13:17:27.843]                           else {
[13:17:27.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.843]                               info, version)
[13:17:27.843]                           }
[13:17:27.843]                           base::stop(msg)
[13:17:27.843]                         }
[13:17:27.843]                       })
[13:17:27.843]                     }
[13:17:27.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.843]                     base::options(mc.cores = 1L)
[13:17:27.843]                   }
[13:17:27.843]                   options(future.plan = NULL)
[13:17:27.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.843]                 }
[13:17:27.843]                 ...future.workdir <- getwd()
[13:17:27.843]             }
[13:17:27.843]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.843]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.843]         }
[13:17:27.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.843]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.843]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.843]             base::names(...future.oldOptions))
[13:17:27.843]     }
[13:17:27.843]     if (FALSE) {
[13:17:27.843]     }
[13:17:27.843]     else {
[13:17:27.843]         if (TRUE) {
[13:17:27.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.843]                 open = "w")
[13:17:27.843]         }
[13:17:27.843]         else {
[13:17:27.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.843]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.843]         }
[13:17:27.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.843]             base::sink(type = "output", split = FALSE)
[13:17:27.843]             base::close(...future.stdout)
[13:17:27.843]         }, add = TRUE)
[13:17:27.843]     }
[13:17:27.843]     ...future.frame <- base::sys.nframe()
[13:17:27.843]     ...future.conditions <- base::list()
[13:17:27.843]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.843]     if (FALSE) {
[13:17:27.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.843]     }
[13:17:27.843]     ...future.result <- base::tryCatch({
[13:17:27.843]         base::withCallingHandlers({
[13:17:27.843]             ...future.value <- base::withVisible(base::local({
[13:17:27.843]                 ...future.makeSendCondition <- local({
[13:17:27.843]                   sendCondition <- NULL
[13:17:27.843]                   function(frame = 1L) {
[13:17:27.843]                     if (is.function(sendCondition)) 
[13:17:27.843]                       return(sendCondition)
[13:17:27.843]                     ns <- getNamespace("parallel")
[13:17:27.843]                     if (exists("sendData", mode = "function", 
[13:17:27.843]                       envir = ns)) {
[13:17:27.843]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.843]                         envir = ns)
[13:17:27.843]                       envir <- sys.frame(frame)
[13:17:27.843]                       master <- NULL
[13:17:27.843]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.843]                         !identical(envir, emptyenv())) {
[13:17:27.843]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.843]                           inherits = FALSE)) {
[13:17:27.843]                           master <- get("master", mode = "list", 
[13:17:27.843]                             envir = envir, inherits = FALSE)
[13:17:27.843]                           if (inherits(master, c("SOCKnode", 
[13:17:27.843]                             "SOCK0node"))) {
[13:17:27.843]                             sendCondition <<- function(cond) {
[13:17:27.843]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.843]                                 success = TRUE)
[13:17:27.843]                               parallel_sendData(master, data)
[13:17:27.843]                             }
[13:17:27.843]                             return(sendCondition)
[13:17:27.843]                           }
[13:17:27.843]                         }
[13:17:27.843]                         frame <- frame + 1L
[13:17:27.843]                         envir <- sys.frame(frame)
[13:17:27.843]                       }
[13:17:27.843]                     }
[13:17:27.843]                     sendCondition <<- function(cond) NULL
[13:17:27.843]                   }
[13:17:27.843]                 })
[13:17:27.843]                 withCallingHandlers({
[13:17:27.843]                   {
[13:17:27.843]                     do.call(function(...) {
[13:17:27.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.843]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.843]                         ...future.globals.maxSize)) {
[13:17:27.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.843]                         on.exit(options(oopts), add = TRUE)
[13:17:27.843]                       }
[13:17:27.843]                       {
[13:17:27.843]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.843]                           FUN = function(jj) {
[13:17:27.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.843]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.843]                           })
[13:17:27.843]                       }
[13:17:27.843]                     }, args = future.call.arguments)
[13:17:27.843]                   }
[13:17:27.843]                 }, immediateCondition = function(cond) {
[13:17:27.843]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.843]                   sendCondition(cond)
[13:17:27.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.843]                   {
[13:17:27.843]                     inherits <- base::inherits
[13:17:27.843]                     invokeRestart <- base::invokeRestart
[13:17:27.843]                     is.null <- base::is.null
[13:17:27.843]                     muffled <- FALSE
[13:17:27.843]                     if (inherits(cond, "message")) {
[13:17:27.843]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.843]                       if (muffled) 
[13:17:27.843]                         invokeRestart("muffleMessage")
[13:17:27.843]                     }
[13:17:27.843]                     else if (inherits(cond, "warning")) {
[13:17:27.843]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.843]                       if (muffled) 
[13:17:27.843]                         invokeRestart("muffleWarning")
[13:17:27.843]                     }
[13:17:27.843]                     else if (inherits(cond, "condition")) {
[13:17:27.843]                       if (!is.null(pattern)) {
[13:17:27.843]                         computeRestarts <- base::computeRestarts
[13:17:27.843]                         grepl <- base::grepl
[13:17:27.843]                         restarts <- computeRestarts(cond)
[13:17:27.843]                         for (restart in restarts) {
[13:17:27.843]                           name <- restart$name
[13:17:27.843]                           if (is.null(name)) 
[13:17:27.843]                             next
[13:17:27.843]                           if (!grepl(pattern, name)) 
[13:17:27.843]                             next
[13:17:27.843]                           invokeRestart(restart)
[13:17:27.843]                           muffled <- TRUE
[13:17:27.843]                           break
[13:17:27.843]                         }
[13:17:27.843]                       }
[13:17:27.843]                     }
[13:17:27.843]                     invisible(muffled)
[13:17:27.843]                   }
[13:17:27.843]                   muffleCondition(cond)
[13:17:27.843]                 })
[13:17:27.843]             }))
[13:17:27.843]             future::FutureResult(value = ...future.value$value, 
[13:17:27.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.843]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.843]                     ...future.globalenv.names))
[13:17:27.843]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.843]         }, condition = base::local({
[13:17:27.843]             c <- base::c
[13:17:27.843]             inherits <- base::inherits
[13:17:27.843]             invokeRestart <- base::invokeRestart
[13:17:27.843]             length <- base::length
[13:17:27.843]             list <- base::list
[13:17:27.843]             seq.int <- base::seq.int
[13:17:27.843]             signalCondition <- base::signalCondition
[13:17:27.843]             sys.calls <- base::sys.calls
[13:17:27.843]             `[[` <- base::`[[`
[13:17:27.843]             `+` <- base::`+`
[13:17:27.843]             `<<-` <- base::`<<-`
[13:17:27.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.843]                   3L)]
[13:17:27.843]             }
[13:17:27.843]             function(cond) {
[13:17:27.843]                 is_error <- inherits(cond, "error")
[13:17:27.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.843]                   NULL)
[13:17:27.843]                 if (is_error) {
[13:17:27.843]                   sessionInformation <- function() {
[13:17:27.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.843]                       search = base::search(), system = base::Sys.info())
[13:17:27.843]                   }
[13:17:27.843]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.843]                     cond$call), session = sessionInformation(), 
[13:17:27.843]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.843]                   signalCondition(cond)
[13:17:27.843]                 }
[13:17:27.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.843]                 "immediateCondition"))) {
[13:17:27.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.843]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.843]                   if (TRUE && !signal) {
[13:17:27.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.843]                     {
[13:17:27.843]                       inherits <- base::inherits
[13:17:27.843]                       invokeRestart <- base::invokeRestart
[13:17:27.843]                       is.null <- base::is.null
[13:17:27.843]                       muffled <- FALSE
[13:17:27.843]                       if (inherits(cond, "message")) {
[13:17:27.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.843]                         if (muffled) 
[13:17:27.843]                           invokeRestart("muffleMessage")
[13:17:27.843]                       }
[13:17:27.843]                       else if (inherits(cond, "warning")) {
[13:17:27.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.843]                         if (muffled) 
[13:17:27.843]                           invokeRestart("muffleWarning")
[13:17:27.843]                       }
[13:17:27.843]                       else if (inherits(cond, "condition")) {
[13:17:27.843]                         if (!is.null(pattern)) {
[13:17:27.843]                           computeRestarts <- base::computeRestarts
[13:17:27.843]                           grepl <- base::grepl
[13:17:27.843]                           restarts <- computeRestarts(cond)
[13:17:27.843]                           for (restart in restarts) {
[13:17:27.843]                             name <- restart$name
[13:17:27.843]                             if (is.null(name)) 
[13:17:27.843]                               next
[13:17:27.843]                             if (!grepl(pattern, name)) 
[13:17:27.843]                               next
[13:17:27.843]                             invokeRestart(restart)
[13:17:27.843]                             muffled <- TRUE
[13:17:27.843]                             break
[13:17:27.843]                           }
[13:17:27.843]                         }
[13:17:27.843]                       }
[13:17:27.843]                       invisible(muffled)
[13:17:27.843]                     }
[13:17:27.843]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.843]                   }
[13:17:27.843]                 }
[13:17:27.843]                 else {
[13:17:27.843]                   if (TRUE) {
[13:17:27.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.843]                     {
[13:17:27.843]                       inherits <- base::inherits
[13:17:27.843]                       invokeRestart <- base::invokeRestart
[13:17:27.843]                       is.null <- base::is.null
[13:17:27.843]                       muffled <- FALSE
[13:17:27.843]                       if (inherits(cond, "message")) {
[13:17:27.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.843]                         if (muffled) 
[13:17:27.843]                           invokeRestart("muffleMessage")
[13:17:27.843]                       }
[13:17:27.843]                       else if (inherits(cond, "warning")) {
[13:17:27.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.843]                         if (muffled) 
[13:17:27.843]                           invokeRestart("muffleWarning")
[13:17:27.843]                       }
[13:17:27.843]                       else if (inherits(cond, "condition")) {
[13:17:27.843]                         if (!is.null(pattern)) {
[13:17:27.843]                           computeRestarts <- base::computeRestarts
[13:17:27.843]                           grepl <- base::grepl
[13:17:27.843]                           restarts <- computeRestarts(cond)
[13:17:27.843]                           for (restart in restarts) {
[13:17:27.843]                             name <- restart$name
[13:17:27.843]                             if (is.null(name)) 
[13:17:27.843]                               next
[13:17:27.843]                             if (!grepl(pattern, name)) 
[13:17:27.843]                               next
[13:17:27.843]                             invokeRestart(restart)
[13:17:27.843]                             muffled <- TRUE
[13:17:27.843]                             break
[13:17:27.843]                           }
[13:17:27.843]                         }
[13:17:27.843]                       }
[13:17:27.843]                       invisible(muffled)
[13:17:27.843]                     }
[13:17:27.843]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.843]                   }
[13:17:27.843]                 }
[13:17:27.843]             }
[13:17:27.843]         }))
[13:17:27.843]     }, error = function(ex) {
[13:17:27.843]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.843]                 ...future.rng), started = ...future.startTime, 
[13:17:27.843]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.843]             version = "1.8"), class = "FutureResult")
[13:17:27.843]     }, finally = {
[13:17:27.843]         if (!identical(...future.workdir, getwd())) 
[13:17:27.843]             setwd(...future.workdir)
[13:17:27.843]         {
[13:17:27.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.843]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.843]             }
[13:17:27.843]             base::options(...future.oldOptions)
[13:17:27.843]             if (.Platform$OS.type == "windows") {
[13:17:27.843]                 old_names <- names(...future.oldEnvVars)
[13:17:27.843]                 envs <- base::Sys.getenv()
[13:17:27.843]                 names <- names(envs)
[13:17:27.843]                 common <- intersect(names, old_names)
[13:17:27.843]                 added <- setdiff(names, old_names)
[13:17:27.843]                 removed <- setdiff(old_names, names)
[13:17:27.843]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.843]                   envs[common]]
[13:17:27.843]                 NAMES <- toupper(changed)
[13:17:27.843]                 args <- list()
[13:17:27.843]                 for (kk in seq_along(NAMES)) {
[13:17:27.843]                   name <- changed[[kk]]
[13:17:27.843]                   NAME <- NAMES[[kk]]
[13:17:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.843]                     next
[13:17:27.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.843]                 }
[13:17:27.843]                 NAMES <- toupper(added)
[13:17:27.843]                 for (kk in seq_along(NAMES)) {
[13:17:27.843]                   name <- added[[kk]]
[13:17:27.843]                   NAME <- NAMES[[kk]]
[13:17:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.843]                     next
[13:17:27.843]                   args[[name]] <- ""
[13:17:27.843]                 }
[13:17:27.843]                 NAMES <- toupper(removed)
[13:17:27.843]                 for (kk in seq_along(NAMES)) {
[13:17:27.843]                   name <- removed[[kk]]
[13:17:27.843]                   NAME <- NAMES[[kk]]
[13:17:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.843]                     next
[13:17:27.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.843]                 }
[13:17:27.843]                 if (length(args) > 0) 
[13:17:27.843]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.843]             }
[13:17:27.843]             else {
[13:17:27.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.843]             }
[13:17:27.843]             {
[13:17:27.843]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.843]                   0L) {
[13:17:27.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.843]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.843]                   base::options(opts)
[13:17:27.843]                 }
[13:17:27.843]                 {
[13:17:27.843]                   {
[13:17:27.843]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.843]                     NULL
[13:17:27.843]                   }
[13:17:27.843]                   options(future.plan = NULL)
[13:17:27.843]                   if (is.na(NA_character_)) 
[13:17:27.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.843]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.843]                     envir = parent.frame()) 
[13:17:27.843]                   {
[13:17:27.843]                     if (is.function(workers)) 
[13:17:27.843]                       workers <- workers()
[13:17:27.843]                     workers <- structure(as.integer(workers), 
[13:17:27.843]                       class = class(workers))
[13:17:27.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.843]                       workers >= 1)
[13:17:27.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.843]                     }
[13:17:27.843]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.843]                       envir = envir)
[13:17:27.843]                     if (!future$lazy) 
[13:17:27.843]                       future <- run(future)
[13:17:27.843]                     invisible(future)
[13:17:27.843]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.843]                 }
[13:17:27.843]             }
[13:17:27.843]         }
[13:17:27.843]     })
[13:17:27.843]     if (TRUE) {
[13:17:27.843]         base::sink(type = "output", split = FALSE)
[13:17:27.843]         if (TRUE) {
[13:17:27.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.843]         }
[13:17:27.843]         else {
[13:17:27.843]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.843]         }
[13:17:27.843]         base::close(...future.stdout)
[13:17:27.843]         ...future.stdout <- NULL
[13:17:27.843]     }
[13:17:27.843]     ...future.result$conditions <- ...future.conditions
[13:17:27.843]     ...future.result$finished <- base::Sys.time()
[13:17:27.843]     ...future.result
[13:17:27.843] }
[13:17:27.846] Exporting 5 global objects (9.71 KiB) to cluster node #1 ...
[13:17:27.847] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.847] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.847] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[13:17:27.848] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[13:17:27.848] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:17:27.848] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:17:27.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:17:27.849] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.849] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:27.849] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.849] Exporting 5 global objects (9.71 KiB) to cluster node #1 ... DONE
[13:17:27.850] MultisessionFuture started
[13:17:27.850] - Launch lazy future ... done
[13:17:27.850] run() for ‘MultisessionFuture’ ... done
[13:17:27.850] Created future:
[13:17:27.850] MultisessionFuture:
[13:17:27.850] Label: ‘future_apply-1’
[13:17:27.850] Expression:
[13:17:27.850] {
[13:17:27.850]     do.call(function(...) {
[13:17:27.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.850]             on.exit(options(oopts), add = TRUE)
[13:17:27.850]         }
[13:17:27.850]         {
[13:17:27.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.850]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.850]             })
[13:17:27.850]         }
[13:17:27.850]     }, args = future.call.arguments)
[13:17:27.850] }
[13:17:27.850] Lazy evaluation: FALSE
[13:17:27.850] Asynchronous evaluation: TRUE
[13:17:27.850] Local evaluation: TRUE
[13:17:27.850] Environment: R_GlobalEnv
[13:17:27.850] Capture standard output: TRUE
[13:17:27.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.850] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.850] Packages: <none>
[13:17:27.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.850] Resolved: FALSE
[13:17:27.850] Value: <not collected>
[13:17:27.850] Conditions captured: <none>
[13:17:27.850] Early signaling: FALSE
[13:17:27.850] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.850] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.862] Chunk #1 of 2 ... DONE
[13:17:27.862] Chunk #2 of 2 ...
[13:17:27.862]  - seeds: <none>
[13:17:27.862] getGlobalsAndPackages() ...
[13:17:27.862] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.862] Resolving globals: FALSE
[13:17:27.863] Tweak future expression to call with '...' arguments ...
[13:17:27.863] {
[13:17:27.863]     do.call(function(...) {
[13:17:27.863]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.863]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.863]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.863]             on.exit(options(oopts), add = TRUE)
[13:17:27.863]         }
[13:17:27.863]         {
[13:17:27.863]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.863]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.863]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.863]             })
[13:17:27.863]         }
[13:17:27.863]     }, args = future.call.arguments)
[13:17:27.863] }
[13:17:27.863] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.863] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.863] 
[13:17:27.863] getGlobalsAndPackages() ... DONE
[13:17:27.866] run() for ‘Future’ ...
[13:17:27.866] - state: ‘created’
[13:17:27.866] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.881] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.881]   - Field: ‘node’
[13:17:27.881]   - Field: ‘label’
[13:17:27.882]   - Field: ‘local’
[13:17:27.882]   - Field: ‘owner’
[13:17:27.882]   - Field: ‘envir’
[13:17:27.882]   - Field: ‘workers’
[13:17:27.882]   - Field: ‘packages’
[13:17:27.882]   - Field: ‘gc’
[13:17:27.882]   - Field: ‘conditions’
[13:17:27.882]   - Field: ‘persistent’
[13:17:27.882]   - Field: ‘expr’
[13:17:27.882]   - Field: ‘uuid’
[13:17:27.882]   - Field: ‘seed’
[13:17:27.883]   - Field: ‘version’
[13:17:27.883]   - Field: ‘result’
[13:17:27.883]   - Field: ‘asynchronous’
[13:17:27.883]   - Field: ‘calls’
[13:17:27.883]   - Field: ‘globals’
[13:17:27.883]   - Field: ‘stdout’
[13:17:27.883]   - Field: ‘earlySignal’
[13:17:27.883]   - Field: ‘lazy’
[13:17:27.883]   - Field: ‘state’
[13:17:27.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.883] - Launch lazy future ...
[13:17:27.884] Packages needed by the future expression (n = 0): <none>
[13:17:27.884] Packages needed by future strategies (n = 0): <none>
[13:17:27.884] {
[13:17:27.884]     {
[13:17:27.884]         {
[13:17:27.884]             ...future.startTime <- base::Sys.time()
[13:17:27.884]             {
[13:17:27.884]                 {
[13:17:27.884]                   {
[13:17:27.884]                     {
[13:17:27.884]                       base::local({
[13:17:27.884]                         has_future <- base::requireNamespace("future", 
[13:17:27.884]                           quietly = TRUE)
[13:17:27.884]                         if (has_future) {
[13:17:27.884]                           ns <- base::getNamespace("future")
[13:17:27.884]                           version <- ns[[".package"]][["version"]]
[13:17:27.884]                           if (is.null(version)) 
[13:17:27.884]                             version <- utils::packageVersion("future")
[13:17:27.884]                         }
[13:17:27.884]                         else {
[13:17:27.884]                           version <- NULL
[13:17:27.884]                         }
[13:17:27.884]                         if (!has_future || version < "1.8.0") {
[13:17:27.884]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.884]                             "", base::R.version$version.string), 
[13:17:27.884]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.884]                               "release", "version")], collapse = " "), 
[13:17:27.884]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.884]                             info)
[13:17:27.884]                           info <- base::paste(info, collapse = "; ")
[13:17:27.884]                           if (!has_future) {
[13:17:27.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.884]                               info)
[13:17:27.884]                           }
[13:17:27.884]                           else {
[13:17:27.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.884]                               info, version)
[13:17:27.884]                           }
[13:17:27.884]                           base::stop(msg)
[13:17:27.884]                         }
[13:17:27.884]                       })
[13:17:27.884]                     }
[13:17:27.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.884]                     base::options(mc.cores = 1L)
[13:17:27.884]                   }
[13:17:27.884]                   options(future.plan = NULL)
[13:17:27.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.884]                 }
[13:17:27.884]                 ...future.workdir <- getwd()
[13:17:27.884]             }
[13:17:27.884]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.884]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.884]         }
[13:17:27.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.884]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.884]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.884]             base::names(...future.oldOptions))
[13:17:27.884]     }
[13:17:27.884]     if (FALSE) {
[13:17:27.884]     }
[13:17:27.884]     else {
[13:17:27.884]         if (TRUE) {
[13:17:27.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.884]                 open = "w")
[13:17:27.884]         }
[13:17:27.884]         else {
[13:17:27.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.884]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.884]         }
[13:17:27.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.884]             base::sink(type = "output", split = FALSE)
[13:17:27.884]             base::close(...future.stdout)
[13:17:27.884]         }, add = TRUE)
[13:17:27.884]     }
[13:17:27.884]     ...future.frame <- base::sys.nframe()
[13:17:27.884]     ...future.conditions <- base::list()
[13:17:27.884]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.884]     if (FALSE) {
[13:17:27.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.884]     }
[13:17:27.884]     ...future.result <- base::tryCatch({
[13:17:27.884]         base::withCallingHandlers({
[13:17:27.884]             ...future.value <- base::withVisible(base::local({
[13:17:27.884]                 ...future.makeSendCondition <- local({
[13:17:27.884]                   sendCondition <- NULL
[13:17:27.884]                   function(frame = 1L) {
[13:17:27.884]                     if (is.function(sendCondition)) 
[13:17:27.884]                       return(sendCondition)
[13:17:27.884]                     ns <- getNamespace("parallel")
[13:17:27.884]                     if (exists("sendData", mode = "function", 
[13:17:27.884]                       envir = ns)) {
[13:17:27.884]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.884]                         envir = ns)
[13:17:27.884]                       envir <- sys.frame(frame)
[13:17:27.884]                       master <- NULL
[13:17:27.884]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.884]                         !identical(envir, emptyenv())) {
[13:17:27.884]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.884]                           inherits = FALSE)) {
[13:17:27.884]                           master <- get("master", mode = "list", 
[13:17:27.884]                             envir = envir, inherits = FALSE)
[13:17:27.884]                           if (inherits(master, c("SOCKnode", 
[13:17:27.884]                             "SOCK0node"))) {
[13:17:27.884]                             sendCondition <<- function(cond) {
[13:17:27.884]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.884]                                 success = TRUE)
[13:17:27.884]                               parallel_sendData(master, data)
[13:17:27.884]                             }
[13:17:27.884]                             return(sendCondition)
[13:17:27.884]                           }
[13:17:27.884]                         }
[13:17:27.884]                         frame <- frame + 1L
[13:17:27.884]                         envir <- sys.frame(frame)
[13:17:27.884]                       }
[13:17:27.884]                     }
[13:17:27.884]                     sendCondition <<- function(cond) NULL
[13:17:27.884]                   }
[13:17:27.884]                 })
[13:17:27.884]                 withCallingHandlers({
[13:17:27.884]                   {
[13:17:27.884]                     do.call(function(...) {
[13:17:27.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.884]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.884]                         ...future.globals.maxSize)) {
[13:17:27.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.884]                         on.exit(options(oopts), add = TRUE)
[13:17:27.884]                       }
[13:17:27.884]                       {
[13:17:27.884]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.884]                           FUN = function(jj) {
[13:17:27.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.884]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.884]                           })
[13:17:27.884]                       }
[13:17:27.884]                     }, args = future.call.arguments)
[13:17:27.884]                   }
[13:17:27.884]                 }, immediateCondition = function(cond) {
[13:17:27.884]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.884]                   sendCondition(cond)
[13:17:27.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.884]                   {
[13:17:27.884]                     inherits <- base::inherits
[13:17:27.884]                     invokeRestart <- base::invokeRestart
[13:17:27.884]                     is.null <- base::is.null
[13:17:27.884]                     muffled <- FALSE
[13:17:27.884]                     if (inherits(cond, "message")) {
[13:17:27.884]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.884]                       if (muffled) 
[13:17:27.884]                         invokeRestart("muffleMessage")
[13:17:27.884]                     }
[13:17:27.884]                     else if (inherits(cond, "warning")) {
[13:17:27.884]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.884]                       if (muffled) 
[13:17:27.884]                         invokeRestart("muffleWarning")
[13:17:27.884]                     }
[13:17:27.884]                     else if (inherits(cond, "condition")) {
[13:17:27.884]                       if (!is.null(pattern)) {
[13:17:27.884]                         computeRestarts <- base::computeRestarts
[13:17:27.884]                         grepl <- base::grepl
[13:17:27.884]                         restarts <- computeRestarts(cond)
[13:17:27.884]                         for (restart in restarts) {
[13:17:27.884]                           name <- restart$name
[13:17:27.884]                           if (is.null(name)) 
[13:17:27.884]                             next
[13:17:27.884]                           if (!grepl(pattern, name)) 
[13:17:27.884]                             next
[13:17:27.884]                           invokeRestart(restart)
[13:17:27.884]                           muffled <- TRUE
[13:17:27.884]                           break
[13:17:27.884]                         }
[13:17:27.884]                       }
[13:17:27.884]                     }
[13:17:27.884]                     invisible(muffled)
[13:17:27.884]                   }
[13:17:27.884]                   muffleCondition(cond)
[13:17:27.884]                 })
[13:17:27.884]             }))
[13:17:27.884]             future::FutureResult(value = ...future.value$value, 
[13:17:27.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.884]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.884]                     ...future.globalenv.names))
[13:17:27.884]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.884]         }, condition = base::local({
[13:17:27.884]             c <- base::c
[13:17:27.884]             inherits <- base::inherits
[13:17:27.884]             invokeRestart <- base::invokeRestart
[13:17:27.884]             length <- base::length
[13:17:27.884]             list <- base::list
[13:17:27.884]             seq.int <- base::seq.int
[13:17:27.884]             signalCondition <- base::signalCondition
[13:17:27.884]             sys.calls <- base::sys.calls
[13:17:27.884]             `[[` <- base::`[[`
[13:17:27.884]             `+` <- base::`+`
[13:17:27.884]             `<<-` <- base::`<<-`
[13:17:27.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.884]                   3L)]
[13:17:27.884]             }
[13:17:27.884]             function(cond) {
[13:17:27.884]                 is_error <- inherits(cond, "error")
[13:17:27.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.884]                   NULL)
[13:17:27.884]                 if (is_error) {
[13:17:27.884]                   sessionInformation <- function() {
[13:17:27.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.884]                       search = base::search(), system = base::Sys.info())
[13:17:27.884]                   }
[13:17:27.884]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.884]                     cond$call), session = sessionInformation(), 
[13:17:27.884]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.884]                   signalCondition(cond)
[13:17:27.884]                 }
[13:17:27.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:17:27.884]                 "immediateCondition"))) {
[13:17:27.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.884]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.884]                   if (TRUE && !signal) {
[13:17:27.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.884]                     {
[13:17:27.884]                       inherits <- base::inherits
[13:17:27.884]                       invokeRestart <- base::invokeRestart
[13:17:27.884]                       is.null <- base::is.null
[13:17:27.884]                       muffled <- FALSE
[13:17:27.884]                       if (inherits(cond, "message")) {
[13:17:27.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.884]                         if (muffled) 
[13:17:27.884]                           invokeRestart("muffleMessage")
[13:17:27.884]                       }
[13:17:27.884]                       else if (inherits(cond, "warning")) {
[13:17:27.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.884]                         if (muffled) 
[13:17:27.884]                           invokeRestart("muffleWarning")
[13:17:27.884]                       }
[13:17:27.884]                       else if (inherits(cond, "condition")) {
[13:17:27.884]                         if (!is.null(pattern)) {
[13:17:27.884]                           computeRestarts <- base::computeRestarts
[13:17:27.884]                           grepl <- base::grepl
[13:17:27.884]                           restarts <- computeRestarts(cond)
[13:17:27.884]                           for (restart in restarts) {
[13:17:27.884]                             name <- restart$name
[13:17:27.884]                             if (is.null(name)) 
[13:17:27.884]                               next
[13:17:27.884]                             if (!grepl(pattern, name)) 
[13:17:27.884]                               next
[13:17:27.884]                             invokeRestart(restart)
[13:17:27.884]                             muffled <- TRUE
[13:17:27.884]                             break
[13:17:27.884]                           }
[13:17:27.884]                         }
[13:17:27.884]                       }
[13:17:27.884]                       invisible(muffled)
[13:17:27.884]                     }
[13:17:27.884]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.884]                   }
[13:17:27.884]                 }
[13:17:27.884]                 else {
[13:17:27.884]                   if (TRUE) {
[13:17:27.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.884]                     {
[13:17:27.884]                       inherits <- base::inherits
[13:17:27.884]                       invokeRestart <- base::invokeRestart
[13:17:27.884]                       is.null <- base::is.null
[13:17:27.884]                       muffled <- FALSE
[13:17:27.884]                       if (inherits(cond, "message")) {
[13:17:27.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.884]                         if (muffled) 
[13:17:27.884]                           invokeRestart("muffleMessage")
[13:17:27.884]                       }
[13:17:27.884]                       else if (inherits(cond, "warning")) {
[13:17:27.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.884]                         if (muffled) 
[13:17:27.884]                           invokeRestart("muffleWarning")
[13:17:27.884]                       }
[13:17:27.884]                       else if (inherits(cond, "condition")) {
[13:17:27.884]                         if (!is.null(pattern)) {
[13:17:27.884]                           computeRestarts <- base::computeRestarts
[13:17:27.884]                           grepl <- base::grepl
[13:17:27.884]                           restarts <- computeRestarts(cond)
[13:17:27.884]                           for (restart in restarts) {
[13:17:27.884]                             name <- restart$name
[13:17:27.884]                             if (is.null(name)) 
[13:17:27.884]                               next
[13:17:27.884]                             if (!grepl(pattern, name)) 
[13:17:27.884]                               next
[13:17:27.884]                             invokeRestart(restart)
[13:17:27.884]                             muffled <- TRUE
[13:17:27.884]                             break
[13:17:27.884]                           }
[13:17:27.884]                         }
[13:17:27.884]                       }
[13:17:27.884]                       invisible(muffled)
[13:17:27.884]                     }
[13:17:27.884]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.884]                   }
[13:17:27.884]                 }
[13:17:27.884]             }
[13:17:27.884]         }))
[13:17:27.884]     }, error = function(ex) {
[13:17:27.884]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.884]                 ...future.rng), started = ...future.startTime, 
[13:17:27.884]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.884]             version = "1.8"), class = "FutureResult")
[13:17:27.884]     }, finally = {
[13:17:27.884]         if (!identical(...future.workdir, getwd())) 
[13:17:27.884]             setwd(...future.workdir)
[13:17:27.884]         {
[13:17:27.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.884]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.884]             }
[13:17:27.884]             base::options(...future.oldOptions)
[13:17:27.884]             if (.Platform$OS.type == "windows") {
[13:17:27.884]                 old_names <- names(...future.oldEnvVars)
[13:17:27.884]                 envs <- base::Sys.getenv()
[13:17:27.884]                 names <- names(envs)
[13:17:27.884]                 common <- intersect(names, old_names)
[13:17:27.884]                 added <- setdiff(names, old_names)
[13:17:27.884]                 removed <- setdiff(old_names, names)
[13:17:27.884]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.884]                   envs[common]]
[13:17:27.884]                 NAMES <- toupper(changed)
[13:17:27.884]                 args <- list()
[13:17:27.884]                 for (kk in seq_along(NAMES)) {
[13:17:27.884]                   name <- changed[[kk]]
[13:17:27.884]                   NAME <- NAMES[[kk]]
[13:17:27.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.884]                     next
[13:17:27.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.884]                 }
[13:17:27.884]                 NAMES <- toupper(added)
[13:17:27.884]                 for (kk in seq_along(NAMES)) {
[13:17:27.884]                   name <- added[[kk]]
[13:17:27.884]                   NAME <- NAMES[[kk]]
[13:17:27.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.884]                     next
[13:17:27.884]                   args[[name]] <- ""
[13:17:27.884]                 }
[13:17:27.884]                 NAMES <- toupper(removed)
[13:17:27.884]                 for (kk in seq_along(NAMES)) {
[13:17:27.884]                   name <- removed[[kk]]
[13:17:27.884]                   NAME <- NAMES[[kk]]
[13:17:27.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.884]                     next
[13:17:27.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.884]                 }
[13:17:27.884]                 if (length(args) > 0) 
[13:17:27.884]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.884]             }
[13:17:27.884]             else {
[13:17:27.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.884]             }
[13:17:27.884]             {
[13:17:27.884]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.884]                   0L) {
[13:17:27.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.884]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.884]                   base::options(opts)
[13:17:27.884]                 }
[13:17:27.884]                 {
[13:17:27.884]                   {
[13:17:27.884]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.884]                     NULL
[13:17:27.884]                   }
[13:17:27.884]                   options(future.plan = NULL)
[13:17:27.884]                   if (is.na(NA_character_)) 
[13:17:27.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.884]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.884]                     envir = parent.frame()) 
[13:17:27.884]                   {
[13:17:27.884]                     if (is.function(workers)) 
[13:17:27.884]                       workers <- workers()
[13:17:27.884]                     workers <- structure(as.integer(workers), 
[13:17:27.884]                       class = class(workers))
[13:17:27.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.884]                       workers >= 1)
[13:17:27.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.884]                     }
[13:17:27.884]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.884]                       envir = envir)
[13:17:27.884]                     if (!future$lazy) 
[13:17:27.884]                       future <- run(future)
[13:17:27.884]                     invisible(future)
[13:17:27.884]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.884]                 }
[13:17:27.884]             }
[13:17:27.884]         }
[13:17:27.884]     })
[13:17:27.884]     if (TRUE) {
[13:17:27.884]         base::sink(type = "output", split = FALSE)
[13:17:27.884]         if (TRUE) {
[13:17:27.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.884]         }
[13:17:27.884]         else {
[13:17:27.884]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.884]         }
[13:17:27.884]         base::close(...future.stdout)
[13:17:27.884]         ...future.stdout <- NULL
[13:17:27.884]     }
[13:17:27.884]     ...future.result$conditions <- ...future.conditions
[13:17:27.884]     ...future.result$finished <- base::Sys.time()
[13:17:27.884]     ...future.result
[13:17:27.884] }
[13:17:27.887] Exporting 5 global objects (9.71 KiB) to cluster node #2 ...
[13:17:27.888] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:27.888] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.888] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[13:17:27.888] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[13:17:27.889] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:17:27.889] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:17:27.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:17:27.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.889] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:27.890] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:27.890] Exporting 5 global objects (9.71 KiB) to cluster node #2 ... DONE
[13:17:27.890] MultisessionFuture started
[13:17:27.890] - Launch lazy future ... done
[13:17:27.891] run() for ‘MultisessionFuture’ ... done
[13:17:27.891] Created future:
[13:17:27.891] MultisessionFuture:
[13:17:27.891] Label: ‘future_apply-2’
[13:17:27.891] Expression:
[13:17:27.891] {
[13:17:27.891]     do.call(function(...) {
[13:17:27.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.891]             on.exit(options(oopts), add = TRUE)
[13:17:27.891]         }
[13:17:27.891]         {
[13:17:27.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.891]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.891]             })
[13:17:27.891]         }
[13:17:27.891]     }, args = future.call.arguments)
[13:17:27.891] }
[13:17:27.891] Lazy evaluation: FALSE
[13:17:27.891] Asynchronous evaluation: TRUE
[13:17:27.891] Local evaluation: TRUE
[13:17:27.891] Environment: R_GlobalEnv
[13:17:27.891] Capture standard output: TRUE
[13:17:27.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:17:27.891] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:27.891] Packages: <none>
[13:17:27.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:17:27.891] Resolved: FALSE
[13:17:27.891] Value: <not collected>
[13:17:27.891] Conditions captured: <none>
[13:17:27.891] Early signaling: FALSE
[13:17:27.891] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:27.891] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.902] Chunk #2 of 2 ... DONE
[13:17:27.902] Launching 2 futures (chunks) ... DONE
[13:17:27.902] Resolving 2 futures (chunks) ...
[13:17:27.903] resolve() on list ...
[13:17:27.903]  recursive: 0
[13:17:27.903]  length: 2
[13:17:27.903] 
[13:17:27.903] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.904] - Validating connection of MultisessionFuture
[13:17:27.904] - received message: FutureResult
[13:17:27.904] - Received FutureResult
[13:17:27.904] - Erased future from FutureRegistry
[13:17:27.904] result() for ClusterFuture ...
[13:17:27.904] - result already collected: FutureResult
[13:17:27.904] result() for ClusterFuture ... done
[13:17:27.904] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.904] Future #1
[13:17:27.905] result() for ClusterFuture ...
[13:17:27.905] - result already collected: FutureResult
[13:17:27.905] result() for ClusterFuture ... done
[13:17:27.905] result() for ClusterFuture ...
[13:17:27.905] - result already collected: FutureResult
[13:17:27.905] result() for ClusterFuture ... done
[13:17:27.905] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:27.905] - nx: 2
[13:17:27.905] - relay: TRUE
[13:17:27.906] - stdout: TRUE
[13:17:27.906] - signal: TRUE
[13:17:27.906] - resignal: FALSE
[13:17:27.906] - force: TRUE
[13:17:27.906] - relayed: [n=2] FALSE, FALSE
[13:17:27.906] - queued futures: [n=2] FALSE, FALSE
[13:17:27.906]  - until=1
[13:17:27.906]  - relaying element #1
[13:17:27.906] result() for ClusterFuture ...
[13:17:27.906] - result already collected: FutureResult
[13:17:27.906] result() for ClusterFuture ... done
[13:17:27.906] result() for ClusterFuture ...
[13:17:27.907] - result already collected: FutureResult
[13:17:27.907] result() for ClusterFuture ... done
[13:17:27.907] result() for ClusterFuture ...
[13:17:27.907] - result already collected: FutureResult
[13:17:27.907] result() for ClusterFuture ... done
[13:17:27.907] result() for ClusterFuture ...
[13:17:27.907] - result already collected: FutureResult
[13:17:27.907] result() for ClusterFuture ... done
[13:17:27.907] - relayed: [n=2] TRUE, FALSE
[13:17:27.907] - queued futures: [n=2] TRUE, FALSE
[13:17:27.908] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:27.908]  length: 1 (resolved future 1)
[13:17:27.937] receiveMessageFromWorker() for ClusterFuture ...
[13:17:27.938] - Validating connection of MultisessionFuture
[13:17:27.938] - received message: FutureResult
[13:17:27.938] - Received FutureResult
[13:17:27.938] - Erased future from FutureRegistry
[13:17:27.938] result() for ClusterFuture ...
[13:17:27.938] - result already collected: FutureResult
[13:17:27.938] result() for ClusterFuture ... done
[13:17:27.938] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:27.938] Future #2
[13:17:27.939] result() for ClusterFuture ...
[13:17:27.939] - result already collected: FutureResult
[13:17:27.939] result() for ClusterFuture ... done
[13:17:27.939] result() for ClusterFuture ...
[13:17:27.939] - result already collected: FutureResult
[13:17:27.939] result() for ClusterFuture ... done
[13:17:27.939] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:27.939] - nx: 2
[13:17:27.939] - relay: TRUE
[13:17:27.939] - stdout: TRUE
[13:17:27.939] - signal: TRUE
[13:17:27.940] - resignal: FALSE
[13:17:27.940] - force: TRUE
[13:17:27.940] - relayed: [n=2] TRUE, FALSE
[13:17:27.940] - queued futures: [n=2] TRUE, FALSE
[13:17:27.940]  - until=2
[13:17:27.940]  - relaying element #2
[13:17:27.940] result() for ClusterFuture ...
[13:17:27.940] - result already collected: FutureResult
[13:17:27.940] result() for ClusterFuture ... done
[13:17:27.940] result() for ClusterFuture ...
[13:17:27.940] - result already collected: FutureResult
[13:17:27.941] result() for ClusterFuture ... done
[13:17:27.941] result() for ClusterFuture ...
[13:17:27.941] - result already collected: FutureResult
[13:17:27.941] result() for ClusterFuture ... done
[13:17:27.941] result() for ClusterFuture ...
[13:17:27.941] - result already collected: FutureResult
[13:17:27.941] result() for ClusterFuture ... done
[13:17:27.941] - relayed: [n=2] TRUE, TRUE
[13:17:27.941] - queued futures: [n=2] TRUE, TRUE
[13:17:27.941] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:27.942]  length: 0 (resolved future 2)
[13:17:27.942] Relaying remaining futures
[13:17:27.942] signalConditionsASAP(NULL, pos=0) ...
[13:17:27.942] - nx: 2
[13:17:27.942] - relay: TRUE
[13:17:27.942] - stdout: TRUE
[13:17:27.942] - signal: TRUE
[13:17:27.942] - resignal: FALSE
[13:17:27.942] - force: TRUE
[13:17:27.942] - relayed: [n=2] TRUE, TRUE
[13:17:27.942] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:27.943] - relayed: [n=2] TRUE, TRUE
[13:17:27.943] - queued futures: [n=2] TRUE, TRUE
[13:17:27.943] signalConditionsASAP(NULL, pos=0) ... done
[13:17:27.943] resolve() on list ... DONE
[13:17:27.943] result() for ClusterFuture ...
[13:17:27.943] - result already collected: FutureResult
[13:17:27.943] result() for ClusterFuture ... done
[13:17:27.943] result() for ClusterFuture ...
[13:17:27.943] - result already collected: FutureResult
[13:17:27.943] result() for ClusterFuture ... done
[13:17:27.944] result() for ClusterFuture ...
[13:17:27.944] - result already collected: FutureResult
[13:17:27.944] result() for ClusterFuture ... done
[13:17:27.944] result() for ClusterFuture ...
[13:17:27.944] - result already collected: FutureResult
[13:17:27.944] result() for ClusterFuture ... done
[13:17:27.944]  - Number of value chunks collected: 2
[13:17:27.944] Resolving 2 futures (chunks) ... DONE
[13:17:27.944] Reducing values from 2 chunks ...
[13:17:27.944]  - Number of values collected after concatenation: 2
[13:17:27.944]  - Number of values expected: 2
[13:17:27.945] Reducing values from 2 chunks ... DONE
[13:17:27.945] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[13:17:27.945] getGlobalsAndPackagesXApply() ...
[13:17:27.945]  - future.globals: TRUE
[13:17:27.945] getGlobalsAndPackages() ...
[13:17:27.945] Searching for globals...
[13:17:27.948] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[13:17:27.948] Searching for globals ... DONE
[13:17:27.948] Resolving globals: FALSE
[13:17:27.949] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[13:17:27.949] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[13:17:27.950] - globals: [1] ‘FUN’
[13:17:27.950] 
[13:17:27.950] getGlobalsAndPackages() ... DONE
[13:17:27.950]  - globals found/used: [n=1] ‘FUN’
[13:17:27.950]  - needed namespaces: [n=0] 
[13:17:27.950] Finding globals ... DONE
[13:17:27.950]  - use_args: TRUE
[13:17:27.950]  - Getting '...' globals ...
[13:17:27.951] resolve() on list ...
[13:17:27.951]  recursive: 0
[13:17:27.951]  length: 1
[13:17:27.951]  elements: ‘...’
[13:17:27.951]  length: 0 (resolved future 1)
[13:17:27.951] resolve() on list ... DONE
[13:17:27.951]    - '...' content: [n=0] 
[13:17:27.951] List of 1
[13:17:27.951]  $ ...: list()
[13:17:27.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.951]  - attr(*, "where")=List of 1
[13:17:27.951]   ..$ ...:<environment: 0x5647b8d84080> 
[13:17:27.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.951]  - attr(*, "resolved")= logi TRUE
[13:17:27.951]  - attr(*, "total_size")= num NA
[13:17:27.954]  - Getting '...' globals ... DONE
[13:17:27.954] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:17:27.954] List of 2
[13:17:27.954]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:17:27.954]  $ ...          : list()
[13:17:27.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.954]  - attr(*, "where")=List of 2
[13:17:27.954]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:17:27.954]   ..$ ...          :<environment: 0x5647b8d84080> 
[13:17:27.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.954]  - attr(*, "resolved")= logi FALSE
[13:17:27.954]  - attr(*, "total_size")= num 36296
[13:17:27.957] Packages to be attached in all futures: [n=0] 
[13:17:27.957] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.960] future_lapply() ...
[13:17:27.962] Generating random seeds ...
[13:17:27.962] Generating random seed streams for 2 elements ...
[13:17:27.962] Generating random seed streams for 2 elements ... DONE
[13:17:27.963] Generating random seeds ... DONE
[13:17:27.963] Will set RNG state on exit: 10407, 1741444439, 1018708863, -2097538445, 190609906, -930432984, -1230946686
[13:17:27.966] Number of chunks: 2
[13:17:27.966] getGlobalsAndPackagesXApply() ...
[13:17:27.966]  - future.globals: <name-value list> with names ‘list()’
[13:17:27.966]  - use_args: TRUE
[13:17:27.967] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[13:17:27.967] List of 2
[13:17:27.967]  $ ...          : list()
[13:17:27.967]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:17:27.967]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[13:17:27.967]  - attr(*, "where")=List of 2
[13:17:27.967]   ..$ ...          :<environment: 0x5647b8d84080> 
[13:17:27.967]   ..$ ...future.FUN:<environment: namespace:base> 
[13:17:27.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:17:27.967]  - attr(*, "resolved")= logi FALSE
[13:17:27.967]  - attr(*, "total_size")= num NA
[13:17:27.970] Packages to be attached in all futures: [n=0] 
[13:17:27.970] getGlobalsAndPackagesXApply() ... DONE
[13:17:27.970] Number of futures (= number of chunks): 2
[13:17:27.970] Launching 2 futures (chunks) ...
[13:17:27.971] Chunk #1 of 2 ...
[13:17:27.971]  - seeds: [1] <seeds>
[13:17:27.971] getGlobalsAndPackages() ...
[13:17:27.971] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.971] Resolving globals: FALSE
[13:17:27.971] Tweak future expression to call with '...' arguments ...
[13:17:27.971] {
[13:17:27.971]     do.call(function(...) {
[13:17:27.971]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.971]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:27.971]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.971]             on.exit(options(oopts), add = TRUE)
[13:17:27.971]         }
[13:17:27.971]         {
[13:17:27.971]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:27.971]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.971]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:27.971]                   envir = globalenv(), inherits = FALSE)
[13:17:27.971]                 ...future.FUN(...future.X_jj, ...)
[13:17:27.971]             })
[13:17:27.971]         }
[13:17:27.971]     }, args = future.call.arguments)
[13:17:27.971] }
[13:17:27.971] Tweak future expression to call with '...' arguments ... DONE
[13:17:27.972] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:27.972] 
[13:17:27.972] getGlobalsAndPackages() ... DONE
[13:17:27.972] run() for ‘Future’ ...
[13:17:27.972] - state: ‘created’
[13:17:27.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:27.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:27.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:27.987]   - Field: ‘node’
[13:17:27.987]   - Field: ‘label’
[13:17:27.987]   - Field: ‘local’
[13:17:27.988]   - Field: ‘owner’
[13:17:27.988]   - Field: ‘envir’
[13:17:27.988]   - Field: ‘workers’
[13:17:27.988]   - Field: ‘packages’
[13:17:27.988]   - Field: ‘gc’
[13:17:27.988]   - Field: ‘conditions’
[13:17:27.988]   - Field: ‘persistent’
[13:17:27.988]   - Field: ‘expr’
[13:17:27.988]   - Field: ‘uuid’
[13:17:27.988]   - Field: ‘seed’
[13:17:27.988]   - Field: ‘version’
[13:17:27.989]   - Field: ‘result’
[13:17:27.989]   - Field: ‘asynchronous’
[13:17:27.989]   - Field: ‘calls’
[13:17:27.989]   - Field: ‘globals’
[13:17:27.989]   - Field: ‘stdout’
[13:17:27.989]   - Field: ‘earlySignal’
[13:17:27.989]   - Field: ‘lazy’
[13:17:27.989]   - Field: ‘state’
[13:17:27.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:27.989] - Launch lazy future ...
[13:17:27.990] Packages needed by the future expression (n = 0): <none>
[13:17:27.990] Packages needed by future strategies (n = 0): <none>
[13:17:27.990] {
[13:17:27.990]     {
[13:17:27.990]         {
[13:17:27.990]             ...future.startTime <- base::Sys.time()
[13:17:27.990]             {
[13:17:27.990]                 {
[13:17:27.990]                   {
[13:17:27.990]                     {
[13:17:27.990]                       base::local({
[13:17:27.990]                         has_future <- base::requireNamespace("future", 
[13:17:27.990]                           quietly = TRUE)
[13:17:27.990]                         if (has_future) {
[13:17:27.990]                           ns <- base::getNamespace("future")
[13:17:27.990]                           version <- ns[[".package"]][["version"]]
[13:17:27.990]                           if (is.null(version)) 
[13:17:27.990]                             version <- utils::packageVersion("future")
[13:17:27.990]                         }
[13:17:27.990]                         else {
[13:17:27.990]                           version <- NULL
[13:17:27.990]                         }
[13:17:27.990]                         if (!has_future || version < "1.8.0") {
[13:17:27.990]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:27.990]                             "", base::R.version$version.string), 
[13:17:27.990]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:27.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:27.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:27.990]                               "release", "version")], collapse = " "), 
[13:17:27.990]                             hostname = base::Sys.info()[["nodename"]])
[13:17:27.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:27.990]                             info)
[13:17:27.990]                           info <- base::paste(info, collapse = "; ")
[13:17:27.990]                           if (!has_future) {
[13:17:27.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:27.990]                               info)
[13:17:27.990]                           }
[13:17:27.990]                           else {
[13:17:27.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:27.990]                               info, version)
[13:17:27.990]                           }
[13:17:27.990]                           base::stop(msg)
[13:17:27.990]                         }
[13:17:27.990]                       })
[13:17:27.990]                     }
[13:17:27.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:27.990]                     base::options(mc.cores = 1L)
[13:17:27.990]                   }
[13:17:27.990]                   options(future.plan = NULL)
[13:17:27.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:27.990]                 }
[13:17:27.990]                 ...future.workdir <- getwd()
[13:17:27.990]             }
[13:17:27.990]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:27.990]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:27.990]         }
[13:17:27.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:27.990]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:27.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:27.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:27.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:27.990]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:27.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:27.990]             base::names(...future.oldOptions))
[13:17:27.990]     }
[13:17:27.990]     if (FALSE) {
[13:17:27.990]     }
[13:17:27.990]     else {
[13:17:27.990]         if (TRUE) {
[13:17:27.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:27.990]                 open = "w")
[13:17:27.990]         }
[13:17:27.990]         else {
[13:17:27.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:27.990]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:27.990]         }
[13:17:27.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:27.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:27.990]             base::sink(type = "output", split = FALSE)
[13:17:27.990]             base::close(...future.stdout)
[13:17:27.990]         }, add = TRUE)
[13:17:27.990]     }
[13:17:27.990]     ...future.frame <- base::sys.nframe()
[13:17:27.990]     ...future.conditions <- base::list()
[13:17:27.990]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:27.990]     if (FALSE) {
[13:17:27.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:27.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:27.990]     }
[13:17:27.990]     ...future.result <- base::tryCatch({
[13:17:27.990]         base::withCallingHandlers({
[13:17:27.990]             ...future.value <- base::withVisible(base::local({
[13:17:27.990]                 ...future.makeSendCondition <- local({
[13:17:27.990]                   sendCondition <- NULL
[13:17:27.990]                   function(frame = 1L) {
[13:17:27.990]                     if (is.function(sendCondition)) 
[13:17:27.990]                       return(sendCondition)
[13:17:27.990]                     ns <- getNamespace("parallel")
[13:17:27.990]                     if (exists("sendData", mode = "function", 
[13:17:27.990]                       envir = ns)) {
[13:17:27.990]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:27.990]                         envir = ns)
[13:17:27.990]                       envir <- sys.frame(frame)
[13:17:27.990]                       master <- NULL
[13:17:27.990]                       while (!identical(envir, .GlobalEnv) && 
[13:17:27.990]                         !identical(envir, emptyenv())) {
[13:17:27.990]                         if (exists("master", mode = "list", envir = envir, 
[13:17:27.990]                           inherits = FALSE)) {
[13:17:27.990]                           master <- get("master", mode = "list", 
[13:17:27.990]                             envir = envir, inherits = FALSE)
[13:17:27.990]                           if (inherits(master, c("SOCKnode", 
[13:17:27.990]                             "SOCK0node"))) {
[13:17:27.990]                             sendCondition <<- function(cond) {
[13:17:27.990]                               data <- list(type = "VALUE", value = cond, 
[13:17:27.990]                                 success = TRUE)
[13:17:27.990]                               parallel_sendData(master, data)
[13:17:27.990]                             }
[13:17:27.990]                             return(sendCondition)
[13:17:27.990]                           }
[13:17:27.990]                         }
[13:17:27.990]                         frame <- frame + 1L
[13:17:27.990]                         envir <- sys.frame(frame)
[13:17:27.990]                       }
[13:17:27.990]                     }
[13:17:27.990]                     sendCondition <<- function(cond) NULL
[13:17:27.990]                   }
[13:17:27.990]                 })
[13:17:27.990]                 withCallingHandlers({
[13:17:27.990]                   {
[13:17:27.990]                     do.call(function(...) {
[13:17:27.990]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:27.990]                       if (!identical(...future.globals.maxSize.org, 
[13:17:27.990]                         ...future.globals.maxSize)) {
[13:17:27.990]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:27.990]                         on.exit(options(oopts), add = TRUE)
[13:17:27.990]                       }
[13:17:27.990]                       {
[13:17:27.990]                         lapply(seq_along(...future.elements_ii), 
[13:17:27.990]                           FUN = function(jj) {
[13:17:27.990]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:27.990]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:27.990]                               envir = globalenv(), inherits = FALSE)
[13:17:27.990]                             ...future.FUN(...future.X_jj, ...)
[13:17:27.990]                           })
[13:17:27.990]                       }
[13:17:27.990]                     }, args = future.call.arguments)
[13:17:27.990]                   }
[13:17:27.990]                 }, immediateCondition = function(cond) {
[13:17:27.990]                   sendCondition <- ...future.makeSendCondition()
[13:17:27.990]                   sendCondition(cond)
[13:17:27.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.990]                   {
[13:17:27.990]                     inherits <- base::inherits
[13:17:27.990]                     invokeRestart <- base::invokeRestart
[13:17:27.990]                     is.null <- base::is.null
[13:17:27.990]                     muffled <- FALSE
[13:17:27.990]                     if (inherits(cond, "message")) {
[13:17:27.990]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:27.990]                       if (muffled) 
[13:17:27.990]                         invokeRestart("muffleMessage")
[13:17:27.990]                     }
[13:17:27.990]                     else if (inherits(cond, "warning")) {
[13:17:27.990]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:27.990]                       if (muffled) 
[13:17:27.990]                         invokeRestart("muffleWarning")
[13:17:27.990]                     }
[13:17:27.990]                     else if (inherits(cond, "condition")) {
[13:17:27.990]                       if (!is.null(pattern)) {
[13:17:27.990]                         computeRestarts <- base::computeRestarts
[13:17:27.990]                         grepl <- base::grepl
[13:17:27.990]                         restarts <- computeRestarts(cond)
[13:17:27.990]                         for (restart in restarts) {
[13:17:27.990]                           name <- restart$name
[13:17:27.990]                           if (is.null(name)) 
[13:17:27.990]                             next
[13:17:27.990]                           if (!grepl(pattern, name)) 
[13:17:27.990]                             next
[13:17:27.990]                           invokeRestart(restart)
[13:17:27.990]                           muffled <- TRUE
[13:17:27.990]                           break
[13:17:27.990]                         }
[13:17:27.990]                       }
[13:17:27.990]                     }
[13:17:27.990]                     invisible(muffled)
[13:17:27.990]                   }
[13:17:27.990]                   muffleCondition(cond)
[13:17:27.990]                 })
[13:17:27.990]             }))
[13:17:27.990]             future::FutureResult(value = ...future.value$value, 
[13:17:27.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.990]                   ...future.rng), globalenv = if (FALSE) 
[13:17:27.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:27.990]                     ...future.globalenv.names))
[13:17:27.990]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:27.990]         }, condition = base::local({
[13:17:27.990]             c <- base::c
[13:17:27.990]             inherits <- base::inherits
[13:17:27.990]             invokeRestart <- base::invokeRestart
[13:17:27.990]             length <- base::length
[13:17:27.990]             list <- base::list
[13:17:27.990]             seq.int <- base::seq.int
[13:17:27.990]             signalCondition <- base::signalCondition
[13:17:27.990]             sys.calls <- base::sys.calls
[13:17:27.990]             `[[` <- base::`[[`
[13:17:27.990]             `+` <- base::`+`
[13:17:27.990]             `<<-` <- base::`<<-`
[13:17:27.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:27.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:27.990]                   3L)]
[13:17:27.990]             }
[13:17:27.990]             function(cond) {
[13:17:27.990]                 is_error <- inherits(cond, "error")
[13:17:27.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:27.990]                   NULL)
[13:17:27.990]                 if (is_error) {
[13:17:27.990]                   sessionInformation <- function() {
[13:17:27.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:27.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:27.990]                       search = base::search(), system = base::Sys.info())
[13:17:27.990]                   }
[13:17:27.990]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:27.990]                     cond$call), session = sessionInformation(), 
[13:17:27.990]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:27.990]                   signalCondition(cond)
[13:17:27.990]                 }
[13:17:27.990]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:17:27.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:27.990]                   ...future.conditions[[length(...future.conditions) + 
[13:17:27.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:27.990]                   if (TRUE && !signal) {
[13:17:27.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.990]                     {
[13:17:27.990]                       inherits <- base::inherits
[13:17:27.990]                       invokeRestart <- base::invokeRestart
[13:17:27.990]                       is.null <- base::is.null
[13:17:27.990]                       muffled <- FALSE
[13:17:27.990]                       if (inherits(cond, "message")) {
[13:17:27.990]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.990]                         if (muffled) 
[13:17:27.990]                           invokeRestart("muffleMessage")
[13:17:27.990]                       }
[13:17:27.990]                       else if (inherits(cond, "warning")) {
[13:17:27.990]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.990]                         if (muffled) 
[13:17:27.990]                           invokeRestart("muffleWarning")
[13:17:27.990]                       }
[13:17:27.990]                       else if (inherits(cond, "condition")) {
[13:17:27.990]                         if (!is.null(pattern)) {
[13:17:27.990]                           computeRestarts <- base::computeRestarts
[13:17:27.990]                           grepl <- base::grepl
[13:17:27.990]                           restarts <- computeRestarts(cond)
[13:17:27.990]                           for (restart in restarts) {
[13:17:27.990]                             name <- restart$name
[13:17:27.990]                             if (is.null(name)) 
[13:17:27.990]                               next
[13:17:27.990]                             if (!grepl(pattern, name)) 
[13:17:27.990]                               next
[13:17:27.990]                             invokeRestart(restart)
[13:17:27.990]                             muffled <- TRUE
[13:17:27.990]                             break
[13:17:27.990]                           }
[13:17:27.990]                         }
[13:17:27.990]                       }
[13:17:27.990]                       invisible(muffled)
[13:17:27.990]                     }
[13:17:27.990]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.990]                   }
[13:17:27.990]                 }
[13:17:27.990]                 else {
[13:17:27.990]                   if (TRUE) {
[13:17:27.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:27.990]                     {
[13:17:27.990]                       inherits <- base::inherits
[13:17:27.990]                       invokeRestart <- base::invokeRestart
[13:17:27.990]                       is.null <- base::is.null
[13:17:27.990]                       muffled <- FALSE
[13:17:27.990]                       if (inherits(cond, "message")) {
[13:17:27.990]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:27.990]                         if (muffled) 
[13:17:27.990]                           invokeRestart("muffleMessage")
[13:17:27.990]                       }
[13:17:27.990]                       else if (inherits(cond, "warning")) {
[13:17:27.990]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:27.990]                         if (muffled) 
[13:17:27.990]                           invokeRestart("muffleWarning")
[13:17:27.990]                       }
[13:17:27.990]                       else if (inherits(cond, "condition")) {
[13:17:27.990]                         if (!is.null(pattern)) {
[13:17:27.990]                           computeRestarts <- base::computeRestarts
[13:17:27.990]                           grepl <- base::grepl
[13:17:27.990]                           restarts <- computeRestarts(cond)
[13:17:27.990]                           for (restart in restarts) {
[13:17:27.990]                             name <- restart$name
[13:17:27.990]                             if (is.null(name)) 
[13:17:27.990]                               next
[13:17:27.990]                             if (!grepl(pattern, name)) 
[13:17:27.990]                               next
[13:17:27.990]                             invokeRestart(restart)
[13:17:27.990]                             muffled <- TRUE
[13:17:27.990]                             break
[13:17:27.990]                           }
[13:17:27.990]                         }
[13:17:27.990]                       }
[13:17:27.990]                       invisible(muffled)
[13:17:27.990]                     }
[13:17:27.990]                     muffleCondition(cond, pattern = "^muffle")
[13:17:27.990]                   }
[13:17:27.990]                 }
[13:17:27.990]             }
[13:17:27.990]         }))
[13:17:27.990]     }, error = function(ex) {
[13:17:27.990]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:27.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:27.990]                 ...future.rng), started = ...future.startTime, 
[13:17:27.990]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:27.990]             version = "1.8"), class = "FutureResult")
[13:17:27.990]     }, finally = {
[13:17:27.990]         if (!identical(...future.workdir, getwd())) 
[13:17:27.990]             setwd(...future.workdir)
[13:17:27.990]         {
[13:17:27.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:27.990]                 ...future.oldOptions$nwarnings <- NULL
[13:17:27.990]             }
[13:17:27.990]             base::options(...future.oldOptions)
[13:17:27.990]             if (.Platform$OS.type == "windows") {
[13:17:27.990]                 old_names <- names(...future.oldEnvVars)
[13:17:27.990]                 envs <- base::Sys.getenv()
[13:17:27.990]                 names <- names(envs)
[13:17:27.990]                 common <- intersect(names, old_names)
[13:17:27.990]                 added <- setdiff(names, old_names)
[13:17:27.990]                 removed <- setdiff(old_names, names)
[13:17:27.990]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:27.990]                   envs[common]]
[13:17:27.990]                 NAMES <- toupper(changed)
[13:17:27.990]                 args <- list()
[13:17:27.990]                 for (kk in seq_along(NAMES)) {
[13:17:27.990]                   name <- changed[[kk]]
[13:17:27.990]                   NAME <- NAMES[[kk]]
[13:17:27.990]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.990]                     next
[13:17:27.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.990]                 }
[13:17:27.990]                 NAMES <- toupper(added)
[13:17:27.990]                 for (kk in seq_along(NAMES)) {
[13:17:27.990]                   name <- added[[kk]]
[13:17:27.990]                   NAME <- NAMES[[kk]]
[13:17:27.990]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.990]                     next
[13:17:27.990]                   args[[name]] <- ""
[13:17:27.990]                 }
[13:17:27.990]                 NAMES <- toupper(removed)
[13:17:27.990]                 for (kk in seq_along(NAMES)) {
[13:17:27.990]                   name <- removed[[kk]]
[13:17:27.990]                   NAME <- NAMES[[kk]]
[13:17:27.990]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:27.990]                     next
[13:17:27.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:27.990]                 }
[13:17:27.990]                 if (length(args) > 0) 
[13:17:27.990]                   base::do.call(base::Sys.setenv, args = args)
[13:17:27.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:27.990]             }
[13:17:27.990]             else {
[13:17:27.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:27.990]             }
[13:17:27.990]             {
[13:17:27.990]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:27.990]                   0L) {
[13:17:27.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:27.990]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:27.990]                   base::options(opts)
[13:17:27.990]                 }
[13:17:27.990]                 {
[13:17:27.990]                   {
[13:17:27.990]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:27.990]                     NULL
[13:17:27.990]                   }
[13:17:27.990]                   options(future.plan = NULL)
[13:17:27.990]                   if (is.na(NA_character_)) 
[13:17:27.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:27.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:27.990]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:27.990]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:27.990]                     envir = parent.frame()) 
[13:17:27.990]                   {
[13:17:27.990]                     if (is.function(workers)) 
[13:17:27.990]                       workers <- workers()
[13:17:27.990]                     workers <- structure(as.integer(workers), 
[13:17:27.990]                       class = class(workers))
[13:17:27.990]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:27.990]                       workers >= 1)
[13:17:27.990]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:27.990]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:27.990]                     }
[13:17:27.990]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:27.990]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:27.990]                       envir = envir)
[13:17:27.990]                     if (!future$lazy) 
[13:17:27.990]                       future <- run(future)
[13:17:27.990]                     invisible(future)
[13:17:27.990]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:27.990]                 }
[13:17:27.990]             }
[13:17:27.990]         }
[13:17:27.990]     })
[13:17:27.990]     if (TRUE) {
[13:17:27.990]         base::sink(type = "output", split = FALSE)
[13:17:27.990]         if (TRUE) {
[13:17:27.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:27.990]         }
[13:17:27.990]         else {
[13:17:27.990]             ...future.result["stdout"] <- base::list(NULL)
[13:17:27.990]         }
[13:17:27.990]         base::close(...future.stdout)
[13:17:27.990]         ...future.stdout <- NULL
[13:17:27.990]     }
[13:17:27.990]     ...future.result$conditions <- ...future.conditions
[13:17:27.990]     ...future.result$finished <- base::Sys.time()
[13:17:27.990]     ...future.result
[13:17:27.990] }
[13:17:27.994] Exporting 5 global objects (35.58 KiB) to cluster node #1 ...
[13:17:27.994] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:17:27.994] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:17:27.994] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[13:17:28.037] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[13:17:28.037] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:17:28.038] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:17:28.038] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[13:17:28.038] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[13:17:28.038] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:17:28.039] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:17:28.039] Exporting 5 global objects (35.58 KiB) to cluster node #1 ... DONE
[13:17:28.039] MultisessionFuture started
[13:17:28.040] - Launch lazy future ... done
[13:17:28.040] run() for ‘MultisessionFuture’ ... done
[13:17:28.040] Created future:
[13:17:28.040] MultisessionFuture:
[13:17:28.040] Label: ‘future_apply-1’
[13:17:28.040] Expression:
[13:17:28.040] {
[13:17:28.040]     do.call(function(...) {
[13:17:28.040]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.040]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.040]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.040]             on.exit(options(oopts), add = TRUE)
[13:17:28.040]         }
[13:17:28.040]         {
[13:17:28.040]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.040]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.040]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:28.040]                   envir = globalenv(), inherits = FALSE)
[13:17:28.040]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.040]             })
[13:17:28.040]         }
[13:17:28.040]     }, args = future.call.arguments)
[13:17:28.040] }
[13:17:28.040] Lazy evaluation: FALSE
[13:17:28.040] Asynchronous evaluation: TRUE
[13:17:28.040] Local evaluation: TRUE
[13:17:28.040] Environment: R_GlobalEnv
[13:17:28.040] Capture standard output: TRUE
[13:17:28.040] Capture condition classes: <none>
[13:17:28.040] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.040] Packages: <none>
[13:17:28.040] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:17:28.040] Resolved: FALSE
[13:17:28.040] Value: <not collected>
[13:17:28.040] Conditions captured: <none>
[13:17:28.040] Early signaling: FALSE
[13:17:28.040] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:28.040] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:28.052] Chunk #1 of 2 ... DONE
[13:17:28.052] Chunk #2 of 2 ...
[13:17:28.052]  - seeds: [1] <seeds>
[13:17:28.052] getGlobalsAndPackages() ...
[13:17:28.052] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.052] Resolving globals: FALSE
[13:17:28.053] Tweak future expression to call with '...' arguments ...
[13:17:28.053] {
[13:17:28.053]     do.call(function(...) {
[13:17:28.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.053]             on.exit(options(oopts), add = TRUE)
[13:17:28.053]         }
[13:17:28.053]         {
[13:17:28.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.053]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:28.053]                   envir = globalenv(), inherits = FALSE)
[13:17:28.053]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.053]             })
[13:17:28.053]         }
[13:17:28.053]     }, args = future.call.arguments)
[13:17:28.053] }
[13:17:28.053] Tweak future expression to call with '...' arguments ... DONE
[13:17:28.053] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:17:28.053] 
[13:17:28.054] getGlobalsAndPackages() ... DONE
[13:17:28.054] run() for ‘Future’ ...
[13:17:28.054] - state: ‘created’
[13:17:28.054] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:17:28.069] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:28.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:17:28.069]   - Field: ‘node’
[13:17:28.069]   - Field: ‘label’
[13:17:28.069]   - Field: ‘local’
[13:17:28.070]   - Field: ‘owner’
[13:17:28.070]   - Field: ‘envir’
[13:17:28.070]   - Field: ‘workers’
[13:17:28.070]   - Field: ‘packages’
[13:17:28.070]   - Field: ‘gc’
[13:17:28.070]   - Field: ‘conditions’
[13:17:28.070]   - Field: ‘persistent’
[13:17:28.070]   - Field: ‘expr’
[13:17:28.070]   - Field: ‘uuid’
[13:17:28.070]   - Field: ‘seed’
[13:17:28.070]   - Field: ‘version’
[13:17:28.071]   - Field: ‘result’
[13:17:28.071]   - Field: ‘asynchronous’
[13:17:28.071]   - Field: ‘calls’
[13:17:28.071]   - Field: ‘globals’
[13:17:28.071]   - Field: ‘stdout’
[13:17:28.071]   - Field: ‘earlySignal’
[13:17:28.071]   - Field: ‘lazy’
[13:17:28.071]   - Field: ‘state’
[13:17:28.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:17:28.071] - Launch lazy future ...
[13:17:28.072] Packages needed by the future expression (n = 0): <none>
[13:17:28.072] Packages needed by future strategies (n = 0): <none>
[13:17:28.072] {
[13:17:28.072]     {
[13:17:28.072]         {
[13:17:28.072]             ...future.startTime <- base::Sys.time()
[13:17:28.072]             {
[13:17:28.072]                 {
[13:17:28.072]                   {
[13:17:28.072]                     {
[13:17:28.072]                       base::local({
[13:17:28.072]                         has_future <- base::requireNamespace("future", 
[13:17:28.072]                           quietly = TRUE)
[13:17:28.072]                         if (has_future) {
[13:17:28.072]                           ns <- base::getNamespace("future")
[13:17:28.072]                           version <- ns[[".package"]][["version"]]
[13:17:28.072]                           if (is.null(version)) 
[13:17:28.072]                             version <- utils::packageVersion("future")
[13:17:28.072]                         }
[13:17:28.072]                         else {
[13:17:28.072]                           version <- NULL
[13:17:28.072]                         }
[13:17:28.072]                         if (!has_future || version < "1.8.0") {
[13:17:28.072]                           info <- base::c(r_version = base::gsub("R version ", 
[13:17:28.072]                             "", base::R.version$version.string), 
[13:17:28.072]                             platform = base::sprintf("%s (%s-bit)", 
[13:17:28.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:17:28.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:17:28.072]                               "release", "version")], collapse = " "), 
[13:17:28.072]                             hostname = base::Sys.info()[["nodename"]])
[13:17:28.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:17:28.072]                             info)
[13:17:28.072]                           info <- base::paste(info, collapse = "; ")
[13:17:28.072]                           if (!has_future) {
[13:17:28.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:17:28.072]                               info)
[13:17:28.072]                           }
[13:17:28.072]                           else {
[13:17:28.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:17:28.072]                               info, version)
[13:17:28.072]                           }
[13:17:28.072]                           base::stop(msg)
[13:17:28.072]                         }
[13:17:28.072]                       })
[13:17:28.072]                     }
[13:17:28.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:17:28.072]                     base::options(mc.cores = 1L)
[13:17:28.072]                   }
[13:17:28.072]                   options(future.plan = NULL)
[13:17:28.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:17:28.072]                 }
[13:17:28.072]                 ...future.workdir <- getwd()
[13:17:28.072]             }
[13:17:28.072]             ...future.oldOptions <- base::as.list(base::.Options)
[13:17:28.072]             ...future.oldEnvVars <- base::Sys.getenv()
[13:17:28.072]         }
[13:17:28.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:17:28.072]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[13:17:28.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:17:28.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:17:28.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:17:28.072]             future.stdout.windows.reencode = NULL, width = 80L)
[13:17:28.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:17:28.072]             base::names(...future.oldOptions))
[13:17:28.072]     }
[13:17:28.072]     if (FALSE) {
[13:17:28.072]     }
[13:17:28.072]     else {
[13:17:28.072]         if (TRUE) {
[13:17:28.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:17:28.072]                 open = "w")
[13:17:28.072]         }
[13:17:28.072]         else {
[13:17:28.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:17:28.072]                 windows = "NUL", "/dev/null"), open = "w")
[13:17:28.072]         }
[13:17:28.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:17:28.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:17:28.072]             base::sink(type = "output", split = FALSE)
[13:17:28.072]             base::close(...future.stdout)
[13:17:28.072]         }, add = TRUE)
[13:17:28.072]     }
[13:17:28.072]     ...future.frame <- base::sys.nframe()
[13:17:28.072]     ...future.conditions <- base::list()
[13:17:28.072]     ...future.rng <- base::globalenv()$.Random.seed
[13:17:28.072]     if (FALSE) {
[13:17:28.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:17:28.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:17:28.072]     }
[13:17:28.072]     ...future.result <- base::tryCatch({
[13:17:28.072]         base::withCallingHandlers({
[13:17:28.072]             ...future.value <- base::withVisible(base::local({
[13:17:28.072]                 ...future.makeSendCondition <- local({
[13:17:28.072]                   sendCondition <- NULL
[13:17:28.072]                   function(frame = 1L) {
[13:17:28.072]                     if (is.function(sendCondition)) 
[13:17:28.072]                       return(sendCondition)
[13:17:28.072]                     ns <- getNamespace("parallel")
[13:17:28.072]                     if (exists("sendData", mode = "function", 
[13:17:28.072]                       envir = ns)) {
[13:17:28.072]                       parallel_sendData <- get("sendData", mode = "function", 
[13:17:28.072]                         envir = ns)
[13:17:28.072]                       envir <- sys.frame(frame)
[13:17:28.072]                       master <- NULL
[13:17:28.072]                       while (!identical(envir, .GlobalEnv) && 
[13:17:28.072]                         !identical(envir, emptyenv())) {
[13:17:28.072]                         if (exists("master", mode = "list", envir = envir, 
[13:17:28.072]                           inherits = FALSE)) {
[13:17:28.072]                           master <- get("master", mode = "list", 
[13:17:28.072]                             envir = envir, inherits = FALSE)
[13:17:28.072]                           if (inherits(master, c("SOCKnode", 
[13:17:28.072]                             "SOCK0node"))) {
[13:17:28.072]                             sendCondition <<- function(cond) {
[13:17:28.072]                               data <- list(type = "VALUE", value = cond, 
[13:17:28.072]                                 success = TRUE)
[13:17:28.072]                               parallel_sendData(master, data)
[13:17:28.072]                             }
[13:17:28.072]                             return(sendCondition)
[13:17:28.072]                           }
[13:17:28.072]                         }
[13:17:28.072]                         frame <- frame + 1L
[13:17:28.072]                         envir <- sys.frame(frame)
[13:17:28.072]                       }
[13:17:28.072]                     }
[13:17:28.072]                     sendCondition <<- function(cond) NULL
[13:17:28.072]                   }
[13:17:28.072]                 })
[13:17:28.072]                 withCallingHandlers({
[13:17:28.072]                   {
[13:17:28.072]                     do.call(function(...) {
[13:17:28.072]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.072]                       if (!identical(...future.globals.maxSize.org, 
[13:17:28.072]                         ...future.globals.maxSize)) {
[13:17:28.072]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.072]                         on.exit(options(oopts), add = TRUE)
[13:17:28.072]                       }
[13:17:28.072]                       {
[13:17:28.072]                         lapply(seq_along(...future.elements_ii), 
[13:17:28.072]                           FUN = function(jj) {
[13:17:28.072]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.072]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:28.072]                               envir = globalenv(), inherits = FALSE)
[13:17:28.072]                             ...future.FUN(...future.X_jj, ...)
[13:17:28.072]                           })
[13:17:28.072]                       }
[13:17:28.072]                     }, args = future.call.arguments)
[13:17:28.072]                   }
[13:17:28.072]                 }, immediateCondition = function(cond) {
[13:17:28.072]                   sendCondition <- ...future.makeSendCondition()
[13:17:28.072]                   sendCondition(cond)
[13:17:28.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.072]                   {
[13:17:28.072]                     inherits <- base::inherits
[13:17:28.072]                     invokeRestart <- base::invokeRestart
[13:17:28.072]                     is.null <- base::is.null
[13:17:28.072]                     muffled <- FALSE
[13:17:28.072]                     if (inherits(cond, "message")) {
[13:17:28.072]                       muffled <- grepl(pattern, "muffleMessage")
[13:17:28.072]                       if (muffled) 
[13:17:28.072]                         invokeRestart("muffleMessage")
[13:17:28.072]                     }
[13:17:28.072]                     else if (inherits(cond, "warning")) {
[13:17:28.072]                       muffled <- grepl(pattern, "muffleWarning")
[13:17:28.072]                       if (muffled) 
[13:17:28.072]                         invokeRestart("muffleWarning")
[13:17:28.072]                     }
[13:17:28.072]                     else if (inherits(cond, "condition")) {
[13:17:28.072]                       if (!is.null(pattern)) {
[13:17:28.072]                         computeRestarts <- base::computeRestarts
[13:17:28.072]                         grepl <- base::grepl
[13:17:28.072]                         restarts <- computeRestarts(cond)
[13:17:28.072]                         for (restart in restarts) {
[13:17:28.072]                           name <- restart$name
[13:17:28.072]                           if (is.null(name)) 
[13:17:28.072]                             next
[13:17:28.072]                           if (!grepl(pattern, name)) 
[13:17:28.072]                             next
[13:17:28.072]                           invokeRestart(restart)
[13:17:28.072]                           muffled <- TRUE
[13:17:28.072]                           break
[13:17:28.072]                         }
[13:17:28.072]                       }
[13:17:28.072]                     }
[13:17:28.072]                     invisible(muffled)
[13:17:28.072]                   }
[13:17:28.072]                   muffleCondition(cond)
[13:17:28.072]                 })
[13:17:28.072]             }))
[13:17:28.072]             future::FutureResult(value = ...future.value$value, 
[13:17:28.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.072]                   ...future.rng), globalenv = if (FALSE) 
[13:17:28.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:17:28.072]                     ...future.globalenv.names))
[13:17:28.072]                 else NULL, started = ...future.startTime, version = "1.8")
[13:17:28.072]         }, condition = base::local({
[13:17:28.072]             c <- base::c
[13:17:28.072]             inherits <- base::inherits
[13:17:28.072]             invokeRestart <- base::invokeRestart
[13:17:28.072]             length <- base::length
[13:17:28.072]             list <- base::list
[13:17:28.072]             seq.int <- base::seq.int
[13:17:28.072]             signalCondition <- base::signalCondition
[13:17:28.072]             sys.calls <- base::sys.calls
[13:17:28.072]             `[[` <- base::`[[`
[13:17:28.072]             `+` <- base::`+`
[13:17:28.072]             `<<-` <- base::`<<-`
[13:17:28.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:17:28.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:17:28.072]                   3L)]
[13:17:28.072]             }
[13:17:28.072]             function(cond) {
[13:17:28.072]                 is_error <- inherits(cond, "error")
[13:17:28.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:17:28.072]                   NULL)
[13:17:28.072]                 if (is_error) {
[13:17:28.072]                   sessionInformation <- function() {
[13:17:28.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:17:28.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:17:28.072]                       search = base::search(), system = base::Sys.info())
[13:17:28.072]                   }
[13:17:28.072]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:17:28.072]                     cond$call), session = sessionInformation(), 
[13:17:28.072]                     timestamp = base::Sys.time(), signaled = 0L)
[13:17:28.072]                   signalCondition(cond)
[13:17:28.072]                 }
[13:17:28.072]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[13:17:28.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:17:28.072]                   ...future.conditions[[length(...future.conditions) + 
[13:17:28.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:17:28.072]                   if (TRUE && !signal) {
[13:17:28.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.072]                     {
[13:17:28.072]                       inherits <- base::inherits
[13:17:28.072]                       invokeRestart <- base::invokeRestart
[13:17:28.072]                       is.null <- base::is.null
[13:17:28.072]                       muffled <- FALSE
[13:17:28.072]                       if (inherits(cond, "message")) {
[13:17:28.072]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.072]                         if (muffled) 
[13:17:28.072]                           invokeRestart("muffleMessage")
[13:17:28.072]                       }
[13:17:28.072]                       else if (inherits(cond, "warning")) {
[13:17:28.072]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.072]                         if (muffled) 
[13:17:28.072]                           invokeRestart("muffleWarning")
[13:17:28.072]                       }
[13:17:28.072]                       else if (inherits(cond, "condition")) {
[13:17:28.072]                         if (!is.null(pattern)) {
[13:17:28.072]                           computeRestarts <- base::computeRestarts
[13:17:28.072]                           grepl <- base::grepl
[13:17:28.072]                           restarts <- computeRestarts(cond)
[13:17:28.072]                           for (restart in restarts) {
[13:17:28.072]                             name <- restart$name
[13:17:28.072]                             if (is.null(name)) 
[13:17:28.072]                               next
[13:17:28.072]                             if (!grepl(pattern, name)) 
[13:17:28.072]                               next
[13:17:28.072]                             invokeRestart(restart)
[13:17:28.072]                             muffled <- TRUE
[13:17:28.072]                             break
[13:17:28.072]                           }
[13:17:28.072]                         }
[13:17:28.072]                       }
[13:17:28.072]                       invisible(muffled)
[13:17:28.072]                     }
[13:17:28.072]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.072]                   }
[13:17:28.072]                 }
[13:17:28.072]                 else {
[13:17:28.072]                   if (TRUE) {
[13:17:28.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:17:28.072]                     {
[13:17:28.072]                       inherits <- base::inherits
[13:17:28.072]                       invokeRestart <- base::invokeRestart
[13:17:28.072]                       is.null <- base::is.null
[13:17:28.072]                       muffled <- FALSE
[13:17:28.072]                       if (inherits(cond, "message")) {
[13:17:28.072]                         muffled <- grepl(pattern, "muffleMessage")
[13:17:28.072]                         if (muffled) 
[13:17:28.072]                           invokeRestart("muffleMessage")
[13:17:28.072]                       }
[13:17:28.072]                       else if (inherits(cond, "warning")) {
[13:17:28.072]                         muffled <- grepl(pattern, "muffleWarning")
[13:17:28.072]                         if (muffled) 
[13:17:28.072]                           invokeRestart("muffleWarning")
[13:17:28.072]                       }
[13:17:28.072]                       else if (inherits(cond, "condition")) {
[13:17:28.072]                         if (!is.null(pattern)) {
[13:17:28.072]                           computeRestarts <- base::computeRestarts
[13:17:28.072]                           grepl <- base::grepl
[13:17:28.072]                           restarts <- computeRestarts(cond)
[13:17:28.072]                           for (restart in restarts) {
[13:17:28.072]                             name <- restart$name
[13:17:28.072]                             if (is.null(name)) 
[13:17:28.072]                               next
[13:17:28.072]                             if (!grepl(pattern, name)) 
[13:17:28.072]                               next
[13:17:28.072]                             invokeRestart(restart)
[13:17:28.072]                             muffled <- TRUE
[13:17:28.072]                             break
[13:17:28.072]                           }
[13:17:28.072]                         }
[13:17:28.072]                       }
[13:17:28.072]                       invisible(muffled)
[13:17:28.072]                     }
[13:17:28.072]                     muffleCondition(cond, pattern = "^muffle")
[13:17:28.072]                   }
[13:17:28.072]                 }
[13:17:28.072]             }
[13:17:28.072]         }))
[13:17:28.072]     }, error = function(ex) {
[13:17:28.072]         base::structure(base::list(value = NULL, visible = NULL, 
[13:17:28.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:17:28.072]                 ...future.rng), started = ...future.startTime, 
[13:17:28.072]             finished = Sys.time(), session_uuid = NA_character_, 
[13:17:28.072]             version = "1.8"), class = "FutureResult")
[13:17:28.072]     }, finally = {
[13:17:28.072]         if (!identical(...future.workdir, getwd())) 
[13:17:28.072]             setwd(...future.workdir)
[13:17:28.072]         {
[13:17:28.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:17:28.072]                 ...future.oldOptions$nwarnings <- NULL
[13:17:28.072]             }
[13:17:28.072]             base::options(...future.oldOptions)
[13:17:28.072]             if (.Platform$OS.type == "windows") {
[13:17:28.072]                 old_names <- names(...future.oldEnvVars)
[13:17:28.072]                 envs <- base::Sys.getenv()
[13:17:28.072]                 names <- names(envs)
[13:17:28.072]                 common <- intersect(names, old_names)
[13:17:28.072]                 added <- setdiff(names, old_names)
[13:17:28.072]                 removed <- setdiff(old_names, names)
[13:17:28.072]                 changed <- common[...future.oldEnvVars[common] != 
[13:17:28.072]                   envs[common]]
[13:17:28.072]                 NAMES <- toupper(changed)
[13:17:28.072]                 args <- list()
[13:17:28.072]                 for (kk in seq_along(NAMES)) {
[13:17:28.072]                   name <- changed[[kk]]
[13:17:28.072]                   NAME <- NAMES[[kk]]
[13:17:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.072]                     next
[13:17:28.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.072]                 }
[13:17:28.072]                 NAMES <- toupper(added)
[13:17:28.072]                 for (kk in seq_along(NAMES)) {
[13:17:28.072]                   name <- added[[kk]]
[13:17:28.072]                   NAME <- NAMES[[kk]]
[13:17:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.072]                     next
[13:17:28.072]                   args[[name]] <- ""
[13:17:28.072]                 }
[13:17:28.072]                 NAMES <- toupper(removed)
[13:17:28.072]                 for (kk in seq_along(NAMES)) {
[13:17:28.072]                   name <- removed[[kk]]
[13:17:28.072]                   NAME <- NAMES[[kk]]
[13:17:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[13:17:28.072]                     next
[13:17:28.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:17:28.072]                 }
[13:17:28.072]                 if (length(args) > 0) 
[13:17:28.072]                   base::do.call(base::Sys.setenv, args = args)
[13:17:28.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:17:28.072]             }
[13:17:28.072]             else {
[13:17:28.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:17:28.072]             }
[13:17:28.072]             {
[13:17:28.072]                 if (base::length(...future.futureOptionsAdded) > 
[13:17:28.072]                   0L) {
[13:17:28.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:17:28.072]                   base::names(opts) <- ...future.futureOptionsAdded
[13:17:28.072]                   base::options(opts)
[13:17:28.072]                 }
[13:17:28.072]                 {
[13:17:28.072]                   {
[13:17:28.072]                     base::options(mc.cores = ...future.mc.cores.old)
[13:17:28.072]                     NULL
[13:17:28.072]                   }
[13:17:28.072]                   options(future.plan = NULL)
[13:17:28.072]                   if (is.na(NA_character_)) 
[13:17:28.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:17:28.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:17:28.072]                   future::plan(list(function (..., workers = availableCores(), 
[13:17:28.072]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:17:28.072]                     envir = parent.frame()) 
[13:17:28.072]                   {
[13:17:28.072]                     if (is.function(workers)) 
[13:17:28.072]                       workers <- workers()
[13:17:28.072]                     workers <- structure(as.integer(workers), 
[13:17:28.072]                       class = class(workers))
[13:17:28.072]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:17:28.072]                       workers >= 1)
[13:17:28.072]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:17:28.072]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:17:28.072]                     }
[13:17:28.072]                     future <- MultisessionFuture(..., workers = workers, 
[13:17:28.072]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:17:28.072]                       envir = envir)
[13:17:28.072]                     if (!future$lazy) 
[13:17:28.072]                       future <- run(future)
[13:17:28.072]                     invisible(future)
[13:17:28.072]                   }), .cleanup = FALSE, .init = FALSE)
[13:17:28.072]                 }
[13:17:28.072]             }
[13:17:28.072]         }
[13:17:28.072]     })
[13:17:28.072]     if (TRUE) {
[13:17:28.072]         base::sink(type = "output", split = FALSE)
[13:17:28.072]         if (TRUE) {
[13:17:28.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:17:28.072]         }
[13:17:28.072]         else {
[13:17:28.072]             ...future.result["stdout"] <- base::list(NULL)
[13:17:28.072]         }
[13:17:28.072]         base::close(...future.stdout)
[13:17:28.072]         ...future.stdout <- NULL
[13:17:28.072]     }
[13:17:28.072]     ...future.result$conditions <- ...future.conditions
[13:17:28.072]     ...future.result$finished <- base::Sys.time()
[13:17:28.072]     ...future.result
[13:17:28.072] }
[13:17:28.075] Exporting 5 global objects (35.58 KiB) to cluster node #2 ...
[13:17:28.076] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:17:28.076] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:17:28.076] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[13:17:28.117] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[13:17:28.117] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:17:28.118] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:17:28.118] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[13:17:28.118] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[13:17:28.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:17:28.119] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:17:28.119] Exporting 5 global objects (35.58 KiB) to cluster node #2 ... DONE
[13:17:28.120] MultisessionFuture started
[13:17:28.120] - Launch lazy future ... done
[13:17:28.120] run() for ‘MultisessionFuture’ ... done
[13:17:28.120] Created future:
[13:17:28.120] MultisessionFuture:
[13:17:28.120] Label: ‘future_apply-2’
[13:17:28.120] Expression:
[13:17:28.120] {
[13:17:28.120]     do.call(function(...) {
[13:17:28.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:17:28.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:17:28.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:17:28.120]             on.exit(options(oopts), add = TRUE)
[13:17:28.120]         }
[13:17:28.120]         {
[13:17:28.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:17:28.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:17:28.120]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[13:17:28.120]                   envir = globalenv(), inherits = FALSE)
[13:17:28.120]                 ...future.FUN(...future.X_jj, ...)
[13:17:28.120]             })
[13:17:28.120]         }
[13:17:28.120]     }, args = future.call.arguments)
[13:17:28.120] }
[13:17:28.120] Lazy evaluation: FALSE
[13:17:28.120] Asynchronous evaluation: TRUE
[13:17:28.120] Local evaluation: TRUE
[13:17:28.120] Environment: R_GlobalEnv
[13:17:28.120] Capture standard output: TRUE
[13:17:28.120] Capture condition classes: <none>
[13:17:28.120] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:17:28.120] Packages: <none>
[13:17:28.120] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[13:17:28.120] Resolved: FALSE
[13:17:28.120] Value: <not collected>
[13:17:28.120] Conditions captured: <none>
[13:17:28.120] Early signaling: FALSE
[13:17:28.120] Owner process: d3ef3930-d788-c1a9-9f8c-3cd61c3a104b
[13:17:28.120] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:17:28.132] Chunk #2 of 2 ... DONE
[13:17:28.132] Launching 2 futures (chunks) ... DONE
[13:17:28.132] Resolving 2 futures (chunks) ...
[13:17:28.132] resolve() on list ...
[13:17:28.132]  recursive: 0
[13:17:28.132]  length: 2
[13:17:28.133] 
[13:17:28.133] receiveMessageFromWorker() for ClusterFuture ...
[13:17:28.133] - Validating connection of MultisessionFuture
[13:17:28.133] - received message: FutureResult
[13:17:28.133] - Received FutureResult
[13:17:28.134] - Erased future from FutureRegistry
[13:17:28.134] result() for ClusterFuture ...
[13:17:28.134] - result already collected: FutureResult
[13:17:28.134] result() for ClusterFuture ... done
[13:17:28.134] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:28.134] Future #1
[13:17:28.134] result() for ClusterFuture ...
[13:17:28.134] - result already collected: FutureResult
[13:17:28.134] result() for ClusterFuture ... done
[13:17:28.134] result() for ClusterFuture ...
[13:17:28.134] - result already collected: FutureResult
[13:17:28.135] result() for ClusterFuture ... done
[13:17:28.135] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:17:28.135] - nx: 2
[13:17:28.135] - relay: TRUE
[13:17:28.135] - stdout: TRUE
[13:17:28.137] - signal: TRUE
[13:17:28.138] - resignal: FALSE
[13:17:28.138] - force: TRUE
[13:17:28.138] - relayed: [n=2] FALSE, FALSE
[13:17:28.138] - queued futures: [n=2] FALSE, FALSE
[13:17:28.138]  - until=1
[13:17:28.138]  - relaying element #1
[13:17:28.138] result() for ClusterFuture ...
[13:17:28.138] - result already collected: FutureResult
[13:17:28.138] result() for ClusterFuture ... done
[13:17:28.138] result() for ClusterFuture ...
[13:17:28.138] - result already collected: FutureResult
[13:17:28.138] result() for ClusterFuture ... done
[13:17:28.139] result() for ClusterFuture ...
[13:17:28.139] - result already collected: FutureResult
[13:17:28.139] result() for ClusterFuture ... done
[13:17:28.139] result() for ClusterFuture ...
[13:17:28.139] - result already collected: FutureResult
[13:17:28.139] result() for ClusterFuture ... done
[13:17:28.139] - relayed: [n=2] TRUE, FALSE
[13:17:28.139] - queued futures: [n=2] TRUE, FALSE
[13:17:28.139] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:17:28.139]  length: 1 (resolved future 1)
[13:17:28.168] receiveMessageFromWorker() for ClusterFuture ...
[13:17:28.168] - Validating connection of MultisessionFuture
[13:17:28.168] - received message: FutureResult
[13:17:28.168] - Received FutureResult
[13:17:28.168] - Erased future from FutureRegistry
[13:17:28.168] result() for ClusterFuture ...
[13:17:28.169] - result already collected: FutureResult
[13:17:28.169] result() for ClusterFuture ... done
[13:17:28.169] receiveMessageFromWorker() for ClusterFuture ... done
[13:17:28.169] Future #2
[13:17:28.169] result() for ClusterFuture ...
[13:17:28.169] - result already collected: FutureResult
[13:17:28.169] result() for ClusterFuture ... done
[13:17:28.169] result() for ClusterFuture ...
[13:17:28.169] - result already collected: FutureResult
[13:17:28.169] result() for ClusterFuture ... done
[13:17:28.170] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:17:28.170] - nx: 2
[13:17:28.170] - relay: TRUE
[13:17:28.170] - stdout: TRUE
[13:17:28.170] - signal: TRUE
[13:17:28.170] - resignal: FALSE
[13:17:28.170] - force: TRUE
[13:17:28.170] - relayed: [n=2] TRUE, FALSE
[13:17:28.170] - queued futures: [n=2] TRUE, FALSE
[13:17:28.170]  - until=2
[13:17:28.170]  - relaying element #2
[13:17:28.171] result() for ClusterFuture ...
[13:17:28.171] - result already collected: FutureResult
[13:17:28.171] result() for ClusterFuture ... done
[13:17:28.171] result() for ClusterFuture ...
[13:17:28.171] - result already collected: FutureResult
[13:17:28.171] result() for ClusterFuture ... done
[13:17:28.171] result() for ClusterFuture ...
[13:17:28.171] - result already collected: FutureResult
[13:17:28.171] result() for ClusterFuture ... done
[13:17:28.171] result() for ClusterFuture ...
[13:17:28.171] - result already collected: FutureResult
[13:17:28.172] result() for ClusterFuture ... done
[13:17:28.172] - relayed: [n=2] TRUE, TRUE
[13:17:28.172] - queued futures: [n=2] TRUE, TRUE
[13:17:28.172] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:17:28.172]  length: 0 (resolved future 2)
[13:17:28.172] Relaying remaining futures
[13:17:28.172] signalConditionsASAP(NULL, pos=0) ...
[13:17:28.172] - nx: 2
[13:17:28.172] - relay: TRUE
[13:17:28.172] - stdout: TRUE
[13:17:28.172] - signal: TRUE
[13:17:28.173] - resignal: FALSE
[13:17:28.173] - force: TRUE
[13:17:28.173] - relayed: [n=2] TRUE, TRUE
[13:17:28.173] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:17:28.173] - relayed: [n=2] TRUE, TRUE
[13:17:28.173] - queued futures: [n=2] TRUE, TRUE
[13:17:28.173] signalConditionsASAP(NULL, pos=0) ... done
[13:17:28.173] resolve() on list ... DONE
[13:17:28.173] result() for ClusterFuture ...
[13:17:28.173] - result already collected: FutureResult
[13:17:28.173] result() for ClusterFuture ... done
[13:17:28.174] result() for ClusterFuture ...
[13:17:28.174] - result already collected: FutureResult
[13:17:28.174] result() for ClusterFuture ... done
[13:17:28.174] result() for ClusterFuture ...
[13:17:28.174] - result already collected: FutureResult
[13:17:28.174] result() for ClusterFuture ... done
[13:17:28.174] result() for ClusterFuture ...
[13:17:28.174] - result already collected: FutureResult
[13:17:28.174] result() for ClusterFuture ... done
[13:17:28.175]  - Number of value chunks collected: 2
[13:17:28.175] Resolving 2 futures (chunks) ... DONE
[13:17:28.175] Reducing values from 2 chunks ...
[13:17:28.175]  - Number of values collected after concatenation: 2
[13:17:28.175]  - Number of values expected: 2
[13:17:28.175] Reducing values from 2 chunks ... DONE
[13:17:28.175] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[13:17:28.175] plan(): Setting new future strategy stack:
[13:17:28.175] List of future strategies:
[13:17:28.175] 1. sequential:
[13:17:28.175]    - args: function (..., envir = parent.frame())
[13:17:28.175]    - tweaked: FALSE
[13:17:28.175]    - call: plan(sequential)
[13:17:28.176] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[13:17:28.178] plan(): Setting new future strategy stack:
[13:17:28.179] List of future strategies:
[13:17:28.179] 1. FutureStrategy:
[13:17:28.179]    - args: function (..., envir = parent.frame())
[13:17:28.179]    - tweaked: FALSE
[13:17:28.179]    - call: future::plan(oplan)
[13:17:28.179] plan(): nbrOfWorkers() = 1
> 
